## gas optimization ### G01: COMPARISONS WITH ZERO FOR UNSIGNED INTEGERS #### problem 0 is less gas efficient than !0 if you enable the optimizer at 10k AND you’re in a require statement. Detailed explanation with the opcodes https://twitter.com/gzeon/status/1485428085885640706 #### prof policies/Governance.sol, 247, b'        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\r'  ### G02: PREFIX INCREMENT SAVE MORE GAS #### problem prefix increment ++i is more cheaper than postfix i++ #### prof policies/Operator.sol, 488, b'            decimals++;\r' policies/Operator.sol, 675, b'                _status.low.count--;\r' policies/Operator.sol, 670, b'                _status.low.count++;\r' policies/Operator.sol, 691, b'                _status.high.count--;\r' policies/Operator.sol, 686, b'                _status.high.count++;\r'   ### G03: X += Y COSTS MORE GAS THAN X = X + Y FOR STATE VARIABLES #### prof policies/BondCallback.sol, 143, b'        _amountsPerMarket[id_][0] += inputAmount_;\r' policies/BondCallback.sol, 144, b'        _amountsPerMarket[id_][1] += outputAmount_;\r' policies/Governance.sol, 194, b'        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\r' policies/Governance.sol, 198, b'        totalEndorsementsForProposal[proposalId_] += userVotes;\r' policies/Governance.sol, 254, b'            noVotesForProposal[activeProposal.proposalId] += userVotes;\r' policies/Governance.sol, 252, b'            yesVotesForProposal[activeProposal.proposalId] += userVotes;\r' policies/Heart.sol, 103, b'        lastBeat += frequency();\r' modules/PRICE.sol, 138, b'            _movingAverage -= (earliestPrice - currentPrice) / numObs;' modules/PRICE.sol, 136, b'            _movingAverage += (currentPrice - earliestPrice) / numObs;' modules/TRSRY.sol, 96, b'        reserveDebt[token_][msg.sender] += amount_;\r' modules/TRSRY.sol, 97, b'        totalDebt[token_] += amount_;\r' modules/TRSRY.sol, 115, b'        reserveDebt[token_][msg.sender] -= received;\r' modules/TRSRY.sol, 116, b'        totalDebt[token_] -= received;\r' modules/TRSRY.sol, 132, b'        else totalDebt[token_] -= oldDebt - amount_;\r' modules/TRSRY.sol, 131, b'        if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;\r'  ### G04: USING BOOLS FOR STORAGE INCURS OVERHEAD #### problem // Booleans are more expensive than uint256 or any type that takes up a full // word because each write operation emits an extra SLOAD to first read the // slot's contents, replace the bits taken up by the boolean, and then write // back. This is the compiler's defense against contract upgrades and // pointer aliasing, and it cannot be disabled. #### prof policies/Governance.sol, 105, b'    mapping(uint256 => bool) public proposalHasBeenActivated;\r' policies/Governance.sol, 117, b'    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;\r' Kernel.sol, 181, b'    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\r' Kernel.sol, 194, b'    mapping(address => mapping(Role => bool)) public hasRole;\r' Kernel.sol, 197, b'    mapping(Role => bool) public isRole;\r'  ### G05: resign the default value to the variables. #### problem  resign the default value to the variables will cost more gas. #### prof Kernel.sol, 397, b'        for (uint256 i = 0; i < reqLength; ) {\r'  ## G06: ++I/I++ SHOULD BE UNCHECKED{++I}/UNCHECKED{I++} WHEN IT IS NOT POSSIBLE FOR THEM TO OVERFLOW, AS IS THE CASE WHEN USED IN FOR- AND WHILE-LOOPS #### problem The unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas per loop #### prof modules/INSTR.sol, 44, b'        uint256 instructionsId = ++totalInstructions;\r' policies/Operator.sol, 488, b'            decimals++;\r' policies/Operator.sol, 675, b'                _status.low.count--;\r' policies/Operator.sol, 670, b'                _status.low.count++;\r' policies/Operator.sol, 691, b'                _status.high.count--;\r' policies/Operator.sol, 686, b'                _status.high.count++;\r'   ### G07: FUNCTIONS GUARANTEED TO REVERT WHEN CALLED BY NORMAL USERS CAN BE MARKED PAYABLE #### problem If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost #### prof policies/Heart.sol, 132, b'    function resetBeat() external onlyRole("heart_admin") ' policies/Heart.sol, 132, b'    function resetBeat() external onlyRole("heart_admin") ' policies/Heart.sol, 137, b'    function toggleBeat() external onlyRole("heart_admin") ' policies/Heart.sol, 137, b'    function toggleBeat() external onlyRole("heart_admin") ' policies/Heart.sol, 147, b'    function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\r\n        external\r\n        onlyRole("heart_admin")\r\n    ' policies/Heart.sol, 152, b'    function withdrawUnspentRewards(ERC20 token_) external onlyRole("heart_admin") ' policies/Heart.sol, 152, b'    function withdrawUnspentRewards(ERC20 token_) external onlyRole("heart_admin") ' Kernel.sol, 260, b'    function executeAction(Actions action_, address target_) external onlyExecutor ' Kernel.sol, 448, b'    function grantRole(Role role_, address addr_) public onlyAdmin ' Kernel.sol, 448, b'    function grantRole(Role role_, address addr_) public onlyAdmin ' Kernel.sol, 458, b'    function revokeRole(Role role_, address addr_) public onlyAdmin ' Kernel.sol, 458, b'    function revokeRole(Role role_, address addr_) public onlyAdmin ' policies/Operator.sol, 595, b'    function setBondContracts(IBondAuctioneer auctioneer_, IBondCallback callback_)\r\n        external\r\n        onlyRole("operator_admin")\r\n    ' policies/Operator.sol, 615, b'    function initialize() external onlyRole("operator_admin") ' policies/Operator.sol, 615, b'    function initialize() external onlyRole("operator_admin") ' policies/Operator.sol, 621, b'    function regenerate(bool high_) external onlyRole("operator_admin") ' policies/Operator.sol, 621, b'    function regenerate(bool high_) external onlyRole("operator_admin") ' policies/Operator.sol, 627, b'    function toggleActive() external onlyRole("operator_admin") ' policies/Operator.sol, 627, b'    function toggleActive() external onlyRole("operator_admin") ' policies/PriceConfig.sol, 50, b'    function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_)\r\n        external\r\n        onlyRole("price_admin")\r\n    ' policies/PriceConfig.sol, 63, b'    function changeMovingAverageDuration(uint48 movingAverageDuration_)\r\n        external\r\n        onlyRole("price_admin")\r\n    ' policies/PriceConfig.sol, 74, b'    function changeObservationFrequency(uint48 observationFrequency_)\r\n        external\r\n        onlyRole("price_admin")\r\n    ' policies/VoterRegistration.sol, 48, b'    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole("voter_admin") ' policies/VoterRegistration.sol, 48, b'    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole("voter_admin") ' policies/VoterRegistration.sol, 56, b'    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole("voter_admin") ' policies/VoterRegistration.sol, 56, b'    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole("voter_admin") '   ### G08: USING PRIVATE RATHER THAN PUBLIC FOR CONSTANTS, SAVES GAS #### problem: We can save getter function of public constants. #### prof: policies/Governance.sol, 121, b'    uint256 public constant SUBMISSION_REQUIREMENT = 100;\r' policies/Governance.sol, 124, b'    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\r' policies/Governance.sol, 127, b'    uint256 public constant GRACE_PERIOD = 1 weeks;\r' policies/Governance.sol, 130, b'    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\r' policies/Governance.sol, 133, b'    uint256 public constant EXECUTION_THRESHOLD = 33;\r' policies/Governance.sol, 137, b'    uint256 public constant EXECUTION_TIMELOCK = 3 days;\r' modules/MINTR.sol, 9, b'    OHM public immutable ohm;\r' policies/Operator.sol, 82, b'    ERC20 public immutable ohm;\r' policies/Operator.sol, 83, b'    uint8 public immutable ohmDecimals;\r' policies/Operator.sol, 85, b'    ERC20 public immutable reserve;\r' policies/Operator.sol, 86, b'    uint8 public immutable reserveDecimals;\r' policies/Operator.sol, 89, b'    uint32 public constant FACTOR_SCALE = 1e4;\r' modules/PRICE.sol, 59, b'    uint8 public constant decimals = 18;' modules/RANGE.sol, 65, b'    uint256 public constant FACTOR_SCALE = 1e4;\r' modules/RANGE.sol, 68, b'    ERC20 public immutable ohm;\r' modules/RANGE.sol, 71, b'    ERC20 public immutable reserve;\r'   ### G09: USAGE OF UINTS/INTS SMALLER THAN 32 BYTES (256 BITS) INCURS OVERHEAD #### problem When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. #### prof policies/Governance.sol, 164, b'        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)\r' policies/Governance.sol, 183, b'        if (proposalId_ == 0) {\r' policies/Governance.sol, 188, b'        if (instructions.length == 0) {\r' policies/Governance.sol, 243, b'        if (activeProposal.proposalId == 0) {\r' policies/Governance.sol, 247, b'        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\r' policies/Governance.sol, 268, b'        if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {\r' policies/Governance.sol, 298, b'        if (userVotes == 0) {\r' policies/Heart.sol, 122, b'        return uint256(PRICE.observationFrequency());\r' policies/Heart.sol, 122, b'        return uint256(PRICE.observationFrequency());\r' modules/INSTR.sol, 29, b'        return (1, 0);\r' modules/INSTR.sol, 48, b'        if (length == 0) revert INSTR_InstructionsCannotBeEmpty();\r' modules/INSTR.sol, 61, b'            } else if (instruction.action == Actions.ChangeExecutor && i != length - 1) {\r' modules/INSTR.sol, 70, b'            instructions.push(instructions_[i]);\r' modules/INSTR.sol, 70, b'            instructions.push(instructions_[i]);\r' Kernel.sol, 133, b'        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\r' Kernel.sol, 269, b'        if (address(getModuleForKeycode[keycode]) != address(0))\r' Kernel.sol, 274, b'        allKeycodes.push(keycode);\r' Kernel.sol, 283, b'        if (address(oldModule) == address(0) || oldModule == newModule_)\r' Kernel.sol, 299, b'        activePolicies.push(policy_);\r' Kernel.sol, 309, b'            moduleDependents[keycode].push(policy_);\r' Kernel.sol, 337, b'        activePolicies.pop();\r' Kernel.sol, 397, b'        for (uint256 i = 0; i < reqLength; ) {\r' Kernel.sol, 422, b'            dependents.pop();\r' Kernel.sol, 422, b'            dependents.pop();\r' modules/MINTR.sol, 26, b'        return (1, 0);\r' policies/Operator.sol, 72, b'    OlympusMinter internal MINTR;\r' policies/Operator.sol, 83, b'    uint8 public immutable ohmDecimals;\r' policies/Operator.sol, 86, b'    uint8 public immutable reserveDecimals;\r' policies/Operator.sol, 89, b'    uint32 public constant FACTOR_SCALE = 1e4;\r' policies/Operator.sol, 164, b'        MINTR = OlympusMinter(getModuleAddress(dependencies[3]));\r' policies/Operator.sol, 167, b'        ohm.safeApprove(address(MINTR), type(uint256).max);\r' policies/Operator.sol, 174, b'        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\r' policies/Operator.sol, 202, b'        _updateCapacity(true, 0);\r' policies/Operator.sol, 203, b'        _updateCapacity(false, 0);\r' policies/Operator.sol, 210, b'            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\r' policies/Operator.sol, 210, b'            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\r' policies/Operator.sol, 210, b'            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\r' policies/Operator.sol, 210, b'            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\r' policies/Operator.sol, 210, b'            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\r' policies/Operator.sol, 211, b'            _status.high.count >= config_.regenThreshold\r' policies/Operator.sol, 211, b'            _status.high.count >= config_.regenThreshold\r' policies/Operator.sol, 216, b'            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\r' policies/Operator.sol, 216, b'            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\r' policies/Operator.sol, 216, b'            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\r' policies/Operator.sol, 216, b'            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\r' policies/Operator.sol, 216, b'            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\r' policies/Operator.sol, 217, b'            _status.low.count >= config_.regenThreshold\r' policies/Operator.sol, 217, b'            _status.low.count >= config_.regenThreshold\r' policies/Operator.sol, 333, b'            MINTR.mintOhm(msg.sender, amountOut);\r' policies/Operator.sol, 302, b'            MINTR.burnOhm(address(this), amountIn_);\r' policies/Operator.sol, 418, b'            uint8 oracleDecimals = PRICE.decimals();\r' policies/Operator.sol, 418, b'            uint8 oracleDecimals = PRICE.decimals();\r' policies/Operator.sol, 418, b'            uint8 oracleDecimals = PRICE.decimals();\r' policies/Operator.sol, 419, b'            uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;\r' policies/Operator.sol, 419, b'            uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;\r' policies/Operator.sol, 420, b'            uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;\r' policies/Operator.sol, 420, b'            uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;\r' policies/Operator.sol, 426, b'            int8 priceDecimals = _getPriceDecimals(invCushionPrice);\r' policies/Operator.sol, 426, b'            int8 priceDecimals = _getPriceDecimals(invCushionPrice);\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 427, b'            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\r' policies/Operator.sol, 430, b'            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\r' policies/Operator.sol, 431, b'            uint256 bondScale = 10 **\r' policies/Operator.sol, 434, b'                uint8(\r\n                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r\n                );\r' policies/Operator.sol, 432, b'                uint8(\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 433, b'                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\r' policies/Operator.sol, 443, b'            uint256 marketCapacity = range.low.capacity.mulDiv(config_.cushionFactor, FACTOR_SCALE);\r' policies/Operator.sol, 443, b'            uint256 marketCapacity = range.low.capacity.mulDiv(config_.cushionFactor, FACTOR_SCALE);\r' policies/Operator.sol, 446, b'            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\r' policies/Operator.sol, 454, b'                debtBuffer: config_.cushionDebtBuffer,\r' policies/Operator.sol, 455, b'                vesting: uint48(0), // Instant swaps\r' policies/Operator.sol, 455, b'                vesting: uint48(0), // Instant swaps\r' policies/Operator.sol, 455, b'                vesting: uint48(0), // Instant swaps\r' policies/Operator.sol, 456, b'                conclusion: uint48(block.timestamp + config_.cushionDuration),\r' policies/Operator.sol, 456, b'                conclusion: uint48(block.timestamp + config_.cushionDuration),\r' policies/Operator.sol, 456, b'                conclusion: uint48(block.timestamp + config_.cushionDuration),\r' policies/Operator.sol, 457, b'                depositInterval: config_.cushionDepositInterval,\r' policies/Operator.sol, 458, b'                scaleAdjustment: scaleAdjustment\r' policies/Operator.sol, 371, b'            int8 priceDecimals = _getPriceDecimals(range.cushion.high.price);\r' policies/Operator.sol, 371, b'            int8 priceDecimals = _getPriceDecimals(range.cushion.high.price);\r' policies/Operator.sol, 372, b'            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 372, b'            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 372, b'            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 372, b'            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 372, b'            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 372, b'            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 372, b'            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 372, b'            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 372, b'            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 372, b'            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\r' policies/Operator.sol, 375, b'            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\r' policies/Operator.sol, 375, b'            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\r' policies/Operator.sol, 375, b'            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\r' policies/Operator.sol, 375, b'            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\r' policies/Operator.sol, 375, b'            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\r' policies/Operator.sol, 375, b'            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\r' policies/Operator.sol, 375, b'            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\r' policies/Operator.sol, 375, b'            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\r' policies/Operator.sol, 375, b'            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\r' policies/Operator.sol, 376, b'            uint256 bondScale = 10 **\r' policies/Operator.sol, 379, b'                uint8(\r\n                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r\n                );\r' policies/Operator.sol, 377, b'                uint8(\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 378, b'                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\r' policies/Operator.sol, 389, b'                config_.cushionFactor,\r' policies/Operator.sol, 390, b'                FACTOR_SCALE\r' policies/Operator.sol, 394, b'            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\r' policies/Operator.sol, 402, b'                debtBuffer: config_.cushionDebtBuffer,\r' policies/Operator.sol, 403, b'                vesting: uint48(0), // Instant swaps\r' policies/Operator.sol, 403, b'                vesting: uint48(0), // Instant swaps\r' policies/Operator.sol, 403, b'                vesting: uint48(0), // Instant swaps\r' policies/Operator.sol, 404, b'                conclusion: uint48(block.timestamp + config_.cushionDuration),\r' policies/Operator.sol, 404, b'                conclusion: uint48(block.timestamp + config_.cushionDuration),\r' policies/Operator.sol, 404, b'                conclusion: uint48(block.timestamp + config_.cushionDuration),\r' policies/Operator.sol, 405, b'                depositInterval: config_.cushionDepositInterval,\r' policies/Operator.sol, 406, b'                scaleAdjustment: scaleAdjustment\r' policies/Operator.sol, 477, b'            RANGE.updateMarket(high_, type(uint256).max, 0);\r' policies/Operator.sol, 485, b'        int8 decimals;\r' policies/Operator.sol, 486, b'        while (price_ >= 10) {\r' policies/Operator.sol, 488, b'            decimals++;\r' policies/Operator.sol, 493, b'        return decimals - int8(PRICE.decimals());\r' policies/Operator.sol, 493, b'        return decimals - int8(PRICE.decimals());\r' policies/Operator.sol, 493, b'        return decimals - int8(PRICE.decimals());\r' policies/Operator.sol, 493, b'        return decimals - int8(PRICE.decimals());\r' policies/Operator.sol, 493, b'        return decimals - int8(PRICE.decimals());\r' policies/Operator.sol, 493, b'        return decimals - int8(PRICE.decimals());\r' policies/Operator.sol, 518, b'        if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\r' policies/Operator.sol, 518, b'        if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\r' policies/Operator.sol, 518, b'        if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\r' policies/Operator.sol, 518, b'        if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\r' policies/Operator.sol, 521, b'        _config.cushionFactor = cushionFactor_;\r' policies/Operator.sol, 533, b'        if (duration_ > uint256(7 days) || duration_ < uint256(1 days))\r' policies/Operator.sol, 533, b'        if (duration_ > uint256(7 days) || duration_ < uint256(1 days))\r' policies/Operator.sol, 533, b'        if (duration_ > uint256(7 days) || duration_ < uint256(1 days))\r' policies/Operator.sol, 533, b'        if (duration_ > uint256(7 days) || duration_ < uint256(1 days))\r' policies/Operator.sol, 535, b'        if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams();\r' policies/Operator.sol, 535, b'        if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams();\r' policies/Operator.sol, 535, b'        if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams();\r' policies/Operator.sol, 535, b'        if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams();\r' policies/Operator.sol, 536, b'        if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)\r' policies/Operator.sol, 536, b'        if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)\r' policies/Operator.sol, 536, b'        if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)\r' policies/Operator.sol, 536, b'        if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)\r' policies/Operator.sol, 536, b'        if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)\r' policies/Operator.sol, 536, b'        if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)\r' policies/Operator.sol, 540, b'        _config.cushionDuration = duration_;\r' policies/Operator.sol, 541, b'        _config.cushionDebtBuffer = debtBuffer_;\r' policies/Operator.sol, 542, b'        _config.cushionDepositInterval = depositInterval_;\r' policies/Operator.sol, 550, b'        if (reserveFactor_ > 10000 || reserveFactor_ < 100) revert Operator_InvalidParams();\r' policies/Operator.sol, 550, b'        if (reserveFactor_ > 10000 || reserveFactor_ < 100) revert Operator_InvalidParams();\r' policies/Operator.sol, 550, b'        if (reserveFactor_ > 10000 || reserveFactor_ < 100) revert Operator_InvalidParams();\r' policies/Operator.sol, 550, b'        if (reserveFactor_ > 10000 || reserveFactor_ < 100) revert Operator_InvalidParams();\r' policies/Operator.sol, 553, b'        _config.reserveFactor = reserveFactor_;\r' policies/Operator.sol, 565, b'        if (wait_ < 1 hours || threshold_ > observe_ || observe_ == 0)\r' policies/Operator.sol, 565, b'        if (wait_ < 1 hours || threshold_ > observe_ || observe_ == 0)\r' policies/Operator.sol, 565, b'        if (wait_ < 1 hours || threshold_ > observe_ || observe_ == 0)\r' policies/Operator.sol, 565, b'        if (wait_ < 1 hours || threshold_ > observe_ || observe_ == 0)\r' policies/Operator.sol, 565, b'        if (wait_ < 1 hours || threshold_ > observe_ || observe_ == 0)\r' policies/Operator.sol, 565, b'        if (wait_ < 1 hours || threshold_ > observe_ || observe_ == 0)\r' policies/Operator.sol, 569, b'        _config.regenWait = wait_;\r' policies/Operator.sol, 570, b'        _config.regenThreshold = threshold_;\r' policies/Operator.sol, 571, b'        _config.regenObserve = observe_;\r' policies/Operator.sol, 574, b'        _status.high.count = 0;\r' policies/Operator.sol, 575, b'        _status.high.nextObservation = 0;\r' policies/Operator.sol, 578, b'        _status.low.count = 0;\r' policies/Operator.sol, 579, b'        _status.low.nextObservation = 0;\r' policies/Operator.sol, 590, b'        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\r' policies/Operator.sol, 590, b'        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\r' policies/Operator.sol, 665, b'        uint32 observe = _config.regenObserve;\r' policies/Operator.sol, 665, b'        uint32 observe = _config.regenObserve;\r' policies/Operator.sol, 675, b'                _status.low.count--;\r' policies/Operator.sol, 670, b'                _status.low.count++;\r' policies/Operator.sol, 678, b'        _status.low.nextObservation = (regen.nextObservation + 1) % observe;\r' policies/Operator.sol, 691, b'                _status.high.count--;\r' policies/Operator.sol, 686, b'                _status.high.count++;\r' policies/Operator.sol, 694, b'        _status.high.nextObservation = (regen.nextObservation + 1) % observe;\r' policies/Operator.sol, 717, b'            _status.low.count = uint32(0);\r' policies/Operator.sol, 719, b'            _status.low.nextObservation = uint32(0);\r' policies/Operator.sol, 720, b'            _status.low.lastRegen = uint48(block.timestamp);\r' policies/Operator.sol, 705, b'            _status.high.count = uint32(0);\r' policies/Operator.sol, 707, b'            _status.high.nextObservation = uint32(0);\r' policies/Operator.sol, 708, b'            _status.high.lastRegen = uint48(block.timestamp);\r' policies/Operator.sol, 764, b'                10**ohmDecimals * 10**PRICE.decimals(),\r' policies/Operator.sol, 764, b'                10**ohmDecimals * 10**PRICE.decimals(),\r' policies/Operator.sol, 764, b'                10**ohmDecimals * 10**PRICE.decimals(),\r' policies/Operator.sol, 764, b'                10**ohmDecimals * 10**PRICE.decimals(),\r' policies/Operator.sol, 764, b'                10**ohmDecimals * 10**PRICE.decimals(),\r' policies/Operator.sol, 765, b'                10**reserveDecimals * RANGE.price(true, true)\r' policies/Operator.sol, 765, b'                10**reserveDecimals * RANGE.price(true, true)\r' policies/Operator.sol, 753, b'                10**reserveDecimals * RANGE.price(true, false),\r' policies/Operator.sol, 753, b'                10**reserveDecimals * RANGE.price(true, false),\r' policies/Operator.sol, 754, b'                10**ohmDecimals * 10**PRICE.decimals()\r' policies/Operator.sol, 754, b'                10**ohmDecimals * 10**PRICE.decimals()\r' policies/Operator.sol, 754, b'                10**ohmDecimals * 10**PRICE.decimals()\r' policies/Operator.sol, 754, b'                10**ohmDecimals * 10**PRICE.decimals()\r' policies/Operator.sol, 754, b'                10**ohmDecimals * 10**PRICE.decimals()\r' policies/Operator.sol, 780, b'        uint256 capacity = (reservesInTreasury * _config.reserveFactor) / FACTOR_SCALE;\r' modules/PRICE.sol, 44, b'    uint32 public nextObsIndex;' modules/PRICE.sol, 47, b'    uint32 public numObservations;' modules/PRICE.sol, 50, b'    uint48 public observationFrequency;' modules/PRICE.sol, 53, b'    uint48 public movingAverageDuration;' modules/PRICE.sol, 56, b'    uint48 public lastObservationTime;' modules/PRICE.sol, 59, b'    uint8 public constant decimals = 18;' modules/PRICE.sol, 114, b'        return (1, 0);' modules/PRICE.sol, 127, b'        uint32 numObs = numObservations;' modules/PRICE.sol, 127, b'        uint32 numObs = numObservations;' modules/PRICE.sol, 143, b'        lastObservationTime = uint48(block.timestamp);' modules/PRICE.sol, 144, b'        nextObsIndex = (nextObsIndex + 1) % numObs;' modules/PRICE.sol, 165, b'            if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))' modules/PRICE.sol, 165, b'            if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))' modules/PRICE.sol, 171, b'            if (updatedAt < block.timestamp - uint256(observationFrequency))' modules/PRICE.sol, 185, b'        uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1;' modules/PRICE.sol, 185, b'        uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1;' modules/PRICE.sol, 185, b'        uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1;' modules/PRICE.sol, 185, b'        uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1;' modules/PRICE.sol, 215, b'        if (startObservations_.length != numObs || lastObservationTime_ > uint48(block.timestamp))' modules/PRICE.sol, 215, b'        if (startObservations_.length != numObs || lastObservationTime_ > uint48(block.timestamp))' modules/PRICE.sol, 215, b'        if (startObservations_.length != numObs || lastObservationTime_ > uint48(block.timestamp))' modules/PRICE.sol, 221, b'            if (startObservations_[i] == 0) revert Price_InvalidParams();' modules/PRICE.sol, 231, b'        lastObservationTime = lastObservationTime_;' modules/PRICE.sol, 242, b'        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency != 0)' modules/PRICE.sol, 242, b'        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency != 0)' modules/PRICE.sol, 242, b'        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency != 0)' modules/PRICE.sol, 242, b'        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency != 0)' modules/PRICE.sol, 242, b'        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency != 0)' modules/PRICE.sol, 242, b'        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency != 0)' modules/PRICE.sol, 246, b'        uint256 newObservations = uint256(movingAverageDuration_ / observationFrequency);' modules/PRICE.sol, 246, b'        uint256 newObservations = uint256(movingAverageDuration_ / observationFrequency);' modules/PRICE.sol, 246, b'        uint256 newObservations = uint256(movingAverageDuration_ / observationFrequency);' modules/PRICE.sol, 253, b'        lastObservationTime = 0;' modules/PRICE.sol, 255, b'        nextObsIndex = 0;' modules/PRICE.sol, 256, b'        movingAverageDuration = movingAverageDuration_;' modules/PRICE.sol, 257, b'        numObservations = uint32(newObservations);' modules/PRICE.sol, 268, b'        if (observationFrequency_ == 0 || movingAverageDuration % observationFrequency_ != 0)' modules/PRICE.sol, 268, b'        if (observationFrequency_ == 0 || movingAverageDuration % observationFrequency_ != 0)' modules/PRICE.sol, 268, b'        if (observationFrequency_ == 0 || movingAverageDuration % observationFrequency_ != 0)' modules/PRICE.sol, 268, b'        if (observationFrequency_ == 0 || movingAverageDuration % observationFrequency_ != 0)' modules/PRICE.sol, 268, b'        if (observationFrequency_ == 0 || movingAverageDuration % observationFrequency_ != 0)' modules/PRICE.sol, 268, b'        if (observationFrequency_ == 0 || movingAverageDuration % observationFrequency_ != 0)' modules/PRICE.sol, 272, b'        uint256 newObservations = uint256(movingAverageDuration / observationFrequency_);' modules/PRICE.sol, 272, b'        uint256 newObservations = uint256(movingAverageDuration / observationFrequency_);' modules/PRICE.sol, 272, b'        uint256 newObservations = uint256(movingAverageDuration / observationFrequency_);' modules/PRICE.sol, 285, b'        lastObservationTime = 0;' modules/PRICE.sol, 287, b'        nextObsIndex = 0;' modules/PRICE.sol, 288, b'        observationFrequency = observationFrequency_;' modules/PRICE.sol, 289, b'        numObservations = uint32(newObservations);' policies/PriceConfig.sol, 49, b'        PRICE.initialize(startObservations_, lastObservationTime_);\r' policies/PriceConfig.sol, 62, b'        PRICE.changeMovingAverageDuration(movingAverageDuration_);\r' policies/PriceConfig.sol, 62, b'        PRICE.changeMovingAverageDuration(movingAverageDuration_);\r' policies/PriceConfig.sol, 73, b'        PRICE.changeObservationFrequency(observationFrequency_);\r' policies/PriceConfig.sol, 73, b'        PRICE.changeObservationFrequency(observationFrequency_);\r' modules/RANGE.sol, 116, b'        return (1, 0);\r' modules/RANGE.sol, 148, b'                _range.low.lastActive = uint48(block.timestamp);\r' modules/RANGE.sol, 136, b'                _range.high.lastActive = uint48(block.timestamp);\r' modules/RANGE.sol, 221, b'        if (market_ == type(uint256).max && marketCapacity_ != 0) revert RANGE_InvalidParams();\r' modules/RANGE.sol, 245, b'            wallSpread_ > 10000 ||\r' modules/RANGE.sol, 246, b'            wallSpread_ < 100 ||\r' modules/RANGE.sol, 247, b'            cushionSpread_ > 10000 ||\r' modules/RANGE.sol, 248, b'            cushionSpread_ < 100 ||\r' modules/RANGE.sol, 264, b'        if (thresholdFactor_ > 10000 || thresholdFactor_ < 100) revert RANGE_InvalidParams();\r' modules/RANGE.sol, 264, b'        if (thresholdFactor_ > 10000 || thresholdFactor_ < 100) revert RANGE_InvalidParams();\r' modules/RANGE.sol, 344, b'            return _range.low.lastActive;\r' modules/RANGE.sol, 342, b'            return _range.high.lastActive;\r' policies/TreasuryCustodian.sol, 60, b'            TRSRY.setApprovalFor(policy_, tokens_[j], 0);\r' modules/TRSRY.sol, 52, b'        return (1, 0);\r' modules/TRSRY.sol, 106, b'        if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding();\r' modules/VOTES.sol, 28, b'        return (1, 0);\r'  ### G10:USE A MORE RECENT VERSION OF SOLIDITY Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value 
