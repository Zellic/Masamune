# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L30-L33   # Vulnerability details  If Bribe and Gauge constructors are run not in the same transaction, the griefing attack is possible. A malicious user can run setGauge after Bribe, but before Gauge constructor, making Bribe contract unusable. The fix here is Bribe redeployment.  Setting severity to be medium as that is temporary system breaking impact.  ## Proof of Concept  setGauge can be run by anyone, but only once with a meaningful gauge:  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L30-L33  ```solidity   function setGauge(address _gauge) external {     require(gauge == address(0), "gauge already set");     gauge = _gauge;   } ```  Now it is called in Gauge constructor:  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L96-L104  ```solidity     constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {         stake = _stake;         bribe = _bribe;         _ve = __ve;         voter = _voter;          factory = msg.sender;          IBribe(bribe).setGauge(address(this)); ```  This way it will not be called before Gauge constructor, but if it is not atomic with Bribe constructor, an attacker can call in-between.  ## Recommended Mitigation Steps  Consider either running Bribe and then Gauge constructors atomically, or introducing an owner role in Bribe constructor and onlyOwner access control in setGauge, setting it manually.  
