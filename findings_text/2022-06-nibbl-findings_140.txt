## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | 1 | Setting `DEFAULT_ADMIN_ROLE` as the role admin is redundant | 1 | | 2 | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 23 | | 3 | Using `storage` instead of `memory` for structs/arrays saves gas | 2 | | 4 | State variables should be cached in stack variables rather than re-reading them from storage | 1 | | 5 | `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables | 7 | | 6 | `internal` functions only called once can be inlined to save gas | 1 | | 7 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement | 5 | | 8 | `<array>.length` should not be looked up in every loop of a `for`-loop | 6 | | 9 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 6 | | 10 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 7 | | 11 | Using `bool`s for storage incurs overhead | 1 | | 12 | Use a more recent version of solidity | 1 | | 13 | `>=` costs less gas than `>` | 1 | | 14 | It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied | 6 | | 15 | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 6 | | 16 | Splitting `require()` statements that use `&&` saves gas | 4 | | 17 | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 14 | | 18 | Using `private` rather than `public` for constants, saves gas | 3 | | 19 | Don't use `SafeMath` once the solidity version is 0.8.0 or greater | 1 | | 20 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 3 | | 21 | Empty blocks should be removed or emit something | 5 | | 22 | Use custom errors rather than `revert()`/`require()` strings to save gas | 41 | | 23 | Functions guaranteed to revert when called by normal users can be marked `payable` | 8 |  Total: 153 instances over 23 issues   ## Gas Optimizations  ### 1. Setting `DEFAULT_ADMIN_ROLE` as the role admin is redundant `DEFAULT_ADMIN_ROLE` is [automatically](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/83277ff916ac4f58fec072b8f28a252c1245c2f1/contracts/access/AccessControl.sol#L40-L48) designated as the role admin of any new role, so setting it again is a waste of gas since it involves fetching role-related state variables, updating state variables, and emitting an event  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  22           _setRoleAdmin(_defaultAdminRole, _defaultAdminRole); 23           _setRoleAdmin(FEE_ROLE, _defaultAdminRole); 24           _setRoleAdmin(PAUSER_ROLE, _defaultAdminRole); 25:          _setRoleAdmin(IMPLEMENTER_ROLE, _defaultAdminRole); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L22-L25  ### 2. Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution.   If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one  *There are 23 instances of this issue:* ```solidity File: contracts/Basket.sol  41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {  41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {  68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {  68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {  91:       function withdrawMultipleERC20(address[] memory _tokens) external override {  99:       function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {  104:      function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41  ```solidity File: contracts/NibblVaultFactory.sol  41:           string memory _name,  42:           string memory _symbol, ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L41  ```solidity File: contracts/NibblVault.sol  174:          string memory _tokenName,   175:          string memory _tokenSymbol,   504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {  504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {  523:      function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {  545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {  545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {  577:      function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L174  ### 3. Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There are 2 instances of this issue:* ```solidity File: contracts/Twav/Twav.sol   #1  38:               TwavObservation memory _twavObservationCurrent = twavObservations[(_index)]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L38  ```solidity File: contracts/Twav/Twav.sol   #2  39:               TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39  ### 4. State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  /// @audit secondaryReserveBalance on line 225 226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade  ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L226  ### 5. `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables  *There are 7 instances of this issue:* ```solidity File: contracts/NibblVault.sol  219:          feeAccruedCurator += _feeCurator;  225:          secondaryReserveBalance += _feeCurve;  242:          feeAccruedCurator += _feeCurator;  320:                  secondaryReserveBalance += _lowerCurveDiff;  380:                  primaryReserveBalance -= _saleReturn;  429:              totalUnsettledBids += _buyoutValuationDeposit;  457:          totalUnsettledBids -= _amount; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L219  ### 6. `internal` functions only called once can be inlined to save gas Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  27:       function getChainID() internal view returns (uint256 id) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L27  ### 7. Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There are 5 instances of this issue:* ```solidity File: contracts/NibblVault.sol  /// @audit require() on line 185 201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  /// @audit require() on line 404 406:          buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);  /// @audit require() on line 404 415:              safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));  /// @audit if-condition on line 373 378:                  uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;  /// @audit if-condition on line 414 415:              safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation)); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L201  ### 8. `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 9. `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 10. `require()`/`revert()` strings longer than 32 bytes cost extra gas Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**  *There are 7 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol  48:           require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low");  49:           require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender");  107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  141:          require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE");  149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48  ### 11. Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  16:       mapping(bytes32 => mapping(address => bool)) public pendingRoles; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L16  ### 12. Use a more recent version of solidity Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  4:    pragma solidity ^0.8.0; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4  ### 13. `>=` costs less gas than `>` The compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  224:          _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L224  ### 14. It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied Not overwriting the default for [stack variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves **8 gas**. Storage and memory variables have larger savings  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 15. `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) Saves **6 gas per loop**  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 16. Splitting `require()` statements that use `&&` saves gas See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper  *There are 4 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107  ```solidity File: contracts/NibblVaultFactory.sol   #2  131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131  ```solidity File: contracts/NibblVaultFactory.sol   #3  149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149  ```solidity File: contracts/NibblVaultFactory.sol   #4  166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166  ### 17. Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead > When using elements that are smaller than 32 bytes, your contractâ€™s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  *There are 14 instances of this issue:* ```solidity File: contracts/NibblVault.sol  28:       uint32 private constant primaryReserveRatio = 200_000; //20%  57:       uint32 public secondaryReserveRatio;  183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));  303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  557:          uint8 v, ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28  ```solidity File: contracts/Twav/Twav.sol  6:            uint32 timestamp;  11:       uint8 public twavObservationsIndex;  12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks   13:       uint32 public lastBlockTimeStamp;  21:       function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {  22:           uint32 _timeElapsed;   37:               uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L6  ### 18. Using `private` rather than `public` for constants, saves gas If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table  *There are 3 instances of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  12:       bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12  ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #2  13:       bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L13  ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #3  14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L14  ### 19. Don't use `SafeMath` once the solidity version is 0.8.0 or greater Version 0.8.0 introduces internal overflow checks, so using `SafeMath` is redundant and adds overhead  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  9:    import { SafeMath } from  "@openzeppelin/contracts/utils/math/SafeMath.sol"; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L9  ### 20. Duplicated `require()`/`revert()` checks should be refactored to a modifier or function Saves deployment costs  *There are 3 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  42:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L42  ```solidity File: contracts/NibblVault.sol   #2  486:          require(msg.sender == curator,"NibblVault: Only Curator"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L486  ```solidity File: contracts/NibblVault.sol   #3  505:          require(msg.sender == bidder,"NibblVault: Only winner"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L505  ### 21. Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)  *There are 5 instances of this issue:* ```solidity File: contracts/Basket.sol  114:      receive() external payable {} ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L114  ```solidity File: contracts/NibblVaultFactory.sol  183:      receive() payable external {    } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L183  ```solidity File: contracts/NibblVault.sol  585:      receive() external payable {} ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L585  ```solidity File: contracts/Proxy/ProxyBasket.sol  56:       receive() external payable {    } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L56  ```solidity File: contracts/Proxy/ProxyVault.sol  56:       receive() external payable {    } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L56  ### 22. Use custom errors rather than `revert()`/`require()` strings to save gas Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hitby [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas  *There are 41 instances of this issue:* ```solidity File: contracts/Basket.sol  36:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  42:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  53:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  62:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  69:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  79:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  86:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  92:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L36  ```solidity File: contracts/NibblVaultFactory.sol  48:           require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low");  49:           require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender");  107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  141:          require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE");  149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48  ```solidity File: contracts/NibblVault.sol  129:          require(unlocked == 1, 'NibblVault: LOCKED');  139:          require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');  146:          require(status == Status.buyout, "NibblVault: status != buyout");  147:          require(buyoutEndTime <= block.timestamp, "NibblVault: buyoutEndTime <= now");  154:          require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');  184:          require(_secondaryReserveRatio <= primaryReserveRatio, "NibblVault: Excess initial funds");  185:          require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, "NibblVault: secResRatio too low");  325:          require(_minAmtOut <= _purchaseReturn, "NibblVault: Return too low");  351:          require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell");  387:          require(_saleReturn >= _minAmtOut, "NibblVault: Return too low");  399:          require(block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now");  400:          require(status == Status.initialized, "NibblVault: Status!=initialized");  404:          require(_buyoutBid >= _currentValuation, "NibblVault: Bid too low");  444:          require(status == Status.buyout, "NibblVault: Status!=Buyout");  475:          require(msg.sender == curator,"NibblVault: Only Curator");  486:          require(msg.sender == curator,"NibblVault: Only Curator");  496:          require(msg.sender == bidder,"NibblVault: Only winner");  505:          require(msg.sender == bidder,"NibblVault: Only winner");  516:          require(msg.sender == bidder, "NibblVault: Only winner");  524:          require(msg.sender == bidder, "NibblVault: Only winner");  536:          require(msg.sender == bidder, "NibblVault: Only winner");  546:          require(msg.sender == bidder, "NibblVault: Only winner");  561:          require(block.timestamp <= deadline, "NibblVault: expired deadline");  564:          require(signer == owner, "NibblVault: invalid signature");  570:          require(success, "NibblVault: ETH transfer failed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L129  ```solidity File: contracts/Utilities/AccessControlMechanism.sol  48:           require(pendingRoles[_role][msg.sender], "AccessControl: Role not pending"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L48  ### 23. Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 8 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol  99:       function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {  123:      function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {  140:      function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {  158:      function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {  173:      function pause() external onlyRole(PAUSER_ROLE) override {  179:      function unPause() external onlyRole(PAUSER_ROLE) override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99  ```solidity File: contracts/Utilities/AccessControlMechanism.sol  32:       function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external override onlyRole(getRoleAdmin(_role)) {  40:       function proposeGrantRole(bytes32 _role, address _to) external override onlyRole(getRoleAdmin(_role)) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L32 
