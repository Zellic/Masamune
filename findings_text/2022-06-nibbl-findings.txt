# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L6   # Vulnerability details  ## Impact The `Basket` contract is intended to be used behind a proxy. But the `ERC721` implementation used is not upgradeable, and its constructor is called at deployment time on the implementation. So all proxies will have a void name and symbol, breaking all potential integrations and listings.  ## Proof of Concept `ERC721("NFT Basket", "NFTB")` is called at deployment time, and sets private variable at the implementation level. Therefore when loading the code during `delegateCall`, these variables will not be initialized.  ## Recommended Mitigation Steps The easiest mitigation would be to pass this variable as immutable so they are hardcoded in the implementation byte code.  
## GAS  1. ## Title: Caching _tokens[i] can save gas  Occurrences: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L71-L73 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L44-L45   Instead of calling array value by assign its key every call, we can cache it for gas saving Change to: ```         for (uint256 i = 0; i < _tokens.length; i++) {      address _token = _tokens[i];      uint _tokenId = _tokenIds[i]             uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);             IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, "0");             emit WithdrawERC1155(_token, _tokenId, _balance, _to);         } ``` By doing this way we can save 48 gas per call   2. ## Title: Prefix increment and unchecked for `i`  Occurrences: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L93  Best practice for doing increment is using prefix increment and unchecked for `i` var inside for():  Change to: ```         for (uint256 i = 0; i < _tokens.length;) {             IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);             emit WithdrawERC721(_tokens[i], _tokenId[i], _to);      unchecked{++i;}         } ```   3. ## Title: Using calldata to store argument variable:  Occurrences: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L41 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L68  We can store `_tokens` and `_tokenIds` read only parameter with calldata instead of using memory.  ## Recommended mitigation step Change to: ```     function withdrawMultipleERC721(address[] calldata _tokens, uint256[] calldata _tokenId, address _to) external override { ```   4. ## Title: Using < operator instead of <=  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L147  By using < operator to validate we can save 3 gas per call. The 1 second difference can be ignore   5. ## Title: Using delete statement to set to default value  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L477  Using delete statement to set value to 0 can save 8 gas per execution  ## Recommended mitigation step ``` delete feeAccruedCurator; ```  
# QA Report  ## [L-01] Lack of ownership transfer pattern Setting the curator to the wrong address will result in permanent loss of functionality in the protocol. It is recommended to apply a two-step transfer.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L488  ## [L-02] Unnecessary safeTransferFrom() when sending from address(this) `safeTransfer()` can be used instead when sending from the current address.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L495-L509  ## [L-03] Missing zero address check Contract would need to be redeployed if the `feeTo` variable is accidently set to address(0).  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L25  ## [L-04] Unsafe transfer, use safeTransfer() It is recommended to use safeTransfer() instead of transfer() to mitigate against ERC20 implementations that do not revert on failure.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517  ## [N-01] Constants should be all caps Most constants defined in the contracts are fully capitalized, just this one example is not.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28  ## [N-02] CURVE_FEE is described as a variable when it is a constant https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L210
## Minus before addition  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L401  ``` _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance; ```  This line perform minus before addition which risk underflow. Should add before minus in all case. Change code to this  ``` _buyoutBid = msg.value + primaryReserveBalance + secondaryReserveBalance - fictitiousPrimaryReserveBalance; ```  This add before minus, so never underflow.  ## Use "" for data instead of "0"  "0" is not 0x "" is 0x  Sending empty data should send "" not "0"  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L538  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L549  ``` IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, "0"); ```  should be  ``` IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, ""); ```
# check the wrong arggument   In this section the function check the amout of the `_adminFeeAmt` and its more correct to check the `_feeAdmin` amount because there is a case that the `_feeAdmin` will be 0 but the `_adminFeeAmt` will be greater than 0.  ``` if(_adminFeeAmt > 0) {             safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract         } ```   ``` fix -  if(_feeAdmin > 0) {             safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract         } ```
# FINDINGS FOR NIBBL CONTEST **Commit:** `N/A` **Type of Audit:** Security Review **Type of Project:** NFT Fractionalization Protocol **Language**: Solidity **Methods**: Manual review ## Audit Scope  --- ## 1.  Contract `NibblVault.sol`   ### [LOW] Missing event emission for state-changing function `updateCurator` function  **File**: [L485](https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L485-L488)  **Description**: State-changing function, `_updateCurator` function does not emit an appropriate event.  ```= solidity function updateCurator(address _newCurator) external override {     require(msg.sender == curator,"NibblVault: Only Curator");     curator = _newCurator; }  ``` **Recommendation**: Consider creating and emitting appropriate event for `_updateCurator` function   --- ## 2.  Contract `NibblVaultFactory.sol`  ### [LOW] Unused Openzeppelin's `SafeMath` Library  **File**: [L9](https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L9)  **Description**: Whereas Openzeppelin's `SafeMath` Library is imported, it is never used in the contract ``` = solidity import { SafeMath } from  "@openzeppelin/contracts/utils/math/SafeMath.sol";  ```  **Recommendation**: Consider utilizing the imported Openzeppelin's `SafeMath` library for efficiency in all logic involving arithmetic operations or consider removing this library if it will be used in the contract.   ---    ### [LOW] Missing access control and possibility of reentrancy attack  **File**: [L112](https://github.com/NibblNFT/nibbl-smartcontracts/blob/master/contracts/NibblVaultFactory.sol#L112)  **Description**: No access control logic to restrict calls to  `withdrawAdminFee(...)` function and missing reentrancy guard to mitigate the risks of reentrancy. The code is shown below:  ```solidity= function withdrawAdminFee() external override {     (bool _success, ) = payable(feeTo).call{value: address(this).balance}("");     require(_success); } ```  **Recommendation**: Consider adding  access control to restrict calls to `withdrawAdminFee(...)` function and consider implementing reentrancy guard to mitigate the risks of reentrancy.  
[G-01] Constant Value of a Call to keccak256() should Use Immutable  When using constant it is expected that the value should be converted into a constant value at compile time. However when using a call to keccak256(), the expression is re-calculated each time the constant is referenced. Resulting in costing about 100 gas more on each access to this "constant". link for more details: https://github.com/ethereum/solidity/issues/9232  Issue found at ``` ./EIP712Base.sol:7-10:    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(bytes("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")); ./NibblVault.sol:51:    bytes32 private constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"); ./AccessControlMechanism.sol:12:    bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE"); ./AccessControlMechanism.sol:13:    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE"); ./AccessControlMechanism.sol:14:    bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE"); ```   [G-02] Unnecessary Default Value Initialization  When variable is not initialized, it will have its default values. For example, 0 for uint, false for bool and address(0) for address. link: https://docs.soliditylang.org/en/v0.8.15/control-structures.html#scoping-and-declarations  I suggest removing default value initialization for following variables. ``` ./Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { ./NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { ./NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  For example these can change to: - for (uint256 i; i < _tokens.length; i++) {   [G-03] Store Array's Length as a Variable   I suggest to store an array's length as a variable before the for-loop since it can save 3 gas per iteration.  Issue found at: ``` ./Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { ./NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { ./NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  For example, I suggest changing it to ``` length = _tokens.length for (uint256 i = 0; i < length; i++) { ```   [G-04] ++i Costs Less Gas than i++  It is better to use ++i than i++ when possible since it costs less gas.  Issue found at: ``` ./Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { ./NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { ./NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:562:        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); ```   [G-05] Use Calldata instead of Memory for Read Only Function Parameters  It is cheaper gas to use calldata than memory if the function parameter is read only. Calldata is a non-modifiable, non-persistent area where function arguments are stored,  and behaves mostly like memory. More details on following link. link: https://docs.soliditylang.org/en/v0.8.15/types.html#data-location  I recommend changing following memory to calldata ``` ./EIP712Base.sol:15:    function INIT_EIP712(string memory name, string memory version) internal { ./Basket.sol:41:    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override { ./Basket.sol:68:    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override { ./Basket.sol:91:    function withdrawMultipleERC20(address[] memory _tokens) external override { ./Basket.sol:99:    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) { ./Basket.sol:104:    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) { ./Basket.sol:109:    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) { ./NibblVault.sol:174:        string memory _tokenName,  ./NibblVault.sol:175:        string memory _tokenSymbol,  ./NibblVault.sol:504:    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut { ./NibblVault.sol:523:    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut { ./NibblVault.sol:545:    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut { ./NibblVault.sol:577:    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) { ./NibblVault.sol:581:    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) { ./NibblVaultFactory.sol:41:        string memory _name, ./NibblVaultFactory.sol:42:        string memory _symbol, ./NibblVaultFactory.sol:80:    function createBasket(address _curator, string memory _mix) public override returns(address)  { ./NibblVaultFactory.sol:88:    function getBasketAddress(address _curator, string memory _mix) public override view returns(address _basket) { ```   [G-06] Using Elements Smaller than 32 bytes (256 bits) Might Use More Gas  This is because EVM operates on 32 bytes at a time. So I recommend using uint256 instead of anything smaller. More information about this in the following link. link: https://docs.soliditylang.org/en/v0.8.15/internals/layout_in_storage.html  Issue found at ``` ./Twav.sol:6:        uint32 timestamp; ./Twav.sol:11:    uint8 public twavObservationsIndex; ./Twav.sol:12:    uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks  ./Twav.sol:13:    uint32 public lastBlockTimeStamp; ./Twav.sol:21:    function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal { ./Twav.sol:22:        uint32 _timeElapsed;  ./Twav.sol:37:            uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS; ./NibblVault.sol:28:    uint32 private constant primaryReserveRatio = 200_000; //20% ./NibblVault.sol:57:    uint32 public secondaryReserveRatio; ./NibblVault.sol:183:        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice)); ./NibblVault.sol:303:            uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ./NibblVault.sol:365:            uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ./NibblVault.sol:445:        uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ./NibblVault.sol:557:        uint8 v, ```   [G-07] Use require instead of &&  When there are multiple conditions in require statement, break down the require statement into multiple require statements instead of using && can save gas.  Issue found at ``` ./NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  For example these can be changed to ``` require(basketUpdateTime != 0); require(block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```   [G-08] Reduce the Long Revert Strings of Error Messages  By keeping the revert strings within 32 bytes will save you gas since each slot is 32 bytes.  Following are revert strings that are more than 32 bytes. ``` ./NibblVaultFactory.sol:48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low"); ./NibblVaultFactory.sol:49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender"); ./NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE"); ./NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```   [G-09] Duplicate require() Checks Should be a Modifier or a Function  Since below require checks are used more than once, I recommend making these to a modifier or a function. ``` ./Basket.sol:36:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:42:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:53:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:62:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:69:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:79:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:86:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:92:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ``` ``` ./NibblVault.sol:475:        require(msg.sender == curator,"NibblVault: Only Curator"); ./NibblVault.sol:486:        require(msg.sender == curator,"NibblVault: Only Curator"); ``` ``` ./NibblVault.sol:496:        require(msg.sender == bidder,"NibblVault: Only winner"); ./NibblVault.sol:505:        require(msg.sender == bidder,"NibblVault: Only winner"); ./NibblVault.sol:516:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:524:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:536:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:546:        require(msg.sender == bidder, "NibblVault: Only winner"); ```   [G-10] Use Custom Errors to Save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings. Details are explained here: https://blog.soliditylang.org/2021/04/21/custom-errors/  I recommend using custom errors. ``` ./Basket.sol:36:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:42:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:53:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:62:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:69:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:79:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:86:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:92:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./NibblVault.sol:129:        require(unlocked == 1, 'NibblVault: LOCKED'); ./NibblVault.sol:139:        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out'); ./NibblVault.sol:146:        require(status == Status.buyout, "NibblVault: status != buyout"); ./NibblVault.sol:147:        require(buyoutEndTime <= block.timestamp, "NibblVault: buyoutEndTime <= now"); ./NibblVault.sol:154:        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused'); ./NibblVault.sol:184:        require(_secondaryReserveRatio <= primaryReserveRatio, "NibblVault: Excess initial funds"); ./NibblVault.sol:185:        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, "NibblVault: secResRatio too low"); ./NibblVault.sol:325:        require(_minAmtOut <= _purchaseReturn, "NibblVault: Return too low"); ./NibblVault.sol:351:        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell"); ./NibblVault.sol:387:        require(_saleReturn >= _minAmtOut, "NibblVault: Return too low"); ./NibblVault.sol:399:        require(block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now"); ./NibblVault.sol:400:        require(status == Status.initialized, "NibblVault: Status!=initialized"); ./NibblVault.sol:404:        require(_buyoutBid >= _currentValuation, "NibblVault: Bid too low"); ./NibblVault.sol:444:        require(status == Status.buyout, "NibblVault: Status!=Buyout"); ./NibblVault.sol:475:        require(msg.sender == curator,"NibblVault: Only Curator"); ./NibblVault.sol:486:        require(msg.sender == curator,"NibblVault: Only Curator"); ./NibblVault.sol:496:        require(msg.sender == bidder,"NibblVault: Only winner"); ./NibblVault.sol:505:        require(msg.sender == bidder,"NibblVault: Only winner"); ./NibblVault.sol:516:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:524:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:536:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:546:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:561:        require(block.timestamp <= deadline, "NibblVault: expired deadline"); ./NibblVault.sol:564:        require(signer == owner, "NibblVault: invalid signature"); ./NibblVault.sol:570:        require(success, "NibblVault: ETH transfer failed"); ./NibblVaultFactory.sol:48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low"); ./NibblVaultFactory.sol:49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender"); ./NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE"); ./NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./AccessControlMechanism.sol:48:        require(pendingRoles[_role][msg.sender], "AccessControl: Role not pending"); ```   [G-11] Defined Variables Used Only Once  Certain variables is defined even though they are used only once. Remove these unnecessary variables to save gas. For cases where it will reduce the readability, one can use comments to help describe what the code is doing.  Issue found at  1. NibblVaultFactory.sol - Remove "newsalt", "code" and "_hash" variable of getVaultAddress function ``` 70:        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID,  _initialSupply, _initialTokenPrice)); 71:        bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this)))); 72:        bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))); 73:        _vault = address(uint160(uint256(_hash)));      ``` - Remove "newsalt", "code" and "hash" variable of getBasketAddress function ``` 89:        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix)); 90:        bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(basketImplementation))); 91:        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))); 92:        _basket = address(uint160(uint256(hash)));      ```  2. Twav.sol - Remove "_prevCumulativeValuation" variable of _updateTWAV function ``` 27:        uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation; 28:        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative ``` 
# Basket.sol - Wrong comment in line 58, it should be ERC1155 instead of ERC721 #NibblVault.sol - Consider adding an event for the `initialize()`, `updateCurator()`. # MISC - Most of the comments in all the contracts assume that the ERC1155 token can be only NFT. This is not true because a tokenID of ERC1155 can be a fungible token. 
# QA Report  ## Table of Contents  - [summary](#summary) - [hash collision with abi.encodePacked](#hash-collision-with-abi.encodepacked) - [Immutable addresses lack zero-address check](#immutable-addresses-lack-zero-address-check) - [Receive function](#receive-function) - [Setters should check the input value](#setters-should-check-the-input-value) - [Unchecked transfer](#unchecked-transfer) - [Comment Missing function parameter](#comment-missing-function-parameter) - [Commented Code](#commented-code) - [Constants instead of magic numbers](#constants-instead-of-magic-numbers) - [Event should be emitted in setters](#event-should-be-emitted-in-setters) - [Function missing comments](#function-missing-comments) - [Function order](#function-order) - [Inconsistent spacing](#inconsistent-spacing) - [Non-library files should use fixed compiler versions](#non-library-files-should-use-fixed-compiler-versions) - [Non-library files should use the same compiler version](#non-library-files-should-use-the-same-compiler-version) - [Public functions can be external](#public-functions-can-be-external) - [Require statements should have descriptive strings](#require-statements-should-have-descriptive-strings) - [Scientific notation](#scientific-notation) - [Timelock for critical parameter change](#timelock-for-critical-parameter-change) - [Uint256 alias](#uint256-alias)     # summary  > Few vulnerabilities were found, the main concerns are with potential lock of ETH in some contracts   # hash collision with abi.encodePacked  ## IMPACT  strings and bytes are encoded with padding when using `abi.encodePacked`. This can lead to [hash collision](https://docs.soliditylang.org/en/v0.8.15/abi-spec.html#non-standard-packed-mode) when passing the result to `keccak256`  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactory.sol  [here](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L71-L72) ``` bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this)))); bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))) ```  and [here](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L81), with a string ``` ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation)) ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use `abi.encode()` instead.  # Immutable addresses lack zero-address check  ## IMPACT  constructors should check the address written in an immutable address variable is not the zero address  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:    ### ProxyBasket.sol  [implementation = payable(_implementation)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L20)  ### ProxyVault.sol  [factory = payable(_factory)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L20)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add a zero address check for the immutable variables aforementioned.  # Receive function  ## PROBLEM  `ProxyBasket` and `ProxyDelegate` have `receive()` functions, but do not have any withdrawal function. A call to these contracts will trigger the `fallback` function. But if a call sends ETH to these contracts with no `msg.data`, `fallback` will not be triggered, only `receive()`, resulting in the ETH getting locked.  ## SEVERITY  Low  ## PROOF OF CONCEPT  ### ProxyBasket.sol  [receive() external payable {    }](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L56)  ### ProxyVault.sol  [receive() external payable {    }](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L56)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add `require(0 == msg.value)` in `receive()` or remove the function altogether.   # Setters should check the input value  ## PROBLEM  Setters and initializers should check the input value - ie make revert if it is the zero address or zero  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [_assetAddress lacks a check in initialize()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L191)\ [_curator lacks a check in initialize()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L193)\ [_newCurator lacks a check in updateCurator()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L487)  ### NibblVaultFactory.sol  [_vaultImplementation lacks a check in the constructor](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L24)\ [_feeTo lacks a check in the constructor](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L25)\ [_basketImplementation lacks a check in the constructor](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L26)\ [_newBasketImplementation lacks a check in proposeNewBasketImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100)\ [_newFeeAddress lacks a check in proposeNewAdminFeeAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L124)\ [_newVaultImplementation lacks a check in proposeNewVaultImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add non-zero checks - address - to the setters aforementioned.   # Unchecked transfer  ## PROBLEM  Several tokens do not revert in case of `ERC20.transfer()` failure and return false. It is good practice to use `safeTransfer()` from OpenZeppelin, or simply check the return value of `.transfer()`  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517)\ [IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526)  ## TOOLS USED  Manual Analysis  ## MITIGATION  use `safeTransfer()` from OpenZeppelin or check the return value of `.transfer()`.   # Comment Missing function parameter  ## PROBLEM  Some of the function comments are missing function parameters or returns  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L275)\ [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L287)\ [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L335)\ [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L347)\ [@return _saleReturn](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L362)\ [@return _buyoutBid](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L398)\ [@param _to](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L464)\ [@return _amtOut](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L464)\ [@return _feeAccruedCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L474)  ### NibblVaultFactory.sol   [@return _proxyVault](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L47)\ [@return _vault](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L69)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Add a comment for these parameters  # Commented code  ## PROBLEM  There are portions of commented code in some files.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [// _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L321)\ [// buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L405)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove commented code  # Constants instead of magic numbers  ## PROBLEM  It is best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183)\ [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L195)\ [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L226)\ [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L253)\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303)\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L365)\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L413)\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L445)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Define constant variables for the literal values aforementioned.  # Event should be emitted in setters  ## PROBLEM  Setters should emit an event so that Dapps can detect important changes to storage  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:   ### NibblVault.sol  [function updateCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485)  ### NibblVaultFactory.sol  [function updateBasketImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L106)\ [function updateNewAdminFeeAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L130)\ [function updateNewAdminFee](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L148)\ [function updateVaultImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L165)   ## TOOLS USED  Manual Analysis  ## MITIGATION  emit an event in all setters  # Function missing comments  ## PROBLEM  Some functions are missing Natspec comments  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [function permit](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L552-L565)\ [function safeTransferETH](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L568)\ [function onERC721Received](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L573)\ [function onERC1155Received](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L577)\ [function onERC1155BatchReceived](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L581)  ### NibblVaultFactory.sol  [function getVaults](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76)\ [function createBasket](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80)\ [function getBasketAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88)\ [function withdrawAdminFee](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L112)   ### Twav.sol  [function getTwavObservations()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44)  ### EIP712Base.sol  [function INIT_EIP712()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15)\ [function getChainID()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L27)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add comments to these functions  # Function order  ## PROBLEM  Functions should be ordered following the [Soldiity conventions](https://docs.soliditylang.org/en/v0.8.15/style-guide.html#order-of-functions): `receive()` function should be placed after the constructor and before every other function.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Several contracts have `receive()` at the end:   - NibblVault.sol  - NibblVaultFactory.sol  - Basket.sol  ## TOOLS USED  Manual Analysis  ## MITIGATION  Place the `receive()`functions after the constructor, before all the other functions.  # Inconsistent spacing  ## PROBLEM  Spacing is present in the vast majority of comments (`// x`), but some comments do not have space.   ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  ### NibblVault.sol  [///@notice current status of vault](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L122)\ [///@notice reenterancy guard](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L125)\ [///@notice withdraw multiple ERC721s](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L500)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use spacings consistently in all comments.   # Non-library files should use fixed compiler versions  ## PROBLEM  contracts should be compiled using a fixed compiler version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most   ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT   `AccessControlMechanism.sol` has a floating pragma.    ## TOOLS USED  Manual Analysis    ## MITIGATION  Used a fixed compiler version  # Non-library files should use the same compiler version  ## PROBLEM  contracts within the scope should be compiled using the same compiler version.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  All the files in scope have the compiler version set to `0.8.10`, except for `AccessControlMechanism.sol` which has its pragma set to `^0.8.0`.   ## TOOLS USED  Manual Analysis    ## MITIGATION  Use the same compiler version throughout the contracts  # Public functions can be external  ## PROBLEM  It is good practice to mark functions as `external` instead of `public` if they are not called by the contract where they are defined.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactory.sol  [function getVaultAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L74)\ [function getVaults](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76-L77)\ [function createBasket](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80-L86)\ [function getBasketAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88-L92)  ### Twav.sol  [function getTwavObservations](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Declare these functions as `external` instead of `public`  # Require statements should have descriptive strings  ## PROBLEM  Some require statements are missing error strings, which makes it more difficult to debug when the function reverts.  ### SEVERITY  Non-critical  ## PROOF OF CONCEPT   ### NibblVaultFactory.sol   [require(_success)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114)  ## TOOL USED  Manual Analysis  ## MITIGATION  Add error strings to all require statements.  # Scientific notation  ## PROBLEM  For readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`). Underscores are used throughout the contracts and do improve readability too, so this is more of a suggestion.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [uint256 private constant SCALE = 1_000_000](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L23)  ## TOOLS USED  Manual Analysis   # Timelock for critical parameter change  ## PROBLEM  It is good practice to add timelock to critical parameters changes, such as admin changes, to give users time to react.     ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### NibblVault.sol  There is no timelock in [updateCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L487). If the curator were to input an incorrect address here, they would lose all the curators fees accrued.   ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a timelock to `updateCurator`   # Uint256 alias  ## IMPACT  `uint` is an alias for `uint256`.  It is better to use uint256: it brings readability and consistency in the code, and it future proofs it in case of any changes to the alias of uint. This is all the more valid as `uint256` is used throughout the contracts, `uint` is only used in few instances.   ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  ### Nibblvault.sol  [uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L195)\ [uint _secondaryReserveBalance = secondaryReserveBalance](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L289)\ [uint _primaryReserveBalance = primaryReserveBalance](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L336)\ [uint _secondaryReserveBalance = secondaryReserveBalance](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L348)\ [uint _amount = unsettledBids[msg.sender]](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L455)  ## TOOLS USED  Manual Analysis    ## MITIGATION  replace `uint` with `uint256`  
# Gas Report  ## Table of Contents  - [Caching storage variables in memory to save gas](#caching-storage-variables-in-memory-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters) - [Comparison operators](#comparison-operators) - [Constant expressions](#constant-expressions) - [Constructor parameters should be avoided when possible](#constructor-parameters-should-be-avoided-when-possible) - [Custom errors](#custom-errors) - [Default value initialization](#default-value-initialization) - [Immutable variables save storage](#immutable-variables-save-storage) - [Mathematical optimizations](#mathematical-optimizations) - [Modifier instead of duplicate require](#modifier-instead-of-duplicate-require) - [Prefix increments](#prefix-increments) - [Require instead of AND](#require-instead-of-and) - [Revert strings length](#revert-strings-length) - [unchecked arithmetic](#unchecked-arithmetic) - [unused import](#unused-import)    # Caching storage variables in memory to save gas  ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable in memory: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.  In particular, in `for` loops, when using the length of a storage array as the condition being checked after each loop, caching the array length in memory can yield significant gas savings if the array length is high  ## PROOF OF CONCEPT  Instances include:  ### Twav.sol  scope: `_updateTWAV()`  - `twavObservationsIndex` is read 3 times  [line 27](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L27)\ [line 28](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L28)\ [line 29](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L29)    ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these storage variables in memory  # Calldata instead of memory for RO function parameters  ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.  Try to use calldata as a data location because it will avoid copies and also makes sure that the data cannot be modified.  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [address[] memory _assetAddresses, uint256[] memory _assetIDs](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504)\ [address[] memory _assets](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L523)\ [address[] memory _assets, uint256[] memory _assetIDs](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `memory` with `calldata`  # Comparison Operators  ## IMPACT  In the EVM, there is no opcode for ` >=` or `<=`. When using greater than or equal, two operations are performed: `>` and `=`.  Using strict comparison operators hence saves gas, approximately `20` gas in `require` and `if` statements  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [buyoutEndTime <= block.timestamp](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L147)\ [_secondaryReserveRatio <= primaryReserveRatio](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L184)\ [_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L185)\ [_totalSupply >= _initialTokenSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L311)\ [_lowerCurveDiff >= msg.value](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L315)\ [_minAmtOut <= _purchaseReturn](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L325)\ [_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L351)\ [(_initialTokenSupply + _amtIn) <= _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L374)\ [_saleReturn >= _minAmtOut, "NibblVault: Return too low"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L387)\ [block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L399)\ [_buyoutBid >= _currentValuation, "NibblVault: Bid too low"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L404)\ [_twav >= buyoutRejectionValuation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L426)\ [block.timestamp <= deadline](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L561)   ### NibblVaultFactory.sol  [msg.value >= MIN_INITIAL_RESERVE_BALANCE](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48)\ [block.timestamp >= basketUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107)\ [block.timestamp >= feeToUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131)\ [_newFee <= MAX_ADMIN_FEE](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141)\ [block.timestamp >= feeAdminUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)\ [block.timestamp >= vaultUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `<=` with `<`, and `>=` with `>`. Do not forget to increment/decrement the compared variable  example:  ``` -block.timestamp >= basketUpdateTime +block.timestamp > basketUpdateTime - 1; ```  However, if `1` is negligible compared to the value of the variable, we can omit the increment.  ``` -block.timestamp >= basketUpdateTime +block.timestamp > basketUpdateTime; ```  # Constant expressions  ## IMPACT  Constant expressions are [re-calculated each time it is in use](https://github.com/ethereum/solidity/issues/9232), costing an extra `97` gas than a constant every time they are called.   ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [bytes32 private constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L51)  ### AccessControlMechanism.sol  [bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12)\ [bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L13)\ [bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L14)  ### EIP712Base.sol  [bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(bytes("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L7-L11)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these as `immutable` instead of `constant`  # Constructor parameters should be avoided when possible  ## IMPACT  Constructor parameters are expensive. The contract deployment will be cheaper in gas if they are hard coded instead of using constructor parameters.  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactory.sol  [vaultImplementation = _vaultImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L24)\ [feeTo = _feeTo](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L25)\ [basketImplementation = _basketImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L26)  ### ProxyBasket.sol  [implementation = payable(_implementation)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L20)  ### ProxyVault.sol  [factory = payable(_factory)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L20)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Hardcode storage variables with their initial value instead of writing it during contract deployment with constructor parameters.  # Custom Errors  ## IMPACT  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information, as explained [here](https://blog.soliditylang.org/2021/04/21/custom-errors/).  It not only saves gas upon deployment - `~5500` gas saved per custom error instead of a require statement, but it is also cheaper in a function call, `22` gas saved per require statement replaced with a custom error.  Custom errors are defined using the error statement  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [require(unlocked == 1, 'NibblVault: LOCKED')](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L129)\ [require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out'))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L139)\ [require(status == Status.buyout, "NibblVault: status != buyout")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L146)\ [require(buyoutEndTime <= block.timestamp, "NibblVault: buyoutEndTime <= now")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L147)\ [require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused')](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L154)\ [require(_secondaryReserveRatio <= primaryReserveRatio, "NibblVault: Excess initial funds")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L184)\ [require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, "NibblVault: secResRatio too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L185)\ [require(_minAmtOut <= _purchaseReturn, "NibblVault: Return too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L325)\ [require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L351)\ [require(_saleReturn >= _minAmtOut, "NibblVault: Return too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L387)\ [require(block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L399)\ [require(status == Status.initialized, "NibblVault: Status!=initialized")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L400)\ [require(_buyoutBid >= _currentValuation, "NibblVault: Bid too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L404)\ [require(status == Status.buyout, "NibblVault: Status!=Buyout")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L444)\ [require(msg.sender == curator,"NibblVault: Only Curator")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L474)\ [require(msg.sender == curator,"NibblVault: Only Curator")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L486)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L496)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L505)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L516)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L524)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L536)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L546)\ [require(block.timestamp <= deadline, "NibblVault: expired deadline")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L561)\ [require(signer == owner, "NibblVault: invalid signature")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L564)\ [require(success, "NibblVault: ETH transfer failed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L570)  ### NibblVaultFactory.sol  [require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48)\ [require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L49)\ [require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107)\ [require(_success)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114)\ [require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131)\ [require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141)\ [require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)\ [require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)  ### AccessControlMechanism.sol  [require(pendingRoles[_role][msg.sender], "AccessControl: Role not pending")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L48)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace require and revert statements with custom errors.  For instance, in `NibbleVault.sol`:  Replace  ``` require(unlocked == 1, 'NibblVault: LOCKED') ```  with  ``` if (unlocked != 1) {   revert NibblVaultLocked(); } ```  and define the custom error in the contract  ``` error NibblVaultLocked(); ```  Here are the deployment costs comparison between:  - the original `NibbleVault` contract |  NibblVault                                                               -            -      7045960       - the same `NibbleVault` contract with one require statement replaced with a custom error:   |  NibblVault                                                               -            -      7036463    # Default value initialization  ## IMPACT  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes `3` gas per variable initialized.  ## PROOF OF CONCEPT  Instances include:  ### NibbleVault.sol  [uint i = 0](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506)\ [uint i = 0](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525)\ [uint i = 0](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547)    ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove explicit initialization for default values.   # Immutable variables save storage  ## PROBLEM  If a variable is set in the constructor and never modified afterwrds, marking it as `immutable` can save a storage operation - `20,000` gas.  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactoryData.sol  [uint256 public UPDATE_TIME = 2 days](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/NibblVaultFactoryData.sol#L6)  Note: the contract is technically not in scope, but as `NibblVaultFactory`, which is in scope, inherits from `NibblVaultFactoryData`, I consider it a valid optimization.  ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these variables as `immutable`.  # Mathematical optimizations  ## PROBLEM  X += Y costs `22` more gas than X = X + Y.   ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [feeAccruedCurator += _feeCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L219)\ [secondaryReserveBalance += _feeCurve](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L225)\ [feeAccruedCurator += _feeCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L242)\ [secondaryReserveBalance += _lowerCurveDiff](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L320)\ [_purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L322)\ [primaryReserveBalance -= _saleReturn](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L380)\ [_saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L383)\ [unsettledBids[bidder] += _buyoutValuationDeposit](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L428)\ [totalUnsettledBids += _buyoutValuationDeposit](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L429)\ [totalUnsettledBids -= _amount](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L450)   ## TOOLS USED  Manual Analysis  ## MITIGATION  use `X = X + Y` instead of `X += Y` (same with `-`)  # Modifier instead of duplicate require  ## PROBLEM  When a `require` statement is use multiple times, it is cheaper to use a modifier instead.  ## PROOF OF CONCEPT  Instances include:   ### NibblVault.sol   [require(msg.sender == curator,"NibblVault: Only Curator")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L474)\ [require(msg.sender == curator,"NibblVault: Only Curator")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L486)  [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L496)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L505)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L516)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L524)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L536)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L546)     ## TOOLS USED  Manual Analysis  ## MITIGATION  Use modifiers for these repeated statements  # Prefix increments  ## IMPACT  Prefix increments are cheaper than postfix increments: it returns the incremented variable instead of returning a temporary variable storing the initial value of the variable. It saves `5` gas per iteration  ## PROOF OF CONCEPT  Instances include:  ### NibbleVault.sol  [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506)\ [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525)\ [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547)   ## TOOLS USED  Manual Analysis  ## MITIGATION  change `variable++` to `++variable`.  # Require instead of AND  ## IMPACT  Require statements including conditions with the `&&` operator can be broken down in multiple require statements to save gas.  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactory.sol   [require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107)\ [require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131)\ [require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)\ [require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Break down the statements in multiple require statements.  ``` -require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed") +require(basketUpdateTime != 0) +require(block.timestamp >= basketUpdateTime) ``` You can also improve gas savings by using [custom errors](#custom-errors)   # Revert strings length  ## IMPACT  Revert strings cost more gas to deploy if the string is larger than 32 bytes. Each string exceeding that 32-byte size adds an extra `9,500` gas upon deployment.  ## PROOF OF CONCEPT  Revert strings exceeding 32 bytes include:   ### NibblVaultFactory.sol  [require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48)\ [require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L49)\ [require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107)\ [require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131)\ [require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141)\ [require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)\ [require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Write the error strings so that they do not exceed 32 bytes. For further gas savings, consider also using [custom errors](#custom-errors).    # Unchecked arithmetic  ## IMPACT  The default "checked" behavior costs more gas when adding/diving/multiplying, because under-the-hood those checks are implemented as a series of opcodes that, prior to performing the actual arithmetic, check for under/overflow and revert if it is detected.  if it can statically be determined there is no possible way for your arithmetic to under/overflow (such as a condition in an if statement), surrounding the arithmetic in an `unchecked` block will save gas  ## PROOF OF CONCEPT  Instances include:  ### NibbleVault.sol  [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506)\ [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525)\ [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Place the arithmetic operations in an `unchecked` block  # Unused import  ## IMPACT  Unused imports should be removed as they waste gas upon deployment  ## PROOF OF CONCEPT  Instances include:  ### NibbleVaultFactory.sol  [import { SafeMath } from  "@openzeppelin/contracts/utils/math/SafeMath.sol";](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L9)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove the `SafeMath` import. 
# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L414-L417   # Vulnerability details  ## Impact In the initiateBuyout function of the NibblVault contract, the second parameter of the BuyoutInitiated event is _buyoutBid instead of _currentValuation, and since the excess Ether in _buyoutBid is transferred to the user, the actual buyout price for the user is the _currentValuation variable. The user can use a large amount of Ether to get a large _buyoutBid variable, however the actual amount of Ether spent by the user is _currentValuation. Events emitted by the smart contract are used off-chain, and incorrect event parameters may have an impact on the user's trading behavior  ## Proof of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L414-L417 ## Tools Used None ## Recommended Mitigation Steps ``` -       emit BuyoutInitiated(msg.sender, _buyoutBid); +      emit BuyoutInitiated(msg.sender, _currentValuation); ```  
# Gas Optimizations Report  ## For-loops: Index initialized with default value Uninitialized `uint` variables are assigned with a default value of `0`.   Thus, in for-loops, explicitly initializing an index with `0` costs unnecesary gas. For example, the following code: ```js for (uint256 i = 0; i < length; ++i) { ``` can be changed to: ```js for (uint256 i; i < length; ++i) { ```  Consider declaring the following lines without explicitly setting the index to `0`:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## For-Loops: Cache array length outside of loops Reading an array length at each iteration of the loop takes 6 gas (3 for `mload` and 3 to place `memory_offset`) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.   For example: ```js for (uint256 i; i < arr.length; ++i) {} ``` can be changed to: ```js uint256 len = arr.length; for (uint256 i; i < len; ++i) {} ```  Consider making the following change to these lines:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## For-Loops: Index increments can be left unchecked From Solidity v0.8 onwards, all arithmetic operations come with implicit overflow and underflow checks.   In for-loops, as it is impossible for the index to overflow, it can be left unchecked to save gas every iteration.   For example, the code below: ```js for (uint256 i; i < numIterations; ++i) {       // ...   }   ``` can be changed to: ```js for (uint256 i; i < numIterations;) {       // ...       unchecked { ++i; }   }   ```  Consider making the following change to these lines:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## Arithmetics: `++i` costs less gas compared to `i++` or `i += 1` `++i` costs less gas compared to `i++` or `i += 1` for unsigned integers, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means: ```js uint i = 1;   i++; // == 1 but i == 2   ``` But `++i` returns the actual incremented value: ```js uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`, thus it costs more gas.  The same logic applies for `--i` and `i--`.  Consider using `++i` instead of `i++` or `i += 1` in the following instances:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## Arithmetics: Use `!= 0` instead of `> 0` for unsigned integers `uint` will never go below 0. Thus, `> 0` is gas inefficient in comparisons as checking if `!= 0` is sufficient and costs less gas.  Consider changing `> 0` to `!= 0` in these lines:   ```js contracts/NibblVault.sol:  227:        if(_adminFeeAmt > 0) {  243:        if(_adminFeeAmt > 0) { ```  ## Visibility: `public` functions can be set to `external` Calls to `external` functions are cheaper than `public` functions. Thus, if a function is not used internally in any contract, it should be set to `external` to save gas and improve code readability.  Consider changing following functions from `public` to `external`:   ```js contracts/NibblVaultFactory.sol:   64:        function getVaultAddress(   65:            address _curator,   66:            address _assetAddress,   67:            uint256 _assetTokenID,   68:            uint256 _initialSupply,   69:            uint256 _initialTokenPrice) public view returns(address _vault) {    76:        function getVaults() public view returns(ProxyVault[] memory ) {  contracts/Twav/Twav.sol:   44:        function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) { ```  ## Errors: Reduce the length of error messages (long revert strings) Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional `mstore`, along with additional overhead for computing memory offset, etc.  In these instances, consider shortening the revert strings to fit within 32 bytes, or using custom errors:     ```js contracts/NibblVaultFactory.sol:   48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low");   49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender");  107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE");  149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  ## Errors: Use modifiers instead of require statements duplicate access role checks Instead of using a `require` statement to check that `msg.sender` belongs to a certain role (e.g. `msg.sender` is owner), consider using modifiers. This would help to save gas and improve code clarity.  For example, to check that `msg.sender` is `owner`, a modifier can be written as such: ```js modifier isOwner() {   require(msg.sender == owner, "error");   _; } ```  Functions can then use `isOwner` to validate `msg.sender`, for example: ```js function setOwner(address _owner) external {   require(msg.sender == owner, "error");   // ... } ``` can be rewritten to: ```js function setOwner(address _owner) external isOwner {   // ... } ```  Instances where modifiers can be used include: ```js contracts/NibblVault.sol:  475:        require(msg.sender == curator,"NibblVault: Only Curator");  486:        require(msg.sender == curator,"NibblVault: Only Curator");  496:        require(msg.sender == bidder,"NibblVault: Only winner");  505:        require(msg.sender == bidder,"NibblVault: Only winner");  516:        require(msg.sender == bidder, "NibblVault: Only winner");  524:        require(msg.sender == bidder, "NibblVault: Only winner");  536:        require(msg.sender == bidder, "NibblVault: Only winner");  546:        require(msg.sender == bidder, "NibblVault: Only winner"); ```  ## Errors: Use multiple `require` statements instead of `&&` Instead of using a single `require` statement with the `&&` operator, using multiple `require` statements would help to save runtime gas cost. However, note that this results in a higher deployment gas cost, which is a fair trade-off.  A `require` statement can be split as such: ```js // Original code: require(a && b, 'error');  // Changed to: require(a, 'error: a'); require(b, 'error: b'); ```  Instances where multiple `require` statements should be used: ```js contracts/NibblVaultFactory.sol:  107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  ## Errors: Use custom errors instead of revert strings Since Solidity v0.8.4, custom errors should be used instead of revert strings due to: * Cheaper deployment cost * Lower runtime cost upon revert  Taken from [Custom Errors in Solidity](https://blog.soliditylang.org/2021/04/21/custom-errors/): > Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors can be defined using of the `error` statement, both inside or outside of contracts.  Instances where custom errors can be used instead:   ```js contracts/NibblVault.sol:  129:        require(unlocked == 1, 'NibblVault: LOCKED');  139:        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');  146:        require(status == Status.buyout, "NibblVault: status != buyout");  147:        require(buyoutEndTime <= block.timestamp, "NibblVault: buyoutEndTime <= now");  154:        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');  184:        require(_secondaryReserveRatio <= primaryReserveRatio, "NibblVault: Excess initial funds");  185:        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, "NibblVault: secResRatio too low");  325:        require(_minAmtOut <= _purchaseReturn, "NibblVault: Return too low");  351:        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell");  387:        require(_saleReturn >= _minAmtOut, "NibblVault: Return too low");  399:        require(block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now");  400:        require(status == Status.initialized, "NibblVault: Status!=initialized");  404:        require(_buyoutBid >= _currentValuation, "NibblVault: Bid too low");  444:        require(status == Status.buyout, "NibblVault: Status!=Buyout");  475:        require(msg.sender == curator,"NibblVault: Only Curator");  486:        require(msg.sender == curator,"NibblVault: Only Curator");  496:        require(msg.sender == bidder,"NibblVault: Only winner");  505:        require(msg.sender == bidder,"NibblVault: Only winner");  516:        require(msg.sender == bidder, "NibblVault: Only winner");  524:        require(msg.sender == bidder, "NibblVault: Only winner");  536:        require(msg.sender == bidder, "NibblVault: Only winner");  546:        require(msg.sender == bidder, "NibblVault: Only winner");  561:        require(block.timestamp <= deadline, "NibblVault: expired deadline");  564:        require(signer == owner, "NibblVault: invalid signature");  570:        require(success, "NibblVault: ETH transfer failed");  contracts/Basket.sol:   36:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   42:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   53:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   62:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   69:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   79:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   86:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   92:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  contracts/NibblVaultFactory.sol:   48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low");   49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender");  107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE");  149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  contracts/Utilities/AccessControlMechanism.sol:   48:        require(pendingRoles[_role][msg.sender], "AccessControl: Role not pending"); ```  ## `lock` modifier in `NibblVault.sol` is unnecessary The function `buy()` in `NibblVault.sol` uses the `lock` modifier to prevent reentrancy. However, this is unneeded as: 1. All external calls are made to trusted contracts and cannot be hooked for reentrancy 2. `safeTransferETH` is used to transfer ETH only to `factory`, which is assumed to be a trusted contract   As such, `buy()` is not vulnerable to reentrancy and does not need the `lock` modifier. Furthermore, as `buy()` is the only function that uses the `lock` modifier, it can be removed from the contract entirely. This would help to save runtime and deployment gas costs.  ## Unnecessary definition of variables Some variables are defined even though they are only used once in their respective functions. Not defining these variables can help to reduce gas cost and contract size.  Instances include:   ```js contracts/NibblVault.sol:  378:        uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply; ```  ## Variables declared as `constant` are expressions, not constants Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was `immutable` instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.  See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232): > Consequences: each usage of a constant costs ~100 gas more on each access (it is still a little better than storing the result in storage, but not much). since these are not real constants, they cant be referenced from a real constant environment (e.g. from assembly, or from another library)  ```js contracts/NibblVault.sol:   51:        bytes32 private constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");  contracts/Utilities/AccessControlMechanism.sol:   12:        bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE");   13:        bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");   14:        bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE");  contracts/Utilities/EIP712Base.sol:    7:        bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(    8:            bytes(    9:                "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"   10:            )   11:        ); ```  Change these expressions from `constant` to `immutable` and implement the calculation in the constructor. Alternatively, hardcode these values in the constants and add a comment to say how the value was calculated.  ## Use `calldata` instead of `memory` for read-only function parameters If a reference type function parameter, such as arrays, is read-only, it is cheaper to use `calldata` instead of `memory`. This would help to save gas as values are read directly from calldata using `calldataload` and avoids additional intermediate memory operations.  Consider changing `memory` to `calldata` in the following functions: ```js contracts/Basket.sol:   41:        function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {   68:        function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {   91:        function withdrawMultipleERC20(address[] memory _tokens) external override {      contracts/NibblVault.sol:  504:        function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {  523:        function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {  545:        function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut { ```
#1 unmatch between comment and function (should be implementer_role) Impact Causing confuse to user and developer.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L156  Tool Used Manual review  Recommendation Mitigation Steps change from FEE_ROLE to IMPLEMENTER_ROLE   #2 Missing param natspec _totalSupply Impact _buyPrimaryCurve, _buySecondaryCurve, _sellPrimaryCurve and _sellSecondaryCurve function have natspec comment which is missing the _totalSupply function parameter. Issues with comments are low risk based on Code4rena risk categories.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L275  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L287  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L335  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L347  Tool Used Manual review  Recommendation Mitigation Steps Add natspec comments include _totalSupply parameter in function that mantion.   #3 Use call instead transfer Impact usage of send() or transfer() would cause an out of gas error.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L80  Tool Used Manual review  Recommendation Mitigation Steps use .call() because .transfer() fowards 2300 gas whereas .call() forwards all / set gas.    #4 Missing state admin Impact the constructor initialize _admin but the state admin was missing, and caused of it made constructor doesn't work properly.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L19  Tool Used Manual review  Recommendation Mitigation Steps i suggest to add state admin, so that the constructor can work to initialize param admin. and make it immutable   #5 constructor cant initialize the state Impact the constructor initialize _vaultImplementation, _feeTo, and _basketImplementation but the states was missing, and caused of it made constructor doesn't work properly.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L23  Tool Used Manual review  Recommendation Mitigation Steps i suggest to add state _vaultImplementation, _feeTo, and _basketImplementation, so that the constructor can work to initialize  _vaultImplementation, _feeTo, and _basketImplementation. and make it immutable    
## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | 1 | Setting `DEFAULT_ADMIN_ROLE` as the role admin is redundant | 1 | | 2 | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 23 | | 3 | Using `storage` instead of `memory` for structs/arrays saves gas | 2 | | 4 | State variables should be cached in stack variables rather than re-reading them from storage | 1 | | 5 | `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables | 7 | | 6 | `internal` functions only called once can be inlined to save gas | 1 | | 7 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement | 5 | | 8 | `<array>.length` should not be looked up in every loop of a `for`-loop | 6 | | 9 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 6 | | 10 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 7 | | 11 | Using `bool`s for storage incurs overhead | 1 | | 12 | Use a more recent version of solidity | 1 | | 13 | `>=` costs less gas than `>` | 1 | | 14 | It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied | 6 | | 15 | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 6 | | 16 | Splitting `require()` statements that use `&&` saves gas | 4 | | 17 | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 14 | | 18 | Using `private` rather than `public` for constants, saves gas | 3 | | 19 | Don't use `SafeMath` once the solidity version is 0.8.0 or greater | 1 | | 20 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 3 | | 21 | Empty blocks should be removed or emit something | 5 | | 22 | Use custom errors rather than `revert()`/`require()` strings to save gas | 41 | | 23 | Functions guaranteed to revert when called by normal users can be marked `payable` | 8 |  Total: 153 instances over 23 issues   ## Gas Optimizations  ### 1. Setting `DEFAULT_ADMIN_ROLE` as the role admin is redundant `DEFAULT_ADMIN_ROLE` is [automatically](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/83277ff916ac4f58fec072b8f28a252c1245c2f1/contracts/access/AccessControl.sol#L40-L48) designated as the role admin of any new role, so setting it again is a waste of gas since it involves fetching role-related state variables, updating state variables, and emitting an event  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  22           _setRoleAdmin(_defaultAdminRole, _defaultAdminRole); 23           _setRoleAdmin(FEE_ROLE, _defaultAdminRole); 24           _setRoleAdmin(PAUSER_ROLE, _defaultAdminRole); 25:          _setRoleAdmin(IMPLEMENTER_ROLE, _defaultAdminRole); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L22-L25  ### 2. Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution.   If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one  *There are 23 instances of this issue:* ```solidity File: contracts/Basket.sol  41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {  41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {  68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {  68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {  91:       function withdrawMultipleERC20(address[] memory _tokens) external override {  99:       function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {  104:      function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41  ```solidity File: contracts/NibblVaultFactory.sol  41:           string memory _name,  42:           string memory _symbol, ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L41  ```solidity File: contracts/NibblVault.sol  174:          string memory _tokenName,   175:          string memory _tokenSymbol,   504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {  504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {  523:      function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {  545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {  545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {  577:      function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L174  ### 3. Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There are 2 instances of this issue:* ```solidity File: contracts/Twav/Twav.sol   #1  38:               TwavObservation memory _twavObservationCurrent = twavObservations[(_index)]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L38  ```solidity File: contracts/Twav/Twav.sol   #2  39:               TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39  ### 4. State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  /// @audit secondaryReserveBalance on line 225 226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade  ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L226  ### 5. `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables  *There are 7 instances of this issue:* ```solidity File: contracts/NibblVault.sol  219:          feeAccruedCurator += _feeCurator;  225:          secondaryReserveBalance += _feeCurve;  242:          feeAccruedCurator += _feeCurator;  320:                  secondaryReserveBalance += _lowerCurveDiff;  380:                  primaryReserveBalance -= _saleReturn;  429:              totalUnsettledBids += _buyoutValuationDeposit;  457:          totalUnsettledBids -= _amount; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L219  ### 6. `internal` functions only called once can be inlined to save gas Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  27:       function getChainID() internal view returns (uint256 id) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L27  ### 7. Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There are 5 instances of this issue:* ```solidity File: contracts/NibblVault.sol  /// @audit require() on line 185 201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  /// @audit require() on line 404 406:          buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);  /// @audit require() on line 404 415:              safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));  /// @audit if-condition on line 373 378:                  uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;  /// @audit if-condition on line 414 415:              safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation)); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L201  ### 8. `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 9. `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 10. `require()`/`revert()` strings longer than 32 bytes cost extra gas Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**  *There are 7 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol  48:           require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low");  49:           require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender");  107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  141:          require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE");  149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48  ### 11. Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  16:       mapping(bytes32 => mapping(address => bool)) public pendingRoles; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L16  ### 12. Use a more recent version of solidity Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  4:    pragma solidity ^0.8.0; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4  ### 13. `>=` costs less gas than `>` The compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  224:          _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L224  ### 14. It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied Not overwriting the default for [stack variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves **8 gas**. Storage and memory variables have larger savings  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 15. `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) Saves **6 gas per loop**  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 16. Splitting `require()` statements that use `&&` saves gas See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper  *There are 4 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107  ```solidity File: contracts/NibblVaultFactory.sol   #2  131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131  ```solidity File: contracts/NibblVaultFactory.sol   #3  149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149  ```solidity File: contracts/NibblVaultFactory.sol   #4  166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166  ### 17. Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead > When using elements that are smaller than 32 bytes, your contracts gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  *There are 14 instances of this issue:* ```solidity File: contracts/NibblVault.sol  28:       uint32 private constant primaryReserveRatio = 200_000; //20%  57:       uint32 public secondaryReserveRatio;  183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));  303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  557:          uint8 v, ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28  ```solidity File: contracts/Twav/Twav.sol  6:            uint32 timestamp;  11:       uint8 public twavObservationsIndex;  12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks   13:       uint32 public lastBlockTimeStamp;  21:       function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {  22:           uint32 _timeElapsed;   37:               uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L6  ### 18. Using `private` rather than `public` for constants, saves gas If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table  *There are 3 instances of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  12:       bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12  ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #2  13:       bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L13  ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #3  14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L14  ### 19. Don't use `SafeMath` once the solidity version is 0.8.0 or greater Version 0.8.0 introduces internal overflow checks, so using `SafeMath` is redundant and adds overhead  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  9:    import { SafeMath } from  "@openzeppelin/contracts/utils/math/SafeMath.sol"; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L9  ### 20. Duplicated `require()`/`revert()` checks should be refactored to a modifier or function Saves deployment costs  *There are 3 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  42:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L42  ```solidity File: contracts/NibblVault.sol   #2  486:          require(msg.sender == curator,"NibblVault: Only Curator"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L486  ```solidity File: contracts/NibblVault.sol   #3  505:          require(msg.sender == bidder,"NibblVault: Only winner"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L505  ### 21. Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)  *There are 5 instances of this issue:* ```solidity File: contracts/Basket.sol  114:      receive() external payable {} ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L114  ```solidity File: contracts/NibblVaultFactory.sol  183:      receive() payable external {    } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L183  ```solidity File: contracts/NibblVault.sol  585:      receive() external payable {} ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L585  ```solidity File: contracts/Proxy/ProxyBasket.sol  56:       receive() external payable {    } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L56  ```solidity File: contracts/Proxy/ProxyVault.sol  56:       receive() external payable {    } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L56  ### 22. Use custom errors rather than `revert()`/`require()` strings to save gas Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hitby [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas  *There are 41 instances of this issue:* ```solidity File: contracts/Basket.sol  36:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  42:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  53:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  62:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  69:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  79:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  86:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  92:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L36  ```solidity File: contracts/NibblVaultFactory.sol  48:           require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low");  49:           require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender");  107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  141:          require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE");  149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48  ```solidity File: contracts/NibblVault.sol  129:          require(unlocked == 1, 'NibblVault: LOCKED');  139:          require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');  146:          require(status == Status.buyout, "NibblVault: status != buyout");  147:          require(buyoutEndTime <= block.timestamp, "NibblVault: buyoutEndTime <= now");  154:          require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');  184:          require(_secondaryReserveRatio <= primaryReserveRatio, "NibblVault: Excess initial funds");  185:          require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, "NibblVault: secResRatio too low");  325:          require(_minAmtOut <= _purchaseReturn, "NibblVault: Return too low");  351:          require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell");  387:          require(_saleReturn >= _minAmtOut, "NibblVault: Return too low");  399:          require(block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now");  400:          require(status == Status.initialized, "NibblVault: Status!=initialized");  404:          require(_buyoutBid >= _currentValuation, "NibblVault: Bid too low");  444:          require(status == Status.buyout, "NibblVault: Status!=Buyout");  475:          require(msg.sender == curator,"NibblVault: Only Curator");  486:          require(msg.sender == curator,"NibblVault: Only Curator");  496:          require(msg.sender == bidder,"NibblVault: Only winner");  505:          require(msg.sender == bidder,"NibblVault: Only winner");  516:          require(msg.sender == bidder, "NibblVault: Only winner");  524:          require(msg.sender == bidder, "NibblVault: Only winner");  536:          require(msg.sender == bidder, "NibblVault: Only winner");  546:          require(msg.sender == bidder, "NibblVault: Only winner");  561:          require(block.timestamp <= deadline, "NibblVault: expired deadline");  564:          require(signer == owner, "NibblVault: invalid signature");  570:          require(success, "NibblVault: ETH transfer failed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L129  ```solidity File: contracts/Utilities/AccessControlMechanism.sol  48:           require(pendingRoles[_role][msg.sender], "AccessControl: Role not pending"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L48  ### 23. Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 8 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol  99:       function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {  123:      function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {  140:      function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {  158:      function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {  173:      function pause() external onlyRole(PAUSER_ROLE) override {  179:      function unPause() external onlyRole(PAUSER_ROLE) override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99  ```solidity File: contracts/Utilities/AccessControlMechanism.sol  32:       function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external override onlyRole(getRoleAdmin(_role)) {  40:       function proposeGrantRole(bytes32 _role, address _to) external override onlyRole(getRoleAdmin(_role)) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L32 
## Summary  ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | 1 | Buyouts that occur during the timestamp wrap will have valuation errors | 1 | | 2 | `ecrecover()` not checked for signer address of zero | 1 | | 3 | Return values of `transfer()`/`transferFrom()` not checked | 4 | | 4 | Input array lengths may differ | 4 | | 5 | `_safeMint()` should be used rather than `_mint()` wherever possible | 1 | | 6 | Missing checks for `address(0x0)` when assigning values to `address` state variables | 6 | | 7 | Vulnerable to cross-chain replay attacks due to static `DOMAIN_SEPARATOR`/`domainSeparator` | 1 | | 8 | Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions | 1 | | 9 | Incorrect comments | 3 |  Total: 22 instances over 9 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | 1 | Consider addings checks for signature malleability | 1 | | 2 | Misleading variable name | 1 | | 3 | Inconsistent version of English being used | 2 | | 4 | Missing `initializer` modifier on constructor | 1 | | 5 | Contract implements interface without extending the interface | 1 | | 6 | `require()`/`revert()` statements should have descriptive reason strings | 1 | | 7 | `public` functions not called by the contract should be declared `external` instead | 3 | | 8 | Non-assembly method available | 1 | | 9 | `2**<n> - 1` should be re-written as `type(uint<n>).max` | 4 | | 10 | `constant`s should be defined rather than using magic numbers | 10 | | 11 | Cast is more restrictive than the type of the variable being assigned | 1 | | 12 | Missing event and or timelock for critical parameter change | 4 | | 13 | Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant` | 5 | | 14 | Inconsistent spacing in comments | 27 | | 15 | Lines are too long | 14 | | 16 | Non-library/interface files should use fixed compiler versions, not floating ones | 1 | | 17 | Typos | 14 | | 18 | File is missing NatSpec | 1 | | 19 | NatSpec is incomplete | 12 | | 20 | Event is missing `indexed` fields | 5 |  Total: 109 instances over 20 issues   ## Low Risk Issues  ### 1. Buyouts that occur during the timestamp wrap will have valuation errors The `_blockTimestamp` has a modulo applied, so at some point, there will be a timestamp with a value close to 2^32, followed by a timestamp close to zero. The `_updateTWAV` function does an unchecked subtraction of the two timestamps, so this will lead to an underflow, making the valuation based on a long time period rather than the actual one. Until more TWAV entries are added, valuations will be wrong  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  303              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); 304              if (_blockTimestamp != lastBlockTimeStamp) { 305:                 _updateTWAV(getCurrentValuation(), _blockTimestamp);    ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303-L305  ### 2. `ecrecover()` not checked for signer address of zero The `ecrecover()` function returns an address of zero when the signature does not match. This can cause problems if address zero is ever the owner of assets, and someone uses the permit function on address zero. If that happens, any invalid signature will pass the checks, and the assets will be stealable. In this case, the asset of concern is the vault's ERC20 token, and fortunately OpenZeppelin's implementation does a good job of making sure that address zero is never able to have a positive balance. If this contract ever changes to another ERC20 implementation that is laxer in its checks in favor of saving gas, this code may become a problem.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563  ### 3. Return values of `transfer()`/`transferFrom()` not checked Not all `IERC20` implementations `revert()` when there's a failure in `transfer()`/`transferFrom()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment  *There are 4 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  87:           IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87  ```solidity File: contracts/Basket.sol   #2  94:               IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94  ```solidity File: contracts/NibblVault.sol   #3  517:          IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517  ```solidity File: contracts/NibblVault.sol   #4  526:              IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526  ### 4. Input array lengths may differ If the caller makes a copy-paste error, the lengths may be mismatchd and an operation believed to have been completed may not in fact have been completed  *There are 4 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  41:      function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41  ```solidity File: contracts/Basket.sol   #2  68:      function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68  ```solidity File: contracts/NibblVault.sol   #3  545:     function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545  ```solidity File: contracts/NibblVault.sol   #4  504:     function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504  ### 5. `_safeMint()` should be used rather than `_mint()` wherever possible `_mint()` is [discouraged](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271) in favor of `_safeMint()` which ensures that the recipient is either an EOA or implements `IERC721Receiver`. Both [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L238-L250) and [solmate](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L180) have versions of this function  *There is 1 instance of this issue:* ```solidity File: contracts/Basket.sol   #1  24:           _mint(_curator, 0); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L24  ### 6. Missing checks for `address(0x0)` when assigning values to `address` state variables  *There are 6 instances of this issue:* ```solidity File: contracts/NibblVault.sol  191:          assetAddress = _assetAddress;  193:          curator = _curator;  487:          curator = _newCurator; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L191  ```solidity File: contracts/NibblVaultFactory.sol  100:         pendingBasketImplementation = _newBasketImplementation;  124:         pendingFeeTo = _newFeeAddress;  159:         pendingVaultImplementation = _newVaultImplementation; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100  ### 7. Vulnerable to cross-chain replay attacks due to static `DOMAIN_SEPARATOR`/`domainSeparator` See [this](https://github.com/code-423n4/2021-04-maple-findings/issues/2) issue from a prior contest for details  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  15       function INIT_EIP712(string memory name, string memory version) internal { 16           domainSeperator = keccak256( 17               abi.encode( 18                   EIP712_DOMAIN_TYPEHASH, 19                   keccak256(bytes(name)), 20                   keccak256(bytes(version)), 21                   getChainID(), 22                   address(this) 23               ) 24           ); 25:      } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15-L25  ### 8. Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20  ### 9. Incorrect comments  *There are 3 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  /// @audit ERC1155, not ERC721 58:      /// @notice withdraw an ERC721 token from this contract into your wallet ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L58  ```solidity File: contracts/Twav/Twav.sol   #2  /// @audit or zero if there have been fewer than four blocks 34:      /// @return _twav TWAV of the last 4 blocks ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34  ```solidity File: contracts/Twav/Twav.sol   #3  /// @audit of the last four updates, not necessarily of the last four blocks (i.e. may be blocked that were skipped) 34:      /// @return _twav TWAV of the last 4 blocks ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34  ## Non-critical Issues  ### 1. Consider addings checks for signature malleability Use OpenZeppelin's `ECDSA` contract rather than calling `ecrecover()` directly  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563  ### 2. Misleading variable name `_twavObservationPrev` is not the previous observation - it's more like the trailing, or next-to-expire TWAV observation`  *There is 1 instance of this issue:* ```solidity File: contracts/Twav/Twav.sol   #1  39:              TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39  ### 3. Inconsistent version of English being used Some functions use American English, whereas others use British English. A single project should use only one of the two  *There are 2 instances of this issue:* ```solidity File: contracts/NibblVault.sol   #1  173:     function initialize( ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L173  ```solidity File: contracts/Interfaces/IBasket.sol   #2  10:      function initialise(address _curator) external; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Interfaces/IBasket.sol#L10  ### 4. Missing `initializer` modifier on constructor OpenZeppelin [recommends](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the `initializer` modifier be applied to constructors in order to avoid potential griefs, [social engineering](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/4), or exploits. Ensure that the modifier is applied to the implementation contract. If the default constructor is currently being used, it should be changed to be an explicit one with the modifier applied.  *There is 1 instance of this issue:* ```solidity File: contracts/Basket.sol   #1  13:   contract Basket is IBasket, ERC721("NFT Basket", "NFTB"), Initializable { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13  ### 5. Contract implements interface without extending the interface Not extending the interface may lead to the wrong function signature being used, leading to unexpected behavior. If the interface is in fact being implemented, use the `override` keyword to indicate that fact  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  /// @audit onERC721Received(), onERC1155Received() 20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20  ### 6. `require()`/`revert()` statements should have descriptive reason strings  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  114:          require(_success); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114  ### 7. `public` functions not called by the contract should be declared `external` instead Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  *There are 3 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  64        function getVaultAddress( 65            address _curator, 66            address _assetAddress, 67            uint256 _assetTokenID, 68            uint256 _initialSupply, 69:           uint256 _initialTokenPrice) public view returns(address _vault) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L69  ```solidity File: contracts/NibblVaultFactory.sol   #2  76:       function getVaults() public view returns(ProxyVault[] memory ) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76  ```solidity File: contracts/Twav/Twav.sol   #3  44:       function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44  ### 8. Non-assembly method available  `assembly{ id := chainid() }` => `uint256 id = block.chainid`, `assembly { size := extcodesize() }` => `uint256 size = address().code.length`  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  29:               id := chainid() ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L29  ### 9. `2**<n> - 1` should be re-written as `type(uint<n>).max` Earlier versions of solidity can use `uint<n>(-1)` instead. Expressions not including the `- 1` can often be re-written to accomodate the change (e.g. by using a `>` rather than a `>=`, which will also save some gas)  *There are 4 instances of this issue:* ```solidity File: contracts/NibblVault.sol   #1  303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303  ```solidity File: contracts/NibblVault.sol   #2  365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L365  ```solidity File: contracts/NibblVault.sol   #3  413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32)); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L413  ```solidity File: contracts/NibblVault.sol   #4  445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L445  ### 10. `constant`s should be defined rather than using magic numbers Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals  *There are 10 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol  /// @audit 0xff 72:           bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));  /// @audit 0xff 91:           bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L72  ```solidity File: contracts/NibblVault.sol  /// @audit 1e18 183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));  /// @audit 1e18 195:          uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);  /// @audit 1e18 226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade   /// @audit 1e18 253:              return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));  /// @audit 32 303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  /// @audit 32 365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  /// @audit 32 413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));  /// @audit 32 445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183  ### 11. Cast is more restrictive than the type of the variable being assigned If `address foo` is being used in an expression such as `IERC20 token = FooToken(foo)`, then the more specific cast to `FooToken` is a waste because the only thing the compiler will check for is that `FooToken` extends `IERC20` - it won't check any of the function signatures. Therefore, it makes more sense to do `IERC20 token = IERC20(token)` or better yet `FooToken token = FooToken(foo)`. The former may allow the file in which it's used to remove the import for `FooToken`  *There is 1 instance of this issue:* ```solidity File: contracts/Proxy/ProxyBasket.sol   #1  /// @audit payable vs address 20:           implementation = payable(_implementation); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L20  ### 12. Missing event and or timelock for critical parameter change Events help non-contract tools to track changes, and events prevent users from being surprised by changes  *There are 4 instances of this issue:* ```solidity File: contracts/NibblVault.sol   #1  485       function updateCurator(address _newCurator) external override { 486           require(msg.sender == curator,"NibblVault: Only Curator"); 487           curator = _newCurator; 488:      } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L488  ```solidity File: contracts/NibblVaultFactory.sol   #2  100:         pendingBasketImplementation = _newBasketImplementation; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100  ```solidity File: contracts/NibblVaultFactory.sol   #3  124:         pendingFeeTo = _newFeeAddress; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L124  ```solidity File: contracts/NibblVaultFactory.sol   #4  159:         pendingVaultImplementation = _newVaultImplementation; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L159  ### 13. Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`  *There are 5 instances of this issue:* ```solidity File: contracts/NibblVault.sol  51:       bytes32 private constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L51  ```solidity File: contracts/Utilities/AccessControlMechanism.sol  12:       bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE");  13:       bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");  14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12  ```solidity File: contracts/Utilities/EIP712Base.sol  7         bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256( 8             bytes( 9                 "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" 10            ) 11:       ); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L7-L11  ### 14. Inconsistent spacing in comments Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file  *There are 27 instances of this issue:* ```solidity File: contracts/NibblVault.sol  28:       uint32 private constant primaryReserveRatio = 200_000; //20%  34:       uint256 private constant REJECTION_PREMIUM = 150_000; //15%  46:       uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%  122:      ///@notice current status of vault  125:      ///@notice reenterancy guard  200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  220:          //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault  221:          //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance  226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade   228:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract  244:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract  301:          //Make update on the first tx of the block  318:                  //Gas Optimization  363:          //Make update on the first tx of the block  368:                  _rejectBuyout(); //For the case when TWAV goes up when updated on sell  377:                  //Gas Optimization  389:          safeTransferETH(_to, _saleReturn); //send _saleReturn to _to  402:          //_buyoutBid: Bid User has made  448:              _rejectBuyout(); //For the case when TWAV goes up when updated externally  500:      ///@notice withdraw multiple ERC721s ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28  ```solidity File: contracts/Proxy/ProxyBasket.sol  28:       //solhint-disable-next-line no-complex-fallback  31:           //solhint-disable-next-line no-inline-assembly ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L28  ```solidity File: contracts/Proxy/ProxyVault.sol  28:       //solhint-disable-next-line no-complex-fallback  31:           //solhint-disable-next-line no-inline-assembly ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L28  ```solidity File: contracts/Twav/Twav.sol  12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks   28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L12  ### 15. Lines are too long Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length  *There are 14 instances of this issue:* ```solidity File: contracts/Basket.sol  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L109  ```solidity File: contracts/NibblVaultFactory.sol  50:           _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this)))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L50  ```solidity File: contracts/NibblVault.sol  19:   /// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.  79:       /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply   201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  224:          _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance  226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade   263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance  266:              return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);  297:      /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both  358:      /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both  395:      /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L19  ```solidity File: contracts/Twav/Twav.sol  28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative  40:               _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L28  ### 16. Non-library/interface files should use fixed compiler versions, not floating ones  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  4:    pragma solidity ^0.8.0; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4  ### 17. Typos  *There are 14 instances of this issue:* ```solidity File: contracts/NibblVault.sol  /// @audit reenterancy 125:      ///@notice reenterancy guard  /// @audit pausablity 152:      /// @dev pausablity implemented in factory  /// @audit primaryReseveRatio 200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  /// @audit primaryReseveRatio 201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  /// @audit continous 250:      /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply  /// @audit seconday 263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance  /// @audit continous 270:      /// @param _amount amount of reserve tokens to buy continous tokens  /// @audit continous 282:      /// @param _amount amount of reserve tokens to buy continous tokens  /// @audit Continous 359:      /// @param _amtIn Continous Tokens to be sold  /// @audit recieve 361:      /// @param _to Address to recieve the reserve token to  /// @audit airdops 512:      /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops   /// @audit airdops 531:      /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops  ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L125  ```solidity File: contracts/Proxy/ProxyBasket.sol  /// @audit internall 26:        * This function does not return to its internall call site, it will return directly to the external caller. ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L26  ```solidity File: contracts/Proxy/ProxyVault.sol  /// @audit internall 26:        * This function does not return to its internall call site, it will return directly to the external caller. ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L26  ### 18. File is missing NatSpec  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol (various lines)   #1  ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol  ### 19. NatSpec is incomplete  *There are 12 instances of this issue:* ```solidity File: contracts/Basket.sol  /// @audit Missing: '@param _to' 32        /// @notice withdraw an ERC721 token from this contract into your wallet 33        /// @param _token the address of the NFT you are withdrawing 34        /// @param _tokenId the ID of the NFT you are withdrawing 35:       function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {  /// @audit Missing: '@param _to' 49        /// @notice withdraw an ERC721 token from this contract into your wallet 50        /// @param _token the address of the NFT you are withdrawing 51        /// @param _tokenId the ID of the NFT you are withdrawing 52:       function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {  /// @audit Missing: '@param _to' 58        /// @notice withdraw an ERC721 token from this contract into your wallet 59        /// @param _token the address of the NFT you are withdrawing 60        /// @param _tokenId the ID of the NFT you are withdrawing 61:       function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L32-L35  ```solidity File: contracts/NibblVaultFactory.sol  /// @audit Missing: '@return' 36        /// @param _initialTokenPrice desired initial token price 37        /// @param _minBuyoutTime minimum time after which buyout can be triggered 38        function createVault( 39            address _assetAddress, 40            address _curator, 41            string memory _name, 42            string memory _symbol, 43            uint256 _assetTokenID, 44            uint256 _initialSupply, 45            uint256 _initialTokenPrice, 46            uint256 _minBuyoutTime 47:           ) external payable override whenNotPaused returns(address payable _proxyVault) {  /// @audit Missing: '@return' 62        /// @param _initialSupply desired initial token supply 63        /// @param _initialTokenPrice desired initial token price     64        function getVaultAddress( 65            address _curator, 66            address _assetAddress, 67            uint256 _assetTokenID, 68            uint256 _initialSupply, 69:           uint256 _initialTokenPrice) public view returns(address _vault) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L36-L47  ```solidity File: contracts/NibblVault.sol  /// @audit Missing: '@param _totalSupply' 269       /// @notice function to buy tokens on the primary curve 270       /// @param _amount amount of reserve tokens to buy continous tokens 271       /// @dev This is executed when current supply >= initial supply 272       /// @dev _amount is charged with fee 273       /// @dev _purchaseReturn is minted to _to 274       /// @return _purchaseReturn Purchase return 275:      function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {  /// @audit Missing: '@param _totalSupply' 281       /// @notice function to buy tokens on secondary curve 282       /// @param _amount amount of reserve tokens to buy continous tokens 283       /// @dev This is executed when current supply < initial supply 284       /// @dev only admin and curator fee is charged in secondary curve 285       /// @dev _purchaseReturn is minted to _to 286       /// @return _purchaseReturn Purchase return 287:      function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {  /// @audit Missing: '@return' 298       /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails. 299       /// @param _to Address to mint the purchase return to 300:      function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {  /// @audit Missing: '@param _totalSupply' 330       /// @notice The function to sell fractional tokens on primary curve 331       /// @dev Executed when currentSupply > initialSupply 332       /// @dev _amount is charged with fee 333       /// @param _amount Amount of tokens to be sold on primary curve 334       /// @return _saleReturn Sale Return 335:      function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {  /// @audit Missing: '@param _totalSupply' 342       /// @notice The function to sell fractional tokens on secondary curve 343       /// @dev Executed when current supply <= initial supply 344       /// @dev only admin and curator fee is charged in secondary curve 345       /// @param _amount Amount of tokens to be sold on SecondaryCurve 346       ///  @return _saleReturn Sale Return 347:      function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){  /// @audit Missing: '@return' 360       /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails. 361       /// @param _to Address to recieve the reserve token to 362:      function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {  /// @audit Missing: '@return' 472       /// @param _to the address where curator fee will be sent 473       /// @dev can only be called by curator 474:      function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L269-L275  ### 20. Event is missing `indexed` fields Each `event` should use three `indexed` fields if there are three or more fields  *There are 5 instances of this issue:* ```solidity File: contracts/Basket.sol  15:       event DepositERC721(address indexed token, uint256 tokenId, address indexed from);  16:       event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);  17:       event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);  18:       event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);  19:       event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L15  
**Overview**  Risk Rating | Number of issues --- | --- Gas Issues | 19  **Table of Contents:**  - [1. Use of the `memory` keyword when `storage` should be used](#1-use-of-the-memory-keyword-when-storage-should-be-used) - [2. Unchecking arithmetics operations that can't underflow/overflow](#2-unchecking-arithmetics-operations-that-cant-underflowoverflow) - [3. Caching storage values in memory](#3-caching-storage-values-in-memory) - [4. Cheap Contract Deployment Through Clones](#4-cheap-contract-deployment-through-clones) - [5. Reduce the size of error messages (Long revert Strings)](#5-reduce-the-size-of-error-messages-long-revert-strings) - [6. SafeMath is not needed when using Solidity version 0.8+](#6-safemath-is-not-needed-when-using-solidity-version-08) - [7. Duplicated conditions should be refactored to a modifier or function to save deployment costs](#7-duplicated-conditions-should-be-refactored-to-a-modifier-or-function-to-save-deployment-costs) - [8. Internal/Private functions only called once can be inlined to save gas](#8-internalprivate-functions-only-called-once-can-be-inlined-to-save-gas) - [9. `>=` is cheaper than `>` (and `<=` cheaper than `<`)](#9--is-cheaper-than--and--cheaper-than-) - [10. Splitting `require()` statements that use `&&` saves gas](#10-splitting-require-statements-that-use--saves-gas) - [11. Using private rather than public for constants saves gas](#11-using-private-rather-than-public-for-constants-saves-gas) - [12. Amounts should be checked for 0 before calling a transfer](#12-amounts-should-be-checked-for-0-before-calling-a-transfer) - [13. `<array>.length` should not be looked up in every loop of a `for-loop`](#13-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop) - [14. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#14-i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [15. Increments/decrements can be unchecked in for-loops](#15-incrementsdecrements-can-be-unchecked-in-for-loops) - [16. Public functions to external](#16-public-functions-to-external) - [17. It costs more gas to initialize variables with their default value than letting the default value be applied](#17-it-costs-more-gas-to-initialize-variables-with-their-default-value-than-letting-the-default-value-be-applied) - [18. Use Custom Errors instead of Revert Strings to save Gas](#18-use-custom-errors-instead-of-revert-strings-to-save-gas) - [19. Functions guaranteed to revert when called by normal users can be marked `payable`](#19-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable)  ## 1. Use of the `memory` keyword when `storage` should be used  Here, the `storage` keyword should be used instead of `memory`:  ```diff File: Twav.sol 35:     function _getTwav() internal view returns(uint256 _twav){ 36:         if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) { 37:             uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS; - 38:             TwavObservation memory _twavObservationCurrent = twavObservations[(_index)]; + 38:             TwavObservation storage _twavObservationCurrent = twavObservations[(_index)]; - 39:             TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; + 39:             TwavObservation storage _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; 40:             _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp); 41:         } 42:     } ```  ## 2. Unchecking arithmetics operations that can't underflow/overflow  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  Consider wrapping with an `unchecked` block here:  - File: NibblVault.sol  ```diff 311:         if (_totalSupply >= _initialTokenSupply) { ... 313:         } else { ... - 319:                 _purchaseReturn = _initialTokenSupply - _totalSupply;  + 319:                 unchecked { _purchaseReturn = _initialTokenSupply - _totalSupply; } ```  ```diff 373:         if(_totalSupply > _initialTokenSupply) { ... - 378:                 uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply; + 378:                 unchecked { uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply; } ```  ```diff 414:         if (_buyoutBid > _currentValuation) { - 415:             safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation)); + 415:             unchecked { safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation) }); ```  ## 3. Caching storage values in memory  The code can be optimized by minimising the number of SLOADs.  SLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.  See the `@audit` tags for details about the multiple SLOADs where a cached value should be used instead of `SLOAD 2` and above:  - `twavObservationsIndex`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L27-L29>  ```solidity File: Twav.sol 27:         uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation; 28:         twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative 29:         twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS; ```  - `secondaryReserveBalance`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L222-L226>  ```solidity File: NibblVault.sol 222:         uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance; ... 226:         secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade  ```  - `secondaryReserveBalance`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L314-L320>  ```solidity File: NibblVault.sol 314:             uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance; ... 320:                 secondaryReserveBalance += _lowerCurveDiff; ```  - `primaryReserveBalance`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L379-L380>  ```solidity File: NibblVault.sol 379:                 _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance; 380:                 primaryReserveBalance -= _saleReturn; ```  - `basketUpdateTime`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107>  ```solidity File: NibblVaultFactory.sol 107:         require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  - `feeToUpdateTime`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131>  ```solidity File: NibblVaultFactory.sol 131:         require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  - `vaultUpdateTime`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166>  ```solidity File: NibblVaultFactory.sol 166:         require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  ## 4. Cheap Contract Deployment Through Clones  See `@audit` tag:  ```solidity 67:     function _executeTransfer(address _owner, uint256 _idx) internal { 68:         (bytes32 salt, ) = precompute(_owner, _idx); 69:         new FlashEscrow{salt: salt}( //@audit gas: deployment can cost less through clones 70:             nftAddress, 71:             _encodeFlashEscrowPayload(_idx) 72:         ); 73:     } ```  ```solidity NibblVaultFactory.sol:50:        _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this)))); NibblVaultFactory.sol:81:        address payable _basketAddress = payable(new ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation)); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  Consider applying a similar pattern, here with a `cloneDeterministic` method to mimic the current `create2`  ## 5. Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity NibblVaultFactory.sol:48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low"); NibblVaultFactory.sol:49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender"); NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE"); NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  Consider shortening the revert strings to fit in 32 bytes.  ## 6. SafeMath is not needed when using Solidity version 0.8+  Solidity version 0.8+ already implements overflow and underflow checks by default. Using the SafeMath library from OpenZeppelin (which is more gas expensive than the 0.8+ overflow checks) is therefore redundant.  Consider using the built-in checks instead of SafeMath and remove SafeMath here:  ```solidity NibblVaultFactory.sol:3:pragma solidity 0.8.10; NibblVaultFactory.sol:9:import { SafeMath } from  "@openzeppelin/contracts/utils/math/SafeMath.sol"; ```  ## 7. Duplicated conditions should be refactored to a modifier or function to save deployment costs  ```solidity Basket.sol:36:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:42:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:53:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:62:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:69:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:79:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:86:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:92:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ```  ```solidity NibblVault.sol:475:        require(msg.sender == curator,"NibblVault: Only Curator"); NibblVault.sol:486:        require(msg.sender == curator,"NibblVault: Only Curator"); ```  ```solidity NibblVault.sol:496:        require(msg.sender == bidder,"NibblVault: Only winner"); NibblVault.sol:505:        require(msg.sender == bidder,"NibblVault: Only winner"); NibblVault.sol:516:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:524:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:536:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:546:        require(msg.sender == bidder, "NibblVault: Only winner"); ```  ## 8. Internal/Private functions only called once can be inlined to save gas  Not inlining costs 20 to 40 gas because of two extra `JUMP` instructions and additional stack operations needed for function calls.  Affected code:  - `NibblVault.sol#getMaxSecondaryCurveBalance()` ```solidity contracts/NibblVault.sol:   252:     function getMaxSecondaryCurveBalance() private view returns(uint256){   314:             uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance; ```  ## 9. `>=` is cheaper than `>` (and `<=` cheaper than `<`)  Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas). This also holds true between `<=` and `<`.    Consider replacing strict inequalities with non-strict ones to save some gas here:  ```solidity NibblVault.sol:224:        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance ```  ## 10. Splitting `require()` statements that use `&&` saves gas  If you're using the Optimizer at 200, instead of using the `&&` operator in a single require statement to check multiple conditions, Consider using multiple require statements with 1 condition per require statement:  ```solidity NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  Please, note that this might not hold true at a higher number of runs for the Optimizer (10k). However, it indeed is true at 200.  ## 11. Using private rather than public for constants saves gas  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  ```solidity Utilities/AccessControlMechanism.sol:12:    bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE"); Utilities/AccessControlMechanism.sol:13:    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE"); Utilities/AccessControlMechanism.sol:14:    bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE"); Utilities/NibblVaultFactoryData.sol:7:    uint256 public constant MAX_ADMIN_FEE = 10_000; //1%  ```  ## 12. Amounts should be checked for 0 before calling a transfer  Checking non-zero transfer values can avoid an expensive external call and save gas (especially in loops, like in `NibblVault.sol#withdrawMultipleERC20()`).    Consider adding a non-zero-value check here:  ```solidity   Basket.sol:80:        _to.transfer(address(this).balance); Basket.sol:87:        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this))); Basket.sol:94:            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this))); NibblVault.sol:517:        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this))); NibblVault.sol:526:            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this))); ```    ## 13. `<array>.length` should not be looked up in every loop of a `for-loop`  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, Consider storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  ## 14. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, "This will be false as i is incremented after the comparison"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, "This will be true as i is incremented before the comparison"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## 15. Increments/decrements can be unchecked in for-loops  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Affected code:    ```solidity Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  The change would be:      ```diff - for (uint256 i; i < numIterations; i++) { + for (uint256 i; i < numIterations;) {  // ...   +   unchecked { ++i; } }   ```  The same can be applied with decrements (which should use `break` when `i == 0`).  The risk of overflow is non-existant for `uint256` here.  ## 16. Public functions to external  An external call cost is less expensive than one of a public function. The following functions could be set external to save gas and improve code quality (extracted from Slither).  ```solidity Twav/Twav.sol:44:    function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) { NibblVaultFactory.sol:76:    function getVaults() public view returns(ProxyVault[] memory ) { ```  ## 17. It costs more gas to initialize variables with their default value than letting the default value be applied  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Affected code:  ```solidity Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  Consider removing explicit initializations for default values.  ## 18. Use Custom Errors instead of Revert Strings to save Gas  Solidity 0.8.4 introduced custom errors. They are more gas efficient than revert strings, when it comes to deploy cost as well as runtime cost when the revert condition is met. Use custom errors instead of revert strings for gas savings.  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Consider replacing all revert strings with custom errors in the solution.  ```solidity Utilities/AccessControlMechanism.sol:48:        require(pendingRoles[_role][msg.sender], "AccessControl: Role not pending"); Basket.sol:36:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:42:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:53:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:62:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:69:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:79:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:86:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:92:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); NibblVault.sol:129:        require(unlocked == 1, 'NibblVault: LOCKED'); NibblVault.sol:139:        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out'); NibblVault.sol:146:        require(status == Status.buyout, "NibblVault: status != buyout"); NibblVault.sol:147:        require(buyoutEndTime <= block.timestamp, "NibblVault: buyoutEndTime <= now"); NibblVault.sol:154:        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused'); NibblVault.sol:184:        require(_secondaryReserveRatio <= primaryReserveRatio, "NibblVault: Excess initial funds"); NibblVault.sol:185:        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, "NibblVault: secResRatio too low"); NibblVault.sol:325:        require(_minAmtOut <= _purchaseReturn, "NibblVault: Return too low"); NibblVault.sol:351:        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell"); NibblVault.sol:387:        require(_saleReturn >= _minAmtOut, "NibblVault: Return too low"); NibblVault.sol:399:        require(block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now"); NibblVault.sol:400:        require(status == Status.initialized, "NibblVault: Status!=initialized"); NibblVault.sol:404:        require(_buyoutBid >= _currentValuation, "NibblVault: Bid too low"); NibblVault.sol:444:        require(status == Status.buyout, "NibblVault: Status!=Buyout"); NibblVault.sol:475:        require(msg.sender == curator,"NibblVault: Only Curator"); NibblVault.sol:486:        require(msg.sender == curator,"NibblVault: Only Curator"); NibblVault.sol:496:        require(msg.sender == bidder,"NibblVault: Only winner"); NibblVault.sol:505:        require(msg.sender == bidder,"NibblVault: Only winner"); NibblVault.sol:516:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:524:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:536:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:546:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:561:        require(block.timestamp <= deadline, "NibblVault: expired deadline"); NibblVault.sol:564:        require(signer == owner, "NibblVault: invalid signature"); NibblVault.sol:570:        require(success, "NibblVault: ETH transfer failed"); NibblVaultFactory.sol:48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low"); NibblVaultFactory.sol:49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender"); NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:114:        require(_success); NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE"); NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  ## 19. Functions guaranteed to revert when called by normal users can be marked `payable`  If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.  ```solidity Utilities/AccessControlMechanism.sol:32:    function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external override onlyRole(getRoleAdmin(_role)) { Utilities/AccessControlMechanism.sol:40:    function proposeGrantRole(bytes32 _role, address _to) external override onlyRole(getRoleAdmin(_role)) { NibblVaultFactory.sol:99:    function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) { NibblVaultFactory.sol:123:    function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) { NibblVaultFactory.sol:140:    function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) { NibblVaultFactory.sol:158:    function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) { NibblVaultFactory.sol:173:    function pause() external onlyRole(PAUSER_ROLE) override { NibblVaultFactory.sol:179:    function unPause() external onlyRole(PAUSER_ROLE) override { ``` 
### [G01] Public Functions that can be External  The following functions are never called in their contracts and can be switched to external to save gas: [NibblVaultFactory.sol#L64-L69](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L69) [NibblVaultFactory.sol#L76](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76) [NibblVaultFactory.sol#L80](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80) [NibblVaultFactory.sol#L88](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88) [Twav.sol#L44](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44)   ### [G02] Unchecked Increments in Loops  When incrementing i in for loops there is no chance of overflow so unchecked can be used to save gas. I ran a simple test in remix and found deployment savings of 31,653 gas and on each function call saved ~141 gas per iteration.  ``` contract Test {  function loopTest() external {   for (uint256 i; i < 1; ++i) {   Deployment Cost: 125,637, Cost on function call: 24,601   vs   for (uint256 i; i < 1; ) {   // for loop body   unchecked { ++i }   Deployment Cost: 93,984, Cost on function call: 24,460   }  } } ```  For loops that can use unchecked increments: [NibblVault.sol#L506](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506) [NibblVault.sol#L525](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525) [NibblVault.sol#L547](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547) [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43) [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70) [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93)   ### [G03] Pre Increments in Loops  In for loops pre increments can also be used to save a small amount of gas per iteration. I ran a test in remix using a for loop and found the deployment savings of 497 gas and ~5 gas per iteration.  ``` contract Test {  function loopTest() external {   for (uint256 i; i < 1; i++) {   (Deployment cost: 118,408, Cost on function call: 24,532)   vs   for (uint256 i; i < 1; ++i) {   (Deployment cost: 117,911, Cost on function call: 24,527)   }  } } ```  For loops that can use pre increments: [NibblVault.sol#L506](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506) [NibblVault.sol#L525](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525) [NibblVault.sol#L547](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547) [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43) [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70) [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93)   ### [G04] Custom Errors As your using a solidity version > 0.8.4 for most of the contracts you can replace revert strings with custom errors. This will save in deployment costs and runtime costs. I ran a test in remix comparing a revert string vs custom errors and found that replacing a single revert string with a custom error saved 12,404 gas in deployment cost and 86 gas on each function call.   ``` contract Test {  uint256 a;  function check() external {   require(a != 0, "check failed");  } }   (Deployment cost: 114,703, Cost on Function call: 23,392) vs  contract Test {  uint256 a;  error checkFailed();  function check() external {   if (a != 0) revert checkFailed();  } }   (Deployment cost: 102,299, Cost on Function call: 23,306) ```  There are 41 revert strings throughout your contracts that can be replaced with custom errors.   ### [G05] Long Revert Strings  If you opt not to use custom errors keeping revert strings <= 32 bytes in length will save gas.  I ran a test in remix and found the savings for a single short revert string vs long string to be 9,377 gas in deployment cost and 18 gas on function call.  ``` contract Test {  uint256 a;  function check() external {   require(a != 0, "short error message");    (Deployment cost: 114,799, Cost on function call: 23,392)    vs    require(a != 0, "A longer Error Message over 32 bytes in              length");    (Deployment cost: 124,176, Cost on function call: 23,410)   } } ```  I recommend shortenning the following revert strings to < 32 bytes in length: [NibblVaultFactory.sol#L48-L49](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48-L49) [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107) [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131) [NibblVaultFactory.sol#L141](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141) [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149) [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)   ### [G06] && in Require Statements  If optimising for runtime costs over deployment costs you can seperate && in require functions into 2 parts. I ran a basic test in remix and it cost an extra 234 gas to deploy but will save ~9 gas everytime the require function is called.  ``` contract Test {  uint256 a = 0;  uint256 b = 1;   function test() external {   require(a == 0 && b > a)    (Deployment cost: 123,291, Cost on function call: 29,371)   vs   require(a == 0);   require(b > a);   (Deployment cost: 123,525, Cost on function call: 29,362)  } } ```  Require statements that can be split up: [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107) [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131) [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149) [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)   ### [G07] Packing Variables  Moving the uint32 variable primaryReserveRatio down to line 52  will it allow it to be stored with secondaryReserveRatio and use 1 less storage slot (save 20,000 gas). [NibblVault.sol#L28](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28)   ### [G08] Calldata Over Memory  When using function arguments that you only need to reference and not make any modifications to it is cheaper to use calldata than memory.  Instances where calldata can be used instead of memory: [NibblVaultFactory.sol#L41-L42](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L41-L42) [NibblVaultFactory.sol#L80](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80) [NibblVaultFactory.sol#L88](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88) [NibblVault.sol#L174-L175](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L174-L175) [NibblVault.sol#L504](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504) [NibblVault.sol#L523](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L523) [NibblVault.sol#L545](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545) [Basket.sol#L41](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41) [Basket.sol#L68](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68) [Basket.sol#L91](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L91) [EIP712Base.sol#L15](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15)  ### [G09] Minimize SLOAD's Whenever referencing a storage variable more than once in a function without modifying it, it is cheaper to cache locally and use that instead.  (normally 100 gas each use vs 103 gas to SLOAD/MSTORE for the first use and then only 3 gas for any others)  [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107) can cache basketUpdateTime (save ~97 gas) [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131) can cache feeToUpdateTime (save ~97 gas) [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149) can cache feeAdminUpdateTime (save ~97 gas) [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166) can cache vaultUpdateTime (save ~97 gas) For the previous 4 make sure to only use cached variables when referencing not when deleting. [NibblVault.sol#L139](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L139) can cache buyoutEndTime (save ~97 gas) [Twav.sol#L27-L29](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L27-L29) can cache twavObservationsIndex (save ~194 gas) On line 29 ensure the cached value is only used on the right side of the assignment.   ### [G10] Using smaller than 32 byte uints (uint256) can cost more As explained in [Solidity Docs](https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html) using elements smaller than 32 bytes can cost more gas. Recommend replacing the follpwing with uint256: [Twav.sol#L22](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L22) [Twav.sol#L37](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L37) 
# Low Risk Vulnerabilities ## 1. `getBasketAddress` could return inaccurate value if `basketImplementation` changes It is possible that the `basketImplementation` gets upgraded to a new address. If an integrator relies on `getBasketAddress` to deterministically determine the  address of a basket that has been deployed using the old implementation, it will return the incorrect address.  ### Recommended Mitigation Steps Consider adding an extra parameter `_implementation` or overload the function with the extra parameter: ``` function getBasketAddress(address _curator, string memory _mix, address _basketImplementation) public override view returns(address _basket) {     bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix));     bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(_basketImplementation)));     bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));     _basket = address(uint160(uint256(hash)));      } ```  ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88-L93  ## 2. Missing sanity check on `_minBuyoutTime` When creating a vault, a faulty deployment payload could set `minBuyoutTime` to a very high value, virtually disabling the buyout function.  ### Recommended Mitigation Steps Consider adding a sanity check to make sure it's set within a reasonable value: ``` require(_minBuyoutTime <= 52 weeks, "NibblVault: minBuyoutTime must not be longer than one year"); ``` ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L202  ## 3. Check `_feeAdmin` instead of `_adminFeeAmt` When charging fee in `_chargeFee` and `_chargeFeeSecondaryCurve`, there's a check to ensure `_adminFeeAmt` is larger than zero before transferring the funds to `feeAdmin`.  It is possible for `_adminFeeAmt` to be higher than zero yet `_feeAdmin` returns zero because of rounding. Therefore, it will be more accurate to use `_feeAdmin` instead. ### PoC ``` uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ; ``` When `_amount  * _adminFeeAmt` is lower than `SCALE`, `_feeAdmin` will have the value of `0`. ### Recommended Mitigation Steps Check that `_feeAdmin` is larger than `0` instead: ``` if(_feeAdmin > 0) {     safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract } ``` ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L227 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L243  # Non-Critical Vulnerabilities ## 1. Uncustomizable Basket details When creating a basket, the basket name and symbol is fixed to "NFT Basket" and "NFTB" respectively. It would be hard for users to distinguish one basket from another when seen through etherscan or wallets.   ### Recommended Mitigation Steps Consider adding an extra parameter so basket creator can append a unique identifier for the baskets. For instance, when making a basket containing CryptoPunks, the name and symbol would be: ``` NFT Basket - Punks NFTB-PUNKS ``` ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L82 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13  
1. Use != 0 instead of > 0 for uint variables - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L227 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L243   2. No need to initialize variables with default values - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  3. Use ++i instead of i++, i+=1, also unchecked increments in for-loops will save gas cost - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  4. An arrays length should be cached to save gas in for-loops - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  5. Non-strict inequalities are cheaper than strict ones - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L224  6. Usage of unchecked can reduce the gas cost - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L319 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L378  7. require()/revert() strings longer than 32 bytes cost extra gas - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L49 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L105 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166  8. Check zero amount before transfer - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L458 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L468 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L478  9. Check "_feeAdmin != 0" instead of "_adminFeeAmt > 0". The real transfer amount is _feeAdmin and this value might be zero even though _adminFeeAmt > 0 according to [fee calculation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L216)  - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L227 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L243   10. Needless calculation From the calculation, we can see "(_index + 1) % TWAV_BLOCK_NUMBERS" is same as "twavObservationsIndex" because "_index" is the previous index of "twavObservationsIndex".  - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39
# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L36   # Vulnerability details  ## Impact The "if" condition of Twav._getTwav() is missing some edge cases. In this case, this function will return 0 which is different from the correct value and it will affect the main functions like NibblVault.buy() and NibblVault.sell().  ## Proof of Concept I think this condition is to confirm at least 4 values were saved for twav calculation. Btw this timestamp would be zero even though there are more than 4 values properly as it's modularized by 2**32. In this case, the if condition will be false and this function will return 0.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps I see "cumulativeValuation" is increasing all the time and recommend replacing "timestamp" with "cumulativeValuation". ``` if (twavObservations[TWAV_BLOCK_NUMBERS - 1].cumulativeValuation != 0) { ```  
# [L-01] `ecrecover` does not check for zero address  The solidity `ecrecover` function is called directly to verify the given signatures. However, the `ecrecover` EVM opcode allows malleable (non-unique) signatures and thus is susceptible to replay attacks. A replay attack may not be possible here, but ensuring the signatures are not malleable is considered a best practice.  https://github.com/code-423n4/2022-06-nibbl/tree/main/contracts/NibblVault.sol#L563  ## Recommended Mitigation Steps  Use the `recover` function from [OpenZeppelin's ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) for signature verification. This is what OpenZeppelin does in their [ERC20 permit implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/83277ff916ac4f58fec072b8f28a252c1245c2f1/contracts/token/ERC20/extensions/draft-ERC20Permit.sol#L64).
# `Twav.sol`  ## `timestamp` in `TwavObservation` is declared as `uint32` but cannot be packed with other variables  Usually, it makes sense to try to follow a Tight Variable Packing approach to not waste gas, but in this case, it's useless and will only cost more gas.  The `timestamp` variable inside the struct will anyway take a whole slot because after it's declaration we have `cumulativeValuation` that is a `uint256`.  Declaring `timestamp` as a `uint256` will allow `NibblVault` to waste less gas because there is no more need to perform all the math + cast operations done on the timestamp (example: `uint32 _blockTimestamp = uint32(block.timestamp % 2**32);`).  Consider change the type of `timestamp` to a `uint256` 
# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L173 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L23 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99   # Vulnerability details  ## Impact In OpenZeppelin Contracts (proxy/utils/Initializable.sol): > CAUTION: An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation...   ## Proof of Concept This can lead to takeover of 2 contracts: `Basket.sol` and `NibblVault.sol` since implementation contracts not initialized and can be initialized publicly. https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol   Also, Upgrading either of their implementation in `NibblVaultFactory.sol` when  `proposeNewVaultImplementation(address _newVaultImplementation)` or `proposeNewBasketImplementation(address _newBasketImplementation)` can lead to the same issue if the upgraded contract did not disable initializers. https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99    ## Recommended Mitigation Steps As its mentioned in OpenZeppelin Contracts documentation:  >To prevent the implementation contract from being used, you should invoke the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:   ``` /// @custom:oz-upgrades-unsafe-allow constructor     constructor() {         _disableInitializers();     } ```  Should both of `Basket.sol` and `NibbleVault.sol` use the `_disableInitializers();` which make the implementation contract unable to be initialized to version 1. Hence, for newer version of `Basket.sol` and `NibbleVault.sol` proposed for the factory should also be initialized to version 1 to prevent the attack https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L165 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L130  
 DEFAULT_ADMIN_ROLE is already default admin role for all roles https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/AccessControlMechanism.sol#L22-25 Those lines are obsolete  --------------------------------------------------------------- Unused receive() function will lock Ether in contract  If the intention is for the Ether to be used, the function should call another function, otherwise it should revert https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L183 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L585 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L114 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyBasket.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyVault.sol#L56  -----------------------------------------------------------  Missing checks for address(0x0) when assigning values to address state variables  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L193 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L191 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L487 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L124 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L132 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L159 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L167  -----------------------------------------------------------  public functions not called by the contract should be declared external instead  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L69 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L76 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L80 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L88 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Twav/Twav.sol#L44  --------------------------------------------------------------------------- Use a more recent version of solidity  Use a solidity version of at least 0.8.12 to get string.concat() to be used instead of abi.encodePacked(,) ----------------------------------------------------------- 
1. Unbounded loops The following contains a for loop that can be unbounded. This would mean it could run out of gas and the function would revert   **Occurrences in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L93 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L93 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L506 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547     2. Missing input validation on array lengths The functions below fail to perform input validation on arrays to verify the lengths match. A mismatch could lead to an exception or undefined behavior.  **Occurences in: NibblVault.withdrawMultipleERC721() -  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L504 NibblVault.withdrawMultipleERC1155() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L545 NibblVault.onERC1155BatchReceived() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L545 Basket.withdrawMultipleERC721() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L41 Basket.withdrawMultipleERC1155() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L68 Basket.onERC1155BatchReceived() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L109   3. Missing validation check for non-zero totalSupply() NibblVault.redeem() doesn't check for a non-zero totalSupply to prevent a divide-by-zero issue in https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L466   4. Use of unchecked transfer() The following are functions make use of unsafe transfer() which does not check the return value.  **Occurrences in: Basket.withdrawERC20() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L87 Basket.withdrawMultipleERC20() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L94 NibblVault.withdrawERC20() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L517 NibblVault.withdrawMultipleERC20() -  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L526 Basket.withdrawETH() -  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L80   5. Missing zero address check during transfers The following functions are missing a zero address check to prevent transfer of ETH or ERC to zero address  **Occurrences in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L454-L459 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L464-L469 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L474-L479 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L504-L509 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L495-L498 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L362-L389 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L300-L326 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L515-L518 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L523-L528 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L535-L539 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L545-L550 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L35-L37 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L41-L44 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L52-L54 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L61-L64 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L68-L72    6. Missing zero address check can make curator lose fee The `updateCurator()` function in https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L485-L488 is missing a require check to ensure the `_to` parameter is not a zero address. Current function could have the curator address changed to 0 address by mistake and with that the accrued curator fees will not be redeemable.   7. Missing zero address check on new Basket Implementation proposeNewBasketImplementation() sets the address for a proposed new Basket Implementation, however fails to check `_newBasketImplementation` is not a zero address. This can allow IMPLEMENTER_ROLE to mistakenly set the proposed new Basket Implementation to address zero and call updateBasketImplementation() to effect the change.  **Occurrence in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L99-L100    8. Missing zero address check on new Admin Fee address proposeNewAdminFeeAddress() sets the address for a proposed new Admin Fee address, however fails to check `_newFeeAddress` is not a zero address. TThis can allow IMPLEMENTER_ROLE to mistakenly set the proposed new Admin Fee address to address zero and the call updateNewAdminFeeAddress() to effect the change.  **Occurrence in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L123    9. Missing zero address check on new Vault plementationproposeNewVaultImplementation() sets the address for a proposed new Vault Implementation, however fails to check `_newVaultImplementation` is not a zero address. This can allow IMPLEMENTER_ROLE to mistakenly set the proposed new Vault Implementation to address zero and call updateVaultImplementation() to effect the change.  **Occurrence in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L158     10. Missing zero address check and zero value check in constructor https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L23   11. Contract can lock ETH. Some contracts' receive() function allows anyone to send ETH to the contract since it's missing a require check https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L183 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyVault.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyBasket.sol#L56 
1. Title: Using multiple `require` instead `&&` can save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L131  Recommended Mitigation Steps: ```  require(basketUpdateTime != 0, "NibblVaultFactory: UPDATE_TIME has not passed");  require(block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` ________________________________________________________________________  2. Title: Comparison operators  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L131 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L141 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L149  Recommended Mitigation Steps: Replace `<=` with `<`, and `>=` with `>` for gas optimization ________________________________________________________________________  3. Title: Reduce the size of error messages (Long revert Strings)  Impact:  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L48 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L131  Recommended Mitigation Steps: Consider shortening the revert strings to fit in 32 bytes ________________________________________________________________________  4. Title: Custom errors from Solidity 0.8.4 are cheaper than revert strings  Impact: Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information  Custom errors are defined using the error statement reference: https://blog.soliditylang.org/2021/04/21/custom-errors/  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol  Recommended Mitigation Steps: Replace require statements with custom errors. ________________________________________________________________________  5. Title: Expression for `constant` values such as a call to `keccak256()`, should use `immutable` rather than `constant`  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L51  Recommended Mitigation Steps: Change from `constant` to `immutable` reference: https://github.com/ethereum/solidity/issues/9232 ________________________________________________________________________  6. Title: `>=` is cheaper than `>`  Impact:  Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L224  Recommended Mitigation Steps: Consider using `>=` instead of `>` to avoid some opcodes ________________________________________________________________________  7. Title: Using unchecked can save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L319  Recommended Mitigation Steps: using `unchecked` can save gas due to L#311  ________________________________________________________________________  8. Title: function sell(): L#378 should be unchecked due to L#373  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L378  Recommended Mitigation Steps: Use `unchecked` ________________________________________________________________________  9. Title: Caching `length` for loop can save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547  Recommended Mitigation Steps: Change to: ```     uint256 Length = _assets.length;      for (uint256 i = 0; i < Length; i++) { ``` ________________________________________________________________________  10. Title: Default value initialization  Impact: If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547  Recommended Mitigation Steps: Remove explicit initialization for default values. ________________________________________________________________________  11. Title: Using unchecked and prefix increment is more effective for gas saving:  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547  Recommended Mitigation Steps: Change to: ```  for (uint i = 0; i < _assets.length;) {             // ...    unchecked { ++i; }          } ``` ________________________________________________________________________  12. Title: Consider make constant as private to save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/AccessControlMechanism.sol#L12-L14  Recommended Mitigation Steps: I suggest changing the visibility from `public` to `internal` or `private` ________________________________________________________________________  13. Title: Expression for `constant` values such as a call to `keccak256()`, should use `immutable` rather than `constant`  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/AccessControlMechanism.sol#L12-L14 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/EIP712Base.sol#L7  Recommended Mitigation Steps: Change from `constant` to `immutable` reference: https://github.com/ethereum/solidity/issues/9232 ________________________________________________________________________
# Low  ## Obsolete pragma  The pragma version used is:  ``` pragma solidity 0.8.10; pragma solidity ^0.8.0; ```  But recently solidity released a new version with important Bugfixes:  - The first one is related to ABI-encoding nested arrays directly from calldata. You can find more information [here](https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/).  - The second bug is triggered in certain inheritance structures and can cause a memory pointer to be interpreted as a calldata pointer or vice-versa. We also have a dedicated blog [post](https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/) about this bug.  Apart from these, there are several minor bug fixes and improvements.  The minimum required version should be [0.8.14](https://github.com/ethereum/solidity/releases/tag/v0.8.14)  ## Lack of empty address checks  The following methods have a lack checks if the received argument is an address, it's good practice in order to reduce human error to check that the address specified in the constructor or initialize is different than `address(0)`.  `address(0)`: - [NibblVaultFactory.sol#L26](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L26) - [AccessControlMechanism.sol#L19](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/AccessControlMechanism.sol#L19)  ## AccessControl / Pausable  The contract `NibblVaultFactory` is `AccessControl` and `Pausable`, so the owner could resign while the contract is paused, causing a Denial of Service. Owner resignation while paused should be avoided.  Affected source code:  - [NibblVaultFactory.sol#L17](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L17)  ## Use `encode` instead of `encodePacked` for hashig  Use of `abi.encodePacked` in `NibblVaultFactory` is safe, but unnecessary and not recommended. `abi.encodePacked` can result in hash collisions when used with two dynamic arguments (string/bytes).  There is also discussion of removing `abi.encodePacked` from future versions of Solidity ([ethereum/solidity#11593](https://github.com/ethereum/solidity/issues/11593)), so using `abi.encode` now will ensure compatibility in the future.  Affected source code:  - [NibblVaultFactory.sol#L50](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L50) - [NibblVaultFactory.sol#L70-L71](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L70-L71) - [NibblVaultFactory.sol#L81](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L81) - [NibblVaultFactory.sol#L89-L91](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L89-L91)  ## Unsafe ERC20 calls  The following code doesn't check the result of the ERC20 calls. ERC20 standard specify that the token can return false if these calls fails, so it's mandatory to check the result of these ERC20 methods.  Reference:  - [eip-20](https://eips.ethereum.org/EIPS/eip-20)  > NOTES: > The following specifications use syntax from Solidity 0.4.17 (or above) Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!  Affected source code for `transfer`:  - [Basket.sol#L87](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L87) - [Basket.sol#L94](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L94) - [NibblVault.sol#L517](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L517) - [NibblVault.sol#L526](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L526)  ## Lack of ACK during owner change  It's possible to lose the ownership under specific circumstances.  Because an human error it's possible to set a new invalid owner. When you want to change the owner's address it's better to propose a new owner, and then accept this ownership with the new wallet.  Affected source code:  - [NibblVault.sol#L485](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L485)  # Non critical  ## Outdated packages  The packages used are out of date, it is good practice to use the latest version of these packages:  ``` "@openzeppelin/contracts": "^4.5.0", "@openzeppelin/contracts-upgradeable": "^4.5.0", ```  Affected source code:  - [package.json#L28-L29](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/package.json#L28-L29)  ## Use call to transfer ether  Because to transfer ether the `.transfer` method (which is capped at 2300 gas) is used instead of `.call` which is limited to the gas provided by the user.  If a contract that has a `fallback` method more expensive than 2300 gas, it will be impossible for a contract receive funds from `Basket` contract.  Reference:  - **transfer** -> The receiving smart contract should have a fallback function defined or else the transfer call will throw an error. There is a gas limit of 2300 gas, which is enough to complete the transfer operation. It is hardcoded to prevent reentrancy attacks. - **send** -> It works in a similar way as to transfer call and has a gas limit of 2300 gas as well. It returns the status as a boolean. - **call** -> It is the recommended way of sending ETH to a smart contract. The empty argument triggers the fallback function of the receiving address.  Affected source code:  - [Basket.sol#L80](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L80)  ## Use interval for update window  If a maximum of time is not used during the update proposal, it is possible that the update will be made at the beginning or during deploy it, and after a few years, the change will be accepted, and users won't be aware of that. It is convenient to use a maximum expiration time of the proposal.  Affected source code:  - [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L107) - [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L131) - [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L149) - [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L166)  ## Possible loss of token 0  Token `0` is more or less the owner of the `Basket` contract. If this token is transfered to the wrong address, for example `address(this)`, this ownership could be losed.   It would be convenient to block the `transfer` when the token is `0` and `to` is `address(this)` (*`address(0)` it's already checked.*).   Affected source code:  - [Basket.sol#L37-L54](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L37-L54)  ## Use abstract for base contracts  Abstract contracts are contracts that have at least one function without its implementation. **An instance of an abstract cannot be created.**  Reference:  - https://docs.soliditylang.org/en/v0.6.2/contracts.html#abstract-contracts  Affected source code:  - [Twav.sol#L4](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Twav/Twav.sol#L4) - [EIP712Base.sol#L5](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/EIP712Base.sol#L5) - [AccessControlMechanism.sol#L8](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/AccessControlMechanism.sol#L8)  ## Wrong initialization  Wrong token name is used during the initialization of `NibblVault.INIT_EIP712`. `NibblVault` is used instead of `_tokenName`.  Affected source code:  - [NibblVault.sol#L186](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L186)  ## Lack of `lock` in `sell` method  if `buy` have `lock`, `sell` should have it, because the danger is the same.  Affected source code:  - [NibblVault.sol#L362](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L362) 
# Use constants  Use constant instead of storage for:  - `UPDATE_TIME` in [NibblVaultFactoryData.sol#L6](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/NibblVaultFactoryData.sol#L6)  Reduce math operations storing the value in a constant:  `2**32`: - [NibblVault.sol#L303](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L303) - [NibblVault.sol#L365](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L365)  # Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  ### Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  **If it's not possible to use error codes due to the pragma used, it is recommended to reduce the strings to less than 32 bytes.**  Affected source code:  - [NibblVaultFactory.sol#L48-L49](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L48-L49) - [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L107)  # Avoid redundant code  Two methods are exposed in the abi for the same value.  `getTwavObservations` returns the same value as `public twavObservations`: - [Twav.sol#L44](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Twav/Twav.sol#L44)  Remove `_defaultAdminRole` var and use `DEFAULT_ADMIN_ROLE`: - [AccessControlMechanism.sol#L20](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/AccessControlMechanism.sol#L20)  There are no sense to have an unsafe version of `withdrawERC721Unsafe`: - [Basket.sol#L49-L56](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L49-L56)  # `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:  ```solidity uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ```solidity uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2` I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`  **It is also recommended to not initialize the counter variable and surround the increment with an `unchecked` region.**  Affected source code:  - [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L43) - [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L70) - [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L93) - [NibblVault.sol#L506](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L506) - [NibblVault.sol#L525](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L525) - [NibblVault.sol#L547](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L547)  # There's no need to set default values for variables.  If a variable is not set/initialized, the default value is assumed (0, `false`, 0x0 ... depending on the data type). You are simply wasting gas if you directly initialize it with its default value.  Affected source code:  - [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L43) - [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L70) - [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L93)  # Use the right type  Move `unlocked` close to an `address` type and change the value to be a boolean to share the same storage slot: - [NibblVault.sol#L126](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L126) 
## missing checks for zero address  ### description Checking addresses against zero-address during initialization or during setting is a security best-practice. However, such checks are missing in address variable initializations/changes in many places.   Impact: Allowing zero-addresses will lead to contract reverts and force redeployments if there are no setters for such address variables.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L23-L26   https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L124 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L159 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L487  ## no check for existing NFT  ### description  `_proxyVault` is pushed onto the array `nibbledTokens` without checking to see if an existing vault already exists for that NFT  this could result in multiple vaults created for the same NFT  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L54  ## no support for cryptopunks  ### description  there appears to be no support for crytopunks, as they do not adhere to the ERC721 standard  ## Use of Block.timestamp  ### description   Block timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the Entropy Illusion for further details), locking funds for periods of time, and various state-changing conditional statements that are time-dependent. Miners have the ability to adjust timestamps slightly, which can prove to be dangerous if block timestamps are used incorrectly in smart contracts.  ### recommendation  Block timestamps should not be used for entropy or generating random numbersi.e., they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state.  Time-sensitive logic is sometimes required; e.g., for unlocking contracts (time-locking), completing an ICO after a few weeks, or enforcing expiry dates. It is sometimes recommended to use block.number and an average block time to estimate times; with a 10 second block time, 1 week equates to approximately, 60480 blocks. Thus, specifying a block number at which to change a contract state can be more secure, as miners are unable to easily manipulate the block number.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L101 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L125 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L143 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L160 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L147  ## Unused receive() function  ### description  If the intention is for the Ether to be used, the function should call another function, otherwise it should revert  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L183 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L114 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L585  ## transferFrom for ERC721  ### description  it is unsafe to use transferFrom for ERC721  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L54  ## use safeTransfer for ERC20  use something like OpenZeppelins safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94  ## Unspecific Compiler Version Pragma  ### description  Avoid floating pragmas for non-library contracts.  While floating pragmas make sense for libraries to allow them to be included with multiple different versions of applications, it may be a security risk for application implementations.  A known vulnerable compiler version may accidentally be selected or security tools might fall-back to an older compiler version ending up checking a different EVM compilation that is ultimately deployed on the blockchain.  It is recommended to pin to a concrete compiler version.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4  ## No Transfer Ownership Pattern  ### description  Recommend considering implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptCurator() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L488 
## don't use && require statement  ### description  The code size on deployment can be a bit smaller to save gas  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166  ## use calldata instead of memory  ### description  Use calldata instead of memory for function parameters saves gas if the function argument is only read.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L91 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L523 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545  ## for loop optimisations  ### description  Uninitialized variables are assigned with the types default value.  Explicitly initializing a variable with it's default value costs unnecessary  gas.  Suggest not initializing the for loop counter to 0.  An arrays length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Suggest storing the arrays length in a variable before the for-loop, and use it instead:  ++i costs less gas compared to i++  ++i costs less gas compared to i++ for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)  Suggest using ++i instead of i++ to increment the value of an uint variable.  Increments can be unchecked  In Solidity 0.8+, theres a default overflow check on unsigned integers. Its possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.  taking all of the above, the recommended format for gas savings is  ``` for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ```  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  ## x = x + y is cheaper than x += y  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L225
# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L6   # Vulnerability details  ## Impact The `Basket` contract is intended to be used behind a proxy. But the `ERC721` implementation used is not upgradeable, and its constructor is called at deployment time on the implementation. So all proxies will have a void name and symbol, breaking all potential integrations and listings.  ## Proof of Concept `ERC721("NFT Basket", "NFTB")` is called at deployment time, and sets private variable at the implementation level. Therefore when loading the code during `delegateCall`, these variables will not be initialized.  ## Recommended Mitigation Steps The easiest mitigation would be to pass this variable as immutable so they are hardcoded in the implementation byte code.  
## GAS  1. ## Title: Caching _tokens[i] can save gas  Occurrences: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L71-L73 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L44-L45   Instead of calling array value by assign its key every call, we can cache it for gas saving Change to: ```         for (uint256 i = 0; i < _tokens.length; i++) {      address _token = _tokens[i];      uint _tokenId = _tokenIds[i]             uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);             IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, "0");             emit WithdrawERC1155(_token, _tokenId, _balance, _to);         } ``` By doing this way we can save 48 gas per call   2. ## Title: Prefix increment and unchecked for `i`  Occurrences: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L93  Best practice for doing increment is using prefix increment and unchecked for `i` var inside for():  Change to: ```         for (uint256 i = 0; i < _tokens.length;) {             IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);             emit WithdrawERC721(_tokens[i], _tokenId[i], _to);      unchecked{++i;}         } ```   3. ## Title: Using calldata to store argument variable:  Occurrences: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L41 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L68  We can store `_tokens` and `_tokenIds` read only parameter with calldata instead of using memory.  ## Recommended mitigation step Change to: ```     function withdrawMultipleERC721(address[] calldata _tokens, uint256[] calldata _tokenId, address _to) external override { ```   4. ## Title: Using < operator instead of <=  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L147  By using < operator to validate we can save 3 gas per call. The 1 second difference can be ignore   5. ## Title: Using delete statement to set to default value  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L477  Using delete statement to set value to 0 can save 8 gas per execution  ## Recommended mitigation step ``` delete feeAccruedCurator; ```  
# QA Report  ## [L-01] Lack of ownership transfer pattern Setting the curator to the wrong address will result in permanent loss of functionality in the protocol. It is recommended to apply a two-step transfer.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L488  ## [L-02] Unnecessary safeTransferFrom() when sending from address(this) `safeTransfer()` can be used instead when sending from the current address.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L495-L509  ## [L-03] Missing zero address check Contract would need to be redeployed if the `feeTo` variable is accidently set to address(0).  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L25  ## [L-04] Unsafe transfer, use safeTransfer() It is recommended to use safeTransfer() instead of transfer() to mitigate against ERC20 implementations that do not revert on failure.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517  ## [N-01] Constants should be all caps Most constants defined in the contracts are fully capitalized, just this one example is not.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28  ## [N-02] CURVE_FEE is described as a variable when it is a constant https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L210
## Minus before addition  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L401  ``` _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance; ```  This line perform minus before addition which risk underflow. Should add before minus in all case. Change code to this  ``` _buyoutBid = msg.value + primaryReserveBalance + secondaryReserveBalance - fictitiousPrimaryReserveBalance; ```  This add before minus, so never underflow.  ## Use "" for data instead of "0"  "0" is not 0x "" is 0x  Sending empty data should send "" not "0"  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L538  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L549  ``` IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, "0"); ```  should be  ``` IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, ""); ```
# check the wrong arggument   In this section the function check the amout of the `_adminFeeAmt` and its more correct to check the `_feeAdmin` amount because there is a case that the `_feeAdmin` will be 0 but the `_adminFeeAmt` will be greater than 0.  ``` if(_adminFeeAmt > 0) {             safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract         } ```   ``` fix -  if(_feeAdmin > 0) {             safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract         } ```
# FINDINGS FOR NIBBL CONTEST **Commit:** `N/A` **Type of Audit:** Security Review **Type of Project:** NFT Fractionalization Protocol **Language**: Solidity **Methods**: Manual review ## Audit Scope  --- ## 1.  Contract `NibblVault.sol`   ### [LOW] Missing event emission for state-changing function `updateCurator` function  **File**: [L485](https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L485-L488)  **Description**: State-changing function, `_updateCurator` function does not emit an appropriate event.  ```= solidity function updateCurator(address _newCurator) external override {     require(msg.sender == curator,"NibblVault: Only Curator");     curator = _newCurator; }  ``` **Recommendation**: Consider creating and emitting appropriate event for `_updateCurator` function   --- ## 2.  Contract `NibblVaultFactory.sol`  ### [LOW] Unused Openzeppelin's `SafeMath` Library  **File**: [L9](https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L9)  **Description**: Whereas Openzeppelin's `SafeMath` Library is imported, it is never used in the contract ``` = solidity import { SafeMath } from  "@openzeppelin/contracts/utils/math/SafeMath.sol";  ```  **Recommendation**: Consider utilizing the imported Openzeppelin's `SafeMath` library for efficiency in all logic involving arithmetic operations or consider removing this library if it will be used in the contract.   ---    ### [LOW] Missing access control and possibility of reentrancy attack  **File**: [L112](https://github.com/NibblNFT/nibbl-smartcontracts/blob/master/contracts/NibblVaultFactory.sol#L112)  **Description**: No access control logic to restrict calls to  `withdrawAdminFee(...)` function and missing reentrancy guard to mitigate the risks of reentrancy. The code is shown below:  ```solidity= function withdrawAdminFee() external override {     (bool _success, ) = payable(feeTo).call{value: address(this).balance}("");     require(_success); } ```  **Recommendation**: Consider adding  access control to restrict calls to `withdrawAdminFee(...)` function and consider implementing reentrancy guard to mitigate the risks of reentrancy.  
[G-01] Constant Value of a Call to keccak256() should Use Immutable  When using constant it is expected that the value should be converted into a constant value at compile time. However when using a call to keccak256(), the expression is re-calculated each time the constant is referenced. Resulting in costing about 100 gas more on each access to this "constant". link for more details: https://github.com/ethereum/solidity/issues/9232  Issue found at ``` ./EIP712Base.sol:7-10:    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(bytes("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")); ./NibblVault.sol:51:    bytes32 private constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"); ./AccessControlMechanism.sol:12:    bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE"); ./AccessControlMechanism.sol:13:    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE"); ./AccessControlMechanism.sol:14:    bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE"); ```   [G-02] Unnecessary Default Value Initialization  When variable is not initialized, it will have its default values. For example, 0 for uint, false for bool and address(0) for address. link: https://docs.soliditylang.org/en/v0.8.15/control-structures.html#scoping-and-declarations  I suggest removing default value initialization for following variables. ``` ./Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { ./NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { ./NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  For example these can change to: - for (uint256 i; i < _tokens.length; i++) {   [G-03] Store Array's Length as a Variable   I suggest to store an array's length as a variable before the for-loop since it can save 3 gas per iteration.  Issue found at: ``` ./Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { ./NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { ./NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  For example, I suggest changing it to ``` length = _tokens.length for (uint256 i = 0; i < length; i++) { ```   [G-04] ++i Costs Less Gas than i++  It is better to use ++i than i++ when possible since it costs less gas.  Issue found at: ``` ./Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { ./NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { ./NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:562:        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); ```   [G-05] Use Calldata instead of Memory for Read Only Function Parameters  It is cheaper gas to use calldata than memory if the function parameter is read only. Calldata is a non-modifiable, non-persistent area where function arguments are stored,  and behaves mostly like memory. More details on following link. link: https://docs.soliditylang.org/en/v0.8.15/types.html#data-location  I recommend changing following memory to calldata ``` ./EIP712Base.sol:15:    function INIT_EIP712(string memory name, string memory version) internal { ./Basket.sol:41:    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override { ./Basket.sol:68:    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override { ./Basket.sol:91:    function withdrawMultipleERC20(address[] memory _tokens) external override { ./Basket.sol:99:    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) { ./Basket.sol:104:    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) { ./Basket.sol:109:    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) { ./NibblVault.sol:174:        string memory _tokenName,  ./NibblVault.sol:175:        string memory _tokenSymbol,  ./NibblVault.sol:504:    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut { ./NibblVault.sol:523:    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut { ./NibblVault.sol:545:    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut { ./NibblVault.sol:577:    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) { ./NibblVault.sol:581:    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) { ./NibblVaultFactory.sol:41:        string memory _name, ./NibblVaultFactory.sol:42:        string memory _symbol, ./NibblVaultFactory.sol:80:    function createBasket(address _curator, string memory _mix) public override returns(address)  { ./NibblVaultFactory.sol:88:    function getBasketAddress(address _curator, string memory _mix) public override view returns(address _basket) { ```   [G-06] Using Elements Smaller than 32 bytes (256 bits) Might Use More Gas  This is because EVM operates on 32 bytes at a time. So I recommend using uint256 instead of anything smaller. More information about this in the following link. link: https://docs.soliditylang.org/en/v0.8.15/internals/layout_in_storage.html  Issue found at ``` ./Twav.sol:6:        uint32 timestamp; ./Twav.sol:11:    uint8 public twavObservationsIndex; ./Twav.sol:12:    uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks  ./Twav.sol:13:    uint32 public lastBlockTimeStamp; ./Twav.sol:21:    function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal { ./Twav.sol:22:        uint32 _timeElapsed;  ./Twav.sol:37:            uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS; ./NibblVault.sol:28:    uint32 private constant primaryReserveRatio = 200_000; //20% ./NibblVault.sol:57:    uint32 public secondaryReserveRatio; ./NibblVault.sol:183:        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice)); ./NibblVault.sol:303:            uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ./NibblVault.sol:365:            uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ./NibblVault.sol:445:        uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ./NibblVault.sol:557:        uint8 v, ```   [G-07] Use require instead of &&  When there are multiple conditions in require statement, break down the require statement into multiple require statements instead of using && can save gas.  Issue found at ``` ./NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  For example these can be changed to ``` require(basketUpdateTime != 0); require(block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```   [G-08] Reduce the Long Revert Strings of Error Messages  By keeping the revert strings within 32 bytes will save you gas since each slot is 32 bytes.  Following are revert strings that are more than 32 bytes. ``` ./NibblVaultFactory.sol:48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low"); ./NibblVaultFactory.sol:49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender"); ./NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE"); ./NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```   [G-09] Duplicate require() Checks Should be a Modifier or a Function  Since below require checks are used more than once, I recommend making these to a modifier or a function. ``` ./Basket.sol:36:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:42:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:53:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:62:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:69:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:79:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:86:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:92:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ``` ``` ./NibblVault.sol:475:        require(msg.sender == curator,"NibblVault: Only Curator"); ./NibblVault.sol:486:        require(msg.sender == curator,"NibblVault: Only Curator"); ``` ``` ./NibblVault.sol:496:        require(msg.sender == bidder,"NibblVault: Only winner"); ./NibblVault.sol:505:        require(msg.sender == bidder,"NibblVault: Only winner"); ./NibblVault.sol:516:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:524:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:536:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:546:        require(msg.sender == bidder, "NibblVault: Only winner"); ```   [G-10] Use Custom Errors to Save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings. Details are explained here: https://blog.soliditylang.org/2021/04/21/custom-errors/  I recommend using custom errors. ``` ./Basket.sol:36:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:42:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:53:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:62:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:69:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:79:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:86:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./Basket.sol:92:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ./NibblVault.sol:129:        require(unlocked == 1, 'NibblVault: LOCKED'); ./NibblVault.sol:139:        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out'); ./NibblVault.sol:146:        require(status == Status.buyout, "NibblVault: status != buyout"); ./NibblVault.sol:147:        require(buyoutEndTime <= block.timestamp, "NibblVault: buyoutEndTime <= now"); ./NibblVault.sol:154:        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused'); ./NibblVault.sol:184:        require(_secondaryReserveRatio <= primaryReserveRatio, "NibblVault: Excess initial funds"); ./NibblVault.sol:185:        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, "NibblVault: secResRatio too low"); ./NibblVault.sol:325:        require(_minAmtOut <= _purchaseReturn, "NibblVault: Return too low"); ./NibblVault.sol:351:        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell"); ./NibblVault.sol:387:        require(_saleReturn >= _minAmtOut, "NibblVault: Return too low"); ./NibblVault.sol:399:        require(block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now"); ./NibblVault.sol:400:        require(status == Status.initialized, "NibblVault: Status!=initialized"); ./NibblVault.sol:404:        require(_buyoutBid >= _currentValuation, "NibblVault: Bid too low"); ./NibblVault.sol:444:        require(status == Status.buyout, "NibblVault: Status!=Buyout"); ./NibblVault.sol:475:        require(msg.sender == curator,"NibblVault: Only Curator"); ./NibblVault.sol:486:        require(msg.sender == curator,"NibblVault: Only Curator"); ./NibblVault.sol:496:        require(msg.sender == bidder,"NibblVault: Only winner"); ./NibblVault.sol:505:        require(msg.sender == bidder,"NibblVault: Only winner"); ./NibblVault.sol:516:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:524:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:536:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:546:        require(msg.sender == bidder, "NibblVault: Only winner"); ./NibblVault.sol:561:        require(block.timestamp <= deadline, "NibblVault: expired deadline"); ./NibblVault.sol:564:        require(signer == owner, "NibblVault: invalid signature"); ./NibblVault.sol:570:        require(success, "NibblVault: ETH transfer failed"); ./NibblVaultFactory.sol:48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low"); ./NibblVaultFactory.sol:49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender"); ./NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE"); ./NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ./AccessControlMechanism.sol:48:        require(pendingRoles[_role][msg.sender], "AccessControl: Role not pending"); ```   [G-11] Defined Variables Used Only Once  Certain variables is defined even though they are used only once. Remove these unnecessary variables to save gas. For cases where it will reduce the readability, one can use comments to help describe what the code is doing.  Issue found at  1. NibblVaultFactory.sol - Remove "newsalt", "code" and "_hash" variable of getVaultAddress function ``` 70:        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID,  _initialSupply, _initialTokenPrice)); 71:        bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this)))); 72:        bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))); 73:        _vault = address(uint160(uint256(_hash)));      ``` - Remove "newsalt", "code" and "hash" variable of getBasketAddress function ``` 89:        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix)); 90:        bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(basketImplementation))); 91:        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))); 92:        _basket = address(uint160(uint256(hash)));      ```  2. Twav.sol - Remove "_prevCumulativeValuation" variable of _updateTWAV function ``` 27:        uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation; 28:        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative ``` 
# Basket.sol - Wrong comment in line 58, it should be ERC1155 instead of ERC721 #NibblVault.sol - Consider adding an event for the `initialize()`, `updateCurator()`. # MISC - Most of the comments in all the contracts assume that the ERC1155 token can be only NFT. This is not true because a tokenID of ERC1155 can be a fungible token. 
# QA Report  ## Table of Contents  - [summary](#summary) - [hash collision with abi.encodePacked](#hash-collision-with-abi.encodepacked) - [Immutable addresses lack zero-address check](#immutable-addresses-lack-zero-address-check) - [Receive function](#receive-function) - [Setters should check the input value](#setters-should-check-the-input-value) - [Unchecked transfer](#unchecked-transfer) - [Comment Missing function parameter](#comment-missing-function-parameter) - [Commented Code](#commented-code) - [Constants instead of magic numbers](#constants-instead-of-magic-numbers) - [Event should be emitted in setters](#event-should-be-emitted-in-setters) - [Function missing comments](#function-missing-comments) - [Function order](#function-order) - [Inconsistent spacing](#inconsistent-spacing) - [Non-library files should use fixed compiler versions](#non-library-files-should-use-fixed-compiler-versions) - [Non-library files should use the same compiler version](#non-library-files-should-use-the-same-compiler-version) - [Public functions can be external](#public-functions-can-be-external) - [Require statements should have descriptive strings](#require-statements-should-have-descriptive-strings) - [Scientific notation](#scientific-notation) - [Timelock for critical parameter change](#timelock-for-critical-parameter-change) - [Uint256 alias](#uint256-alias)     # summary  > Few vulnerabilities were found, the main concerns are with potential lock of ETH in some contracts   # hash collision with abi.encodePacked  ## IMPACT  strings and bytes are encoded with padding when using `abi.encodePacked`. This can lead to [hash collision](https://docs.soliditylang.org/en/v0.8.15/abi-spec.html#non-standard-packed-mode) when passing the result to `keccak256`  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactory.sol  [here](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L71-L72) ``` bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this)))); bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))) ```  and [here](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L81), with a string ``` ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation)) ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use `abi.encode()` instead.  # Immutable addresses lack zero-address check  ## IMPACT  constructors should check the address written in an immutable address variable is not the zero address  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:    ### ProxyBasket.sol  [implementation = payable(_implementation)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L20)  ### ProxyVault.sol  [factory = payable(_factory)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L20)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add a zero address check for the immutable variables aforementioned.  # Receive function  ## PROBLEM  `ProxyBasket` and `ProxyDelegate` have `receive()` functions, but do not have any withdrawal function. A call to these contracts will trigger the `fallback` function. But if a call sends ETH to these contracts with no `msg.data`, `fallback` will not be triggered, only `receive()`, resulting in the ETH getting locked.  ## SEVERITY  Low  ## PROOF OF CONCEPT  ### ProxyBasket.sol  [receive() external payable {    }](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L56)  ### ProxyVault.sol  [receive() external payable {    }](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L56)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add `require(0 == msg.value)` in `receive()` or remove the function altogether.   # Setters should check the input value  ## PROBLEM  Setters and initializers should check the input value - ie make revert if it is the zero address or zero  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [_assetAddress lacks a check in initialize()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L191)\ [_curator lacks a check in initialize()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L193)\ [_newCurator lacks a check in updateCurator()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L487)  ### NibblVaultFactory.sol  [_vaultImplementation lacks a check in the constructor](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L24)\ [_feeTo lacks a check in the constructor](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L25)\ [_basketImplementation lacks a check in the constructor](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L26)\ [_newBasketImplementation lacks a check in proposeNewBasketImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100)\ [_newFeeAddress lacks a check in proposeNewAdminFeeAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L124)\ [_newVaultImplementation lacks a check in proposeNewVaultImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add non-zero checks - address - to the setters aforementioned.   # Unchecked transfer  ## PROBLEM  Several tokens do not revert in case of `ERC20.transfer()` failure and return false. It is good practice to use `safeTransfer()` from OpenZeppelin, or simply check the return value of `.transfer()`  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517)\ [IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526)  ## TOOLS USED  Manual Analysis  ## MITIGATION  use `safeTransfer()` from OpenZeppelin or check the return value of `.transfer()`.   # Comment Missing function parameter  ## PROBLEM  Some of the function comments are missing function parameters or returns  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L275)\ [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L287)\ [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L335)\ [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L347)\ [@return _saleReturn](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L362)\ [@return _buyoutBid](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L398)\ [@param _to](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L464)\ [@return _amtOut](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L464)\ [@return _feeAccruedCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L474)  ### NibblVaultFactory.sol   [@return _proxyVault](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L47)\ [@return _vault](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L69)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Add a comment for these parameters  # Commented code  ## PROBLEM  There are portions of commented code in some files.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [// _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L321)\ [// buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L405)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove commented code  # Constants instead of magic numbers  ## PROBLEM  It is best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183)\ [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L195)\ [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L226)\ [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L253)\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303)\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L365)\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L413)\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L445)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Define constant variables for the literal values aforementioned.  # Event should be emitted in setters  ## PROBLEM  Setters should emit an event so that Dapps can detect important changes to storage  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:   ### NibblVault.sol  [function updateCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485)  ### NibblVaultFactory.sol  [function updateBasketImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L106)\ [function updateNewAdminFeeAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L130)\ [function updateNewAdminFee](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L148)\ [function updateVaultImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L165)   ## TOOLS USED  Manual Analysis  ## MITIGATION  emit an event in all setters  # Function missing comments  ## PROBLEM  Some functions are missing Natspec comments  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [function permit](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L552-L565)\ [function safeTransferETH](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L568)\ [function onERC721Received](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L573)\ [function onERC1155Received](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L577)\ [function onERC1155BatchReceived](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L581)  ### NibblVaultFactory.sol  [function getVaults](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76)\ [function createBasket](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80)\ [function getBasketAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88)\ [function withdrawAdminFee](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L112)   ### Twav.sol  [function getTwavObservations()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44)  ### EIP712Base.sol  [function INIT_EIP712()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15)\ [function getChainID()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L27)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add comments to these functions  # Function order  ## PROBLEM  Functions should be ordered following the [Soldiity conventions](https://docs.soliditylang.org/en/v0.8.15/style-guide.html#order-of-functions): `receive()` function should be placed after the constructor and before every other function.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Several contracts have `receive()` at the end:   - NibblVault.sol  - NibblVaultFactory.sol  - Basket.sol  ## TOOLS USED  Manual Analysis  ## MITIGATION  Place the `receive()`functions after the constructor, before all the other functions.  # Inconsistent spacing  ## PROBLEM  Spacing is present in the vast majority of comments (`// x`), but some comments do not have space.   ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  ### NibblVault.sol  [///@notice current status of vault](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L122)\ [///@notice reenterancy guard](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L125)\ [///@notice withdraw multiple ERC721s](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L500)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use spacings consistently in all comments.   # Non-library files should use fixed compiler versions  ## PROBLEM  contracts should be compiled using a fixed compiler version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most   ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT   `AccessControlMechanism.sol` has a floating pragma.    ## TOOLS USED  Manual Analysis    ## MITIGATION  Used a fixed compiler version  # Non-library files should use the same compiler version  ## PROBLEM  contracts within the scope should be compiled using the same compiler version.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  All the files in scope have the compiler version set to `0.8.10`, except for `AccessControlMechanism.sol` which has its pragma set to `^0.8.0`.   ## TOOLS USED  Manual Analysis    ## MITIGATION  Use the same compiler version throughout the contracts  # Public functions can be external  ## PROBLEM  It is good practice to mark functions as `external` instead of `public` if they are not called by the contract where they are defined.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactory.sol  [function getVaultAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L74)\ [function getVaults](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76-L77)\ [function createBasket](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80-L86)\ [function getBasketAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88-L92)  ### Twav.sol  [function getTwavObservations](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Declare these functions as `external` instead of `public`  # Require statements should have descriptive strings  ## PROBLEM  Some require statements are missing error strings, which makes it more difficult to debug when the function reverts.  ### SEVERITY  Non-critical  ## PROOF OF CONCEPT   ### NibblVaultFactory.sol   [require(_success)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114)  ## TOOL USED  Manual Analysis  ## MITIGATION  Add error strings to all require statements.  # Scientific notation  ## PROBLEM  For readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`). Underscores are used throughout the contracts and do improve readability too, so this is more of a suggestion.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [uint256 private constant SCALE = 1_000_000](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L23)  ## TOOLS USED  Manual Analysis   # Timelock for critical parameter change  ## PROBLEM  It is good practice to add timelock to critical parameters changes, such as admin changes, to give users time to react.     ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### NibblVault.sol  There is no timelock in [updateCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L487). If the curator were to input an incorrect address here, they would lose all the curators fees accrued.   ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a timelock to `updateCurator`   # Uint256 alias  ## IMPACT  `uint` is an alias for `uint256`.  It is better to use uint256: it brings readability and consistency in the code, and it future proofs it in case of any changes to the alias of uint. This is all the more valid as `uint256` is used throughout the contracts, `uint` is only used in few instances.   ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  ### Nibblvault.sol  [uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L195)\ [uint _secondaryReserveBalance = secondaryReserveBalance](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L289)\ [uint _primaryReserveBalance = primaryReserveBalance](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L336)\ [uint _secondaryReserveBalance = secondaryReserveBalance](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L348)\ [uint _amount = unsettledBids[msg.sender]](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L455)  ## TOOLS USED  Manual Analysis    ## MITIGATION  replace `uint` with `uint256`  
# Gas Report  ## Table of Contents  - [Caching storage variables in memory to save gas](#caching-storage-variables-in-memory-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters) - [Comparison operators](#comparison-operators) - [Constant expressions](#constant-expressions) - [Constructor parameters should be avoided when possible](#constructor-parameters-should-be-avoided-when-possible) - [Custom errors](#custom-errors) - [Default value initialization](#default-value-initialization) - [Immutable variables save storage](#immutable-variables-save-storage) - [Mathematical optimizations](#mathematical-optimizations) - [Modifier instead of duplicate require](#modifier-instead-of-duplicate-require) - [Prefix increments](#prefix-increments) - [Require instead of AND](#require-instead-of-and) - [Revert strings length](#revert-strings-length) - [unchecked arithmetic](#unchecked-arithmetic) - [unused import](#unused-import)    # Caching storage variables in memory to save gas  ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable in memory: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.  In particular, in `for` loops, when using the length of a storage array as the condition being checked after each loop, caching the array length in memory can yield significant gas savings if the array length is high  ## PROOF OF CONCEPT  Instances include:  ### Twav.sol  scope: `_updateTWAV()`  - `twavObservationsIndex` is read 3 times  [line 27](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L27)\ [line 28](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L28)\ [line 29](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L29)    ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these storage variables in memory  # Calldata instead of memory for RO function parameters  ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.  Try to use calldata as a data location because it will avoid copies and also makes sure that the data cannot be modified.  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [address[] memory _assetAddresses, uint256[] memory _assetIDs](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504)\ [address[] memory _assets](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L523)\ [address[] memory _assets, uint256[] memory _assetIDs](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `memory` with `calldata`  # Comparison Operators  ## IMPACT  In the EVM, there is no opcode for ` >=` or `<=`. When using greater than or equal, two operations are performed: `>` and `=`.  Using strict comparison operators hence saves gas, approximately `20` gas in `require` and `if` statements  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [buyoutEndTime <= block.timestamp](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L147)\ [_secondaryReserveRatio <= primaryReserveRatio](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L184)\ [_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L185)\ [_totalSupply >= _initialTokenSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L311)\ [_lowerCurveDiff >= msg.value](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L315)\ [_minAmtOut <= _purchaseReturn](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L325)\ [_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L351)\ [(_initialTokenSupply + _amtIn) <= _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L374)\ [_saleReturn >= _minAmtOut, "NibblVault: Return too low"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L387)\ [block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L399)\ [_buyoutBid >= _currentValuation, "NibblVault: Bid too low"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L404)\ [_twav >= buyoutRejectionValuation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L426)\ [block.timestamp <= deadline](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L561)   ### NibblVaultFactory.sol  [msg.value >= MIN_INITIAL_RESERVE_BALANCE](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48)\ [block.timestamp >= basketUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107)\ [block.timestamp >= feeToUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131)\ [_newFee <= MAX_ADMIN_FEE](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141)\ [block.timestamp >= feeAdminUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)\ [block.timestamp >= vaultUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `<=` with `<`, and `>=` with `>`. Do not forget to increment/decrement the compared variable  example:  ``` -block.timestamp >= basketUpdateTime +block.timestamp > basketUpdateTime - 1; ```  However, if `1` is negligible compared to the value of the variable, we can omit the increment.  ``` -block.timestamp >= basketUpdateTime +block.timestamp > basketUpdateTime; ```  # Constant expressions  ## IMPACT  Constant expressions are [re-calculated each time it is in use](https://github.com/ethereum/solidity/issues/9232), costing an extra `97` gas than a constant every time they are called.   ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [bytes32 private constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L51)  ### AccessControlMechanism.sol  [bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12)\ [bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L13)\ [bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L14)  ### EIP712Base.sol  [bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(bytes("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L7-L11)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these as `immutable` instead of `constant`  # Constructor parameters should be avoided when possible  ## IMPACT  Constructor parameters are expensive. The contract deployment will be cheaper in gas if they are hard coded instead of using constructor parameters.  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactory.sol  [vaultImplementation = _vaultImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L24)\ [feeTo = _feeTo](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L25)\ [basketImplementation = _basketImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L26)  ### ProxyBasket.sol  [implementation = payable(_implementation)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L20)  ### ProxyVault.sol  [factory = payable(_factory)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L20)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Hardcode storage variables with their initial value instead of writing it during contract deployment with constructor parameters.  # Custom Errors  ## IMPACT  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information, as explained [here](https://blog.soliditylang.org/2021/04/21/custom-errors/).  It not only saves gas upon deployment - `~5500` gas saved per custom error instead of a require statement, but it is also cheaper in a function call, `22` gas saved per require statement replaced with a custom error.  Custom errors are defined using the error statement  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [require(unlocked == 1, 'NibblVault: LOCKED')](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L129)\ [require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out'))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L139)\ [require(status == Status.buyout, "NibblVault: status != buyout")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L146)\ [require(buyoutEndTime <= block.timestamp, "NibblVault: buyoutEndTime <= now")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L147)\ [require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused')](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L154)\ [require(_secondaryReserveRatio <= primaryReserveRatio, "NibblVault: Excess initial funds")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L184)\ [require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, "NibblVault: secResRatio too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L185)\ [require(_minAmtOut <= _purchaseReturn, "NibblVault: Return too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L325)\ [require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L351)\ [require(_saleReturn >= _minAmtOut, "NibblVault: Return too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L387)\ [require(block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L399)\ [require(status == Status.initialized, "NibblVault: Status!=initialized")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L400)\ [require(_buyoutBid >= _currentValuation, "NibblVault: Bid too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L404)\ [require(status == Status.buyout, "NibblVault: Status!=Buyout")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L444)\ [require(msg.sender == curator,"NibblVault: Only Curator")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L474)\ [require(msg.sender == curator,"NibblVault: Only Curator")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L486)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L496)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L505)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L516)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L524)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L536)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L546)\ [require(block.timestamp <= deadline, "NibblVault: expired deadline")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L561)\ [require(signer == owner, "NibblVault: invalid signature")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L564)\ [require(success, "NibblVault: ETH transfer failed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L570)  ### NibblVaultFactory.sol  [require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48)\ [require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L49)\ [require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107)\ [require(_success)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114)\ [require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131)\ [require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141)\ [require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)\ [require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)  ### AccessControlMechanism.sol  [require(pendingRoles[_role][msg.sender], "AccessControl: Role not pending")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L48)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace require and revert statements with custom errors.  For instance, in `NibbleVault.sol`:  Replace  ``` require(unlocked == 1, 'NibblVault: LOCKED') ```  with  ``` if (unlocked != 1) {   revert NibblVaultLocked(); } ```  and define the custom error in the contract  ``` error NibblVaultLocked(); ```  Here are the deployment costs comparison between:  - the original `NibbleVault` contract |  NibblVault                                                               -            -      7045960       - the same `NibbleVault` contract with one require statement replaced with a custom error:   |  NibblVault                                                               -            -      7036463    # Default value initialization  ## IMPACT  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes `3` gas per variable initialized.  ## PROOF OF CONCEPT  Instances include:  ### NibbleVault.sol  [uint i = 0](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506)\ [uint i = 0](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525)\ [uint i = 0](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547)    ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove explicit initialization for default values.   # Immutable variables save storage  ## PROBLEM  If a variable is set in the constructor and never modified afterwrds, marking it as `immutable` can save a storage operation - `20,000` gas.  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactoryData.sol  [uint256 public UPDATE_TIME = 2 days](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/NibblVaultFactoryData.sol#L6)  Note: the contract is technically not in scope, but as `NibblVaultFactory`, which is in scope, inherits from `NibblVaultFactoryData`, I consider it a valid optimization.  ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these variables as `immutable`.  # Mathematical optimizations  ## PROBLEM  X += Y costs `22` more gas than X = X + Y.   ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [feeAccruedCurator += _feeCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L219)\ [secondaryReserveBalance += _feeCurve](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L225)\ [feeAccruedCurator += _feeCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L242)\ [secondaryReserveBalance += _lowerCurveDiff](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L320)\ [_purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L322)\ [primaryReserveBalance -= _saleReturn](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L380)\ [_saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L383)\ [unsettledBids[bidder] += _buyoutValuationDeposit](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L428)\ [totalUnsettledBids += _buyoutValuationDeposit](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L429)\ [totalUnsettledBids -= _amount](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L450)   ## TOOLS USED  Manual Analysis  ## MITIGATION  use `X = X + Y` instead of `X += Y` (same with `-`)  # Modifier instead of duplicate require  ## PROBLEM  When a `require` statement is use multiple times, it is cheaper to use a modifier instead.  ## PROOF OF CONCEPT  Instances include:   ### NibblVault.sol   [require(msg.sender == curator,"NibblVault: Only Curator")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L474)\ [require(msg.sender == curator,"NibblVault: Only Curator")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L486)  [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L496)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L505)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L516)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L524)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L536)\ [require(msg.sender == bidder,"NibblVault: Only winner")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L546)     ## TOOLS USED  Manual Analysis  ## MITIGATION  Use modifiers for these repeated statements  # Prefix increments  ## IMPACT  Prefix increments are cheaper than postfix increments: it returns the incremented variable instead of returning a temporary variable storing the initial value of the variable. It saves `5` gas per iteration  ## PROOF OF CONCEPT  Instances include:  ### NibbleVault.sol  [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506)\ [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525)\ [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547)   ## TOOLS USED  Manual Analysis  ## MITIGATION  change `variable++` to `++variable`.  # Require instead of AND  ## IMPACT  Require statements including conditions with the `&&` operator can be broken down in multiple require statements to save gas.  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactory.sol   [require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107)\ [require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131)\ [require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)\ [require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Break down the statements in multiple require statements.  ``` -require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed") +require(basketUpdateTime != 0) +require(block.timestamp >= basketUpdateTime) ``` You can also improve gas savings by using [custom errors](#custom-errors)   # Revert strings length  ## IMPACT  Revert strings cost more gas to deploy if the string is larger than 32 bytes. Each string exceeding that 32-byte size adds an extra `9,500` gas upon deployment.  ## PROOF OF CONCEPT  Revert strings exceeding 32 bytes include:   ### NibblVaultFactory.sol  [require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48)\ [require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L49)\ [require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107)\ [require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131)\ [require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141)\ [require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)\ [require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Write the error strings so that they do not exceed 32 bytes. For further gas savings, consider also using [custom errors](#custom-errors).    # Unchecked arithmetic  ## IMPACT  The default "checked" behavior costs more gas when adding/diving/multiplying, because under-the-hood those checks are implemented as a series of opcodes that, prior to performing the actual arithmetic, check for under/overflow and revert if it is detected.  if it can statically be determined there is no possible way for your arithmetic to under/overflow (such as a condition in an if statement), surrounding the arithmetic in an `unchecked` block will save gas  ## PROOF OF CONCEPT  Instances include:  ### NibbleVault.sol  [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506)\ [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525)\ [i++](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Place the arithmetic operations in an `unchecked` block  # Unused import  ## IMPACT  Unused imports should be removed as they waste gas upon deployment  ## PROOF OF CONCEPT  Instances include:  ### NibbleVaultFactory.sol  [import { SafeMath } from  "@openzeppelin/contracts/utils/math/SafeMath.sol";](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L9)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove the `SafeMath` import. 
# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L414-L417   # Vulnerability details  ## Impact In the initiateBuyout function of the NibblVault contract, the second parameter of the BuyoutInitiated event is _buyoutBid instead of _currentValuation, and since the excess Ether in _buyoutBid is transferred to the user, the actual buyout price for the user is the _currentValuation variable. The user can use a large amount of Ether to get a large _buyoutBid variable, however the actual amount of Ether spent by the user is _currentValuation. Events emitted by the smart contract are used off-chain, and incorrect event parameters may have an impact on the user's trading behavior  ## Proof of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L414-L417 ## Tools Used None ## Recommended Mitigation Steps ``` -       emit BuyoutInitiated(msg.sender, _buyoutBid); +      emit BuyoutInitiated(msg.sender, _currentValuation); ```  
# Gas Optimizations Report  ## For-loops: Index initialized with default value Uninitialized `uint` variables are assigned with a default value of `0`.   Thus, in for-loops, explicitly initializing an index with `0` costs unnecesary gas. For example, the following code: ```js for (uint256 i = 0; i < length; ++i) { ``` can be changed to: ```js for (uint256 i; i < length; ++i) { ```  Consider declaring the following lines without explicitly setting the index to `0`:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## For-Loops: Cache array length outside of loops Reading an array length at each iteration of the loop takes 6 gas (3 for `mload` and 3 to place `memory_offset`) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.   For example: ```js for (uint256 i; i < arr.length; ++i) {} ``` can be changed to: ```js uint256 len = arr.length; for (uint256 i; i < len; ++i) {} ```  Consider making the following change to these lines:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## For-Loops: Index increments can be left unchecked From Solidity v0.8 onwards, all arithmetic operations come with implicit overflow and underflow checks.   In for-loops, as it is impossible for the index to overflow, it can be left unchecked to save gas every iteration.   For example, the code below: ```js for (uint256 i; i < numIterations; ++i) {       // ...   }   ``` can be changed to: ```js for (uint256 i; i < numIterations;) {       // ...       unchecked { ++i; }   }   ```  Consider making the following change to these lines:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## Arithmetics: `++i` costs less gas compared to `i++` or `i += 1` `++i` costs less gas compared to `i++` or `i += 1` for unsigned integers, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means: ```js uint i = 1;   i++; // == 1 but i == 2   ``` But `++i` returns the actual incremented value: ```js uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`, thus it costs more gas.  The same logic applies for `--i` and `i--`.  Consider using `++i` instead of `i++` or `i += 1` in the following instances:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## Arithmetics: Use `!= 0` instead of `> 0` for unsigned integers `uint` will never go below 0. Thus, `> 0` is gas inefficient in comparisons as checking if `!= 0` is sufficient and costs less gas.  Consider changing `> 0` to `!= 0` in these lines:   ```js contracts/NibblVault.sol:  227:        if(_adminFeeAmt > 0) {  243:        if(_adminFeeAmt > 0) { ```  ## Visibility: `public` functions can be set to `external` Calls to `external` functions are cheaper than `public` functions. Thus, if a function is not used internally in any contract, it should be set to `external` to save gas and improve code readability.  Consider changing following functions from `public` to `external`:   ```js contracts/NibblVaultFactory.sol:   64:        function getVaultAddress(   65:            address _curator,   66:            address _assetAddress,   67:            uint256 _assetTokenID,   68:            uint256 _initialSupply,   69:            uint256 _initialTokenPrice) public view returns(address _vault) {    76:        function getVaults() public view returns(ProxyVault[] memory ) {  contracts/Twav/Twav.sol:   44:        function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) { ```  ## Errors: Reduce the length of error messages (long revert strings) Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional `mstore`, along with additional overhead for computing memory offset, etc.  In these instances, consider shortening the revert strings to fit within 32 bytes, or using custom errors:     ```js contracts/NibblVaultFactory.sol:   48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low");   49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender");  107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE");  149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  ## Errors: Use modifiers instead of require statements duplicate access role checks Instead of using a `require` statement to check that `msg.sender` belongs to a certain role (e.g. `msg.sender` is owner), consider using modifiers. This would help to save gas and improve code clarity.  For example, to check that `msg.sender` is `owner`, a modifier can be written as such: ```js modifier isOwner() {   require(msg.sender == owner, "error");   _; } ```  Functions can then use `isOwner` to validate `msg.sender`, for example: ```js function setOwner(address _owner) external {   require(msg.sender == owner, "error");   // ... } ``` can be rewritten to: ```js function setOwner(address _owner) external isOwner {   // ... } ```  Instances where modifiers can be used include: ```js contracts/NibblVault.sol:  475:        require(msg.sender == curator,"NibblVault: Only Curator");  486:        require(msg.sender == curator,"NibblVault: Only Curator");  496:        require(msg.sender == bidder,"NibblVault: Only winner");  505:        require(msg.sender == bidder,"NibblVault: Only winner");  516:        require(msg.sender == bidder, "NibblVault: Only winner");  524:        require(msg.sender == bidder, "NibblVault: Only winner");  536:        require(msg.sender == bidder, "NibblVault: Only winner");  546:        require(msg.sender == bidder, "NibblVault: Only winner"); ```  ## Errors: Use multiple `require` statements instead of `&&` Instead of using a single `require` statement with the `&&` operator, using multiple `require` statements would help to save runtime gas cost. However, note that this results in a higher deployment gas cost, which is a fair trade-off.  A `require` statement can be split as such: ```js // Original code: require(a && b, 'error');  // Changed to: require(a, 'error: a'); require(b, 'error: b'); ```  Instances where multiple `require` statements should be used: ```js contracts/NibblVaultFactory.sol:  107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  ## Errors: Use custom errors instead of revert strings Since Solidity v0.8.4, custom errors should be used instead of revert strings due to: * Cheaper deployment cost * Lower runtime cost upon revert  Taken from [Custom Errors in Solidity](https://blog.soliditylang.org/2021/04/21/custom-errors/): > Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors can be defined using of the `error` statement, both inside or outside of contracts.  Instances where custom errors can be used instead:   ```js contracts/NibblVault.sol:  129:        require(unlocked == 1, 'NibblVault: LOCKED');  139:        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');  146:        require(status == Status.buyout, "NibblVault: status != buyout");  147:        require(buyoutEndTime <= block.timestamp, "NibblVault: buyoutEndTime <= now");  154:        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');  184:        require(_secondaryReserveRatio <= primaryReserveRatio, "NibblVault: Excess initial funds");  185:        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, "NibblVault: secResRatio too low");  325:        require(_minAmtOut <= _purchaseReturn, "NibblVault: Return too low");  351:        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell");  387:        require(_saleReturn >= _minAmtOut, "NibblVault: Return too low");  399:        require(block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now");  400:        require(status == Status.initialized, "NibblVault: Status!=initialized");  404:        require(_buyoutBid >= _currentValuation, "NibblVault: Bid too low");  444:        require(status == Status.buyout, "NibblVault: Status!=Buyout");  475:        require(msg.sender == curator,"NibblVault: Only Curator");  486:        require(msg.sender == curator,"NibblVault: Only Curator");  496:        require(msg.sender == bidder,"NibblVault: Only winner");  505:        require(msg.sender == bidder,"NibblVault: Only winner");  516:        require(msg.sender == bidder, "NibblVault: Only winner");  524:        require(msg.sender == bidder, "NibblVault: Only winner");  536:        require(msg.sender == bidder, "NibblVault: Only winner");  546:        require(msg.sender == bidder, "NibblVault: Only winner");  561:        require(block.timestamp <= deadline, "NibblVault: expired deadline");  564:        require(signer == owner, "NibblVault: invalid signature");  570:        require(success, "NibblVault: ETH transfer failed");  contracts/Basket.sol:   36:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   42:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   53:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   62:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   69:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   79:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   86:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");   92:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  contracts/NibblVaultFactory.sol:   48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low");   49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender");  107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE");  149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  contracts/Utilities/AccessControlMechanism.sol:   48:        require(pendingRoles[_role][msg.sender], "AccessControl: Role not pending"); ```  ## `lock` modifier in `NibblVault.sol` is unnecessary The function `buy()` in `NibblVault.sol` uses the `lock` modifier to prevent reentrancy. However, this is unneeded as: 1. All external calls are made to trusted contracts and cannot be hooked for reentrancy 2. `safeTransferETH` is used to transfer ETH only to `factory`, which is assumed to be a trusted contract   As such, `buy()` is not vulnerable to reentrancy and does not need the `lock` modifier. Furthermore, as `buy()` is the only function that uses the `lock` modifier, it can be removed from the contract entirely. This would help to save runtime and deployment gas costs.  ## Unnecessary definition of variables Some variables are defined even though they are only used once in their respective functions. Not defining these variables can help to reduce gas cost and contract size.  Instances include:   ```js contracts/NibblVault.sol:  378:        uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply; ```  ## Variables declared as `constant` are expressions, not constants Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was `immutable` instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.  See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232): > Consequences: each usage of a constant costs ~100 gas more on each access (it is still a little better than storing the result in storage, but not much). since these are not real constants, they cant be referenced from a real constant environment (e.g. from assembly, or from another library)  ```js contracts/NibblVault.sol:   51:        bytes32 private constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");  contracts/Utilities/AccessControlMechanism.sol:   12:        bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE");   13:        bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");   14:        bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE");  contracts/Utilities/EIP712Base.sol:    7:        bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(    8:            bytes(    9:                "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"   10:            )   11:        ); ```  Change these expressions from `constant` to `immutable` and implement the calculation in the constructor. Alternatively, hardcode these values in the constants and add a comment to say how the value was calculated.  ## Use `calldata` instead of `memory` for read-only function parameters If a reference type function parameter, such as arrays, is read-only, it is cheaper to use `calldata` instead of `memory`. This would help to save gas as values are read directly from calldata using `calldataload` and avoids additional intermediate memory operations.  Consider changing `memory` to `calldata` in the following functions: ```js contracts/Basket.sol:   41:        function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {   68:        function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {   91:        function withdrawMultipleERC20(address[] memory _tokens) external override {      contracts/NibblVault.sol:  504:        function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {  523:        function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {  545:        function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut { ```
#1 unmatch between comment and function (should be implementer_role) Impact Causing confuse to user and developer.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L156  Tool Used Manual review  Recommendation Mitigation Steps change from FEE_ROLE to IMPLEMENTER_ROLE   #2 Missing param natspec _totalSupply Impact _buyPrimaryCurve, _buySecondaryCurve, _sellPrimaryCurve and _sellSecondaryCurve function have natspec comment which is missing the _totalSupply function parameter. Issues with comments are low risk based on Code4rena risk categories.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L275  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L287  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L335  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L347  Tool Used Manual review  Recommendation Mitigation Steps Add natspec comments include _totalSupply parameter in function that mantion.   #3 Use call instead transfer Impact usage of send() or transfer() would cause an out of gas error.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L80  Tool Used Manual review  Recommendation Mitigation Steps use .call() because .transfer() fowards 2300 gas whereas .call() forwards all / set gas.    #4 Missing state admin Impact the constructor initialize _admin but the state admin was missing, and caused of it made constructor doesn't work properly.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L19  Tool Used Manual review  Recommendation Mitigation Steps i suggest to add state admin, so that the constructor can work to initialize param admin. and make it immutable   #5 constructor cant initialize the state Impact the constructor initialize _vaultImplementation, _feeTo, and _basketImplementation but the states was missing, and caused of it made constructor doesn't work properly.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L23  Tool Used Manual review  Recommendation Mitigation Steps i suggest to add state _vaultImplementation, _feeTo, and _basketImplementation, so that the constructor can work to initialize  _vaultImplementation, _feeTo, and _basketImplementation. and make it immutable    
## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | 1 | Setting `DEFAULT_ADMIN_ROLE` as the role admin is redundant | 1 | | 2 | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 23 | | 3 | Using `storage` instead of `memory` for structs/arrays saves gas | 2 | | 4 | State variables should be cached in stack variables rather than re-reading them from storage | 1 | | 5 | `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables | 7 | | 6 | `internal` functions only called once can be inlined to save gas | 1 | | 7 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement | 5 | | 8 | `<array>.length` should not be looked up in every loop of a `for`-loop | 6 | | 9 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 6 | | 10 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 7 | | 11 | Using `bool`s for storage incurs overhead | 1 | | 12 | Use a more recent version of solidity | 1 | | 13 | `>=` costs less gas than `>` | 1 | | 14 | It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied | 6 | | 15 | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 6 | | 16 | Splitting `require()` statements that use `&&` saves gas | 4 | | 17 | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 14 | | 18 | Using `private` rather than `public` for constants, saves gas | 3 | | 19 | Don't use `SafeMath` once the solidity version is 0.8.0 or greater | 1 | | 20 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 3 | | 21 | Empty blocks should be removed or emit something | 5 | | 22 | Use custom errors rather than `revert()`/`require()` strings to save gas | 41 | | 23 | Functions guaranteed to revert when called by normal users can be marked `payable` | 8 |  Total: 153 instances over 23 issues   ## Gas Optimizations  ### 1. Setting `DEFAULT_ADMIN_ROLE` as the role admin is redundant `DEFAULT_ADMIN_ROLE` is [automatically](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/83277ff916ac4f58fec072b8f28a252c1245c2f1/contracts/access/AccessControl.sol#L40-L48) designated as the role admin of any new role, so setting it again is a waste of gas since it involves fetching role-related state variables, updating state variables, and emitting an event  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  22           _setRoleAdmin(_defaultAdminRole, _defaultAdminRole); 23           _setRoleAdmin(FEE_ROLE, _defaultAdminRole); 24           _setRoleAdmin(PAUSER_ROLE, _defaultAdminRole); 25:          _setRoleAdmin(IMPLEMENTER_ROLE, _defaultAdminRole); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L22-L25  ### 2. Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution.   If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one  *There are 23 instances of this issue:* ```solidity File: contracts/Basket.sol  41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {  41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {  68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {  68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {  91:       function withdrawMultipleERC20(address[] memory _tokens) external override {  99:       function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {  104:      function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41  ```solidity File: contracts/NibblVaultFactory.sol  41:           string memory _name,  42:           string memory _symbol, ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L41  ```solidity File: contracts/NibblVault.sol  174:          string memory _tokenName,   175:          string memory _tokenSymbol,   504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {  504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {  523:      function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {  545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {  545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {  577:      function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L174  ### 3. Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There are 2 instances of this issue:* ```solidity File: contracts/Twav/Twav.sol   #1  38:               TwavObservation memory _twavObservationCurrent = twavObservations[(_index)]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L38  ```solidity File: contracts/Twav/Twav.sol   #2  39:               TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39  ### 4. State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  /// @audit secondaryReserveBalance on line 225 226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade  ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L226  ### 5. `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables  *There are 7 instances of this issue:* ```solidity File: contracts/NibblVault.sol  219:          feeAccruedCurator += _feeCurator;  225:          secondaryReserveBalance += _feeCurve;  242:          feeAccruedCurator += _feeCurator;  320:                  secondaryReserveBalance += _lowerCurveDiff;  380:                  primaryReserveBalance -= _saleReturn;  429:              totalUnsettledBids += _buyoutValuationDeposit;  457:          totalUnsettledBids -= _amount; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L219  ### 6. `internal` functions only called once can be inlined to save gas Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  27:       function getChainID() internal view returns (uint256 id) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L27  ### 7. Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There are 5 instances of this issue:* ```solidity File: contracts/NibblVault.sol  /// @audit require() on line 185 201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  /// @audit require() on line 404 406:          buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);  /// @audit require() on line 404 415:              safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));  /// @audit if-condition on line 373 378:                  uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;  /// @audit if-condition on line 414 415:              safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation)); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L201  ### 8. `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 9. `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 10. `require()`/`revert()` strings longer than 32 bytes cost extra gas Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**  *There are 7 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol  48:           require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low");  49:           require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender");  107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  141:          require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE");  149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48  ### 11. Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  16:       mapping(bytes32 => mapping(address => bool)) public pendingRoles; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L16  ### 12. Use a more recent version of solidity Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  4:    pragma solidity ^0.8.0; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4  ### 13. `>=` costs less gas than `>` The compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  224:          _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L224  ### 14. It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied Not overwriting the default for [stack variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves **8 gas**. Storage and memory variables have larger savings  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 15. `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) Saves **6 gas per loop**  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 16. Splitting `require()` statements that use `&&` saves gas See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper  *There are 4 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107  ```solidity File: contracts/NibblVaultFactory.sol   #2  131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131  ```solidity File: contracts/NibblVaultFactory.sol   #3  149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149  ```solidity File: contracts/NibblVaultFactory.sol   #4  166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166  ### 17. Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead > When using elements that are smaller than 32 bytes, your contracts gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  *There are 14 instances of this issue:* ```solidity File: contracts/NibblVault.sol  28:       uint32 private constant primaryReserveRatio = 200_000; //20%  57:       uint32 public secondaryReserveRatio;  183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));  303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  557:          uint8 v, ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28  ```solidity File: contracts/Twav/Twav.sol  6:            uint32 timestamp;  11:       uint8 public twavObservationsIndex;  12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks   13:       uint32 public lastBlockTimeStamp;  21:       function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {  22:           uint32 _timeElapsed;   37:               uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L6  ### 18. Using `private` rather than `public` for constants, saves gas If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table  *There are 3 instances of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  12:       bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12  ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #2  13:       bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L13  ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #3  14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L14  ### 19. Don't use `SafeMath` once the solidity version is 0.8.0 or greater Version 0.8.0 introduces internal overflow checks, so using `SafeMath` is redundant and adds overhead  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  9:    import { SafeMath } from  "@openzeppelin/contracts/utils/math/SafeMath.sol"; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L9  ### 20. Duplicated `require()`/`revert()` checks should be refactored to a modifier or function Saves deployment costs  *There are 3 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  42:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L42  ```solidity File: contracts/NibblVault.sol   #2  486:          require(msg.sender == curator,"NibblVault: Only Curator"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L486  ```solidity File: contracts/NibblVault.sol   #3  505:          require(msg.sender == bidder,"NibblVault: Only winner"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L505  ### 21. Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)  *There are 5 instances of this issue:* ```solidity File: contracts/Basket.sol  114:      receive() external payable {} ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L114  ```solidity File: contracts/NibblVaultFactory.sol  183:      receive() payable external {    } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L183  ```solidity File: contracts/NibblVault.sol  585:      receive() external payable {} ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L585  ```solidity File: contracts/Proxy/ProxyBasket.sol  56:       receive() external payable {    } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L56  ```solidity File: contracts/Proxy/ProxyVault.sol  56:       receive() external payable {    } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L56  ### 22. Use custom errors rather than `revert()`/`require()` strings to save gas Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hitby [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas  *There are 41 instances of this issue:* ```solidity File: contracts/Basket.sol  36:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  42:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  53:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  62:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  69:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  79:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  86:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed");  92:           require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L36  ```solidity File: contracts/NibblVaultFactory.sol  48:           require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low");  49:           require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender");  107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  141:          require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE");  149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed");  166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48  ```solidity File: contracts/NibblVault.sol  129:          require(unlocked == 1, 'NibblVault: LOCKED');  139:          require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');  146:          require(status == Status.buyout, "NibblVault: status != buyout");  147:          require(buyoutEndTime <= block.timestamp, "NibblVault: buyoutEndTime <= now");  154:          require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');  184:          require(_secondaryReserveRatio <= primaryReserveRatio, "NibblVault: Excess initial funds");  185:          require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, "NibblVault: secResRatio too low");  325:          require(_minAmtOut <= _purchaseReturn, "NibblVault: Return too low");  351:          require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell");  387:          require(_saleReturn >= _minAmtOut, "NibblVault: Return too low");  399:          require(block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now");  400:          require(status == Status.initialized, "NibblVault: Status!=initialized");  404:          require(_buyoutBid >= _currentValuation, "NibblVault: Bid too low");  444:          require(status == Status.buyout, "NibblVault: Status!=Buyout");  475:          require(msg.sender == curator,"NibblVault: Only Curator");  486:          require(msg.sender == curator,"NibblVault: Only Curator");  496:          require(msg.sender == bidder,"NibblVault: Only winner");  505:          require(msg.sender == bidder,"NibblVault: Only winner");  516:          require(msg.sender == bidder, "NibblVault: Only winner");  524:          require(msg.sender == bidder, "NibblVault: Only winner");  536:          require(msg.sender == bidder, "NibblVault: Only winner");  546:          require(msg.sender == bidder, "NibblVault: Only winner");  561:          require(block.timestamp <= deadline, "NibblVault: expired deadline");  564:          require(signer == owner, "NibblVault: invalid signature");  570:          require(success, "NibblVault: ETH transfer failed"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L129  ```solidity File: contracts/Utilities/AccessControlMechanism.sol  48:           require(pendingRoles[_role][msg.sender], "AccessControl: Role not pending"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L48  ### 23. Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 8 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol  99:       function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {  123:      function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {  140:      function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {  158:      function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {  173:      function pause() external onlyRole(PAUSER_ROLE) override {  179:      function unPause() external onlyRole(PAUSER_ROLE) override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99  ```solidity File: contracts/Utilities/AccessControlMechanism.sol  32:       function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external override onlyRole(getRoleAdmin(_role)) {  40:       function proposeGrantRole(bytes32 _role, address _to) external override onlyRole(getRoleAdmin(_role)) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L32 
## Summary  ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | 1 | Buyouts that occur during the timestamp wrap will have valuation errors | 1 | | 2 | `ecrecover()` not checked for signer address of zero | 1 | | 3 | Return values of `transfer()`/`transferFrom()` not checked | 4 | | 4 | Input array lengths may differ | 4 | | 5 | `_safeMint()` should be used rather than `_mint()` wherever possible | 1 | | 6 | Missing checks for `address(0x0)` when assigning values to `address` state variables | 6 | | 7 | Vulnerable to cross-chain replay attacks due to static `DOMAIN_SEPARATOR`/`domainSeparator` | 1 | | 8 | Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions | 1 | | 9 | Incorrect comments | 3 |  Total: 22 instances over 9 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | 1 | Consider addings checks for signature malleability | 1 | | 2 | Misleading variable name | 1 | | 3 | Inconsistent version of English being used | 2 | | 4 | Missing `initializer` modifier on constructor | 1 | | 5 | Contract implements interface without extending the interface | 1 | | 6 | `require()`/`revert()` statements should have descriptive reason strings | 1 | | 7 | `public` functions not called by the contract should be declared `external` instead | 3 | | 8 | Non-assembly method available | 1 | | 9 | `2**<n> - 1` should be re-written as `type(uint<n>).max` | 4 | | 10 | `constant`s should be defined rather than using magic numbers | 10 | | 11 | Cast is more restrictive than the type of the variable being assigned | 1 | | 12 | Missing event and or timelock for critical parameter change | 4 | | 13 | Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant` | 5 | | 14 | Inconsistent spacing in comments | 27 | | 15 | Lines are too long | 14 | | 16 | Non-library/interface files should use fixed compiler versions, not floating ones | 1 | | 17 | Typos | 14 | | 18 | File is missing NatSpec | 1 | | 19 | NatSpec is incomplete | 12 | | 20 | Event is missing `indexed` fields | 5 |  Total: 109 instances over 20 issues   ## Low Risk Issues  ### 1. Buyouts that occur during the timestamp wrap will have valuation errors The `_blockTimestamp` has a modulo applied, so at some point, there will be a timestamp with a value close to 2^32, followed by a timestamp close to zero. The `_updateTWAV` function does an unchecked subtraction of the two timestamps, so this will lead to an underflow, making the valuation based on a long time period rather than the actual one. Until more TWAV entries are added, valuations will be wrong  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  303              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); 304              if (_blockTimestamp != lastBlockTimeStamp) { 305:                 _updateTWAV(getCurrentValuation(), _blockTimestamp);    ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303-L305  ### 2. `ecrecover()` not checked for signer address of zero The `ecrecover()` function returns an address of zero when the signature does not match. This can cause problems if address zero is ever the owner of assets, and someone uses the permit function on address zero. If that happens, any invalid signature will pass the checks, and the assets will be stealable. In this case, the asset of concern is the vault's ERC20 token, and fortunately OpenZeppelin's implementation does a good job of making sure that address zero is never able to have a positive balance. If this contract ever changes to another ERC20 implementation that is laxer in its checks in favor of saving gas, this code may become a problem.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563  ### 3. Return values of `transfer()`/`transferFrom()` not checked Not all `IERC20` implementations `revert()` when there's a failure in `transfer()`/`transferFrom()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment  *There are 4 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  87:           IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87  ```solidity File: contracts/Basket.sol   #2  94:               IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94  ```solidity File: contracts/NibblVault.sol   #3  517:          IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517  ```solidity File: contracts/NibblVault.sol   #4  526:              IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526  ### 4. Input array lengths may differ If the caller makes a copy-paste error, the lengths may be mismatchd and an operation believed to have been completed may not in fact have been completed  *There are 4 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  41:      function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41  ```solidity File: contracts/Basket.sol   #2  68:      function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68  ```solidity File: contracts/NibblVault.sol   #3  545:     function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545  ```solidity File: contracts/NibblVault.sol   #4  504:     function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504  ### 5. `_safeMint()` should be used rather than `_mint()` wherever possible `_mint()` is [discouraged](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271) in favor of `_safeMint()` which ensures that the recipient is either an EOA or implements `IERC721Receiver`. Both [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L238-L250) and [solmate](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L180) have versions of this function  *There is 1 instance of this issue:* ```solidity File: contracts/Basket.sol   #1  24:           _mint(_curator, 0); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L24  ### 6. Missing checks for `address(0x0)` when assigning values to `address` state variables  *There are 6 instances of this issue:* ```solidity File: contracts/NibblVault.sol  191:          assetAddress = _assetAddress;  193:          curator = _curator;  487:          curator = _newCurator; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L191  ```solidity File: contracts/NibblVaultFactory.sol  100:         pendingBasketImplementation = _newBasketImplementation;  124:         pendingFeeTo = _newFeeAddress;  159:         pendingVaultImplementation = _newVaultImplementation; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100  ### 7. Vulnerable to cross-chain replay attacks due to static `DOMAIN_SEPARATOR`/`domainSeparator` See [this](https://github.com/code-423n4/2021-04-maple-findings/issues/2) issue from a prior contest for details  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  15       function INIT_EIP712(string memory name, string memory version) internal { 16           domainSeperator = keccak256( 17               abi.encode( 18                   EIP712_DOMAIN_TYPEHASH, 19                   keccak256(bytes(name)), 20                   keccak256(bytes(version)), 21                   getChainID(), 22                   address(this) 23               ) 24           ); 25:      } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15-L25  ### 8. Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20  ### 9. Incorrect comments  *There are 3 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  /// @audit ERC1155, not ERC721 58:      /// @notice withdraw an ERC721 token from this contract into your wallet ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L58  ```solidity File: contracts/Twav/Twav.sol   #2  /// @audit or zero if there have been fewer than four blocks 34:      /// @return _twav TWAV of the last 4 blocks ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34  ```solidity File: contracts/Twav/Twav.sol   #3  /// @audit of the last four updates, not necessarily of the last four blocks (i.e. may be blocked that were skipped) 34:      /// @return _twav TWAV of the last 4 blocks ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34  ## Non-critical Issues  ### 1. Consider addings checks for signature malleability Use OpenZeppelin's `ECDSA` contract rather than calling `ecrecover()` directly  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563  ### 2. Misleading variable name `_twavObservationPrev` is not the previous observation - it's more like the trailing, or next-to-expire TWAV observation`  *There is 1 instance of this issue:* ```solidity File: contracts/Twav/Twav.sol   #1  39:              TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39  ### 3. Inconsistent version of English being used Some functions use American English, whereas others use British English. A single project should use only one of the two  *There are 2 instances of this issue:* ```solidity File: contracts/NibblVault.sol   #1  173:     function initialize( ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L173  ```solidity File: contracts/Interfaces/IBasket.sol   #2  10:      function initialise(address _curator) external; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Interfaces/IBasket.sol#L10  ### 4. Missing `initializer` modifier on constructor OpenZeppelin [recommends](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the `initializer` modifier be applied to constructors in order to avoid potential griefs, [social engineering](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/4), or exploits. Ensure that the modifier is applied to the implementation contract. If the default constructor is currently being used, it should be changed to be an explicit one with the modifier applied.  *There is 1 instance of this issue:* ```solidity File: contracts/Basket.sol   #1  13:   contract Basket is IBasket, ERC721("NFT Basket", "NFTB"), Initializable { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13  ### 5. Contract implements interface without extending the interface Not extending the interface may lead to the wrong function signature being used, leading to unexpected behavior. If the interface is in fact being implemented, use the `override` keyword to indicate that fact  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  /// @audit onERC721Received(), onERC1155Received() 20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20  ### 6. `require()`/`revert()` statements should have descriptive reason strings  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  114:          require(_success); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114  ### 7. `public` functions not called by the contract should be declared `external` instead Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  *There are 3 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  64        function getVaultAddress( 65            address _curator, 66            address _assetAddress, 67            uint256 _assetTokenID, 68            uint256 _initialSupply, 69:           uint256 _initialTokenPrice) public view returns(address _vault) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L69  ```solidity File: contracts/NibblVaultFactory.sol   #2  76:       function getVaults() public view returns(ProxyVault[] memory ) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76  ```solidity File: contracts/Twav/Twav.sol   #3  44:       function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44  ### 8. Non-assembly method available  `assembly{ id := chainid() }` => `uint256 id = block.chainid`, `assembly { size := extcodesize() }` => `uint256 size = address().code.length`  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  29:               id := chainid() ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L29  ### 9. `2**<n> - 1` should be re-written as `type(uint<n>).max` Earlier versions of solidity can use `uint<n>(-1)` instead. Expressions not including the `- 1` can often be re-written to accomodate the change (e.g. by using a `>` rather than a `>=`, which will also save some gas)  *There are 4 instances of this issue:* ```solidity File: contracts/NibblVault.sol   #1  303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303  ```solidity File: contracts/NibblVault.sol   #2  365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L365  ```solidity File: contracts/NibblVault.sol   #3  413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32)); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L413  ```solidity File: contracts/NibblVault.sol   #4  445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L445  ### 10. `constant`s should be defined rather than using magic numbers Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals  *There are 10 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol  /// @audit 0xff 72:           bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));  /// @audit 0xff 91:           bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L72  ```solidity File: contracts/NibblVault.sol  /// @audit 1e18 183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));  /// @audit 1e18 195:          uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);  /// @audit 1e18 226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade   /// @audit 1e18 253:              return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));  /// @audit 32 303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  /// @audit 32 365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  /// @audit 32 413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));  /// @audit 32 445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183  ### 11. Cast is more restrictive than the type of the variable being assigned If `address foo` is being used in an expression such as `IERC20 token = FooToken(foo)`, then the more specific cast to `FooToken` is a waste because the only thing the compiler will check for is that `FooToken` extends `IERC20` - it won't check any of the function signatures. Therefore, it makes more sense to do `IERC20 token = IERC20(token)` or better yet `FooToken token = FooToken(foo)`. The former may allow the file in which it's used to remove the import for `FooToken`  *There is 1 instance of this issue:* ```solidity File: contracts/Proxy/ProxyBasket.sol   #1  /// @audit payable vs address 20:           implementation = payable(_implementation); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L20  ### 12. Missing event and or timelock for critical parameter change Events help non-contract tools to track changes, and events prevent users from being surprised by changes  *There are 4 instances of this issue:* ```solidity File: contracts/NibblVault.sol   #1  485       function updateCurator(address _newCurator) external override { 486           require(msg.sender == curator,"NibblVault: Only Curator"); 487           curator = _newCurator; 488:      } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L488  ```solidity File: contracts/NibblVaultFactory.sol   #2  100:         pendingBasketImplementation = _newBasketImplementation; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100  ```solidity File: contracts/NibblVaultFactory.sol   #3  124:         pendingFeeTo = _newFeeAddress; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L124  ```solidity File: contracts/NibblVaultFactory.sol   #4  159:         pendingVaultImplementation = _newVaultImplementation; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L159  ### 13. Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`  *There are 5 instances of this issue:* ```solidity File: contracts/NibblVault.sol  51:       bytes32 private constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L51  ```solidity File: contracts/Utilities/AccessControlMechanism.sol  12:       bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE");  13:       bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");  14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12  ```solidity File: contracts/Utilities/EIP712Base.sol  7         bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256( 8             bytes( 9                 "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)" 10            ) 11:       ); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L7-L11  ### 14. Inconsistent spacing in comments Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file  *There are 27 instances of this issue:* ```solidity File: contracts/NibblVault.sol  28:       uint32 private constant primaryReserveRatio = 200_000; //20%  34:       uint256 private constant REJECTION_PREMIUM = 150_000; //15%  46:       uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%  122:      ///@notice current status of vault  125:      ///@notice reenterancy guard  200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  220:          //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault  221:          //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance  226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade   228:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract  244:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract  301:          //Make update on the first tx of the block  318:                  //Gas Optimization  363:          //Make update on the first tx of the block  368:                  _rejectBuyout(); //For the case when TWAV goes up when updated on sell  377:                  //Gas Optimization  389:          safeTransferETH(_to, _saleReturn); //send _saleReturn to _to  402:          //_buyoutBid: Bid User has made  448:              _rejectBuyout(); //For the case when TWAV goes up when updated externally  500:      ///@notice withdraw multiple ERC721s ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28  ```solidity File: contracts/Proxy/ProxyBasket.sol  28:       //solhint-disable-next-line no-complex-fallback  31:           //solhint-disable-next-line no-inline-assembly ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L28  ```solidity File: contracts/Proxy/ProxyVault.sol  28:       //solhint-disable-next-line no-complex-fallback  31:           //solhint-disable-next-line no-inline-assembly ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L28  ```solidity File: contracts/Twav/Twav.sol  12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks   28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L12  ### 15. Lines are too long Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length  *There are 14 instances of this issue:* ```solidity File: contracts/Basket.sol  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L109  ```solidity File: contracts/NibblVaultFactory.sol  50:           _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this)))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L50  ```solidity File: contracts/NibblVault.sol  19:   /// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.  79:       /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply   201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  224:          _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance  226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade   263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance  266:              return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);  297:      /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both  358:      /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both  395:      /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L19  ```solidity File: contracts/Twav/Twav.sol  28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative  40:               _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L28  ### 16. Non-library/interface files should use fixed compiler versions, not floating ones  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  4:    pragma solidity ^0.8.0; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4  ### 17. Typos  *There are 14 instances of this issue:* ```solidity File: contracts/NibblVault.sol  /// @audit reenterancy 125:      ///@notice reenterancy guard  /// @audit pausablity 152:      /// @dev pausablity implemented in factory  /// @audit primaryReseveRatio 200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  /// @audit primaryReseveRatio 201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  /// @audit continous 250:      /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply  /// @audit seconday 263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance  /// @audit continous 270:      /// @param _amount amount of reserve tokens to buy continous tokens  /// @audit continous 282:      /// @param _amount amount of reserve tokens to buy continous tokens  /// @audit Continous 359:      /// @param _amtIn Continous Tokens to be sold  /// @audit recieve 361:      /// @param _to Address to recieve the reserve token to  /// @audit airdops 512:      /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops   /// @audit airdops 531:      /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops  ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L125  ```solidity File: contracts/Proxy/ProxyBasket.sol  /// @audit internall 26:        * This function does not return to its internall call site, it will return directly to the external caller. ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L26  ```solidity File: contracts/Proxy/ProxyVault.sol  /// @audit internall 26:        * This function does not return to its internall call site, it will return directly to the external caller. ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L26  ### 18. File is missing NatSpec  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol (various lines)   #1  ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol  ### 19. NatSpec is incomplete  *There are 12 instances of this issue:* ```solidity File: contracts/Basket.sol  /// @audit Missing: '@param _to' 32        /// @notice withdraw an ERC721 token from this contract into your wallet 33        /// @param _token the address of the NFT you are withdrawing 34        /// @param _tokenId the ID of the NFT you are withdrawing 35:       function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {  /// @audit Missing: '@param _to' 49        /// @notice withdraw an ERC721 token from this contract into your wallet 50        /// @param _token the address of the NFT you are withdrawing 51        /// @param _tokenId the ID of the NFT you are withdrawing 52:       function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {  /// @audit Missing: '@param _to' 58        /// @notice withdraw an ERC721 token from this contract into your wallet 59        /// @param _token the address of the NFT you are withdrawing 60        /// @param _tokenId the ID of the NFT you are withdrawing 61:       function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L32-L35  ```solidity File: contracts/NibblVaultFactory.sol  /// @audit Missing: '@return' 36        /// @param _initialTokenPrice desired initial token price 37        /// @param _minBuyoutTime minimum time after which buyout can be triggered 38        function createVault( 39            address _assetAddress, 40            address _curator, 41            string memory _name, 42            string memory _symbol, 43            uint256 _assetTokenID, 44            uint256 _initialSupply, 45            uint256 _initialTokenPrice, 46            uint256 _minBuyoutTime 47:           ) external payable override whenNotPaused returns(address payable _proxyVault) {  /// @audit Missing: '@return' 62        /// @param _initialSupply desired initial token supply 63        /// @param _initialTokenPrice desired initial token price     64        function getVaultAddress( 65            address _curator, 66            address _assetAddress, 67            uint256 _assetTokenID, 68            uint256 _initialSupply, 69:           uint256 _initialTokenPrice) public view returns(address _vault) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L36-L47  ```solidity File: contracts/NibblVault.sol  /// @audit Missing: '@param _totalSupply' 269       /// @notice function to buy tokens on the primary curve 270       /// @param _amount amount of reserve tokens to buy continous tokens 271       /// @dev This is executed when current supply >= initial supply 272       /// @dev _amount is charged with fee 273       /// @dev _purchaseReturn is minted to _to 274       /// @return _purchaseReturn Purchase return 275:      function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {  /// @audit Missing: '@param _totalSupply' 281       /// @notice function to buy tokens on secondary curve 282       /// @param _amount amount of reserve tokens to buy continous tokens 283       /// @dev This is executed when current supply < initial supply 284       /// @dev only admin and curator fee is charged in secondary curve 285       /// @dev _purchaseReturn is minted to _to 286       /// @return _purchaseReturn Purchase return 287:      function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {  /// @audit Missing: '@return' 298       /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails. 299       /// @param _to Address to mint the purchase return to 300:      function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {  /// @audit Missing: '@param _totalSupply' 330       /// @notice The function to sell fractional tokens on primary curve 331       /// @dev Executed when currentSupply > initialSupply 332       /// @dev _amount is charged with fee 333       /// @param _amount Amount of tokens to be sold on primary curve 334       /// @return _saleReturn Sale Return 335:      function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {  /// @audit Missing: '@param _totalSupply' 342       /// @notice The function to sell fractional tokens on secondary curve 343       /// @dev Executed when current supply <= initial supply 344       /// @dev only admin and curator fee is charged in secondary curve 345       /// @param _amount Amount of tokens to be sold on SecondaryCurve 346       ///  @return _saleReturn Sale Return 347:      function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){  /// @audit Missing: '@return' 360       /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails. 361       /// @param _to Address to recieve the reserve token to 362:      function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {  /// @audit Missing: '@return' 472       /// @param _to the address where curator fee will be sent 473       /// @dev can only be called by curator 474:      function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L269-L275  ### 20. Event is missing `indexed` fields Each `event` should use three `indexed` fields if there are three or more fields  *There are 5 instances of this issue:* ```solidity File: contracts/Basket.sol  15:       event DepositERC721(address indexed token, uint256 tokenId, address indexed from);  16:       event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);  17:       event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);  18:       event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);  19:       event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L15  
**Overview**  Risk Rating | Number of issues --- | --- Gas Issues | 19  **Table of Contents:**  - [1. Use of the `memory` keyword when `storage` should be used](#1-use-of-the-memory-keyword-when-storage-should-be-used) - [2. Unchecking arithmetics operations that can't underflow/overflow](#2-unchecking-arithmetics-operations-that-cant-underflowoverflow) - [3. Caching storage values in memory](#3-caching-storage-values-in-memory) - [4. Cheap Contract Deployment Through Clones](#4-cheap-contract-deployment-through-clones) - [5. Reduce the size of error messages (Long revert Strings)](#5-reduce-the-size-of-error-messages-long-revert-strings) - [6. SafeMath is not needed when using Solidity version 0.8+](#6-safemath-is-not-needed-when-using-solidity-version-08) - [7. Duplicated conditions should be refactored to a modifier or function to save deployment costs](#7-duplicated-conditions-should-be-refactored-to-a-modifier-or-function-to-save-deployment-costs) - [8. Internal/Private functions only called once can be inlined to save gas](#8-internalprivate-functions-only-called-once-can-be-inlined-to-save-gas) - [9. `>=` is cheaper than `>` (and `<=` cheaper than `<`)](#9--is-cheaper-than--and--cheaper-than-) - [10. Splitting `require()` statements that use `&&` saves gas](#10-splitting-require-statements-that-use--saves-gas) - [11. Using private rather than public for constants saves gas](#11-using-private-rather-than-public-for-constants-saves-gas) - [12. Amounts should be checked for 0 before calling a transfer](#12-amounts-should-be-checked-for-0-before-calling-a-transfer) - [13. `<array>.length` should not be looked up in every loop of a `for-loop`](#13-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop) - [14. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#14-i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [15. Increments/decrements can be unchecked in for-loops](#15-incrementsdecrements-can-be-unchecked-in-for-loops) - [16. Public functions to external](#16-public-functions-to-external) - [17. It costs more gas to initialize variables with their default value than letting the default value be applied](#17-it-costs-more-gas-to-initialize-variables-with-their-default-value-than-letting-the-default-value-be-applied) - [18. Use Custom Errors instead of Revert Strings to save Gas](#18-use-custom-errors-instead-of-revert-strings-to-save-gas) - [19. Functions guaranteed to revert when called by normal users can be marked `payable`](#19-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable)  ## 1. Use of the `memory` keyword when `storage` should be used  Here, the `storage` keyword should be used instead of `memory`:  ```diff File: Twav.sol 35:     function _getTwav() internal view returns(uint256 _twav){ 36:         if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) { 37:             uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS; - 38:             TwavObservation memory _twavObservationCurrent = twavObservations[(_index)]; + 38:             TwavObservation storage _twavObservationCurrent = twavObservations[(_index)]; - 39:             TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; + 39:             TwavObservation storage _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; 40:             _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp); 41:         } 42:     } ```  ## 2. Unchecking arithmetics operations that can't underflow/overflow  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  Consider wrapping with an `unchecked` block here:  - File: NibblVault.sol  ```diff 311:         if (_totalSupply >= _initialTokenSupply) { ... 313:         } else { ... - 319:                 _purchaseReturn = _initialTokenSupply - _totalSupply;  + 319:                 unchecked { _purchaseReturn = _initialTokenSupply - _totalSupply; } ```  ```diff 373:         if(_totalSupply > _initialTokenSupply) { ... - 378:                 uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply; + 378:                 unchecked { uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply; } ```  ```diff 414:         if (_buyoutBid > _currentValuation) { - 415:             safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation)); + 415:             unchecked { safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation) }); ```  ## 3. Caching storage values in memory  The code can be optimized by minimising the number of SLOADs.  SLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.  See the `@audit` tags for details about the multiple SLOADs where a cached value should be used instead of `SLOAD 2` and above:  - `twavObservationsIndex`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L27-L29>  ```solidity File: Twav.sol 27:         uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation; 28:         twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative 29:         twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS; ```  - `secondaryReserveBalance`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L222-L226>  ```solidity File: NibblVault.sol 222:         uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance; ... 226:         secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade  ```  - `secondaryReserveBalance`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L314-L320>  ```solidity File: NibblVault.sol 314:             uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance; ... 320:                 secondaryReserveBalance += _lowerCurveDiff; ```  - `primaryReserveBalance`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L379-L380>  ```solidity File: NibblVault.sol 379:                 _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance; 380:                 primaryReserveBalance -= _saleReturn; ```  - `basketUpdateTime`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107>  ```solidity File: NibblVaultFactory.sol 107:         require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  - `feeToUpdateTime`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131>  ```solidity File: NibblVaultFactory.sol 131:         require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  - `vaultUpdateTime`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166>  ```solidity File: NibblVaultFactory.sol 166:         require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  ## 4. Cheap Contract Deployment Through Clones  See `@audit` tag:  ```solidity 67:     function _executeTransfer(address _owner, uint256 _idx) internal { 68:         (bytes32 salt, ) = precompute(_owner, _idx); 69:         new FlashEscrow{salt: salt}( //@audit gas: deployment can cost less through clones 70:             nftAddress, 71:             _encodeFlashEscrowPayload(_idx) 72:         ); 73:     } ```  ```solidity NibblVaultFactory.sol:50:        _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this)))); NibblVaultFactory.sol:81:        address payable _basketAddress = payable(new ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation)); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  Consider applying a similar pattern, here with a `cloneDeterministic` method to mimic the current `create2`  ## 5. Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity NibblVaultFactory.sol:48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low"); NibblVaultFactory.sol:49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender"); NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE"); NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  Consider shortening the revert strings to fit in 32 bytes.  ## 6. SafeMath is not needed when using Solidity version 0.8+  Solidity version 0.8+ already implements overflow and underflow checks by default. Using the SafeMath library from OpenZeppelin (which is more gas expensive than the 0.8+ overflow checks) is therefore redundant.  Consider using the built-in checks instead of SafeMath and remove SafeMath here:  ```solidity NibblVaultFactory.sol:3:pragma solidity 0.8.10; NibblVaultFactory.sol:9:import { SafeMath } from  "@openzeppelin/contracts/utils/math/SafeMath.sol"; ```  ## 7. Duplicated conditions should be refactored to a modifier or function to save deployment costs  ```solidity Basket.sol:36:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:42:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:53:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:62:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:69:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:79:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:86:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:92:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); ```  ```solidity NibblVault.sol:475:        require(msg.sender == curator,"NibblVault: Only Curator"); NibblVault.sol:486:        require(msg.sender == curator,"NibblVault: Only Curator"); ```  ```solidity NibblVault.sol:496:        require(msg.sender == bidder,"NibblVault: Only winner"); NibblVault.sol:505:        require(msg.sender == bidder,"NibblVault: Only winner"); NibblVault.sol:516:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:524:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:536:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:546:        require(msg.sender == bidder, "NibblVault: Only winner"); ```  ## 8. Internal/Private functions only called once can be inlined to save gas  Not inlining costs 20 to 40 gas because of two extra `JUMP` instructions and additional stack operations needed for function calls.  Affected code:  - `NibblVault.sol#getMaxSecondaryCurveBalance()` ```solidity contracts/NibblVault.sol:   252:     function getMaxSecondaryCurveBalance() private view returns(uint256){   314:             uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance; ```  ## 9. `>=` is cheaper than `>` (and `<=` cheaper than `<`)  Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas). This also holds true between `<=` and `<`.    Consider replacing strict inequalities with non-strict ones to save some gas here:  ```solidity NibblVault.sol:224:        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance ```  ## 10. Splitting `require()` statements that use `&&` saves gas  If you're using the Optimizer at 200, instead of using the `&&` operator in a single require statement to check multiple conditions, Consider using multiple require statements with 1 condition per require statement:  ```solidity NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  Please, note that this might not hold true at a higher number of runs for the Optimizer (10k). However, it indeed is true at 200.  ## 11. Using private rather than public for constants saves gas  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  ```solidity Utilities/AccessControlMechanism.sol:12:    bytes32 public constant FEE_ROLE = keccak256("FEE_ROLE"); Utilities/AccessControlMechanism.sol:13:    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE"); Utilities/AccessControlMechanism.sol:14:    bytes32 public constant IMPLEMENTER_ROLE = keccak256("IMPLEMENTER_ROLE"); Utilities/NibblVaultFactoryData.sol:7:    uint256 public constant MAX_ADMIN_FEE = 10_000; //1%  ```  ## 12. Amounts should be checked for 0 before calling a transfer  Checking non-zero transfer values can avoid an expensive external call and save gas (especially in loops, like in `NibblVault.sol#withdrawMultipleERC20()`).    Consider adding a non-zero-value check here:  ```solidity   Basket.sol:80:        _to.transfer(address(this).balance); Basket.sol:87:        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this))); Basket.sol:94:            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this))); NibblVault.sol:517:        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this))); NibblVault.sol:526:            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this))); ```    ## 13. `<array>.length` should not be looked up in every loop of a `for-loop`  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, Consider storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  ## 14. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, "This will be false as i is incremented after the comparison"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, "This will be true as i is incremented before the comparison"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## 15. Increments/decrements can be unchecked in for-loops  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Affected code:    ```solidity Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  The change would be:      ```diff - for (uint256 i; i < numIterations; i++) { + for (uint256 i; i < numIterations;) {  // ...   +   unchecked { ++i; } }   ```  The same can be applied with decrements (which should use `break` when `i == 0`).  The risk of overflow is non-existant for `uint256` here.  ## 16. Public functions to external  An external call cost is less expensive than one of a public function. The following functions could be set external to save gas and improve code quality (extracted from Slither).  ```solidity Twav/Twav.sol:44:    function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) { NibblVaultFactory.sol:76:    function getVaults() public view returns(ProxyVault[] memory ) { ```  ## 17. It costs more gas to initialize variables with their default value than letting the default value be applied  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Affected code:  ```solidity Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  Consider removing explicit initializations for default values.  ## 18. Use Custom Errors instead of Revert Strings to save Gas  Solidity 0.8.4 introduced custom errors. They are more gas efficient than revert strings, when it comes to deploy cost as well as runtime cost when the revert condition is met. Use custom errors instead of revert strings for gas savings.  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Consider replacing all revert strings with custom errors in the solution.  ```solidity Utilities/AccessControlMechanism.sol:48:        require(pendingRoles[_role][msg.sender], "AccessControl: Role not pending"); Basket.sol:36:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:42:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:53:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:62:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:69:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:79:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:86:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); Basket.sol:92:        require(_isApprovedOrOwner(msg.sender, 0), "withdraw:not allowed"); NibblVault.sol:129:        require(unlocked == 1, 'NibblVault: LOCKED'); NibblVault.sol:139:        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out'); NibblVault.sol:146:        require(status == Status.buyout, "NibblVault: status != buyout"); NibblVault.sol:147:        require(buyoutEndTime <= block.timestamp, "NibblVault: buyoutEndTime <= now"); NibblVault.sol:154:        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused'); NibblVault.sol:184:        require(_secondaryReserveRatio <= primaryReserveRatio, "NibblVault: Excess initial funds"); NibblVault.sol:185:        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, "NibblVault: secResRatio too low"); NibblVault.sol:325:        require(_minAmtOut <= _purchaseReturn, "NibblVault: Return too low"); NibblVault.sol:351:        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, "NibblVault: Excess sell"); NibblVault.sol:387:        require(_saleReturn >= _minAmtOut, "NibblVault: Return too low"); NibblVault.sol:399:        require(block.timestamp >= minBuyoutTime, "NibblVault: minBuyoutTime < now"); NibblVault.sol:400:        require(status == Status.initialized, "NibblVault: Status!=initialized"); NibblVault.sol:404:        require(_buyoutBid >= _currentValuation, "NibblVault: Bid too low"); NibblVault.sol:444:        require(status == Status.buyout, "NibblVault: Status!=Buyout"); NibblVault.sol:475:        require(msg.sender == curator,"NibblVault: Only Curator"); NibblVault.sol:486:        require(msg.sender == curator,"NibblVault: Only Curator"); NibblVault.sol:496:        require(msg.sender == bidder,"NibblVault: Only winner"); NibblVault.sol:505:        require(msg.sender == bidder,"NibblVault: Only winner"); NibblVault.sol:516:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:524:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:536:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:546:        require(msg.sender == bidder, "NibblVault: Only winner"); NibblVault.sol:561:        require(block.timestamp <= deadline, "NibblVault: expired deadline"); NibblVault.sol:564:        require(signer == owner, "NibblVault: invalid signature"); NibblVault.sol:570:        require(success, "NibblVault: ETH transfer failed"); NibblVaultFactory.sol:48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, "NibblVaultFactory: Initial reserve balance too low"); NibblVaultFactory.sol:49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, "NibblVaultFactory: Invalid sender"); NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:114:        require(_success); NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:141:        require(_newFee <= MAX_ADMIN_FEE, "NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE"); NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ```  ## 19. Functions guaranteed to revert when called by normal users can be marked `payable`  If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.  ```solidity Utilities/AccessControlMechanism.sol:32:    function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external override onlyRole(getRoleAdmin(_role)) { Utilities/AccessControlMechanism.sol:40:    function proposeGrantRole(bytes32 _role, address _to) external override onlyRole(getRoleAdmin(_role)) { NibblVaultFactory.sol:99:    function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) { NibblVaultFactory.sol:123:    function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) { NibblVaultFactory.sol:140:    function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) { NibblVaultFactory.sol:158:    function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) { NibblVaultFactory.sol:173:    function pause() external onlyRole(PAUSER_ROLE) override { NibblVaultFactory.sol:179:    function unPause() external onlyRole(PAUSER_ROLE) override { ``` 
### [G01] Public Functions that can be External  The following functions are never called in their contracts and can be switched to external to save gas: [NibblVaultFactory.sol#L64-L69](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L69) [NibblVaultFactory.sol#L76](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76) [NibblVaultFactory.sol#L80](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80) [NibblVaultFactory.sol#L88](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88) [Twav.sol#L44](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44)   ### [G02] Unchecked Increments in Loops  When incrementing i in for loops there is no chance of overflow so unchecked can be used to save gas. I ran a simple test in remix and found deployment savings of 31,653 gas and on each function call saved ~141 gas per iteration.  ``` contract Test {  function loopTest() external {   for (uint256 i; i < 1; ++i) {   Deployment Cost: 125,637, Cost on function call: 24,601   vs   for (uint256 i; i < 1; ) {   // for loop body   unchecked { ++i }   Deployment Cost: 93,984, Cost on function call: 24,460   }  } } ```  For loops that can use unchecked increments: [NibblVault.sol#L506](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506) [NibblVault.sol#L525](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525) [NibblVault.sol#L547](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547) [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43) [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70) [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93)   ### [G03] Pre Increments in Loops  In for loops pre increments can also be used to save a small amount of gas per iteration. I ran a test in remix using a for loop and found the deployment savings of 497 gas and ~5 gas per iteration.  ``` contract Test {  function loopTest() external {   for (uint256 i; i < 1; i++) {   (Deployment cost: 118,408, Cost on function call: 24,532)   vs   for (uint256 i; i < 1; ++i) {   (Deployment cost: 117,911, Cost on function call: 24,527)   }  } } ```  For loops that can use pre increments: [NibblVault.sol#L506](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506) [NibblVault.sol#L525](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525) [NibblVault.sol#L547](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547) [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43) [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70) [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93)   ### [G04] Custom Errors As your using a solidity version > 0.8.4 for most of the contracts you can replace revert strings with custom errors. This will save in deployment costs and runtime costs. I ran a test in remix comparing a revert string vs custom errors and found that replacing a single revert string with a custom error saved 12,404 gas in deployment cost and 86 gas on each function call.   ``` contract Test {  uint256 a;  function check() external {   require(a != 0, "check failed");  } }   (Deployment cost: 114,703, Cost on Function call: 23,392) vs  contract Test {  uint256 a;  error checkFailed();  function check() external {   if (a != 0) revert checkFailed();  } }   (Deployment cost: 102,299, Cost on Function call: 23,306) ```  There are 41 revert strings throughout your contracts that can be replaced with custom errors.   ### [G05] Long Revert Strings  If you opt not to use custom errors keeping revert strings <= 32 bytes in length will save gas.  I ran a test in remix and found the savings for a single short revert string vs long string to be 9,377 gas in deployment cost and 18 gas on function call.  ``` contract Test {  uint256 a;  function check() external {   require(a != 0, "short error message");    (Deployment cost: 114,799, Cost on function call: 23,392)    vs    require(a != 0, "A longer Error Message over 32 bytes in              length");    (Deployment cost: 124,176, Cost on function call: 23,410)   } } ```  I recommend shortenning the following revert strings to < 32 bytes in length: [NibblVaultFactory.sol#L48-L49](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48-L49) [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107) [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131) [NibblVaultFactory.sol#L141](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141) [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149) [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)   ### [G06] && in Require Statements  If optimising for runtime costs over deployment costs you can seperate && in require functions into 2 parts. I ran a basic test in remix and it cost an extra 234 gas to deploy but will save ~9 gas everytime the require function is called.  ``` contract Test {  uint256 a = 0;  uint256 b = 1;   function test() external {   require(a == 0 && b > a)    (Deployment cost: 123,291, Cost on function call: 29,371)   vs   require(a == 0);   require(b > a);   (Deployment cost: 123,525, Cost on function call: 29,362)  } } ```  Require statements that can be split up: [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107) [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131) [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149) [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)   ### [G07] Packing Variables  Moving the uint32 variable primaryReserveRatio down to line 52  will it allow it to be stored with secondaryReserveRatio and use 1 less storage slot (save 20,000 gas). [NibblVault.sol#L28](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28)   ### [G08] Calldata Over Memory  When using function arguments that you only need to reference and not make any modifications to it is cheaper to use calldata than memory.  Instances where calldata can be used instead of memory: [NibblVaultFactory.sol#L41-L42](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L41-L42) [NibblVaultFactory.sol#L80](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80) [NibblVaultFactory.sol#L88](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88) [NibblVault.sol#L174-L175](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L174-L175) [NibblVault.sol#L504](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504) [NibblVault.sol#L523](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L523) [NibblVault.sol#L545](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545) [Basket.sol#L41](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41) [Basket.sol#L68](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68) [Basket.sol#L91](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L91) [EIP712Base.sol#L15](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15)  ### [G09] Minimize SLOAD's Whenever referencing a storage variable more than once in a function without modifying it, it is cheaper to cache locally and use that instead.  (normally 100 gas each use vs 103 gas to SLOAD/MSTORE for the first use and then only 3 gas for any others)  [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107) can cache basketUpdateTime (save ~97 gas) [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131) can cache feeToUpdateTime (save ~97 gas) [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149) can cache feeAdminUpdateTime (save ~97 gas) [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166) can cache vaultUpdateTime (save ~97 gas) For the previous 4 make sure to only use cached variables when referencing not when deleting. [NibblVault.sol#L139](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L139) can cache buyoutEndTime (save ~97 gas) [Twav.sol#L27-L29](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L27-L29) can cache twavObservationsIndex (save ~194 gas) On line 29 ensure the cached value is only used on the right side of the assignment.   ### [G10] Using smaller than 32 byte uints (uint256) can cost more As explained in [Solidity Docs](https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html) using elements smaller than 32 bytes can cost more gas. Recommend replacing the follpwing with uint256: [Twav.sol#L22](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L22) [Twav.sol#L37](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L37) 
# Low Risk Vulnerabilities ## 1. `getBasketAddress` could return inaccurate value if `basketImplementation` changes It is possible that the `basketImplementation` gets upgraded to a new address. If an integrator relies on `getBasketAddress` to deterministically determine the  address of a basket that has been deployed using the old implementation, it will return the incorrect address.  ### Recommended Mitigation Steps Consider adding an extra parameter `_implementation` or overload the function with the extra parameter: ``` function getBasketAddress(address _curator, string memory _mix, address _basketImplementation) public override view returns(address _basket) {     bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix));     bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(_basketImplementation)));     bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));     _basket = address(uint160(uint256(hash)));      } ```  ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88-L93  ## 2. Missing sanity check on `_minBuyoutTime` When creating a vault, a faulty deployment payload could set `minBuyoutTime` to a very high value, virtually disabling the buyout function.  ### Recommended Mitigation Steps Consider adding a sanity check to make sure it's set within a reasonable value: ``` require(_minBuyoutTime <= 52 weeks, "NibblVault: minBuyoutTime must not be longer than one year"); ``` ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L202  ## 3. Check `_feeAdmin` instead of `_adminFeeAmt` When charging fee in `_chargeFee` and `_chargeFeeSecondaryCurve`, there's a check to ensure `_adminFeeAmt` is larger than zero before transferring the funds to `feeAdmin`.  It is possible for `_adminFeeAmt` to be higher than zero yet `_feeAdmin` returns zero because of rounding. Therefore, it will be more accurate to use `_feeAdmin` instead. ### PoC ``` uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ; ``` When `_amount  * _adminFeeAmt` is lower than `SCALE`, `_feeAdmin` will have the value of `0`. ### Recommended Mitigation Steps Check that `_feeAdmin` is larger than `0` instead: ``` if(_feeAdmin > 0) {     safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract } ``` ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L227 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L243  # Non-Critical Vulnerabilities ## 1. Uncustomizable Basket details When creating a basket, the basket name and symbol is fixed to "NFT Basket" and "NFTB" respectively. It would be hard for users to distinguish one basket from another when seen through etherscan or wallets.   ### Recommended Mitigation Steps Consider adding an extra parameter so basket creator can append a unique identifier for the baskets. For instance, when making a basket containing CryptoPunks, the name and symbol would be: ``` NFT Basket - Punks NFTB-PUNKS ``` ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L82 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13  
1. Use != 0 instead of > 0 for uint variables - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L227 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L243   2. No need to initialize variables with default values - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  3. Use ++i instead of i++, i+=1, also unchecked increments in for-loops will save gas cost - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  4. An arrays length should be cached to save gas in for-loops - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  5. Non-strict inequalities are cheaper than strict ones - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L224  6. Usage of unchecked can reduce the gas cost - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L319 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L378  7. require()/revert() strings longer than 32 bytes cost extra gas - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L49 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L105 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166  8. Check zero amount before transfer - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L458 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L468 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L478  9. Check "_feeAdmin != 0" instead of "_adminFeeAmt > 0". The real transfer amount is _feeAdmin and this value might be zero even though _adminFeeAmt > 0 according to [fee calculation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L216)  - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L227 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L243   10. Needless calculation From the calculation, we can see "(_index + 1) % TWAV_BLOCK_NUMBERS" is same as "twavObservationsIndex" because "_index" is the previous index of "twavObservationsIndex".  - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39
# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L36   # Vulnerability details  ## Impact The "if" condition of Twav._getTwav() is missing some edge cases. In this case, this function will return 0 which is different from the correct value and it will affect the main functions like NibblVault.buy() and NibblVault.sell().  ## Proof of Concept I think this condition is to confirm at least 4 values were saved for twav calculation. Btw this timestamp would be zero even though there are more than 4 values properly as it's modularized by 2**32. In this case, the if condition will be false and this function will return 0.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps I see "cumulativeValuation" is increasing all the time and recommend replacing "timestamp" with "cumulativeValuation". ``` if (twavObservations[TWAV_BLOCK_NUMBERS - 1].cumulativeValuation != 0) { ```  
# [L-01] `ecrecover` does not check for zero address  The solidity `ecrecover` function is called directly to verify the given signatures. However, the `ecrecover` EVM opcode allows malleable (non-unique) signatures and thus is susceptible to replay attacks. A replay attack may not be possible here, but ensuring the signatures are not malleable is considered a best practice.  https://github.com/code-423n4/2022-06-nibbl/tree/main/contracts/NibblVault.sol#L563  ## Recommended Mitigation Steps  Use the `recover` function from [OpenZeppelin's ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) for signature verification. This is what OpenZeppelin does in their [ERC20 permit implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/83277ff916ac4f58fec072b8f28a252c1245c2f1/contracts/token/ERC20/extensions/draft-ERC20Permit.sol#L64).
# `Twav.sol`  ## `timestamp` in `TwavObservation` is declared as `uint32` but cannot be packed with other variables  Usually, it makes sense to try to follow a Tight Variable Packing approach to not waste gas, but in this case, it's useless and will only cost more gas.  The `timestamp` variable inside the struct will anyway take a whole slot because after it's declaration we have `cumulativeValuation` that is a `uint256`.  Declaring `timestamp` as a `uint256` will allow `NibblVault` to waste less gas because there is no more need to perform all the math + cast operations done on the timestamp (example: `uint32 _blockTimestamp = uint32(block.timestamp % 2**32);`).  Consider change the type of `timestamp` to a `uint256` 
# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L173 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L23 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99   # Vulnerability details  ## Impact In OpenZeppelin Contracts (proxy/utils/Initializable.sol): > CAUTION: An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation...   ## Proof of Concept This can lead to takeover of 2 contracts: `Basket.sol` and `NibblVault.sol` since implementation contracts not initialized and can be initialized publicly. https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol   Also, Upgrading either of their implementation in `NibblVaultFactory.sol` when  `proposeNewVaultImplementation(address _newVaultImplementation)` or `proposeNewBasketImplementation(address _newBasketImplementation)` can lead to the same issue if the upgraded contract did not disable initializers. https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99    ## Recommended Mitigation Steps As its mentioned in OpenZeppelin Contracts documentation:  >To prevent the implementation contract from being used, you should invoke the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:   ``` /// @custom:oz-upgrades-unsafe-allow constructor     constructor() {         _disableInitializers();     } ```  Should both of `Basket.sol` and `NibbleVault.sol` use the `_disableInitializers();` which make the implementation contract unable to be initialized to version 1. Hence, for newer version of `Basket.sol` and `NibbleVault.sol` proposed for the factory should also be initialized to version 1 to prevent the attack https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L165 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L130  
 DEFAULT_ADMIN_ROLE is already default admin role for all roles https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/AccessControlMechanism.sol#L22-25 Those lines are obsolete  --------------------------------------------------------------- Unused receive() function will lock Ether in contract  If the intention is for the Ether to be used, the function should call another function, otherwise it should revert https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L183 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L585 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L114 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyBasket.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyVault.sol#L56  -----------------------------------------------------------  Missing checks for address(0x0) when assigning values to address state variables  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L193 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L191 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L487 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L124 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L132 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L159 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L167  -----------------------------------------------------------  public functions not called by the contract should be declared external instead  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L69 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L76 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L80 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L88 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Twav/Twav.sol#L44  --------------------------------------------------------------------------- Use a more recent version of solidity  Use a solidity version of at least 0.8.12 to get string.concat() to be used instead of abi.encodePacked(,) ----------------------------------------------------------- 
1. Unbounded loops The following contains a for loop that can be unbounded. This would mean it could run out of gas and the function would revert   **Occurrences in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L93 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L93 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L506 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547     2. Missing input validation on array lengths The functions below fail to perform input validation on arrays to verify the lengths match. A mismatch could lead to an exception or undefined behavior.  **Occurences in: NibblVault.withdrawMultipleERC721() -  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L504 NibblVault.withdrawMultipleERC1155() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L545 NibblVault.onERC1155BatchReceived() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L545 Basket.withdrawMultipleERC721() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L41 Basket.withdrawMultipleERC1155() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L68 Basket.onERC1155BatchReceived() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L109   3. Missing validation check for non-zero totalSupply() NibblVault.redeem() doesn't check for a non-zero totalSupply to prevent a divide-by-zero issue in https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L466   4. Use of unchecked transfer() The following are functions make use of unsafe transfer() which does not check the return value.  **Occurrences in: Basket.withdrawERC20() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L87 Basket.withdrawMultipleERC20() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L94 NibblVault.withdrawERC20() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L517 NibblVault.withdrawMultipleERC20() -  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L526 Basket.withdrawETH() -  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L80   5. Missing zero address check during transfers The following functions are missing a zero address check to prevent transfer of ETH or ERC to zero address  **Occurrences in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L454-L459 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L464-L469 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L474-L479 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L504-L509 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L495-L498 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L362-L389 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L300-L326 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L515-L518 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L523-L528 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L535-L539 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L545-L550 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L35-L37 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L41-L44 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L52-L54 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L61-L64 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L68-L72    6. Missing zero address check can make curator lose fee The `updateCurator()` function in https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L485-L488 is missing a require check to ensure the `_to` parameter is not a zero address. Current function could have the curator address changed to 0 address by mistake and with that the accrued curator fees will not be redeemable.   7. Missing zero address check on new Basket Implementation proposeNewBasketImplementation() sets the address for a proposed new Basket Implementation, however fails to check `_newBasketImplementation` is not a zero address. This can allow IMPLEMENTER_ROLE to mistakenly set the proposed new Basket Implementation to address zero and call updateBasketImplementation() to effect the change.  **Occurrence in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L99-L100    8. Missing zero address check on new Admin Fee address proposeNewAdminFeeAddress() sets the address for a proposed new Admin Fee address, however fails to check `_newFeeAddress` is not a zero address. TThis can allow IMPLEMENTER_ROLE to mistakenly set the proposed new Admin Fee address to address zero and the call updateNewAdminFeeAddress() to effect the change.  **Occurrence in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L123    9. Missing zero address check on new Vault plementationproposeNewVaultImplementation() sets the address for a proposed new Vault Implementation, however fails to check `_newVaultImplementation` is not a zero address. This can allow IMPLEMENTER_ROLE to mistakenly set the proposed new Vault Implementation to address zero and call updateVaultImplementation() to effect the change.  **Occurrence in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L158     10. Missing zero address check and zero value check in constructor https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L23   11. Contract can lock ETH. Some contracts' receive() function allows anyone to send ETH to the contract since it's missing a require check https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L183 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyVault.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyBasket.sol#L56 
1. Title: Using multiple `require` instead `&&` can save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L131  Recommended Mitigation Steps: ```  require(basketUpdateTime != 0, "NibblVaultFactory: UPDATE_TIME has not passed");  require(block.timestamp >= basketUpdateTime, "NibblVaultFactory: UPDATE_TIME has not passed"); ``` ________________________________________________________________________  2. Title: Comparison operators  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L131 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L141 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L149  Recommended Mitigation Steps: Replace `<=` with `<`, and `>=` with `>` for gas optimization ________________________________________________________________________  3. Title: Reduce the size of error messages (Long revert Strings)  Impact:  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L48 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L131  Recommended Mitigation Steps: Consider shortening the revert strings to fit in 32 bytes ________________________________________________________________________  4. Title: Custom errors from Solidity 0.8.4 are cheaper than revert strings  Impact: Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information  Custom errors are defined using the error statement reference: https://blog.soliditylang.org/2021/04/21/custom-errors/  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol  Recommended Mitigation Steps: Replace require statements with custom errors. ________________________________________________________________________  5. Title: Expression for `constant` values such as a call to `keccak256()`, should use `immutable` rather than `constant`  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L51  Recommended Mitigation Steps: Change from `constant` to `immutable` reference: https://github.com/ethereum/solidity/issues/9232 ________________________________________________________________________  6. Title: `>=` is cheaper than `>`  Impact:  Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L224  Recommended Mitigation Steps: Consider using `>=` instead of `>` to avoid some opcodes ________________________________________________________________________  7. Title: Using unchecked can save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L319  Recommended Mitigation Steps: using `unchecked` can save gas due to L#311  ________________________________________________________________________  8. Title: function sell(): L#378 should be unchecked due to L#373  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L378  Recommended Mitigation Steps: Use `unchecked` ________________________________________________________________________  9. Title: Caching `length` for loop can save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547  Recommended Mitigation Steps: Change to: ```     uint256 Length = _assets.length;      for (uint256 i = 0; i < Length; i++) { ``` ________________________________________________________________________  10. Title: Default value initialization  Impact: If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547  Recommended Mitigation Steps: Remove explicit initialization for default values. ________________________________________________________________________  11. Title: Using unchecked and prefix increment is more effective for gas saving:  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547  Recommended Mitigation Steps: Change to: ```  for (uint i = 0; i < _assets.length;) {             // ...    unchecked { ++i; }          } ``` ________________________________________________________________________  12. Title: Consider make constant as private to save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/AccessControlMechanism.sol#L12-L14  Recommended Mitigation Steps: I suggest changing the visibility from `public` to `internal` or `private` ________________________________________________________________________  13. Title: Expression for `constant` values such as a call to `keccak256()`, should use `immutable` rather than `constant`  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/AccessControlMechanism.sol#L12-L14 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/EIP712Base.sol#L7  Recommended Mitigation Steps: Change from `constant` to `immutable` reference: https://github.com/ethereum/solidity/issues/9232 ________________________________________________________________________
# Low  ## Obsolete pragma  The pragma version used is:  ``` pragma solidity 0.8.10; pragma solidity ^0.8.0; ```  But recently solidity released a new version with important Bugfixes:  - The first one is related to ABI-encoding nested arrays directly from calldata. You can find more information [here](https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/).  - The second bug is triggered in certain inheritance structures and can cause a memory pointer to be interpreted as a calldata pointer or vice-versa. We also have a dedicated blog [post](https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/) about this bug.  Apart from these, there are several minor bug fixes and improvements.  The minimum required version should be [0.8.14](https://github.com/ethereum/solidity/releases/tag/v0.8.14)  ## Lack of empty address checks  The following methods have a lack checks if the received argument is an address, it's good practice in order to reduce human error to check that the address specified in the constructor or initialize is different than `address(0)`.  `address(0)`: - [NibblVaultFactory.sol#L26](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L26) - [AccessControlMechanism.sol#L19](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/AccessControlMechanism.sol#L19)  ## AccessControl / Pausable  The contract `NibblVaultFactory` is `AccessControl` and `Pausable`, so the owner could resign while the contract is paused, causing a Denial of Service. Owner resignation while paused should be avoided.  Affected source code:  - [NibblVaultFactory.sol#L17](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L17)  ## Use `encode` instead of `encodePacked` for hashig  Use of `abi.encodePacked` in `NibblVaultFactory` is safe, but unnecessary and not recommended. `abi.encodePacked` can result in hash collisions when used with two dynamic arguments (string/bytes).  There is also discussion of removing `abi.encodePacked` from future versions of Solidity ([ethereum/solidity#11593](https://github.com/ethereum/solidity/issues/11593)), so using `abi.encode` now will ensure compatibility in the future.  Affected source code:  - [NibblVaultFactory.sol#L50](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L50) - [NibblVaultFactory.sol#L70-L71](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L70-L71) - [NibblVaultFactory.sol#L81](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L81) - [NibblVaultFactory.sol#L89-L91](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L89-L91)  ## Unsafe ERC20 calls  The following code doesn't check the result of the ERC20 calls. ERC20 standard specify that the token can return false if these calls fails, so it's mandatory to check the result of these ERC20 methods.  Reference:  - [eip-20](https://eips.ethereum.org/EIPS/eip-20)  > NOTES: > The following specifications use syntax from Solidity 0.4.17 (or above) Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!  Affected source code for `transfer`:  - [Basket.sol#L87](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L87) - [Basket.sol#L94](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L94) - [NibblVault.sol#L517](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L517) - [NibblVault.sol#L526](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L526)  ## Lack of ACK during owner change  It's possible to lose the ownership under specific circumstances.  Because an human error it's possible to set a new invalid owner. When you want to change the owner's address it's better to propose a new owner, and then accept this ownership with the new wallet.  Affected source code:  - [NibblVault.sol#L485](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L485)  # Non critical  ## Outdated packages  The packages used are out of date, it is good practice to use the latest version of these packages:  ``` "@openzeppelin/contracts": "^4.5.0", "@openzeppelin/contracts-upgradeable": "^4.5.0", ```  Affected source code:  - [package.json#L28-L29](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/package.json#L28-L29)  ## Use call to transfer ether  Because to transfer ether the `.transfer` method (which is capped at 2300 gas) is used instead of `.call` which is limited to the gas provided by the user.  If a contract that has a `fallback` method more expensive than 2300 gas, it will be impossible for a contract receive funds from `Basket` contract.  Reference:  - **transfer** -> The receiving smart contract should have a fallback function defined or else the transfer call will throw an error. There is a gas limit of 2300 gas, which is enough to complete the transfer operation. It is hardcoded to prevent reentrancy attacks. - **send** -> It works in a similar way as to transfer call and has a gas limit of 2300 gas as well. It returns the status as a boolean. - **call** -> It is the recommended way of sending ETH to a smart contract. The empty argument triggers the fallback function of the receiving address.  Affected source code:  - [Basket.sol#L80](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L80)  ## Use interval for update window  If a maximum of time is not used during the update proposal, it is possible that the update will be made at the beginning or during deploy it, and after a few years, the change will be accepted, and users won't be aware of that. It is convenient to use a maximum expiration time of the proposal.  Affected source code:  - [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L107) - [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L131) - [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L149) - [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L166)  ## Possible loss of token 0  Token `0` is more or less the owner of the `Basket` contract. If this token is transfered to the wrong address, for example `address(this)`, this ownership could be losed.   It would be convenient to block the `transfer` when the token is `0` and `to` is `address(this)` (*`address(0)` it's already checked.*).   Affected source code:  - [Basket.sol#L37-L54](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L37-L54)  ## Use abstract for base contracts  Abstract contracts are contracts that have at least one function without its implementation. **An instance of an abstract cannot be created.**  Reference:  - https://docs.soliditylang.org/en/v0.6.2/contracts.html#abstract-contracts  Affected source code:  - [Twav.sol#L4](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Twav/Twav.sol#L4) - [EIP712Base.sol#L5](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/EIP712Base.sol#L5) - [AccessControlMechanism.sol#L8](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/AccessControlMechanism.sol#L8)  ## Wrong initialization  Wrong token name is used during the initialization of `NibblVault.INIT_EIP712`. `NibblVault` is used instead of `_tokenName`.  Affected source code:  - [NibblVault.sol#L186](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L186)  ## Lack of `lock` in `sell` method  if `buy` have `lock`, `sell` should have it, because the danger is the same.  Affected source code:  - [NibblVault.sol#L362](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L362) 
# Use constants  Use constant instead of storage for:  - `UPDATE_TIME` in [NibblVaultFactoryData.sol#L6](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/NibblVaultFactoryData.sol#L6)  Reduce math operations storing the value in a constant:  `2**32`: - [NibblVault.sol#L303](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L303) - [NibblVault.sol#L365](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L365)  # Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  ### Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert("Insufficient funds.");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  **If it's not possible to use error codes due to the pragma used, it is recommended to reduce the strings to less than 32 bytes.**  Affected source code:  - [NibblVaultFactory.sol#L48-L49](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L48-L49) - [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L107)  # Avoid redundant code  Two methods are exposed in the abi for the same value.  `getTwavObservations` returns the same value as `public twavObservations`: - [Twav.sol#L44](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Twav/Twav.sol#L44)  Remove `_defaultAdminRole` var and use `DEFAULT_ADMIN_ROLE`: - [AccessControlMechanism.sol#L20](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/AccessControlMechanism.sol#L20)  There are no sense to have an unsafe version of `withdrawERC721Unsafe`: - [Basket.sol#L49-L56](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L49-L56)  # `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:  ```solidity uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ```solidity uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2` I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`  **It is also recommended to not initialize the counter variable and surround the increment with an `unchecked` region.**  Affected source code:  - [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L43) - [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L70) - [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L93) - [NibblVault.sol#L506](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L506) - [NibblVault.sol#L525](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L525) - [NibblVault.sol#L547](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L547)  # There's no need to set default values for variables.  If a variable is not set/initialized, the default value is assumed (0, `false`, 0x0 ... depending on the data type). You are simply wasting gas if you directly initialize it with its default value.  Affected source code:  - [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L43) - [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L70) - [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L93)  # Use the right type  Move `unlocked` close to an `address` type and change the value to be a boolean to share the same storage slot: - [NibblVault.sol#L126](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L126) 
## missing checks for zero address  ### description Checking addresses against zero-address during initialization or during setting is a security best-practice. However, such checks are missing in address variable initializations/changes in many places.   Impact: Allowing zero-addresses will lead to contract reverts and force redeployments if there are no setters for such address variables.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L23-L26   https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L124 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L159 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L487  ## no check for existing NFT  ### description  `_proxyVault` is pushed onto the array `nibbledTokens` without checking to see if an existing vault already exists for that NFT  this could result in multiple vaults created for the same NFT  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L54  ## no support for cryptopunks  ### description  there appears to be no support for crytopunks, as they do not adhere to the ERC721 standard  ## Use of Block.timestamp  ### description   Block timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the Entropy Illusion for further details), locking funds for periods of time, and various state-changing conditional statements that are time-dependent. Miners have the ability to adjust timestamps slightly, which can prove to be dangerous if block timestamps are used incorrectly in smart contracts.  ### recommendation  Block timestamps should not be used for entropy or generating random numbersi.e., they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state.  Time-sensitive logic is sometimes required; e.g., for unlocking contracts (time-locking), completing an ICO after a few weeks, or enforcing expiry dates. It is sometimes recommended to use block.number and an average block time to estimate times; with a 10 second block time, 1 week equates to approximately, 60480 blocks. Thus, specifying a block number at which to change a contract state can be more secure, as miners are unable to easily manipulate the block number.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L101 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L125 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L143 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L160 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L147  ## Unused receive() function  ### description  If the intention is for the Ether to be used, the function should call another function, otherwise it should revert  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L183 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L114 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L585  ## transferFrom for ERC721  ### description  it is unsafe to use transferFrom for ERC721  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L54  ## use safeTransfer for ERC20  use something like OpenZeppelins safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94  ## Unspecific Compiler Version Pragma  ### description  Avoid floating pragmas for non-library contracts.  While floating pragmas make sense for libraries to allow them to be included with multiple different versions of applications, it may be a security risk for application implementations.  A known vulnerable compiler version may accidentally be selected or security tools might fall-back to an older compiler version ending up checking a different EVM compilation that is ultimately deployed on the blockchain.  It is recommended to pin to a concrete compiler version.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4  ## No Transfer Ownership Pattern  ### description  Recommend considering implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptCurator() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L488 
## don't use && require statement  ### description  The code size on deployment can be a bit smaller to save gas  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166  ## use calldata instead of memory  ### description  Use calldata instead of memory for function parameters saves gas if the function argument is only read.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L91 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L523 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545  ## for loop optimisations  ### description  Uninitialized variables are assigned with the types default value.  Explicitly initializing a variable with it's default value costs unnecessary  gas.  Suggest not initializing the for loop counter to 0.  An arrays length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Suggest storing the arrays length in a variable before the for-loop, and use it instead:  ++i costs less gas compared to i++  ++i costs less gas compared to i++ for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)  Suggest using ++i instead of i++ to increment the value of an uint variable.  Increments can be unchecked  In Solidity 0.8+, theres a default overflow check on unsigned integers. Its possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.  taking all of the above, the recommended format for gas savings is  ``` for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ```  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  ## x = x + y is cheaper than x += y  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L225
