## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | 1 | Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate | 5 | | 2 | State variables only set in the constructor should be declared `immutable` | 1 | | 3 | State variables can be packed into fewer storage slots | 2 | | 4 | State variables should be cached in stack variables rather than re-reading them from storage | 32 | | 5 | Multiple accesses of a mapping/array should use a local variable cache | 7 | | 6 | The result of external function calls should be cached rather than re-calling the function | 2 | | 7 | `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables | 14 | | 8 | `internal` functions only called once can be inlined to save gas | 6 | | 9 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` | 1 | | 10 | `<array>.length` should not be looked up in every loop of a `for`-loop | 8 | | 11 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 1 | | 12 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 1 | | 13 | Using `bool`s for storage incurs overhead | 7 | | 14 | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 7 | | 15 | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 3 | | 16 | Using `private` rather than `public` for constants, saves gas | 11 | | 17 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 7 | | 18 | `require()` or `revert()` statements that check input arguments should be at the top of the function | 3 | | 19 | Empty blocks should be removed or emit something | 3 | | 20 | Use custom errors rather than `revert()`/`require()` strings to save deployment gas | 109 | | 21 | Functions guaranteed to revert when called by normal users can be marked `payable` | 53 |  Total: 283 instances over 21 issues   ## Gas Optimizations  ### 1. Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - **30 gas**) and that calculation's associated stack operations.  *There are 5 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  50        mapping(address => uint256) public balances; 51        mapping(address => uint256) public actionLockedBalances; 52     53:       mapping(address => mapping(address => uint256)) internal _allowances; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L50-L53  ```solidity File: protocol/contracts/BkdLocker.sol  27        mapping(address => uint256) public balances; 28        mapping(address => uint256) public boostFactors; 29        mapping(address => uint256) public lastUpdated; 30        mapping(address => WithdrawStash[]) public stashedGovTokens; 31:       mapping(address => uint256) public totalStashed; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L27-L31  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  27        mapping(address => uint256) public perUserStakedIntegral; 28:       mapping(address => uint256) public perUserShare; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L27-L28  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  44        mapping(address => uint256) public initialLocked; 45        mapping(address => uint256) public totalClaimed; 46:       mapping(address => address) public holdingContract; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L44-L46  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  25        mapping(address => uint256) public perUserStakedIntegral; 26:       mapping(address => uint256) public perUserShare; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L25-L26  ### 2. State variables only set in the constructor should be declared `immutable` Avoids a Gsset (**20000 gas**) in the constructor, and replaces each Gwarmacces (**100 gas**) with a `PUSH32` (**3 gas**).  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  39:       uint256 public totalTime; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L39  ### 3. State variables can be packed into fewer storage slots If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  /// @audit Variable ordering with 8 slots instead of the current 9: /// @audit  uint256(32):totalTime, uint256(32):initialLockedSupply, uint256(32):unallocatedSupply, mapping(32):initialLocked, mapping(32):totalClaimed, mapping(32):holdingContract, address(20):admin, bool(1):initializedSupply, address(20):fundAdmin 34:       address public admin; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L34  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol   #2  /// @audit Variable ordering with 5 slots instead of the current 6: /// @audit  mapping(32):keeperRecords, mapping(32):perPeriodTotalFees, uint256(32):epoch, mapping(32):perPeriodTotalInflation, uint48(6):lastUpdated, bool(1):killed 27:       mapping(address => KeeperRecord) public keeperRecords; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L27  ### 4. State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There are 32 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  /// @audit token 330:          uint256 oldBal = IERC20(token).balanceOf(address(this));  /// @audit token 333:              ILiquidityPool pool = addressProvider.getPoolForToken(token);  /// @audit token 337:          IERC20(token).safeTransferFrom(msg.sender, address(this), amount);  /// @audit token 338:          uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;  /// @audit token 375:          uint256 oldBal = IERC20(token).balanceOf(address(this));  /// @audit token 381:          IERC20(token).safeTransfer(dst, amount);  /// @audit token 383:          uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L330  ```solidity File: protocol/contracts/BkdLocker.sol  /// @audit totalLockedBoosted 97:           curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L97  ```solidity File: protocol/contracts/tokenomics/Minter.sol  /// @audit currentInflationAmountLp 91:               currentInflationAmountLp +  /// @audit currentInflationAmountLp 208:                  currentInflationAmountLp +  /// @audit currentInflationAmountKeeper 92:               currentInflationAmountKeeper +  /// @audit currentInflationAmountKeeper 209:                  currentInflationAmountKeeper +  /// @audit currentInflationAmountAmm 93:               currentInflationAmountAmm;  /// @audit currentInflationAmountAmm 210:                  currentInflationAmountAmm;  /// @audit totalAvailableToNow 220:          require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L91  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  /// @audit minter 501:          uint256 lpInflationRate = Minter(minter).getLpInflationRate();  /// @audit minter 511:          uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();  /// @audit minter 526:          uint256 ammInflationRate = Minter(minter).getAmmInflationRate();  /// @audit totalKeeperPoolWeight 517:              totalKeeperPoolWeight;  /// @audit totalKeeperPoolWeight 575:          totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;  /// @audit totalLpPoolWeight 502:          uint256 poolInflationRate = (currentUInts256[key] * lpInflationRate) / totalLpPoolWeight;  /// @audit totalLpPoolWeight 589:          totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;  /// @audit totalAmmTokenWeight 528:              totalAmmTokenWeight;  /// @audit totalAmmTokenWeight 602:          totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L501  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  /// @audit ammStakedIntegral 159:          perUserStakedIntegral[user] = ammStakedIntegral;  /// @audit totalStaked 90:                   (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);  /// @audit totalStaked 148:              ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L159  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  /// @audit unallocatedSupply 84:           require(unallocatedSupply > 0, "No reward tokens in contract"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  /// @audit epoch 87:           keeperRecords[beneficiary].feesInPeriod[epoch] += amount;  /// @audit epoch 88:           perPeriodTotalFees[epoch] += amount;  /// @audit epoch 131:              endEpoch = epoch; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L87  ```solidity File: protocol/contracts/access/RoleManager.sol  /// @audit _roles[role].members 148:          return _roles[role].members[account]; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L148  ### 5. Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol  /// @audit stashedWithdraws[i] 142:                  totalAvailableToWithdraw += stashedWithdraws[i].amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L142  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  /// @audit amounts[i] 96:               address recipient_ = amounts[i].recipient; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L96  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  /// @audit keeperRecords[beneficiary] 84:               keeperRecords[beneficiary].firstEpochSet = true;  /// @audit keeperRecords[beneficiary] 85:               keeperRecords[beneficiary].nextEpochToClaim = epoch;  /// @audit keeperRecords[beneficiary] 87:           keeperRecords[beneficiary].feesInPeriod[epoch] += amount;  /// @audit keeperRecords[beneficiary] 139:          keeperRecords[beneficiary].nextEpochToClaim = endEpoch; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L84  ```solidity File: protocol/contracts/access/RoleManager.sol  /// @audit _roles[role] 148:          return _roles[role].members[account]; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L148  ### 6. The result of external function calls should be cached rather than re-calling the function The instances below point to the second+ call of the function within a single function  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol   #1  /// @audit _controller.addressProvider() 62:           Authorization(_controller.addressProvider().getRoleManager()) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L62  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #2  /// @audit i.uncheckedInc() 121:          for (uint256 i; i < length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L121  ### 7. `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables  *There are 14 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  343:              strategiesTotalStaked += staked;  345:              _poolTotalStaked += staked;  392:              strategiesTotalStaked -= unstaked;  394:              _poolTotalStaked -= unstaked; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L343  ```solidity File: protocol/contracts/BkdLocker.sol  152:          totalLocked -= totalAvailableToWithdraw;  230:          totalLocked += amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L152  ```solidity File: protocol/contracts/tokenomics/Minter.sol  154:          issuedNonInflationSupply += amount;  188:          totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));  218:          totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L154  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  67:           _vestedBefore += vested; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L67  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  113:          totalStaked += staked;  135:          totalStaked -= unstaked;  148:              ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L113  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  115               poolStakedIntegral += (currentRate * (block.timestamp - poolLastUpdate)).scaledDiv( 116                   poolTotalStaked 117:              ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L115-L117  ### 8. `internal` functions only called once can be inlined to save gas Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.  *There are 6 instances of this issue:* ```solidity File: protocol/contracts/AddressProvider.sol  433:      function _addKnownAddressKey(bytes32 key, AddressProviderMeta.Meta memory meta) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L433  ```solidity File: protocol/contracts/RewardHandler.sol  62:       function _approve(address token, address spender) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L62  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  146:      function _mintRewards(address beneficiary, uint256 amount) internal returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L146  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  96        function _depositInPool(address underlying_, ILiquidityPool pool_) 97            internal 98:           returns (uint256 received)  125:      function _swapperRouter() internal view returns (ISwapperRouter) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L96-L98  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  106:      function _mintRewards(address beneficiary, uint256 amount) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L106  ### 9. Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  63:           totalTime = endtime_ - starttime_; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L63  ### 10. `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 8 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  259:          for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259  ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol  22:           for (uint256 i; i < newPools_.length; ++i) {  39:           for (uint256 i; i < oldPoolAddresses_.length; ) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  ```solidity File: protocol/contracts/RewardHandler.sol  42:           for (uint256 i; i < pools.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  116:          for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L116  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  94:           for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L94  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  56:           for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L56  ```solidity File: protocol/contracts/access/RoleManager.sol  82:           for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L82  ### 11. `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  22:           for (uint256 i; i < newPools_.length; ++i) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  ### 12. `require()`/`revert()` strings longer than 32 bytes cost extra gas  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/Minter.sol   #1  150           require( 151               issuedNonInflationSupply + amount <= nonInflationDistribution, 152               "Maximum non-inflation amount exceeded." 153:          ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150-L153  ### 13. Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**), and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  58:       mapping(address => bool) public strategies; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L58  ```solidity File: protocol/contracts/tokenomics/Minter.sol  41:       bool public initialPeriodEnded; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L41  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  31:       bool public weightBasedKeeperDistributionDeactivated;  41:       mapping(address => bool) public gauges; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L31  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  31:       bool public killed; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L31  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  42:       bool public initializedSupply; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L42  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  37:       bool public override killed; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L37  ### 14. Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement This change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol  91:           require(amount > 0, Error.INVALID_AMOUNT);  92:           require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  137:          require(length > 0, "No entries"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  104:          require(amount > 0, Error.INVALID_AMOUNT);  125:          require(amount > 0, Error.INVALID_AMOUNT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  84:           require(unallocatedSupply > 0, "No reward tokens in contract"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  140:          require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L140  ### 15. Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead > When using elements that are smaller than 32 bytes, your contractâ€™s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol   #1  295:      function decimals() external view override returns (uint8) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L295  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol   #2  32:       uint48 public ammLastUpdated; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L32  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol   #3  34:       uint48 public lastUpdated; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L34  ### 16. Using `private` rather than `public` for constants, saves gas If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  *There are 11 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/Minter.sol  25:       uint256 public immutable initialAnnualInflationRateLp;  26:       uint256 public immutable annualInflationDecayLp;  30:       uint256 public immutable initialPeriodKeeperInflation;  31:       uint256 public immutable initialAnnualInflationRateKeeper;  32:       uint256 public immutable annualInflationDecayKeeper;  36:       uint256 public immutable initialPeriodAmmInflation;  37:       uint256 public immutable initialAnnualInflationRateAmm;  38:       uint256 public immutable annualInflationDecayAmm;  44:       uint256 public immutable nonInflationDistribution; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L25  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  37:       uint256 public immutable startTime;  38:       uint256 public immutable endTime; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L37  ### 17. Duplicated `require()`/`revert()` checks should be refactored to a modifier or function Saves deployment costs  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  223:          require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L223  ```solidity File: protocol/contracts/utils/Preparable.sol  98:           require(deadlines[key] != 0, Error.NOTHING_PENDING); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L98  ```solidity File: protocol/contracts/AddressProvider.sol  260:          require(!meta.frozen, Error.ADDRESS_FROZEN); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L260  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  270:              require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  365:          require(length == weights.length, "Invalid length of arguments"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L270  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  125:          require(amount > 0, Error.INVALID_AMOUNT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  76:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L76  ### 18. `require()` or `revert()` statements that check input arguments should be at the top of the function Checks that involve constants should come before checks that involve state variables  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/Controller.sol   #1  35:           require(_inflationManager != address(0), Error.INVALID_ARGUMENT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L35  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #2  60:           require(_minter != address(0), Error.INVALID_MINTER); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L60  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol   #3  54:           require(_recipient != treasury, "Treasury cannot be revoked!"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L54  ### 19. Empty blocks should be removed or emit something  The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty if-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  31:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L31  ```solidity File: protocol/contracts/RewardHandler.sol   #2  30:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L30  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #3  35:       receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35  ### 20. Use custom errors rather than `revert()`/`require()` strings to save deployment gas Custom errors are available from solidity version 0.8.4. The instances below match or exceed that version  *There are 109 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  66:           require(address(inflationManager_) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  76:           require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);  99:           require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);  112:          require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);  113:          require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);  145:          require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);  154:          require(startingAllowance >= amount, Error.INSUFFICIENT_ALLOWANCE);  157:          require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);  202:          require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);  223:          require(addressProvider.isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);  323:          require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);  339:          require(staked == amount, Error.INVALID_AMOUNT);  366           require( 367               src == msg.sender || allowance_ >= amount || address(pool) == msg.sender, 368               Error.UNAUTHORIZED_ACCESS 369:          );  370:          require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L66  ```solidity File: protocol/contracts/Controller.sol  34:           require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET);  35:           require(_inflationManager != address(0), Error.INVALID_ARGUMENT);  82:           require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L34  ```solidity File: protocol/contracts/utils/Preparable.sol  28:           require(deadlines[key] == 0, Error.DEADLINE_NOT_ZERO);  29:           require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT);  86:           require(deadlines[key] != 0, Error.NOTHING_PENDING);  98:           require(deadlines[key] != 0, Error.NOTHING_PENDING);  110:          require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED);  111:          require(deadline != 0, Error.DEADLINE_NOT_SET); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L28  ```solidity File: protocol/contracts/BkdLocker.sol  59:           require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);  91:           require(amount > 0, Error.INVALID_AMOUNT);  92:           require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  119           require( 120               totalStashed[msg.sender] + amount <= balances[msg.sender], 121               "Amount exceeds locked balance" 122:          );  137:          require(length > 0, "No entries");  208           require( 209               _rewardToken == rewardToken || _replacedRewardTokens.contains(_rewardToken), 210               Error.INVALID_ARGUMENT 211:          ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L59  ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol  56:           require(lpTokenAmount_ != 0, "No LP Tokens");  57:           require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, "withdrawal fee not 0"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L56  ```solidity File: protocol/contracts/AddressProvider.sol  64:           require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED);  71:           require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED);  98:           require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  102:          require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  176:          require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);  185:          require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);  199:          require(exists, Error.ADDRESS_DOES_NOT_EXIST);  241:          require(!meta.frozen, Error.ADDRESS_FROZEN);  242:          require(meta.freezable, Error.INVALID_ARGUMENT);  260:          require(!meta.frozen, Error.ADDRESS_FROZEN);  270:          require(!meta.frozen, Error.ADDRESS_FROZEN);  295:          require(token != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  296:          require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS);  325:          require(exists, Error.ADDRESS_NOT_FOUND);  428:          require(!_addressKeyMetas.contains(key), Error.INVALID_ARGUMENT);  434:          require(_addressKeyMetas.set(key, meta.toUInt()), Error.INVALID_ARGUMENT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L64  ```solidity File: protocol/contracts/tokenomics/Minter.sol  72:           require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);  73:           require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);  74:           require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);  100:          require(address(token) == address(0), "Token already set!");  105:          require(lastEvent == 0, "Inflation has already started.");  132:          require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);  150           require( 151               issuedNonInflationSupply + amount <= nonInflationDistribution, 152               "Maximum non-inflation amount exceeded." 153:          );  220:          require(newTotalMintedToNow <= totalAvailableToNow, "Mintable amount exceeded"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L72  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  48:           require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS);  59:           require(minter == address(0), Error.ADDRESS_ALREADY_SET);  60:           require(_minter != address(0), Error.INVALID_MINTER);  95:           require(!weightBasedKeeperDistributionDeactivated, "Weight-based dist. deactivated.");  139:          require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT);  171:          require(length == weights.length, Error.INVALID_ARGUMENT);  174:              require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT);  229:          require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST);  244:          require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  265:          require(length == weights.length, "Invalid length of arguments");  270:              require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  295:              require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);  315:          require(_ammGauges.contains(token), "amm gauge not found");  365:          require(length == weights.length, "Invalid length of arguments");  367:              require(_ammGauges.contains(tokens[i]), "amm gauge not found");  424:          require(!exists || keeperGauge != _keeperGauge, Error.INVALID_ARGUMENT);  452:          require(IAmmGauge(_ammGauge).isAmmToken(token), Error.ADDRESS_NOT_WHITELISTED);  484:          require(addressProvider.isStakerVault(msg.sender, lpToken), Error.UNAUTHORIZED_ACCESS);  486:          require(lpGauge != address(0), Error.GAUGE_DOES_NOT_EXIST);  621           require( 622               address(addressProvider.safeGetPoolForToken(lpToken)) != address(0), 623               Error.ADDRESS_NOT_FOUND 624:          ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L48  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  52:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  53:           require(revokedTime[_recipient] == 0, "Recipient already revoked");  54:           require(_recipient != treasury, "Treasury cannot be revoked!"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L52  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  50:           require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);  57            require( 58                msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender), 59                Error.UNAUTHORIZED_ACCESS 60:           );  104:          require(amount > 0, Error.INVALID_AMOUNT);  125:          require(amount > 0, Error.INVALID_AMOUNT);  126:          require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L50  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  57:           require(starttime_ >= block.timestamp, "start must be future");  58:           require(endtime_ > starttime_, "end must be greater");  69:           require(_admin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  70:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  75:           require(_fundadmin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  76:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  81:           require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  82:           require(!initializedSupply, "Supply already initialized once");  84:           require(unallocatedSupply > 0, "No reward tokens in contract");  90:           require(msg.sender == fundAdmin || msg.sender == admin, Error.UNAUTHORIZED_ACCESS);  91:           require(initializedSupply, "Supply must be initialized"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L57  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  40:           require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);  78            require( 79                IController(controller).addressProvider().isWhiteListedFeeHandler(msg.sender), 80                Error.ADDRESS_NOT_WHITELISTED 81:           );  82:           require(!killed, Error.CONTRACT_PAUSED);  126           require( 127               msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender), 128               Error.UNAUTHORIZED_ACCESS 129:          );  140:          require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L40  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  49:           require(tokens_.length != 0, "No tokens to burn");  75:           require(burningEth_ || msg.value == 0, Error.INVALID_VALUE); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L49  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  31:           require(_stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  35:           require(address(_inflationManager) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  53            require( 54                msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender), 55                Error.UNAUTHORIZED_ACCESS 56:           ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L31  ```solidity File: protocol/contracts/tokenomics/BkdToken.sol  31:           require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L31  ```solidity File: protocol/contracts/access/RoleManager.sol  28:           require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);  46:           require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE);  112:          require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE);  113:          require(hasRole(role, account), Error.INVALID_ARGUMENT); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L28  ### 21. Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 53 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  75:       function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {  82:       function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {  87:       function executeLpGauge() external override onlyGovernance returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L75  ```solidity File: protocol/contracts/Controller.sol  33:       function setInflationManager(address _inflationManager) external onlyGovernance {  39        function addStakerVault(address stakerVault) 40            external 41            override 42            onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY) 43:           returns (bool)  62:       function removePool(address pool) external override onlyGovernance returns (bool) {  81:       function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {  89:       function resetKeeperRequiredStakedBKD() external override onlyGovernance { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L33  ```solidity File: protocol/contracts/BkdLocker.sol  53        function initialize( 54            uint256 startBoost, 55            uint256 maxBoost, 56            uint256 increasePeriod, 57            uint256 withdrawDelay 58:       ) external override onlyGovernance {  70:       function migrate(address newRewardToken) external override onlyGovernance { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L53-L58  ```solidity File: protocol/contracts/AddressProvider.sol  63:       function addFeeHandler(address feeHandler) external override onlyGovernance returns (bool) {  70:       function removeFeeHandler(address feeHandler) external override onlyGovernance returns (bool) {  81:       function addAction(address action) external override onlyGovernance returns (bool) {  93        function addPool(address pool) 94            external 95            override 96:           onlyRoles2(Roles.POOL_FACTORY, Roles.GOVERNANCE)  117:      function removePool(address pool) external override onlyRole(Roles.CONTROLLER) returns (bool) {  158       function updateVault(address previousVault, address newVault) 159           external 160           override 161:          onlyRole(Roles.POOL)  212       function initializeAddress( 213           bytes32 key, 214           address initialAddress, 215           bool freezable 216:      ) public override onlyGovernance {  226       function initializeAndFreezeAddress(bytes32 key, address initialAddress) 227           external 228           override 229:          onlyGovernance  239:      function freezeAddress(bytes32 key) external override onlyGovernance {  253       function prepareAddress(bytes32 key, address newAddress) 254           external 255           override 256           onlyGovernance 257:          returns (bool)  278:      function resetAddress(bytes32 key) external override onlyGovernance returns (bool) {  288       function addStakerVault(address stakerVault) 289           external 290           override 291           onlyRole(Roles.CONTROLLER) 292:          returns (bool) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L63  ```solidity File: protocol/contracts/tokenomics/Minter.sol  99:       function setToken(address _token) external override onlyGovernance {  104:      function startInflation() external override onlyGovernance {  144       function mintNonInflationTokens(address beneficiary, uint256 amount) 145           external 146           override 147           onlyGovernance 148:          returns (bool) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L99  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  58:       function setMinter(address _minter) external override onlyGovernance returns (bool) {  70:       function advanceKeeperGaugeEpoch(address pool) external override onlyGovernance returns (bool) {  80:       function mintRewards(address beneficiary, uint256 amount) external override onlyGauge {  89        function deactivateWeightBasedKeeperDistribution() 90            external 91            override 92            onlyGovernance 93:           returns (bool)  133       function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight) 134           external 135           override 136           onlyGovernance 137:          returns (bool)  164       function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights) 165           external 166           override 167           onlyGovernance 168:          returns (bool)  181:      function whitelistGauge(address gauge) external override onlyRole(Roles.CONTROLLER) {  190       function batchExecuteKeeperPoolWeights(address[] calldata pools) 191           external 192           override 193           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 194:          returns (bool)  205       function removeStakerVaultFromInflation(address stakerVault, address lpToken) 206           external 207           override 208:          onlyRole(Roles.CONTROLLER)  221       function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight) 222           external 223           override 224           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 225:          returns (bool)  258       function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights) 259           external 260           override 261           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 262:          returns (bool)  284       function batchExecuteLpPoolWeights(address[] calldata lpTokens) 285           external 286           override 287           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 288:          returns (bool)  309       function prepareAmmTokenWeight(address token, uint256 newTokenWeight) 310           external 311           override 312           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 313:          returns (bool)  339       function addStrategyToDepositStakerVault(address depositStakerVault, address strategyPool) 340           external 341           override 342           onlyGovernance 343:          returns (bool)  357       function batchPrepareAmmTokenWeights(address[] calldata tokens, uint256[] calldata weights) 358           external 359           override 360           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 361:          returns (bool)  380       function batchExecuteAmmTokenWeights(address[] calldata tokens) 381           external 382           override 383           onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER) 384:          returns (bool)  405       function setKeeperGauge(address pool, address _keeperGauge) 406           external 407           override 408           onlyGovernance 409:          returns (bool)  435:      function removeKeeperGauge(address pool) external onlyGovernance returns (bool) {  446       function setAmmGauge(address token, address _ammGauge) 447           external 448           override 449           onlyGovernance 450:          returns (bool)  469:      function removeAmmGauge(address token) external override onlyGovernance returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  57:       function kill() external override onlyInflationManager returns (bool) {  96:       function advanceEpoch() external virtual override onlyInflationManager returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L57  ```solidity File: protocol/contracts/access/RoleManager.sol  37:       function grantRole(bytes32 role, address account) external override onlyGovernance {  41:       function addGovernor(address newGovernor) external override onlyGovernance {  45:       function renounceGovernance() external override onlyGovernance {  50:       function addGaugeZap(address zap) external override onlyGovernance {  54:       function removeGaugeZap(address zap) external override onlyGovernance {  111:      function revokeRole(bytes32 role, address account) public onlyGovernance { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L37  
