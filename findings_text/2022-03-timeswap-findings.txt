2022-03-timeswap  1 delete unused import statement.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/CollateralizedDebt.sol#L5  
2022-03-timeswap gas optimization  1 Use memory for cache instead of storage.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L62  State memory state = pools[maturity].state; 
# QA Report  **Table of Contents:**  - [QA Report](#qa-report)   - [Global remarks](#global-remarks)   - [File: TimeswapConvenience.sol](#file-timeswapconveniencesol)     - [receive()](#receive)       - [The require statement should have a revert string](#the-require-statement-should-have-a-revert-string)     - [functions timeswapMintCallback() / timeswapLendCallback() / timeswapBorrowCallback() / timeswapPayCallback()](#functions-timeswapmintcallback--timeswaplendcallback--timeswapborrowcallback--timeswappaycallback)       - [A duplicated piece of code should be refactored as a function](#a-duplicated-piece-of-code-should-be-refactored-as-a-function)  ## Global remarks  1. `TimeswapConvenience.sol:receive()` is missing a friendly revert string. 2. For maintainability and readability: duplicated code should be avoided  ## File: TimeswapConvenience.sol  ### receive()  #### The require statement should have a revert string  Here, a friendly message should exist for users to understand what went wrong:  ```jsx File: TimeswapConvenience.sol 74:     receive() external payable { 75:         require(msg.sender == address(weth)); 76:     } ```  This is the only require statement in the whole solution that misses a revert string. This is especially important IMHO as `receive()` is a callback, not a function, and therefore it might be harder to guess why the transaction reverted here.  ### functions timeswapMintCallback() / timeswapLendCallback() / timeswapBorrowCallback() / timeswapPayCallback()  #### A duplicated piece of code should be refactored as a function  Those 4 functions are using a refactorable piece of code:  ```jsx File: TimeswapConvenience.sol 549:     function timeswapMintCallback( 550:         uint256 assetIn, 551:         uint112 collateralIn, 552:         bytes calldata data 553:     ) external override { 554:         (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode( 555:             data, 556:             (IERC20, IERC20, address, address) 557:         ); 558:         IPair pair = factory.getPair(asset, collateral); 559:  560:         require(msg.sender == address(pair), 'E701'); 561:  562:         IWETH _weth = weth; 563:  564:         if (assetFrom == address(this)) { 565:             _weth.deposit{value: assetIn}(); 566:             asset.safeTransfer(pair, assetIn); 567:         } else { 568:             asset.safeTransferFrom(assetFrom, pair, assetIn); 569:         } 570:  571:         if (collateralFrom == address(this)) { 572:             _weth.deposit{value: collateralIn}(); 573:             collateral.safeTransfer(pair, collateralIn); 574:         } else { 575:             collateral.safeTransferFrom(collateralFrom, pair, collateralIn); 576:         } 577:     } 578:  579:     /// @inheritdoc ITimeswapLendCallback 580:     function timeswapLendCallback(uint256 assetIn, bytes calldata data) external override {  581:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 582:         IPair pair = factory.getPair(asset, collateral); 583:  584:         require(msg.sender == address(pair), 'E701'); 585:  586:         if (from == address(this)) { 587:             weth.deposit{value: assetIn}(); 588:             asset.safeTransfer(pair, assetIn); 589:         } else { 590:             asset.safeTransferFrom(from, pair, assetIn); 591:         } 592:     } 593:  594:     /// @inheritdoc ITimeswapBorrowCallback 595:     function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external override { 596:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 597:         IPair pair = factory.getPair(asset, collateral); 598:         require(msg.sender == address(pair), 'E701'); 599:         if (from == address(this)) { 600:             weth.deposit{value: collateralIn}(); 601:             collateral.safeTransfer(pair, collateralIn); 602:         } else { 603:             collateral.safeTransferFrom(from, pair, collateralIn); 604:         } 605:     } 606:  607:     /// @inheritdoc ITimeswapPayCallback 608:     function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override { 609:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 610:  611:         IPair pair = factory.getPair(asset, collateral); 612:         require(msg.sender == address(pair), 'E701'); 613:  614:         if (from == address(this)) { 615:             weth.deposit{value: assetIn}(); 616:             asset.safeTransfer(pair, assetIn); 617:         } else { 618:             asset.safeTransferFrom(from, pair, assetIn); 619:         } 620:     } ```  For maintainability and readability, I suggest creating a private function (here `_timeswapCallback`) and using it as such:  ```jsx File: TimeswapConvenience.sol 549:     function timeswapMintCallback(  550:         uint256 assetIn, 551:         uint112 collateralIn, 552:         bytes calldata data 553:     ) external override { 554:         (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode( 555:             data, 556:             (IERC20, IERC20, address, address) 557:         ); 558:         IPair pair = factory.getPair(asset, collateral); 559:         _timeswapCallback(asset, pair, assetFrom, assetIn, data); 560:         _timeswapCallback(asset, pair, collateralFrom, collateralIn, data); 561:     } 562:  563:     /// @inheritdoc ITimeswapLendCallback 564:     function timeswapLendCallback(uint256 assetIn, bytes calldata data) external override {  565:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 566:         IPair pair = factory.getPair(asset, collateral); 567:         _timeswapCallback(asset, pair, from, assetIn, data); 568:     } 569:  570:     /// @inheritdoc ITimeswapBorrowCallback 571:     function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external override { 572:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 573:         IPair pair = factory.getPair(asset, collateral); 574:         _timeswapCallback(asset, pair, from, collateralIn, data); 575:     } 576:  577:     /// @inheritdoc ITimeswapPayCallback 578:     function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override { 579:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 580:         IPair pair = factory.getPair(asset, collateral); 581:         _timeswapCallback(asset, pair, from, assetIn, data); 582:     } 583:  584:     function _timeswapCallback(IERC20 asset, IIPair pair, address from, uint256 assetOrCollateralIn) private { 585:         require(msg.sender == address(pair), 'E701'); 586:         if (from == address(this)) { 587:             weth.deposit{value: assetOrCollateralIn}(); 588:             asset.safeTransfer(pair, assetOrCollateralIn); 589:         } else { 590:             asset.safeTransferFrom(from, pair, assetOrCollateralIn); 591:         } 592:     } ```  Names and arguments can be changed according to the sponsor's preference, this is simply a suggestion. Here, `pair` was evaluated outside of `_timeswapCallback()` and passed as an argument to save gas (1 extra external call). The original piece of code `L562: IWETH _weth = weth;` is also unnecessary as the state variable is immutable. 
# Gas Reduction opportunities  To check the actual size of the reduction, ``hardhat-gas-reporter`` is used. ( https://www.npmjs.com/package/hardhat-gas-reporter ). At each result, it lists how many size of the gas is reduced after the change.  --- # Title: ``Borrow.sol`` can shorten the code size and gas fee by extracting common functionality into private function  Here are codes which can be shared by a function. https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L368-L369  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L409-L410  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L452-L453  The above codes use following logic which can be shared: ``` IPair pair = params.factory.getPair(params.asset, params.collateral); require(address(pair) != address(0), 'E501'); ```  Here is an example common function: ``` function _commonCheck(     IFactory factory,     IERC20 asset,     IERC20 collateral ) private view returns(IPair pair) {     pair = factory.getPair(asset, collateral);     require(address(pair) != address(0), 'E501'); } ```  The above function can be used at each place like this: ``` IPair pair = _commonCheck(params.factory, params.asset, params.collateral); ```  Here is the comparison of the gas cost at Borrow.sol - Before: 2591800 - After: 2524220 - Redution: 67580 (About 2.6% reduction)  Borrow.sol  - Before: 11.48 KB - After: 11.17 KB - Reduction: 0.31 KB  ---
# Gas Report  **Table of Contents:**  - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [File: CollateralizedDebt.sol](#file-collateralizeddebtsol)     - [modifier onlyConvenience()](#modifier-onlyconvenience)       - [Inline a modifier that's only used once](#inline-a-modifier-thats-only-used-once)   - [File: TimeswapPair.sol](#file-timeswappairsol)     - [function mint()](#function-mint)       - [Use memory variables for calculation](#use-memory-variables-for-calculation)     - [function burn()](#function-burn)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [function lend()](#function-lend)       - [Use memory variables for calculation](#use-memory-variables-for-calculation-1)     - [function borrow()](#function-borrow)       - [Use memory variables for calculation](#use-memory-variables-for-calculation-2)     - [function pay()](#function-pay)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)   - [General recommendation](#general-recommendation)     - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword  - **Storage-reading optimizations**  > The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). In the paragraphs below, please see the `@audit-issue` tags in the pieces of code's comments for more information about SLOADs that could be saved by caching the mentioned **storage** variables in **memory** variables.  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## File: CollateralizedDebt.sol  ### modifier onlyConvenience()  #### Inline a modifier that's only used once  As `onlyConvenience()` is only used once in this contract (in `function mint()`), it should get inlined to save gas:  ```jsx File: CollateralizedDebt.sol 80:     modifier onlyConvenience() { 81:         require(msg.sender == address(convenience), 'E403'); 82:         _; 83:     } 84:  85:     function mint(address to, uint256 id) external override onlyConvenience { //@audit onlyConvenience modifier only used only here: inline it. 86:         _safeMint(to, id); 87:     } ```  ## File: TimeswapPair.sol  ### function mint()  #### Use memory variables for calculation  The code can be optimized from this:  ```jsx File: TimeswapPair.sol 185:         pool.state.x += param.xIncrease; 186:         pool.state.y += param.yIncrease; 187:         pool.state.z += param.zIncrease; ... 193:         emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z); //@audit can save 3 SLOADs by using memory for calc ```  to this:  ```jsx File: TimeswapPair.sol 185:         (uint112 _poolStateX, uint112 _poolStateY, uint112 _poolStateZ) = (pool.state.x + param.xIncrease, pool.state.y + param.yIncrease, pool.state.z + param.zIncrease); 186:  187:         pool.state.x = _poolStateX; 188:         pool.state.y = _poolStateY; 189:         pool.state.z = _poolStateZ; ... 195:         emit Sync(param.maturity, _poolStateX, _poolStateY, _poolStateZ); ```  ### function burn()  #### `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  I suggest changing `> 0` with `!= 0` here:  ```jsx File: TimeswapPair.sol 225:         require(pool.state.totalLiquidity > 0, 'E206'); //@audit should be != 0 ```  Also, please enable the Optimizer.  ### function lend()  #### Use memory variables for calculation  Just like in `function mint()` ( [Use memory variables for calculation](#use-memory-variables-for-calculation) ), the code can be optimized here by caching the new values for `pool.state.x`, `pool.state.y` and `pool.state.z` :  ```jsx File: TimeswapPair.sol 310:         pool.state.x += param.xIncrease; 311:         pool.state.y -= param.yDecrease; 312:         pool.state.z -= param.zDecrease; ... 320:         emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);//@audit can save 3 SLOADs by using memory for calc ```  The same way, the final code will look like this (with the difference that `yDecrease` and `zDecreased` are used here):  ```jsx          (uint112 _poolStateX, uint112 _poolStateY, uint112 _poolStateZ) = (pool.state.x + param.xIncrease, pool.state.y - param.yDecrease, pool.state.z - param.zDecrease);            pool.state.x = _poolStateX;          pool.state.y = _poolStateY;          pool.state.z = _poolStateZ; ...          emit Sync(param.maturity, _poolStateX, _poolStateY, _poolStateZ); ```  ### function borrow()  #### Use memory variables for calculation  Just like in `function mint()` ( [Use memory variables for calculation](#use-memory-variables-for-calculation) ) and `function lend()`, the code can be optimized here by caching the new values for `pool.state.x`, `pool.state.y` and `pool.state.z` :  ```jsx File: TimeswapPair.sol 432:         pool.state.x -= param.xDecrease; 433:         pool.state.y += param.yIncrease; 434:         pool.state.z += param.zIncrease; ... 444:         emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);//@audit can save 3 SLOADs by using memory for calc  ```  The same way, the final code will look like this (with the difference that `xDecrease` is used here):  ```jsx          (uint112 _poolStateX, uint112 _poolStateY, uint112 _poolStateZ) = (pool.state.x - param.xDecrease, pool.state.y + param.yIncrease, pool.state.z + param.zIncrease);            pool.state.x = _poolStateX;          pool.state.y = _poolStateY;          pool.state.z = _poolStateZ; ...          emit Sync(param.maturity, _poolStateX, _poolStateY, _poolStateZ); ```  ### function pay()  #### An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  ```jsx File: TimeswapPair.sol 480:         for (uint256 i; i < param.ids.length;) { //@audit cache this ```  ## General recommendation  ### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  ```jsx Timeswap/Convenience/contracts/BondInterest.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/BondPrincipal.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/CollateralizedDebt.sol:45:        require(_owners[id] != address(0), 'E404'); Timeswap/Convenience/contracts/CollateralizedDebt.sol:62:        require(id < pair.totalDuesOf(maturity, address(convenience)), 'E614'); Timeswap/Convenience/contracts/CollateralizedDebt.sol:81:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/InsuranceInterest.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/InsurancePrincipal.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/Liquidity.sol:52:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:64:        require(address(_factory) != address(0), 'E601'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:65:        require(address(_weth) != address(0), 'E601'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:66:        require(address(_factory) != address(_weth), 'E612'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:75:        require(msg.sender == address(weth)); Timeswap/Convenience/contracts/TimeswapConvenience.sol:560:        require(msg.sender == address(pair), 'E701'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:584:        require(msg.sender == address(pair), 'E701'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:598:        require(msg.sender == address(pair), 'E701'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:612:        require(msg.sender == address(pair), 'E701'); Timeswap/Core/contracts/TimeswapFactory.sol:38:        require(_owner != address(0), 'E101'); Timeswap/Core/contracts/TimeswapFactory.sol:48:        require(asset != collateral, 'E103'); Timeswap/Core/contracts/TimeswapFactory.sol:49:        require(asset != IERC20(address(0)) && collateral != IERC20(address(0)), 'E101'); Timeswap/Core/contracts/TimeswapFactory.sol:50:        require(getPair[asset][collateral] == IPair(address(0)), 'E104'); Timeswap/Core/contracts/TimeswapFactory.sol:61:        require(msg.sender == owner, 'E102'); Timeswap/Core/contracts/TimeswapFactory.sol:62:        require(_pendingOwner != address(0), 'E101'); Timeswap/Core/contracts/TimeswapFactory.sol:70:        require(msg.sender == pendingOwner, 'E102'); Timeswap/Core/contracts/TimeswapPair.sol:131:        require(locked == 1, 'E211'); Timeswap/Core/contracts/TimeswapPair.sol:151:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:152:        unchecked { require(param.maturity - block.timestamp < 0x100000000, 'E208'); } Timeswap/Core/contracts/TimeswapPair.sol:153:        require(param.liquidityTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:154:        require(param.dueTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:155:        require(param.liquidityTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:156:        require(param.dueTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:157:        require(param.xIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:158:        require(param.yIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:159:        require(param.zIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:172:        require(liquidityOut != 0, 'E212'); Timeswap/Core/contracts/TimeswapPair.sol:217:        require(block.timestamp >= param.maturity, 'E203'); Timeswap/Core/contracts/TimeswapPair.sol:218:        require(param.assetTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:219:        require(param.collateralTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:220:        require(param.assetTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:221:        require(param.collateralTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:222:        require(param.liquidityIn != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:225:        require(pool.state.totalLiquidity > 0, 'E206'); Timeswap/Core/contracts/TimeswapPair.sol:273:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:274:        require(param.bondTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:275:        require(param.insuranceTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:276:        require(param.bondTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:277:        require(param.insuranceTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:278:        require(param.xIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:281:        require(pool.state.totalLiquidity != 0, 'E206'); Timeswap/Core/contracts/TimeswapPair.sol:342:        require(block.timestamp >= param.maturity, 'E203'); Timeswap/Core/contracts/TimeswapPair.sol:343:        require(param.assetTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:344:        require(param.collateralTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:345:        require(param.assetTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:346:        require(param.collateralTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:347:        require( Timeswap/Core/contracts/TimeswapPair.sol:401:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:402:        require(param.assetTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:403:        require(param.dueTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:404:        require(param.assetTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:405:        require(param.dueTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:406:        require(param.xDecrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:409:        require(pool.state.totalLiquidity != 0, 'E206'); Timeswap/Core/contracts/TimeswapPair.sol:468:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:469:        require(param.owner != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:470:        require(param.to != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:471:        require(param.to != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:472:        require(param.ids.length == param.assetsIn.length, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:473:        require(param.ids.length == param.collateralsOut.length, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:478:        require(dues.length >= param.ids.length, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:482:            require(due.startBlock != BlockNumber.get(), 'E207'); Timeswap/Core/contracts/TimeswapPair.sol:483:            if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213'); Timeswap/Core/contracts/TimeswapPair.sol:484:            require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); Timeswap/Core/contracts/TimeswapPair.sol:514:        require(msg.sender == factory.owner(), 'E216'); ```  I suggest replacing revert strings with custom errors. 
# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L166   # Vulnerability details  ## Impact  Standard ERC721 tokenURI call will fail for CollateralizedDebt pools whose underlying pair.asset() or pair.collateral() have decimals lower than 4 whenever the corresponding due quantity is lower than 1e9.  Pair's asset and collateral ERC20 can be arbitrary and some ERC20 contracts have decimals lower than 4, so such a combination is possible. In such cases current tokenURI implementation fails, which can be the issue for all integrations down the line as various systems routinely make tokenURI calls.  Placing severity to be medium per 'Assets not at direct risk, but the function of the protocol or its availability could be impacted', which is the case here as protocol availability is in question when EIP level functionality fails.  ## References  https://eips.ethereum.org/EIPS/eip-721  https://github.com/d-xo/weird-erc20#low-decimals   ## Proof of Concept  NFTTokenURIScaffold.weiToPrecisionString will fail if used for a token with decimals lower than 4 as subtraction is performed without prior checks:  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L166  NFTTokenURIScaffold.weiToPrecisionString is called by NFTTokenURIScaffold.tokenURI for pair's asset and collateral ERC20:  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L16-L39  NFTTokenURIScaffold.tokenURI is used in CollateralizedDebt.tokenURI:  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/CollateralizedDebt.sol#L46  Pair's asset and collateral tokens can be arbitrary, while tokenURI is routinely requested by a variety of external systems  ## Recommended Mitigation Steps  Consider adding the check and special care for low decimals case, for example add another naming rule similarly to how `significantDigits > 1e9` case is being handled  
# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L121-L127   # Vulnerability details  ## Impact ``borrowGivenDebtETHCollateral`` function does never properly call ``ETH.transfer`` due to underflow. If ``borrowGivenDebtETHCollateral`` function is not deprecated, it would cause unexpected behaviors for users.   ## Proof of Concept Here are codes which contain a potential issue.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L121-L127 ``` if (maxCollateral > dueOut.collateral) {     uint256 excess;     unchecked {         excess -= dueOut.collateral;     }     ETH.transfer(payable(msg.sender), excess); } ```  ``excess`` variable is ``uint256``, and ``dueOut.collateral`` variable is ``uint112`` as shown below. Hence, both variables will never be less than 0.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/interfaces/IPair.sol#L22-L26 ``` struct Due {     uint112 debt;     uint112 collateral;     uint32 startBlock; } ```  ``uint256 excess`` is initialized to 0. However, subtracting ``dueOut.collateral`` variable which is more than or equal to 0 from ``excess`` variable which is 0 will be less than 0. Hence, ``excess -= dueOut.collateral`` will be less than 0, and ``excess`` will be underflown.   ## Tools Used static code analysis   ## Recommended Mitigation Steps The code should properly initialize ``excess`` variable.  ``borrowGivenPercentETHCollateral`` function uses ``uint256 excess = maxCollateral`` at similar functionality. https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L347  Hence, just initializing ``excess`` variable with ``maxCollateral`` can be a potential workaround to prevent the underflown. ``` if (maxCollateral > dueOut.collateral) {     uint256 excess = maxCollateral;     unchecked {         excess -= dueOut.collateral;     }     ETH.transfer(payable(msg.sender), excess); } ```  
#1 using != instead < https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225 by using != instead of > or < to validate can save gas  #2 Simple way to set `assetOut` value https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L238-L239 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L436-L438 In the current implementation the value of `assetOut` was set multipleTime. use this to save gas: ``` assetOut = _assetOut + feeOut; ``` #3  Removing && operator can saving more gas usage  POC it can be seen from my report here : https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L49 instead of using operator && on single require check. using additional require check can save more execution gas. occurance : https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L49  Recommended Mitigation Steps: ``` require(asset != IERC20(address(0)), 'E101'); require(collateral != IERC20(address(0)), 'E101'); ```  #4 Simple way to set `assetIn` value https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L189-L190 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L314-L316 In the current implementation the value of `assetIn` was set multiple times. use this to save gas: ``` assetIn = param.xIncrease + feeStoredIncrease ``` #5 Unused `SafeERC20` lib https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L18 The `SafeERC20.functions()` was never called in this contract. Remove L6 and L18.  #6 Better way to use library for saving more gas  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/TimeswapConvenience.sol#L29-L35  less gas usage by not declearing library used (L28-L35). Removing line which declare that       using Mint for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Burn for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Lend for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Withdraw for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Borrow for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Pay for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using DeployNative for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));   and call library.function() directly can saving both deploying and execution gas usage.  for ex.      function deployNatives(DeployNatives calldata params) external override {         natives.deploy(this, factory, params);      }       change to   DeployNatives.deploy(natives, this, factory, params); //--> Call the library name directly and passed natives to the first argument.    #7 Unnecessary SafeTransfer Library  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/contracts/TimeswapConvenience.sol#L28  because it was the only SafeERC20.function lib were used, so it better to just use transfer and transferFrom from ERC20.function to saving more gas.  
Title: The `setOwner()` function name https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L60 The `owner` is not set in the function. I recommend to change the name to `setPendingOwner()` (and also the event L 65)   
# Use custom errors Solidity ^0.8.4 allow the use of custom errors to optimize gas usage. https://blog.soliditylang.org/2021/04/21/custom-errors/  # Consolidate operations For example: https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L189 ```         assetIn = param.xIncrease + feeStoredIncrease; ``` https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L238 ```         assetOut = _assetOut + feeOut; ``` https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L314 ```         assetIn = param.xIncrease + feeStoredIncrease + protocolFeeStoredIncrease; ``` https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L436 ```         assetOut = param.xDecrease - feeStoredIncrease - protocolFeeStoredIncrease; ``` There are also a lot of similar case in  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/libraries/TimeswapMath.sol  # Unnecessary modulo https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/libraries/SafeCast.sol#L6 `uint32(x)` is same as `uint32(x % 0x100000000)` ```         y = uint32(x % 0x100000000); ```
1. considered using bool in `modifier lock()` can save gas https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L130  Example: ``` pragma solidity =0.8.4;  contract test {  bool internal _locked = true; uint256 internal _lock = 1;  modifier noReenter() {         require(_locked, "LOCKED");         _locked = true;         _;         _locked = false;     } modifier noReentir(){         require(_lock == 1, "LOCKED");         _lock = 2;         _;         _lock = 1; }      function abc() public noReenter returns(uint){         return 12121;         // 22066     }     function def() public noReentir returns(uint){         return 1234;         // 23752     } } ```  ========================================================================  2. `> 0` is less efficient than `!= 0` for uint in require condition https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225  Change it the same as this: https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L281  ========================================================================  3. Shift right instead of dividing by 2 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SquareRoot.sol#L6  issue information: https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g008---use-shift-rightleft-instead-of-divisionmultiplication-if-possible  Tools used c4udit  ========================================================================  4. multiple `require` can save gas https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L49  Change to: ``` require(asset != IERC20(address(0)); require(collateral != IERC20(address(0)), 'E101'); ```
**[S]**: Suggested optimation, save a decent amount of gas without compromising readability;  **[M]**: Minor optimation, the amount of gas saved is minor, change when you see fit;  **[N]**: Non-preferred, the amount of gas saved is at cost of readability, only apply when gas saving is a top priority.  ## [S] Avoid unnecessary storage read can save gas  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L56-L64  ```solidity     function constantProduct(uint256 maturity)         external         view         override         returns (uint112, uint112, uint112)     {         State storage state = pools[maturity].state;         return (state.x, state.y, state.z);     } ```  Can be changed to:  ```solidity     function constantProduct(uint256 maturity)         external         view         override         returns (uint112, uint112, uint112)     {         State memory state = pools[maturity].state;         return (state.x, state.y, state.z);     } ```  ## [M] "> 0" is less efficient than "!= 0" for unsigned integers  It is cheaper to use `!= 0` than `> 0` for uint256.  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L225-L226  ```solidity         require(pool.state.totalLiquidity > 0, 'E206');  ```  ## [S] Cache storage variables in the stack can save gas  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L510  `param.ids.length` can be cached as it will be read for more than 4 times.   ## [S] Do not reduce approval on transferFrom if current allowance is type(uint256).max  The Wrapped Ether (WETH) ERC-20 contract has a gas optimization that does not update the allowance if it is the max uint.  The latest version of OpenZeppelin's ERC20 token contract also adopted this optimization.  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/contracts/base/ERC20.sol#L16-L25  ```solidity function transferFrom(         address from,         address to,         uint256 amount     ) external override returns (bool) {         _approve(from, msg.sender, allowance[from][msg.sender] - amount);         _transfer(from, to, amount);          return true;     } ``` ```  See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162 -   https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085 
# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L490   # Vulnerability details  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L490  ```solidity function pay(PayParam calldata param)     external      override      lock      returns (         uint128 assetIn,          uint128 collateralOut     )  {     require(block.timestamp < param.maturity, 'E202');     require(param.owner != address(0), 'E201');     require(param.to != address(0), 'E201');     require(param.to != address(this), 'E204');     require(param.ids.length == param.assetsIn.length, 'E205');     require(param.ids.length == param.collateralsOut.length, 'E205');      Pool storage pool = pools[param.maturity];      Due[] storage dues = pool.dues[param.owner];     require(dues.length >= param.ids.length, 'E205');      for (uint256 i; i < param.ids.length;) {         Due storage due = dues[param.ids[i]];         require(due.startBlock != BlockNumber.get(), 'E207');         if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');         require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');         due.debt -= param.assetsIn[i];         due.collateral -= param.collateralsOut[i];         assetIn += param.assetsIn[i];         collateralOut += param.collateralsOut[i];         unchecked { ++i; }     }     ... ```  At L484, if there is only one `id`, and for the first and only time of the for loop, `assetIn` and `collateralOut` will be `0`, therefore `require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');` will pass.  A attacker can call `pay()` with `param.assetsIn[0] == 0` and `param.collateralsOut[i] == due.collateral`.  ### PoC  The attacker can:   1. `borrow()` `10,000 USDC` with `1 BTC` as `collateral`; 2. `pay()` with `0 USDC` as `assetsIn` and `1 BTC` as `collateralsOut`.  As a result, the attacker effectively stole `10,000 USDC`.  ### Recommendation  Change to:  ```solidity for (uint256 i; i < param.ids.length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');     due.debt -= param.assetsIn[i];     due.collateral -= param.collateralsOut[i];     assetIn += param.assetsIn[i];     collateralOut += param.collateralsOut[i];     unchecked { ++i; } }  require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); ... ```  
# Gas Optimizations ## optimize the for loop in the pay function of the TimeswapPair contracts The for loop in the pay function can be optimized. Let's look at the for loop: ```sol for (uint256 i; i < param.ids.length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');     due.debt -= param.assetsIn[i];     due.collateral -= param.collateralsOut[i];     assetIn += param.assetsIn[i];     collateralOut += param.collateralsOut[i];     unchecked { ++i; } } ```  It is pretty optimized, but it can be more optimized: 1. The array's length can be saved instead of being accessed in every iteration. 2. `param.assetsIn[i]` and `param.collateralsOut[i]` can be saved in order to save gas. Instead of accessing it multiple times in every iteration, these values can be saved in a local variable.  The code after these changes will look like this: ```sol uint length = param.ids.length; uint112 collateralOut_i; uint112 assetsIn_i;  for (uint256 i; i < length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');      assetsIn_i = param.assetsIn[i];     collateralOut_i = param.collateralOut[i];      if (param.owner != msg.sender) require(collateralOut_i == 0, 'E213');     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');     due.debt -= assetsIn_i;     due.collateral -= collateralOut_i;     assetIn += assetsIn_i;     collateralOut += collateralOut_i;     unchecked { ++i; } } ```   ## Use local variables (memory) instead of storage variables In order to save gas, local variables can be used instead of storage variables. For example, let's look at the `mint` function of the `TimeswapPair` contract: ```sol     function mint(MintParam calldata param)         external         override         lock         returns (             uint256 assetIn,             uint256 liquidityOut,             uint256 id,             Due memory dueOut         )     {            // ...          Pool storage pool = pools[param.maturity];          uint256 feeStoredIncrease;         (liquidityOut, dueOut, feeStoredIncrease) = TimeswapMath.mint(             param.maturity,             pool.state,             param.xIncrease,             param.yIncrease,             param.zIncrease         );          require(liquidityOut != 0, 'E212');         pool.state.totalLiquidity += liquidityOut;         pool.liquidities[param.liquidityTo] += liquidityOut;          pool.state.feeStored += feeStoredIncrease;           id = pool.dues[param.dueTo].insert(dueOut);          pool.state.reserves.asset += param.xIncrease;         pool.state.reserves.collateral += dueOut.collateral;         pool.state.totalDebtCreated += dueOut.debt;          pool.state.x += param.xIncrease;         pool.state.y += param.yIncrease;         pool.state.z += param.zIncrease;          assetIn = param.xIncrease;         assetIn += feeStoredIncrease;         Callback.mint(asset, collateral, assetIn, dueOut.collateral, param.data);          // ...     } ``` Here, a lot of changes are made to the pool variable. The pool variable is a storage variable (as we can see in here `Pool storage pool = pools[param.maturity]`), and instead of modifying it we can use a local (memory) variable and assign it to the storage memory in the end. That will made all the memory operations cheaper in gas and will cocnsume less gas.  This optimization can be done to the `pool` variable in more function in the `TimeswapPair` contract - the `burn`, `lend`, `withdraw`, `borrow` and `pay` functions.  ## optimize the `returnDataToString` function in the `SafeMetadata` library ```sol function returnDataToString(bytes memory data) private pure returns (string memory) {     if (data.length >= 64) {         return abi.decode(data, (string));     } else if (data.length == 32) {         uint8 i = 0;         while (i < 32 && data[i] != 0) {             i++;         }         bytes memory bytesArray = new bytes(i);         for (i = 0; i < 32 && data[i] != 0; i++) {             bytesArray[i] = data[i];         }         return string(bytesArray);     } else {         return '???';     } } ```  This function can be optimized in several ways: 1. Use ++i instead of i++. 2. Use unchecked on the increment of i. 3. Not initializing i to it's default value - when declaring the i variable, initializing it to zero actually costs more gas than just declaring it (`uint8 i;` is cheaper than `uint8 i = 0;`). 4. Instead of checking 2 conditions in the second loop, we can run using the new array length (the old i value).     The code after the mentioned changes will look like this: ```sol function returnDataToString(bytes memory data) private pure returns (string memory) {     if (data.length >= 64) {         return abi.decode(data, (string));     } else if (data.length == 32) {         uint8 i;         while (i < 32 && data[i] != 0) {             unchecked { ++i; }         }         bytes memory bytesArray = new bytes(i);         uint length = bytesArray.length;         for (i = 0; i < length; ) {             bytesArray[i] = data[i];             unchecked { ++i; }         }         return string(bytesArray);     } else {         return '???';     } } ```  These changes will save a great amount of gas spent on unnecessary stuff.
### Storage of `uints`/`ints` smaller than 32 bytes incurs overhead > When using elements that are smaller than 32 bytes, your contractâ€™s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed ```solidity uint16 public immutable override fee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L30  ```solidity uint16 public immutable override protocolFee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L32  ```solidity uint16 public immutable override fee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L21  ```solidity uint16 public immutable override protocolFee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L23   ### `abi.encode()` is less efficient than `abi.encodePacked()` ```solidity bytes32 salt = keccak256(abi.encode(asset, collateral, maturity.toString()));           ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Deploy.sol#L35  ```solidity bytes(abi.encode(params.asset, params.collateral, params.from, params.maturity))             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Pay.sol#L127  ```solidity bytes(abi.encode(params.asset, params.collateral, params.from))              ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L510  ```solidity bytes(abi.encode(params.asset, params.collateral, params.from))              ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Lend.sol#L383  ```solidity bytes(abi.encode(params.asset, params.collateral, params.assetFrom, params.collateralFrom))             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Mint.sol#L690  ```solidity pair = new TimeswapPair{saltkeccak256(abi.encode(asset, collateral))}(asset, collateral, fee, protocolFee);         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L52   ### `require()` strings longer than 32 bytes cost extra gas Consider not using the version of this function that takes in a `string` ```solidity "balanceOf Call to IERC20 token not successful" ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/libraries/SafeBalance.sol#L16  ### Using `> 0` costs more gas than `!= 0` when used on uints in a `require()` statement ```solidity require(pool.state.totalLiquidity > 0, 'E206');             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225   ### Splitting `require()` statements that use `&&` saves gas See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) for an example ```solidity require(asset != IERC20(address(0)) && collateral != IERC20(address(0)), 'E101');         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol   ### `<array>.length` should not be looked up in every loop of a for-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length ```solidity for (uint256 i; i < data.length; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L228  ```solidity for (uint256 i; i < param.ids.length;) {          ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L480  ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in for- and while-loops ```solidity for (i = 0; i < 32 && data[i] != 0; i++) {    ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L38  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L146  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L174  ```solidity for (uint256 i; i < data.length; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L228  ```solidity for (uint256 i; i <= end - begin; i++) {       ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L241   ### `++i` costs less gas than `++i`, especially when it's used in for-loops (`--i`/`i--` too) ```solidity for (i = 0; i < 32 && data[i] != 0; i++) {    ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L38  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L146  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L174  ```solidity for (uint256 i; i < data.length; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L228  ```solidity for (uint256 i; i <= end - begin; i++) {       ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L241   ### It costs more gas to initialize variables to zero than to let the default of zero be applied ```solidity uint8 i = 0;             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L33 
# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/package.json#L40   # Vulnerability details  ## Impact I discovered an npm package and the scope of the package is unclaimed on the NPM website. This will give any User to claim that package and be able to Upload a Malicious Code under that unclaimed package. This results in achieving the Remote code execution on developers/users' machine who depends on the timeswap repository to build it on local env.  ##Vulnerable Package Name: @timeswap-labs/timeswap-v1-core  ## Proof of Concept 1. Create an Organization called "timeswap-labs". 2. Create a package called "@timeswap-labs/timeswap-v1-core" under "timeswap-labs" Organization. 3. Attacker can able to upload malicious code on unclaimed npm package with a higher version like 99.99.99 4. Now If any user/timeswap developer installs it by npm install package.json. The malicious pkg will be executed.  Till now "The Package is not claimed on NPM Registry, but it's vulnerable to dependency confusion".  You can read more dependency confusion here: https://dhiyaneshgeek.github.io/web/security/2021/09/04/dependency-confusion/  ## Tools Used Nothing Just OSINT  ## Recommended Mitigation Steps Claim the Scope name called "timeswap-labs" By Following the above POC Step 1.  
1. Using mixed versions of openzeppelin: - Core:          "@openzeppelin/contracts": "^4.2.0" - Convenienve:   "@openzeppelin/contracts": "^4.1.0"  2. It seems that use an outdated version of openzeppelin - Core:          "@openzeppelin/contracts": "^4.2.0" - Convenienve:   "@openzeppelin/contracts": "^4.1.0" - **Latest:**        "@openzeppelin/contracts": "4.5.0"  3. Use a buggy solidity version with immutables. The contract use immutable, and this solidity version defined in the pragma has some issues with them, as you can see [here](https://github.com/ethereum/solidity/blob/develop/Changelog.md#089-2021-09-29).  4. Issue [69](https://github.com/code-423n4/2022-01-timeswap-findings/issues/69) remains active - [SafeMetadata.sol#L8-L27](https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L8-L27)
# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L513-L522   # Vulnerability details  ## Impact collectProtocolFee function has a missing zero address check on `asset.safeTransfer(to, protocolFeeOut);`  A user may mistakenly make the transfer to a zero address which may lead to loss of Protocol Fee.  ## Proof of Concept https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L519  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require check for the address passed in collectProtocolFee()  
  Title: Unused state variables Severity: GAS  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           Liquidity.sol, decimals  Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               TimeswapConvenience.repay (params)         TimeswapConvenience.repayETHAsset (params)         TimeswapConvenience.repayETHCollateral (params)    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           TimeswapPair.sol, ids.param, 480    Title: Unused declared local variables Severity: GAS  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           TimeswapConvenience.sol, timeswapMintCallback, _weth     
2022-03-timeswap  1 delete unused import statement.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/CollateralizedDebt.sol#L5  
2022-03-timeswap gas optimization  1 Use memory for cache instead of storage.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L62  State memory state = pools[maturity].state; 
# QA Report  **Table of Contents:**  - [QA Report](#qa-report)   - [Global remarks](#global-remarks)   - [File: TimeswapConvenience.sol](#file-timeswapconveniencesol)     - [receive()](#receive)       - [The require statement should have a revert string](#the-require-statement-should-have-a-revert-string)     - [functions timeswapMintCallback() / timeswapLendCallback() / timeswapBorrowCallback() / timeswapPayCallback()](#functions-timeswapmintcallback--timeswaplendcallback--timeswapborrowcallback--timeswappaycallback)       - [A duplicated piece of code should be refactored as a function](#a-duplicated-piece-of-code-should-be-refactored-as-a-function)  ## Global remarks  1. `TimeswapConvenience.sol:receive()` is missing a friendly revert string. 2. For maintainability and readability: duplicated code should be avoided  ## File: TimeswapConvenience.sol  ### receive()  #### The require statement should have a revert string  Here, a friendly message should exist for users to understand what went wrong:  ```jsx File: TimeswapConvenience.sol 74:     receive() external payable { 75:         require(msg.sender == address(weth)); 76:     } ```  This is the only require statement in the whole solution that misses a revert string. This is especially important IMHO as `receive()` is a callback, not a function, and therefore it might be harder to guess why the transaction reverted here.  ### functions timeswapMintCallback() / timeswapLendCallback() / timeswapBorrowCallback() / timeswapPayCallback()  #### A duplicated piece of code should be refactored as a function  Those 4 functions are using a refactorable piece of code:  ```jsx File: TimeswapConvenience.sol 549:     function timeswapMintCallback( 550:         uint256 assetIn, 551:         uint112 collateralIn, 552:         bytes calldata data 553:     ) external override { 554:         (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode( 555:             data, 556:             (IERC20, IERC20, address, address) 557:         ); 558:         IPair pair = factory.getPair(asset, collateral); 559:  560:         require(msg.sender == address(pair), 'E701'); 561:  562:         IWETH _weth = weth; 563:  564:         if (assetFrom == address(this)) { 565:             _weth.deposit{value: assetIn}(); 566:             asset.safeTransfer(pair, assetIn); 567:         } else { 568:             asset.safeTransferFrom(assetFrom, pair, assetIn); 569:         } 570:  571:         if (collateralFrom == address(this)) { 572:             _weth.deposit{value: collateralIn}(); 573:             collateral.safeTransfer(pair, collateralIn); 574:         } else { 575:             collateral.safeTransferFrom(collateralFrom, pair, collateralIn); 576:         } 577:     } 578:  579:     /// @inheritdoc ITimeswapLendCallback 580:     function timeswapLendCallback(uint256 assetIn, bytes calldata data) external override {  581:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 582:         IPair pair = factory.getPair(asset, collateral); 583:  584:         require(msg.sender == address(pair), 'E701'); 585:  586:         if (from == address(this)) { 587:             weth.deposit{value: assetIn}(); 588:             asset.safeTransfer(pair, assetIn); 589:         } else { 590:             asset.safeTransferFrom(from, pair, assetIn); 591:         } 592:     } 593:  594:     /// @inheritdoc ITimeswapBorrowCallback 595:     function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external override { 596:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 597:         IPair pair = factory.getPair(asset, collateral); 598:         require(msg.sender == address(pair), 'E701'); 599:         if (from == address(this)) { 600:             weth.deposit{value: collateralIn}(); 601:             collateral.safeTransfer(pair, collateralIn); 602:         } else { 603:             collateral.safeTransferFrom(from, pair, collateralIn); 604:         } 605:     } 606:  607:     /// @inheritdoc ITimeswapPayCallback 608:     function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override { 609:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 610:  611:         IPair pair = factory.getPair(asset, collateral); 612:         require(msg.sender == address(pair), 'E701'); 613:  614:         if (from == address(this)) { 615:             weth.deposit{value: assetIn}(); 616:             asset.safeTransfer(pair, assetIn); 617:         } else { 618:             asset.safeTransferFrom(from, pair, assetIn); 619:         } 620:     } ```  For maintainability and readability, I suggest creating a private function (here `_timeswapCallback`) and using it as such:  ```jsx File: TimeswapConvenience.sol 549:     function timeswapMintCallback(  550:         uint256 assetIn, 551:         uint112 collateralIn, 552:         bytes calldata data 553:     ) external override { 554:         (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode( 555:             data, 556:             (IERC20, IERC20, address, address) 557:         ); 558:         IPair pair = factory.getPair(asset, collateral); 559:         _timeswapCallback(asset, pair, assetFrom, assetIn, data); 560:         _timeswapCallback(asset, pair, collateralFrom, collateralIn, data); 561:     } 562:  563:     /// @inheritdoc ITimeswapLendCallback 564:     function timeswapLendCallback(uint256 assetIn, bytes calldata data) external override {  565:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 566:         IPair pair = factory.getPair(asset, collateral); 567:         _timeswapCallback(asset, pair, from, assetIn, data); 568:     } 569:  570:     /// @inheritdoc ITimeswapBorrowCallback 571:     function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external override { 572:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 573:         IPair pair = factory.getPair(asset, collateral); 574:         _timeswapCallback(asset, pair, from, collateralIn, data); 575:     } 576:  577:     /// @inheritdoc ITimeswapPayCallback 578:     function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override { 579:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 580:         IPair pair = factory.getPair(asset, collateral); 581:         _timeswapCallback(asset, pair, from, assetIn, data); 582:     } 583:  584:     function _timeswapCallback(IERC20 asset, IIPair pair, address from, uint256 assetOrCollateralIn) private { 585:         require(msg.sender == address(pair), 'E701'); 586:         if (from == address(this)) { 587:             weth.deposit{value: assetOrCollateralIn}(); 588:             asset.safeTransfer(pair, assetOrCollateralIn); 589:         } else { 590:             asset.safeTransferFrom(from, pair, assetOrCollateralIn); 591:         } 592:     } ```  Names and arguments can be changed according to the sponsor's preference, this is simply a suggestion. Here, `pair` was evaluated outside of `_timeswapCallback()` and passed as an argument to save gas (1 extra external call). The original piece of code `L562: IWETH _weth = weth;` is also unnecessary as the state variable is immutable. 
# Gas Reduction opportunities  To check the actual size of the reduction, ``hardhat-gas-reporter`` is used. ( https://www.npmjs.com/package/hardhat-gas-reporter ). At each result, it lists how many size of the gas is reduced after the change.  --- # Title: ``Borrow.sol`` can shorten the code size and gas fee by extracting common functionality into private function  Here are codes which can be shared by a function. https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L368-L369  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L409-L410  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L452-L453  The above codes use following logic which can be shared: ``` IPair pair = params.factory.getPair(params.asset, params.collateral); require(address(pair) != address(0), 'E501'); ```  Here is an example common function: ``` function _commonCheck(     IFactory factory,     IERC20 asset,     IERC20 collateral ) private view returns(IPair pair) {     pair = factory.getPair(asset, collateral);     require(address(pair) != address(0), 'E501'); } ```  The above function can be used at each place like this: ``` IPair pair = _commonCheck(params.factory, params.asset, params.collateral); ```  Here is the comparison of the gas cost at Borrow.sol - Before: 2591800 - After: 2524220 - Redution: 67580 (About 2.6% reduction)  Borrow.sol  - Before: 11.48 KB - After: 11.17 KB - Reduction: 0.31 KB  ---
# Gas Report  **Table of Contents:**  - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [File: CollateralizedDebt.sol](#file-collateralizeddebtsol)     - [modifier onlyConvenience()](#modifier-onlyconvenience)       - [Inline a modifier that's only used once](#inline-a-modifier-thats-only-used-once)   - [File: TimeswapPair.sol](#file-timeswappairsol)     - [function mint()](#function-mint)       - [Use memory variables for calculation](#use-memory-variables-for-calculation)     - [function burn()](#function-burn)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [function lend()](#function-lend)       - [Use memory variables for calculation](#use-memory-variables-for-calculation-1)     - [function borrow()](#function-borrow)       - [Use memory variables for calculation](#use-memory-variables-for-calculation-2)     - [function pay()](#function-pay)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)   - [General recommendation](#general-recommendation)     - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword  - **Storage-reading optimizations**  > The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). In the paragraphs below, please see the `@audit-issue` tags in the pieces of code's comments for more information about SLOADs that could be saved by caching the mentioned **storage** variables in **memory** variables.  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## File: CollateralizedDebt.sol  ### modifier onlyConvenience()  #### Inline a modifier that's only used once  As `onlyConvenience()` is only used once in this contract (in `function mint()`), it should get inlined to save gas:  ```jsx File: CollateralizedDebt.sol 80:     modifier onlyConvenience() { 81:         require(msg.sender == address(convenience), 'E403'); 82:         _; 83:     } 84:  85:     function mint(address to, uint256 id) external override onlyConvenience { //@audit onlyConvenience modifier only used only here: inline it. 86:         _safeMint(to, id); 87:     } ```  ## File: TimeswapPair.sol  ### function mint()  #### Use memory variables for calculation  The code can be optimized from this:  ```jsx File: TimeswapPair.sol 185:         pool.state.x += param.xIncrease; 186:         pool.state.y += param.yIncrease; 187:         pool.state.z += param.zIncrease; ... 193:         emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z); //@audit can save 3 SLOADs by using memory for calc ```  to this:  ```jsx File: TimeswapPair.sol 185:         (uint112 _poolStateX, uint112 _poolStateY, uint112 _poolStateZ) = (pool.state.x + param.xIncrease, pool.state.y + param.yIncrease, pool.state.z + param.zIncrease); 186:  187:         pool.state.x = _poolStateX; 188:         pool.state.y = _poolStateY; 189:         pool.state.z = _poolStateZ; ... 195:         emit Sync(param.maturity, _poolStateX, _poolStateY, _poolStateZ); ```  ### function burn()  #### `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  I suggest changing `> 0` with `!= 0` here:  ```jsx File: TimeswapPair.sol 225:         require(pool.state.totalLiquidity > 0, 'E206'); //@audit should be != 0 ```  Also, please enable the Optimizer.  ### function lend()  #### Use memory variables for calculation  Just like in `function mint()` ( [Use memory variables for calculation](#use-memory-variables-for-calculation) ), the code can be optimized here by caching the new values for `pool.state.x`, `pool.state.y` and `pool.state.z` :  ```jsx File: TimeswapPair.sol 310:         pool.state.x += param.xIncrease; 311:         pool.state.y -= param.yDecrease; 312:         pool.state.z -= param.zDecrease; ... 320:         emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);//@audit can save 3 SLOADs by using memory for calc ```  The same way, the final code will look like this (with the difference that `yDecrease` and `zDecreased` are used here):  ```jsx          (uint112 _poolStateX, uint112 _poolStateY, uint112 _poolStateZ) = (pool.state.x + param.xIncrease, pool.state.y - param.yDecrease, pool.state.z - param.zDecrease);            pool.state.x = _poolStateX;          pool.state.y = _poolStateY;          pool.state.z = _poolStateZ; ...          emit Sync(param.maturity, _poolStateX, _poolStateY, _poolStateZ); ```  ### function borrow()  #### Use memory variables for calculation  Just like in `function mint()` ( [Use memory variables for calculation](#use-memory-variables-for-calculation) ) and `function lend()`, the code can be optimized here by caching the new values for `pool.state.x`, `pool.state.y` and `pool.state.z` :  ```jsx File: TimeswapPair.sol 432:         pool.state.x -= param.xDecrease; 433:         pool.state.y += param.yIncrease; 434:         pool.state.z += param.zIncrease; ... 444:         emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);//@audit can save 3 SLOADs by using memory for calc  ```  The same way, the final code will look like this (with the difference that `xDecrease` is used here):  ```jsx          (uint112 _poolStateX, uint112 _poolStateY, uint112 _poolStateZ) = (pool.state.x - param.xDecrease, pool.state.y + param.yIncrease, pool.state.z + param.zIncrease);            pool.state.x = _poolStateX;          pool.state.y = _poolStateY;          pool.state.z = _poolStateZ; ...          emit Sync(param.maturity, _poolStateX, _poolStateY, _poolStateZ); ```  ### function pay()  #### An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  ```jsx File: TimeswapPair.sol 480:         for (uint256 i; i < param.ids.length;) { //@audit cache this ```  ## General recommendation  ### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert("Insufficient funds.");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  ```jsx Timeswap/Convenience/contracts/BondInterest.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/BondPrincipal.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/CollateralizedDebt.sol:45:        require(_owners[id] != address(0), 'E404'); Timeswap/Convenience/contracts/CollateralizedDebt.sol:62:        require(id < pair.totalDuesOf(maturity, address(convenience)), 'E614'); Timeswap/Convenience/contracts/CollateralizedDebt.sol:81:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/InsuranceInterest.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/InsurancePrincipal.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/Liquidity.sol:52:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:64:        require(address(_factory) != address(0), 'E601'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:65:        require(address(_weth) != address(0), 'E601'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:66:        require(address(_factory) != address(_weth), 'E612'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:75:        require(msg.sender == address(weth)); Timeswap/Convenience/contracts/TimeswapConvenience.sol:560:        require(msg.sender == address(pair), 'E701'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:584:        require(msg.sender == address(pair), 'E701'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:598:        require(msg.sender == address(pair), 'E701'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:612:        require(msg.sender == address(pair), 'E701'); Timeswap/Core/contracts/TimeswapFactory.sol:38:        require(_owner != address(0), 'E101'); Timeswap/Core/contracts/TimeswapFactory.sol:48:        require(asset != collateral, 'E103'); Timeswap/Core/contracts/TimeswapFactory.sol:49:        require(asset != IERC20(address(0)) && collateral != IERC20(address(0)), 'E101'); Timeswap/Core/contracts/TimeswapFactory.sol:50:        require(getPair[asset][collateral] == IPair(address(0)), 'E104'); Timeswap/Core/contracts/TimeswapFactory.sol:61:        require(msg.sender == owner, 'E102'); Timeswap/Core/contracts/TimeswapFactory.sol:62:        require(_pendingOwner != address(0), 'E101'); Timeswap/Core/contracts/TimeswapFactory.sol:70:        require(msg.sender == pendingOwner, 'E102'); Timeswap/Core/contracts/TimeswapPair.sol:131:        require(locked == 1, 'E211'); Timeswap/Core/contracts/TimeswapPair.sol:151:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:152:        unchecked { require(param.maturity - block.timestamp < 0x100000000, 'E208'); } Timeswap/Core/contracts/TimeswapPair.sol:153:        require(param.liquidityTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:154:        require(param.dueTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:155:        require(param.liquidityTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:156:        require(param.dueTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:157:        require(param.xIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:158:        require(param.yIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:159:        require(param.zIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:172:        require(liquidityOut != 0, 'E212'); Timeswap/Core/contracts/TimeswapPair.sol:217:        require(block.timestamp >= param.maturity, 'E203'); Timeswap/Core/contracts/TimeswapPair.sol:218:        require(param.assetTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:219:        require(param.collateralTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:220:        require(param.assetTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:221:        require(param.collateralTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:222:        require(param.liquidityIn != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:225:        require(pool.state.totalLiquidity > 0, 'E206'); Timeswap/Core/contracts/TimeswapPair.sol:273:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:274:        require(param.bondTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:275:        require(param.insuranceTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:276:        require(param.bondTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:277:        require(param.insuranceTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:278:        require(param.xIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:281:        require(pool.state.totalLiquidity != 0, 'E206'); Timeswap/Core/contracts/TimeswapPair.sol:342:        require(block.timestamp >= param.maturity, 'E203'); Timeswap/Core/contracts/TimeswapPair.sol:343:        require(param.assetTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:344:        require(param.collateralTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:345:        require(param.assetTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:346:        require(param.collateralTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:347:        require( Timeswap/Core/contracts/TimeswapPair.sol:401:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:402:        require(param.assetTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:403:        require(param.dueTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:404:        require(param.assetTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:405:        require(param.dueTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:406:        require(param.xDecrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:409:        require(pool.state.totalLiquidity != 0, 'E206'); Timeswap/Core/contracts/TimeswapPair.sol:468:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:469:        require(param.owner != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:470:        require(param.to != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:471:        require(param.to != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:472:        require(param.ids.length == param.assetsIn.length, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:473:        require(param.ids.length == param.collateralsOut.length, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:478:        require(dues.length >= param.ids.length, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:482:            require(due.startBlock != BlockNumber.get(), 'E207'); Timeswap/Core/contracts/TimeswapPair.sol:483:            if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213'); Timeswap/Core/contracts/TimeswapPair.sol:484:            require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); Timeswap/Core/contracts/TimeswapPair.sol:514:        require(msg.sender == factory.owner(), 'E216'); ```  I suggest replacing revert strings with custom errors. 
# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L166   # Vulnerability details  ## Impact  Standard ERC721 tokenURI call will fail for CollateralizedDebt pools whose underlying pair.asset() or pair.collateral() have decimals lower than 4 whenever the corresponding due quantity is lower than 1e9.  Pair's asset and collateral ERC20 can be arbitrary and some ERC20 contracts have decimals lower than 4, so such a combination is possible. In such cases current tokenURI implementation fails, which can be the issue for all integrations down the line as various systems routinely make tokenURI calls.  Placing severity to be medium per 'Assets not at direct risk, but the function of the protocol or its availability could be impacted', which is the case here as protocol availability is in question when EIP level functionality fails.  ## References  https://eips.ethereum.org/EIPS/eip-721  https://github.com/d-xo/weird-erc20#low-decimals   ## Proof of Concept  NFTTokenURIScaffold.weiToPrecisionString will fail if used for a token with decimals lower than 4 as subtraction is performed without prior checks:  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L166  NFTTokenURIScaffold.weiToPrecisionString is called by NFTTokenURIScaffold.tokenURI for pair's asset and collateral ERC20:  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L16-L39  NFTTokenURIScaffold.tokenURI is used in CollateralizedDebt.tokenURI:  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/CollateralizedDebt.sol#L46  Pair's asset and collateral tokens can be arbitrary, while tokenURI is routinely requested by a variety of external systems  ## Recommended Mitigation Steps  Consider adding the check and special care for low decimals case, for example add another naming rule similarly to how `significantDigits > 1e9` case is being handled  
# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L121-L127   # Vulnerability details  ## Impact ``borrowGivenDebtETHCollateral`` function does never properly call ``ETH.transfer`` due to underflow. If ``borrowGivenDebtETHCollateral`` function is not deprecated, it would cause unexpected behaviors for users.   ## Proof of Concept Here are codes which contain a potential issue.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L121-L127 ``` if (maxCollateral > dueOut.collateral) {     uint256 excess;     unchecked {         excess -= dueOut.collateral;     }     ETH.transfer(payable(msg.sender), excess); } ```  ``excess`` variable is ``uint256``, and ``dueOut.collateral`` variable is ``uint112`` as shown below. Hence, both variables will never be less than 0.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/interfaces/IPair.sol#L22-L26 ``` struct Due {     uint112 debt;     uint112 collateral;     uint32 startBlock; } ```  ``uint256 excess`` is initialized to 0. However, subtracting ``dueOut.collateral`` variable which is more than or equal to 0 from ``excess`` variable which is 0 will be less than 0. Hence, ``excess -= dueOut.collateral`` will be less than 0, and ``excess`` will be underflown.   ## Tools Used static code analysis   ## Recommended Mitigation Steps The code should properly initialize ``excess`` variable.  ``borrowGivenPercentETHCollateral`` function uses ``uint256 excess = maxCollateral`` at similar functionality. https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L347  Hence, just initializing ``excess`` variable with ``maxCollateral`` can be a potential workaround to prevent the underflown. ``` if (maxCollateral > dueOut.collateral) {     uint256 excess = maxCollateral;     unchecked {         excess -= dueOut.collateral;     }     ETH.transfer(payable(msg.sender), excess); } ```  
#1 using != instead < https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225 by using != instead of > or < to validate can save gas  #2 Simple way to set `assetOut` value https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L238-L239 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L436-L438 In the current implementation the value of `assetOut` was set multipleTime. use this to save gas: ``` assetOut = _assetOut + feeOut; ``` #3  Removing && operator can saving more gas usage  POC it can be seen from my report here : https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L49 instead of using operator && on single require check. using additional require check can save more execution gas. occurance : https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L49  Recommended Mitigation Steps: ``` require(asset != IERC20(address(0)), 'E101'); require(collateral != IERC20(address(0)), 'E101'); ```  #4 Simple way to set `assetIn` value https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L189-L190 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L314-L316 In the current implementation the value of `assetIn` was set multiple times. use this to save gas: ``` assetIn = param.xIncrease + feeStoredIncrease ``` #5 Unused `SafeERC20` lib https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L18 The `SafeERC20.functions()` was never called in this contract. Remove L6 and L18.  #6 Better way to use library for saving more gas  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/TimeswapConvenience.sol#L29-L35  less gas usage by not declearing library used (L28-L35). Removing line which declare that       using Mint for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Burn for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Lend for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Withdraw for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Borrow for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Pay for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using DeployNative for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));   and call library.function() directly can saving both deploying and execution gas usage.  for ex.      function deployNatives(DeployNatives calldata params) external override {         natives.deploy(this, factory, params);      }       change to   DeployNatives.deploy(natives, this, factory, params); //--> Call the library name directly and passed natives to the first argument.    #7 Unnecessary SafeTransfer Library  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/contracts/TimeswapConvenience.sol#L28  because it was the only SafeERC20.function lib were used, so it better to just use transfer and transferFrom from ERC20.function to saving more gas.  
Title: The `setOwner()` function name https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L60 The `owner` is not set in the function. I recommend to change the name to `setPendingOwner()` (and also the event L 65)   
# Use custom errors Solidity ^0.8.4 allow the use of custom errors to optimize gas usage. https://blog.soliditylang.org/2021/04/21/custom-errors/  # Consolidate operations For example: https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L189 ```         assetIn = param.xIncrease + feeStoredIncrease; ``` https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L238 ```         assetOut = _assetOut + feeOut; ``` https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L314 ```         assetIn = param.xIncrease + feeStoredIncrease + protocolFeeStoredIncrease; ``` https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L436 ```         assetOut = param.xDecrease - feeStoredIncrease - protocolFeeStoredIncrease; ``` There are also a lot of similar case in  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/libraries/TimeswapMath.sol  # Unnecessary modulo https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/libraries/SafeCast.sol#L6 `uint32(x)` is same as `uint32(x % 0x100000000)` ```         y = uint32(x % 0x100000000); ```
1. considered using bool in `modifier lock()` can save gas https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L130  Example: ``` pragma solidity =0.8.4;  contract test {  bool internal _locked = true; uint256 internal _lock = 1;  modifier noReenter() {         require(_locked, "LOCKED");         _locked = true;         _;         _locked = false;     } modifier noReentir(){         require(_lock == 1, "LOCKED");         _lock = 2;         _;         _lock = 1; }      function abc() public noReenter returns(uint){         return 12121;         // 22066     }     function def() public noReentir returns(uint){         return 1234;         // 23752     } } ```  ========================================================================  2. `> 0` is less efficient than `!= 0` for uint in require condition https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225  Change it the same as this: https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L281  ========================================================================  3. Shift right instead of dividing by 2 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SquareRoot.sol#L6  issue information: https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g008---use-shift-rightleft-instead-of-divisionmultiplication-if-possible  Tools used c4udit  ========================================================================  4. multiple `require` can save gas https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L49  Change to: ``` require(asset != IERC20(address(0)); require(collateral != IERC20(address(0)), 'E101'); ```
**[S]**: Suggested optimation, save a decent amount of gas without compromising readability;  **[M]**: Minor optimation, the amount of gas saved is minor, change when you see fit;  **[N]**: Non-preferred, the amount of gas saved is at cost of readability, only apply when gas saving is a top priority.  ## [S] Avoid unnecessary storage read can save gas  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L56-L64  ```solidity     function constantProduct(uint256 maturity)         external         view         override         returns (uint112, uint112, uint112)     {         State storage state = pools[maturity].state;         return (state.x, state.y, state.z);     } ```  Can be changed to:  ```solidity     function constantProduct(uint256 maturity)         external         view         override         returns (uint112, uint112, uint112)     {         State memory state = pools[maturity].state;         return (state.x, state.y, state.z);     } ```  ## [M] "> 0" is less efficient than "!= 0" for unsigned integers  It is cheaper to use `!= 0` than `> 0` for uint256.  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L225-L226  ```solidity         require(pool.state.totalLiquidity > 0, 'E206');  ```  ## [S] Cache storage variables in the stack can save gas  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L510  `param.ids.length` can be cached as it will be read for more than 4 times.   ## [S] Do not reduce approval on transferFrom if current allowance is type(uint256).max  The Wrapped Ether (WETH) ERC-20 contract has a gas optimization that does not update the allowance if it is the max uint.  The latest version of OpenZeppelin's ERC20 token contract also adopted this optimization.  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/contracts/base/ERC20.sol#L16-L25  ```solidity function transferFrom(         address from,         address to,         uint256 amount     ) external override returns (bool) {         _approve(from, msg.sender, allowance[from][msg.sender] - amount);         _transfer(from, to, amount);          return true;     } ``` ```  See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162 -   https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085 
# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L490   # Vulnerability details  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L490  ```solidity function pay(PayParam calldata param)     external      override      lock      returns (         uint128 assetIn,          uint128 collateralOut     )  {     require(block.timestamp < param.maturity, 'E202');     require(param.owner != address(0), 'E201');     require(param.to != address(0), 'E201');     require(param.to != address(this), 'E204');     require(param.ids.length == param.assetsIn.length, 'E205');     require(param.ids.length == param.collateralsOut.length, 'E205');      Pool storage pool = pools[param.maturity];      Due[] storage dues = pool.dues[param.owner];     require(dues.length >= param.ids.length, 'E205');      for (uint256 i; i < param.ids.length;) {         Due storage due = dues[param.ids[i]];         require(due.startBlock != BlockNumber.get(), 'E207');         if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');         require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');         due.debt -= param.assetsIn[i];         due.collateral -= param.collateralsOut[i];         assetIn += param.assetsIn[i];         collateralOut += param.collateralsOut[i];         unchecked { ++i; }     }     ... ```  At L484, if there is only one `id`, and for the first and only time of the for loop, `assetIn` and `collateralOut` will be `0`, therefore `require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');` will pass.  A attacker can call `pay()` with `param.assetsIn[0] == 0` and `param.collateralsOut[i] == due.collateral`.  ### PoC  The attacker can:   1. `borrow()` `10,000 USDC` with `1 BTC` as `collateral`; 2. `pay()` with `0 USDC` as `assetsIn` and `1 BTC` as `collateralsOut`.  As a result, the attacker effectively stole `10,000 USDC`.  ### Recommendation  Change to:  ```solidity for (uint256 i; i < param.ids.length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');     due.debt -= param.assetsIn[i];     due.collateral -= param.collateralsOut[i];     assetIn += param.assetsIn[i];     collateralOut += param.collateralsOut[i];     unchecked { ++i; } }  require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); ... ```  
# Gas Optimizations ## optimize the for loop in the pay function of the TimeswapPair contracts The for loop in the pay function can be optimized. Let's look at the for loop: ```sol for (uint256 i; i < param.ids.length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');     due.debt -= param.assetsIn[i];     due.collateral -= param.collateralsOut[i];     assetIn += param.assetsIn[i];     collateralOut += param.collateralsOut[i];     unchecked { ++i; } } ```  It is pretty optimized, but it can be more optimized: 1. The array's length can be saved instead of being accessed in every iteration. 2. `param.assetsIn[i]` and `param.collateralsOut[i]` can be saved in order to save gas. Instead of accessing it multiple times in every iteration, these values can be saved in a local variable.  The code after these changes will look like this: ```sol uint length = param.ids.length; uint112 collateralOut_i; uint112 assetsIn_i;  for (uint256 i; i < length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');      assetsIn_i = param.assetsIn[i];     collateralOut_i = param.collateralOut[i];      if (param.owner != msg.sender) require(collateralOut_i == 0, 'E213');     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');     due.debt -= assetsIn_i;     due.collateral -= collateralOut_i;     assetIn += assetsIn_i;     collateralOut += collateralOut_i;     unchecked { ++i; } } ```   ## Use local variables (memory) instead of storage variables In order to save gas, local variables can be used instead of storage variables. For example, let's look at the `mint` function of the `TimeswapPair` contract: ```sol     function mint(MintParam calldata param)         external         override         lock         returns (             uint256 assetIn,             uint256 liquidityOut,             uint256 id,             Due memory dueOut         )     {            // ...          Pool storage pool = pools[param.maturity];          uint256 feeStoredIncrease;         (liquidityOut, dueOut, feeStoredIncrease) = TimeswapMath.mint(             param.maturity,             pool.state,             param.xIncrease,             param.yIncrease,             param.zIncrease         );          require(liquidityOut != 0, 'E212');         pool.state.totalLiquidity += liquidityOut;         pool.liquidities[param.liquidityTo] += liquidityOut;          pool.state.feeStored += feeStoredIncrease;           id = pool.dues[param.dueTo].insert(dueOut);          pool.state.reserves.asset += param.xIncrease;         pool.state.reserves.collateral += dueOut.collateral;         pool.state.totalDebtCreated += dueOut.debt;          pool.state.x += param.xIncrease;         pool.state.y += param.yIncrease;         pool.state.z += param.zIncrease;          assetIn = param.xIncrease;         assetIn += feeStoredIncrease;         Callback.mint(asset, collateral, assetIn, dueOut.collateral, param.data);          // ...     } ``` Here, a lot of changes are made to the pool variable. The pool variable is a storage variable (as we can see in here `Pool storage pool = pools[param.maturity]`), and instead of modifying it we can use a local (memory) variable and assign it to the storage memory in the end. That will made all the memory operations cheaper in gas and will cocnsume less gas.  This optimization can be done to the `pool` variable in more function in the `TimeswapPair` contract - the `burn`, `lend`, `withdraw`, `borrow` and `pay` functions.  ## optimize the `returnDataToString` function in the `SafeMetadata` library ```sol function returnDataToString(bytes memory data) private pure returns (string memory) {     if (data.length >= 64) {         return abi.decode(data, (string));     } else if (data.length == 32) {         uint8 i = 0;         while (i < 32 && data[i] != 0) {             i++;         }         bytes memory bytesArray = new bytes(i);         for (i = 0; i < 32 && data[i] != 0; i++) {             bytesArray[i] = data[i];         }         return string(bytesArray);     } else {         return '???';     } } ```  This function can be optimized in several ways: 1. Use ++i instead of i++. 2. Use unchecked on the increment of i. 3. Not initializing i to it's default value - when declaring the i variable, initializing it to zero actually costs more gas than just declaring it (`uint8 i;` is cheaper than `uint8 i = 0;`). 4. Instead of checking 2 conditions in the second loop, we can run using the new array length (the old i value).     The code after the mentioned changes will look like this: ```sol function returnDataToString(bytes memory data) private pure returns (string memory) {     if (data.length >= 64) {         return abi.decode(data, (string));     } else if (data.length == 32) {         uint8 i;         while (i < 32 && data[i] != 0) {             unchecked { ++i; }         }         bytes memory bytesArray = new bytes(i);         uint length = bytesArray.length;         for (i = 0; i < length; ) {             bytesArray[i] = data[i];             unchecked { ++i; }         }         return string(bytesArray);     } else {         return '???';     } } ```  These changes will save a great amount of gas spent on unnecessary stuff.
### Storage of `uints`/`ints` smaller than 32 bytes incurs overhead > When using elements that are smaller than 32 bytes, your contractâ€™s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed ```solidity uint16 public immutable override fee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L30  ```solidity uint16 public immutable override protocolFee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L32  ```solidity uint16 public immutable override fee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L21  ```solidity uint16 public immutable override protocolFee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L23   ### `abi.encode()` is less efficient than `abi.encodePacked()` ```solidity bytes32 salt = keccak256(abi.encode(asset, collateral, maturity.toString()));           ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Deploy.sol#L35  ```solidity bytes(abi.encode(params.asset, params.collateral, params.from, params.maturity))             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Pay.sol#L127  ```solidity bytes(abi.encode(params.asset, params.collateral, params.from))              ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L510  ```solidity bytes(abi.encode(params.asset, params.collateral, params.from))              ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Lend.sol#L383  ```solidity bytes(abi.encode(params.asset, params.collateral, params.assetFrom, params.collateralFrom))             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Mint.sol#L690  ```solidity pair = new TimeswapPair{saltkeccak256(abi.encode(asset, collateral))}(asset, collateral, fee, protocolFee);         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L52   ### `require()` strings longer than 32 bytes cost extra gas Consider not using the version of this function that takes in a `string` ```solidity "balanceOf Call to IERC20 token not successful" ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/libraries/SafeBalance.sol#L16  ### Using `> 0` costs more gas than `!= 0` when used on uints in a `require()` statement ```solidity require(pool.state.totalLiquidity > 0, 'E206');             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225   ### Splitting `require()` statements that use `&&` saves gas See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) for an example ```solidity require(asset != IERC20(address(0)) && collateral != IERC20(address(0)), 'E101');         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol   ### `<array>.length` should not be looked up in every loop of a for-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length ```solidity for (uint256 i; i < data.length; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L228  ```solidity for (uint256 i; i < param.ids.length;) {          ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L480  ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in for- and while-loops ```solidity for (i = 0; i < 32 && data[i] != 0; i++) {    ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L38  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L146  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L174  ```solidity for (uint256 i; i < data.length; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L228  ```solidity for (uint256 i; i <= end - begin; i++) {       ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L241   ### `++i` costs less gas than `++i`, especially when it's used in for-loops (`--i`/`i--` too) ```solidity for (i = 0; i < 32 && data[i] != 0; i++) {    ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L38  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L146  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L174  ```solidity for (uint256 i; i < data.length; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L228  ```solidity for (uint256 i; i <= end - begin; i++) {       ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L241   ### It costs more gas to initialize variables to zero than to let the default of zero be applied ```solidity uint8 i = 0;             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L33 
# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/package.json#L40   # Vulnerability details  ## Impact I discovered an npm package and the scope of the package is unclaimed on the NPM website. This will give any User to claim that package and be able to Upload a Malicious Code under that unclaimed package. This results in achieving the Remote code execution on developers/users' machine who depends on the timeswap repository to build it on local env.  ##Vulnerable Package Name: @timeswap-labs/timeswap-v1-core  ## Proof of Concept 1. Create an Organization called "timeswap-labs". 2. Create a package called "@timeswap-labs/timeswap-v1-core" under "timeswap-labs" Organization. 3. Attacker can able to upload malicious code on unclaimed npm package with a higher version like 99.99.99 4. Now If any user/timeswap developer installs it by npm install package.json. The malicious pkg will be executed.  Till now "The Package is not claimed on NPM Registry, but it's vulnerable to dependency confusion".  You can read more dependency confusion here: https://dhiyaneshgeek.github.io/web/security/2021/09/04/dependency-confusion/  ## Tools Used Nothing Just OSINT  ## Recommended Mitigation Steps Claim the Scope name called "timeswap-labs" By Following the above POC Step 1.  
1. Using mixed versions of openzeppelin: - Core:          "@openzeppelin/contracts": "^4.2.0" - Convenienve:   "@openzeppelin/contracts": "^4.1.0"  2. It seems that use an outdated version of openzeppelin - Core:          "@openzeppelin/contracts": "^4.2.0" - Convenienve:   "@openzeppelin/contracts": "^4.1.0" - **Latest:**        "@openzeppelin/contracts": "4.5.0"  3. Use a buggy solidity version with immutables. The contract use immutable, and this solidity version defined in the pragma has some issues with them, as you can see [here](https://github.com/ethereum/solidity/blob/develop/Changelog.md#089-2021-09-29).  4. Issue [69](https://github.com/code-423n4/2022-01-timeswap-findings/issues/69) remains active - [SafeMetadata.sol#L8-L27](https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L8-L27)
# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L513-L522   # Vulnerability details  ## Impact collectProtocolFee function has a missing zero address check on `asset.safeTransfer(to, protocolFeeOut);`  A user may mistakenly make the transfer to a zero address which may lead to loss of Protocol Fee.  ## Proof of Concept https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L519  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require check for the address passed in collectProtocolFee()  
  Title: Unused state variables Severity: GAS  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           Liquidity.sol, decimals  Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               TimeswapConvenience.repay (params)         TimeswapConvenience.repayETHAsset (params)         TimeswapConvenience.repayETHCollateral (params)    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           TimeswapPair.sol, ids.param, 480    Title: Unused declared local variables Severity: GAS  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           TimeswapConvenience.sol, timeswapMintCallback, _weth     
