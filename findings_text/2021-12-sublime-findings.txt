# Handle  p4st13r4   # Vulnerability details  ## Impact The `liquidityToken` function in `NoYield.sol` can have its state mutability changed to `pure` instead of `view`. This has no other effect than suppressing compiler warnings, but may help the compiler optimize this function in the future  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps Change state mutability of `liquidityToken` to `pure`  
# Handle  0x0x0x   # Vulnerability details  [https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L150](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L150)  In `Verfication.sol#unlinkAddress`, there is a not needed zero address check.  ```  require(_linkedTo != address(0), 'V:UA-Address not linked'); require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');  ```  Since, `msg.sender != address(0)`, there is no need for a zero address check here.  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept  Example:  ```  for (uint i = 0; i < arr.length; i++) {  //Operations not effecting the length of the array.  }  ```  Loading length of array costs gas. Therefore, the length should be cached, if the length of the array doesn't change inside the loop. Furthermore, there is no need to assign the initial value 0. This costs extra gas.  Recommended implementation:  ```  uint length = arr.length;  for (uint i; i < length; ++i) {  //Operations not effecting the length of the array.  }  ```  By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Occurences  ```  ./CreditLine/CreditLine.sol:484:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:662:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:738:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:892:        for (uint256 index = 0; index < _strategyList.length; index++) { ./CreditLine/CreditLine.sol:959:        for (uint256 index = 0; index < _strategyList.length; index++) { ./SavingsAccount/SavingsAccount.sol:289:        for (uint256 i = 0; i < _strategyList.length; i++) { ./SavingsAccount/SavingsAccount.sol:467:        for (uint256 i = 0; i < _strategyList.length; i++) {  ```  
# Handle  0x0x0x   # Vulnerability details  Current implementation to get the price is as follows:  `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);`  [https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050)  But it should not consult `borrowToken / collateralToken`, rather it should consult the inverse of this result. As a consequence, in `liquidate` the liquidator/lender can lose/gain funds as a result of this miscalculation.  ## Mitigation step  Replace it with  `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_collateralAsset, _borrowAsset);`  
# Handle  certora   # Vulnerability details   https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/Pool/Pool.sol#L645 if the borrow token is address(0) (ether), and someone calls withdrawLiquidity, it calls SavingsAccountUtil.transferTokens which will transfer to msg.sender, msg.value (of withdrawLiquidity, because it's an internal function). In other words, the liquidity provided will pay to themselves and their liquidity tokens will still be burned. therefore they will never be able to get their funds back.    ## Recommended Mitigation Steps the bug is in  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccountUtil.sol It is wrong to use msg.value in transferTokens because it'll be the msg.value of the calling function. therefore every transfer of ether using this function is wrong and dangerous, the solution is to remove all msg.value from this function and just transfer _amount regularly.  
# Handle  cmichel   # Vulnerability details  The `if` conditions in `Pool.withdrawLiquidity` are distinct conditions on the pool status. Therefore, `else if` is semantically equivalent but more gas efficient.  ```solidity if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {     uint256 _totalAsset;     if (poolConstants.borrowAsset != address(0)) {         _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));     } else {         _totalAsset = address(this).balance;     }     //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()     _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply()); } // @audit gas: use else if, status fields are distinct, only one of the branches is (if ever) executed anyway if (_loanStatus == LoanStatus.CANCELLED) {     _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply())); }  if (_loanStatus == LoanStatus.CLOSED) {     //transfer repayment     _withdrawRepayment(msg.sender); } ```   
# Handle  cmichel   # Vulnerability details  When transferring pool tokens to oneself the `Pool._beforeTokenTransfer` overwrites the `effectiveInterestWithdrawn` of the user with a higher amount than expected. It uses the previous balance + the transfer amount instead of just the previous balance:  ```solidity // @audit if from == to: overwrites with last _to statement => bug lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply); lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply); ```  # Impact The bug is not in the user's favor and would lead to them being able to withdraw fewer repayments in the future.  #### POC - user calls `Pool.transfer(from=user, to=user, amount=pool.balanceOf(user))` - pending repayments are withdrawn first by the `_withdrawRepayment` calls. (second one does not lead to a second withdrawal as the `effectiveInterestWithdrawn` is already increased in the first call) - `lenders[user].effectiveInterestWithdrawn` is then set using `2 * userBalance`. - This has the effect that the user appears to have claimed twice as many repayments as their balance indicates already and they won't be able to claim anymore for a while.  ## Recommended Mitigation Steps We still recommend fixing this bug, for example, by disallowing self-transfers.   
# Handle  cmichel   # Vulnerability details  The `Extension` contract correctly reduces votes from the `from` address of a transfer and adds it to the `to` address of the transfer (in case both of them voted on it before), but it does not rerun the voting logic in `voteOnExtension` that actually grants the extension. This leads to issues where an extension should be granted but is not:  #### POC - `to` address has 100 tokens and votes for the extension - `from` address has 100 tokens but does not vote for the extension and transfers the 100 tokens to `to` - `to` now has 200 tokens, `removeVotes` is run, the `totalExtensionSupport` is increased by 100 to 200. In theory, the threshold is reached and the vote should pass if `to` could call `voteOnExtension` again. - But their call to `voteOnExtension` with the new balance will fail as they already voted on it (`lastVotedExtension == _extensionVoteEndTime`). The extension is not granted.  ## Impact Extensions that should be granted after a token transfer are not granted.  ## Recommended Mitigation Steps Rerun the threshold logic in `removeVotes` as it has the potential to increase the total support if `to` voted for the extension but `from` did not.   
# Handle  cmichel   # Vulnerability details  The strategy contracts define an `unlockShares` function that must accept an `asset` parameter as the **share** token (yield token, aToken, cToken, etc.), otherwise, the code does not work. However, all comments say that `asset` is the address of the **underlying token**.  ```solidity /**   * @notice Used to unlock shares   * @param asset the address of underlying token   * @param amount the amount of shares to unlock   * @return received amount of shares received   **/ function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {     if (amount == 0) {         return 0;     } } ```  ## Recommended Mitigation Steps Fix the comments for all `unlockShares` by saying `asset` is the share token, not the underlying token.   
# Handle  cmichel   # Vulnerability details  The yearn strategy `YearnYield` converts shares to tokens by doing `pricePerFullShare * shares / 1e18`:  ``` function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {     if (shares == 0) return 0;     // @audit should divided by vaultDecimals      amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18); } ```  But Yearn's `getPricePerFullShare` seems to be [in `vault.decimals()` precision](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L1147), i.e., it should convert it as `pricePerFullShare * shares / (10 ** vault.decimals())`. The vault decimals are the same [as the underlying token decimals](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L295-L296)  ## Impact The token and shares conversions do not work correctly for underlying tokens that do not have 18 decimals. Too much or too little might be paid out leading to a loss for either the protocol or user.  ## Recommended Mitigation Steps Divide by `10**vault.decimals()` instead of `1e18` in `getTokensForShares`. Apply a similar fix in `getSharesForTokens`.  
# Handle  WatchPug   # Vulnerability details  The function `SavingsAccountUtil.depositFromSavingsAccount()` is expected to return the number of equivalent shares for given `_asset`.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L225-L267  ```solidity /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } } ```  However, since `savingsAccountTransfer()` does not return the result of `_savingsAccount.transfer()`, but returned `_amount` instead, which means that `SavingsAccountUtil.depositFromSavingsAccount()` may not return the actual shares (when pps is not 1).   https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L11-L26  ```solidity     function depositFromSavingsAccount(         ISavingsAccount _savingsAccount,         address _from,         address _to,         uint256 _amount,         address _token,         address _strategy,         bool _withdrawShares,         bool _toSavingsAccount     ) internal returns (uint256) {         if (_toSavingsAccount) {             return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);         } else {             return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);         }     } ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L66-L80  ```solidity     function savingsAccountTransfer(         ISavingsAccount _savingsAccount,         address _from,         address _to,         uint256 _amount,         address _token,         address _strategy     ) internal returns (uint256) {         if (_from == address(this)) {             _savingsAccount.transfer(_amount, _token, _strategy, _to);         } else {             _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);         }         return _amount;     } ```  As a result, the recorded `_sharesReceived` can be wrong.   https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L207-L223  ```solidity     function _depositCollateral(         address _depositor,         uint256 _amount,         bool _transferFromSavingsAccount     ) internal nonReentrant {         uint256 _sharesReceived = _deposit(             _transferFromSavingsAccount,             true,             poolConstants.collateralAsset,             _amount,             poolConstants.poolSavingsStrategy,             _depositor,             address(this)         );         poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);         emit CollateralAdded(_depositor, _amount, _sharesReceived);     } ```  ### PoC  Given:  - the price per share of yearn USDC vault is `1.2`  1. Alice deposited `12,000 USDC` to `yearn` strategy, received `10,000` share tokens; 2. Alice created a pool, and added all the `12,000 USDC` from the saving account as collateral; The recorded `CollateralAdded` got the wrong number: `12000` which should be `10000`; 3. Alice failed to borrow money with the pool and tries to `cancelPool()`, it fails as the recorded collateral `shares` are more than the actual collateral.  As a result, Alice has lost all the `12,000 USDC`.  If Alice managed to borrow with the pool, when the loan defaults, the liquidation will also fail, and cause fund loss to the lenders.  ### Recommendation  Change to:  ```solidity function savingsAccountTransfer(     ISavingsAccount _savingsAccount,     address _from,     address _to,     uint256 _amount,     address _token,     address _strategy ) internal returns (uint256) {     if (_from == address(this)) {         return _savingsAccount.transfer(_amount, _token, _strategy, _to);     } else {         return _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);     } } ```  
# Handle  gzeon   # Vulnerability details  Rewrite the PoolConstants struct as follow can save some gas ```     struct PoolConstants {         uint256 borrowAmountRequested;         uint256 loanStartTime;         uint256 loanWithdrawalDeadline;         uint256 idealCollateralRatio;         uint256 borrowRate;         uint256 noOfRepaymentIntervals;         uint256 repaymentInterval;         address borrower;         address borrowAsset;         address collateralAsset;         address poolSavingsStrategy; // invest contract         address lenderVerifier;     }      ``` https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L46  
# Handle  WatchPug   # Vulnerability details  Check if `_poolStatus` and `block.timestamp` earlier can avoid unnecessary code execution when this check failed.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L310-L348  ```solidity     function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {         LoanStatus _poolStatus = poolVariables.loanStatus;         uint256 _tokensLent = totalSupply();         require(             _poolStatus == LoanStatus.COLLECTION &&                 poolConstants.loanStartTime < block.timestamp &&                 block.timestamp < poolConstants.loanWithdrawalDeadline,             'WBA1'         );         IPoolFactory _poolFactory = IPoolFactory(poolFactory);         require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');          poolVariables.loanStatus = LoanStatus.ACTIVE;         uint256 _currentCollateralRatio = getCurrentCollateralRatio();         require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');          uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;         uint256 _repaymentInterval = poolConstants.repaymentInterval;         IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(             _noOfRepaymentIntervals,             _repaymentInterval,             poolConstants.borrowRate,             poolConstants.loanStartTime,             poolConstants.borrowAsset         );         IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);          address _borrowAsset = poolConstants.borrowAsset;         (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();         uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);         delete poolConstants.loanWithdrawalDeadline;          uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);          SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);         SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);          emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);     } ```  ### Recommendation  Change to:  ```solidity     function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {         LoanStatus _poolStatus = poolVariables.loanStatus;         require(             _poolStatus == LoanStatus.COLLECTION &&                 poolConstants.loanStartTime < block.timestamp &&                 block.timestamp < poolConstants.loanWithdrawalDeadline,             'WBA1'         );         uint256 _tokensLent = totalSupply();         IPoolFactory _poolFactory = IPoolFactory(poolFactory);         require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');          poolVariables.loanStatus = LoanStatus.ACTIVE;         uint256 _currentCollateralRatio = getCurrentCollateralRatio();         require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');          uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;         uint256 _repaymentInterval = poolConstants.repaymentInterval;         IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(             _noOfRepaymentIntervals,             _repaymentInterval,             poolConstants.borrowRate,             poolConstants.loanStartTime,             poolConstants.borrowAsset         );         IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);          address _borrowAsset = poolConstants.borrowAsset;         (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();         uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);         delete poolConstants.loanWithdrawalDeadline;          uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);          SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);         SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);          emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L379-L383  ```solidity     function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {         require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');         liquidatorRewardFraction = _rewardFraction;         emit LiquidationRewardFractionUpdated(_rewardFraction);     } ```  Can be changed to:  ```solidity     function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {         require(_rewardFraction <= 1e30, 'Fraction has to be less than 1');         liquidatorRewardFraction = _rewardFraction;         emit LiquidationRewardFractionUpdated(_rewardFraction);     } ```  and save some gas from unnecessary arithmetic operation in `10**30`.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  The local variables `_receivedToken` in the functions `SavingsAccount.withdraw` and `SavingsAccount.withdrawFrom` are unused.  Removing them would save gas.  ## Tools used  slither  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `wethGateway` in `AaveYield#_withdrawETH()`      https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L307-L312  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L78-L83  ```solidity=78{81} function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     uint256 amount = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received);     received = amount; } ```  `received` is not being assigned prior to L81, therefore, at L81, `received` is `0`.  As a result, the `emergencyWithdraw()` does not work, in essence.  ### Recommendation  Change to:  ```solidity=78 function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     received = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L691-L727  ```solidity=691{693-694} function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender; ```  `_borrowableAmount` is unnecessary. The code above can be changed to:  ```solidity=691{693} function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(_amount <= calculateBorrowableAmount(_id), "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender; ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L391-L399  ```solidity=391 function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; } ```  `_interest` is unnecessary.  
# Handle  WatchPug   # Vulnerability details  Given that `Pool` is deployed as a proxied contract, it should use the Upgradeable variant of OpenZeppelin Contracts.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/PoolFactory.sol#L320-L355  ```solidity=320{348} function _createPool(     uint256 _poolSize,     uint256 _borrowRate,     address _borrowToken,     address _collateralToken,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     bytes32 _salt,     address _lenderVerifier ) internal {     bytes memory data = _encodePoolInitCall(         _poolSize,         _borrowRate,         _borrowToken,         _collateralToken,         _idealCollateralRatio,         _repaymentInterval,         _noOfRepaymentIntervals,         _poolSavingsStrategy,         _collateralAmount,         _transferFromSavingsAccount,         _lenderVerifier     );     bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));     bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));     uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;      address pool = _deploy(amount, salt, bytecode);      poolRegistry[pool] = true;     emit PoolCreated(pool, msg.sender); } ```  Otherwise, the constructor functions of `Pool`'s parent contracts which may change storage at deploy time, won't work for deployed instances.  The effect may be different for different OpenZeppelin libraries.  Take `ReentrancyGuard` for example, the code inside `ReentrancyGuard.sol#constructor` won't work, should use `ReentrancyGuardUpgradeable.sol` instead:  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L6-L8  ```solidity=6{6} import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L24-L24  ```solidity=24 contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard { ```  ### Recommendation  Change to:  ```solidity=6{6} import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; ```  ```solidity=24 contract Pool is Initializable, ReentrancyGuardUpgradeable, ERC20PausableUpgradeable, IPool { ```  ```solidity=133{164} function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ReentrancyGuard_init();     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} } ```  
# Handle  WatchPug   # Vulnerability details  Having a consistent naming style in the project leads to fewer errors.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Proxy.sol#L6-L6  ```solidity=6 contract SublimeProxy is TransparentUpgradeableProxy { ```  The filename `Proxy.sol` should be `SublimeProxy.sol`.  
# Handle  defsec   # Vulnerability details  ## Impact  Setter functions for critical contract parameters accessible only by privileged roles e.g. admin should consider adding timelocks (along with emitted events) so that users and other privileged roles can detect upcoming changes and have the time to react to them.  Changes to whitelists, oracle addresses and migrator address may have a financial or trust impact on users who should be given an opportunity to react to them by exiting/engaging without being surprised when such changes are made effective immediately.  See similar Medium-severity finding in ConsenSys's Audit of 1inch Liquidity Protocol (https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing)    ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L189  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L203  2. The functions are responsible for the price oracles. Therefore, If the price oracle is set to wrong. All price feeds will be affected by this.   ## Tools Used  None  ## Recommended Mitigation Steps  Consider adding timelocks to such contracts with critical setter functions.    
# Handle  defsec   # Vulnerability details  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.   """ https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/YearnYield.sol#L42  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/CompoundYield.sol#L43  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/AaveYield.sol#L71  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/NoYield.sol#L31  """   ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  
# Handle  Jujic   # Vulnerability details  ## Impact There doesn't seem to be a use case for the existence of the `receive()` function. In fact, I will recommend removing it as it will prevent accidental native token transfers to the contract.  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L481  ## Tools Used VSC ## Recommended Mitigation Steps https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L481  
# Handle  sirhashalot   # Vulnerability details  ## Impact  There are 3 instances where the `IERC20.approve()` function is called only once without setting the allowance to zero. Some tokens, like USDT, require first reducing the address' allowance to zero by calling `approve(_spender, 0)`. Transactions will revert when using an unsupported token like USDT (see the `approve()` function requirement [at line 199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)).  ## Proof of Concept  - [CreditLine/CreditLine.sol:647](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L647) - [CreditLine/CreditLine.sol:779](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L779) - [yield/AaveYield.sol:324](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L324)  Note: the usage of `approve()` in yield/CompoundYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/CompoundYield.sol#L211-L212)), in yield/YearnYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/YearnYield.sol#L210-L211)), and in yield/AaveYield.sol ([lines 297-298](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L297-L298)) do not need modification since it they already use the recommended approach. Additionally the usage of `approve()` in [yield/AaveYield.sol:307](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L307) likely does not need modification since that approve function only handles ETH.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Use `approve(_spender, 0)` to set the allowance to zero immediately before each of the existing `approve()` calls.  
# Handle  harleythedog   # Vulnerability details  ## Impact It is intended that if a credit line has autoLiquidation as false, then only the lender can be the liquidator (see docs here: https://docs.sublime.finance/sublime-docs/smart-contracts/creditlines). However, this is not correctly implemented, and anyone can liquidate a position that has autoLiquidation set to false.   Even worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens (determined by `_borrowTokensToLiquidate`) that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, so this represents a huge loss to the lender. Since the lender will lose all of the collateral that they are owed, this is a high severity issue.  ## Proof of Concept The current implementation of liquidate is here: https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L996.  Notice that the autoLiquidation value is only used in one place within this function, which is in this segment of the code: ``` ...  if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {   uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);   if (_borrowAsset == address(0)) {    uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');    if (_returnETH != 0) {     (bool success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'Transfer fail');    }   } else {   IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);   }  }    _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);   emit  CreditLineLiquidated(_id, msg.sender); } ```  So, if `autoLiquidation` is false, the code inside of the if statement will simply not be executed, and there are no further checks that the sender HAS to be the lender if `autoLiquidation` is false. This means that anyone can liquidate a non-autoLiquidation credit line, and receive all of the collateral without first transferring the necessary borrow tokens.  For a further proof of concept, consider the test file here: https://github.com/code-423n4/2021-12-sublime/blob/main/test/CreditLines/2.spec.ts. If the code on line 238 is changed from `let  _autoLiquidation: boolean  =  true;` to `let  _autoLiquidation: boolean  =  false;`, all the test cases will still pass. This confirms the issue, as the final test case "Liquidate credit line" has the `admin` as the liquidator, which should not work in non-autoLiquidations since they are not the lender.   ## Tools Used Inspection and confirmed with Hardhat.  ## Recommended Mitigation Steps Add the following require statement somewhere in the `liquidate` function:  ``` require(  creditLineConstants[_id].autoLiquidation ||   msg.sender == creditLineConstants[_id].lender,  "not autoLiquidation and not lender"); ```  
# Handle  robee   # Vulnerability details   The following contracts have a function that allows them an admin to change it to a different address. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked. It is important to have two steps admin change where the first is announcing a pending new admin and the new address should then claim its ownership.  A similar issue was reported in a previous contest and was assigned a severity of medium: [code-423n4/2021-06-realitycards-findings#105](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105)           ILendingPoolAddressesProvider.sol         IUniswapV3Factory.sol         Controller.sol         Strategy.sol         yVault.sol  
# Handle  Jujic   # Vulnerability details  ## Impact Using the safeMath to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.   ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L461  ``` if (_maxPossible > _currentDebt) {             return _maxPossible.sub(_currentDebt); ```  ## Tools Used  ## Recommended Mitigation Steps Consider using: ``` if (_maxPossible > _currentDebt) {             return _maxPossible - _currentDebt; ```  
# Handle  hyh   # Vulnerability details  ## Impact  Funds that are acquired from a liquidator and should be sent to a lender are left with the contract instead. The funds aren't lost, but after the fact mitigation will require manual accounting and fund transfer for each CreditLine.liquidate usage.  ## Proof of Concept  ETH sent to CreditLine.liquidate by an external liquidator when `autoLiquidation` is enabled remain with the contract and aren't transferred to the lender: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L1015  ## Recommended Mitigation Steps  Add transfer to a lender for ETH case:  Now: ``` if (_borrowAsset == address(0)) {   uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');   if (_returnETH != 0) {     (bool success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'Transfer fail');   } } ```  To be: ``` if (_borrowAsset == address(0)) {   uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');      (bool success, ) = _lender.call{value: _borrowTokens}('');   require(success, 'liquidate: Transfer failed');      if (_returnETH != 0) {     (success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'liquidate: Return transfer failed');   } } ```  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The public `calculateInterest` function in CreditLine.sol is missing a @param comment for the `_timeElapsed` parameter. This parameter is obviously important and the units should be clearly stated as seconds.  ## Proof of Concept  The `calculateInterest` function in CreditLine.sol: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L385-L395   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the following line to the `calculateInterest` function comments in CreditLine.sol: `* @param _timeElapsed Seconds elapsed since lastPrincipalUpdateTime`  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `updateProtocolFeeFraction` function in CreditLine.sol does not validate the value submitted. Fee fractions of 0%, 100%, or 200% are equally valid. A maximum fee value check is recommended and a similar check is used in `_updateLiquidatorRewardFraction` in CreditLine.sol to set a maximum liquidator fraction. However, if the assumption is that the owner is trusted and does not make mistakes, this may not be considered a problem.   ## Proof of Concept  The `updateProtocolFeeFraction` function calls `_updateProtocolFeeFraction` in CreditLine.sol: https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L335-L338   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Apply a maximum fee hard cap with a require statement to make sure the fee does not exceed a certain limit, whether by admin error or theoretical malicious overtake of the contract  
# Handle  sirhashalot   # Vulnerability details  ## Impact  There are many instances of the value 30, usually used for exponents of base 10. Currently this integer value is used directly without a clear indication that this value relates to the decimals value, which could lead to one of these values being modified but not the other (perhaps by a typo), which is the basis for many past hacks. Coding best practices suggests using a constant integer to store this value in a way that clearly explains the purpose of this value to prevent confusion.  ## Proof of Concept The magic number 30 is found in dozens of places, including:  Pool/Repayments.sol https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Repayments.sol#L164-L165  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Repayments.sol#L190  PriceOracle.sol file https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/PriceOracle.sol#L130-L131  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/PriceOracle.sol#L88-L93   ## Tools Used  Manual review  ## Recommended Mitigation Steps  Replace the magic number 30 with a variable explaining the meaning of this value, such as: `uint8 private constant DECIMALS_EXPONENT = 30;`  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Weird naming ## Proof of Concept  Credit lines have an "ideal collateral ratio" which acts very much like a minimum collateral ratio, i.e. if you fall below it you can be liquidated.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1002  "Ideal" to me implies that you'll be hovering around that value sometimes drifting above and sometimes below but the systems drives the value back to the ideal so this is quite confusingly named imo.  ## Recommended Mitigation Steps  Change `idealCollateralRatio` to `minCollateralRatio`  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L600-L604  ``` (msg.sender == creditLineConstants[_id].borrower && _requestByLender) || (msg.sender == creditLineConstants[_id].lender && !_requestByLender) ```  is equivalent to   ``` _requestByLender ? (msg.sender == creditLineConstants[_id].borrower) : (msg.sender == creditLineConstants[_id].lender) ``` or ``` msg.sender == (_requestByLender ? creditLineConstants[_id].borrower : creditLineConstants[_id].lender) ```  Which avoid loading the borrower address in the case where the borrower made the request.  ## Recommended Mitigation Steps  Use simplified logic  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Possible confusion  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L326-L368  Compare this to the standard ERC20 versions.  ``` approve(address spender, uint256 amount)  vs   approve(uint256 amount, address token, address to)  ```  Having the amount at the beginning is very odd imo and I'd expect it at the end.  ## Recommended Mitigation Steps  Change `approve(uint256 amount, address token, address to)` to `approve(address token, address to, uint256 amount)` and similar for other functions.  I'd also change `to` to the standard `spender` but this is nbd.     
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs on linking/unlinking addresses  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L10-L13  The activation timestamp can be restricted to a `uint64` variable so that it shares a slot with the `masterAddress`. This will save an SSTORE and a substantial amount of gas.  ## Recommended Mitigation Steps  As above.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Inability to set a sensible range which covers all borrow assets without being overly wide.  ## Proof of Concept  `PoolFactory` has a set requirement that created pool must ask to borrow an amount of assets which are within a certain range as encoded in the `poolSizeLimit`.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/PoolFactory.sol#L286  This doesn't take into account the relative values of each borrow asset so it's hard to choose a one-size-fits-all value for these limits (A 100 WBTC loan could be sensible but a 100 USDC loan will be dwarfs by the gas costs to deploy the pool.)  ## Recommended Mitigation Steps  Place limits on the USD value of the borrowed amount as reported by the factory's price oracle.  
# Handle  TomFrenchBlockchain   # Vulnerability details  Typo in "cancelled"  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L545  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L322-L340  In `Pool.withdrawBorrowedAmount` we set the loan to active and delete the withdrawal deadline (see link).  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L802  When checking whether we can liquidate the pool we check that the loan is active and that `block.timestamp > poolConstants.loanWithdrawalDeadline`. This second condition always resolves true as `poolConstants.loanWithdrawalDeadline = 0` after deletion. We can then save an SLOAD by skipping this second check.  ## Recommended Mitigation Steps  As above.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function repayPrincipal() calls _repay() with MAX_INT as parameter. In _repay() this value (_amount) is multiplied by 10**30. As _amount already has the maximum value of an int256 it will overflow. Because solidity 7.6.0 is used and mul() isn't used (!) this actually works. The resulting value is still large and thus the function repayPrincipal() does still work.  It is not recommended to rely on overflow working and when moving to solidity 0.8.x this will no longer work.  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L23  ```JS     uint256 constant MAX_INT = 2**256 - 1; ```  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L377-L425  ```JS      function repayPrincipal(address payable _poolID) external payable nonReentrant isPoolInitialized(_poolID) {         ....         uint256 _interestToRepay = _repay(_poolID, MAX_INT, true);         ...   function _repay( ... uint256 _amount,..) internal returns (uint256) { ..         _amount = _amount * 10**30;     ```  ## Tools Used  ## Recommended Mitigation Steps Use safemath in _replay() and change MAX_INT to something like: ```JS uint256 constant LARGE_INT = 2**128 ``` Note: 10**30 ~ 2**100  
# Handle  gpersoon   # Vulnerability details  ## Impact The function transferTokens of SavingsAccountUtil.sol sends the excess ETH to msg.sender, while a _from parameter is also present in the function. It seems more logical to send it to _from, like the similar function _transferTokens of Repayments.sol  Luckily in the current code the _from is always msg.sender so it doesn't pose a direct risk. However if the code is reused or forked it might lead to unexpected issues.  Note: transferTokens and _transferTokens are very similar so they could be integrated; they have to be checked carefully when doing this  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccountUtil.sol#L98-L127 ```JS function transferTokens(.... ,   address _from,   address _to ) {      ...        (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}(''); // uses msg.sender instead of _from // also uses - instead of sub  ```  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L457-L473 ```JS     function _transferTokens(  address _from,  address _to,.... ) {        (bool refundSuccess, ) = payable(_from).call{value: msg.value.sub(_amount)}(''); ```  ## Tools Used  ## Recommended Mitigation Steps In function transferTokens() change msg.sender to _from   
# Handle  gpersoon   # Vulnerability details  ## Impact After a master calls unlinkAddress() to unlink an address, the address that has just been unlinked can directly link again without permission. The address that is just unlinked can call linkAddress(masterAddress) which will execute because pendingLinkAddresses is still set. Assuming the master has unlinked for a good reason it is unwanted to be able to be linked again without any permission from the master.  Note: a master can prevent this by calling cancelAddressLinkingRequest(), but this doesn't seem logical to do  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Verification/Verification.sol#L129-L154  ```JS     function unlinkAddress(address _linkedAddress) external {         address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;         require(_linkedTo != address(0), 'V:UA-Address not linked');         require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');         delete linkedAddresses[_linkedAddress];         ... }     function linkAddress(address _masterAddress) external {         require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA-Address already linked');   // == true (after unlinkAddress)         require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA-No pending request');                 // == true (after unlinkAddress)         _linkAddress(msg.sender, _masterAddress);                                                                                           // // pendingLinkAddresses not reset     }  function cancelAddressLinkingRequest(address _linkedAddress) external {         ...          delete pendingLinkAddresses[_linkedAddress][msg.sender]; // only location where pendingLinkAddresses is reset ```  ## Tools Used  ## Recommended Mitigation Steps Add something like to following at the end of linkAddress: ```JS  delete pendingLinkAddresses[msg.sender][_masterAddress];  ```  
# Handle  leastwood   # Vulnerability details  ## Impact  The `emergencyWithdraw` function is implemented in all yield sources to allow the `onlyOwner` role to drain the contract's balance in case of emergency. The contract considers ETH as a zero address asset. However, there is a call made on `_asset` which will revert if it is the zero address. As a result, ETH tokens can never be withdrawn from the `NoYield` contract in the event of an emergency.  ## Proof of Concept  Consider the case where `_asset == address(0)`. An external call is made to check the contract's token balance for the target `_asset`. However, this call will revert as `_asset` is the zero address. As a result, the `onlyOwner` role will never be able to withdraw ETH tokens during an emergency.  ``` function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     uint256 amount = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received);     received = amount; } ```  Affected function as per below: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/yield/NoYield.sol#L78-L83  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider handling the case where `_asset` is the zero address, i.e. the asset to be withdrawn under emergency is the ETH token.  
# Handle  0xngndev   # Vulnerability details  ### Impact  Some of your contracts are quite large byte-wise and require the optimizer with low runs to not reach the code size limit of 24576 bytes. The code size of these contracts can be drastically reduced by shortening the length of your error messages, reducing their deployment cost.  The best example of contracts having unnecessary long erorr messages are `CreditLine.sol` and `PoolFactory.sol`. When it comes to factories, whose primary goal is to deploy contracts, reducing the cost  of doing so is something to keep in mind.  ### Mitigation Steps  Reduce the length of your error strings. Error messages like:  `'PoolFactory::createPool - Repayment interval not within limits'`  Could be reduced to:  `Interval out of limits`  You could save even more by doing something similar to what Uniswap does. They have very short error messages like: `ST`, and they expand on what they mean in their documentation.  Another approach is to use revert with CustomErrors, something like this:  `if (....) revert CustomError()`  Following the example I used above, you could have a custom error message that says:  `OutOfBounds()` and expand what it means in the natspec.  Custom error messages are cheaper than strings error messages. Here's a snippet of Solidity's documentation about this:  > Using a**custom****error**instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs. >  
# Handle  0xngndev   # Vulnerability details  ## Impact  In `AaveYield.sol` the functions:  - `liquidityToken` - `_withdrawETH` - `_depositETH`  Make a conditional call to `IWETHGateway(wethGateway).getAWETHAddress()`  This function does not exist in the `wethGateway` contract, causing these function to fail with the error `"Fallback not allowed"`.  The function they should be calling is `getWethAddress()` without the "A".  Small yet dangerous typo.  ### Mitigation Steps  Simply modify:   `IWETHGateway(wethGateway).getAWETHAddress()`  to:  `IWETHGateway(wethGateway).getWETHAddress()`  In the functions mentioned above.  
# Handle  0xngndev   # Vulnerability details  ### Impact  Reduce code size and gas expenditure by inlining internal functions that are only used once throughout your contract.  In some of your contracts, like `AaveYield.sol`, you have an `initialize` function that calls the internal functions `updateSavingsAccount` and `updateAaveAddresses`. These two functions are only called in the `initialize` function, so you can save some gas and code size by simply inlining their logic inside `initialize`. **The tradeoff, of course, is that you lose readability, and because `initialize` will only be called once, perhaps it's not worth the tradeoff.**  To test the difference in code size and gas expenditure I wrote a example contract replicating the behaviour to see how much cheaper inlining the logic was.  **The results:**  Inlining the logic:  - Gas spent: 45155 - Code size: 453 bytes  Separating into internal functions:  - Gas spent: 45189 - Code size: 467 bytes  ### Proof of Concept  Contracts I used to test the gas expenditure and code size differences:  - InliningLogic  ```bash //SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.10;  contract InliningLogic {   address public someRandomAddress;   address public anotherRandomAddress;    function assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) public {     someRandomAddress = _someRandomAddress;     anotherRandomAddress = _anotherRandomAddress;   } } ```  - InliningLogic.t > DappTools test file  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import "ds-test/test.sol"; import "../InliningLogic.sol";  contract InliningLogicTest is DSTest {   InliningLogic inliningLogicContract;    function setUp() public {     inliningLogicContract = new InliningLogic();   }    function testInliningLogic() public logs_gas {     inliningLogicContract.assignAddresses(address(0x1), address(0x1));   } } ```  - NotInliningLogic  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  contract NotInliningLogic {   address public someRandomAddress;   address public anotherRandomAddress;    function assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) public {     _assignAddresses(_someRandomAddress, _anotherRandomAddress);   }    function _assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) internal {     someRandomAddress = _someRandomAddress;     anotherRandomAddress = _anotherRandomAddress;   } } ```  - NotInliningLogic.t > test file  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import "ds-test/test.sol"; import "../NotInliningLogic.sol";  contract NotInliningLogicTest is DSTest {   NotInliningLogic notInliningLogicContract;    function setUp() public {     notInliningLogicContract = new NotInliningLogic();   }    function testNotInliningLogic() public logs_gas {     notInliningLogicContract.assignAddresses(address(0x1), address(0x1));   } } ```  ### Tools  DappTools  
# Handle  sirhashalot   # Vulnerability details  ## Impact  uint256 variable are initialized to a default value of zero per Solidity docs: https://docs.soliditylang.org/en/latest/control-structures.html#default-value   Setting a variable to the default value is unnecessary. Removing lines of code where variables are initialized to zero can save gas. Here are a few articles describing this gas optimization: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#53bd  https://medium.com/coinmonks/gas-optimization-in-solidity-part-i-variables-9d5775e43dde#4135   ## Proof of Concept  - contracts/Pool/Pool.sol:358 https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L358  - contracts/CreditLine/CreditLine.sol:812 https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L812   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Instead of initializing a variable to zero, such as `uint256 abc = 0;`, the line can be shortened to `uint256 abc;` as Solidity automatically initializes uint variables to zero.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The method initializeRepayment inside the contract Repayments has multipe storage access, it's better to get a pointer of the `RepaymentConstants` with the `storage` keyword in order to avoid seeking and storage access.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use storage keyword in order to save gas  
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: CreditLine.sol, _index, 484         change to prefix increment and unchecked: CreditLine.sol, _index, 661         change to prefix increment and unchecked: CreditLine.sol, _index, 735         change to prefix increment and unchecked: CreditLine.sol, index, 888         change to prefix increment and unchecked: CreditLine.sol, index, 955         change to prefix increment and unchecked: SavingsAccount.sol, i, 286         change to prefix increment and unchecked: SavingsAccount.sol, i, 464    
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept  It's possible to optimize the struct CreditLineConstants from CreditLine contract, the last 4 fields spend 3 storage slots, moving the boolean values between the address values, it will spend only two slots as follows:  ```struct CreditLineConstants {         address lender;         address borrower;         uint256 borrowLimit;         uint256 idealCollateralRatio;         uint256 borrowRate;         address borrowAsset;         bool autoLiquidation;         address collateralAsset;         bool requestByLender;     }```.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Reorder the structs fields  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept In the method updateStrategy and removeStrategy of StrategyRegistry contract, when the contract want to remove a strategy, the old one, it's set to false, instead of use delete, this will remaing the storage space and it has expensive than use delete.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use delete instead of set to `false`  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The method addStrategy inside StrategyRegistry do a require with safe math: `require(strategies.length.add(1) <= maxStrategies, "StrategyRegistry::addStrategy - Can't add more strategies");` is not possible to has a map that could lead in an integer overflow, so remove this `add` and use a regular +  will safe gas.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove safe math in this call  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept In the contract `StrategyRegistry` the method `initialize` execute a require in order to check that the `_maxStrategies` is different than 0, this check will be done later inside the method `_updateMaxStrategies`, so it's duplicated and can be removed.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove the _maxStrategies checks inside the initialize method.  
# Handle  sirhashalot   # Vulnerability details  The OpenZeppelin ERC20 `safeApprove()` function has been deprecated, as seen in the comments of the OpenZeppelin code.  ## Impact Detailed description of the impact of this finding.  Using this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in OZ [issue #2219](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219).  ## Proof of Concept  The deprecated function is found in: - SavingsAccount/SavingsAccount.sol [line 173](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccount.sol#L173) - SavingsAccount/SavingsAccountUtil.sol [line 61](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccountUtil.sol#L61) - mocks/yVault/yVault.sol [line 164](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/mocks/yVault/yVault.sol#L164) - mocks/yVault/Controller.sol [line 196 and 197](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/mocks/yVault/Controller.sol#L196)   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  As suggested by the OpenZeppelin comment, replace `safeApprove()` with `safeIncreaseAllowance()` or `safeDecreaseAllowance()` instead.  
# Handle  p4st13r4   # Vulnerability details  ## Impact The `liquidityToken` function in `NoYield.sol` can have its state mutability changed to `pure` instead of `view`. This has no other effect than suppressing compiler warnings, but may help the compiler optimize this function in the future  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps Change state mutability of `liquidityToken` to `pure`  
# Handle  0x0x0x   # Vulnerability details  [https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L150](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L150)  In `Verfication.sol#unlinkAddress`, there is a not needed zero address check.  ```  require(_linkedTo != address(0), 'V:UA-Address not linked'); require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');  ```  Since, `msg.sender != address(0)`, there is no need for a zero address check here.  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept  Example:  ```  for (uint i = 0; i < arr.length; i++) {  //Operations not effecting the length of the array.  }  ```  Loading length of array costs gas. Therefore, the length should be cached, if the length of the array doesn't change inside the loop. Furthermore, there is no need to assign the initial value 0. This costs extra gas.  Recommended implementation:  ```  uint length = arr.length;  for (uint i; i < length; ++i) {  //Operations not effecting the length of the array.  }  ```  By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Occurences  ```  ./CreditLine/CreditLine.sol:484:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:662:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:738:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:892:        for (uint256 index = 0; index < _strategyList.length; index++) { ./CreditLine/CreditLine.sol:959:        for (uint256 index = 0; index < _strategyList.length; index++) { ./SavingsAccount/SavingsAccount.sol:289:        for (uint256 i = 0; i < _strategyList.length; i++) { ./SavingsAccount/SavingsAccount.sol:467:        for (uint256 i = 0; i < _strategyList.length; i++) {  ```  
# Handle  0x0x0x   # Vulnerability details  Current implementation to get the price is as follows:  `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);`  [https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050)  But it should not consult `borrowToken / collateralToken`, rather it should consult the inverse of this result. As a consequence, in `liquidate` the liquidator/lender can lose/gain funds as a result of this miscalculation.  ## Mitigation step  Replace it with  `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_collateralAsset, _borrowAsset);`  
# Handle  certora   # Vulnerability details   https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/Pool/Pool.sol#L645 if the borrow token is address(0) (ether), and someone calls withdrawLiquidity, it calls SavingsAccountUtil.transferTokens which will transfer to msg.sender, msg.value (of withdrawLiquidity, because it's an internal function). In other words, the liquidity provided will pay to themselves and their liquidity tokens will still be burned. therefore they will never be able to get their funds back.    ## Recommended Mitigation Steps the bug is in  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccountUtil.sol It is wrong to use msg.value in transferTokens because it'll be the msg.value of the calling function. therefore every transfer of ether using this function is wrong and dangerous, the solution is to remove all msg.value from this function and just transfer _amount regularly.  
# Handle  cmichel   # Vulnerability details  The `if` conditions in `Pool.withdrawLiquidity` are distinct conditions on the pool status. Therefore, `else if` is semantically equivalent but more gas efficient.  ```solidity if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {     uint256 _totalAsset;     if (poolConstants.borrowAsset != address(0)) {         _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));     } else {         _totalAsset = address(this).balance;     }     //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()     _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply()); } // @audit gas: use else if, status fields are distinct, only one of the branches is (if ever) executed anyway if (_loanStatus == LoanStatus.CANCELLED) {     _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply())); }  if (_loanStatus == LoanStatus.CLOSED) {     //transfer repayment     _withdrawRepayment(msg.sender); } ```   
# Handle  cmichel   # Vulnerability details  When transferring pool tokens to oneself the `Pool._beforeTokenTransfer` overwrites the `effectiveInterestWithdrawn` of the user with a higher amount than expected. It uses the previous balance + the transfer amount instead of just the previous balance:  ```solidity // @audit if from == to: overwrites with last _to statement => bug lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply); lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply); ```  # Impact The bug is not in the user's favor and would lead to them being able to withdraw fewer repayments in the future.  #### POC - user calls `Pool.transfer(from=user, to=user, amount=pool.balanceOf(user))` - pending repayments are withdrawn first by the `_withdrawRepayment` calls. (second one does not lead to a second withdrawal as the `effectiveInterestWithdrawn` is already increased in the first call) - `lenders[user].effectiveInterestWithdrawn` is then set using `2 * userBalance`. - This has the effect that the user appears to have claimed twice as many repayments as their balance indicates already and they won't be able to claim anymore for a while.  ## Recommended Mitigation Steps We still recommend fixing this bug, for example, by disallowing self-transfers.   
# Handle  cmichel   # Vulnerability details  The `Extension` contract correctly reduces votes from the `from` address of a transfer and adds it to the `to` address of the transfer (in case both of them voted on it before), but it does not rerun the voting logic in `voteOnExtension` that actually grants the extension. This leads to issues where an extension should be granted but is not:  #### POC - `to` address has 100 tokens and votes for the extension - `from` address has 100 tokens but does not vote for the extension and transfers the 100 tokens to `to` - `to` now has 200 tokens, `removeVotes` is run, the `totalExtensionSupport` is increased by 100 to 200. In theory, the threshold is reached and the vote should pass if `to` could call `voteOnExtension` again. - But their call to `voteOnExtension` with the new balance will fail as they already voted on it (`lastVotedExtension == _extensionVoteEndTime`). The extension is not granted.  ## Impact Extensions that should be granted after a token transfer are not granted.  ## Recommended Mitigation Steps Rerun the threshold logic in `removeVotes` as it has the potential to increase the total support if `to` voted for the extension but `from` did not.   
# Handle  cmichel   # Vulnerability details  The strategy contracts define an `unlockShares` function that must accept an `asset` parameter as the **share** token (yield token, aToken, cToken, etc.), otherwise, the code does not work. However, all comments say that `asset` is the address of the **underlying token**.  ```solidity /**   * @notice Used to unlock shares   * @param asset the address of underlying token   * @param amount the amount of shares to unlock   * @return received amount of shares received   **/ function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {     if (amount == 0) {         return 0;     } } ```  ## Recommended Mitigation Steps Fix the comments for all `unlockShares` by saying `asset` is the share token, not the underlying token.   
# Handle  cmichel   # Vulnerability details  The yearn strategy `YearnYield` converts shares to tokens by doing `pricePerFullShare * shares / 1e18`:  ``` function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {     if (shares == 0) return 0;     // @audit should divided by vaultDecimals      amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18); } ```  But Yearn's `getPricePerFullShare` seems to be [in `vault.decimals()` precision](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L1147), i.e., it should convert it as `pricePerFullShare * shares / (10 ** vault.decimals())`. The vault decimals are the same [as the underlying token decimals](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L295-L296)  ## Impact The token and shares conversions do not work correctly for underlying tokens that do not have 18 decimals. Too much or too little might be paid out leading to a loss for either the protocol or user.  ## Recommended Mitigation Steps Divide by `10**vault.decimals()` instead of `1e18` in `getTokensForShares`. Apply a similar fix in `getSharesForTokens`.  
# Handle  WatchPug   # Vulnerability details  The function `SavingsAccountUtil.depositFromSavingsAccount()` is expected to return the number of equivalent shares for given `_asset`.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L225-L267  ```solidity /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } } ```  However, since `savingsAccountTransfer()` does not return the result of `_savingsAccount.transfer()`, but returned `_amount` instead, which means that `SavingsAccountUtil.depositFromSavingsAccount()` may not return the actual shares (when pps is not 1).   https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L11-L26  ```solidity     function depositFromSavingsAccount(         ISavingsAccount _savingsAccount,         address _from,         address _to,         uint256 _amount,         address _token,         address _strategy,         bool _withdrawShares,         bool _toSavingsAccount     ) internal returns (uint256) {         if (_toSavingsAccount) {             return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);         } else {             return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);         }     } ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L66-L80  ```solidity     function savingsAccountTransfer(         ISavingsAccount _savingsAccount,         address _from,         address _to,         uint256 _amount,         address _token,         address _strategy     ) internal returns (uint256) {         if (_from == address(this)) {             _savingsAccount.transfer(_amount, _token, _strategy, _to);         } else {             _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);         }         return _amount;     } ```  As a result, the recorded `_sharesReceived` can be wrong.   https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L207-L223  ```solidity     function _depositCollateral(         address _depositor,         uint256 _amount,         bool _transferFromSavingsAccount     ) internal nonReentrant {         uint256 _sharesReceived = _deposit(             _transferFromSavingsAccount,             true,             poolConstants.collateralAsset,             _amount,             poolConstants.poolSavingsStrategy,             _depositor,             address(this)         );         poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);         emit CollateralAdded(_depositor, _amount, _sharesReceived);     } ```  ### PoC  Given:  - the price per share of yearn USDC vault is `1.2`  1. Alice deposited `12,000 USDC` to `yearn` strategy, received `10,000` share tokens; 2. Alice created a pool, and added all the `12,000 USDC` from the saving account as collateral; The recorded `CollateralAdded` got the wrong number: `12000` which should be `10000`; 3. Alice failed to borrow money with the pool and tries to `cancelPool()`, it fails as the recorded collateral `shares` are more than the actual collateral.  As a result, Alice has lost all the `12,000 USDC`.  If Alice managed to borrow with the pool, when the loan defaults, the liquidation will also fail, and cause fund loss to the lenders.  ### Recommendation  Change to:  ```solidity function savingsAccountTransfer(     ISavingsAccount _savingsAccount,     address _from,     address _to,     uint256 _amount,     address _token,     address _strategy ) internal returns (uint256) {     if (_from == address(this)) {         return _savingsAccount.transfer(_amount, _token, _strategy, _to);     } else {         return _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);     } } ```  
# Handle  gzeon   # Vulnerability details  Rewrite the PoolConstants struct as follow can save some gas ```     struct PoolConstants {         uint256 borrowAmountRequested;         uint256 loanStartTime;         uint256 loanWithdrawalDeadline;         uint256 idealCollateralRatio;         uint256 borrowRate;         uint256 noOfRepaymentIntervals;         uint256 repaymentInterval;         address borrower;         address borrowAsset;         address collateralAsset;         address poolSavingsStrategy; // invest contract         address lenderVerifier;     }      ``` https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L46  
# Handle  WatchPug   # Vulnerability details  Check if `_poolStatus` and `block.timestamp` earlier can avoid unnecessary code execution when this check failed.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L310-L348  ```solidity     function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {         LoanStatus _poolStatus = poolVariables.loanStatus;         uint256 _tokensLent = totalSupply();         require(             _poolStatus == LoanStatus.COLLECTION &&                 poolConstants.loanStartTime < block.timestamp &&                 block.timestamp < poolConstants.loanWithdrawalDeadline,             'WBA1'         );         IPoolFactory _poolFactory = IPoolFactory(poolFactory);         require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');          poolVariables.loanStatus = LoanStatus.ACTIVE;         uint256 _currentCollateralRatio = getCurrentCollateralRatio();         require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');          uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;         uint256 _repaymentInterval = poolConstants.repaymentInterval;         IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(             _noOfRepaymentIntervals,             _repaymentInterval,             poolConstants.borrowRate,             poolConstants.loanStartTime,             poolConstants.borrowAsset         );         IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);          address _borrowAsset = poolConstants.borrowAsset;         (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();         uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);         delete poolConstants.loanWithdrawalDeadline;          uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);          SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);         SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);          emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);     } ```  ### Recommendation  Change to:  ```solidity     function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {         LoanStatus _poolStatus = poolVariables.loanStatus;         require(             _poolStatus == LoanStatus.COLLECTION &&                 poolConstants.loanStartTime < block.timestamp &&                 block.timestamp < poolConstants.loanWithdrawalDeadline,             'WBA1'         );         uint256 _tokensLent = totalSupply();         IPoolFactory _poolFactory = IPoolFactory(poolFactory);         require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');          poolVariables.loanStatus = LoanStatus.ACTIVE;         uint256 _currentCollateralRatio = getCurrentCollateralRatio();         require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');          uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;         uint256 _repaymentInterval = poolConstants.repaymentInterval;         IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(             _noOfRepaymentIntervals,             _repaymentInterval,             poolConstants.borrowRate,             poolConstants.loanStartTime,             poolConstants.borrowAsset         );         IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);          address _borrowAsset = poolConstants.borrowAsset;         (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();         uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);         delete poolConstants.loanWithdrawalDeadline;          uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);          SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);         SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);          emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L379-L383  ```solidity     function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {         require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');         liquidatorRewardFraction = _rewardFraction;         emit LiquidationRewardFractionUpdated(_rewardFraction);     } ```  Can be changed to:  ```solidity     function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {         require(_rewardFraction <= 1e30, 'Fraction has to be less than 1');         liquidatorRewardFraction = _rewardFraction;         emit LiquidationRewardFractionUpdated(_rewardFraction);     } ```  and save some gas from unnecessary arithmetic operation in `10**30`.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  The local variables `_receivedToken` in the functions `SavingsAccount.withdraw` and `SavingsAccount.withdrawFrom` are unused.  Removing them would save gas.  ## Tools used  slither  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `wethGateway` in `AaveYield#_withdrawETH()`      https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L307-L312  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L78-L83  ```solidity=78{81} function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     uint256 amount = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received);     received = amount; } ```  `received` is not being assigned prior to L81, therefore, at L81, `received` is `0`.  As a result, the `emergencyWithdraw()` does not work, in essence.  ### Recommendation  Change to:  ```solidity=78 function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     received = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L691-L727  ```solidity=691{693-694} function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender; ```  `_borrowableAmount` is unnecessary. The code above can be changed to:  ```solidity=691{693} function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(_amount <= calculateBorrowableAmount(_id), "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender; ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L391-L399  ```solidity=391 function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; } ```  `_interest` is unnecessary.  
# Handle  WatchPug   # Vulnerability details  Given that `Pool` is deployed as a proxied contract, it should use the Upgradeable variant of OpenZeppelin Contracts.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/PoolFactory.sol#L320-L355  ```solidity=320{348} function _createPool(     uint256 _poolSize,     uint256 _borrowRate,     address _borrowToken,     address _collateralToken,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     bytes32 _salt,     address _lenderVerifier ) internal {     bytes memory data = _encodePoolInitCall(         _poolSize,         _borrowRate,         _borrowToken,         _collateralToken,         _idealCollateralRatio,         _repaymentInterval,         _noOfRepaymentIntervals,         _poolSavingsStrategy,         _collateralAmount,         _transferFromSavingsAccount,         _lenderVerifier     );     bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));     bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));     uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;      address pool = _deploy(amount, salt, bytecode);      poolRegistry[pool] = true;     emit PoolCreated(pool, msg.sender); } ```  Otherwise, the constructor functions of `Pool`'s parent contracts which may change storage at deploy time, won't work for deployed instances.  The effect may be different for different OpenZeppelin libraries.  Take `ReentrancyGuard` for example, the code inside `ReentrancyGuard.sol#constructor` won't work, should use `ReentrancyGuardUpgradeable.sol` instead:  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L6-L8  ```solidity=6{6} import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L24-L24  ```solidity=24 contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard { ```  ### Recommendation  Change to:  ```solidity=6{6} import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; ```  ```solidity=24 contract Pool is Initializable, ReentrancyGuardUpgradeable, ERC20PausableUpgradeable, IPool { ```  ```solidity=133{164} function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ReentrancyGuard_init();     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} } ```  
# Handle  WatchPug   # Vulnerability details  Having a consistent naming style in the project leads to fewer errors.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Proxy.sol#L6-L6  ```solidity=6 contract SublimeProxy is TransparentUpgradeableProxy { ```  The filename `Proxy.sol` should be `SublimeProxy.sol`.  
# Handle  defsec   # Vulnerability details  ## Impact  Setter functions for critical contract parameters accessible only by privileged roles e.g. admin should consider adding timelocks (along with emitted events) so that users and other privileged roles can detect upcoming changes and have the time to react to them.  Changes to whitelists, oracle addresses and migrator address may have a financial or trust impact on users who should be given an opportunity to react to them by exiting/engaging without being surprised when such changes are made effective immediately.  See similar Medium-severity finding in ConsenSys's Audit of 1inch Liquidity Protocol (https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing)    ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L189  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L203  2. The functions are responsible for the price oracles. Therefore, If the price oracle is set to wrong. All price feeds will be affected by this.   ## Tools Used  None  ## Recommended Mitigation Steps  Consider adding timelocks to such contracts with critical setter functions.    
# Handle  defsec   # Vulnerability details  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.   """ https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/YearnYield.sol#L42  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/CompoundYield.sol#L43  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/AaveYield.sol#L71  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/NoYield.sol#L31  """   ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  
# Handle  Jujic   # Vulnerability details  ## Impact There doesn't seem to be a use case for the existence of the `receive()` function. In fact, I will recommend removing it as it will prevent accidental native token transfers to the contract.  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L481  ## Tools Used VSC ## Recommended Mitigation Steps https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L481  
# Handle  sirhashalot   # Vulnerability details  ## Impact  There are 3 instances where the `IERC20.approve()` function is called only once without setting the allowance to zero. Some tokens, like USDT, require first reducing the address' allowance to zero by calling `approve(_spender, 0)`. Transactions will revert when using an unsupported token like USDT (see the `approve()` function requirement [at line 199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)).  ## Proof of Concept  - [CreditLine/CreditLine.sol:647](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L647) - [CreditLine/CreditLine.sol:779](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L779) - [yield/AaveYield.sol:324](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L324)  Note: the usage of `approve()` in yield/CompoundYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/CompoundYield.sol#L211-L212)), in yield/YearnYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/YearnYield.sol#L210-L211)), and in yield/AaveYield.sol ([lines 297-298](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L297-L298)) do not need modification since it they already use the recommended approach. Additionally the usage of `approve()` in [yield/AaveYield.sol:307](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L307) likely does not need modification since that approve function only handles ETH.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Use `approve(_spender, 0)` to set the allowance to zero immediately before each of the existing `approve()` calls.  
# Handle  harleythedog   # Vulnerability details  ## Impact It is intended that if a credit line has autoLiquidation as false, then only the lender can be the liquidator (see docs here: https://docs.sublime.finance/sublime-docs/smart-contracts/creditlines). However, this is not correctly implemented, and anyone can liquidate a position that has autoLiquidation set to false.   Even worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens (determined by `_borrowTokensToLiquidate`) that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, so this represents a huge loss to the lender. Since the lender will lose all of the collateral that they are owed, this is a high severity issue.  ## Proof of Concept The current implementation of liquidate is here: https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L996.  Notice that the autoLiquidation value is only used in one place within this function, which is in this segment of the code: ``` ...  if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {   uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);   if (_borrowAsset == address(0)) {    uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');    if (_returnETH != 0) {     (bool success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'Transfer fail');    }   } else {   IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);   }  }    _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);   emit  CreditLineLiquidated(_id, msg.sender); } ```  So, if `autoLiquidation` is false, the code inside of the if statement will simply not be executed, and there are no further checks that the sender HAS to be the lender if `autoLiquidation` is false. This means that anyone can liquidate a non-autoLiquidation credit line, and receive all of the collateral without first transferring the necessary borrow tokens.  For a further proof of concept, consider the test file here: https://github.com/code-423n4/2021-12-sublime/blob/main/test/CreditLines/2.spec.ts. If the code on line 238 is changed from `let  _autoLiquidation: boolean  =  true;` to `let  _autoLiquidation: boolean  =  false;`, all the test cases will still pass. This confirms the issue, as the final test case "Liquidate credit line" has the `admin` as the liquidator, which should not work in non-autoLiquidations since they are not the lender.   ## Tools Used Inspection and confirmed with Hardhat.  ## Recommended Mitigation Steps Add the following require statement somewhere in the `liquidate` function:  ``` require(  creditLineConstants[_id].autoLiquidation ||   msg.sender == creditLineConstants[_id].lender,  "not autoLiquidation and not lender"); ```  
# Handle  robee   # Vulnerability details   The following contracts have a function that allows them an admin to change it to a different address. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked. It is important to have two steps admin change where the first is announcing a pending new admin and the new address should then claim its ownership.  A similar issue was reported in a previous contest and was assigned a severity of medium: [code-423n4/2021-06-realitycards-findings#105](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105)           ILendingPoolAddressesProvider.sol         IUniswapV3Factory.sol         Controller.sol         Strategy.sol         yVault.sol  
# Handle  Jujic   # Vulnerability details  ## Impact Using the safeMath to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.   ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L461  ``` if (_maxPossible > _currentDebt) {             return _maxPossible.sub(_currentDebt); ```  ## Tools Used  ## Recommended Mitigation Steps Consider using: ``` if (_maxPossible > _currentDebt) {             return _maxPossible - _currentDebt; ```  
# Handle  hyh   # Vulnerability details  ## Impact  Funds that are acquired from a liquidator and should be sent to a lender are left with the contract instead. The funds aren't lost, but after the fact mitigation will require manual accounting and fund transfer for each CreditLine.liquidate usage.  ## Proof of Concept  ETH sent to CreditLine.liquidate by an external liquidator when `autoLiquidation` is enabled remain with the contract and aren't transferred to the lender: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L1015  ## Recommended Mitigation Steps  Add transfer to a lender for ETH case:  Now: ``` if (_borrowAsset == address(0)) {   uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');   if (_returnETH != 0) {     (bool success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'Transfer fail');   } } ```  To be: ``` if (_borrowAsset == address(0)) {   uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');      (bool success, ) = _lender.call{value: _borrowTokens}('');   require(success, 'liquidate: Transfer failed');      if (_returnETH != 0) {     (success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'liquidate: Return transfer failed');   } } ```  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The public `calculateInterest` function in CreditLine.sol is missing a @param comment for the `_timeElapsed` parameter. This parameter is obviously important and the units should be clearly stated as seconds.  ## Proof of Concept  The `calculateInterest` function in CreditLine.sol: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L385-L395   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the following line to the `calculateInterest` function comments in CreditLine.sol: `* @param _timeElapsed Seconds elapsed since lastPrincipalUpdateTime`  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `updateProtocolFeeFraction` function in CreditLine.sol does not validate the value submitted. Fee fractions of 0%, 100%, or 200% are equally valid. A maximum fee value check is recommended and a similar check is used in `_updateLiquidatorRewardFraction` in CreditLine.sol to set a maximum liquidator fraction. However, if the assumption is that the owner is trusted and does not make mistakes, this may not be considered a problem.   ## Proof of Concept  The `updateProtocolFeeFraction` function calls `_updateProtocolFeeFraction` in CreditLine.sol: https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L335-L338   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Apply a maximum fee hard cap with a require statement to make sure the fee does not exceed a certain limit, whether by admin error or theoretical malicious overtake of the contract  
# Handle  sirhashalot   # Vulnerability details  ## Impact  There are many instances of the value 30, usually used for exponents of base 10. Currently this integer value is used directly without a clear indication that this value relates to the decimals value, which could lead to one of these values being modified but not the other (perhaps by a typo), which is the basis for many past hacks. Coding best practices suggests using a constant integer to store this value in a way that clearly explains the purpose of this value to prevent confusion.  ## Proof of Concept The magic number 30 is found in dozens of places, including:  Pool/Repayments.sol https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Repayments.sol#L164-L165  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Repayments.sol#L190  PriceOracle.sol file https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/PriceOracle.sol#L130-L131  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/PriceOracle.sol#L88-L93   ## Tools Used  Manual review  ## Recommended Mitigation Steps  Replace the magic number 30 with a variable explaining the meaning of this value, such as: `uint8 private constant DECIMALS_EXPONENT = 30;`  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Weird naming ## Proof of Concept  Credit lines have an "ideal collateral ratio" which acts very much like a minimum collateral ratio, i.e. if you fall below it you can be liquidated.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1002  "Ideal" to me implies that you'll be hovering around that value sometimes drifting above and sometimes below but the systems drives the value back to the ideal so this is quite confusingly named imo.  ## Recommended Mitigation Steps  Change `idealCollateralRatio` to `minCollateralRatio`  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L600-L604  ``` (msg.sender == creditLineConstants[_id].borrower && _requestByLender) || (msg.sender == creditLineConstants[_id].lender && !_requestByLender) ```  is equivalent to   ``` _requestByLender ? (msg.sender == creditLineConstants[_id].borrower) : (msg.sender == creditLineConstants[_id].lender) ``` or ``` msg.sender == (_requestByLender ? creditLineConstants[_id].borrower : creditLineConstants[_id].lender) ```  Which avoid loading the borrower address in the case where the borrower made the request.  ## Recommended Mitigation Steps  Use simplified logic  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Possible confusion  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L326-L368  Compare this to the standard ERC20 versions.  ``` approve(address spender, uint256 amount)  vs   approve(uint256 amount, address token, address to)  ```  Having the amount at the beginning is very odd imo and I'd expect it at the end.  ## Recommended Mitigation Steps  Change `approve(uint256 amount, address token, address to)` to `approve(address token, address to, uint256 amount)` and similar for other functions.  I'd also change `to` to the standard `spender` but this is nbd.     
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs on linking/unlinking addresses  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L10-L13  The activation timestamp can be restricted to a `uint64` variable so that it shares a slot with the `masterAddress`. This will save an SSTORE and a substantial amount of gas.  ## Recommended Mitigation Steps  As above.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Inability to set a sensible range which covers all borrow assets without being overly wide.  ## Proof of Concept  `PoolFactory` has a set requirement that created pool must ask to borrow an amount of assets which are within a certain range as encoded in the `poolSizeLimit`.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/PoolFactory.sol#L286  This doesn't take into account the relative values of each borrow asset so it's hard to choose a one-size-fits-all value for these limits (A 100 WBTC loan could be sensible but a 100 USDC loan will be dwarfs by the gas costs to deploy the pool.)  ## Recommended Mitigation Steps  Place limits on the USD value of the borrowed amount as reported by the factory's price oracle.  
# Handle  TomFrenchBlockchain   # Vulnerability details  Typo in "cancelled"  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L545  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L322-L340  In `Pool.withdrawBorrowedAmount` we set the loan to active and delete the withdrawal deadline (see link).  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L802  When checking whether we can liquidate the pool we check that the loan is active and that `block.timestamp > poolConstants.loanWithdrawalDeadline`. This second condition always resolves true as `poolConstants.loanWithdrawalDeadline = 0` after deletion. We can then save an SLOAD by skipping this second check.  ## Recommended Mitigation Steps  As above.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function repayPrincipal() calls _repay() with MAX_INT as parameter. In _repay() this value (_amount) is multiplied by 10**30. As _amount already has the maximum value of an int256 it will overflow. Because solidity 7.6.0 is used and mul() isn't used (!) this actually works. The resulting value is still large and thus the function repayPrincipal() does still work.  It is not recommended to rely on overflow working and when moving to solidity 0.8.x this will no longer work.  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L23  ```JS     uint256 constant MAX_INT = 2**256 - 1; ```  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L377-L425  ```JS      function repayPrincipal(address payable _poolID) external payable nonReentrant isPoolInitialized(_poolID) {         ....         uint256 _interestToRepay = _repay(_poolID, MAX_INT, true);         ...   function _repay( ... uint256 _amount,..) internal returns (uint256) { ..         _amount = _amount * 10**30;     ```  ## Tools Used  ## Recommended Mitigation Steps Use safemath in _replay() and change MAX_INT to something like: ```JS uint256 constant LARGE_INT = 2**128 ``` Note: 10**30 ~ 2**100  
# Handle  gpersoon   # Vulnerability details  ## Impact The function transferTokens of SavingsAccountUtil.sol sends the excess ETH to msg.sender, while a _from parameter is also present in the function. It seems more logical to send it to _from, like the similar function _transferTokens of Repayments.sol  Luckily in the current code the _from is always msg.sender so it doesn't pose a direct risk. However if the code is reused or forked it might lead to unexpected issues.  Note: transferTokens and _transferTokens are very similar so they could be integrated; they have to be checked carefully when doing this  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccountUtil.sol#L98-L127 ```JS function transferTokens(.... ,   address _from,   address _to ) {      ...        (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}(''); // uses msg.sender instead of _from // also uses - instead of sub  ```  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L457-L473 ```JS     function _transferTokens(  address _from,  address _to,.... ) {        (bool refundSuccess, ) = payable(_from).call{value: msg.value.sub(_amount)}(''); ```  ## Tools Used  ## Recommended Mitigation Steps In function transferTokens() change msg.sender to _from   
# Handle  gpersoon   # Vulnerability details  ## Impact After a master calls unlinkAddress() to unlink an address, the address that has just been unlinked can directly link again without permission. The address that is just unlinked can call linkAddress(masterAddress) which will execute because pendingLinkAddresses is still set. Assuming the master has unlinked for a good reason it is unwanted to be able to be linked again without any permission from the master.  Note: a master can prevent this by calling cancelAddressLinkingRequest(), but this doesn't seem logical to do  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Verification/Verification.sol#L129-L154  ```JS     function unlinkAddress(address _linkedAddress) external {         address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;         require(_linkedTo != address(0), 'V:UA-Address not linked');         require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');         delete linkedAddresses[_linkedAddress];         ... }     function linkAddress(address _masterAddress) external {         require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA-Address already linked');   // == true (after unlinkAddress)         require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA-No pending request');                 // == true (after unlinkAddress)         _linkAddress(msg.sender, _masterAddress);                                                                                           // // pendingLinkAddresses not reset     }  function cancelAddressLinkingRequest(address _linkedAddress) external {         ...          delete pendingLinkAddresses[_linkedAddress][msg.sender]; // only location where pendingLinkAddresses is reset ```  ## Tools Used  ## Recommended Mitigation Steps Add something like to following at the end of linkAddress: ```JS  delete pendingLinkAddresses[msg.sender][_masterAddress];  ```  
# Handle  leastwood   # Vulnerability details  ## Impact  The `emergencyWithdraw` function is implemented in all yield sources to allow the `onlyOwner` role to drain the contract's balance in case of emergency. The contract considers ETH as a zero address asset. However, there is a call made on `_asset` which will revert if it is the zero address. As a result, ETH tokens can never be withdrawn from the `NoYield` contract in the event of an emergency.  ## Proof of Concept  Consider the case where `_asset == address(0)`. An external call is made to check the contract's token balance for the target `_asset`. However, this call will revert as `_asset` is the zero address. As a result, the `onlyOwner` role will never be able to withdraw ETH tokens during an emergency.  ``` function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     uint256 amount = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received);     received = amount; } ```  Affected function as per below: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/yield/NoYield.sol#L78-L83  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider handling the case where `_asset` is the zero address, i.e. the asset to be withdrawn under emergency is the ETH token.  
# Handle  0xngndev   # Vulnerability details  ### Impact  Some of your contracts are quite large byte-wise and require the optimizer with low runs to not reach the code size limit of 24576 bytes. The code size of these contracts can be drastically reduced by shortening the length of your error messages, reducing their deployment cost.  The best example of contracts having unnecessary long erorr messages are `CreditLine.sol` and `PoolFactory.sol`. When it comes to factories, whose primary goal is to deploy contracts, reducing the cost  of doing so is something to keep in mind.  ### Mitigation Steps  Reduce the length of your error strings. Error messages like:  `'PoolFactory::createPool - Repayment interval not within limits'`  Could be reduced to:  `Interval out of limits`  You could save even more by doing something similar to what Uniswap does. They have very short error messages like: `ST`, and they expand on what they mean in their documentation.  Another approach is to use revert with CustomErrors, something like this:  `if (....) revert CustomError()`  Following the example I used above, you could have a custom error message that says:  `OutOfBounds()` and expand what it means in the natspec.  Custom error messages are cheaper than strings error messages. Here's a snippet of Solidity's documentation about this:  > Using a**custom****error**instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs. >  
# Handle  0xngndev   # Vulnerability details  ## Impact  In `AaveYield.sol` the functions:  - `liquidityToken` - `_withdrawETH` - `_depositETH`  Make a conditional call to `IWETHGateway(wethGateway).getAWETHAddress()`  This function does not exist in the `wethGateway` contract, causing these function to fail with the error `"Fallback not allowed"`.  The function they should be calling is `getWethAddress()` without the "A".  Small yet dangerous typo.  ### Mitigation Steps  Simply modify:   `IWETHGateway(wethGateway).getAWETHAddress()`  to:  `IWETHGateway(wethGateway).getWETHAddress()`  In the functions mentioned above.  
# Handle  0xngndev   # Vulnerability details  ### Impact  Reduce code size and gas expenditure by inlining internal functions that are only used once throughout your contract.  In some of your contracts, like `AaveYield.sol`, you have an `initialize` function that calls the internal functions `updateSavingsAccount` and `updateAaveAddresses`. These two functions are only called in the `initialize` function, so you can save some gas and code size by simply inlining their logic inside `initialize`. **The tradeoff, of course, is that you lose readability, and because `initialize` will only be called once, perhaps it's not worth the tradeoff.**  To test the difference in code size and gas expenditure I wrote a example contract replicating the behaviour to see how much cheaper inlining the logic was.  **The results:**  Inlining the logic:  - Gas spent: 45155 - Code size: 453 bytes  Separating into internal functions:  - Gas spent: 45189 - Code size: 467 bytes  ### Proof of Concept  Contracts I used to test the gas expenditure and code size differences:  - InliningLogic  ```bash //SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.10;  contract InliningLogic {   address public someRandomAddress;   address public anotherRandomAddress;    function assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) public {     someRandomAddress = _someRandomAddress;     anotherRandomAddress = _anotherRandomAddress;   } } ```  - InliningLogic.t > DappTools test file  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import "ds-test/test.sol"; import "../InliningLogic.sol";  contract InliningLogicTest is DSTest {   InliningLogic inliningLogicContract;    function setUp() public {     inliningLogicContract = new InliningLogic();   }    function testInliningLogic() public logs_gas {     inliningLogicContract.assignAddresses(address(0x1), address(0x1));   } } ```  - NotInliningLogic  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  contract NotInliningLogic {   address public someRandomAddress;   address public anotherRandomAddress;    function assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) public {     _assignAddresses(_someRandomAddress, _anotherRandomAddress);   }    function _assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) internal {     someRandomAddress = _someRandomAddress;     anotherRandomAddress = _anotherRandomAddress;   } } ```  - NotInliningLogic.t > test file  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import "ds-test/test.sol"; import "../NotInliningLogic.sol";  contract NotInliningLogicTest is DSTest {   NotInliningLogic notInliningLogicContract;    function setUp() public {     notInliningLogicContract = new NotInliningLogic();   }    function testNotInliningLogic() public logs_gas {     notInliningLogicContract.assignAddresses(address(0x1), address(0x1));   } } ```  ### Tools  DappTools  
# Handle  sirhashalot   # Vulnerability details  ## Impact  uint256 variable are initialized to a default value of zero per Solidity docs: https://docs.soliditylang.org/en/latest/control-structures.html#default-value   Setting a variable to the default value is unnecessary. Removing lines of code where variables are initialized to zero can save gas. Here are a few articles describing this gas optimization: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#53bd  https://medium.com/coinmonks/gas-optimization-in-solidity-part-i-variables-9d5775e43dde#4135   ## Proof of Concept  - contracts/Pool/Pool.sol:358 https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L358  - contracts/CreditLine/CreditLine.sol:812 https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L812   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Instead of initializing a variable to zero, such as `uint256 abc = 0;`, the line can be shortened to `uint256 abc;` as Solidity automatically initializes uint variables to zero.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The method initializeRepayment inside the contract Repayments has multipe storage access, it's better to get a pointer of the `RepaymentConstants` with the `storage` keyword in order to avoid seeking and storage access.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use storage keyword in order to save gas  
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: CreditLine.sol, _index, 484         change to prefix increment and unchecked: CreditLine.sol, _index, 661         change to prefix increment and unchecked: CreditLine.sol, _index, 735         change to prefix increment and unchecked: CreditLine.sol, index, 888         change to prefix increment and unchecked: CreditLine.sol, index, 955         change to prefix increment and unchecked: SavingsAccount.sol, i, 286         change to prefix increment and unchecked: SavingsAccount.sol, i, 464    
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept  It's possible to optimize the struct CreditLineConstants from CreditLine contract, the last 4 fields spend 3 storage slots, moving the boolean values between the address values, it will spend only two slots as follows:  ```struct CreditLineConstants {         address lender;         address borrower;         uint256 borrowLimit;         uint256 idealCollateralRatio;         uint256 borrowRate;         address borrowAsset;         bool autoLiquidation;         address collateralAsset;         bool requestByLender;     }```.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Reorder the structs fields  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept In the method updateStrategy and removeStrategy of StrategyRegistry contract, when the contract want to remove a strategy, the old one, it's set to false, instead of use delete, this will remaing the storage space and it has expensive than use delete.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use delete instead of set to `false`  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The method addStrategy inside StrategyRegistry do a require with safe math: `require(strategies.length.add(1) <= maxStrategies, "StrategyRegistry::addStrategy - Can't add more strategies");` is not possible to has a map that could lead in an integer overflow, so remove this `add` and use a regular +  will safe gas.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove safe math in this call  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept In the contract `StrategyRegistry` the method `initialize` execute a require in order to check that the `_maxStrategies` is different than 0, this check will be done later inside the method `_updateMaxStrategies`, so it's duplicated and can be removed.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove the _maxStrategies checks inside the initialize method.  
# Handle  sirhashalot   # Vulnerability details  The OpenZeppelin ERC20 `safeApprove()` function has been deprecated, as seen in the comments of the OpenZeppelin code.  ## Impact Detailed description of the impact of this finding.  Using this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in OZ [issue #2219](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219).  ## Proof of Concept  The deprecated function is found in: - SavingsAccount/SavingsAccount.sol [line 173](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccount.sol#L173) - SavingsAccount/SavingsAccountUtil.sol [line 61](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccountUtil.sol#L61) - mocks/yVault/yVault.sol [line 164](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/mocks/yVault/yVault.sol#L164) - mocks/yVault/Controller.sol [line 196 and 197](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/mocks/yVault/Controller.sol#L196)   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  As suggested by the OpenZeppelin comment, replace `safeApprove()` with `safeIncreaseAllowance()` or `safeDecreaseAllowance()` instead.  
# Handle  p4st13r4   # Vulnerability details  ## Impact The `liquidityToken` function in `NoYield.sol` can have its state mutability changed to `pure` instead of `view`. This has no other effect than suppressing compiler warnings, but may help the compiler optimize this function in the future  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps Change state mutability of `liquidityToken` to `pure`  
# Handle  0x0x0x   # Vulnerability details  [https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L150](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L150)  In `Verfication.sol#unlinkAddress`, there is a not needed zero address check.  ```  require(_linkedTo != address(0), 'V:UA-Address not linked'); require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');  ```  Since, `msg.sender != address(0)`, there is no need for a zero address check here.  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept  Example:  ```  for (uint i = 0; i < arr.length; i++) {  //Operations not effecting the length of the array.  }  ```  Loading length of array costs gas. Therefore, the length should be cached, if the length of the array doesn't change inside the loop. Furthermore, there is no need to assign the initial value 0. This costs extra gas.  Recommended implementation:  ```  uint length = arr.length;  for (uint i; i < length; ++i) {  //Operations not effecting the length of the array.  }  ```  By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Occurences  ```  ./CreditLine/CreditLine.sol:484:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:662:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:738:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:892:        for (uint256 index = 0; index < _strategyList.length; index++) { ./CreditLine/CreditLine.sol:959:        for (uint256 index = 0; index < _strategyList.length; index++) { ./SavingsAccount/SavingsAccount.sol:289:        for (uint256 i = 0; i < _strategyList.length; i++) { ./SavingsAccount/SavingsAccount.sol:467:        for (uint256 i = 0; i < _strategyList.length; i++) {  ```  
# Handle  0x0x0x   # Vulnerability details  Current implementation to get the price is as follows:  `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);`  [https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050)  But it should not consult `borrowToken / collateralToken`, rather it should consult the inverse of this result. As a consequence, in `liquidate` the liquidator/lender can lose/gain funds as a result of this miscalculation.  ## Mitigation step  Replace it with  `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_collateralAsset, _borrowAsset);`  
# Handle  certora   # Vulnerability details   https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/Pool/Pool.sol#L645 if the borrow token is address(0) (ether), and someone calls withdrawLiquidity, it calls SavingsAccountUtil.transferTokens which will transfer to msg.sender, msg.value (of withdrawLiquidity, because it's an internal function). In other words, the liquidity provided will pay to themselves and their liquidity tokens will still be burned. therefore they will never be able to get their funds back.    ## Recommended Mitigation Steps the bug is in  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccountUtil.sol It is wrong to use msg.value in transferTokens because it'll be the msg.value of the calling function. therefore every transfer of ether using this function is wrong and dangerous, the solution is to remove all msg.value from this function and just transfer _amount regularly.  
# Handle  cmichel   # Vulnerability details  The `if` conditions in `Pool.withdrawLiquidity` are distinct conditions on the pool status. Therefore, `else if` is semantically equivalent but more gas efficient.  ```solidity if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {     uint256 _totalAsset;     if (poolConstants.borrowAsset != address(0)) {         _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));     } else {         _totalAsset = address(this).balance;     }     //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()     _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply()); } // @audit gas: use else if, status fields are distinct, only one of the branches is (if ever) executed anyway if (_loanStatus == LoanStatus.CANCELLED) {     _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply())); }  if (_loanStatus == LoanStatus.CLOSED) {     //transfer repayment     _withdrawRepayment(msg.sender); } ```   
# Handle  cmichel   # Vulnerability details  When transferring pool tokens to oneself the `Pool._beforeTokenTransfer` overwrites the `effectiveInterestWithdrawn` of the user with a higher amount than expected. It uses the previous balance + the transfer amount instead of just the previous balance:  ```solidity // @audit if from == to: overwrites with last _to statement => bug lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply); lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply); ```  # Impact The bug is not in the user's favor and would lead to them being able to withdraw fewer repayments in the future.  #### POC - user calls `Pool.transfer(from=user, to=user, amount=pool.balanceOf(user))` - pending repayments are withdrawn first by the `_withdrawRepayment` calls. (second one does not lead to a second withdrawal as the `effectiveInterestWithdrawn` is already increased in the first call) - `lenders[user].effectiveInterestWithdrawn` is then set using `2 * userBalance`. - This has the effect that the user appears to have claimed twice as many repayments as their balance indicates already and they won't be able to claim anymore for a while.  ## Recommended Mitigation Steps We still recommend fixing this bug, for example, by disallowing self-transfers.   
# Handle  cmichel   # Vulnerability details  The `Extension` contract correctly reduces votes from the `from` address of a transfer and adds it to the `to` address of the transfer (in case both of them voted on it before), but it does not rerun the voting logic in `voteOnExtension` that actually grants the extension. This leads to issues where an extension should be granted but is not:  #### POC - `to` address has 100 tokens and votes for the extension - `from` address has 100 tokens but does not vote for the extension and transfers the 100 tokens to `to` - `to` now has 200 tokens, `removeVotes` is run, the `totalExtensionSupport` is increased by 100 to 200. In theory, the threshold is reached and the vote should pass if `to` could call `voteOnExtension` again. - But their call to `voteOnExtension` with the new balance will fail as they already voted on it (`lastVotedExtension == _extensionVoteEndTime`). The extension is not granted.  ## Impact Extensions that should be granted after a token transfer are not granted.  ## Recommended Mitigation Steps Rerun the threshold logic in `removeVotes` as it has the potential to increase the total support if `to` voted for the extension but `from` did not.   
# Handle  cmichel   # Vulnerability details  The strategy contracts define an `unlockShares` function that must accept an `asset` parameter as the **share** token (yield token, aToken, cToken, etc.), otherwise, the code does not work. However, all comments say that `asset` is the address of the **underlying token**.  ```solidity /**   * @notice Used to unlock shares   * @param asset the address of underlying token   * @param amount the amount of shares to unlock   * @return received amount of shares received   **/ function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {     if (amount == 0) {         return 0;     } } ```  ## Recommended Mitigation Steps Fix the comments for all `unlockShares` by saying `asset` is the share token, not the underlying token.   
# Handle  cmichel   # Vulnerability details  The yearn strategy `YearnYield` converts shares to tokens by doing `pricePerFullShare * shares / 1e18`:  ``` function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {     if (shares == 0) return 0;     // @audit should divided by vaultDecimals      amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18); } ```  But Yearn's `getPricePerFullShare` seems to be [in `vault.decimals()` precision](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L1147), i.e., it should convert it as `pricePerFullShare * shares / (10 ** vault.decimals())`. The vault decimals are the same [as the underlying token decimals](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L295-L296)  ## Impact The token and shares conversions do not work correctly for underlying tokens that do not have 18 decimals. Too much or too little might be paid out leading to a loss for either the protocol or user.  ## Recommended Mitigation Steps Divide by `10**vault.decimals()` instead of `1e18` in `getTokensForShares`. Apply a similar fix in `getSharesForTokens`.  
# Handle  WatchPug   # Vulnerability details  The function `SavingsAccountUtil.depositFromSavingsAccount()` is expected to return the number of equivalent shares for given `_asset`.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L225-L267  ```solidity /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } } ```  However, since `savingsAccountTransfer()` does not return the result of `_savingsAccount.transfer()`, but returned `_amount` instead, which means that `SavingsAccountUtil.depositFromSavingsAccount()` may not return the actual shares (when pps is not 1).   https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L11-L26  ```solidity     function depositFromSavingsAccount(         ISavingsAccount _savingsAccount,         address _from,         address _to,         uint256 _amount,         address _token,         address _strategy,         bool _withdrawShares,         bool _toSavingsAccount     ) internal returns (uint256) {         if (_toSavingsAccount) {             return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);         } else {             return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);         }     } ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L66-L80  ```solidity     function savingsAccountTransfer(         ISavingsAccount _savingsAccount,         address _from,         address _to,         uint256 _amount,         address _token,         address _strategy     ) internal returns (uint256) {         if (_from == address(this)) {             _savingsAccount.transfer(_amount, _token, _strategy, _to);         } else {             _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);         }         return _amount;     } ```  As a result, the recorded `_sharesReceived` can be wrong.   https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L207-L223  ```solidity     function _depositCollateral(         address _depositor,         uint256 _amount,         bool _transferFromSavingsAccount     ) internal nonReentrant {         uint256 _sharesReceived = _deposit(             _transferFromSavingsAccount,             true,             poolConstants.collateralAsset,             _amount,             poolConstants.poolSavingsStrategy,             _depositor,             address(this)         );         poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);         emit CollateralAdded(_depositor, _amount, _sharesReceived);     } ```  ### PoC  Given:  - the price per share of yearn USDC vault is `1.2`  1. Alice deposited `12,000 USDC` to `yearn` strategy, received `10,000` share tokens; 2. Alice created a pool, and added all the `12,000 USDC` from the saving account as collateral; The recorded `CollateralAdded` got the wrong number: `12000` which should be `10000`; 3. Alice failed to borrow money with the pool and tries to `cancelPool()`, it fails as the recorded collateral `shares` are more than the actual collateral.  As a result, Alice has lost all the `12,000 USDC`.  If Alice managed to borrow with the pool, when the loan defaults, the liquidation will also fail, and cause fund loss to the lenders.  ### Recommendation  Change to:  ```solidity function savingsAccountTransfer(     ISavingsAccount _savingsAccount,     address _from,     address _to,     uint256 _amount,     address _token,     address _strategy ) internal returns (uint256) {     if (_from == address(this)) {         return _savingsAccount.transfer(_amount, _token, _strategy, _to);     } else {         return _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);     } } ```  
# Handle  gzeon   # Vulnerability details  Rewrite the PoolConstants struct as follow can save some gas ```     struct PoolConstants {         uint256 borrowAmountRequested;         uint256 loanStartTime;         uint256 loanWithdrawalDeadline;         uint256 idealCollateralRatio;         uint256 borrowRate;         uint256 noOfRepaymentIntervals;         uint256 repaymentInterval;         address borrower;         address borrowAsset;         address collateralAsset;         address poolSavingsStrategy; // invest contract         address lenderVerifier;     }      ``` https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L46  
# Handle  WatchPug   # Vulnerability details  Check if `_poolStatus` and `block.timestamp` earlier can avoid unnecessary code execution when this check failed.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L310-L348  ```solidity     function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {         LoanStatus _poolStatus = poolVariables.loanStatus;         uint256 _tokensLent = totalSupply();         require(             _poolStatus == LoanStatus.COLLECTION &&                 poolConstants.loanStartTime < block.timestamp &&                 block.timestamp < poolConstants.loanWithdrawalDeadline,             'WBA1'         );         IPoolFactory _poolFactory = IPoolFactory(poolFactory);         require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');          poolVariables.loanStatus = LoanStatus.ACTIVE;         uint256 _currentCollateralRatio = getCurrentCollateralRatio();         require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');          uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;         uint256 _repaymentInterval = poolConstants.repaymentInterval;         IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(             _noOfRepaymentIntervals,             _repaymentInterval,             poolConstants.borrowRate,             poolConstants.loanStartTime,             poolConstants.borrowAsset         );         IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);          address _borrowAsset = poolConstants.borrowAsset;         (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();         uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);         delete poolConstants.loanWithdrawalDeadline;          uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);          SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);         SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);          emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);     } ```  ### Recommendation  Change to:  ```solidity     function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {         LoanStatus _poolStatus = poolVariables.loanStatus;         require(             _poolStatus == LoanStatus.COLLECTION &&                 poolConstants.loanStartTime < block.timestamp &&                 block.timestamp < poolConstants.loanWithdrawalDeadline,             'WBA1'         );         uint256 _tokensLent = totalSupply();         IPoolFactory _poolFactory = IPoolFactory(poolFactory);         require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');          poolVariables.loanStatus = LoanStatus.ACTIVE;         uint256 _currentCollateralRatio = getCurrentCollateralRatio();         require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');          uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;         uint256 _repaymentInterval = poolConstants.repaymentInterval;         IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(             _noOfRepaymentIntervals,             _repaymentInterval,             poolConstants.borrowRate,             poolConstants.loanStartTime,             poolConstants.borrowAsset         );         IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);          address _borrowAsset = poolConstants.borrowAsset;         (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();         uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);         delete poolConstants.loanWithdrawalDeadline;          uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);          SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);         SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);          emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);     } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L379-L383  ```solidity     function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {         require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');         liquidatorRewardFraction = _rewardFraction;         emit LiquidationRewardFractionUpdated(_rewardFraction);     } ```  Can be changed to:  ```solidity     function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {         require(_rewardFraction <= 1e30, 'Fraction has to be less than 1');         liquidatorRewardFraction = _rewardFraction;         emit LiquidationRewardFractionUpdated(_rewardFraction);     } ```  and save some gas from unnecessary arithmetic operation in `10**30`.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  The local variables `_receivedToken` in the functions `SavingsAccount.withdraw` and `SavingsAccount.withdrawFrom` are unused.  Removing them would save gas.  ## Tools used  slither  
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `wethGateway` in `AaveYield#_withdrawETH()`      https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L307-L312  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L78-L83  ```solidity=78{81} function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     uint256 amount = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received);     received = amount; } ```  `received` is not being assigned prior to L81, therefore, at L81, `received` is `0`.  As a result, the `emergencyWithdraw()` does not work, in essence.  ### Recommendation  Change to:  ```solidity=78 function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     received = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L691-L727  ```solidity=691{693-694} function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender; ```  `_borrowableAmount` is unnecessary. The code above can be changed to:  ```solidity=691{693} function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(_amount <= calculateBorrowableAmount(_id), "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender; ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L391-L399  ```solidity=391 function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; } ```  `_interest` is unnecessary.  
# Handle  WatchPug   # Vulnerability details  Given that `Pool` is deployed as a proxied contract, it should use the Upgradeable variant of OpenZeppelin Contracts.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/PoolFactory.sol#L320-L355  ```solidity=320{348} function _createPool(     uint256 _poolSize,     uint256 _borrowRate,     address _borrowToken,     address _collateralToken,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     bytes32 _salt,     address _lenderVerifier ) internal {     bytes memory data = _encodePoolInitCall(         _poolSize,         _borrowRate,         _borrowToken,         _collateralToken,         _idealCollateralRatio,         _repaymentInterval,         _noOfRepaymentIntervals,         _poolSavingsStrategy,         _collateralAmount,         _transferFromSavingsAccount,         _lenderVerifier     );     bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));     bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));     uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;      address pool = _deploy(amount, salt, bytecode);      poolRegistry[pool] = true;     emit PoolCreated(pool, msg.sender); } ```  Otherwise, the constructor functions of `Pool`'s parent contracts which may change storage at deploy time, won't work for deployed instances.  The effect may be different for different OpenZeppelin libraries.  Take `ReentrancyGuard` for example, the code inside `ReentrancyGuard.sol#constructor` won't work, should use `ReentrancyGuardUpgradeable.sol` instead:  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L6-L8  ```solidity=6{6} import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L24-L24  ```solidity=24 contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard { ```  ### Recommendation  Change to:  ```solidity=6{6} import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; ```  ```solidity=24 contract Pool is Initializable, ReentrancyGuardUpgradeable, ERC20PausableUpgradeable, IPool { ```  ```solidity=133{164} function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ReentrancyGuard_init();     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} } ```  
# Handle  WatchPug   # Vulnerability details  Having a consistent naming style in the project leads to fewer errors.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Proxy.sol#L6-L6  ```solidity=6 contract SublimeProxy is TransparentUpgradeableProxy { ```  The filename `Proxy.sol` should be `SublimeProxy.sol`.  
# Handle  defsec   # Vulnerability details  ## Impact  Setter functions for critical contract parameters accessible only by privileged roles e.g. admin should consider adding timelocks (along with emitted events) so that users and other privileged roles can detect upcoming changes and have the time to react to them.  Changes to whitelists, oracle addresses and migrator address may have a financial or trust impact on users who should be given an opportunity to react to them by exiting/engaging without being surprised when such changes are made effective immediately.  See similar Medium-severity finding in ConsenSys's Audit of 1inch Liquidity Protocol (https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing)    ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L189  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L203  2. The functions are responsible for the price oracles. Therefore, If the price oracle is set to wrong. All price feeds will be affected by this.   ## Tools Used  None  ## Recommended Mitigation Steps  Consider adding timelocks to such contracts with critical setter functions.    
# Handle  defsec   # Vulnerability details  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.   """ https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/YearnYield.sol#L42  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/CompoundYield.sol#L43  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/AaveYield.sol#L71  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/NoYield.sol#L31  """   ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  
# Handle  Jujic   # Vulnerability details  ## Impact There doesn't seem to be a use case for the existence of the `receive()` function. In fact, I will recommend removing it as it will prevent accidental native token transfers to the contract.  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L481  ## Tools Used VSC ## Recommended Mitigation Steps https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L481  
# Handle  sirhashalot   # Vulnerability details  ## Impact  There are 3 instances where the `IERC20.approve()` function is called only once without setting the allowance to zero. Some tokens, like USDT, require first reducing the address' allowance to zero by calling `approve(_spender, 0)`. Transactions will revert when using an unsupported token like USDT (see the `approve()` function requirement [at line 199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)).  ## Proof of Concept  - [CreditLine/CreditLine.sol:647](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L647) - [CreditLine/CreditLine.sol:779](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L779) - [yield/AaveYield.sol:324](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L324)  Note: the usage of `approve()` in yield/CompoundYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/CompoundYield.sol#L211-L212)), in yield/YearnYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/YearnYield.sol#L210-L211)), and in yield/AaveYield.sol ([lines 297-298](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L297-L298)) do not need modification since it they already use the recommended approach. Additionally the usage of `approve()` in [yield/AaveYield.sol:307](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L307) likely does not need modification since that approve function only handles ETH.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Use `approve(_spender, 0)` to set the allowance to zero immediately before each of the existing `approve()` calls.  
# Handle  harleythedog   # Vulnerability details  ## Impact It is intended that if a credit line has autoLiquidation as false, then only the lender can be the liquidator (see docs here: https://docs.sublime.finance/sublime-docs/smart-contracts/creditlines). However, this is not correctly implemented, and anyone can liquidate a position that has autoLiquidation set to false.   Even worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens (determined by `_borrowTokensToLiquidate`) that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, so this represents a huge loss to the lender. Since the lender will lose all of the collateral that they are owed, this is a high severity issue.  ## Proof of Concept The current implementation of liquidate is here: https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L996.  Notice that the autoLiquidation value is only used in one place within this function, which is in this segment of the code: ``` ...  if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {   uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);   if (_borrowAsset == address(0)) {    uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');    if (_returnETH != 0) {     (bool success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'Transfer fail');    }   } else {   IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);   }  }    _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);   emit  CreditLineLiquidated(_id, msg.sender); } ```  So, if `autoLiquidation` is false, the code inside of the if statement will simply not be executed, and there are no further checks that the sender HAS to be the lender if `autoLiquidation` is false. This means that anyone can liquidate a non-autoLiquidation credit line, and receive all of the collateral without first transferring the necessary borrow tokens.  For a further proof of concept, consider the test file here: https://github.com/code-423n4/2021-12-sublime/blob/main/test/CreditLines/2.spec.ts. If the code on line 238 is changed from `let  _autoLiquidation: boolean  =  true;` to `let  _autoLiquidation: boolean  =  false;`, all the test cases will still pass. This confirms the issue, as the final test case "Liquidate credit line" has the `admin` as the liquidator, which should not work in non-autoLiquidations since they are not the lender.   ## Tools Used Inspection and confirmed with Hardhat.  ## Recommended Mitigation Steps Add the following require statement somewhere in the `liquidate` function:  ``` require(  creditLineConstants[_id].autoLiquidation ||   msg.sender == creditLineConstants[_id].lender,  "not autoLiquidation and not lender"); ```  
# Handle  robee   # Vulnerability details   The following contracts have a function that allows them an admin to change it to a different address. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked. It is important to have two steps admin change where the first is announcing a pending new admin and the new address should then claim its ownership.  A similar issue was reported in a previous contest and was assigned a severity of medium: [code-423n4/2021-06-realitycards-findings#105](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105)           ILendingPoolAddressesProvider.sol         IUniswapV3Factory.sol         Controller.sol         Strategy.sol         yVault.sol  
# Handle  Jujic   # Vulnerability details  ## Impact Using the safeMath to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.   ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L461  ``` if (_maxPossible > _currentDebt) {             return _maxPossible.sub(_currentDebt); ```  ## Tools Used  ## Recommended Mitigation Steps Consider using: ``` if (_maxPossible > _currentDebt) {             return _maxPossible - _currentDebt; ```  
# Handle  hyh   # Vulnerability details  ## Impact  Funds that are acquired from a liquidator and should be sent to a lender are left with the contract instead. The funds aren't lost, but after the fact mitigation will require manual accounting and fund transfer for each CreditLine.liquidate usage.  ## Proof of Concept  ETH sent to CreditLine.liquidate by an external liquidator when `autoLiquidation` is enabled remain with the contract and aren't transferred to the lender: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L1015  ## Recommended Mitigation Steps  Add transfer to a lender for ETH case:  Now: ``` if (_borrowAsset == address(0)) {   uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');   if (_returnETH != 0) {     (bool success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'Transfer fail');   } } ```  To be: ``` if (_borrowAsset == address(0)) {   uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');      (bool success, ) = _lender.call{value: _borrowTokens}('');   require(success, 'liquidate: Transfer failed');      if (_returnETH != 0) {     (success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'liquidate: Return transfer failed');   } } ```  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The public `calculateInterest` function in CreditLine.sol is missing a @param comment for the `_timeElapsed` parameter. This parameter is obviously important and the units should be clearly stated as seconds.  ## Proof of Concept  The `calculateInterest` function in CreditLine.sol: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L385-L395   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the following line to the `calculateInterest` function comments in CreditLine.sol: `* @param _timeElapsed Seconds elapsed since lastPrincipalUpdateTime`  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `updateProtocolFeeFraction` function in CreditLine.sol does not validate the value submitted. Fee fractions of 0%, 100%, or 200% are equally valid. A maximum fee value check is recommended and a similar check is used in `_updateLiquidatorRewardFraction` in CreditLine.sol to set a maximum liquidator fraction. However, if the assumption is that the owner is trusted and does not make mistakes, this may not be considered a problem.   ## Proof of Concept  The `updateProtocolFeeFraction` function calls `_updateProtocolFeeFraction` in CreditLine.sol: https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L335-L338   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Apply a maximum fee hard cap with a require statement to make sure the fee does not exceed a certain limit, whether by admin error or theoretical malicious overtake of the contract  
# Handle  sirhashalot   # Vulnerability details  ## Impact  There are many instances of the value 30, usually used for exponents of base 10. Currently this integer value is used directly without a clear indication that this value relates to the decimals value, which could lead to one of these values being modified but not the other (perhaps by a typo), which is the basis for many past hacks. Coding best practices suggests using a constant integer to store this value in a way that clearly explains the purpose of this value to prevent confusion.  ## Proof of Concept The magic number 30 is found in dozens of places, including:  Pool/Repayments.sol https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Repayments.sol#L164-L165  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Repayments.sol#L190  PriceOracle.sol file https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/PriceOracle.sol#L130-L131  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/PriceOracle.sol#L88-L93   ## Tools Used  Manual review  ## Recommended Mitigation Steps  Replace the magic number 30 with a variable explaining the meaning of this value, such as: `uint8 private constant DECIMALS_EXPONENT = 30;`  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Weird naming ## Proof of Concept  Credit lines have an "ideal collateral ratio" which acts very much like a minimum collateral ratio, i.e. if you fall below it you can be liquidated.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1002  "Ideal" to me implies that you'll be hovering around that value sometimes drifting above and sometimes below but the systems drives the value back to the ideal so this is quite confusingly named imo.  ## Recommended Mitigation Steps  Change `idealCollateralRatio` to `minCollateralRatio`  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L600-L604  ``` (msg.sender == creditLineConstants[_id].borrower && _requestByLender) || (msg.sender == creditLineConstants[_id].lender && !_requestByLender) ```  is equivalent to   ``` _requestByLender ? (msg.sender == creditLineConstants[_id].borrower) : (msg.sender == creditLineConstants[_id].lender) ``` or ``` msg.sender == (_requestByLender ? creditLineConstants[_id].borrower : creditLineConstants[_id].lender) ```  Which avoid loading the borrower address in the case where the borrower made the request.  ## Recommended Mitigation Steps  Use simplified logic  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Possible confusion  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L326-L368  Compare this to the standard ERC20 versions.  ``` approve(address spender, uint256 amount)  vs   approve(uint256 amount, address token, address to)  ```  Having the amount at the beginning is very odd imo and I'd expect it at the end.  ## Recommended Mitigation Steps  Change `approve(uint256 amount, address token, address to)` to `approve(address token, address to, uint256 amount)` and similar for other functions.  I'd also change `to` to the standard `spender` but this is nbd.     
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs on linking/unlinking addresses  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L10-L13  The activation timestamp can be restricted to a `uint64` variable so that it shares a slot with the `masterAddress`. This will save an SSTORE and a substantial amount of gas.  ## Recommended Mitigation Steps  As above.  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Inability to set a sensible range which covers all borrow assets without being overly wide.  ## Proof of Concept  `PoolFactory` has a set requirement that created pool must ask to borrow an amount of assets which are within a certain range as encoded in the `poolSizeLimit`.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/PoolFactory.sol#L286  This doesn't take into account the relative values of each borrow asset so it's hard to choose a one-size-fits-all value for these limits (A 100 WBTC loan could be sensible but a 100 USDC loan will be dwarfs by the gas costs to deploy the pool.)  ## Recommended Mitigation Steps  Place limits on the USD value of the borrowed amount as reported by the factory's price oracle.  
# Handle  TomFrenchBlockchain   # Vulnerability details  Typo in "cancelled"  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L545  
# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L322-L340  In `Pool.withdrawBorrowedAmount` we set the loan to active and delete the withdrawal deadline (see link).  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L802  When checking whether we can liquidate the pool we check that the loan is active and that `block.timestamp > poolConstants.loanWithdrawalDeadline`. This second condition always resolves true as `poolConstants.loanWithdrawalDeadline = 0` after deletion. We can then save an SLOAD by skipping this second check.  ## Recommended Mitigation Steps  As above.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function repayPrincipal() calls _repay() with MAX_INT as parameter. In _repay() this value (_amount) is multiplied by 10**30. As _amount already has the maximum value of an int256 it will overflow. Because solidity 7.6.0 is used and mul() isn't used (!) this actually works. The resulting value is still large and thus the function repayPrincipal() does still work.  It is not recommended to rely on overflow working and when moving to solidity 0.8.x this will no longer work.  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L23  ```JS     uint256 constant MAX_INT = 2**256 - 1; ```  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L377-L425  ```JS      function repayPrincipal(address payable _poolID) external payable nonReentrant isPoolInitialized(_poolID) {         ....         uint256 _interestToRepay = _repay(_poolID, MAX_INT, true);         ...   function _repay( ... uint256 _amount,..) internal returns (uint256) { ..         _amount = _amount * 10**30;     ```  ## Tools Used  ## Recommended Mitigation Steps Use safemath in _replay() and change MAX_INT to something like: ```JS uint256 constant LARGE_INT = 2**128 ``` Note: 10**30 ~ 2**100  
# Handle  gpersoon   # Vulnerability details  ## Impact The function transferTokens of SavingsAccountUtil.sol sends the excess ETH to msg.sender, while a _from parameter is also present in the function. It seems more logical to send it to _from, like the similar function _transferTokens of Repayments.sol  Luckily in the current code the _from is always msg.sender so it doesn't pose a direct risk. However if the code is reused or forked it might lead to unexpected issues.  Note: transferTokens and _transferTokens are very similar so they could be integrated; they have to be checked carefully when doing this  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccountUtil.sol#L98-L127 ```JS function transferTokens(.... ,   address _from,   address _to ) {      ...        (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}(''); // uses msg.sender instead of _from // also uses - instead of sub  ```  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L457-L473 ```JS     function _transferTokens(  address _from,  address _to,.... ) {        (bool refundSuccess, ) = payable(_from).call{value: msg.value.sub(_amount)}(''); ```  ## Tools Used  ## Recommended Mitigation Steps In function transferTokens() change msg.sender to _from   
# Handle  gpersoon   # Vulnerability details  ## Impact After a master calls unlinkAddress() to unlink an address, the address that has just been unlinked can directly link again without permission. The address that is just unlinked can call linkAddress(masterAddress) which will execute because pendingLinkAddresses is still set. Assuming the master has unlinked for a good reason it is unwanted to be able to be linked again without any permission from the master.  Note: a master can prevent this by calling cancelAddressLinkingRequest(), but this doesn't seem logical to do  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Verification/Verification.sol#L129-L154  ```JS     function unlinkAddress(address _linkedAddress) external {         address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;         require(_linkedTo != address(0), 'V:UA-Address not linked');         require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');         delete linkedAddresses[_linkedAddress];         ... }     function linkAddress(address _masterAddress) external {         require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA-Address already linked');   // == true (after unlinkAddress)         require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA-No pending request');                 // == true (after unlinkAddress)         _linkAddress(msg.sender, _masterAddress);                                                                                           // // pendingLinkAddresses not reset     }  function cancelAddressLinkingRequest(address _linkedAddress) external {         ...          delete pendingLinkAddresses[_linkedAddress][msg.sender]; // only location where pendingLinkAddresses is reset ```  ## Tools Used  ## Recommended Mitigation Steps Add something like to following at the end of linkAddress: ```JS  delete pendingLinkAddresses[msg.sender][_masterAddress];  ```  
# Handle  leastwood   # Vulnerability details  ## Impact  The `emergencyWithdraw` function is implemented in all yield sources to allow the `onlyOwner` role to drain the contract's balance in case of emergency. The contract considers ETH as a zero address asset. However, there is a call made on `_asset` which will revert if it is the zero address. As a result, ETH tokens can never be withdrawn from the `NoYield` contract in the event of an emergency.  ## Proof of Concept  Consider the case where `_asset == address(0)`. An external call is made to check the contract's token balance for the target `_asset`. However, this call will revert as `_asset` is the zero address. As a result, the `onlyOwner` role will never be able to withdraw ETH tokens during an emergency.  ``` function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     uint256 amount = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received);     received = amount; } ```  Affected function as per below: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/yield/NoYield.sol#L78-L83  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider handling the case where `_asset` is the zero address, i.e. the asset to be withdrawn under emergency is the ETH token.  
# Handle  0xngndev   # Vulnerability details  ### Impact  Some of your contracts are quite large byte-wise and require the optimizer with low runs to not reach the code size limit of 24576 bytes. The code size of these contracts can be drastically reduced by shortening the length of your error messages, reducing their deployment cost.  The best example of contracts having unnecessary long erorr messages are `CreditLine.sol` and `PoolFactory.sol`. When it comes to factories, whose primary goal is to deploy contracts, reducing the cost  of doing so is something to keep in mind.  ### Mitigation Steps  Reduce the length of your error strings. Error messages like:  `'PoolFactory::createPool - Repayment interval not within limits'`  Could be reduced to:  `Interval out of limits`  You could save even more by doing something similar to what Uniswap does. They have very short error messages like: `ST`, and they expand on what they mean in their documentation.  Another approach is to use revert with CustomErrors, something like this:  `if (....) revert CustomError()`  Following the example I used above, you could have a custom error message that says:  `OutOfBounds()` and expand what it means in the natspec.  Custom error messages are cheaper than strings error messages. Here's a snippet of Solidity's documentation about this:  > Using a**custom****error**instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs. >  
# Handle  0xngndev   # Vulnerability details  ## Impact  In `AaveYield.sol` the functions:  - `liquidityToken` - `_withdrawETH` - `_depositETH`  Make a conditional call to `IWETHGateway(wethGateway).getAWETHAddress()`  This function does not exist in the `wethGateway` contract, causing these function to fail with the error `"Fallback not allowed"`.  The function they should be calling is `getWethAddress()` without the "A".  Small yet dangerous typo.  ### Mitigation Steps  Simply modify:   `IWETHGateway(wethGateway).getAWETHAddress()`  to:  `IWETHGateway(wethGateway).getWETHAddress()`  In the functions mentioned above.  
# Handle  0xngndev   # Vulnerability details  ### Impact  Reduce code size and gas expenditure by inlining internal functions that are only used once throughout your contract.  In some of your contracts, like `AaveYield.sol`, you have an `initialize` function that calls the internal functions `updateSavingsAccount` and `updateAaveAddresses`. These two functions are only called in the `initialize` function, so you can save some gas and code size by simply inlining their logic inside `initialize`. **The tradeoff, of course, is that you lose readability, and because `initialize` will only be called once, perhaps it's not worth the tradeoff.**  To test the difference in code size and gas expenditure I wrote a example contract replicating the behaviour to see how much cheaper inlining the logic was.  **The results:**  Inlining the logic:  - Gas spent: 45155 - Code size: 453 bytes  Separating into internal functions:  - Gas spent: 45189 - Code size: 467 bytes  ### Proof of Concept  Contracts I used to test the gas expenditure and code size differences:  - InliningLogic  ```bash //SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.10;  contract InliningLogic {   address public someRandomAddress;   address public anotherRandomAddress;    function assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) public {     someRandomAddress = _someRandomAddress;     anotherRandomAddress = _anotherRandomAddress;   } } ```  - InliningLogic.t > DappTools test file  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import "ds-test/test.sol"; import "../InliningLogic.sol";  contract InliningLogicTest is DSTest {   InliningLogic inliningLogicContract;    function setUp() public {     inliningLogicContract = new InliningLogic();   }    function testInliningLogic() public logs_gas {     inliningLogicContract.assignAddresses(address(0x1), address(0x1));   } } ```  - NotInliningLogic  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  contract NotInliningLogic {   address public someRandomAddress;   address public anotherRandomAddress;    function assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) public {     _assignAddresses(_someRandomAddress, _anotherRandomAddress);   }    function _assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) internal {     someRandomAddress = _someRandomAddress;     anotherRandomAddress = _anotherRandomAddress;   } } ```  - NotInliningLogic.t > test file  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import "ds-test/test.sol"; import "../NotInliningLogic.sol";  contract NotInliningLogicTest is DSTest {   NotInliningLogic notInliningLogicContract;    function setUp() public {     notInliningLogicContract = new NotInliningLogic();   }    function testNotInliningLogic() public logs_gas {     notInliningLogicContract.assignAddresses(address(0x1), address(0x1));   } } ```  ### Tools  DappTools  
# Handle  sirhashalot   # Vulnerability details  ## Impact  uint256 variable are initialized to a default value of zero per Solidity docs: https://docs.soliditylang.org/en/latest/control-structures.html#default-value   Setting a variable to the default value is unnecessary. Removing lines of code where variables are initialized to zero can save gas. Here are a few articles describing this gas optimization: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#53bd  https://medium.com/coinmonks/gas-optimization-in-solidity-part-i-variables-9d5775e43dde#4135   ## Proof of Concept  - contracts/Pool/Pool.sol:358 https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L358  - contracts/CreditLine/CreditLine.sol:812 https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L812   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Instead of initializing a variable to zero, such as `uint256 abc = 0;`, the line can be shortened to `uint256 abc;` as Solidity automatically initializes uint variables to zero.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The method initializeRepayment inside the contract Repayments has multipe storage access, it's better to get a pointer of the `RepaymentConstants` with the `storage` keyword in order to avoid seeking and storage access.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use storage keyword in order to save gas  
# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: CreditLine.sol, _index, 484         change to prefix increment and unchecked: CreditLine.sol, _index, 661         change to prefix increment and unchecked: CreditLine.sol, _index, 735         change to prefix increment and unchecked: CreditLine.sol, index, 888         change to prefix increment and unchecked: CreditLine.sol, index, 955         change to prefix increment and unchecked: SavingsAccount.sol, i, 286         change to prefix increment and unchecked: SavingsAccount.sol, i, 464    
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept  It's possible to optimize the struct CreditLineConstants from CreditLine contract, the last 4 fields spend 3 storage slots, moving the boolean values between the address values, it will spend only two slots as follows:  ```struct CreditLineConstants {         address lender;         address borrower;         uint256 borrowLimit;         uint256 idealCollateralRatio;         uint256 borrowRate;         address borrowAsset;         bool autoLiquidation;         address collateralAsset;         bool requestByLender;     }```.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Reorder the structs fields  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept In the method updateStrategy and removeStrategy of StrategyRegistry contract, when the contract want to remove a strategy, the old one, it's set to false, instead of use delete, this will remaing the storage space and it has expensive than use delete.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use delete instead of set to `false`  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The method addStrategy inside StrategyRegistry do a require with safe math: `require(strategies.length.add(1) <= maxStrategies, "StrategyRegistry::addStrategy - Can't add more strategies");` is not possible to has a map that could lead in an integer overflow, so remove this `add` and use a regular +  will safe gas.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove safe math in this call  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept In the contract `StrategyRegistry` the method `initialize` execute a require in order to check that the `_maxStrategies` is different than 0, this check will be done later inside the method `_updateMaxStrategies`, so it's duplicated and can be removed.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove the _maxStrategies checks inside the initialize method.  
# Handle  sirhashalot   # Vulnerability details  The OpenZeppelin ERC20 `safeApprove()` function has been deprecated, as seen in the comments of the OpenZeppelin code.  ## Impact Detailed description of the impact of this finding.  Using this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in OZ [issue #2219](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219).  ## Proof of Concept  The deprecated function is found in: - SavingsAccount/SavingsAccount.sol [line 173](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccount.sol#L173) - SavingsAccount/SavingsAccountUtil.sol [line 61](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccountUtil.sol#L61) - mocks/yVault/yVault.sol [line 164](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/mocks/yVault/yVault.sol#L164) - mocks/yVault/Controller.sol [line 196 and 197](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/mocks/yVault/Controller.sol#L196)   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  As suggested by the OpenZeppelin comment, replace `safeApprove()` with `safeIncreaseAllowance()` or `safeDecreaseAllowance()` instead.  
