# Handle  gzeon   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L61 ```     return (       maltDataLab.maltPriceAverage(priceLookback) > priceTarget * (10000 - thresholdBps) / 10000,       "The price of Malt is below peg. Wait for peg to be regained or purchase arbitrage tokens."     ); ``` when the condition is true (which should be the majority of time), the reason string is unnecessary. Only return the string when the condition is false.  
# Handle  Koustre   # Vulnerability details  ## Impact In UniswapHandler, in the function ```removeBuyer``` there is a for loop over an unbounded Buyers array, which if the buyers array gets too large can cause a denial of service and prevents the contract from being able to remove buyer roles from users/contracts. This would allow users/contracts to circumvent recovery mode and to continue to purchase and sell tokens using the contract.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used - Manual Study ## Recommended Mitigation Steps - remove unbounded for loop  
# Handle  harleythedog   # Vulnerability details  ## Impact In ForfeitHandler.sol, there are two values `swingTraderRewardCut ` and `treasuryRewardCut `, and these values always sum to 1000. Instead of having to go through all of the logic of setting these values independently and always ensuring that they sum to 1000, it would be simpler (and definitely save a lot of gas) if you simply removed everything related to `treasuryRewardCut` and always just used `1000-swingTraderRewardCut` in its place.  This also is more similar to what is done in StabilizerNode.sol where `treasuryCut` is simply what is left over after other components have taken their cut.  ## Proof of Concept See ForfeitHandler.sol here: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ForfeitHandler.sol  ## Tools Used Inspection  ## Recommended Mitigation Steps Simplify logic and save gas by removing `treasuryRewardCut`.  
# Handle  harleythedog   # Vulnerability details  ## Impact In UniswapHandler.sol within the `removeBuyer` function, there is a statement on line 308: ``` address buyer; ```  This variable is not used at all in the rest of the function, so this statement can be removed to save gas.  ## Proof of Concept See statement here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L308  ## Tools Used Inspection  ## Recommended Mitigation Steps Remove unnecessary line to save gas  
# Handle  gzeon   # Vulnerability details  ## Impact When malt is under-peg and the swing trader module do not have enough capital to buy back to peg, a Dutch auction is triggered to sell arb token. The price of the Dutch auction decrease linearly toward endprice until _endAuction() is called. https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L589  _endAuction() is called in   1. When auction.commitments >= auction.maxCommitments https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L212  2. On stabilize() -> checkAuctionFinalization() -> _checkAuctionFinalization() https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L146 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754  3. On stabilize() ->_startAuction() -> triggerAuction() -> _checkAuctionFinalization() https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L170 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754  It is possible manipulate the dutch auction by preventing _endAuction() being called.  ## Proof of Concept Consider someone call purchaseArbitrageTokens with auction.maxCommitments minus 1 wei, `_endAuction` won't be called because auction.commitments < auction.maxCommitments. Further purchase would revert because `purchaseAndBurn` (https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L184) would likely revert since swapping 1 wei in most AMM will fail due to rounding error. Even if it does not revert, there is no incentive to waste gas to purchase 1 wei of token.  As such, the only way for the auction to finalize is to call stabilize().  However, this is not immediately possible because it require  `block.timestamp >= stabilizeWindowEnd` where `stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod` stabilizeBackoffPeriod is initially set to 5 minutes in the contract  After 5 minute, stabilize() can be called by anyone. By using this exploit, an attacker can guarantee he can purchase at (startingPrice+endingPrice)/2 or lower, given the default 10 minute auctionLength and 5 minute stabilizeBackoffPeriod. (unless a privileged user call stabilize() which override the stability window)  Also note that stabilize() might not be called since there is no incentive.  ## Recommended Mitigation Steps 1. Incentivize stabilize() or incentivize a permission-less call to _endAuction() 2. Lock-in auction price when user commit purchase  
# Handle  leastwood   # Vulnerability details  ## Impact  `MaltDataLab` integrates several `MovingAverage` contracts to fetch sensitive data for the Malt protocol. Primary data used by the protocol consists of the real value for LP tokens, the average price for Malt and average reserve ratios. `trackMaltPrice`, `trackPoolReserves` and `trackPool` are called by a restricted role denoted as the `UPDATER_ROLE` and represented by an EOA account and not another contract. Hence, the EOA account must consistently update the aforementioned functions to ensure the most up-to-date values. However, miners can censor calls to `MaltDataLab` and effectively extract value from other areas of the protocol which use stale values.  ## Proof of Concept  Consider the following attack vector: - The price of Malt exceeds the lower bound threshold and hence `stabilize` can be called by any user. - The `_stabilityWindowOverride` function is satisfied, hence the function will execute. - The state variable, `exchangeRate`, queries `maltPriceAverage` which may use an outdated exchange rate. - `_startAuction` is executed which rewards `msg.sender` with 100 Malt as an incentive for triggering an auction. - As the price is not subsequently updated, a malicious attacker could collude with a miner to censor further pool updates and continue calling `stabilize` on every `fastAveragePeriod` interval to extract incentive payments. - If the payments exceed what the `UPDATER_ROLE` is willing to pay to call `trackMaltPrice`, a user is able to sustain this attack.  This threatens the overall stability of the protocol and should be properly handled to prevent such attacks. However, the fact that `MaltDataLab` uses a series of spot price data points to calculate the `MovingAverage` also creates an area of concern as well-funded actors could still manipulate the `MovingAverage` contract by sandwiching calls to `trackMaltPrice`, `trackPool` and `trackPoolReserves`.  `trackMaltPrice`, `trackPool`, and `trackPoolReserves` should be added to the following areas of the code where applicable. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L159 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L173 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L177 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L881 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L710 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L190 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L105  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding calls to `trackMaltPrice`, `trackPoolReserves` and `trackPool` wherever the values are impacted by the protocol. This should ensure the protocol is tracking the most up-to-date values. Assuming the cumulative values are used in the `MovingAverage` contracts, then sensitive calls utilising `MaltDataLab` should be protected from flashloan attacks. However, currently this is not the case, rather `MovingAverage` consists of a series of spot price data points which can be manipulated by well-funded actors or via a flashloan. Therefore, there needs to be necessary changes made to `MaltDataLab` to use cumulative price updates as its moving average instead of spot price.  
# Handle  stonesandtrees   # Vulnerability details  ## Impact All of the `rewardToken` in a given AMM pool can be removed from the AMM pool and distributed as LP rewards.  ## Proof of Concept In the `stabilize` method in the `StabilizerNode` the initial check to see if the Malt price needs to be stabilized it uses a short period TWAP: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156  However, if the price is above the threshold for stabilization then the trade size required to stabilize looks at the AMM pool directly which is vulnerable to flashloan manipulation.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L250-L275  Attack: 1. Wait for TWAP to rise above the stabilization threshold 2. Flashloan remove all but a tiny amount of Malt from the pool. 3. Call `stabilize`. This will pass the TWAP check and execute `_distributeSupply` which in turn ultimately calls `_calculateTradeSize` in the `UniswapHandler`. This calculation will determine that almost all of the `rewardToken` needs to be removed from the pool to return the price to peg.  4. Malt will mint enough Malt to remove a lot of the `rewardToken` from the pool. 5. The protocol will now distribute that received `rewardToken` as rewards. 0.3% of which goes directly to the attacker and the rest goes to LP rewards, swing trader and the treasury.  The amount of money that can be directly stolen by a malicious actor is small but it can cause a lot of pain for the protocol as the pool will be destroyed and confusion around rewards will be created.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use a short TWAP to calculate the trade size instead of reading directly from the pool.  
# Handle  pauliax   # Vulnerability details  ## Impact Consider caching decimals when initializing malt and collateralToken to avoid repeated external calls, as they are not supposed to change unless initialized again: ```solidity   uint256 maltDecimals = malt.decimals();   uint256 decimals = collateralToken.decimals(); ```   
# Handle  hyh   # Vulnerability details  ## Impact  BONDING_ROLE cannot be managed after it was initialized.  ## Proof of Concept  ```setBonding``` set the wrong role via _swapRole:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L116  ## Recommended Mitigation Steps  Set ```BONDING_ROLE``` instead of ```REINVESTOR_ROLE``` in ```setBonding``` function:  Now: ``` function setBonding(address _bonding)  public  onlyRole(ADMIN_ROLE, "Must have admin privs") {  require(_bonding != address(0), "Cannot use address 0");  _swapRole(_bonding, bonding, REINVESTOR_ROLE);  bonding = _bonding; } ```  To be: ``` function setBonding(address _bonding)  public  onlyRole(ADMIN_ROLE, "Must have admin privs") {  require(_bonding != address(0), "Cannot use address 0");  _swapRole(_bonding, bonding, BONDING_ROLE);  bonding = _bonding; } ```  
# Handle  pauliax   # Vulnerability details  ## Impact contract PoolTransferVerification sets thresholdBps but in calculations uses only ```(10000 - thresholdBps)```. Consider pre-calculating to avoid re-evaluation again and again when this function is invoked.  
# Handle  pauliax   # Vulnerability details  ## Impact Function purchaseArbitrageTokens should validate that amount > 0, otherwise it may be possible to spam accountCommitmentEpochs with 0 amounts: ```solidity   if (auction.accountCommitments[msg.sender].commitment == 0) {     accountCommitmentEpochs[msg.sender].push(currentAuctionId);   } ```  ## Recommended Mitigation Steps require amount > 0  
# Handle  pauliax   # Vulnerability details  ## Impact There are several loops in the contract which can eventually grow so large as to make future operations of the contract cost too much gas to fit in a block, e.g.: ```solidity   for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) // function outstandingArbTokens()   while (true) // function allocateArbRewards ```  ## Recommended Mitigation Steps Consider introducing a reasonable upper limit based on block gas limits. Also, you can consider using EnumerableSet (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol) where possible, e.g. 'buyers' or 'verifierList'.  
# Handle  pauliax   # Vulnerability details  ## Impact I think this if check is incorrect, because in theory maxAmount parameter can be greater than totalMaltBalance: ```solidity     if (rewards <= deployedCapital && maxAmount != totalMaltBalance) {       // If all malt is spent we want to reset deployed capital       deployedCapital = deployedCapital - rewards;     } else {       deployedCapital = 0;     } ```  ## Recommended Mitigation Steps If my assumption is correct, the check should use balance, not maxAmount: ``solidity   balance != totalMaltBalance ``` Another possible solution: ``solidity   maxAmount <= totalMaltBalance ``` However, I think the best approach would be to eliminate 'balance' altogether: ```solidity   uint256 totalMaltBalance = malt.balanceOf(address(this));    if (totalMaltBalance == 0) {     return 0;   }    (uint256 basis,) = costBasis();    if (maxAmount > totalMaltBalance) {     maxAmount = totalMaltBalance;   }    malt.safeTransfer(address(dexHandler), maxAmount);   uint256 rewards = dexHandler.sellMalt();    if (rewards <= deployedCapital && maxAmount < totalMaltBalance) {     // If all malt is spent we want to reset deployed capital     deployedCapital = deployedCapital - rewards;   } else {     deployedCapital = 0;   }   ```  
# Handle  pauliax   # Vulnerability details  ## Impact These checks should be inclusive: ```solidity        require(amountOut > minOut, "EarlyExit: Insufficient output");   require(_bps > 0 && _bps < 1000, "Must be between 0-100%");   require(newThreshold > 0 && newThreshold < 10000, "Threshold must be between 0-100%");   require(_distance > 0 && _distance < 1000, "Override must be between 0-100%"); ```  ## Recommended Mitigation Steps Replace > with >= and < with <= where necesseary.  
# Handle  hyh   # Vulnerability details  ## Impact  A condition requires that calculated retrievable amount shouldn't be too big. If it is the function fails and the remaining portion of commitment is frozen.  As the amount is calculated by the system a user cannot do anything to retrieve remaining part of commitment, if any.  ## Proof of Concept  ```claimArbitrage``` fails if calculated redemption is higher than remaining commitment: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L230  ```userClaimableArbTokens``` calculated amount can be bigger than remaining user funds: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L279  ## Recommended Mitigation Steps  If the freezing of remainder amount is not intentional then substitute require with ceiling the amount to be retrieved with the remaining part.  Now: ``` require(redemption <= remaining.add(1), "Cannot claim more tokens than available"); ```  To be: ``` if (redemption > remaining) {  redemption = remaining; } ```   
# Handle  pauliax   # Vulnerability details  ## Impact When auction.endingTime == now, function purchaseArbitrageTokens thinks that auction is still active, while isAuctionFinished and earlyExitReturn think that it has ended: purchaseArbitrageTokens: ```solidity   require(auction.endingTime >= now, "Auction is already over"); ``` isAuctionFinished: ```solidity   return auction.endingTime > 0 && (now >= auction.endingTime || ...); ``` earlyExitReturn: ```solidity   if(active || block.timestamp < auctionEndTime) {     return 0;   } ```  ## Recommended Mitigation Steps Consider unifying it across the functions.  
# Handle  pauliax   # Vulnerability details  ## Impact In functions transferAndCall and transferWithPermit the condition should be AND, not OR: ```solidity   require(to != address(0) || to != address(this)); ```  ## Recommended Mitigation Steps ```solidity   require(to != address(0) && to != address(this)); ```   
# Handle  pauliax   # Vulnerability details  ## Impact The variable DOMAIN_SEPARATOR in contract ERC20Permit is assigned in the constructor and will not change after being initialized. However, if a hard fork happens after the contract deployment, the domain would become invalid on one of the forked chains due to the block.chainid has changed.  Also, you don't need an assmebly to retrieve chainid, you can get it from a built in variable block.chainid.  Similar issues were reported in a previous contest and were assigned a severity of low:  https://github.com/code-423n4/2021-06-realitycards-findings/issues/166  https://github.com/code-423n4/2021-09-swivel-findings/issues/98  ## Recommended Mitigation Steps An elegant solution that you may consider applying is from Sushi Trident: https://github.com/sushiswap/trident/blob/concentrated/contracts/pool/concentrated/TridentNFT.sol#L47-L62  
# Handle  pauliax   # Vulnerability details  ## Impact Inaccurate revert messages: ```solidity           _delay >= 0 && _delay < gracePeriod,   "Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod"    require(startEpoch < endEpoch, "Start cannot be before the end");   require(rewardAmount <= rewardEarned, "< earned");   require(bondedBalance > 0, "< bonded balance");   require(amount <= bondedBalance, "< bonded balance"); ```   
# Handle  ScopeLift   # Vulnerability details  ## Impact  Inside `provideReinvest` and `_bondAccount` gas can be saved by using the standard transfer method on the Malt token, since we know its implementation is correct and will return true/false.  ## Proof of Concept  N/A  ## Tools Used  N/A  ## Recommended Mitigation Steps  Replace `malt.safeTransfer(address(dexHandler), balance);` with something like:  ```solidity require(malt.transfer(address(dexHandler), balance), 'malt transfer failed'); ```   
# Handle  ScopeLift   # Vulnerability details  ## Impact  The internal `_withdraw` method does not follow the checks-effects-interactions pattern. A malicious token, or one that implemented transfer hooks, could re-enter the public calling function (such as `withdraw()`) before proper internal accounting was completed. Because the `earned` function looks up the `_userWithdrawn` mapping, which is not yet updated when the transfer occurs, it would be possible for a malicious contract to re-enter `_withdraw` repeatedly and drain the pool.  ## Proof of Concept  N/A  ## Tools Used  N/A  ## Recommended Mitigation Steps  The internal accounting should be done before the transfer occurs:  ```solidity function _withdraw(address account, uint256 amountReward, address to) internal {     _userWithdrawn[account] += amountReward;     _globalWithdrawn += amountReward;f     rewardToken.safeTransfer(to, amountReward);      emit Withdraw(account, amountReward, to);   } ```   
# Handle  ScopeLift   # Vulnerability details  ## Impact  There are four functions that can have stricter function mutability declarations. Using a stricter declaration can help the compiler save gas when it knows whether reads and writes will occur in a function  ## Proof of Concept  N/A  ## Tools Used  solc  ## Recommended Mitigation Steps  Implement the changes suggested by the Solidity compiler. For examples like `AbstractTransferVerification`, the solidity compiler is wrong because it doesn't know you plan to override this function declaration. Instead, `AbstractTransferVerification` could be an interface without a function definition  ``` contracts/AbstractTransferVerification.sol:9:3: Warning: Function state mutability can be restricted to pure   function verifyTransfer(address from, address to, uint256 amount) public view virtual returns (bool, string memory) {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/AuctionEscapeHatch.sol:168:3: Warning: Function state mutability can be restricted to view   function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/AuctionParticipant.sol:127:3: Warning: Function state mutability can be restricted to pure   function _handleRewardDistribution(uint256 rewarded) virtual internal {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/MaltDataLab.sol:202:3: Warning: Function state mutability can be restricted to pure   function _normalizedPrice(   ^ (Relevant source part starts here and spans across multiple lines). ```  
# Handle  ScopeLift   # Vulnerability details  ## Impact  On lines 85 and 101, ETH is transferred using a `.call` to an address provided as an input, but there is no verification that the call call succeeded. This can result in a call to `emergencyWithdrawGAS` or `partialWithdrawGAS` appearing successful but in reality it failed. This can happen when the provided `destination` address is a contract that cannot receive ETH, or if the `amount` provided is larger than the contract's balance  ## Proof of Concept  Enter the following in remix, deploy the `Receiver` contract, and send 1 ETH when deploying the `Permissions` contract. Call `emergencyWithdrawGAS` with the receiver address and you'll see it reverts. This would not be caught in the current code  ```solidity pragma solidity ^0.8.0;  contract Receivier{}  contract Permissions {     constructor() payable {}      function emergencyWithdrawGAS(address payable destination) external {         (bool ok, ) = destination.call{value: address(this).balance}('');         require(ok, "call failed");     } } ```  ## Tools Used  Remix  ## Recommended Mitigation Steps  In `emergencyWithdrawGAS`:  ```diff - destination.call{value: address(this).balance}(''); + (bool ok, ) = destination.call{value: address(this).balance}(''); + require(ok, "call failed"); ```  And similar for `partialWithdrawGAS`  
# Handle  ScopeLift   # Vulnerability details  ## Estimated risk level Gas Optimization  ## Impact Instantiating an array of length n is better than `push(0)`  n times and saves 20k gas in tests.  ## Proof of Concept  ## Tools Used   ## Recommended Mitigation Steps change the initializer  ```diff ## Saves ~20,000 gas on initialize  diff --git a/src/contracts/AuctionBurnReserveSkew.sol b/src/contracts/AuctionBurnReserveSkew.sol index 4ed6fa6..87d5959 100644 --- a/src/contracts/AuctionBurnReserveSkew.sol +++ b/src/contracts/AuctionBurnReserveSkew.sol @@ -51,9 +51,7 @@ contract AuctionBurnReserveSkew is Initializable, Permissions {      auction = IAuction(_auction);      auctionAverageLookback = _period;   -    for (uint i = 0; i < _period; i++) { -      pegObservations.push(0); -    } +    pegObservations = new uint256[](_period);    }      function consult(uint256 excess) public view returns (uint256) { ```  
# Handle  gzeon   # Vulnerability details  ## Impact One of the innovative feature of Malt is to block buying while under peg. The buy block can be bypassed by swapping to the whitelisted UniswapHandler, and then extract the token by abusing the add and remove liquidity function. This is considered a high severity issue because it undermine to protocol's ability to generate profit by the privileged role as designed and allow potential risk-free MEV.  ## Proof of Concept 1) User swap dai into malt and send malt directly to uniswapHandler, this is possible becuase uniswapHandler is whitelisted `swapExactTokensForTokens(amountDai, 0, [dai.address, malt.address], uniswapHandler.address, new Date().getTime() + 10000);` 2) User send matching amount of dai to uniswapHandler 3) User call addLiquidity() and get back LP token 4) User call removeLiquidity() and get back both dai and malt  ## Recommended Mitigation Steps According to documentation in https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol > Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode. , this should be exploitable. Meanwhile the current implementation did not actually allow remove liquidity during recovery mode (refer to issue "Unable to remove liquidity in Recovery Mode") This exploit can be mitigated by disabling addLiquidity() when the protocol is in recovery mode  
# Handle  gzeon   # Vulnerability details  ## Impact According to https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol > When the Malt price TWAP drops below a specified threshold (eg 2% below peg) then the protocol will revert any transaction that tries to remove Malt from the AMM pool (ie buying Malt or removing liquidity). Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode.  However, in https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L236 liquidity removed is directly sent to msg.sender, which would revert if it is not whitelisted https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L53  ## Recommended Mitigation Steps Liquidity should be removed to UniswapHandler contract, then the proceed is sent to msg.sender  
# Handle  WatchPug   # Vulnerability details  Based on the context, `maltDataLab.trackReserveRatio()` should be called once a market buy/sell is made.  However, in `_distributeSupply()` when `swingAmount >= tradeSize`, after a market sell, the function returned without `maltDataLab.trackReserveRatio()`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L145-L174  ```solidity=145{168,170,172}   function stabilize() external notSameBlock {     auction.checkAuctionFinalization();      require(       block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),       "Can't call stabilize"     );     stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;      rewardThrottle.checkRewardUnderflow();      uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);      if (!_shouldAdjustSupply(exchangeRate)) {       maltDataLab.trackReserveRatio();        lastStabilize = block.timestamp;       return;     }      emit Stabilize(block.timestamp, exchangeRate);      if (exchangeRate > maltDataLab.priceTarget()) {       _distributeSupply();     } else {       _startAuction();     }      lastStabilize = block.timestamp;   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L211-L246  ```solidity=211{228-230,244}   function _distributeSupply() internal {     if (supplyDistributionController != address(0)) {       bool success = ISupplyDistributionController(supplyDistributionController).check();       if (!success) {         return;       }     }      uint256 priceTarget = maltDataLab.priceTarget();     uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);      if (tradeSize == 0) {       return;     }      uint256 swingAmount = swingTrader.sellMalt(tradeSize); // @Auditor: At this time, a market operation occurred, affecting the reserveRatio      if (swingAmount >= tradeSize) {       return;     }      tradeSize = tradeSize - swingAmount;      malt.mint(address(dexHandler), tradeSize);     emit MintMalt(tradeSize);     uint256 rewards = dexHandler.sellMalt();      auctionBurnReserveSkew.addAbovePegObservation(tradeSize);      uint256 remaining = _replenishLiquidityExtension(rewards);      _distributeRewards(remaining);      maltDataLab.trackReserveRatio();     impliedCollateralService.claim();   } ```  ### Recommendation  Consider moving `maltDataLab.trackReserveRatio()` from `_distributeSupply()`, `_startAuction()` to `stabilize()` before L173.  
# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L135-L141  ```solidity=135   function _notSameBlock() internal {     require(       block.number > lastBlock[_msgSender()],       "Can't carry out actions in the same block"     );     lastBlock[_msgSender()] = block.number;   } ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L223-L223 ```solidity=223 require(!auction.active, "Cannot claim tokens on an active auction"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L230-L230 ```solidity=230 require(redemption <= remaining.add(1), "Cannot claim more tokens than available"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L659-L659 ```solidity=659 require(auction.startingTime > 0, "No auction available for the given id"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L177-L177 ```solidity=177 require(!active, "Cannot exit early on an active auction"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L136-L136 ```solidity=136 require(_index > replenishingIndex, "Cannot replenishingIndex to old value"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L56-L56 ```solidity=56 require(block.timestamp >= getEpochStartTime(epoch + 1), "Cannot advance epoch until start of new epoch"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L81-L81 ```solidity=81 require(balance >= value, "ERC20Permit: transfer amount exceeds balance"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L122-L122 ```solidity=122 require(balance >= value, "ERC20Permit: transfer amount exceeds balance"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Malt.sol#L65-L65 ```solidity=65 require(_service != address(0), "Cannot use address 0 as transfer service"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L412-L412 ```solidity=412 require(_sampleLength > 0, "Cannot have 0 second sample length"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L154-L154 ```solidity=154 require(forfeited <= _globals.declaredBalance, "Cannot forfeit more than declared"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L275-L275 ```solidity=275 require(amount <= _globals.declaredBalance, "Can't decrement more than total reward balance"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L118-L121 ```solidity=118     require(       eta >= block.timestamp.add(delay),       "Timelock::queueTransaction: Estimated execution block must satisfy delay."     ); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L165-L176 ```solidity=165     require(       queuedTransactions[txHash],       "Timelock::executeTransaction: Transaction hasn't been queued."     );     require(       block.timestamp >= eta,       "Timelock::executeTransaction: Transaction hasn't surpassed time lock."     );     require(       block.timestamp <= eta.add(gracePeriod),       "Timelock::executeTransaction: Transaction is stale."     ); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L195-L198 ```solidity=195     require(       success,       "Timelock::executeTransaction: Transaction execution reverted."     ); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L114-L132  ```solidity=114 function unbondAndBreak(uint256 amount)     external   {     require(amount > 0, "Cannot unbond 0");      uint256 bondedBalance = balanceOfBonded(msg.sender);      require(bondedBalance > 0, "< bonded balance");     require(amount <= bondedBalance, "< bonded balance");      // Avoid leaving dust behind     if (amount.add(1e16) > bondedBalance) {       amount = bondedBalance;     }      miningService.onUnbond(msg.sender, amount);      _unbondAndBreak(amount);   } ```  L121, the check of `bondedBalance > 0` is unnecessary, since the L122 already included the same check.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L118-L127  ```solidity=118{121-122, 124}   function transferAndCall(address to, uint value, bytes calldata data) external returns (bool) {     require(to != address(0) || to != address(this));      uint256 balance = balanceOf(msg.sender);     require(balance >= value, "ERC20Permit: transfer amount exceeds balance");      _transfer(msg.sender, to, value);      return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);   } ```  L121-L122, the check of `balance >= value` is unnecessary, since the L124 already included the same check.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L424-L442  ```solidity=424   function setSampleMemory(uint256 _sampleMemory)     external     onlyRole(ADMIN_ROLE, "Must have admin privs")   {     require(_sampleMemory > 0, "Cannot have sample memroy of 0");      if (_sampleMemory > sampleMemory) {       for (uint i = sampleMemory; i < _sampleMemory; i++) {         samples.push();       }       counter = counter % _sampleMemory;     } else {       activeSamples = _sampleMemory;        // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST     }      sampleMemory = _sampleMemory;   } ```  In the current implementation, when `sampleMemory` is updated, the samples index will be malposition, making `getValueWithLookback()` get the wrong samples, so that returns the wrong value.  ## PoC  -  When initial sampleMemory is `10` -  After `movingAverage.update(1e18)` being called for 120 times -  The admin calls `movingAverage.setSampleMemory(118)` and set sampleMemory to `118`  The current `movingAverage.getValueWithLookback(sampleLength * 10)` returns `0.00000203312 e18`, while it's expeceted to be `1e18`  After `setSampleMemory()`, `getValueWithLookback()` may also return `0`or revert FullMath: FULLDIV_OVERFLOW at L134.  ### Recommendation  Consider removing `setSampleMemory` function.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L136-L141  ```solidity if (profit > 0) {     uint256 lpCut = profit.mul(lpProfitCut).div(1000);      collateralToken.safeTransfer(address(rewardThrottle), lpCut);     rewardThrottle.handleReward();   } ```  Given that `lpProfitCut` can be `0`, checking if `lpProfitCut > 0` can avoid unnecessary code execution (including external calls) and save some gas.  
# Handle  WatchPug   # Vulnerability details  Checking `uint256` variables >= 0 is redundant as they always >= 0.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L169-L172  ```solidity function setLpProfitCut(uint256 _profitCut) public onlyRole(ADMIN_ROLE, "Must have admin privs") {     require(_profitCut >= 0 && _profitCut <= 1000, "Must be between 0 and 100%");     lpProfitCut = _profitCut;     } ```  `_profitCut >= 0` at L170.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77  ```solidity function setDelay(uint256 _delay)     public     onlyRole(GOVERNOR_ROLE, "Must have timelock role")   {     require(       _delay >= 0 && _delay < gracePeriod,       "Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod"     );     delay = _delay;      emit NewDelay(delay);   } ```  `_delay >= 0` at L71.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L238-L242  ```solidity=238     if (amountTokens > unclaimedArbTokens) {       unclaimedArbTokens = 0;     } else {       unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);     } ```  `unclaimedArbTokens - amountTokens` will never underflow.  ### Recommendation  Change to:  ```solidity=238     if (amountTokens >= unclaimedArbTokens) {       unclaimedArbTokens = 0;     } else {       unclaimedArbTokens -= amountTokens;     } ```    https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L76-L80  ```solidity=76 if (premiumExcess > maxBurnSpend) {   return premiumExcess; }  uint256 usableExcess = maxBurnSpend.sub(premiumExcess); ```  `maxBurnSpend - premiumExcess` will never underflow.  ### Recommendation  Change to:  ```solidity=76 if (premiumExcess > maxBurnSpend) {   return premiumExcess; }  uint256 usableExcess = maxBurnSpend - premiumExcess; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L69-L89  ```solidity=69{76,82-84}   function getRealBurnBudget(     uint256 maxBurnSpend,     uint256 premiumExcess   ) public view returns(uint256) {     // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement     // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn      if (premiumExcess > maxBurnSpend) {       return premiumExcess;     }      uint256 usableExcess = maxBurnSpend.sub(premiumExcess);      if (usableExcess == 0) {       return premiumExcess;     }      uint256 burnable = consult(usableExcess);      return premiumExcess + burnable;   } ```  L82-84 `if (maxBurnSpend == premiumExcess)` can be combined with L76-78.  ### Recommendation  Change to:  ```solidity=69{76}   function getRealBurnBudget(     uint256 maxBurnSpend,     uint256 premiumExcess   ) public view returns(uint256) {     // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement     // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn      if (premiumExcess >= maxBurnSpend) {       return premiumExcess;     }      uint256 usableExcess = maxBurnSpend.sub(premiumExcess);      uint256 burnable = consult(usableExcess);      return premiumExcess + burnable;   } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L131-L140  ```solidity=131     uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;     if (progressionBps > 10000) {         progressionBps = 10000;     }      if (fullReturn > amount) {         // Allow a % of profit to be realised         uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;         return amount + maxProfit;     } ```  If we assume that `maxEarlyExitBps` is 200 and `cooloffPeriod` is 1 day, when `progressionBps` less than 50, `(maxEarlyExitBps * progressionBps / 10000)` will be 0 due to precision loss, which resulted in `maxProfit` is 0.  When `maxEarlyExitBps` is set smaller, the margin of error will be even larger.  # POC  Given:  - Current price of arb token is 0.8 DAI  1. Alice calls `purchaseArbitrageTokens()` and purchase with 8,000 DAI; 2. 7 mins later, the market price of MALT become 0.9 DAI; Alice calls `exitEarly()`, it will mint 8,888.88 Malt and receive 8,000 DAI, while it's expected to 8,890 MALT and 8,000.96 DAI.  ### Recommendation  Change to:  ```solidity if (fullReturn > amount) {     // Allow a % of profit to be realised     uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * 1000 * progressionBps / 10000) / 1000 / 1000;     return amount + maxProfit; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132  ```solidity=116   function getPegDeltaFrequency() public view returns (uint256) {     uint256 initialIndex = 0;     uint256 index;      if (count > auctionAverageLookback) {       initialIndex = count - auctionAverageLookback;     }      uint256 total = 0;      for (uint256 i = initialIndex; i < count; ++i) {       index = _getIndexOfObservation(i);       total = total + pegObservations[index];     }      return total * 10000 / auctionAverageLookback;   } ```  ### Recommendation  Change to:  ```solidity=116   function getPegDeltaFrequency() public view returns (uint256) {     uint256 availablePegObservationsCount;     {       uint256 auctionAverageLookback_ = auctionAverageLookback;       uint256 count_ = count;       availablePegObservationsCount = count_ > auctionAverageLookback_ ? auctionAverageLookback_ : count_;     }      uint256 total = 0;     for (uint256 i = 0; i < availablePegObservationsCount; ++i) {       total += pegObservations[i];     }     return total * 10000 / availablePegObservationsCount;   } ```  
# Handle  WatchPug   # Vulnerability details  Using `++i` is more gas efficient than `i++`, especially in a loop.  For example:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L54-L56 ```solidity=54 for (uint i = 0; i < _period; i++) {   pegObservations.push(0); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L193-L195 ```solidity=193 for (uint i = auctionAverageLookback; i < _lookback; i++) {   pegObservations.push(0); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L60-L62 ```solidity=60 for (uint i = 0; i < sampleMemory; i++) {   samples.push(); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L187-L195  ```solidity=187 for (uint256 i = 0; i < sampleMemory; i++ ) {   tempCount += 1;   liveSample = samples[_getIndexOfSample(tempCount)];   liveSample.timestamp = currentTimestamp;   liveSample.cumulativeValue = currentCumulative;    currentCumulative += addition;   currentTimestamp += uint64(sampleLength); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L292-L300 ```solidity=292 for (uint256 i = 0; i < sampleMemory; i++ ) {   tempCount += 1;   liveSample = samples[_getIndexOfSample(tempCount)];   liveSample.timestamp = currentTimestamp;   liveSample.cumulativeValue = currentCumulative;    currentCumulative += addition;   currentTimestamp += uint64(sampleLength); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L431-L433 ```solidity=431 for (uint i = sampleMemory; i < _sampleMemory; i++) {   samples.push(); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/libraries/UniswapV2Library.sol#L66-L69 ```solidity=66 for (uint i; i < path.length - 1; i++) {     (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);     amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132  ```solidity=116{131}   function getPegDeltaFrequency() public view returns (uint256) {     uint256 initialIndex = 0;     uint256 index;      if (count > auctionAverageLookback) {       initialIndex = count - auctionAverageLookback;     }      uint256 total = 0;      for (uint256 i = initialIndex; i < count; ++i) {       index = _getIndexOfObservation(i);       total = total + pegObservations[index];     }      return total * 10000 / auctionAverageLookback;   } ```  When `count < auctionAverageLookback`, at L131, it should be `return total * 10000 / count;`. The current implementation will return a smaller value than expected.  The result of `getPegDeltaFrequency()` will be used for calculating `realBurnBudget` for auctions. With the result of `getPegDeltaFrequency()` being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.  
# Handle  WatchPug   # Vulnerability details  The default `upperStabilityThreshold` and `lowerStabilityThreshold` assumes that `rewardToken.decimals()` is 18.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L32-L33  ```solidity=32   uint256 public upperStabilityThreshold = (10**18) / 100; // 1%   uint256 public lowerStabilityThreshold = (10**18) / 100; ```  When the `StabilizerNode.sol` contract is initialized with a rewardToken with decimals of 8 (eg. USDC). `upperThreshold` and `lowerThreshold` will be much larger than expected.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L198-L206 ```solidity   function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {     uint256 decimals = rewardToken.decimals();     uint256 priceTarget = maltDataLab.priceTarget();      uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals); ```  ### Recommendation  Consider changing to:  ```solidity   uint256 public upperStabilityThresholdBps = 100; // 1%   uint256 public lowerStabilityThresholdBps = 100; ```  ```solidity   function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {     uint256 decimals = rewardToken.decimals();     uint256 priceTarget = maltDataLab.priceTarget();      uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10000);     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10000); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardReinvestor.sol#L62-L76  ```solidity=62 function provideReinvest(uint256 rewardLiquidity) external {     _retrieveReward(rewardLiquidity);      uint256 rewardBalance = rewardToken.balanceOf(address(this));      // This is how much malt is required     uint256 maltLiquidity = dexHandler.getOptimalLiquidity(address(malt), address(rewardToken), rewardBalance);      // Transfer the remaining Malt required     malt.safeTransferFrom(msg.sender, address(this), maltLiquidity);      _bondAccount(msg.sender);      emit ProvideReinvest(msg.sender, rewardLiquidity);   } ```  `_retrieveReward` will call `MiningService.sol#withdrawRewardsForAccount()` which uses `amount` as max withdrawnAmount, if there are no enough rewards, the actual rewarded amount will be less than `amount`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MiningService.sol#L155-L179  ```solidity=155 function withdrawRewardsForAccount(address account, uint256 amount)     public     onlyRole(REINVESTOR_ROLE, "Must have reinvestor privs")   {     _withdrawMultiple(account, amount);   }    /*    * INTERNAL FUNCTIONS    */   function _withdrawMultiple(address account, uint256 amount) internal {     for (uint i = 0; i < mines.length; i = i + 1) {       if (!mineActive[mines[i]]) {         continue;       }        uint256 withdrawnAmount = IRewardMine(mines[i]).withdrawForAccount(account, amount, msg.sender);        amount = amount.sub(withdrawnAmount);        if (amount == 0) {         break;       }     }   } ```  ### Recommendation  Consider using `rewardBalance` as the value of the `reward` parameter.  
# Handle  0x0x0x   # Vulnerability details  ## Concept  In `MovingAverage.sol`, `uint64` is used for computation of time etc. But computations with `uint64` does cost more gas and furthermore `block.timestamp` is `uint256`, which is additionally casted to `uint64`. `uint32` is used for indexes, but this can also be changed with `uint256`.  Same applies for `RewardDistributer.sol.`  ## Recommendation  Use `uint256` rather than custom `uint`.  
# Handle  0x0x0x   # Vulnerability details  ## Concept  [https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L200-L212](https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L200-L212):  ```   uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;     if (progressionBps > 10000) {       progressionBps = 10000;     }      if (fullReturn > amount) {       // Allow a % of profit to be realised       uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;       uint256 desiredReturn = amount + maxProfit;       maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;     }       return maltQuantity; ```  `progressionBps` is only used, if there is a profit. Calculations of this parameter should be under if statement checking whether there is a profit to save gas and increase readability as follows:  ```      if (fullReturn > amount) {       // Allow a % of profit to be realised    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;      if (progressionBps > 10000) {        progressionBps = 10000;      }       uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;       uint256 desiredReturn = amount + maxProfit;       maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;     }       return maltQuantity; ```  
# Handle  WatchPug   # Vulnerability details  Unused storage variables in contracts use up storage slots and increase contract size and gas usage at deployment and initialization.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L57-L57 ```solidity=57 address public uniswapV2Factory; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L80-L86  ```solidity=80 function emergencyWithdrawGAS(address payable destination)     external      onlyRole(TIMELOCK_ROLE, "Only timelock can assign roles")   {     // Transfers the entire balance of the Gas token to destination     destination.call{value: address(this).balance}('');   } ```  The error message "Only timelock can assign roles" can be changed to "Only timelock can emergencyWithdrawGAS".  Other examples include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L104-L110  ```solidity=104 function partialWithdraw(address _token, address destination, uint256 amount)     external      onlyRole(TIMELOCK_ROLE, "Only timelock can assign roles")   {     ERC20 token = ERC20(_token);     token.safeTransfer(destination, amount);   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L94-L94  ```solidity=94 require(_pool != address(0), "Cannot have 0 lookback"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L230-L230  ```solidity=230 require(_period > 0, "Cannot have 0 lookback period"); ```  
# Handle  0x0x0x   # Vulnerability details  ## Impact  In case the reward token is changed, `totalDeclaredReward` will be changed and likely equal to `0`.  Since `_userStakePadding` and `_globalStakePadding` are accumulated, changing the reward token will not reset those values. Thus, it will create problems.  ## Recommendation  I think it would be the best to remove this function.   If you want to keep it, then it must have an event and it should be used by a timelock contract. Furthermore, it has to be used carefully and the new token should be distributed such that padding variables still make sense.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L112-L116  ```solidity=112   function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool) {     _approve(msg.sender, spender, value);      return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);   } ```  ```solidity=208 function _transfer(address sender, address recipient, uint256 amount) internal virtual {     require(sender != address(0), "ERC20: transfer from the zero address");     require(recipient != address(0), "ERC20: transfer to the zero address");      _beforeTokenTransfer(sender, recipient, amount);      _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");     _balances[recipient] = _balances[recipient].add(amount);     emit Transfer(sender, recipient, amount); } ```  Using approve() to manage allowances opens yourself and users of the token up to frontrunning. Best practice, but doesn't usually matter.  [Explanation](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit) of this possible attack vector  See also: [0xProject/0x-monorepo#850](https://github.com/0xProject/0x-monorepo/issues/850)  Using increase/decreaseAllowance instead is recommended.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L154-L154  ```solidity=154 uint64 blockTimestamp = uint64(block.timestamp % 2**64);  ```  Use `uint64(n)` can cut off higher-order bits already, `n % 2**64` is redundant.  See: https://docs.soliditylang.org/en/v0.8.10/types.html#explicit-conversions  ### Recommendation  Change to:  ```solidity=154 uint64 blockTimestamp = uint64(block.timestamp);  ```  
# Handle  0x0x0x   # Vulnerability details  ## Impact  `!= 0` is a cheaper operation compared to `> 0`, when dealing with `uint`.  ## Occurences  ```  ./AbstractRewardMine.sol:147:    if (rewardDenominator > 0) { ./Auction.sol:219:    require(amountTokens > 0, "No claimable Arb tokens"); ./Auction.sol:265:    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments); ./Auction.sol:385:    return auction.startingTime > 0; ./Auction.sol:639:    if (realBurnBudget > 0) { ./Auction.sol:659:    require(auction.startingTime > 0, "No auction available for the given id"); ./Auction.sol:663:    if (auction.maltPurchased > 0) { ./Auction.sol:861:          if (auction.commitments > 0 || !auction.finalized) { ./Auction.sol:894:    require(_length > 0, "Length must be larger than 0"); ./Auction.sol:972:    require(_split > 0 && _split <= 10000, "Must be between 0-100%"); ./Auction.sol:980:    require(_maxEnd > 0 && _maxEnd <= 1000, "Must be between 0-100%"); ./Auction.sol:988:    require(_lookback > 0, "Must be above 0"); ./Auction.sol:996:    require(_lookback > 0, "Must be above 0"); ./Auction.sol:1004:    require(_bps > 0 && _bps < 1000, "Must be between 0-100%"); ./Auction.sol:1012:    require(_threshold > 0, "Must be between greater than 0"); ./AuctionBurnReserveSkew.sol:109:    if (aggregate.maxCommitments > 0) { ./AuctionBurnReserveSkew.sol:190:    require(_lookback > 0, "Cannot have zero lookback period"); ./AuctionEscapeHatch.sol:191:    require(amount > 0, "Nothing to claim"); ./AuctionEscapeHatch.sol:222:    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, "Must be between 0-100%"); ./AuctionEscapeHatch.sol:230:    require(_period > 0, "Cannot have 0 lookback period"); ./AuctionPool.sol:118:    if (globalRewarded > 0 && userReward > 0) { ./AuctionPool.sol:125:    if (forfeitAmount > 0) { ./AuctionPool.sol:129:    if (declaredRewardDecrease > 0) { ./AuctionPool.sol:141:    if (forfeitedRewards > 0) { ./Bonding.sol:87:    require(amount > 0, "Cannot bond 0"); ./Bonding.sol:97:    require(amount > 0, "Cannot unbond 0"); ./Bonding.sol:101:    require(bondedBalance > 0, "< bonded balance"); ./Bonding.sol:117:    require(amount > 0, "Cannot unbond 0"); ./Bonding.sol:121:    require(bondedBalance > 0, "< bonded balance"); ./Bonding.sol:283:      if (diff > 0) { ./DAO.sol:47:    if (offeringMint > 0) { ./DAO.sol:78:    require(amount > 0, "Cannot have zero amount"); ./DAO.sol:94:    require(_length > 0, "Cannot have zero length epochs"); ./ERC20VestedMine.sol:93:    if (globalRewarded > 0 && userReward > 0) { ./ERC20VestedMine.sol:115:    if (forfeitReward > 0) { ./ERC20VestedMine.sol:119:    if (declaredRewardDecrease > 0) { ./ForfeitHandler.sol:49:    if (swingTraderCut > 0) { ./ForfeitHandler.sol:53:    if (treasuryCut > 0) { ./ImpliedCollateralService.sol:64:    if (maxAmount > 0) { ./ImpliedCollateralService.sol:68:    if (maxAmount > 0) { ./ImpliedCollateralService.sol:71:      // if (maxAmount > 0) { ./ImpliedCollateralService.sol:74:      //   if (maxAmount > 0) { ./LiquidityExtension.sol:161:    require(_ratio > 0 && _ratio <= 100, "Must be between 0 and 100"); ./MaltDataLab.sol:234:    require(_price > 0, "Cannot have 0 price"); ./MaltDataLab.sol:242:    require(_lookback > 0, "Cannot have 0 lookback"); ./MaltDataLab.sol:250:    require(_lookback > 0, "Cannot have 0 lookback"); ./MaltDataLab.sol:258:    require(_lookback > 0, "Cannot have 0 lookback"); ./MovingAverage.sol:385:    if (oldSample.timestamp > 0 && activeSamples > 1) { ./MovingAverage.sol:412:    require(_sampleLength > 0, "Cannot have 0 second sample length"); ./MovingAverage.sol:428:    require(_sampleMemory > 0, "Cannot have sample memroy of 0"); ./PoolTransferVerification.sol:76:    require(newThreshold > 0 && newThreshold < 10000, "Threshold must be between 0-100%"); ./PoolTransferVerification.sol:85:    require(lookback > 0, "Cannot have 0 lookback"); ./RewardReinvestor.sol:93:    require(rewardLiquidity > 0, "Cannot reinvest 0"); ./RewardReinvestor.sol:115:    if (maltBalance > 0) { ./RewardReinvestor.sol:119:    if (rewardTokenBalance > 0) { ./RewardSystem/RewardDistributor.sol:144:    require(reward > 0, "Cannot declare 0 reward"); ./RewardSystem/RewardDistributor.sol:266:    if (amount > 0) { ./RewardSystem/RewardDistributor.sol:277:    if (amount > 0) { ./RewardSystem/RewardOverflowPool.sol:76:    require(_maxFulfillment > 0, "Can't have 0 max fulfillment"); ./RewardSystem/RewardThrottle.sol:85:    if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) { ./RewardSystem/RewardThrottle.sol:89:      if (remainder > 0) { ./RewardSystem/RewardThrottle.sol:271:          if (underflow > 0) { ./RewardSystem/RewardThrottle.sol:323:    require(_smoothingPeriod > 0, "No zero smoothing period"); ./StabilizerNode.sol:270:    if (callerCut > 0) { ./StabilizerNode.sol:274:    if (auctionPoolCut > 0) { ./StabilizerNode.sol:278:    if (swingTraderCut > 0) { ./StabilizerNode.sol:282:    if (treasuryCut > 0) { ./StabilizerNode.sol:286:    if (daoCut > 0) { ./StabilizerNode.sol:290:    if (lpCut > 0) { ./StabilizerNode.sol:359:    require(_period > 0, "Must be greater than 0"); ./StabilizerNode.sol:406:    require(_incentive > 0, "No negative incentive"); ./StabilizerNode.sol:417:    require(amount > 0, "No negative damping"); ./StabilizerNode.sol:449:    require(_upper > 0 && _lower > 0, "Must be above 0"); ./StabilizerNode.sol:488:    require(_maxContribution > 0 && _maxContribution <= 100, "Must be between 0 and 100"); ./StabilizerNode.sol:552:    require(_period > 0, "Cannot have 0 period"); ./StabilizerNode.sol:561:    require(_distance > 0 && _distance < 1000, "Override must be between 0-100%"); ./StabilizerNode.sol:570:    require(_period > 0, "Cannot have 0 period"); ./SwingTrader.sol:136:    if (profit > 0) { ./libraries/SafeBurnMintableERC20.sol:70:        if (returndata.length > 0) { // Return data is optional ./libraries/UniswapV2Library.sol:37:        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); ./libraries/UniswapV2Library.sol:38:        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:44:        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); ./libraries/UniswapV2Library.sol:45:        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:54:        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); ./libraries/UniswapV2Library.sol:55:        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) {  ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L356-L360  ```solidity=356   function _getCurrentSample() private view returns (Sample storage currentSample) {     // Active sample is always counter - 1. Counter is the in progress sample     uint32 currentSampleIndex = _getIndexOfSample(counter - 1);     currentSample = samples[currentSampleIndex];   } ```  The local variable `currentSampleIndex` is used only once. Making the expression inline can save gas.  Similar issue exists in `_getFirstSample()`, `_getNthSample()`, `AuctionBurnReserveSkew.sol#getRealBurnBudget()`, `MovingAverage.sol#_getFirstSample()`.  ### Recommendation  Change to:  ```solidity=356   function _getCurrentSample() private view returns (Sample storage currentSample) {     // Active sample is always counter - 1. Counter is the in progress sample     currentSample = samples[_getIndexOfSample(counter - 1)];   } ```  
# Handle  0x0x0x   # Vulnerability details  ## Vulnerability  `AuctionEschapeHatch.sol#exitEarly` takes as input `amount` to represent how much of the   When the user exits an auction with profit, to apply the profit penalty less `maltQuantity` is liquidated compared to how much malt token the liquidated amount corresponds to. The problem is `auction.amendAccountParticipation()` simply subtracts the malt quantity with penalty and full `amount` from users auction stats. This causes a major problem, since in `_calculateMaltRequiredForExit` those values are used for calculation by calculating maltQuantity as follow:  `uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);`   The ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking (since penalty is applied to substracted `maltQuantity` from `userMaltPurchased`), by doing so a user can earn more than it should. Since after each profit taking users commitment corresponds to proportionally more malt, the user can even reduce profit penalties by dividing `exitEarly` calls in several calls.  In other words, the ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking and user can claim more malt with less commitment. Furthermore after all `userMaltPurchased` is claimed the user can have `userCommitment` left over, which can be used to `claimArbitrage`, when possible.  ## Mitigation Step  Make sure which values are used for what and update values which doesn't create problems like this. Rethink about how to track values of an auction correctly.  
# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style of function names does not follow the best practices:  - MaltDAO#incrementEpoch()      https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L106-L119  ```solidity=106{107} /* Internal methods */ function incrementEpoch() internal {     epoch = epoch.add(1); }  function _setEpochLength(uint256 length) internal {     epochLength = length;     emit SetEpochLength(length); }  function _setMaltToken(address _malt) internal {     malt = IBurnMintableERC20(_malt);     emit SetMaltToken(_malt); } ```  
# Handle  WatchPug   # Vulnerability details  The purpose of a Timelock contract is to put a limit on the privileges of the `governor`, by forcing a two step process with a preset delay time.  However, we found that the current implementation actually won't serve that purpose as it allows the `governor` to execute any transactions without any constraints.  To do that, the current governor can call `Timelock#setGovernor(address _governor)` and set a new `governor` effective immediately.  And the new `governor` can then call `Timelock#setDelay()` and change the delay to `0`, also effective immediately.  The new `governor` can now use all the privileges without a delay, including granting minter role to any address and mint unlimited amount of MALT.  In conclusion, a Timelock contract is supposed to guard the protocol from lost private key or malicious actions. The current implementation won't fulfill that mission.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L98-L105 ```solidity=98{100,102-103}   function setGovernor(address _governor)     public     onlyRole(GOVERNOR_ROLE, "Must have timelock role")   {     _swapRole(_governor, governor, GOVERNOR_ROLE);     governor = _governor;     emit NewGovernor(_governor);   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77 ```solidity=66{71,74}   function setDelay(uint256 _delay)     public     onlyRole(GOVERNOR_ROLE, "Must have timelock role")   {     require(       _delay >= 0 && _delay < gracePeriod,       "Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod"     );     delay = _delay;      emit NewDelay(delay);   } ```   ## Recommendation  Consider making `setGovernor` and `setDelay` only callable from the Timelock contract itself.  Specificaly, changing from `onlyRole(GOVERNOR_ROLE, "Must have timelock role")` to `require(msg.sender == address(this), "...")`.  Also, consider changing `_adminSetup(_admin)` in `Timelock#initialize()` to `_adminSetup(address(this))`, so that all roles are managed by the timelock itself as well.  
# Handle  cmichel   # Vulnerability details  When adding liquidity through `UniswapHandler.addLiquidity`, the entire contract balances are used to add liquidity and the min amounts are set to 95% of these balances. If the balances in this contract are unbalanced (the ratio is not similar to the current Uniswap pool reserve ratios) then this function will revert and no liquidity is added.  See `UniswapHandler.buyMalt`:  ```solidity (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(   address(malt),   address(rewardToken),   maltBalance, // @audit-info amountADesired   rewardBalance,   // @audit assumes that whatever is in this contract is already balanced. good assumption?   maltBalance.mul(95).div(100), // @audit-info amountAMin   rewardBalance.mul(95).div(100),   msg.sender, // transfer LP tokens to sender   now ); ```  ## Impact If the contract has unbalanced balances, then the `router.addLiquidity` call will revert. Note that an attacker could even send tokens to this contract to make them unbalanced and revert, resulting in a griefing attack.  ## Recommended Mitigation Steps It needs to be ensured that the balances in the contract are always balanced and match the current reserve ratio. It might be better to avoid directly using the balances which can be manipulated by transferring tokens to the contract and accepting parameters instead of how many tokens to provide liquidity with from the caller side.  
# Handle  cmichel   # Vulnerability details  The `UniswapHandler.maltMarketPrice` function returns a tuple of the `price` and the `decimals` of the price. However, the returned `decimals` do not match the computed `price` for the `else if (rewardDecimals < maltDecimals)` branch:  ```solidity else if (rewardDecimals < maltDecimals) {   uint256 diff = maltDecimals - rewardDecimals;   price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);   decimals = maltDecimals; } ```  Note that `rewardReserves` are in reward token decimals, `maltReserves` is a malt balance amount (18 decimals). Then, the returned amount is in `rewardDecimals + diffDecimals + rewardDecimals - maltDecimals = maltDecimals + rewardDecimals - maltDecimals = rewardDecimals`. However `decimals = maltDecimals` is wrongly returned.  ## Impact Callers to this function will receive a price in unexpected decimals and might inflate or deflate the actual amount. Luckily, the `AuctionEscapeHatch` decides to completely ignore the returned `decimals` and as all prices are effectively in `rewardDecimals`, even if stated in `maltDecimals`, it currently does not seem to lead to an issue.  ## Recommendation Fix the function by returning `rewardDecimals` instead of `maltDecimals` in the `rewardDecimals < maltDecimals` branch.  
# Handle  cmichel   # Vulnerability details  The `MovingAverage.sol` contract defines several variables that in the end make the `samples` array act as a ring buffer: - `sampleMemory`: The total length (buffer size) of the `samples` array. `samples` is initialized with `sampleMemory` zero observations. - `counter`: The pending sample index (modulo `sampleMemory`)  The `_getFirstSample` function computes the first sample as `(counter + 1) % sampleMemory` which returns the correct index only _if the ring buffer is full_, i.e., it wraps around. (in the `counter + 1 >= sampleMemory`).  If the `samples` array does not wrap around yet, the zero index should be returned instead.  ## Impact Returning `counter + 1` if `counter + 1 < sampleMemory` returns a zero initialized `samples` observation index. This then leads to a wrong computation of the TWAP.  ## Recommended Mitigation Steps Add an additional check for `if (counter + 1 < sampleMemory) return 0` in `_getFirstSample`.  
# Handle  cmichel   # Vulnerability details  Certain ERC20 tokens make modifications to their ERC20's `transfer` or `balanceOf` functions. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.  ## Impact The `Bonding._bond()` function will revert in the `_balanceCheck` when transferring a fee-on-transfer token as it assumes the entire `amount` was received.  ## Recommended Mitigation Steps To support fee-on-transfer tokens, measure the asset change right before and after the asset-transferring calls and use the difference as the actual bonded amount.  
# Handle  cmichel   # Vulnerability details  The `Permissions.reassignGlobalAdmin` function is supposed to only be run with the `TIMELOCK_ROLE` role, see `onlyRole(TIMELOCK_ROLE, "Only timelock can assign roles")`.  However, the `TIMELOCK_ROLE` is not the admin of all the reassigned roles and the `revokeRole(role, oldAccount)` calls will fail as it requires the `ADMIN_ROLE`.  ## Recommended Mitigation Steps The idea might have been that only the `TIMELOCK` should be able to call this function, and usually it is also an admin, but the function strictly does not work if the caller _only_ has the `TIMELOCK` roll and will revert in this case. Maybe governance decided to remove the admin role from the Timelock, which makes it impossible to call `reassignGlobalAdmin` anymore as both the timelock and admin are locked out.  
# Handle  cmichel   # Vulnerability details  The initial `SetTransferService` event in `Malt.initialize` is not emitted.  ## Impact Off-chain programs might not correctly track the initial `transferService` variable as the initial event is missing.  ## Recommended Mitigation Steps Emit it in `initialize`.  
# Handle  cmichel   # Vulnerability details  The `ERC20.approve()` function returns a boolean value indicating success. This parameter needs to be checked for success. Some tokens do **not** revert if the transfer failed but return `false` instead.  In addition, some tokens (like [USDT L199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ```solidity IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  This issue exists for example in `AuctionParticipant.purchaseArbitrageTokens`:  ```solidity auctionRewardToken.approve(address(auction), balance); ```  As well as in `UniswapHandler.buyMalt`:  ```solidity rewardToken.approve(address(router), rewardBalance); ```  ## Impact Tokens that don't correctly implement the latest EIP20 spec, by either returning `false` on failure or reverting if approved from a non-zero value, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelins `SafeERC20` versions with the `safeApprove(0)` functions that handle the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  The `initialize` function that initializes important contract state can be called by anyone. See: - `ERC20VestedMine.initialize` - `AuctionPool.initialize` - all contracts that extend `Permissions`  ## Impact The attacker can initialize the contract before the legitimate deployer, hoping that the victim continues to use the same contract. In the best case for the victim, they notice it and have to redeploy their contract costing gas.  ## Recommended Mitigation Steps Use the constructor to initialize non-proxied contracts. For initializing proxy contracts deploy contracts using a factory contract that immediately calls `initialize` after deployment or make sure to call it immediately after deployment and verify the transaction succeeded.  
# Handle  WatchPug   # Vulnerability details  It's a best practice for the contract implementations to inherit their interface definition.  Doing so would improve the contract's clarity, and force the implementation to comply with the defined interface.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/TransferService.sol#L14-L14 ```solidity=14 contract TransferService is Initializable, Permissions { ```  `TransferService` should inherit `ITransferService`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L20-L20  ```solidity=20 contract UniswapHandler is Initializable, Permissions { ```  `UniswapHandler` should inherit `IDexHandler`.  
# Handle  harleythedog   # Vulnerability details  ## Impact In Bonding.sol, the internal function `_unbondAndBreak` transfers a user's stake tokens to the dexHandler and then calls `removeLiquidity` on the dexHandler. Within the Uniswap handler (which is the only handler so far) `removeLiquidity` takes special care in the edge case where `router.removeLiquidity` returns zero tokens. Specifically, the Uniswap handler has this code: ``` if (amountMalt == 0 || amountReward == 0) {  liquidityBalance = lpToken.balanceOf(address(this));  lpToken.safeTransfer(msg.sender, liquidityBalance);  return (amountMalt, amountReward); } ```  If this edge case does indeed happen (i.e. if something is preventing the Uniswap router from removing liquidity at the moment), then the Uniswap handler will transfer the LP tokens back to Bonding.sol. However, Bonding.sol does not have any logic to recognize that this happened, so the LP tokens will become stuck in the contract and the user will never get any of their value back. This could be very bad if the user unbonds a lot of LP and they don't get any of it back.  ## Proof of Concept See `_unbondAndBreak` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L226  Notice how the edge case where `amountMalt == 0 || amountReward == 0` is not considered in this function, but it is considered in the Uniswap handler's `removeLiquidity` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L240  ## Tools Used Inspection.  ## Recommended Mitigation Steps Add a similar edge case check to `_unbondAndBreak`. In the case where LP tokens are transferred back to Bonding.sol instead of malt/reward, these LP tokens should be forwarded back to the user since the value is rightfully theirs.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `permit` function is intended to facilitate approvals though signature verification. This helps to merge the two-step token transfer process consisting of an initial token approval and subsequent transfer. The `permit` function emits an `Approval` event, however, the `_approve` function also emits the same `Approval` event. As a result, off-chain scripts monitoring the blockchain for such events will see the same event emitted twice which may cause unintended issues.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ERC20Permit.sol#L58-L59 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L314  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider not emitting an `Approval` event in `permit`.  
# Handle  leastwood   # Vulnerability details  ## Impact  `_distributeRewards` attempts to reward LP token holders when the price of Malt exceeds its price target. Malt Finance is able to being Malt back to its peg by selling Malt and distributing rewards tokens to LP token holders. An external call to `Auction` is made via the `allocateArbRewards` function. Prior to this call, the `StabilizerNode` approves the contract for a fixed amount of tokens, however, the `allocateArbRewards` function does not necessarily utilise this entire amount. Hence, dust token approval amounts may accrue from within the `StabilizerNode` contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L252-L253 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L809-L871  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider resetting the approval amount if the input `rewarded` amount to `allocateArbRewards` is less than the output amount.  
# Handle  leastwood   # Vulnerability details  ## Impact  `addLiquidity` is called when users reinvest their tokens through bonding events. The `RewardReinvestor` first transfers Malt and rewards tokens before adding liquidity to the token pool. `addLiquidity` provides protections against slippage by a margin of 5%, and any dust token amounts are transferred back to the caller. In this instance, the caller is the `RewardReinvestor` contract which further distributes the dust token amounts to the protocol's treasury. However, the token approval for this outcome is not handled properly. Dust approval amounts can accrue over time, leading to large Uniswap approval amounts by the `UniswapHandler` contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L212-L214 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L216-L218  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider resetting the approval amount if either `maltUsed < maltBalance` or `rewardUsed < rewardBalance` in `addLiquidity`.  
# Handle  harleythedog   # Vulnerability details  ## Impact There are several ERC20 tokens that take a small fee on transfers/transferFroms (known as "fee-on-transfer" tokens). Most notably, USDT is an ERC20 token that has togglable transfer fees, but for now the fee is set to 0 (see the contract here: https://etherscan.io/address/0xdAC17F958D2ee523a2206206994597C13D831ec7#code). For these tokens, it should not be assumed that if you transfer `x` tokens to an address, that the address actually receives `x` tokens. In the current test environment, DAI is the only `collateralToken` available, so there are no issues. However, it has been noted that more pools will be added in the future, so special care will need to be taken if fee-on-transfer tokens (like USDT) are planned to be used as `collateralTokens`.  For example, consider the function `purchaseArbitrageTokens` in Auction.sol. This function transfers `realCommitment` amount of `collateralToken` to the liquidityExtension, and then calls `purchaseAndBurn(realCommitment)` on the liquidityExtension. The very first line of `purchaseAndBurn(amount)` is `require(collateralToken.balanceOf(address(this)) >= amount, "Insufficient balance");`. In the case of fee-on-transfer tokens, this line will revert due to the small fee taken. This means that all calls to `purchaseArbitrageTokens` will fail, which would be very bad when the price goes below peg, since no one would be able to participate in this auction.  ## Proof of Concept See `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177  See `purchaseAndBurn` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L117  ## Tools Used Inspection  ## Recommended Mitigation Steps Add logic to transfers/transferFroms to calculate exactly how many tokens were actually sent to a specific address. In the example given with `purchaseArbitrageTokens`, instead of calling `purchaseAndBurn` with `realCommitment`, the contract should use the difference in the liquidityExtension balance after the transfer minus the liquidityExtension  balance before the transfer.  
# Handle  thank_you   # Vulnerability details  ## Impact UniswapHandler utilizes UniswapV2Router to swap, add liquidity, and remove liquidity with the UniswapV2Pair contract. In order to utilize these functionalities, UniswapHandler must call various UniswapV2Router methods.  - addLiquidity - removeLiquidity - swapExactTokensForTokens (swaps for both DAI and Malt)  In all three methods, UniswapV2Router requires the callee to provide input arguments that define how much the amount out minimum UniswapHandler will allow for a trade. This argument is designed to prevent slippage and more importantly, sandwich attacks.  UniswapHandler correctly handles price slippage when calling [addLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L201). However, that is not the case for [removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L230) and swapExactTokensForTokens [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) and [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L173). For both methods, 0 is passed in as the amount out minimum allowed for a trade. This allows for anyone watching the mempool to sandwich attack UniswapHandler (or any contract that calls UniswapHandler) in such a way that allows the hacker to profit off of a guaranteed trade.  How does this work? Let's assume UniswapHandler makes a call to [UniswapV2Router#swapExactTokensForTokens](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) to trade DAI for Malt. Any hacker who watches the mempool and sees this transaction can immediately buy as much Malt as they want. This raises the price of Malt. Since UniswapHandler is willing to accept any amount out minimum (the number is set to [zero](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L150)), then the UniswapHandler will always trade DAI for Malt. This second transaction raises the price of Malt even further. Finally, the hacker trades their Malt for DAI, receiving a profit due to the artificially inflated price of Malt from the sandwich attack.  It's important to note that anyone has access to the UniswapV2Router contract. There are no known ACL controls on UniswapV2Router. This sandwich attack can impact even the `buyMalt` function.  The following functions when called are vulnerable to frontrunning attacks:  - [UniswapHandler#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L131) - [UniswapHandler#sellMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L160) - [UniswapHandler#removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221)  And by extension the following contract functions since they also call the UniswapHandler function calls:  - [Bonding#unbondAndBreak](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L114) - [LiquidityExtension#purchaseAndBurn](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117) - [RewardReinvestor#splitReinvest](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L78) - [StabilizerNode#stabilize](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145) - [SwingTrader#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L50)   ## Proof of Concept Refer to the impact section for affected code and links to the appropriate LoC.  ## Tools Used N/A  ## Recommended Mitigation Steps The UniswapV2Router and UniswapV2Pair contract should allow only the UniswapHandler contract to call either contract. In addition, price slippage checks should be implemented whenever removing liquidity or swapping tokens. This ensures that a frontrunning attack can't occur.   ## Anything Else We Should Know I wish I had more time to work on this bug but unfortunately I have several current clients who require significant time from me. I'm happy to pursue this beyond the initial submission, in particular building a concrete PoC. I think the most important takeaway from this bug find is that anyone can purchase Malt at any time and anyone can manipulate the Malt reserve. This in turn impacts other functionalities that rely on the Malt reserve to make price/token calculations such as exiting an auction early or reinvesting rewards.  
# Handle  0xwags   # Vulnerability details  ## Impact Since users forfeited awards will be shared between either the treasury and the swing trader, there should be a zero address in the initialize() function to ensure rewards are not lost and thereby affecting  Malt's collateralisation and other such funding mechanism.   This will have implications for safetransfer() functions in lines 50 & 54 in handleForfeit().   ## Tools Used Manual Analysis.   ## Recommended Mitigation Steps  require(treasuryMultisig&& swingTrader ! =address(0), "0x0");  
# Handle  leastwood   # Vulnerability details  ## Impact  `_calculateMaltRequiredForExit` in `AuctionEscapeHatch` currently uses Malt's spot price to calculate the quantity to return to the exiting user. This spot price simply tracks the Uniswap pool's reserves which can easily be manipulated via a flash loan attack to extract funds from the protocol.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L65-L92 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L193 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L80-L109 https://shouldiusespotpriceasmyoracle.com/  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing/integrating a TWAP oracle to track the price of Malt.  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Reuse the function argument in the event emit instead of the storage variable. This saves a SLOAD.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L82   ## Tools Used  ## Recommended Mitigation Steps - L76 write: emit NewDelay(_delay); - L92: write: emit NewGracePeriod(_gracePeriod);  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Move the initialization of sampleDiff below the if block to save gas in the case of return of the if block.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L128  ## Tools Used  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact move the sampleDiff (L86) below the if statement L88 to save the declaration/initialization of sampleDiff in the case the if block gets executed and the function returns early  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L86 ## Tools Used  ## Recommended Mitigation Steps - move the declaration/initialization of of sampleDiff below the if statement  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Reuse _sampleMemory instead of the storage variable sampleMemory in the condition statement of the loop to save gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L60 ## Tools Used  ## Recommended Mitigation Steps - rewrite L60 as: for (uint i = 0; i < _sampleMemory ; i++)  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L167  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L219  Before call _distributeSupply function, it already get priceTarget, But in _distributeSupply, it again call external call to get price target. This will use higher gas.   ## Tools Used Manual  ## Recommended Mitigation Steps Send price target in _distributeSupply() function argument, and please review all duplicated external calls and optimize them.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact In removeVerifier function, it loop until last index - 1 to find source index. If you added many verifiers, then the gas cost of removeVerifier will be very high, and it can be reverted due to gas limit as well.   ## Tools Used Manual  ## Recommended Mitigation Steps Store index of address in addVerifier function, and remove loop in removeVerifier, and use stored index.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L62 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L78  In addVerifier and removeVerifier functions of TransferService.sol, it just returns instead of revert if it is unable to change data. Revert transaction to avoid creating unnecessary transaction and save transaction cost.   ## Tools Used Manual  ## Recommended Mitigation Steps Revert transaction instead of return.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function bondToAccount() of Bonding.sol has a check based on _notSameBlock()  _notSameBlock() makes sure the same msg.sender cannot do 2 actions within the same block.  However this can be circumvented in this case: Suppose you call bondToAccount() via a (custom) smart contract, then the msg.sender will be the address of the smart contract. For a pseudo code proof of concept see below.  I'm not sure what the deeper reason is for the _notSameBlock() in bondToAccount(). But if it is important then circumventing this check it will pose a risk.  ## Proof of Concept call function attack1.attack() ```JS contract attack1 {    function attack(address account, uint256 amount) {          call attack2.forward(account, amount);          call any other function of malt   } }  contract attack2 {    function forward(address account, uint256 amount) {        call bonding.bondToAccount(account, amount); // uses msg.sender of attack2    } } ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Bonding.sol#L81-L92  ```JS function bondToAccount(address account, uint256 amount) public {     if (msg.sender != offering) {          _notSameBlock();     }     ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Permissions.sol#L135-L141 ```JS function _notSameBlock() internal {     require( block.number > lastBlock[_msgSender()],"Can't carry out actions in the same block" );     lastBlock[_msgSender()] = block.number;   } ```  ## Tools Used  ## Recommended Mitigation Steps Add access controls to the function bondToAccount() An end-user could still call bond()   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setAuctionAverageLookback of AuctionBurnReserveSkew.sol change auctionAverageLookback  However there is also the variable "count" that is used in amongst others, addAbovePegObservation(). The modulo of count with auctionAverageLookback is calculated via _getIndexOfObservation(). When you change auctionAverageLookback then the modulo will result in a different value, so you end up in a different location of the circular buffer.  You should probably adapt count as well in the function setAuctionAverageLookback() (see also function setSampleMemory of MovingAverage.sol where a similar pattern is used)  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L186-L200  ```JS function setAuctionAverageLookback(uint256 _lookback) external onlyRole(ADMIN_ROLE, "Must have admin role") { ..     if (_lookback > auctionAverageLookback) {       for (uint i = auctionAverageLookback; i < _lookback; i++) {         pegObservations.push(0);       }     }      auctionAverageLookback = _lookback;  ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L143-L153 ```JS  function addAbovePegObservation(uint256 amount)  public onlyRole(STABILIZER_NODE_ROLE, "Must be a stabilizer node to call this method") {     uint256 index = _getIndexOfObservation(count);     ...     pegObservations[index] = 1;     count = count + 1; ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L134-L136 ```JS  function _getIndexOfObservation(uint _index) internal view returns (uint index) {     return _index % auctionAverageLookback;   } ```  ## Tools Used  ## Recommended Mitigation Steps Doublecheck the theory above and if you agree: Add the following statement in the function  setAuctionAverageLookback(), before auctionAverageLookback is updated.  ```JS  count = count  % auctionAverageLookback ; // the old version of auctionAverageLookback  ```   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setSampleMemory of MovingAverage.sol takes the modulo of counter with the new value of _sampleMemory: "counter = counter % _sampleMemory;"  Suppose: counter =15 ; sampleMemory=10 and  _sampleMemory=12 Then:   counter = counter % _sampleMemory ==> 3,  which means processing will continue at position 3.  However I think it should use: counter = counter % sampleMemory,  so it will continue at position 5  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/MovingAverage.sol#L424-L442  ```JS function setSampleMemory(uint256 _sampleMemory) external onlyRole(ADMIN_ROLE, "Must have admin privs")  {   ...     if (_sampleMemory > sampleMemory) {       ...       counter = counter % _sampleMemory;     } else {    }     sampleMemory = _sampleMemory; } ```  ## Tools Used  ## Recommended Mitigation Steps Doublecheck the theory above and if you agree: change ```JS  counter = counter % _sampleMemory; ``` to ```JS  counter = counter %  sampleMemory; ```   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setStabilityThresholds of StabilizerNode.sol set the values for upperStabilityThreshold and lowerStabilityThreshold, however there is no check for a maximum value. This means that in function _shouldAdjustSupply() the values for upperThreshold and lowerThreshold  could get larger than priceTarget. When they are subtracted from priceTarget a revert will occur.  Thus it is useful the make sure that upperStabilityThreshold and lowerStabilityThreshold don't get too large.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L445-L454  ```JS function setStabilityThresholds(uint256 _upper, uint256 _lower) external onlyRole(ADMIN_ROLE, "Must have admin role") {     require(_upper > 0 && _lower > 0, "Must be above 0");     upperStabilityThreshold = _upper;     lowerStabilityThreshold = _lower; ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L198-L206  ```JS function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {    ...     uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals); // upperStabilityThreshold could be > 10**dec => upperThreshold could be > priceTarget     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);  // lowerStabilityThreshold could be > 10**dec => lowerThreshold could be > priceTarget      return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold); // can revert   } ```  ## Tools Used  ## Recommended Mitigation Steps In function setStabilityThresholds() check for a maximum value of upperStabilityThreshold and lowerStabilityThreshold  
# Handle  leastwood   # Vulnerability details  ## Impact  `_startAuction` utilises the `SwingTrader` contract to purchase Malt. If `SwingTrader` has insufficient capital to return the price of Malt back to its target price, an auction is triggered with the remaining amount. However, no auction is triggered if the current auction exists, but `msg.sender` is still rewarded for their call to `stabilize`.  ## Proof of Concept  `_shouldAdjustSupply` initially checks if the current auction is active, however, it does not check if the current auction exists. There is a key distinction between the `auctionActive` and `auctionExists` functions which are not used consistently. Hence, an auction which is inactive but exists would satisfy the edge case and result in `triggerAuction` simply returning.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L382-L386 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L342-L344 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L873-L888  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider using `auctionExists` and `auctionActive` consistently in `StabilizerNode` and `Auction` to ensure this edge case cannot be abused.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function setAdvanceIncentive of DAO.sol doesn't check for a maximum value of incentive. If incentivewould be very large, then advanceIncentive would be very large and the function advance() would mint a large amount of malt.  The function setAdvanceIncentive() can only be called by an admin, but a mistake could be made. Also if an admin would want to do a rug pull, this would be an ideal place to do it.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L98-L104  ```JS   function setAdvanceIncentive(uint256 incentive)  externalonlyRole(ADMIN_ROLE, "Must have admin role") {    ...     advanceIncentive = incentive; ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63  ```JS function advance() external { ...     malt.mint(msg.sender, advanceIncentive * 1e18);  ```  ## Tools Used  ## Recommended Mitigation Steps Check for a reasonable maximum value in advance()  
# Handle  leastwood   # Vulnerability details  ## Impact  `purchaseArbitrageTokens` enables users to commit collateral tokens and in return receive arbitrage tokens which are redeemable in the future for Malt tokens. Each auction specifies a commitment cap which when reached, prevents users from participating in the auction. However, `realCommitment` can be ignored by directly sending the `LiquidityExtension` contract collateral tokens and subsequently calling `purchaseArbitrageTokens`.  ## Proof of Concept  Consider the following scenario: - An auction is currently active. - A user sends collateral tokens to the `LiquidityExtension` contract. - The same user calls `purchaseArbitrageTokens` with amount `0`. - The `purchaseAndBurn` call returns a positive `purchased` amount which is subsequently used in auction calculations.  As a result, a user could effectively influence the average malt price used throughout the `Auction` contract.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L177-L214 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117-L128  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding a check to ensure that `realCommitment != 0` in `purchaseArbitrageTokens`.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the contract Timelock.sol the following onlyRole expression occurs a few times, referring GOVERNER and timelock: onlyRole(GOVERNOR_ROLE, "Must have timelock role")  Whereas several other onlyRole expressions are referring to governor: onlyRole(GOVERNOR_ROLE, "Timelock::...: Call must come from governor.")  Either the role should be TIMELOCK_ROLE or the messages should refer consistently to governor. Otherwise it might be more difficult to solve error messages from reverts.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L68  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L84  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L100  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L115  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L140  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L159  ## Tools Used  ## Recommended Mitigation Steps Make the error messages consistent   
# Handle  leastwood   # Vulnerability details  ## Impact  Malt Finance uses solidity version `>=0.6.6` throughout all of its contracts. This solidity version provides no protections against arithmetic underflows and overflows. As a result, it is incredibly difficult to guarantee that the protocol enforces the necessary arithmetic checks during sensitive actions.  There are several instances where the OpenZeppelin's `SafeMath` library is not used. This exposes the protocol to potential exploits via arithmetic underflows and overflows. The liveness of the protocol depends on safety guarantees that are not provided/enforced. Therefore, this issue should be deemed high severity.  ## Proof of Concept  Solidity version shown in all contracts.  ## Tools Used  Manual code review. https://docs.soliditylang.org/en/v0.8.10/080-breaking-changes.html  ## Recommended Mitigation Steps  Consider updating the smart contract suite to use the latest solidity version or at the very least integrate OpenZeppelin's `SafeMath` library in all areas of the code containing arithmetic operations.  
# Handle  nathaniel   # Vulnerability details  ## Impact No vulnerability, however as `setupPartipant` would only ever be executed by the constructor in its deriving contracts, it would make sense if it was internal instead of public. If it was not executed in the constructor of the deriving contract, then at least it is safer with internal visibility.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionParticipant.sol#L30   
# Handle  nathaniel   # Vulnerability details  ## Impact The code in `getCollateralValueInMalt` of ImpliedCollateralService.sol, can leverage the `totalUsefulCollateral` function, reducing code size and gas cost when calling the contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L104-L124  ## Tools Used manual  ## Recommended Mitigation Steps Remove L108-L110, then in the return of `getCollateralValueInMalt` return `totalUsefulCollateral().mul(target).div(maltPrice) + swingTraderMaltBalance`  
# Handle  nathaniel   # Vulnerability details  ## Impact A large portion of the `unbond` and `unbondAndBreak` code of Bonding.sol is the same, to reduce code bloat and gas when calling the contract   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L97-L109  ## Tools Used Manual  ## Recommended Mitigation Steps I would suggest wrapping the duplicated code into an internal function called by `unbond` and `unbondAndBreak`.  
# Handle  hyh   # Vulnerability details  ## Impact  If Malt token be set to have lower decimals the incentives will be too big to be issued and DAO advance epoch and StabilizerNode auction start functions will fail, the system will have to be redeployed.  For example, if Malt was set to have 6 decimals like USDC, then 100*1e18 StabilizerNode defaultIncentive will be 100 trillions Malt.  ## Proof of Concept  Now some parts of the system use ```malt.decimals()``` (SwingTrader, UniswapHandler), some (StabilizerNode, DAO) use 18.  DAO advanceIncentive:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DAO.sol#L60   StabilizerNode defaultIncentive:  stabilize function https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145  calls _startAuction in low exchangeRate case, minting defaultIncentive * 10**18 = 100 * 1e18 Malt to the sender as a caller fee. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L344   ## Recommended Mitigation Steps  If Malt decimals are meant to be set to 18, add a constant variable and use it across the system to save gas.  If the flexibility is desired ```malt.decimals()``` to be used, in a form of contract storage variable for gas optimization (```decimals()``` can be saved to storage once on initialization, and read from there afterwards).   
# Handle  robee   # Vulnerability details  This issue is about arithmetic computation that could have been done more percise.  The following are places in the codebase in which you multiplied after the divisions.  Doing the multiplications at start lead to more accurate calculations.  This is a list of places in the code that this appears (Solidity file, line number, actual line):           DAO.sol, 105,   /* Internal methods */          UniswapHandler.sol, 265,         buyBase.div(priceTarget).mul(buyBase).mul(997)          RewardDistributor.sol, 113,   /* PUBLIC VIEW FUNCTIONS */          RewardDistributor.sol, 118,   /* INTERNAL VIEW FUNCTIONS */          RewardDistributor.sol, 129,   /* INTERNAL FUNCTIONS */   
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function getRewardOwnershipFraction in AbstractRewardMine.sol could be set external         The function balanceOfStakePadding in AbstractRewardMine.sol could be set external         The function withdrawnBalance in AbstractRewardMine.sol could be set external         The function earned in AbstractRewardMine.sol could be set external         The function setMiningService in AbstractRewardMine.sol could be set external         The function totalReleasedReward in AbstractRewardMine.sol could be set external         The function totalStakePadding in AbstractRewardMine.sol could be set external         The function totalBonded in AbstractRewardMine.sol could be set external         The function totalWithdrawn in AbstractRewardMine.sol could be set external         The function setRewardToken in AbstractRewardMine.sol could be set external         The function onBond in AbstractRewardMine.sol could be set external         The function withdrawAll in AbstractRewardMine.sol could be set external         The function onUnbond in AbstractRewardMine.sol could be set external         The function balanceOfBonded in AbstractRewardMine.sol could be set external         The function verifyTransfer in AbstractTransferVerification.sol could be set external         The function getAuctionCore in Auction.sol could be set external         The function getAuctionPrices in Auction.sol could be set external         The function getAuction in Auction.sol could be set external         The function auctionActive in Auction.sol could be set external         The function getAuctionCommitments in Auction.sol could be set external         The function isAuctionFinalized in Auction.sol could be set external         The function balanceOfArbTokens in Auction.sol could be set external         The function auctionExists in Auction.sol could be set external         The function consult in AuctionBurnReserveSkew.sol could be set external         The function getAverageParticipation in AuctionBurnReserveSkew.sol could be set external         The function addAbovePegObservation in AuctionBurnReserveSkew.sol could be set external         The function getPegDeltaFrequency in AuctionBurnReserveSkew.sol could be set external         The function addBelowPegObservation in AuctionBurnReserveSkew.sol could be set external         The function getRealBurnBudget in AuctionBurnReserveSkew.sol could be set external         The function earlyExitReturn in AuctionEscapeHatch.sol could be set external         The function setReplenishingIndex in AuctionParticipant.sol could be set external         The function usableBalance in AuctionParticipant.sol could be set external         The function outstandingArbTokens in AuctionParticipant.sol could be set external         The function getAllAuctionIds in AuctionParticipant.sol could be set external         The function setupParticipant in AuctionParticipant.sol could be set external         The function usableBalance in AuctionPool.sol could be set external         The function setBonding in AuctionPool.sol could be set external         The function totalReleasedReward in AuctionPool.sol could be set external         The function totalBonded in AuctionPool.sol could be set external         The function setForfeitDestination in AuctionPool.sol could be set external         The function onUnbond in AuctionPool.sol could be set external         The function totalDeclaredReward in AuctionPool.sol could be set external         The function balanceOfBonded in AuctionPool.sol could be set external         The function setMiningService in Bonding.sol could be set external         The function epochData in Bonding.sol could be set external         The function totalBonded in Bonding.sol could be set external         The function bondedEpoch in Bonding.sol could be set external         The function setDAO in Bonding.sol could be set external         The function setDexHandler in Bonding.sol could be set external         The function setCurrentEpoch in Bonding.sol could be set external         The function bondToAccount in Bonding.sol could be set external         The function averageBondedValue in Bonding.sol could be set external         The function balanceOfBonded in Bonding.sol could be set external         The function deploy in Create2Deployer.sol could be set external         The function getEpochStartTime in DAO.sol could be set external         The function epochsPerYear in DAO.sol could be set external         The function mint in DAO.sol could be set external         The function setEpochLength in DAO.sol could be set external         The function setMaltToken in DAO.sol could be set external         The function maltMarketPrice in UniswapHandler.sol could be set external         The function reserves in UniswapHandler.sol could be set external         The function constructor in ERC20Permit.sol could be set external         The function setBonding in ERC20VestedMine.sol could be set external         The function totalReleasedReward in ERC20VestedMine.sol could be set external         The function totalBonded in ERC20VestedMine.sol could be set external         The function setDistributor in ERC20VestedMine.sol could be set external         The function onUnbond in ERC20VestedMine.sol could be set external         The function totalDeclaredReward in ERC20VestedMine.sol could be set external         The function balanceOfBonded in ERC20VestedMine.sol could be set external         The function handleForfeit in ForfeitHandler.sol could be set external         The function totalUsefulCollateral in ImpliedCollateralService.sol could be set external         The function getCollateralValueInMalt in ImpliedCollateralService.sol could be set external         The function collateralDeficit in LiquidityExtension.sol could be set external         The function reserveRatio in LiquidityExtension.sol could be set external         The function hasMinimumReserves in LiquidityExtension.sol could be set external         The function constructor in Malt.sol could be set external         The function burn in Malt.sol could be set external         The function mint in Malt.sol could be set external         The function smoothedMaltPrice in MaltDataLab.sol could be set external         The function trackReserveRatio in MaltDataLab.sol could be set external         The function maltInPoolAverage in MaltDataLab.sol could be set external         The function smoothedMaltInPool in MaltDataLab.sol could be set external         The function reserveRatioAverage in MaltDataLab.sol could be set external         The function maltPriceAverage in MaltDataLab.sol could be set external         The function smoothedReserves in MaltDataLab.sol could be set external         The function smoothedReserveRatio in MaltDataLab.sol could be set external         The function balanceOfRewards in MiningService.sol could be set external         The function removeRewardMine in MiningService.sol could be set external         The function earned in MiningService.sol could be set external         The function withdrawRewardsForAccount in MiningService.sol could be set external         The function setReinvestor in MiningService.sol could be set external         The function withdrawAccountRewards in MiningService.sol could be set external         The function setBonding in MiningService.sol could be set external         The function isMineActive in MiningService.sol could be set external         The function onBond in MiningService.sol could be set external         The function numberOfMines in MiningService.sol could be set external         The function onUnbond in MiningService.sol could be set external         The function addRewardMine in MiningService.sol could be set external         The function getValue in MovingAverage.sol could be set external         The function getValueWithLookback in MovingAverage.sol could be set external         The function isWhitelisted in PoolTransferVerification.sol could be set external         The function setPool in PoolTransferVerification.sol could be set external         The function addToWhitelist in PoolTransferVerification.sol could be set external         The function verifyTransfer in PoolTransferVerification.sol could be set external         The function setThreshold in PoolTransferVerification.sol could be set external         The function setPriceLookback in PoolTransferVerification.sol could be set external         The function removeFromWhitelist in PoolTransferVerification.sol could be set external         The function setForfeitor in RewardDistributor.sol could be set external         The function addFocalLengthUpdater in RewardDistributor.sol could be set external         The function setRewardMine in RewardDistributor.sol could be set external         The function setBonding in RewardDistributor.sol could be set external         The function forfeit in RewardDistributor.sol could be set external         The function vest in RewardDistributor.sol could be set external         The function setThrottler in RewardDistributor.sol could be set external         The function setRewardToken in RewardDistributor.sol could be set external         The function removeFocalLengthUpdater in RewardDistributor.sol could be set external         The function decrementRewards in RewardDistributor.sol could be set external         The function totalDeclaredReward in RewardDistributor.sol could be set external         The function setFocalLength in RewardDistributor.sol could be set external         The function averageAPR in RewardThrottle.sol could be set external         The function targetEpochProfit in RewardThrottle.sol could be set external         The function epochData in RewardThrottle.sol could be set external         The function targetAPR in RewardThrottle.sol could be set external         The function getTargets in RewardThrottle.sol could be set external         The function handleReward in RewardThrottle.sol could be set external         The function checkRewardUnderflow in RewardThrottle.sol could be set external         The function epochAPR in RewardThrottle.sol could be set external         The function costBasis in SwingTrader.sol could be set external         The function setLpProfitCut in SwingTrader.sol could be set external         The function addVerifier in TransferService.sol could be set external         The function numberOfVerifiers in TransferService.sol could be set external         The function verifyTransfer in TransferService.sol could be set external         The function removeVerifier in TransferService.sol could be set external   
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           AbstractRewardMine.sol Variable miningService is read 3 times in the function:  setMiningService         Auction.sol Variable currentAuctionId is read 3 times in the function:  purchaseArbitrageTokens         Auction.sol Variable nextCommitmentId is read 2 times in the function:  purchaseArbitrageTokens         Auction.sol Variable currentAuctionId is read 4 times in the function:  _checkAuctionFinalization         Auction.sol Variable replenishingAuctionId is read 4 times in the function:  allocateArbRewards         Auction.sol Variable stabilizerNode is read 2 times in the function:  setStabilizerNode         Auction.sol Variable amender is read 2 times in the function:  setAuctionAmender         AuctionBurnReserveSkew.sol Variable auctionAverageLookback is read 2 times in the function:  getPegDeltaFrequency         AuctionBurnReserveSkew.sol Variable count is read 2 times in the function:  addAbovePegObservation         AuctionBurnReserveSkew.sol Variable count is read 2 times in the function:  addBelowPegObservation         AuctionBurnReserveSkew.sol Variable stabilizerNode is read 2 times in the function:  setNewStabilizerNode         AuctionParticipant.sol Variable replenishingIndex is read 2 times in the function:  claim         AuctionParticipant.sol Variable replenishingIndex is read 2 times in the function:  setReplenishingIndex         AuctionPool.sol Variable forfeitedRewards is read 2 times in the function:  _checkForForfeit         AuctionPool.sol Variable forfeitedRewards is read 3 times in the function:  _handleRewardDistribution         UniswapHandler.sol Variable router is read 2 times in the function:  addLiquidity         MaltDataLab.sol Variable UPDATER_ROLE is read 2 times in the function:  initialize         MiningService.sol Variable reinvestor is read 2 times in the function:  setReinvestor         MiningService.sol Variable bonding is read 2 times in the function:  setBonding         MovingAverage.sol Variable UPDATER_ROLE is read 2 times in the function:  initialize         MovingAverage.sol Variable cumulativeValue is read 11 times in the function:  update         MovingAverage.sol Variable blockTimestampLast is read 5 times in the function:  update         MovingAverage.sol Variable activeSamples is read 2 times in the function:  update         MovingAverage.sol Variable sampleLength is read 3 times in the function:  update         MovingAverage.sol Variable cumulativeValue is read 10 times in the function:  updateCumulative         MovingAverage.sol Variable blockTimestampLast is read 4 times in the function:  updateCumulative         MovingAverage.sol Variable activeSamples is read 2 times in the function:  updateCumulative         MovingAverage.sol Variable sampleLength is read 2 times in the function:  updateCumulative         MovingAverage.sol Variable activeSamples is read 2 times in the function:  _createNewSample         MovingAverage.sol Variable counter is read 2 times in the function:  setSampleMemory         RewardReinvestor.sol Variable dexHandler is read 2 times in the function:  _bondAccount         RewardReinvestor.sol Variable treasury is read 2 times in the function:  _bondAccount         RewardDistributor.sol Variable FOCAL_LENGTH_UPDATER_ROLE is read 2 times in the function:  initialize         RewardDistributor.sol Variable focalLength is read 2 times in the function:  _resetFocalPoint         RewardDistributor.sol Variable focalID is read 3 times in the function:  _incrementFocalPoint         RewardDistributor.sol Variable throttler is read 2 times in the function:  setThrottler         RewardDistributor.sol Variable rewardMine is read 2 times in the function:  setRewardMine         RewardOverflowPool.sol Variable throttler is read 2 times in the function:  setThrottler         RewardThrottle.sol Variable _activeEpoch is read 3 times in the function:  handleReward         StabilizerNode.sol Variable stabilizeWindowEnd is read 2 times in the function:  stabilize         StabilizerNode.sol Variable lastStabilize is read 2 times in the function:  stabilize         StabilizerNode.sol Variable liquidityExtension is read 2 times in the function:  _replenishLiquidityExtension         StabilizerNode.sol Variable auction is read 2 times in the function:  setAuctionContract         SwingTrader.sol Variable deployedCapital is read 2 times in the function:  buyMalt         SwingTrader.sol Variable deployedCapital is read 2 times in the function:  sellMalt   
# Handle  robee   # Vulnerability details  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.  The format is <solidity file>, <in which function we found it>, <unused local variable name>:           AbstractRewardMine.sol, _handleStakePadding, totalRewardedWithStakePadding         AbstractRewardMine.sol, _handleStakePadding, INITIAL_STAKE_SHARE_MULTIPLE         AbstractRewardMine.sol, _handleStakePadding, bondedTotal         Auction.sol, _finalizeAuction, avgMaltPrice         AuctionParticipant.sol, claim, replenishingId         AuctionParticipant.sol, claim, claimableTokens         AuctionParticipant.sol, claim, claimable         Create2Deployer.sol, deploy, addr         UniswapHandler.sol, removeBuyer, buyer         MaltDataLab.sol, trackPoolReserves, rewardDecimals         MovingAverage.sol, update, elapsedSamples         MovingAverage.sol, updateCumulative, elapsedSamples         StabilizerNode.sol, stabilize, exchangeRate         StabilizerNode.sol, _startAuction, decimals         SwingTrader.sol, sellMalt, maltDecimals         SwingTrader.sol, costBasis, maltDecimals         TransferService.sol, removeVerifier, verifier   
# Handle  robee   # Vulnerability details  In the following files, there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           AuctionBurnReserveSkew.sol, line 4, import "@openzeppelin/contracts/access/AccessControl.sol";         AuctionParticipant.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         AuctionParticipant.sol, line 3, import "@openzeppelin/upgrades/contracts/Initializable.sol";         AuctionPool.sol, line 9, import "./interfaces/IAuction.sol";         AuctionPool.sol, line 10, import "./interfaces/IBurnMintableERC20.sol";         AuctionPool.sol, line 11, import "./interfaces/IDexHandler.sol";         Bonding.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         ERC20VestedMine.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         ImpliedCollateralService.sol, line 12, import "./interfaces/IRewardThrottle.sol";         LiquidityExtension.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         LiquidityExtension.sol, line 3, import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";         MaltDataLab.sol, line 7, import "./interfaces/IStabilizerNode.sol";         MaltDataLab.sol, line 9, import "./interfaces/IDAO.sol";         MiningService.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         MiningService.sol, line 3, import "@openzeppelin/contracts/token/ERC20/ERC20.sol";         PoolTransferVerification.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         PoolTransferVerification.sol, line 6, import "./Permissions.sol";         RewardDistributor.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         RewardDistributor.sol, line 11, import "hardhat/console.sol";         RewardOverflowPool.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         RewardThrottle.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         RewardThrottle.sol, line 13, import "hardhat/console.sol";         SwingTrader.sol, line 8, import "./interfaces/IAuction.sol";         TransferService.sol, line 4, import "./interfaces/IMaltDataLab.sol";   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Remove L151 count = count + 1; and change L147 to uint256 index = _getIndexOfObservation(count++); so we save at least a SLOAD.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L143  ## Tools Used  ## Recommended Mitigation Steps Remove L151 count = count + 1; and change L147 to uint256 index = _getIndexOfObservation(count++);  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact After teh if statement on L74, we have premiumExcess <= maxBurnSpend and therefore don't need to do a save subtraction (underflow check) on L80.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L69  ## Tools Used  ## Recommended Mitigation Steps - rewrite L80 as: uint256 usableExcess = maxBurnSpend - premiumExcess;  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Else block on L805 satisfies amountArbTokens <= unclaimedArbTokens and therefore no safe subtraction (underflow check) is needed (saves gas).  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L786  ## Tools Used  ## Recommended Mitigation Steps - rewrite L805 as: unclaimedArbTokens = unclaimedArbTokens - amountArbTokens;  
# Handle  GiveMeTestEther   # Vulnerability details  # Vulnerability details  ## Impact The else block on L241 satisfies amountTokens <= unclaimedArbTokens and therefore we don't need to do a safe subtraction (underflow check).  The else block on L247 satisfies amountTokens <= claimableArbitrageRewards and therefore we don't need to do a safe subtraction (underflow check).     ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L216 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L247  ## Tools Used  ## Recommended Mitigation Steps - rewrite L241 as: unclaimedArbTokens = unclaimedArbTokens - amountTokens; - rewrite L274 as: claimableArbitrageRewards = claimableArbitrageRewards - amountTokens-;   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact L209 nextCommitmentId = nextCommitmentId + 1; can be removed and L202 can be changed to nextCommitmentId++; to save a SLOAD  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Storage variable _activeEpoch is read a lot and can be cached in a local variable (epochTmp, maybe choose a better name =)) to save gas. Also the State struct can be loaded into a State storage (currentState, maybe also choose a better name) variable such that we don't have to access the storage array each time.   In the gas optimized code of "Recommended Mitigation Steps" section, the _activeEpoch only gets read once. Also note after the first "if" we write epoch to the storage variable "_activeEpoch" but then also write epoch to the local var "epochTmp" so we can use this local var in the whole function.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L63  ## Tools Used  ## Recommended Mitigation Steps   function handleReward() public {     uint256 balance = rewardToken.balanceOf(address(this));      uint256 epoch = dao.epoch();     uint256 epochTmp = _activeEpoch;     State storage currentState;      checkRewardUnderflow();      if (epoch > epochTmp) {       _activeEpoch = epoch;       epochTmp = epoch;        currentState = _state[epochTmp];        currentState.bondedValue = bonding.averageBondedValue(epochTmp);        currentState.profit = balance;       currentState.rewarded = 0;       currentState.throttle = throttle;     } else {       currentState = _state[epochTmp];       currentState.profit = currentState.profit.add(balance);       currentState.throttle = throttle;      }      // Fetch targetAPR before we update current epoch state     uint256 aprTarget = targetAPR();      // Distribute balance to the correct places     if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) {       uint256 remainder = _getRewardOverflow(balance, aprTarget);       emit RewardOverflow(epochTmp, remainder);        if (remainder > 0) {         rewardToken.safeTransfer(address(overflowPool), remainder);          if (balance > remainder) {           _sendToDistributor(balance - remainder, epochTmp);         }       }     } else {       _sendToDistributor(balance, epochTmp);     }      emit HandleReward(epoch, balance);   }  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Require statement conditions checks that no underflow can happen, therefore we don't need to use safe subtraction (underflow check).  - L275:  require(amount <= _globals.declaredBalance, "Can't decrement more than total reward balance"); - L278:  _globals.declaredBalance = _globals.declaredBalance.sub(amount); => Rewrite L278 as:  _globals.declaredBalance = _globals.declaredBalance - amount;  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L271 ## Tools Used  ## Recommended Mitigation Steps - rewrite L278 as:  _globals.declaredBalance = _globals.declaredBalance - amount;  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact L185:  focalID = focalID + 1; can be removed and L197 can be adapted to:  _resetFocalPoint(++focalID, newEndTime); to save at least one warm storage read (100 gas)  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L180 ## Tools Used  ## Recommended Mitigation Steps  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Require condition checks already underflow condition. There for no underflow check is needed.  - L154: require(forfeited <= _globals.declaredBalance, "Cannot forfeit more than declared"); - L156:_globals.declaredBalance = _globals.declaredBalance.sub(forfeited);  Therefore L156 can be written as: _globals.declaredBalance = _globals.declaredBalance - forfeited;   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L153 ## Tools Used  ## Recommended Mitigation Steps - L156 can be written as: _globals.declaredBalance = _globals.declaredBalance - forfeited;  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on operations.  ## Proof of Concept  The function contains two non-intersecting logic pathways, which can be separated to lighten calculations.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L179   ## Recommended Mitigation Steps  Now: ``` function _handleStakePadding(address account, uint256 amount) internal {  uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());   uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;   uint256 bondedTotal = totalBonded();   uint256 newStakePadding = bondedTotal == 0 ?   totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :   totalRewardedWithStakePadding.mul(amount).div(bondedTotal);   _addToStakePadding(account, newStakePadding); } ```  To be: ``` function _handleStakePadding(address account, uint256 amount) internal {  uint256 bondedTotal = totalBonded();    uint256 newStakePadding;  if (bondedTotal == 0) {   uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;   newStakePadding = totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0;  } else {   newStakePadding = (totalDeclaredReward().add(totalStakePadding())).mul(amount).div(bondedTotal);  }   if (newStakePadding > 0)   _addToStakePadding(account, newStakePadding); } ```  
# Handle  jayjonah8   # Vulnerability details  ## Impact The setupParticipant() function in AuctionParticipant.sol does not have require statements to protect again contracts that do not yet exist.  It sets the addresses for " _impliedCollateralService", "_rewardToken", and "_auction" and can only be called once so its vital to have this guard in place.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionParticipant.sol#L26  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add require checks for the addresses that are passed in the setupParticipant() function checking if they exist like: require("address" != address(0), "contract does not exist")  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and function calls.  ## Proof of Concept  totalDeclaredReward is called by _handleStakePadding twice: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L180  While totalDeclaredReward does expensive balanceOf call: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L97  ## Recommended Mitigation Steps  It is viable to at least remove its double usage:  Now: ``` uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding()); ... uint256 newStakePadding = bondedTotal == 0 ?  totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :  totalRewardedWithStakePadding.mul(amount).div(bondedTotal); ```  To be: ``` uint256 declaredRewardTotal =  rewardToken.balanceOf(address(this)); uint256 totalRewardedWithStakePadding = declaredRewardTotal.add(totalStakePadding()); ... uint256 newStakePadding = bondedTotal == 0 ?  declaredRewardTotal == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 : totalRewardedWithStakePadding.mul(amount).div(bondedTotal); ```  
# Handle  Meta0xNull   # Vulnerability details  ## Impact Is Not Uncommon Normal Users Accidentally Send Tokens into Contract.  ENS Airdrop is a Good Example Normal Users Accidentally Send Tokens into Contract: https://discuss.ens.domains/t/social-amend-airdrop-proposal-to-include-accidentally-returned-funds/6975  In UniswapHandler.sol, sellMalt(), addLiquidity() and removeLiquidity() Have No Access Control. When Normal Users Accidently Deposit Tokens into the Contract, Any Random Persons/Bot Can Withdraw the Tokens because it will safeTransfer to msg.sender who find out there is token balance in the contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L185-L219 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221-L245  ## Tools Used Manual Review  ## Recommended Mitigation Steps Add relevant access control, probably Only StabilizerNode and Admin have Access to this contract various functions like sellMalt(), addLiquidity() and removeLiquidity() etc.   
# Handle  Meta0xNull   # Vulnerability details  ## Impact removeVerifier() loops follows this for-each pattern: for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` }  In such for loops, the array.length is read on every iteration, instead of caching it once in a local variable and read it again using the local variable.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L87-L88  ## Tools Used Manual Review  ## Recommended Mitigation Steps Read these values from memory once, cache them in local variables and then read them again using the local variables. For example:  Before: for (uint i = 0; i < verifierList.length - 1; i = i + 1) { if (verifierList[i] == _address) {  After: uint256 verifierList_temp = verifierList  for (uint i = 0; i < verifierList_temp.length - 1; i = i + 1) { if (verifierList_temp[i] == _address) {  
# Handle  Meta0xNull   # Vulnerability details  ## Impact The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L87 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionBurnReserveSkew.sol#L54 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Malt.sol#L34-L37 More...  ## Tools Used Manual Review  ## Recommended Mitigation Steps Remove explicit 0 initialization of for loop index variable.   Before: for (uint i = 0; After for (uint i;  
# Handle  Meta0xNull   # Vulnerability details  ## Impact      * [WARNING]      * ====      * This function should only be called from the constructor when setting      * up the initial roles for the system.      *      * Using this function in any other way is effectively circumventing the admin      * system imposed by {AccessControl}.      * ====      *      * NOTE: This function is deprecated in favor of {_grantRole}.  There are multiple contracts that import Permissions.sol and using Deprecated Function _setupRole() with Security Problem that Applicable to all these contracts because all of the contracts use initialize() Rather Than Constructor.   ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L174-L186 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L53 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L117 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L121  ## Tools Used Manual Review  ## Recommended Mitigation Steps Replace _setupRole() with _grantRole()  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on function calls.  ## Proof of Concept  ```earned``` function calls public ```getRewardOwnershipFraction``` function: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L144  ## Recommended Mitigation Steps  Now: ``` function totalDeclaredReward() virtual public view returns (uint256) {  return rewardToken.balanceOf(address(this)); } function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {  numerator = balanceOfRewards(account);  denominator = totalDeclaredReward(); } ... function earned(address account) public view returns (uint256 earnedReward) {  (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);  ```  To be: ``` function earned(address account) public view returns (uint256 earnedReward) {  uint256 rewardNumerator = balanceOfRewards(account);  uint256 rewardDenominator = rewardToken.balanceOf(address(this)); ```  
# Handle  Meta0xNull   # Vulnerability details  ## Impact A wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or Users'FUND Locked inside the Contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L63-L77  ## Tools Used Manual Review  ## Recommended Mitigation Steps requires Addresses is not zero.  require(_admin != address(0), "Address Can't Be Zero")  
# Handle  Meta0xNull   # Vulnerability details  ## Impact The current ownership transfer process involves the current TIMELOCK_ROLE calling reassignGlobalAdmin().  If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the TIMELOCK_ROLE modifier.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L63-L77  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider implementing a two step process where the TIMELOCK_ROLE nominates an account and the nominated account needs to call an accept_TIMELOCK_ROLE() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.   
# Handle  loop   # Vulnerability details  When invoking `purchaseArbitrageTokens()` is will first check whether the auction is active using: ``` require(auctionActive(currentAuctionId), "No auction running"); ``` `auctionActive()` checks for the following things: ``` auction.active && now >= auction.startingTime; ``` As a result the require statement will fail if either `!auction.active` or `now < auction.startingTime`.   Later on in `purchaseArbitrageTokens()` two more require statements will check the same thing: ``` require(auction.startingTime <= now, "Auction hasn't started yet"); (...)  require(auction.active == true, "Auction is not active"); ``` These will always pass if `auctionActive(currentAuctionId)` is `true` and never be reached if it is `false`, making them redundant.  ## Proof of Concept - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L178 - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L188-L190 - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272  ## Recommended Mitigation Steps Remove redundant require statements  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  Caching the array length in a `for`-loop saves gas as the length does not need to be read on every iteration.  The following loops could be refactored: ``` ./Malt.sol:34:    for (uint256 i = 0; i < minters.length; i = i + 1) { ./Malt.sol:37:    for (uint256 i = 0; i < burners.length; i = i + 1) { ./TransferService.sol:87:    for (uint i = 0; i < verifierList.length - 1; i = i + 1) { ./Auction.sol:407:    for (uint i = 0; i < epochCommitments.length; ++i) { ./libraries/UniswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./AuctionParticipant.sol:107:    for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) { ./MiningService.sol:49:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:69:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:86:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:96:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:142:    for (uint i = 0; i < mines.length - 1; i = i + 1) { ./MiningService.sol:166:    for (uint i = 0; i < mines.length; i = i + 1) { ./DexHandlers/UniswapHandler.sol:317:    for (uint i = 0; i < buyers.length - 1; i = i + 1) { ```  ## Tools used  `grep -rn ".length" .`  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  The functions `setDefaultIncentive` and `setExpansionDamping` in `StabilizerNode.sol` require their arguments to be non-zero, i.e. to be positive, as their argument types are `uint`.  However, the error messages state that the arguments should not be non-negative.  See lines [406](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L406) and [417](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L417).  ## Recommended Mitigation Steps  Change the error messages to something like: "Must be above 0".  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  Function `RewardReinvestor::_bondAccount` tries to bond liquidity to an account, even though it is known whether the liquidity is zero.  ## Proof of Concept  The return value `liquidityCreated` in [line 105](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L105) can be zero. The following function call, `bondToAccount()`, then reverts with "Cannot bond 0".  ## Recommended Mitigation Steps  Gas could be saved if the function would revert earlier, i.e. in [line 106](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L106), if the `liquidityCreated` is zero.  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description There is multiple instances within the **Malt** protocol codebase that do not append messages to the require statements.  ## Impact add a custom message to the require statement to create a better sense of what's is the reason of failure.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L681 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L56 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L76 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L78 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L119  ## Tools Used manual code review.  ## Recommended Mitigation Steps append custom message to the require statements.  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description On contract **AuctionEscapeHatch** there is a function labeled as Public, However this function is not used within the contracts of **Malt** protocol.  ## Impact Improve coding style quality for developers and audit.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L94  ## Tools Used manual code review.  ## Recommended Mitigation Steps Evaluate functions labeled as public and set to external if needed just like the rest of functions inside this contract.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Caching the references to "currentAuctionID" will decrease gas usage.   ## Proof of Concept  The state variable "currentAuctionID" is read 7 times in function "_checkAuctionFinalization" here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L746-L762  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to cache the variable:    ```   function _checkAuctionFinalization(bool isInternal) internal {      uint256 currentId = currentAuctionId;     if (isInternal && !isAuctionFinished(currentId)) {       // Auction is still in progress after internal auction purchasing.       _resetAuctionMaxCommitments();     }      if (isAuctionFinished(currentId)) {       if (auctionActive(currentId)) {         _endAuction(currentId);       }        if (!isAuctionFinalized(currentId)) {         _finalizeAuction(currentId);       }       currentAuctionId = currentId + 1;     }   } ```   
# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticipant.sol, the function `setReplenishingIndex` is an admin function that allows manually setting `replenishingIndex`. As I have shown in my two previous findings, I believe that this function could be called frequently. In my opinion (and Murphy's law would agree), this implies that eventually an admin will accidentally set `replenishingIndex` incorrectly with this function.  Right now, `setReplenishingIndex` does not allow the admin to set `replenishingIndex` to a value smaller than it currently is. So, if an admin were to accidentally set this value too high, then it would be impossible to set it back to a lower value (the higher the value set, the worse this issue). All of the unclaimed tokens on auctions at smaller indices would be locked forever.  ## Proof of Concept See code for `setReplenishingIndex` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L132  ## Tools Used Inspection  ## Recommended Mitigation Steps Remove the require statement on line 136, so that an admin can set the index to a smaller value.  
# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticpant.sol, every time `purchaseArbitrageTokens` is called, the current auction is pushed to `auctionIds`. If this function were to be called on the same auction multiple times, then the same auction id would be pushed multiple times into this array, and the `claim` function would have issues with `replenishingIndex`.   Specifically, even if `replenishingIndex` was incremented once in `claim`, it is still possible that the auction at the next index will never reward any more tokens to the participant, so the contract would need manual intervention to set `replenishingIndex` (due to the if statement on lines 79-82 that does nothing if there is no claimable yield).   It is likely that `purchaseArbitrageTokens` would be called multiple times on the same auction. In fact, the commented out code for `handleDeficit` (in ImpliedCollateralService.sol) even suggests that the purchases might happen within the same transaction. So this issue will likely be an issue on most auctions and would require manual setting of `replenishingIndex`.  NOTE: This is a separate issue from the one I just submitted previously relating to `replenishingIndex`. The previous issue was related to an edge case where `replenishingIndex` might need to be incremented by one if there are never going to be more claims, while this issue is due to duplicate auction ids.  ## Proof of Concept See code for `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L40  Notice that `currentAuction` is always appended to `auctionIds`.   ## Tools Used Inspection  ## Recommended Mitigation Steps Add a check to the function to `purchaseArbitrageTokens` to ensure that duplicate ids are not added. For example, this can be achieved by changing auctionIds to a mapping instead of an array.  
# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticipant.sol, the `claim` function is called to claim arb tokens from auctions the participant has entered. This is achieved through the global variable `replenishingIndex` which keeps track of which auction `claim` should be claiming from next. The logic for incrementing `replenishingIndex` is at the end of claim.   I agree with the current logic at the end of the function. The comment on lines 96/97 says "Don't increment replenishingIndex if replenishingAuctionId == auctionId as claimable could be 0 due to the debt not being 100% replenished". Notice the keyword "could" - it is possible that replenishingAuctionId == auctionId but we will never be able to claim any more arb tokens from this contract, and in this case `replenishingIndex` will NOT be incremented.  In this case, all subsequent calls to `claim` will simply do nothing. Line 77 will have `claimableTokens` be 0, and then the function will immediately return since it thinks it needs to wait longer to get more tokens, which will never happen. In this case, a manual intervention by an admin would be required to set `replenishingIndex', which is obviously annoying and should be avoided. Since `claim` is an external function, a malicious user/troll could intentionally call `claim` at the worst times to trigger this issue to happen. In this case, manual intervention would be required quite often.  The following logic should be added immediately after line 77 to account for this issue:  if (claimableTokens == 0 && replenishingId > auctionId) { // in this case, we will never receive any more tokens from this auction     replenishingIndex = replenishingIndex + 1;     auctionId = auctionIds[replenishingIndex]; }  // retry check for 0 claimable amount  ## Proof of Concept See the code for `claim` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L65  Other than manual intervention, the only place where `replenishingIndex` is set is at the end of `claim`.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add the code described above.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Variables are being assigned their default value which is unnecessary. Removing the assignment will save gas when deploying and improve code clarity.  ## Proof of Concept  State: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L19  Local: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L351 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L626 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L92 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L108 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L117 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L124 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionPool.sol#L115 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20VestedMine.sol#L90 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L94 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L125 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L149-L150 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L112  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unneeded assignments.  Or if you feel it is important to show the default assignment will occur then replace the assignments with a comment.  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODOs are here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L716 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L68 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L18 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L73 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L98 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L438 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L72 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L81 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L114 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L200 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L251 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L328  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODOs before deploying.  
# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been seen that malt price return value has not been checked on the function.  If oracle is returned price as a 0, fullReturn will be zero on the earlyExitReturn function.  ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L124" 2. The return value maltMarketPrice() function has not been checked.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to add return value check. The maltPrice should be more than zero for the calculation.  """ require(dexHandler.maltMarketPrice()>0, "Price should be more than zero"); """  
# Handle  hyh   # Vulnerability details  ## Impact  Being instantiated with wrong configuration, the contract is inoperable and deploy gas costs will be lost. If misconfiguration is noticed too late the various types of malfunctions become possible.  ## Proof of Concept  The checks for zero addresses during contract construction and initialization are considered to be the best-practice.  Now basically all the contract do not check for correctness of constructor arguments:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Malt.sol#L29  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardSystem/RewardOverflowPool.sol#L25  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L25  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ForfeitHandler.sol#L31  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L30  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L47  ...  ## Recommended Mitigation Steps  Add zero-address checks and key non-address variables checks in all contract constructors. Small increase of gas costs are far out weighted by wrong deploy costs savings and additional coverage against misconfiguration.   
# Handle  hyh   # Vulnerability details  ## Impact  ERC20 balanceOf call is costly. Malt balance is read twice in sellMalt call, which isn't needed, so gas is overspent here.  ## Proof of Concept  Malt balanceOf(address(this)) is called twice: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L86 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L150  ## Recommended Mitigation Steps  It's recommended to make internal version of costBasis that takes Malt balance as an argument.  Now: ``` uint256 totalMaltBalance = malt.balanceOf(address(this)); ... (...) = costBasis(); ... function costBasis() public view returns (uint256 cost, uint256 decimals) { ... uint256 maltBalance = malt.balanceOf(address(this)); ... ``` To be: ``` uint256 totalMaltBalance = malt.balanceOf(address(this)); ... (...) = _costBasis(totalMaltBalance); ... function _costBasis(uint256 maltBalance) internal view returns (...) { ... function costBasis() public view returns (...) {  return _costBasis(malt.balanceOf(address(this))); } ```  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on function call and calculations  ## Proof of Concept  First, save Malt and Collateral tokens decimals difference to storage variable. As neither Malt, nor Collateral token decimals change since initial setup, both can be saved and accessed as a storage variable instead of calling ```decimals()``` function and calculating the difference each time.  Second, now sellMalt calls costBasis, which already retrieved decimals and their difference, but sellMalt ignores those, retrieving them from functions/storage again. This could be unified as discussed below.  sellMalt: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L77 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L109  costBasis: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L146   ## Recommended Mitigation Steps   Save both decimals values to contract storage variables and use them instead of ```decimals()``` function. As the calculations use decimals difference it might be enough to save and use the difference only. In any case saving is preferred to calling as the latter spend gas on call and storage access anyway.   Also, return the difference along with decimals from costBasis and use them in sellMalt instead of obtaining afresh. I.e. first reuse ```costBasis``` returned ```decimals``` instead of ```collateralToken.decimals()```, then add ```maltDecimals``` and the difference, whether ```maltDecimals - decimals``` or ```decimals - maltDecimals``` to its output and use in rewards / soldBasis calculations. Function arguments and returned values are memory and are cheaper than another storage access.  Now: ``` (uint256 basis,) = costBasis(); ... uint256 maltDecimals = malt.decimals(); uint256 decimals = collateralToken.decimals(); ... uint256 diff = maltDecimals - decimals;  ``` To be: ``` (uint256 basis, uint256 decimals, uint256 maltDecimals, uint256 diff) = costBasis(); ... ```  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description  The event **SetAnnualYield** on Contract **StabilizerNode** is defined but never emitted inside the Contract.  ## Impact Unused events in the codebase can be confusing, each declared event should have a corresponding emit statement.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L73  ## Tools Used manual code review.  ## Recommended Mitigation Steps it's better to remove unused events from the code to improve coding quality, Also monitoring will be effected since no emit statements is there.  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and operations.  ## Proof of Concept  ```amountOut``` is calculated in 3 steps, which can be made simpler. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L302-305  ## Recommended Mitigation Steps  Now: ``` uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price); uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price); uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens); ```  To be (```amountTokens``` and ```redeemedTokens``` aren't used elsewhere): ```  /* * uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price); * uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price); * uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens); */ uint256 redeemed = commitment.redeemed.mul(auction.pegPrice); uint256 amountOut = commitment.commitment.mul(claimablePerc).sub(redeemed).div(price); ```   
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description On contract **Permissions.sol** there is multiple functions to withdraws funds, these functions currently do not check for zero value address before doing the transaction.  ## Impact Loss of funds, ETHs and ERC20.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L80 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L88 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L97 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L104  ## Tools Used manual code review.  ## Recommended Mitigation Steps use require() statement to validate address address(0) before sending the funds.  
# Handle  jayjonah8   # Vulnerability details  ## Impact In the AuctionEscapeHatch.sol file both earlyExitReturn() and _calculateMaltRequiredForExit call the getAuctionCore() function which has 10 possible return values most of which are not used.  It gets the wrong value back for the "active"  variable since it's the 10th argument but both functions have it as the 9th return value where "preAuctionReserveRatio" should be because of one missing comma.  This is serious because these both are functions which deal with allowing a user to exit their arbitrage token position early.  This can result in a loss of user funds.    ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L100 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L174 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L527   ## Tools Used Manual code review   ## Recommended Mitigation Steps In AuctionEscapeHatch.sol change the following in _calculateMaltRequiredForExit() and earlyExitReturn() functions:  From:   (,,,,,      uint256 pegPrice,      ,      uint256 auctionEndTime,      bool active     ) = auction.getAuctionCore(_auctionId);  To:   (,,,,,      uint256 pegPrice,      ,      uint256 auctionEndTime,      ,      bool active     ) = auction.getAuctionCore(_auctionId);   
# Handle  defsec   # Vulnerability details  ## Impact  SafeMath library functions are not always used in arithmetic operations in the contracts, which could potentially cause integer underflow/overflows. Although in the reference lines of code, there are upper limits on the variables to ensure an integer underflow/overflow could not happen, using SafeMath is always a best practice, which prevents underflow/overflows completely (even if there were no assumptions on the variables) and increases code consistency as well.   ## Proof of Concept  1. Navigate to the following contracts.  ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L795  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L821  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L64  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L76  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L188  ```  2. SafeMath functions are not used in the every functionality.   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider using the SafeMath library functions in the referenced lines of code.   
# Handle  defsec   # Vulnerability details  ## Impact  The admin only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in the contracts.   ## Proof of Concept  Missing events  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/SwingTrader.sol#L169  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L1000  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L1008  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L992  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L984  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L976  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L968  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L960  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L937  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L930  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L923  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L916  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionParticipant.sol#L132  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L226  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L234  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L218   See similar High-severity H03 finding OpenZeppelins Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelins Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)  ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all admin/privileged functions that change critical parameters.  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and operations.  ## Proof of Concept  ```claimablePerc``` is calculated in two steps, which can be made simpler. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L294  ## Recommended Mitigation Steps  Now: ``` uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice); uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens); ```  To be (```totalTokens``` isn't used elsewhere): ``` uint256 claimablePerc = auction.claimableTokens.mul(auction.finalPrice).div(auction.commitments); ```  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  As there is a check in the beginning of the function that includes the ```auction.finalPrice == 0``` condition: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L285  ## Recommended Mitigation Steps  The same condition down the line is never true and its check is redundant: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L298  
# Handle  sabtikw   # Vulnerability details  ## Impact  storage variables are initialized in the contract and overwritten in the initializer function.   ## Proof of Concept Auction.sol L#89 L#164 auctionLength AuctionBurnReserveSkew.sol L#25 auctionAverageLookback MaltDataLab.sol L#69 priceTarget  ## Tools Used  manual review   ## Recommended Mitigation Steps  remove initialization outside of initializer function  
# Handle  defsec   # Vulnerability details  ## Impact  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  ## Proof of Concept  1. Navigate to the following contracts.  ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L167  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionParticipant.sol#L59  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L252  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/RewardReinvestor.sol#L107 ``` 2.  When trying to re-approve an already approved token, all transactions revert and the protocol cannot be used.  ## Tools Used  None  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Cheaper storage.  ## Proof of Concept  The struct AuctionData file Auction.sol is optimizable. It looks like this:  ``` struct AuctionData {   // The full amount of commitments required to return to peg   uint256 fullRequirement;   // total maximum desired commitments to this auction   uint256 maxCommitments;   // Quantity of sale currency committed to this auction   uint256 commitments;   // Malt purchased and burned using current commitments   uint256 maltPurchased;   // Desired starting price for the auction   uint256 startingPrice;   // Desired lowest price for the arbitrage token   uint256 endingPrice;   // Price of arbitrage tokens at conclusion of auction. This is either   // when the duration elapses or the maxCommitments is reached   uint256 finalPrice;   // The peg price for the liquidity pool   uint256 pegPrice;   // Time when auction started   uint256 startingTime;   uint256 endingTime;   // Is the auction currently accepting commitments?   bool active;   // The reserve ratio at the start of the auction   uint256 preAuctionReserveRatio;   // Has this auction been finalized? Meaning any additional stabilizing   // has been done   bool finalized;   // The amount of arb tokens that have been executed and are now claimable   uint256 claimableTokens;   // The finally calculated realBurnBudget   uint256 finalBurnBudget;   // The amount of Malt purchased with realBurnBudget   uint256 finalPurchased;   // A map of all commitments to this auction by specific accounts   mapping(address => AccountCommitment) accountCommitments; } ``` But `active` and `finalized`, the unique boolean values, should be together, otherwise they will spend two slots instead of one. ```   uint256 preAuctionReserveRatio;   bool active;   bool finalized; ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps  
# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Use `indexed` on address to filter through logs better https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L105 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L112   
# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding. Some variables are in form of bps https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L90  while some are not https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L91 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L92  As a good programming practice, should use bps everywhere if you accepting it as a unit    
# Handle  jayjonah8   # Vulnerability details  ## Impact In MovingAverage.sol the safeMath.sol library is imported but I counted at least 25 places in the file where it should be used (Nearly the entire file).  This can result in values wrapping around which has caused devastating effects on many protocols in the past.  These values directly effect the exchangeRate variable given in the stabilize() function in StabilizerNode.sol so they must be treated with care.   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MovingAverage.sol#L3  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156  ## Tools Used Manual code review   ## Recommended Mitigation Steps The MovingAverage.sol file should be completely reviewed making use of safeMath through out the entire file.  
# Handle  defsec   # Vulnerability details  ## Impact  After pragma version, 0.7.0, the contract should use block.timestamp.  ## Proof of Concept  1. Navigate to the following contract.  "https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L153"  "https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L178"  2. Now is used instead of block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  It is recommended to use block.timestamp instead of now.  
# Handle  jayjonah8   # Vulnerability details  ## Impact The executeTransaction() function in Timelock.sol does not include a check if the contract being called actually exists. The extcodesize is not used when using .call on addresses directly as per the solidity docs.  This is important because the EVM allows calls to a non-existing contract to always succeed.   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Timelock.sol#L191  solidity docs: https://docs.soliditylang.org/en/v0.8.10/units-and-global-variables.html#address-related  "Due to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity includes an extra check using the extcodesize opcode when performing external calls. This ensures that the contract that is about to be called either actually exists (it contains code) or an exception is raised. The low-level calls which operate on addresses rather than contract instances (i.e. .call(), .delegatecall(), .staticcall(), .send() and .transfer()) do not include this check, which makes them cheaper in terms of gas but also less safe."   ## Tools Used Manual code review  ## Recommended Mitigation Steps A check should be included to make sure the contract being called actually exists to avoid making possible errors in the executeTransaction() function  
# Handle  TomFrench   # Vulnerability details  ## Impact  Greater costs of epoch advancement  ## Proof of Concept  The `Advance` event emits the block number and timestamp in its data  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L24  These fields are attached to events by default so it's unnecessary to manually emit them (and pay the associated gas costs)  ## Recommended Mitigation Steps  Remove `block` and `timestamp` fields from `Advance` event  
# Handle  TomFrench   # Vulnerability details  ## Impact  Unintended advancement incentives being paid out to third party  ## Proof of Concept  `DAO.sol` incentives outside parties to advance the epoch by minting 100 MALT tokens for calling the `advance` function. This is limited by checking that the start timestamp of the next epoch has passed.   https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63  This start timestamp is calculated by multiplying the new epoch number by the length of an epoch and adding it to the genesis timestamp.  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L65-L67  This method makes no accommodation for the fact that previous epochs may have been set to be a different length to what they are currently.  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L111-L114  In the case where the epoch length is reduced, `DAO` will think that the epoch number can be incremented potentially many times. Provided the `advanceIncentive` is worth more than the gas necessary to advance the epoch will be rapidly advanced potentially many times paying out unnecessary incentives.  ## Recommended Mitigation Steps  Rather than calculating from the genesis timestamp, store the last time that the epoch length was modified and calculate from there.  
# Handle  gzeon   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L61 ```     return (       maltDataLab.maltPriceAverage(priceLookback) > priceTarget * (10000 - thresholdBps) / 10000,       "The price of Malt is below peg. Wait for peg to be regained or purchase arbitrage tokens."     ); ``` when the condition is true (which should be the majority of time), the reason string is unnecessary. Only return the string when the condition is false.  
# Handle  Koustre   # Vulnerability details  ## Impact In UniswapHandler, in the function ```removeBuyer``` there is a for loop over an unbounded Buyers array, which if the buyers array gets too large can cause a denial of service and prevents the contract from being able to remove buyer roles from users/contracts. This would allow users/contracts to circumvent recovery mode and to continue to purchase and sell tokens using the contract.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used - Manual Study ## Recommended Mitigation Steps - remove unbounded for loop  
# Handle  harleythedog   # Vulnerability details  ## Impact In ForfeitHandler.sol, there are two values `swingTraderRewardCut ` and `treasuryRewardCut `, and these values always sum to 1000. Instead of having to go through all of the logic of setting these values independently and always ensuring that they sum to 1000, it would be simpler (and definitely save a lot of gas) if you simply removed everything related to `treasuryRewardCut` and always just used `1000-swingTraderRewardCut` in its place.  This also is more similar to what is done in StabilizerNode.sol where `treasuryCut` is simply what is left over after other components have taken their cut.  ## Proof of Concept See ForfeitHandler.sol here: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ForfeitHandler.sol  ## Tools Used Inspection  ## Recommended Mitigation Steps Simplify logic and save gas by removing `treasuryRewardCut`.  
# Handle  harleythedog   # Vulnerability details  ## Impact In UniswapHandler.sol within the `removeBuyer` function, there is a statement on line 308: ``` address buyer; ```  This variable is not used at all in the rest of the function, so this statement can be removed to save gas.  ## Proof of Concept See statement here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L308  ## Tools Used Inspection  ## Recommended Mitigation Steps Remove unnecessary line to save gas  
# Handle  gzeon   # Vulnerability details  ## Impact When malt is under-peg and the swing trader module do not have enough capital to buy back to peg, a Dutch auction is triggered to sell arb token. The price of the Dutch auction decrease linearly toward endprice until _endAuction() is called. https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L589  _endAuction() is called in   1. When auction.commitments >= auction.maxCommitments https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L212  2. On stabilize() -> checkAuctionFinalization() -> _checkAuctionFinalization() https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L146 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754  3. On stabilize() ->_startAuction() -> triggerAuction() -> _checkAuctionFinalization() https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L170 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754  It is possible manipulate the dutch auction by preventing _endAuction() being called.  ## Proof of Concept Consider someone call purchaseArbitrageTokens with auction.maxCommitments minus 1 wei, `_endAuction` won't be called because auction.commitments < auction.maxCommitments. Further purchase would revert because `purchaseAndBurn` (https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L184) would likely revert since swapping 1 wei in most AMM will fail due to rounding error. Even if it does not revert, there is no incentive to waste gas to purchase 1 wei of token.  As such, the only way for the auction to finalize is to call stabilize().  However, this is not immediately possible because it require  `block.timestamp >= stabilizeWindowEnd` where `stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod` stabilizeBackoffPeriod is initially set to 5 minutes in the contract  After 5 minute, stabilize() can be called by anyone. By using this exploit, an attacker can guarantee he can purchase at (startingPrice+endingPrice)/2 or lower, given the default 10 minute auctionLength and 5 minute stabilizeBackoffPeriod. (unless a privileged user call stabilize() which override the stability window)  Also note that stabilize() might not be called since there is no incentive.  ## Recommended Mitigation Steps 1. Incentivize stabilize() or incentivize a permission-less call to _endAuction() 2. Lock-in auction price when user commit purchase  
# Handle  leastwood   # Vulnerability details  ## Impact  `MaltDataLab` integrates several `MovingAverage` contracts to fetch sensitive data for the Malt protocol. Primary data used by the protocol consists of the real value for LP tokens, the average price for Malt and average reserve ratios. `trackMaltPrice`, `trackPoolReserves` and `trackPool` are called by a restricted role denoted as the `UPDATER_ROLE` and represented by an EOA account and not another contract. Hence, the EOA account must consistently update the aforementioned functions to ensure the most up-to-date values. However, miners can censor calls to `MaltDataLab` and effectively extract value from other areas of the protocol which use stale values.  ## Proof of Concept  Consider the following attack vector: - The price of Malt exceeds the lower bound threshold and hence `stabilize` can be called by any user. - The `_stabilityWindowOverride` function is satisfied, hence the function will execute. - The state variable, `exchangeRate`, queries `maltPriceAverage` which may use an outdated exchange rate. - `_startAuction` is executed which rewards `msg.sender` with 100 Malt as an incentive for triggering an auction. - As the price is not subsequently updated, a malicious attacker could collude with a miner to censor further pool updates and continue calling `stabilize` on every `fastAveragePeriod` interval to extract incentive payments. - If the payments exceed what the `UPDATER_ROLE` is willing to pay to call `trackMaltPrice`, a user is able to sustain this attack.  This threatens the overall stability of the protocol and should be properly handled to prevent such attacks. However, the fact that `MaltDataLab` uses a series of spot price data points to calculate the `MovingAverage` also creates an area of concern as well-funded actors could still manipulate the `MovingAverage` contract by sandwiching calls to `trackMaltPrice`, `trackPool` and `trackPoolReserves`.  `trackMaltPrice`, `trackPool`, and `trackPoolReserves` should be added to the following areas of the code where applicable. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L159 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L173 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L177 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L881 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L710 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L190 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L105  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding calls to `trackMaltPrice`, `trackPoolReserves` and `trackPool` wherever the values are impacted by the protocol. This should ensure the protocol is tracking the most up-to-date values. Assuming the cumulative values are used in the `MovingAverage` contracts, then sensitive calls utilising `MaltDataLab` should be protected from flashloan attacks. However, currently this is not the case, rather `MovingAverage` consists of a series of spot price data points which can be manipulated by well-funded actors or via a flashloan. Therefore, there needs to be necessary changes made to `MaltDataLab` to use cumulative price updates as its moving average instead of spot price.  
# Handle  stonesandtrees   # Vulnerability details  ## Impact All of the `rewardToken` in a given AMM pool can be removed from the AMM pool and distributed as LP rewards.  ## Proof of Concept In the `stabilize` method in the `StabilizerNode` the initial check to see if the Malt price needs to be stabilized it uses a short period TWAP: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156  However, if the price is above the threshold for stabilization then the trade size required to stabilize looks at the AMM pool directly which is vulnerable to flashloan manipulation.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L250-L275  Attack: 1. Wait for TWAP to rise above the stabilization threshold 2. Flashloan remove all but a tiny amount of Malt from the pool. 3. Call `stabilize`. This will pass the TWAP check and execute `_distributeSupply` which in turn ultimately calls `_calculateTradeSize` in the `UniswapHandler`. This calculation will determine that almost all of the `rewardToken` needs to be removed from the pool to return the price to peg.  4. Malt will mint enough Malt to remove a lot of the `rewardToken` from the pool. 5. The protocol will now distribute that received `rewardToken` as rewards. 0.3% of which goes directly to the attacker and the rest goes to LP rewards, swing trader and the treasury.  The amount of money that can be directly stolen by a malicious actor is small but it can cause a lot of pain for the protocol as the pool will be destroyed and confusion around rewards will be created.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use a short TWAP to calculate the trade size instead of reading directly from the pool.  
# Handle  pauliax   # Vulnerability details  ## Impact Consider caching decimals when initializing malt and collateralToken to avoid repeated external calls, as they are not supposed to change unless initialized again: ```solidity   uint256 maltDecimals = malt.decimals();   uint256 decimals = collateralToken.decimals(); ```   
# Handle  hyh   # Vulnerability details  ## Impact  BONDING_ROLE cannot be managed after it was initialized.  ## Proof of Concept  ```setBonding``` set the wrong role via _swapRole:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L116  ## Recommended Mitigation Steps  Set ```BONDING_ROLE``` instead of ```REINVESTOR_ROLE``` in ```setBonding``` function:  Now: ``` function setBonding(address _bonding)  public  onlyRole(ADMIN_ROLE, "Must have admin privs") {  require(_bonding != address(0), "Cannot use address 0");  _swapRole(_bonding, bonding, REINVESTOR_ROLE);  bonding = _bonding; } ```  To be: ``` function setBonding(address _bonding)  public  onlyRole(ADMIN_ROLE, "Must have admin privs") {  require(_bonding != address(0), "Cannot use address 0");  _swapRole(_bonding, bonding, BONDING_ROLE);  bonding = _bonding; } ```  
# Handle  pauliax   # Vulnerability details  ## Impact contract PoolTransferVerification sets thresholdBps but in calculations uses only ```(10000 - thresholdBps)```. Consider pre-calculating to avoid re-evaluation again and again when this function is invoked.  
# Handle  pauliax   # Vulnerability details  ## Impact Function purchaseArbitrageTokens should validate that amount > 0, otherwise it may be possible to spam accountCommitmentEpochs with 0 amounts: ```solidity   if (auction.accountCommitments[msg.sender].commitment == 0) {     accountCommitmentEpochs[msg.sender].push(currentAuctionId);   } ```  ## Recommended Mitigation Steps require amount > 0  
# Handle  pauliax   # Vulnerability details  ## Impact There are several loops in the contract which can eventually grow so large as to make future operations of the contract cost too much gas to fit in a block, e.g.: ```solidity   for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) // function outstandingArbTokens()   while (true) // function allocateArbRewards ```  ## Recommended Mitigation Steps Consider introducing a reasonable upper limit based on block gas limits. Also, you can consider using EnumerableSet (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol) where possible, e.g. 'buyers' or 'verifierList'.  
# Handle  pauliax   # Vulnerability details  ## Impact I think this if check is incorrect, because in theory maxAmount parameter can be greater than totalMaltBalance: ```solidity     if (rewards <= deployedCapital && maxAmount != totalMaltBalance) {       // If all malt is spent we want to reset deployed capital       deployedCapital = deployedCapital - rewards;     } else {       deployedCapital = 0;     } ```  ## Recommended Mitigation Steps If my assumption is correct, the check should use balance, not maxAmount: ``solidity   balance != totalMaltBalance ``` Another possible solution: ``solidity   maxAmount <= totalMaltBalance ``` However, I think the best approach would be to eliminate 'balance' altogether: ```solidity   uint256 totalMaltBalance = malt.balanceOf(address(this));    if (totalMaltBalance == 0) {     return 0;   }    (uint256 basis,) = costBasis();    if (maxAmount > totalMaltBalance) {     maxAmount = totalMaltBalance;   }    malt.safeTransfer(address(dexHandler), maxAmount);   uint256 rewards = dexHandler.sellMalt();    if (rewards <= deployedCapital && maxAmount < totalMaltBalance) {     // If all malt is spent we want to reset deployed capital     deployedCapital = deployedCapital - rewards;   } else {     deployedCapital = 0;   }   ```  
# Handle  pauliax   # Vulnerability details  ## Impact These checks should be inclusive: ```solidity        require(amountOut > minOut, "EarlyExit: Insufficient output");   require(_bps > 0 && _bps < 1000, "Must be between 0-100%");   require(newThreshold > 0 && newThreshold < 10000, "Threshold must be between 0-100%");   require(_distance > 0 && _distance < 1000, "Override must be between 0-100%"); ```  ## Recommended Mitigation Steps Replace > with >= and < with <= where necesseary.  
# Handle  hyh   # Vulnerability details  ## Impact  A condition requires that calculated retrievable amount shouldn't be too big. If it is the function fails and the remaining portion of commitment is frozen.  As the amount is calculated by the system a user cannot do anything to retrieve remaining part of commitment, if any.  ## Proof of Concept  ```claimArbitrage``` fails if calculated redemption is higher than remaining commitment: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L230  ```userClaimableArbTokens``` calculated amount can be bigger than remaining user funds: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L279  ## Recommended Mitigation Steps  If the freezing of remainder amount is not intentional then substitute require with ceiling the amount to be retrieved with the remaining part.  Now: ``` require(redemption <= remaining.add(1), "Cannot claim more tokens than available"); ```  To be: ``` if (redemption > remaining) {  redemption = remaining; } ```   
# Handle  pauliax   # Vulnerability details  ## Impact When auction.endingTime == now, function purchaseArbitrageTokens thinks that auction is still active, while isAuctionFinished and earlyExitReturn think that it has ended: purchaseArbitrageTokens: ```solidity   require(auction.endingTime >= now, "Auction is already over"); ``` isAuctionFinished: ```solidity   return auction.endingTime > 0 && (now >= auction.endingTime || ...); ``` earlyExitReturn: ```solidity   if(active || block.timestamp < auctionEndTime) {     return 0;   } ```  ## Recommended Mitigation Steps Consider unifying it across the functions.  
# Handle  pauliax   # Vulnerability details  ## Impact In functions transferAndCall and transferWithPermit the condition should be AND, not OR: ```solidity   require(to != address(0) || to != address(this)); ```  ## Recommended Mitigation Steps ```solidity   require(to != address(0) && to != address(this)); ```   
# Handle  pauliax   # Vulnerability details  ## Impact The variable DOMAIN_SEPARATOR in contract ERC20Permit is assigned in the constructor and will not change after being initialized. However, if a hard fork happens after the contract deployment, the domain would become invalid on one of the forked chains due to the block.chainid has changed.  Also, you don't need an assmebly to retrieve chainid, you can get it from a built in variable block.chainid.  Similar issues were reported in a previous contest and were assigned a severity of low:  https://github.com/code-423n4/2021-06-realitycards-findings/issues/166  https://github.com/code-423n4/2021-09-swivel-findings/issues/98  ## Recommended Mitigation Steps An elegant solution that you may consider applying is from Sushi Trident: https://github.com/sushiswap/trident/blob/concentrated/contracts/pool/concentrated/TridentNFT.sol#L47-L62  
# Handle  pauliax   # Vulnerability details  ## Impact Inaccurate revert messages: ```solidity           _delay >= 0 && _delay < gracePeriod,   "Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod"    require(startEpoch < endEpoch, "Start cannot be before the end");   require(rewardAmount <= rewardEarned, "< earned");   require(bondedBalance > 0, "< bonded balance");   require(amount <= bondedBalance, "< bonded balance"); ```   
# Handle  ScopeLift   # Vulnerability details  ## Impact  Inside `provideReinvest` and `_bondAccount` gas can be saved by using the standard transfer method on the Malt token, since we know its implementation is correct and will return true/false.  ## Proof of Concept  N/A  ## Tools Used  N/A  ## Recommended Mitigation Steps  Replace `malt.safeTransfer(address(dexHandler), balance);` with something like:  ```solidity require(malt.transfer(address(dexHandler), balance), 'malt transfer failed'); ```   
# Handle  ScopeLift   # Vulnerability details  ## Impact  The internal `_withdraw` method does not follow the checks-effects-interactions pattern. A malicious token, or one that implemented transfer hooks, could re-enter the public calling function (such as `withdraw()`) before proper internal accounting was completed. Because the `earned` function looks up the `_userWithdrawn` mapping, which is not yet updated when the transfer occurs, it would be possible for a malicious contract to re-enter `_withdraw` repeatedly and drain the pool.  ## Proof of Concept  N/A  ## Tools Used  N/A  ## Recommended Mitigation Steps  The internal accounting should be done before the transfer occurs:  ```solidity function _withdraw(address account, uint256 amountReward, address to) internal {     _userWithdrawn[account] += amountReward;     _globalWithdrawn += amountReward;f     rewardToken.safeTransfer(to, amountReward);      emit Withdraw(account, amountReward, to);   } ```   
# Handle  ScopeLift   # Vulnerability details  ## Impact  There are four functions that can have stricter function mutability declarations. Using a stricter declaration can help the compiler save gas when it knows whether reads and writes will occur in a function  ## Proof of Concept  N/A  ## Tools Used  solc  ## Recommended Mitigation Steps  Implement the changes suggested by the Solidity compiler. For examples like `AbstractTransferVerification`, the solidity compiler is wrong because it doesn't know you plan to override this function declaration. Instead, `AbstractTransferVerification` could be an interface without a function definition  ``` contracts/AbstractTransferVerification.sol:9:3: Warning: Function state mutability can be restricted to pure   function verifyTransfer(address from, address to, uint256 amount) public view virtual returns (bool, string memory) {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/AuctionEscapeHatch.sol:168:3: Warning: Function state mutability can be restricted to view   function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/AuctionParticipant.sol:127:3: Warning: Function state mutability can be restricted to pure   function _handleRewardDistribution(uint256 rewarded) virtual internal {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/MaltDataLab.sol:202:3: Warning: Function state mutability can be restricted to pure   function _normalizedPrice(   ^ (Relevant source part starts here and spans across multiple lines). ```  
# Handle  ScopeLift   # Vulnerability details  ## Impact  On lines 85 and 101, ETH is transferred using a `.call` to an address provided as an input, but there is no verification that the call call succeeded. This can result in a call to `emergencyWithdrawGAS` or `partialWithdrawGAS` appearing successful but in reality it failed. This can happen when the provided `destination` address is a contract that cannot receive ETH, or if the `amount` provided is larger than the contract's balance  ## Proof of Concept  Enter the following in remix, deploy the `Receiver` contract, and send 1 ETH when deploying the `Permissions` contract. Call `emergencyWithdrawGAS` with the receiver address and you'll see it reverts. This would not be caught in the current code  ```solidity pragma solidity ^0.8.0;  contract Receivier{}  contract Permissions {     constructor() payable {}      function emergencyWithdrawGAS(address payable destination) external {         (bool ok, ) = destination.call{value: address(this).balance}('');         require(ok, "call failed");     } } ```  ## Tools Used  Remix  ## Recommended Mitigation Steps  In `emergencyWithdrawGAS`:  ```diff - destination.call{value: address(this).balance}(''); + (bool ok, ) = destination.call{value: address(this).balance}(''); + require(ok, "call failed"); ```  And similar for `partialWithdrawGAS`  
# Handle  ScopeLift   # Vulnerability details  ## Estimated risk level Gas Optimization  ## Impact Instantiating an array of length n is better than `push(0)`  n times and saves 20k gas in tests.  ## Proof of Concept  ## Tools Used   ## Recommended Mitigation Steps change the initializer  ```diff ## Saves ~20,000 gas on initialize  diff --git a/src/contracts/AuctionBurnReserveSkew.sol b/src/contracts/AuctionBurnReserveSkew.sol index 4ed6fa6..87d5959 100644 --- a/src/contracts/AuctionBurnReserveSkew.sol +++ b/src/contracts/AuctionBurnReserveSkew.sol @@ -51,9 +51,7 @@ contract AuctionBurnReserveSkew is Initializable, Permissions {      auction = IAuction(_auction);      auctionAverageLookback = _period;   -    for (uint i = 0; i < _period; i++) { -      pegObservations.push(0); -    } +    pegObservations = new uint256[](_period);    }      function consult(uint256 excess) public view returns (uint256) { ```  
# Handle  gzeon   # Vulnerability details  ## Impact One of the innovative feature of Malt is to block buying while under peg. The buy block can be bypassed by swapping to the whitelisted UniswapHandler, and then extract the token by abusing the add and remove liquidity function. This is considered a high severity issue because it undermine to protocol's ability to generate profit by the privileged role as designed and allow potential risk-free MEV.  ## Proof of Concept 1) User swap dai into malt and send malt directly to uniswapHandler, this is possible becuase uniswapHandler is whitelisted `swapExactTokensForTokens(amountDai, 0, [dai.address, malt.address], uniswapHandler.address, new Date().getTime() + 10000);` 2) User send matching amount of dai to uniswapHandler 3) User call addLiquidity() and get back LP token 4) User call removeLiquidity() and get back both dai and malt  ## Recommended Mitigation Steps According to documentation in https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol > Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode. , this should be exploitable. Meanwhile the current implementation did not actually allow remove liquidity during recovery mode (refer to issue "Unable to remove liquidity in Recovery Mode") This exploit can be mitigated by disabling addLiquidity() when the protocol is in recovery mode  
# Handle  gzeon   # Vulnerability details  ## Impact According to https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol > When the Malt price TWAP drops below a specified threshold (eg 2% below peg) then the protocol will revert any transaction that tries to remove Malt from the AMM pool (ie buying Malt or removing liquidity). Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode.  However, in https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L236 liquidity removed is directly sent to msg.sender, which would revert if it is not whitelisted https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L53  ## Recommended Mitigation Steps Liquidity should be removed to UniswapHandler contract, then the proceed is sent to msg.sender  
# Handle  WatchPug   # Vulnerability details  Based on the context, `maltDataLab.trackReserveRatio()` should be called once a market buy/sell is made.  However, in `_distributeSupply()` when `swingAmount >= tradeSize`, after a market sell, the function returned without `maltDataLab.trackReserveRatio()`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L145-L174  ```solidity=145{168,170,172}   function stabilize() external notSameBlock {     auction.checkAuctionFinalization();      require(       block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),       "Can't call stabilize"     );     stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;      rewardThrottle.checkRewardUnderflow();      uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);      if (!_shouldAdjustSupply(exchangeRate)) {       maltDataLab.trackReserveRatio();        lastStabilize = block.timestamp;       return;     }      emit Stabilize(block.timestamp, exchangeRate);      if (exchangeRate > maltDataLab.priceTarget()) {       _distributeSupply();     } else {       _startAuction();     }      lastStabilize = block.timestamp;   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L211-L246  ```solidity=211{228-230,244}   function _distributeSupply() internal {     if (supplyDistributionController != address(0)) {       bool success = ISupplyDistributionController(supplyDistributionController).check();       if (!success) {         return;       }     }      uint256 priceTarget = maltDataLab.priceTarget();     uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);      if (tradeSize == 0) {       return;     }      uint256 swingAmount = swingTrader.sellMalt(tradeSize); // @Auditor: At this time, a market operation occurred, affecting the reserveRatio      if (swingAmount >= tradeSize) {       return;     }      tradeSize = tradeSize - swingAmount;      malt.mint(address(dexHandler), tradeSize);     emit MintMalt(tradeSize);     uint256 rewards = dexHandler.sellMalt();      auctionBurnReserveSkew.addAbovePegObservation(tradeSize);      uint256 remaining = _replenishLiquidityExtension(rewards);      _distributeRewards(remaining);      maltDataLab.trackReserveRatio();     impliedCollateralService.claim();   } ```  ### Recommendation  Consider moving `maltDataLab.trackReserveRatio()` from `_distributeSupply()`, `_startAuction()` to `stabilize()` before L173.  
# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L135-L141  ```solidity=135   function _notSameBlock() internal {     require(       block.number > lastBlock[_msgSender()],       "Can't carry out actions in the same block"     );     lastBlock[_msgSender()] = block.number;   } ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L223-L223 ```solidity=223 require(!auction.active, "Cannot claim tokens on an active auction"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L230-L230 ```solidity=230 require(redemption <= remaining.add(1), "Cannot claim more tokens than available"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L659-L659 ```solidity=659 require(auction.startingTime > 0, "No auction available for the given id"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L177-L177 ```solidity=177 require(!active, "Cannot exit early on an active auction"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L136-L136 ```solidity=136 require(_index > replenishingIndex, "Cannot replenishingIndex to old value"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L56-L56 ```solidity=56 require(block.timestamp >= getEpochStartTime(epoch + 1), "Cannot advance epoch until start of new epoch"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L81-L81 ```solidity=81 require(balance >= value, "ERC20Permit: transfer amount exceeds balance"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L122-L122 ```solidity=122 require(balance >= value, "ERC20Permit: transfer amount exceeds balance"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Malt.sol#L65-L65 ```solidity=65 require(_service != address(0), "Cannot use address 0 as transfer service"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L412-L412 ```solidity=412 require(_sampleLength > 0, "Cannot have 0 second sample length"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L154-L154 ```solidity=154 require(forfeited <= _globals.declaredBalance, "Cannot forfeit more than declared"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L275-L275 ```solidity=275 require(amount <= _globals.declaredBalance, "Can't decrement more than total reward balance"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L118-L121 ```solidity=118     require(       eta >= block.timestamp.add(delay),       "Timelock::queueTransaction: Estimated execution block must satisfy delay."     ); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L165-L176 ```solidity=165     require(       queuedTransactions[txHash],       "Timelock::executeTransaction: Transaction hasn't been queued."     );     require(       block.timestamp >= eta,       "Timelock::executeTransaction: Transaction hasn't surpassed time lock."     );     require(       block.timestamp <= eta.add(gracePeriod),       "Timelock::executeTransaction: Transaction is stale."     ); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L195-L198 ```solidity=195     require(       success,       "Timelock::executeTransaction: Transaction execution reverted."     ); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L114-L132  ```solidity=114 function unbondAndBreak(uint256 amount)     external   {     require(amount > 0, "Cannot unbond 0");      uint256 bondedBalance = balanceOfBonded(msg.sender);      require(bondedBalance > 0, "< bonded balance");     require(amount <= bondedBalance, "< bonded balance");      // Avoid leaving dust behind     if (amount.add(1e16) > bondedBalance) {       amount = bondedBalance;     }      miningService.onUnbond(msg.sender, amount);      _unbondAndBreak(amount);   } ```  L121, the check of `bondedBalance > 0` is unnecessary, since the L122 already included the same check.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L118-L127  ```solidity=118{121-122, 124}   function transferAndCall(address to, uint value, bytes calldata data) external returns (bool) {     require(to != address(0) || to != address(this));      uint256 balance = balanceOf(msg.sender);     require(balance >= value, "ERC20Permit: transfer amount exceeds balance");      _transfer(msg.sender, to, value);      return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);   } ```  L121-L122, the check of `balance >= value` is unnecessary, since the L124 already included the same check.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L424-L442  ```solidity=424   function setSampleMemory(uint256 _sampleMemory)     external     onlyRole(ADMIN_ROLE, "Must have admin privs")   {     require(_sampleMemory > 0, "Cannot have sample memroy of 0");      if (_sampleMemory > sampleMemory) {       for (uint i = sampleMemory; i < _sampleMemory; i++) {         samples.push();       }       counter = counter % _sampleMemory;     } else {       activeSamples = _sampleMemory;        // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST     }      sampleMemory = _sampleMemory;   } ```  In the current implementation, when `sampleMemory` is updated, the samples index will be malposition, making `getValueWithLookback()` get the wrong samples, so that returns the wrong value.  ## PoC  -  When initial sampleMemory is `10` -  After `movingAverage.update(1e18)` being called for 120 times -  The admin calls `movingAverage.setSampleMemory(118)` and set sampleMemory to `118`  The current `movingAverage.getValueWithLookback(sampleLength * 10)` returns `0.00000203312 e18`, while it's expeceted to be `1e18`  After `setSampleMemory()`, `getValueWithLookback()` may also return `0`or revert FullMath: FULLDIV_OVERFLOW at L134.  ### Recommendation  Consider removing `setSampleMemory` function.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L136-L141  ```solidity if (profit > 0) {     uint256 lpCut = profit.mul(lpProfitCut).div(1000);      collateralToken.safeTransfer(address(rewardThrottle), lpCut);     rewardThrottle.handleReward();   } ```  Given that `lpProfitCut` can be `0`, checking if `lpProfitCut > 0` can avoid unnecessary code execution (including external calls) and save some gas.  
# Handle  WatchPug   # Vulnerability details  Checking `uint256` variables >= 0 is redundant as they always >= 0.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L169-L172  ```solidity function setLpProfitCut(uint256 _profitCut) public onlyRole(ADMIN_ROLE, "Must have admin privs") {     require(_profitCut >= 0 && _profitCut <= 1000, "Must be between 0 and 100%");     lpProfitCut = _profitCut;     } ```  `_profitCut >= 0` at L170.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77  ```solidity function setDelay(uint256 _delay)     public     onlyRole(GOVERNOR_ROLE, "Must have timelock role")   {     require(       _delay >= 0 && _delay < gracePeriod,       "Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod"     );     delay = _delay;      emit NewDelay(delay);   } ```  `_delay >= 0` at L71.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L238-L242  ```solidity=238     if (amountTokens > unclaimedArbTokens) {       unclaimedArbTokens = 0;     } else {       unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);     } ```  `unclaimedArbTokens - amountTokens` will never underflow.  ### Recommendation  Change to:  ```solidity=238     if (amountTokens >= unclaimedArbTokens) {       unclaimedArbTokens = 0;     } else {       unclaimedArbTokens -= amountTokens;     } ```    https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L76-L80  ```solidity=76 if (premiumExcess > maxBurnSpend) {   return premiumExcess; }  uint256 usableExcess = maxBurnSpend.sub(premiumExcess); ```  `maxBurnSpend - premiumExcess` will never underflow.  ### Recommendation  Change to:  ```solidity=76 if (premiumExcess > maxBurnSpend) {   return premiumExcess; }  uint256 usableExcess = maxBurnSpend - premiumExcess; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L69-L89  ```solidity=69{76,82-84}   function getRealBurnBudget(     uint256 maxBurnSpend,     uint256 premiumExcess   ) public view returns(uint256) {     // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement     // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn      if (premiumExcess > maxBurnSpend) {       return premiumExcess;     }      uint256 usableExcess = maxBurnSpend.sub(premiumExcess);      if (usableExcess == 0) {       return premiumExcess;     }      uint256 burnable = consult(usableExcess);      return premiumExcess + burnable;   } ```  L82-84 `if (maxBurnSpend == premiumExcess)` can be combined with L76-78.  ### Recommendation  Change to:  ```solidity=69{76}   function getRealBurnBudget(     uint256 maxBurnSpend,     uint256 premiumExcess   ) public view returns(uint256) {     // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement     // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn      if (premiumExcess >= maxBurnSpend) {       return premiumExcess;     }      uint256 usableExcess = maxBurnSpend.sub(premiumExcess);      uint256 burnable = consult(usableExcess);      return premiumExcess + burnable;   } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L131-L140  ```solidity=131     uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;     if (progressionBps > 10000) {         progressionBps = 10000;     }      if (fullReturn > amount) {         // Allow a % of profit to be realised         uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;         return amount + maxProfit;     } ```  If we assume that `maxEarlyExitBps` is 200 and `cooloffPeriod` is 1 day, when `progressionBps` less than 50, `(maxEarlyExitBps * progressionBps / 10000)` will be 0 due to precision loss, which resulted in `maxProfit` is 0.  When `maxEarlyExitBps` is set smaller, the margin of error will be even larger.  # POC  Given:  - Current price of arb token is 0.8 DAI  1. Alice calls `purchaseArbitrageTokens()` and purchase with 8,000 DAI; 2. 7 mins later, the market price of MALT become 0.9 DAI; Alice calls `exitEarly()`, it will mint 8,888.88 Malt and receive 8,000 DAI, while it's expected to 8,890 MALT and 8,000.96 DAI.  ### Recommendation  Change to:  ```solidity if (fullReturn > amount) {     // Allow a % of profit to be realised     uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * 1000 * progressionBps / 10000) / 1000 / 1000;     return amount + maxProfit; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132  ```solidity=116   function getPegDeltaFrequency() public view returns (uint256) {     uint256 initialIndex = 0;     uint256 index;      if (count > auctionAverageLookback) {       initialIndex = count - auctionAverageLookback;     }      uint256 total = 0;      for (uint256 i = initialIndex; i < count; ++i) {       index = _getIndexOfObservation(i);       total = total + pegObservations[index];     }      return total * 10000 / auctionAverageLookback;   } ```  ### Recommendation  Change to:  ```solidity=116   function getPegDeltaFrequency() public view returns (uint256) {     uint256 availablePegObservationsCount;     {       uint256 auctionAverageLookback_ = auctionAverageLookback;       uint256 count_ = count;       availablePegObservationsCount = count_ > auctionAverageLookback_ ? auctionAverageLookback_ : count_;     }      uint256 total = 0;     for (uint256 i = 0; i < availablePegObservationsCount; ++i) {       total += pegObservations[i];     }     return total * 10000 / availablePegObservationsCount;   } ```  
# Handle  WatchPug   # Vulnerability details  Using `++i` is more gas efficient than `i++`, especially in a loop.  For example:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L54-L56 ```solidity=54 for (uint i = 0; i < _period; i++) {   pegObservations.push(0); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L193-L195 ```solidity=193 for (uint i = auctionAverageLookback; i < _lookback; i++) {   pegObservations.push(0); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L60-L62 ```solidity=60 for (uint i = 0; i < sampleMemory; i++) {   samples.push(); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L187-L195  ```solidity=187 for (uint256 i = 0; i < sampleMemory; i++ ) {   tempCount += 1;   liveSample = samples[_getIndexOfSample(tempCount)];   liveSample.timestamp = currentTimestamp;   liveSample.cumulativeValue = currentCumulative;    currentCumulative += addition;   currentTimestamp += uint64(sampleLength); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L292-L300 ```solidity=292 for (uint256 i = 0; i < sampleMemory; i++ ) {   tempCount += 1;   liveSample = samples[_getIndexOfSample(tempCount)];   liveSample.timestamp = currentTimestamp;   liveSample.cumulativeValue = currentCumulative;    currentCumulative += addition;   currentTimestamp += uint64(sampleLength); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L431-L433 ```solidity=431 for (uint i = sampleMemory; i < _sampleMemory; i++) {   samples.push(); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/libraries/UniswapV2Library.sol#L66-L69 ```solidity=66 for (uint i; i < path.length - 1; i++) {     (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);     amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132  ```solidity=116{131}   function getPegDeltaFrequency() public view returns (uint256) {     uint256 initialIndex = 0;     uint256 index;      if (count > auctionAverageLookback) {       initialIndex = count - auctionAverageLookback;     }      uint256 total = 0;      for (uint256 i = initialIndex; i < count; ++i) {       index = _getIndexOfObservation(i);       total = total + pegObservations[index];     }      return total * 10000 / auctionAverageLookback;   } ```  When `count < auctionAverageLookback`, at L131, it should be `return total * 10000 / count;`. The current implementation will return a smaller value than expected.  The result of `getPegDeltaFrequency()` will be used for calculating `realBurnBudget` for auctions. With the result of `getPegDeltaFrequency()` being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.  
# Handle  WatchPug   # Vulnerability details  The default `upperStabilityThreshold` and `lowerStabilityThreshold` assumes that `rewardToken.decimals()` is 18.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L32-L33  ```solidity=32   uint256 public upperStabilityThreshold = (10**18) / 100; // 1%   uint256 public lowerStabilityThreshold = (10**18) / 100; ```  When the `StabilizerNode.sol` contract is initialized with a rewardToken with decimals of 8 (eg. USDC). `upperThreshold` and `lowerThreshold` will be much larger than expected.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L198-L206 ```solidity   function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {     uint256 decimals = rewardToken.decimals();     uint256 priceTarget = maltDataLab.priceTarget();      uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals); ```  ### Recommendation  Consider changing to:  ```solidity   uint256 public upperStabilityThresholdBps = 100; // 1%   uint256 public lowerStabilityThresholdBps = 100; ```  ```solidity   function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {     uint256 decimals = rewardToken.decimals();     uint256 priceTarget = maltDataLab.priceTarget();      uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10000);     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10000); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardReinvestor.sol#L62-L76  ```solidity=62 function provideReinvest(uint256 rewardLiquidity) external {     _retrieveReward(rewardLiquidity);      uint256 rewardBalance = rewardToken.balanceOf(address(this));      // This is how much malt is required     uint256 maltLiquidity = dexHandler.getOptimalLiquidity(address(malt), address(rewardToken), rewardBalance);      // Transfer the remaining Malt required     malt.safeTransferFrom(msg.sender, address(this), maltLiquidity);      _bondAccount(msg.sender);      emit ProvideReinvest(msg.sender, rewardLiquidity);   } ```  `_retrieveReward` will call `MiningService.sol#withdrawRewardsForAccount()` which uses `amount` as max withdrawnAmount, if there are no enough rewards, the actual rewarded amount will be less than `amount`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MiningService.sol#L155-L179  ```solidity=155 function withdrawRewardsForAccount(address account, uint256 amount)     public     onlyRole(REINVESTOR_ROLE, "Must have reinvestor privs")   {     _withdrawMultiple(account, amount);   }    /*    * INTERNAL FUNCTIONS    */   function _withdrawMultiple(address account, uint256 amount) internal {     for (uint i = 0; i < mines.length; i = i + 1) {       if (!mineActive[mines[i]]) {         continue;       }        uint256 withdrawnAmount = IRewardMine(mines[i]).withdrawForAccount(account, amount, msg.sender);        amount = amount.sub(withdrawnAmount);        if (amount == 0) {         break;       }     }   } ```  ### Recommendation  Consider using `rewardBalance` as the value of the `reward` parameter.  
# Handle  0x0x0x   # Vulnerability details  ## Concept  In `MovingAverage.sol`, `uint64` is used for computation of time etc. But computations with `uint64` does cost more gas and furthermore `block.timestamp` is `uint256`, which is additionally casted to `uint64`. `uint32` is used for indexes, but this can also be changed with `uint256`.  Same applies for `RewardDistributer.sol.`  ## Recommendation  Use `uint256` rather than custom `uint`.  
# Handle  0x0x0x   # Vulnerability details  ## Concept  [https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L200-L212](https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L200-L212):  ```   uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;     if (progressionBps > 10000) {       progressionBps = 10000;     }      if (fullReturn > amount) {       // Allow a % of profit to be realised       uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;       uint256 desiredReturn = amount + maxProfit;       maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;     }       return maltQuantity; ```  `progressionBps` is only used, if there is a profit. Calculations of this parameter should be under if statement checking whether there is a profit to save gas and increase readability as follows:  ```      if (fullReturn > amount) {       // Allow a % of profit to be realised    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;      if (progressionBps > 10000) {        progressionBps = 10000;      }       uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;       uint256 desiredReturn = amount + maxProfit;       maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;     }       return maltQuantity; ```  
# Handle  WatchPug   # Vulnerability details  Unused storage variables in contracts use up storage slots and increase contract size and gas usage at deployment and initialization.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L57-L57 ```solidity=57 address public uniswapV2Factory; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L80-L86  ```solidity=80 function emergencyWithdrawGAS(address payable destination)     external      onlyRole(TIMELOCK_ROLE, "Only timelock can assign roles")   {     // Transfers the entire balance of the Gas token to destination     destination.call{value: address(this).balance}('');   } ```  The error message "Only timelock can assign roles" can be changed to "Only timelock can emergencyWithdrawGAS".  Other examples include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L104-L110  ```solidity=104 function partialWithdraw(address _token, address destination, uint256 amount)     external      onlyRole(TIMELOCK_ROLE, "Only timelock can assign roles")   {     ERC20 token = ERC20(_token);     token.safeTransfer(destination, amount);   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L94-L94  ```solidity=94 require(_pool != address(0), "Cannot have 0 lookback"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L230-L230  ```solidity=230 require(_period > 0, "Cannot have 0 lookback period"); ```  
# Handle  0x0x0x   # Vulnerability details  ## Impact  In case the reward token is changed, `totalDeclaredReward` will be changed and likely equal to `0`.  Since `_userStakePadding` and `_globalStakePadding` are accumulated, changing the reward token will not reset those values. Thus, it will create problems.  ## Recommendation  I think it would be the best to remove this function.   If you want to keep it, then it must have an event and it should be used by a timelock contract. Furthermore, it has to be used carefully and the new token should be distributed such that padding variables still make sense.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L112-L116  ```solidity=112   function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool) {     _approve(msg.sender, spender, value);      return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);   } ```  ```solidity=208 function _transfer(address sender, address recipient, uint256 amount) internal virtual {     require(sender != address(0), "ERC20: transfer from the zero address");     require(recipient != address(0), "ERC20: transfer to the zero address");      _beforeTokenTransfer(sender, recipient, amount);      _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");     _balances[recipient] = _balances[recipient].add(amount);     emit Transfer(sender, recipient, amount); } ```  Using approve() to manage allowances opens yourself and users of the token up to frontrunning. Best practice, but doesn't usually matter.  [Explanation](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit) of this possible attack vector  See also: [0xProject/0x-monorepo#850](https://github.com/0xProject/0x-monorepo/issues/850)  Using increase/decreaseAllowance instead is recommended.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L154-L154  ```solidity=154 uint64 blockTimestamp = uint64(block.timestamp % 2**64);  ```  Use `uint64(n)` can cut off higher-order bits already, `n % 2**64` is redundant.  See: https://docs.soliditylang.org/en/v0.8.10/types.html#explicit-conversions  ### Recommendation  Change to:  ```solidity=154 uint64 blockTimestamp = uint64(block.timestamp);  ```  
# Handle  0x0x0x   # Vulnerability details  ## Impact  `!= 0` is a cheaper operation compared to `> 0`, when dealing with `uint`.  ## Occurences  ```  ./AbstractRewardMine.sol:147:    if (rewardDenominator > 0) { ./Auction.sol:219:    require(amountTokens > 0, "No claimable Arb tokens"); ./Auction.sol:265:    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments); ./Auction.sol:385:    return auction.startingTime > 0; ./Auction.sol:639:    if (realBurnBudget > 0) { ./Auction.sol:659:    require(auction.startingTime > 0, "No auction available for the given id"); ./Auction.sol:663:    if (auction.maltPurchased > 0) { ./Auction.sol:861:          if (auction.commitments > 0 || !auction.finalized) { ./Auction.sol:894:    require(_length > 0, "Length must be larger than 0"); ./Auction.sol:972:    require(_split > 0 && _split <= 10000, "Must be between 0-100%"); ./Auction.sol:980:    require(_maxEnd > 0 && _maxEnd <= 1000, "Must be between 0-100%"); ./Auction.sol:988:    require(_lookback > 0, "Must be above 0"); ./Auction.sol:996:    require(_lookback > 0, "Must be above 0"); ./Auction.sol:1004:    require(_bps > 0 && _bps < 1000, "Must be between 0-100%"); ./Auction.sol:1012:    require(_threshold > 0, "Must be between greater than 0"); ./AuctionBurnReserveSkew.sol:109:    if (aggregate.maxCommitments > 0) { ./AuctionBurnReserveSkew.sol:190:    require(_lookback > 0, "Cannot have zero lookback period"); ./AuctionEscapeHatch.sol:191:    require(amount > 0, "Nothing to claim"); ./AuctionEscapeHatch.sol:222:    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, "Must be between 0-100%"); ./AuctionEscapeHatch.sol:230:    require(_period > 0, "Cannot have 0 lookback period"); ./AuctionPool.sol:118:    if (globalRewarded > 0 && userReward > 0) { ./AuctionPool.sol:125:    if (forfeitAmount > 0) { ./AuctionPool.sol:129:    if (declaredRewardDecrease > 0) { ./AuctionPool.sol:141:    if (forfeitedRewards > 0) { ./Bonding.sol:87:    require(amount > 0, "Cannot bond 0"); ./Bonding.sol:97:    require(amount > 0, "Cannot unbond 0"); ./Bonding.sol:101:    require(bondedBalance > 0, "< bonded balance"); ./Bonding.sol:117:    require(amount > 0, "Cannot unbond 0"); ./Bonding.sol:121:    require(bondedBalance > 0, "< bonded balance"); ./Bonding.sol:283:      if (diff > 0) { ./DAO.sol:47:    if (offeringMint > 0) { ./DAO.sol:78:    require(amount > 0, "Cannot have zero amount"); ./DAO.sol:94:    require(_length > 0, "Cannot have zero length epochs"); ./ERC20VestedMine.sol:93:    if (globalRewarded > 0 && userReward > 0) { ./ERC20VestedMine.sol:115:    if (forfeitReward > 0) { ./ERC20VestedMine.sol:119:    if (declaredRewardDecrease > 0) { ./ForfeitHandler.sol:49:    if (swingTraderCut > 0) { ./ForfeitHandler.sol:53:    if (treasuryCut > 0) { ./ImpliedCollateralService.sol:64:    if (maxAmount > 0) { ./ImpliedCollateralService.sol:68:    if (maxAmount > 0) { ./ImpliedCollateralService.sol:71:      // if (maxAmount > 0) { ./ImpliedCollateralService.sol:74:      //   if (maxAmount > 0) { ./LiquidityExtension.sol:161:    require(_ratio > 0 && _ratio <= 100, "Must be between 0 and 100"); ./MaltDataLab.sol:234:    require(_price > 0, "Cannot have 0 price"); ./MaltDataLab.sol:242:    require(_lookback > 0, "Cannot have 0 lookback"); ./MaltDataLab.sol:250:    require(_lookback > 0, "Cannot have 0 lookback"); ./MaltDataLab.sol:258:    require(_lookback > 0, "Cannot have 0 lookback"); ./MovingAverage.sol:385:    if (oldSample.timestamp > 0 && activeSamples > 1) { ./MovingAverage.sol:412:    require(_sampleLength > 0, "Cannot have 0 second sample length"); ./MovingAverage.sol:428:    require(_sampleMemory > 0, "Cannot have sample memroy of 0"); ./PoolTransferVerification.sol:76:    require(newThreshold > 0 && newThreshold < 10000, "Threshold must be between 0-100%"); ./PoolTransferVerification.sol:85:    require(lookback > 0, "Cannot have 0 lookback"); ./RewardReinvestor.sol:93:    require(rewardLiquidity > 0, "Cannot reinvest 0"); ./RewardReinvestor.sol:115:    if (maltBalance > 0) { ./RewardReinvestor.sol:119:    if (rewardTokenBalance > 0) { ./RewardSystem/RewardDistributor.sol:144:    require(reward > 0, "Cannot declare 0 reward"); ./RewardSystem/RewardDistributor.sol:266:    if (amount > 0) { ./RewardSystem/RewardDistributor.sol:277:    if (amount > 0) { ./RewardSystem/RewardOverflowPool.sol:76:    require(_maxFulfillment > 0, "Can't have 0 max fulfillment"); ./RewardSystem/RewardThrottle.sol:85:    if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) { ./RewardSystem/RewardThrottle.sol:89:      if (remainder > 0) { ./RewardSystem/RewardThrottle.sol:271:          if (underflow > 0) { ./RewardSystem/RewardThrottle.sol:323:    require(_smoothingPeriod > 0, "No zero smoothing period"); ./StabilizerNode.sol:270:    if (callerCut > 0) { ./StabilizerNode.sol:274:    if (auctionPoolCut > 0) { ./StabilizerNode.sol:278:    if (swingTraderCut > 0) { ./StabilizerNode.sol:282:    if (treasuryCut > 0) { ./StabilizerNode.sol:286:    if (daoCut > 0) { ./StabilizerNode.sol:290:    if (lpCut > 0) { ./StabilizerNode.sol:359:    require(_period > 0, "Must be greater than 0"); ./StabilizerNode.sol:406:    require(_incentive > 0, "No negative incentive"); ./StabilizerNode.sol:417:    require(amount > 0, "No negative damping"); ./StabilizerNode.sol:449:    require(_upper > 0 && _lower > 0, "Must be above 0"); ./StabilizerNode.sol:488:    require(_maxContribution > 0 && _maxContribution <= 100, "Must be between 0 and 100"); ./StabilizerNode.sol:552:    require(_period > 0, "Cannot have 0 period"); ./StabilizerNode.sol:561:    require(_distance > 0 && _distance < 1000, "Override must be between 0-100%"); ./StabilizerNode.sol:570:    require(_period > 0, "Cannot have 0 period"); ./SwingTrader.sol:136:    if (profit > 0) { ./libraries/SafeBurnMintableERC20.sol:70:        if (returndata.length > 0) { // Return data is optional ./libraries/UniswapV2Library.sol:37:        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); ./libraries/UniswapV2Library.sol:38:        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:44:        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); ./libraries/UniswapV2Library.sol:45:        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:54:        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); ./libraries/UniswapV2Library.sol:55:        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) {  ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L356-L360  ```solidity=356   function _getCurrentSample() private view returns (Sample storage currentSample) {     // Active sample is always counter - 1. Counter is the in progress sample     uint32 currentSampleIndex = _getIndexOfSample(counter - 1);     currentSample = samples[currentSampleIndex];   } ```  The local variable `currentSampleIndex` is used only once. Making the expression inline can save gas.  Similar issue exists in `_getFirstSample()`, `_getNthSample()`, `AuctionBurnReserveSkew.sol#getRealBurnBudget()`, `MovingAverage.sol#_getFirstSample()`.  ### Recommendation  Change to:  ```solidity=356   function _getCurrentSample() private view returns (Sample storage currentSample) {     // Active sample is always counter - 1. Counter is the in progress sample     currentSample = samples[_getIndexOfSample(counter - 1)];   } ```  
# Handle  0x0x0x   # Vulnerability details  ## Vulnerability  `AuctionEschapeHatch.sol#exitEarly` takes as input `amount` to represent how much of the   When the user exits an auction with profit, to apply the profit penalty less `maltQuantity` is liquidated compared to how much malt token the liquidated amount corresponds to. The problem is `auction.amendAccountParticipation()` simply subtracts the malt quantity with penalty and full `amount` from users auction stats. This causes a major problem, since in `_calculateMaltRequiredForExit` those values are used for calculation by calculating maltQuantity as follow:  `uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);`   The ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking (since penalty is applied to substracted `maltQuantity` from `userMaltPurchased`), by doing so a user can earn more than it should. Since after each profit taking users commitment corresponds to proportionally more malt, the user can even reduce profit penalties by dividing `exitEarly` calls in several calls.  In other words, the ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking and user can claim more malt with less commitment. Furthermore after all `userMaltPurchased` is claimed the user can have `userCommitment` left over, which can be used to `claimArbitrage`, when possible.  ## Mitigation Step  Make sure which values are used for what and update values which doesn't create problems like this. Rethink about how to track values of an auction correctly.  
# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style of function names does not follow the best practices:  - MaltDAO#incrementEpoch()      https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L106-L119  ```solidity=106{107} /* Internal methods */ function incrementEpoch() internal {     epoch = epoch.add(1); }  function _setEpochLength(uint256 length) internal {     epochLength = length;     emit SetEpochLength(length); }  function _setMaltToken(address _malt) internal {     malt = IBurnMintableERC20(_malt);     emit SetMaltToken(_malt); } ```  
# Handle  WatchPug   # Vulnerability details  The purpose of a Timelock contract is to put a limit on the privileges of the `governor`, by forcing a two step process with a preset delay time.  However, we found that the current implementation actually won't serve that purpose as it allows the `governor` to execute any transactions without any constraints.  To do that, the current governor can call `Timelock#setGovernor(address _governor)` and set a new `governor` effective immediately.  And the new `governor` can then call `Timelock#setDelay()` and change the delay to `0`, also effective immediately.  The new `governor` can now use all the privileges without a delay, including granting minter role to any address and mint unlimited amount of MALT.  In conclusion, a Timelock contract is supposed to guard the protocol from lost private key or malicious actions. The current implementation won't fulfill that mission.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L98-L105 ```solidity=98{100,102-103}   function setGovernor(address _governor)     public     onlyRole(GOVERNOR_ROLE, "Must have timelock role")   {     _swapRole(_governor, governor, GOVERNOR_ROLE);     governor = _governor;     emit NewGovernor(_governor);   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77 ```solidity=66{71,74}   function setDelay(uint256 _delay)     public     onlyRole(GOVERNOR_ROLE, "Must have timelock role")   {     require(       _delay >= 0 && _delay < gracePeriod,       "Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod"     );     delay = _delay;      emit NewDelay(delay);   } ```   ## Recommendation  Consider making `setGovernor` and `setDelay` only callable from the Timelock contract itself.  Specificaly, changing from `onlyRole(GOVERNOR_ROLE, "Must have timelock role")` to `require(msg.sender == address(this), "...")`.  Also, consider changing `_adminSetup(_admin)` in `Timelock#initialize()` to `_adminSetup(address(this))`, so that all roles are managed by the timelock itself as well.  
# Handle  cmichel   # Vulnerability details  When adding liquidity through `UniswapHandler.addLiquidity`, the entire contract balances are used to add liquidity and the min amounts are set to 95% of these balances. If the balances in this contract are unbalanced (the ratio is not similar to the current Uniswap pool reserve ratios) then this function will revert and no liquidity is added.  See `UniswapHandler.buyMalt`:  ```solidity (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(   address(malt),   address(rewardToken),   maltBalance, // @audit-info amountADesired   rewardBalance,   // @audit assumes that whatever is in this contract is already balanced. good assumption?   maltBalance.mul(95).div(100), // @audit-info amountAMin   rewardBalance.mul(95).div(100),   msg.sender, // transfer LP tokens to sender   now ); ```  ## Impact If the contract has unbalanced balances, then the `router.addLiquidity` call will revert. Note that an attacker could even send tokens to this contract to make them unbalanced and revert, resulting in a griefing attack.  ## Recommended Mitigation Steps It needs to be ensured that the balances in the contract are always balanced and match the current reserve ratio. It might be better to avoid directly using the balances which can be manipulated by transferring tokens to the contract and accepting parameters instead of how many tokens to provide liquidity with from the caller side.  
# Handle  cmichel   # Vulnerability details  The `UniswapHandler.maltMarketPrice` function returns a tuple of the `price` and the `decimals` of the price. However, the returned `decimals` do not match the computed `price` for the `else if (rewardDecimals < maltDecimals)` branch:  ```solidity else if (rewardDecimals < maltDecimals) {   uint256 diff = maltDecimals - rewardDecimals;   price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);   decimals = maltDecimals; } ```  Note that `rewardReserves` are in reward token decimals, `maltReserves` is a malt balance amount (18 decimals). Then, the returned amount is in `rewardDecimals + diffDecimals + rewardDecimals - maltDecimals = maltDecimals + rewardDecimals - maltDecimals = rewardDecimals`. However `decimals = maltDecimals` is wrongly returned.  ## Impact Callers to this function will receive a price in unexpected decimals and might inflate or deflate the actual amount. Luckily, the `AuctionEscapeHatch` decides to completely ignore the returned `decimals` and as all prices are effectively in `rewardDecimals`, even if stated in `maltDecimals`, it currently does not seem to lead to an issue.  ## Recommendation Fix the function by returning `rewardDecimals` instead of `maltDecimals` in the `rewardDecimals < maltDecimals` branch.  
# Handle  cmichel   # Vulnerability details  The `MovingAverage.sol` contract defines several variables that in the end make the `samples` array act as a ring buffer: - `sampleMemory`: The total length (buffer size) of the `samples` array. `samples` is initialized with `sampleMemory` zero observations. - `counter`: The pending sample index (modulo `sampleMemory`)  The `_getFirstSample` function computes the first sample as `(counter + 1) % sampleMemory` which returns the correct index only _if the ring buffer is full_, i.e., it wraps around. (in the `counter + 1 >= sampleMemory`).  If the `samples` array does not wrap around yet, the zero index should be returned instead.  ## Impact Returning `counter + 1` if `counter + 1 < sampleMemory` returns a zero initialized `samples` observation index. This then leads to a wrong computation of the TWAP.  ## Recommended Mitigation Steps Add an additional check for `if (counter + 1 < sampleMemory) return 0` in `_getFirstSample`.  
# Handle  cmichel   # Vulnerability details  Certain ERC20 tokens make modifications to their ERC20's `transfer` or `balanceOf` functions. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.  ## Impact The `Bonding._bond()` function will revert in the `_balanceCheck` when transferring a fee-on-transfer token as it assumes the entire `amount` was received.  ## Recommended Mitigation Steps To support fee-on-transfer tokens, measure the asset change right before and after the asset-transferring calls and use the difference as the actual bonded amount.  
# Handle  cmichel   # Vulnerability details  The `Permissions.reassignGlobalAdmin` function is supposed to only be run with the `TIMELOCK_ROLE` role, see `onlyRole(TIMELOCK_ROLE, "Only timelock can assign roles")`.  However, the `TIMELOCK_ROLE` is not the admin of all the reassigned roles and the `revokeRole(role, oldAccount)` calls will fail as it requires the `ADMIN_ROLE`.  ## Recommended Mitigation Steps The idea might have been that only the `TIMELOCK` should be able to call this function, and usually it is also an admin, but the function strictly does not work if the caller _only_ has the `TIMELOCK` roll and will revert in this case. Maybe governance decided to remove the admin role from the Timelock, which makes it impossible to call `reassignGlobalAdmin` anymore as both the timelock and admin are locked out.  
# Handle  cmichel   # Vulnerability details  The initial `SetTransferService` event in `Malt.initialize` is not emitted.  ## Impact Off-chain programs might not correctly track the initial `transferService` variable as the initial event is missing.  ## Recommended Mitigation Steps Emit it in `initialize`.  
# Handle  cmichel   # Vulnerability details  The `ERC20.approve()` function returns a boolean value indicating success. This parameter needs to be checked for success. Some tokens do **not** revert if the transfer failed but return `false` instead.  In addition, some tokens (like [USDT L199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ```solidity IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  This issue exists for example in `AuctionParticipant.purchaseArbitrageTokens`:  ```solidity auctionRewardToken.approve(address(auction), balance); ```  As well as in `UniswapHandler.buyMalt`:  ```solidity rewardToken.approve(address(router), rewardBalance); ```  ## Impact Tokens that don't correctly implement the latest EIP20 spec, by either returning `false` on failure or reverting if approved from a non-zero value, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelins `SafeERC20` versions with the `safeApprove(0)` functions that handle the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  The `initialize` function that initializes important contract state can be called by anyone. See: - `ERC20VestedMine.initialize` - `AuctionPool.initialize` - all contracts that extend `Permissions`  ## Impact The attacker can initialize the contract before the legitimate deployer, hoping that the victim continues to use the same contract. In the best case for the victim, they notice it and have to redeploy their contract costing gas.  ## Recommended Mitigation Steps Use the constructor to initialize non-proxied contracts. For initializing proxy contracts deploy contracts using a factory contract that immediately calls `initialize` after deployment or make sure to call it immediately after deployment and verify the transaction succeeded.  
# Handle  WatchPug   # Vulnerability details  It's a best practice for the contract implementations to inherit their interface definition.  Doing so would improve the contract's clarity, and force the implementation to comply with the defined interface.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/TransferService.sol#L14-L14 ```solidity=14 contract TransferService is Initializable, Permissions { ```  `TransferService` should inherit `ITransferService`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L20-L20  ```solidity=20 contract UniswapHandler is Initializable, Permissions { ```  `UniswapHandler` should inherit `IDexHandler`.  
# Handle  harleythedog   # Vulnerability details  ## Impact In Bonding.sol, the internal function `_unbondAndBreak` transfers a user's stake tokens to the dexHandler and then calls `removeLiquidity` on the dexHandler. Within the Uniswap handler (which is the only handler so far) `removeLiquidity` takes special care in the edge case where `router.removeLiquidity` returns zero tokens. Specifically, the Uniswap handler has this code: ``` if (amountMalt == 0 || amountReward == 0) {  liquidityBalance = lpToken.balanceOf(address(this));  lpToken.safeTransfer(msg.sender, liquidityBalance);  return (amountMalt, amountReward); } ```  If this edge case does indeed happen (i.e. if something is preventing the Uniswap router from removing liquidity at the moment), then the Uniswap handler will transfer the LP tokens back to Bonding.sol. However, Bonding.sol does not have any logic to recognize that this happened, so the LP tokens will become stuck in the contract and the user will never get any of their value back. This could be very bad if the user unbonds a lot of LP and they don't get any of it back.  ## Proof of Concept See `_unbondAndBreak` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L226  Notice how the edge case where `amountMalt == 0 || amountReward == 0` is not considered in this function, but it is considered in the Uniswap handler's `removeLiquidity` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L240  ## Tools Used Inspection.  ## Recommended Mitigation Steps Add a similar edge case check to `_unbondAndBreak`. In the case where LP tokens are transferred back to Bonding.sol instead of malt/reward, these LP tokens should be forwarded back to the user since the value is rightfully theirs.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `permit` function is intended to facilitate approvals though signature verification. This helps to merge the two-step token transfer process consisting of an initial token approval and subsequent transfer. The `permit` function emits an `Approval` event, however, the `_approve` function also emits the same `Approval` event. As a result, off-chain scripts monitoring the blockchain for such events will see the same event emitted twice which may cause unintended issues.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ERC20Permit.sol#L58-L59 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L314  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider not emitting an `Approval` event in `permit`.  
# Handle  leastwood   # Vulnerability details  ## Impact  `_distributeRewards` attempts to reward LP token holders when the price of Malt exceeds its price target. Malt Finance is able to being Malt back to its peg by selling Malt and distributing rewards tokens to LP token holders. An external call to `Auction` is made via the `allocateArbRewards` function. Prior to this call, the `StabilizerNode` approves the contract for a fixed amount of tokens, however, the `allocateArbRewards` function does not necessarily utilise this entire amount. Hence, dust token approval amounts may accrue from within the `StabilizerNode` contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L252-L253 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L809-L871  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider resetting the approval amount if the input `rewarded` amount to `allocateArbRewards` is less than the output amount.  
# Handle  leastwood   # Vulnerability details  ## Impact  `addLiquidity` is called when users reinvest their tokens through bonding events. The `RewardReinvestor` first transfers Malt and rewards tokens before adding liquidity to the token pool. `addLiquidity` provides protections against slippage by a margin of 5%, and any dust token amounts are transferred back to the caller. In this instance, the caller is the `RewardReinvestor` contract which further distributes the dust token amounts to the protocol's treasury. However, the token approval for this outcome is not handled properly. Dust approval amounts can accrue over time, leading to large Uniswap approval amounts by the `UniswapHandler` contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L212-L214 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L216-L218  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider resetting the approval amount if either `maltUsed < maltBalance` or `rewardUsed < rewardBalance` in `addLiquidity`.  
# Handle  harleythedog   # Vulnerability details  ## Impact There are several ERC20 tokens that take a small fee on transfers/transferFroms (known as "fee-on-transfer" tokens). Most notably, USDT is an ERC20 token that has togglable transfer fees, but for now the fee is set to 0 (see the contract here: https://etherscan.io/address/0xdAC17F958D2ee523a2206206994597C13D831ec7#code). For these tokens, it should not be assumed that if you transfer `x` tokens to an address, that the address actually receives `x` tokens. In the current test environment, DAI is the only `collateralToken` available, so there are no issues. However, it has been noted that more pools will be added in the future, so special care will need to be taken if fee-on-transfer tokens (like USDT) are planned to be used as `collateralTokens`.  For example, consider the function `purchaseArbitrageTokens` in Auction.sol. This function transfers `realCommitment` amount of `collateralToken` to the liquidityExtension, and then calls `purchaseAndBurn(realCommitment)` on the liquidityExtension. The very first line of `purchaseAndBurn(amount)` is `require(collateralToken.balanceOf(address(this)) >= amount, "Insufficient balance");`. In the case of fee-on-transfer tokens, this line will revert due to the small fee taken. This means that all calls to `purchaseArbitrageTokens` will fail, which would be very bad when the price goes below peg, since no one would be able to participate in this auction.  ## Proof of Concept See `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177  See `purchaseAndBurn` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L117  ## Tools Used Inspection  ## Recommended Mitigation Steps Add logic to transfers/transferFroms to calculate exactly how many tokens were actually sent to a specific address. In the example given with `purchaseArbitrageTokens`, instead of calling `purchaseAndBurn` with `realCommitment`, the contract should use the difference in the liquidityExtension balance after the transfer minus the liquidityExtension  balance before the transfer.  
# Handle  thank_you   # Vulnerability details  ## Impact UniswapHandler utilizes UniswapV2Router to swap, add liquidity, and remove liquidity with the UniswapV2Pair contract. In order to utilize these functionalities, UniswapHandler must call various UniswapV2Router methods.  - addLiquidity - removeLiquidity - swapExactTokensForTokens (swaps for both DAI and Malt)  In all three methods, UniswapV2Router requires the callee to provide input arguments that define how much the amount out minimum UniswapHandler will allow for a trade. This argument is designed to prevent slippage and more importantly, sandwich attacks.  UniswapHandler correctly handles price slippage when calling [addLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L201). However, that is not the case for [removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L230) and swapExactTokensForTokens [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) and [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L173). For both methods, 0 is passed in as the amount out minimum allowed for a trade. This allows for anyone watching the mempool to sandwich attack UniswapHandler (or any contract that calls UniswapHandler) in such a way that allows the hacker to profit off of a guaranteed trade.  How does this work? Let's assume UniswapHandler makes a call to [UniswapV2Router#swapExactTokensForTokens](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) to trade DAI for Malt. Any hacker who watches the mempool and sees this transaction can immediately buy as much Malt as they want. This raises the price of Malt. Since UniswapHandler is willing to accept any amount out minimum (the number is set to [zero](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L150)), then the UniswapHandler will always trade DAI for Malt. This second transaction raises the price of Malt even further. Finally, the hacker trades their Malt for DAI, receiving a profit due to the artificially inflated price of Malt from the sandwich attack.  It's important to note that anyone has access to the UniswapV2Router contract. There are no known ACL controls on UniswapV2Router. This sandwich attack can impact even the `buyMalt` function.  The following functions when called are vulnerable to frontrunning attacks:  - [UniswapHandler#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L131) - [UniswapHandler#sellMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L160) - [UniswapHandler#removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221)  And by extension the following contract functions since they also call the UniswapHandler function calls:  - [Bonding#unbondAndBreak](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L114) - [LiquidityExtension#purchaseAndBurn](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117) - [RewardReinvestor#splitReinvest](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L78) - [StabilizerNode#stabilize](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145) - [SwingTrader#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L50)   ## Proof of Concept Refer to the impact section for affected code and links to the appropriate LoC.  ## Tools Used N/A  ## Recommended Mitigation Steps The UniswapV2Router and UniswapV2Pair contract should allow only the UniswapHandler contract to call either contract. In addition, price slippage checks should be implemented whenever removing liquidity or swapping tokens. This ensures that a frontrunning attack can't occur.   ## Anything Else We Should Know I wish I had more time to work on this bug but unfortunately I have several current clients who require significant time from me. I'm happy to pursue this beyond the initial submission, in particular building a concrete PoC. I think the most important takeaway from this bug find is that anyone can purchase Malt at any time and anyone can manipulate the Malt reserve. This in turn impacts other functionalities that rely on the Malt reserve to make price/token calculations such as exiting an auction early or reinvesting rewards.  
# Handle  0xwags   # Vulnerability details  ## Impact Since users forfeited awards will be shared between either the treasury and the swing trader, there should be a zero address in the initialize() function to ensure rewards are not lost and thereby affecting  Malt's collateralisation and other such funding mechanism.   This will have implications for safetransfer() functions in lines 50 & 54 in handleForfeit().   ## Tools Used Manual Analysis.   ## Recommended Mitigation Steps  require(treasuryMultisig&& swingTrader ! =address(0), "0x0");  
# Handle  leastwood   # Vulnerability details  ## Impact  `_calculateMaltRequiredForExit` in `AuctionEscapeHatch` currently uses Malt's spot price to calculate the quantity to return to the exiting user. This spot price simply tracks the Uniswap pool's reserves which can easily be manipulated via a flash loan attack to extract funds from the protocol.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L65-L92 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L193 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L80-L109 https://shouldiusespotpriceasmyoracle.com/  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing/integrating a TWAP oracle to track the price of Malt.  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Reuse the function argument in the event emit instead of the storage variable. This saves a SLOAD.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L82   ## Tools Used  ## Recommended Mitigation Steps - L76 write: emit NewDelay(_delay); - L92: write: emit NewGracePeriod(_gracePeriod);  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Move the initialization of sampleDiff below the if block to save gas in the case of return of the if block.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L128  ## Tools Used  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact move the sampleDiff (L86) below the if statement L88 to save the declaration/initialization of sampleDiff in the case the if block gets executed and the function returns early  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L86 ## Tools Used  ## Recommended Mitigation Steps - move the declaration/initialization of of sampleDiff below the if statement  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Reuse _sampleMemory instead of the storage variable sampleMemory in the condition statement of the loop to save gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L60 ## Tools Used  ## Recommended Mitigation Steps - rewrite L60 as: for (uint i = 0; i < _sampleMemory ; i++)  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L167  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L219  Before call _distributeSupply function, it already get priceTarget, But in _distributeSupply, it again call external call to get price target. This will use higher gas.   ## Tools Used Manual  ## Recommended Mitigation Steps Send price target in _distributeSupply() function argument, and please review all duplicated external calls and optimize them.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact In removeVerifier function, it loop until last index - 1 to find source index. If you added many verifiers, then the gas cost of removeVerifier will be very high, and it can be reverted due to gas limit as well.   ## Tools Used Manual  ## Recommended Mitigation Steps Store index of address in addVerifier function, and remove loop in removeVerifier, and use stored index.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L62 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L78  In addVerifier and removeVerifier functions of TransferService.sol, it just returns instead of revert if it is unable to change data. Revert transaction to avoid creating unnecessary transaction and save transaction cost.   ## Tools Used Manual  ## Recommended Mitigation Steps Revert transaction instead of return.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function bondToAccount() of Bonding.sol has a check based on _notSameBlock()  _notSameBlock() makes sure the same msg.sender cannot do 2 actions within the same block.  However this can be circumvented in this case: Suppose you call bondToAccount() via a (custom) smart contract, then the msg.sender will be the address of the smart contract. For a pseudo code proof of concept see below.  I'm not sure what the deeper reason is for the _notSameBlock() in bondToAccount(). But if it is important then circumventing this check it will pose a risk.  ## Proof of Concept call function attack1.attack() ```JS contract attack1 {    function attack(address account, uint256 amount) {          call attack2.forward(account, amount);          call any other function of malt   } }  contract attack2 {    function forward(address account, uint256 amount) {        call bonding.bondToAccount(account, amount); // uses msg.sender of attack2    } } ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Bonding.sol#L81-L92  ```JS function bondToAccount(address account, uint256 amount) public {     if (msg.sender != offering) {          _notSameBlock();     }     ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Permissions.sol#L135-L141 ```JS function _notSameBlock() internal {     require( block.number > lastBlock[_msgSender()],"Can't carry out actions in the same block" );     lastBlock[_msgSender()] = block.number;   } ```  ## Tools Used  ## Recommended Mitigation Steps Add access controls to the function bondToAccount() An end-user could still call bond()   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setAuctionAverageLookback of AuctionBurnReserveSkew.sol change auctionAverageLookback  However there is also the variable "count" that is used in amongst others, addAbovePegObservation(). The modulo of count with auctionAverageLookback is calculated via _getIndexOfObservation(). When you change auctionAverageLookback then the modulo will result in a different value, so you end up in a different location of the circular buffer.  You should probably adapt count as well in the function setAuctionAverageLookback() (see also function setSampleMemory of MovingAverage.sol where a similar pattern is used)  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L186-L200  ```JS function setAuctionAverageLookback(uint256 _lookback) external onlyRole(ADMIN_ROLE, "Must have admin role") { ..     if (_lookback > auctionAverageLookback) {       for (uint i = auctionAverageLookback; i < _lookback; i++) {         pegObservations.push(0);       }     }      auctionAverageLookback = _lookback;  ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L143-L153 ```JS  function addAbovePegObservation(uint256 amount)  public onlyRole(STABILIZER_NODE_ROLE, "Must be a stabilizer node to call this method") {     uint256 index = _getIndexOfObservation(count);     ...     pegObservations[index] = 1;     count = count + 1; ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L134-L136 ```JS  function _getIndexOfObservation(uint _index) internal view returns (uint index) {     return _index % auctionAverageLookback;   } ```  ## Tools Used  ## Recommended Mitigation Steps Doublecheck the theory above and if you agree: Add the following statement in the function  setAuctionAverageLookback(), before auctionAverageLookback is updated.  ```JS  count = count  % auctionAverageLookback ; // the old version of auctionAverageLookback  ```   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setSampleMemory of MovingAverage.sol takes the modulo of counter with the new value of _sampleMemory: "counter = counter % _sampleMemory;"  Suppose: counter =15 ; sampleMemory=10 and  _sampleMemory=12 Then:   counter = counter % _sampleMemory ==> 3,  which means processing will continue at position 3.  However I think it should use: counter = counter % sampleMemory,  so it will continue at position 5  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/MovingAverage.sol#L424-L442  ```JS function setSampleMemory(uint256 _sampleMemory) external onlyRole(ADMIN_ROLE, "Must have admin privs")  {   ...     if (_sampleMemory > sampleMemory) {       ...       counter = counter % _sampleMemory;     } else {    }     sampleMemory = _sampleMemory; } ```  ## Tools Used  ## Recommended Mitigation Steps Doublecheck the theory above and if you agree: change ```JS  counter = counter % _sampleMemory; ``` to ```JS  counter = counter %  sampleMemory; ```   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setStabilityThresholds of StabilizerNode.sol set the values for upperStabilityThreshold and lowerStabilityThreshold, however there is no check for a maximum value. This means that in function _shouldAdjustSupply() the values for upperThreshold and lowerThreshold  could get larger than priceTarget. When they are subtracted from priceTarget a revert will occur.  Thus it is useful the make sure that upperStabilityThreshold and lowerStabilityThreshold don't get too large.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L445-L454  ```JS function setStabilityThresholds(uint256 _upper, uint256 _lower) external onlyRole(ADMIN_ROLE, "Must have admin role") {     require(_upper > 0 && _lower > 0, "Must be above 0");     upperStabilityThreshold = _upper;     lowerStabilityThreshold = _lower; ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L198-L206  ```JS function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {    ...     uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals); // upperStabilityThreshold could be > 10**dec => upperThreshold could be > priceTarget     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);  // lowerStabilityThreshold could be > 10**dec => lowerThreshold could be > priceTarget      return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold); // can revert   } ```  ## Tools Used  ## Recommended Mitigation Steps In function setStabilityThresholds() check for a maximum value of upperStabilityThreshold and lowerStabilityThreshold  
# Handle  leastwood   # Vulnerability details  ## Impact  `_startAuction` utilises the `SwingTrader` contract to purchase Malt. If `SwingTrader` has insufficient capital to return the price of Malt back to its target price, an auction is triggered with the remaining amount. However, no auction is triggered if the current auction exists, but `msg.sender` is still rewarded for their call to `stabilize`.  ## Proof of Concept  `_shouldAdjustSupply` initially checks if the current auction is active, however, it does not check if the current auction exists. There is a key distinction between the `auctionActive` and `auctionExists` functions which are not used consistently. Hence, an auction which is inactive but exists would satisfy the edge case and result in `triggerAuction` simply returning.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L382-L386 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L342-L344 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L873-L888  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider using `auctionExists` and `auctionActive` consistently in `StabilizerNode` and `Auction` to ensure this edge case cannot be abused.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function setAdvanceIncentive of DAO.sol doesn't check for a maximum value of incentive. If incentivewould be very large, then advanceIncentive would be very large and the function advance() would mint a large amount of malt.  The function setAdvanceIncentive() can only be called by an admin, but a mistake could be made. Also if an admin would want to do a rug pull, this would be an ideal place to do it.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L98-L104  ```JS   function setAdvanceIncentive(uint256 incentive)  externalonlyRole(ADMIN_ROLE, "Must have admin role") {    ...     advanceIncentive = incentive; ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63  ```JS function advance() external { ...     malt.mint(msg.sender, advanceIncentive * 1e18);  ```  ## Tools Used  ## Recommended Mitigation Steps Check for a reasonable maximum value in advance()  
# Handle  leastwood   # Vulnerability details  ## Impact  `purchaseArbitrageTokens` enables users to commit collateral tokens and in return receive arbitrage tokens which are redeemable in the future for Malt tokens. Each auction specifies a commitment cap which when reached, prevents users from participating in the auction. However, `realCommitment` can be ignored by directly sending the `LiquidityExtension` contract collateral tokens and subsequently calling `purchaseArbitrageTokens`.  ## Proof of Concept  Consider the following scenario: - An auction is currently active. - A user sends collateral tokens to the `LiquidityExtension` contract. - The same user calls `purchaseArbitrageTokens` with amount `0`. - The `purchaseAndBurn` call returns a positive `purchased` amount which is subsequently used in auction calculations.  As a result, a user could effectively influence the average malt price used throughout the `Auction` contract.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L177-L214 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117-L128  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding a check to ensure that `realCommitment != 0` in `purchaseArbitrageTokens`.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the contract Timelock.sol the following onlyRole expression occurs a few times, referring GOVERNER and timelock: onlyRole(GOVERNOR_ROLE, "Must have timelock role")  Whereas several other onlyRole expressions are referring to governor: onlyRole(GOVERNOR_ROLE, "Timelock::...: Call must come from governor.")  Either the role should be TIMELOCK_ROLE or the messages should refer consistently to governor. Otherwise it might be more difficult to solve error messages from reverts.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L68  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L84  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L100  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L115  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L140  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L159  ## Tools Used  ## Recommended Mitigation Steps Make the error messages consistent   
# Handle  leastwood   # Vulnerability details  ## Impact  Malt Finance uses solidity version `>=0.6.6` throughout all of its contracts. This solidity version provides no protections against arithmetic underflows and overflows. As a result, it is incredibly difficult to guarantee that the protocol enforces the necessary arithmetic checks during sensitive actions.  There are several instances where the OpenZeppelin's `SafeMath` library is not used. This exposes the protocol to potential exploits via arithmetic underflows and overflows. The liveness of the protocol depends on safety guarantees that are not provided/enforced. Therefore, this issue should be deemed high severity.  ## Proof of Concept  Solidity version shown in all contracts.  ## Tools Used  Manual code review. https://docs.soliditylang.org/en/v0.8.10/080-breaking-changes.html  ## Recommended Mitigation Steps  Consider updating the smart contract suite to use the latest solidity version or at the very least integrate OpenZeppelin's `SafeMath` library in all areas of the code containing arithmetic operations.  
# Handle  nathaniel   # Vulnerability details  ## Impact No vulnerability, however as `setupPartipant` would only ever be executed by the constructor in its deriving contracts, it would make sense if it was internal instead of public. If it was not executed in the constructor of the deriving contract, then at least it is safer with internal visibility.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionParticipant.sol#L30   
# Handle  nathaniel   # Vulnerability details  ## Impact The code in `getCollateralValueInMalt` of ImpliedCollateralService.sol, can leverage the `totalUsefulCollateral` function, reducing code size and gas cost when calling the contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L104-L124  ## Tools Used manual  ## Recommended Mitigation Steps Remove L108-L110, then in the return of `getCollateralValueInMalt` return `totalUsefulCollateral().mul(target).div(maltPrice) + swingTraderMaltBalance`  
# Handle  nathaniel   # Vulnerability details  ## Impact A large portion of the `unbond` and `unbondAndBreak` code of Bonding.sol is the same, to reduce code bloat and gas when calling the contract   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L97-L109  ## Tools Used Manual  ## Recommended Mitigation Steps I would suggest wrapping the duplicated code into an internal function called by `unbond` and `unbondAndBreak`.  
# Handle  hyh   # Vulnerability details  ## Impact  If Malt token be set to have lower decimals the incentives will be too big to be issued and DAO advance epoch and StabilizerNode auction start functions will fail, the system will have to be redeployed.  For example, if Malt was set to have 6 decimals like USDC, then 100*1e18 StabilizerNode defaultIncentive will be 100 trillions Malt.  ## Proof of Concept  Now some parts of the system use ```malt.decimals()``` (SwingTrader, UniswapHandler), some (StabilizerNode, DAO) use 18.  DAO advanceIncentive:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DAO.sol#L60   StabilizerNode defaultIncentive:  stabilize function https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145  calls _startAuction in low exchangeRate case, minting defaultIncentive * 10**18 = 100 * 1e18 Malt to the sender as a caller fee. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L344   ## Recommended Mitigation Steps  If Malt decimals are meant to be set to 18, add a constant variable and use it across the system to save gas.  If the flexibility is desired ```malt.decimals()``` to be used, in a form of contract storage variable for gas optimization (```decimals()``` can be saved to storage once on initialization, and read from there afterwards).   
# Handle  robee   # Vulnerability details  This issue is about arithmetic computation that could have been done more percise.  The following are places in the codebase in which you multiplied after the divisions.  Doing the multiplications at start lead to more accurate calculations.  This is a list of places in the code that this appears (Solidity file, line number, actual line):           DAO.sol, 105,   /* Internal methods */          UniswapHandler.sol, 265,         buyBase.div(priceTarget).mul(buyBase).mul(997)          RewardDistributor.sol, 113,   /* PUBLIC VIEW FUNCTIONS */          RewardDistributor.sol, 118,   /* INTERNAL VIEW FUNCTIONS */          RewardDistributor.sol, 129,   /* INTERNAL FUNCTIONS */   
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function getRewardOwnershipFraction in AbstractRewardMine.sol could be set external         The function balanceOfStakePadding in AbstractRewardMine.sol could be set external         The function withdrawnBalance in AbstractRewardMine.sol could be set external         The function earned in AbstractRewardMine.sol could be set external         The function setMiningService in AbstractRewardMine.sol could be set external         The function totalReleasedReward in AbstractRewardMine.sol could be set external         The function totalStakePadding in AbstractRewardMine.sol could be set external         The function totalBonded in AbstractRewardMine.sol could be set external         The function totalWithdrawn in AbstractRewardMine.sol could be set external         The function setRewardToken in AbstractRewardMine.sol could be set external         The function onBond in AbstractRewardMine.sol could be set external         The function withdrawAll in AbstractRewardMine.sol could be set external         The function onUnbond in AbstractRewardMine.sol could be set external         The function balanceOfBonded in AbstractRewardMine.sol could be set external         The function verifyTransfer in AbstractTransferVerification.sol could be set external         The function getAuctionCore in Auction.sol could be set external         The function getAuctionPrices in Auction.sol could be set external         The function getAuction in Auction.sol could be set external         The function auctionActive in Auction.sol could be set external         The function getAuctionCommitments in Auction.sol could be set external         The function isAuctionFinalized in Auction.sol could be set external         The function balanceOfArbTokens in Auction.sol could be set external         The function auctionExists in Auction.sol could be set external         The function consult in AuctionBurnReserveSkew.sol could be set external         The function getAverageParticipation in AuctionBurnReserveSkew.sol could be set external         The function addAbovePegObservation in AuctionBurnReserveSkew.sol could be set external         The function getPegDeltaFrequency in AuctionBurnReserveSkew.sol could be set external         The function addBelowPegObservation in AuctionBurnReserveSkew.sol could be set external         The function getRealBurnBudget in AuctionBurnReserveSkew.sol could be set external         The function earlyExitReturn in AuctionEscapeHatch.sol could be set external         The function setReplenishingIndex in AuctionParticipant.sol could be set external         The function usableBalance in AuctionParticipant.sol could be set external         The function outstandingArbTokens in AuctionParticipant.sol could be set external         The function getAllAuctionIds in AuctionParticipant.sol could be set external         The function setupParticipant in AuctionParticipant.sol could be set external         The function usableBalance in AuctionPool.sol could be set external         The function setBonding in AuctionPool.sol could be set external         The function totalReleasedReward in AuctionPool.sol could be set external         The function totalBonded in AuctionPool.sol could be set external         The function setForfeitDestination in AuctionPool.sol could be set external         The function onUnbond in AuctionPool.sol could be set external         The function totalDeclaredReward in AuctionPool.sol could be set external         The function balanceOfBonded in AuctionPool.sol could be set external         The function setMiningService in Bonding.sol could be set external         The function epochData in Bonding.sol could be set external         The function totalBonded in Bonding.sol could be set external         The function bondedEpoch in Bonding.sol could be set external         The function setDAO in Bonding.sol could be set external         The function setDexHandler in Bonding.sol could be set external         The function setCurrentEpoch in Bonding.sol could be set external         The function bondToAccount in Bonding.sol could be set external         The function averageBondedValue in Bonding.sol could be set external         The function balanceOfBonded in Bonding.sol could be set external         The function deploy in Create2Deployer.sol could be set external         The function getEpochStartTime in DAO.sol could be set external         The function epochsPerYear in DAO.sol could be set external         The function mint in DAO.sol could be set external         The function setEpochLength in DAO.sol could be set external         The function setMaltToken in DAO.sol could be set external         The function maltMarketPrice in UniswapHandler.sol could be set external         The function reserves in UniswapHandler.sol could be set external         The function constructor in ERC20Permit.sol could be set external         The function setBonding in ERC20VestedMine.sol could be set external         The function totalReleasedReward in ERC20VestedMine.sol could be set external         The function totalBonded in ERC20VestedMine.sol could be set external         The function setDistributor in ERC20VestedMine.sol could be set external         The function onUnbond in ERC20VestedMine.sol could be set external         The function totalDeclaredReward in ERC20VestedMine.sol could be set external         The function balanceOfBonded in ERC20VestedMine.sol could be set external         The function handleForfeit in ForfeitHandler.sol could be set external         The function totalUsefulCollateral in ImpliedCollateralService.sol could be set external         The function getCollateralValueInMalt in ImpliedCollateralService.sol could be set external         The function collateralDeficit in LiquidityExtension.sol could be set external         The function reserveRatio in LiquidityExtension.sol could be set external         The function hasMinimumReserves in LiquidityExtension.sol could be set external         The function constructor in Malt.sol could be set external         The function burn in Malt.sol could be set external         The function mint in Malt.sol could be set external         The function smoothedMaltPrice in MaltDataLab.sol could be set external         The function trackReserveRatio in MaltDataLab.sol could be set external         The function maltInPoolAverage in MaltDataLab.sol could be set external         The function smoothedMaltInPool in MaltDataLab.sol could be set external         The function reserveRatioAverage in MaltDataLab.sol could be set external         The function maltPriceAverage in MaltDataLab.sol could be set external         The function smoothedReserves in MaltDataLab.sol could be set external         The function smoothedReserveRatio in MaltDataLab.sol could be set external         The function balanceOfRewards in MiningService.sol could be set external         The function removeRewardMine in MiningService.sol could be set external         The function earned in MiningService.sol could be set external         The function withdrawRewardsForAccount in MiningService.sol could be set external         The function setReinvestor in MiningService.sol could be set external         The function withdrawAccountRewards in MiningService.sol could be set external         The function setBonding in MiningService.sol could be set external         The function isMineActive in MiningService.sol could be set external         The function onBond in MiningService.sol could be set external         The function numberOfMines in MiningService.sol could be set external         The function onUnbond in MiningService.sol could be set external         The function addRewardMine in MiningService.sol could be set external         The function getValue in MovingAverage.sol could be set external         The function getValueWithLookback in MovingAverage.sol could be set external         The function isWhitelisted in PoolTransferVerification.sol could be set external         The function setPool in PoolTransferVerification.sol could be set external         The function addToWhitelist in PoolTransferVerification.sol could be set external         The function verifyTransfer in PoolTransferVerification.sol could be set external         The function setThreshold in PoolTransferVerification.sol could be set external         The function setPriceLookback in PoolTransferVerification.sol could be set external         The function removeFromWhitelist in PoolTransferVerification.sol could be set external         The function setForfeitor in RewardDistributor.sol could be set external         The function addFocalLengthUpdater in RewardDistributor.sol could be set external         The function setRewardMine in RewardDistributor.sol could be set external         The function setBonding in RewardDistributor.sol could be set external         The function forfeit in RewardDistributor.sol could be set external         The function vest in RewardDistributor.sol could be set external         The function setThrottler in RewardDistributor.sol could be set external         The function setRewardToken in RewardDistributor.sol could be set external         The function removeFocalLengthUpdater in RewardDistributor.sol could be set external         The function decrementRewards in RewardDistributor.sol could be set external         The function totalDeclaredReward in RewardDistributor.sol could be set external         The function setFocalLength in RewardDistributor.sol could be set external         The function averageAPR in RewardThrottle.sol could be set external         The function targetEpochProfit in RewardThrottle.sol could be set external         The function epochData in RewardThrottle.sol could be set external         The function targetAPR in RewardThrottle.sol could be set external         The function getTargets in RewardThrottle.sol could be set external         The function handleReward in RewardThrottle.sol could be set external         The function checkRewardUnderflow in RewardThrottle.sol could be set external         The function epochAPR in RewardThrottle.sol could be set external         The function costBasis in SwingTrader.sol could be set external         The function setLpProfitCut in SwingTrader.sol could be set external         The function addVerifier in TransferService.sol could be set external         The function numberOfVerifiers in TransferService.sol could be set external         The function verifyTransfer in TransferService.sol could be set external         The function removeVerifier in TransferService.sol could be set external   
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           AbstractRewardMine.sol Variable miningService is read 3 times in the function:  setMiningService         Auction.sol Variable currentAuctionId is read 3 times in the function:  purchaseArbitrageTokens         Auction.sol Variable nextCommitmentId is read 2 times in the function:  purchaseArbitrageTokens         Auction.sol Variable currentAuctionId is read 4 times in the function:  _checkAuctionFinalization         Auction.sol Variable replenishingAuctionId is read 4 times in the function:  allocateArbRewards         Auction.sol Variable stabilizerNode is read 2 times in the function:  setStabilizerNode         Auction.sol Variable amender is read 2 times in the function:  setAuctionAmender         AuctionBurnReserveSkew.sol Variable auctionAverageLookback is read 2 times in the function:  getPegDeltaFrequency         AuctionBurnReserveSkew.sol Variable count is read 2 times in the function:  addAbovePegObservation         AuctionBurnReserveSkew.sol Variable count is read 2 times in the function:  addBelowPegObservation         AuctionBurnReserveSkew.sol Variable stabilizerNode is read 2 times in the function:  setNewStabilizerNode         AuctionParticipant.sol Variable replenishingIndex is read 2 times in the function:  claim         AuctionParticipant.sol Variable replenishingIndex is read 2 times in the function:  setReplenishingIndex         AuctionPool.sol Variable forfeitedRewards is read 2 times in the function:  _checkForForfeit         AuctionPool.sol Variable forfeitedRewards is read 3 times in the function:  _handleRewardDistribution         UniswapHandler.sol Variable router is read 2 times in the function:  addLiquidity         MaltDataLab.sol Variable UPDATER_ROLE is read 2 times in the function:  initialize         MiningService.sol Variable reinvestor is read 2 times in the function:  setReinvestor         MiningService.sol Variable bonding is read 2 times in the function:  setBonding         MovingAverage.sol Variable UPDATER_ROLE is read 2 times in the function:  initialize         MovingAverage.sol Variable cumulativeValue is read 11 times in the function:  update         MovingAverage.sol Variable blockTimestampLast is read 5 times in the function:  update         MovingAverage.sol Variable activeSamples is read 2 times in the function:  update         MovingAverage.sol Variable sampleLength is read 3 times in the function:  update         MovingAverage.sol Variable cumulativeValue is read 10 times in the function:  updateCumulative         MovingAverage.sol Variable blockTimestampLast is read 4 times in the function:  updateCumulative         MovingAverage.sol Variable activeSamples is read 2 times in the function:  updateCumulative         MovingAverage.sol Variable sampleLength is read 2 times in the function:  updateCumulative         MovingAverage.sol Variable activeSamples is read 2 times in the function:  _createNewSample         MovingAverage.sol Variable counter is read 2 times in the function:  setSampleMemory         RewardReinvestor.sol Variable dexHandler is read 2 times in the function:  _bondAccount         RewardReinvestor.sol Variable treasury is read 2 times in the function:  _bondAccount         RewardDistributor.sol Variable FOCAL_LENGTH_UPDATER_ROLE is read 2 times in the function:  initialize         RewardDistributor.sol Variable focalLength is read 2 times in the function:  _resetFocalPoint         RewardDistributor.sol Variable focalID is read 3 times in the function:  _incrementFocalPoint         RewardDistributor.sol Variable throttler is read 2 times in the function:  setThrottler         RewardDistributor.sol Variable rewardMine is read 2 times in the function:  setRewardMine         RewardOverflowPool.sol Variable throttler is read 2 times in the function:  setThrottler         RewardThrottle.sol Variable _activeEpoch is read 3 times in the function:  handleReward         StabilizerNode.sol Variable stabilizeWindowEnd is read 2 times in the function:  stabilize         StabilizerNode.sol Variable lastStabilize is read 2 times in the function:  stabilize         StabilizerNode.sol Variable liquidityExtension is read 2 times in the function:  _replenishLiquidityExtension         StabilizerNode.sol Variable auction is read 2 times in the function:  setAuctionContract         SwingTrader.sol Variable deployedCapital is read 2 times in the function:  buyMalt         SwingTrader.sol Variable deployedCapital is read 2 times in the function:  sellMalt   
# Handle  robee   # Vulnerability details  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.  The format is <solidity file>, <in which function we found it>, <unused local variable name>:           AbstractRewardMine.sol, _handleStakePadding, totalRewardedWithStakePadding         AbstractRewardMine.sol, _handleStakePadding, INITIAL_STAKE_SHARE_MULTIPLE         AbstractRewardMine.sol, _handleStakePadding, bondedTotal         Auction.sol, _finalizeAuction, avgMaltPrice         AuctionParticipant.sol, claim, replenishingId         AuctionParticipant.sol, claim, claimableTokens         AuctionParticipant.sol, claim, claimable         Create2Deployer.sol, deploy, addr         UniswapHandler.sol, removeBuyer, buyer         MaltDataLab.sol, trackPoolReserves, rewardDecimals         MovingAverage.sol, update, elapsedSamples         MovingAverage.sol, updateCumulative, elapsedSamples         StabilizerNode.sol, stabilize, exchangeRate         StabilizerNode.sol, _startAuction, decimals         SwingTrader.sol, sellMalt, maltDecimals         SwingTrader.sol, costBasis, maltDecimals         TransferService.sol, removeVerifier, verifier   
# Handle  robee   # Vulnerability details  In the following files, there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           AuctionBurnReserveSkew.sol, line 4, import "@openzeppelin/contracts/access/AccessControl.sol";         AuctionParticipant.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         AuctionParticipant.sol, line 3, import "@openzeppelin/upgrades/contracts/Initializable.sol";         AuctionPool.sol, line 9, import "./interfaces/IAuction.sol";         AuctionPool.sol, line 10, import "./interfaces/IBurnMintableERC20.sol";         AuctionPool.sol, line 11, import "./interfaces/IDexHandler.sol";         Bonding.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         ERC20VestedMine.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         ImpliedCollateralService.sol, line 12, import "./interfaces/IRewardThrottle.sol";         LiquidityExtension.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         LiquidityExtension.sol, line 3, import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";         MaltDataLab.sol, line 7, import "./interfaces/IStabilizerNode.sol";         MaltDataLab.sol, line 9, import "./interfaces/IDAO.sol";         MiningService.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         MiningService.sol, line 3, import "@openzeppelin/contracts/token/ERC20/ERC20.sol";         PoolTransferVerification.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         PoolTransferVerification.sol, line 6, import "./Permissions.sol";         RewardDistributor.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         RewardDistributor.sol, line 11, import "hardhat/console.sol";         RewardOverflowPool.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         RewardThrottle.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         RewardThrottle.sol, line 13, import "hardhat/console.sol";         SwingTrader.sol, line 8, import "./interfaces/IAuction.sol";         TransferService.sol, line 4, import "./interfaces/IMaltDataLab.sol";   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Remove L151 count = count + 1; and change L147 to uint256 index = _getIndexOfObservation(count++); so we save at least a SLOAD.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L143  ## Tools Used  ## Recommended Mitigation Steps Remove L151 count = count + 1; and change L147 to uint256 index = _getIndexOfObservation(count++);  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact After teh if statement on L74, we have premiumExcess <= maxBurnSpend and therefore don't need to do a save subtraction (underflow check) on L80.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L69  ## Tools Used  ## Recommended Mitigation Steps - rewrite L80 as: uint256 usableExcess = maxBurnSpend - premiumExcess;  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Else block on L805 satisfies amountArbTokens <= unclaimedArbTokens and therefore no safe subtraction (underflow check) is needed (saves gas).  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L786  ## Tools Used  ## Recommended Mitigation Steps - rewrite L805 as: unclaimedArbTokens = unclaimedArbTokens - amountArbTokens;  
# Handle  GiveMeTestEther   # Vulnerability details  # Vulnerability details  ## Impact The else block on L241 satisfies amountTokens <= unclaimedArbTokens and therefore we don't need to do a safe subtraction (underflow check).  The else block on L247 satisfies amountTokens <= claimableArbitrageRewards and therefore we don't need to do a safe subtraction (underflow check).     ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L216 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L247  ## Tools Used  ## Recommended Mitigation Steps - rewrite L241 as: unclaimedArbTokens = unclaimedArbTokens - amountTokens; - rewrite L274 as: claimableArbitrageRewards = claimableArbitrageRewards - amountTokens-;   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact L209 nextCommitmentId = nextCommitmentId + 1; can be removed and L202 can be changed to nextCommitmentId++; to save a SLOAD  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Storage variable _activeEpoch is read a lot and can be cached in a local variable (epochTmp, maybe choose a better name =)) to save gas. Also the State struct can be loaded into a State storage (currentState, maybe also choose a better name) variable such that we don't have to access the storage array each time.   In the gas optimized code of "Recommended Mitigation Steps" section, the _activeEpoch only gets read once. Also note after the first "if" we write epoch to the storage variable "_activeEpoch" but then also write epoch to the local var "epochTmp" so we can use this local var in the whole function.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L63  ## Tools Used  ## Recommended Mitigation Steps   function handleReward() public {     uint256 balance = rewardToken.balanceOf(address(this));      uint256 epoch = dao.epoch();     uint256 epochTmp = _activeEpoch;     State storage currentState;      checkRewardUnderflow();      if (epoch > epochTmp) {       _activeEpoch = epoch;       epochTmp = epoch;        currentState = _state[epochTmp];        currentState.bondedValue = bonding.averageBondedValue(epochTmp);        currentState.profit = balance;       currentState.rewarded = 0;       currentState.throttle = throttle;     } else {       currentState = _state[epochTmp];       currentState.profit = currentState.profit.add(balance);       currentState.throttle = throttle;      }      // Fetch targetAPR before we update current epoch state     uint256 aprTarget = targetAPR();      // Distribute balance to the correct places     if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) {       uint256 remainder = _getRewardOverflow(balance, aprTarget);       emit RewardOverflow(epochTmp, remainder);        if (remainder > 0) {         rewardToken.safeTransfer(address(overflowPool), remainder);          if (balance > remainder) {           _sendToDistributor(balance - remainder, epochTmp);         }       }     } else {       _sendToDistributor(balance, epochTmp);     }      emit HandleReward(epoch, balance);   }  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Require statement conditions checks that no underflow can happen, therefore we don't need to use safe subtraction (underflow check).  - L275:  require(amount <= _globals.declaredBalance, "Can't decrement more than total reward balance"); - L278:  _globals.declaredBalance = _globals.declaredBalance.sub(amount); => Rewrite L278 as:  _globals.declaredBalance = _globals.declaredBalance - amount;  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L271 ## Tools Used  ## Recommended Mitigation Steps - rewrite L278 as:  _globals.declaredBalance = _globals.declaredBalance - amount;  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact L185:  focalID = focalID + 1; can be removed and L197 can be adapted to:  _resetFocalPoint(++focalID, newEndTime); to save at least one warm storage read (100 gas)  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L180 ## Tools Used  ## Recommended Mitigation Steps  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Require condition checks already underflow condition. There for no underflow check is needed.  - L154: require(forfeited <= _globals.declaredBalance, "Cannot forfeit more than declared"); - L156:_globals.declaredBalance = _globals.declaredBalance.sub(forfeited);  Therefore L156 can be written as: _globals.declaredBalance = _globals.declaredBalance - forfeited;   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L153 ## Tools Used  ## Recommended Mitigation Steps - L156 can be written as: _globals.declaredBalance = _globals.declaredBalance - forfeited;  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on operations.  ## Proof of Concept  The function contains two non-intersecting logic pathways, which can be separated to lighten calculations.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L179   ## Recommended Mitigation Steps  Now: ``` function _handleStakePadding(address account, uint256 amount) internal {  uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());   uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;   uint256 bondedTotal = totalBonded();   uint256 newStakePadding = bondedTotal == 0 ?   totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :   totalRewardedWithStakePadding.mul(amount).div(bondedTotal);   _addToStakePadding(account, newStakePadding); } ```  To be: ``` function _handleStakePadding(address account, uint256 amount) internal {  uint256 bondedTotal = totalBonded();    uint256 newStakePadding;  if (bondedTotal == 0) {   uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;   newStakePadding = totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0;  } else {   newStakePadding = (totalDeclaredReward().add(totalStakePadding())).mul(amount).div(bondedTotal);  }   if (newStakePadding > 0)   _addToStakePadding(account, newStakePadding); } ```  
# Handle  jayjonah8   # Vulnerability details  ## Impact The setupParticipant() function in AuctionParticipant.sol does not have require statements to protect again contracts that do not yet exist.  It sets the addresses for " _impliedCollateralService", "_rewardToken", and "_auction" and can only be called once so its vital to have this guard in place.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionParticipant.sol#L26  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add require checks for the addresses that are passed in the setupParticipant() function checking if they exist like: require("address" != address(0), "contract does not exist")  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and function calls.  ## Proof of Concept  totalDeclaredReward is called by _handleStakePadding twice: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L180  While totalDeclaredReward does expensive balanceOf call: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L97  ## Recommended Mitigation Steps  It is viable to at least remove its double usage:  Now: ``` uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding()); ... uint256 newStakePadding = bondedTotal == 0 ?  totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :  totalRewardedWithStakePadding.mul(amount).div(bondedTotal); ```  To be: ``` uint256 declaredRewardTotal =  rewardToken.balanceOf(address(this)); uint256 totalRewardedWithStakePadding = declaredRewardTotal.add(totalStakePadding()); ... uint256 newStakePadding = bondedTotal == 0 ?  declaredRewardTotal == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 : totalRewardedWithStakePadding.mul(amount).div(bondedTotal); ```  
# Handle  Meta0xNull   # Vulnerability details  ## Impact Is Not Uncommon Normal Users Accidentally Send Tokens into Contract.  ENS Airdrop is a Good Example Normal Users Accidentally Send Tokens into Contract: https://discuss.ens.domains/t/social-amend-airdrop-proposal-to-include-accidentally-returned-funds/6975  In UniswapHandler.sol, sellMalt(), addLiquidity() and removeLiquidity() Have No Access Control. When Normal Users Accidently Deposit Tokens into the Contract, Any Random Persons/Bot Can Withdraw the Tokens because it will safeTransfer to msg.sender who find out there is token balance in the contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L185-L219 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221-L245  ## Tools Used Manual Review  ## Recommended Mitigation Steps Add relevant access control, probably Only StabilizerNode and Admin have Access to this contract various functions like sellMalt(), addLiquidity() and removeLiquidity() etc.   
# Handle  Meta0xNull   # Vulnerability details  ## Impact removeVerifier() loops follows this for-each pattern: for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` }  In such for loops, the array.length is read on every iteration, instead of caching it once in a local variable and read it again using the local variable.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L87-L88  ## Tools Used Manual Review  ## Recommended Mitigation Steps Read these values from memory once, cache them in local variables and then read them again using the local variables. For example:  Before: for (uint i = 0; i < verifierList.length - 1; i = i + 1) { if (verifierList[i] == _address) {  After: uint256 verifierList_temp = verifierList  for (uint i = 0; i < verifierList_temp.length - 1; i = i + 1) { if (verifierList_temp[i] == _address) {  
# Handle  Meta0xNull   # Vulnerability details  ## Impact The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L87 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionBurnReserveSkew.sol#L54 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Malt.sol#L34-L37 More...  ## Tools Used Manual Review  ## Recommended Mitigation Steps Remove explicit 0 initialization of for loop index variable.   Before: for (uint i = 0; After for (uint i;  
# Handle  Meta0xNull   # Vulnerability details  ## Impact      * [WARNING]      * ====      * This function should only be called from the constructor when setting      * up the initial roles for the system.      *      * Using this function in any other way is effectively circumventing the admin      * system imposed by {AccessControl}.      * ====      *      * NOTE: This function is deprecated in favor of {_grantRole}.  There are multiple contracts that import Permissions.sol and using Deprecated Function _setupRole() with Security Problem that Applicable to all these contracts because all of the contracts use initialize() Rather Than Constructor.   ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L174-L186 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L53 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L117 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L121  ## Tools Used Manual Review  ## Recommended Mitigation Steps Replace _setupRole() with _grantRole()  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on function calls.  ## Proof of Concept  ```earned``` function calls public ```getRewardOwnershipFraction``` function: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L144  ## Recommended Mitigation Steps  Now: ``` function totalDeclaredReward() virtual public view returns (uint256) {  return rewardToken.balanceOf(address(this)); } function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {  numerator = balanceOfRewards(account);  denominator = totalDeclaredReward(); } ... function earned(address account) public view returns (uint256 earnedReward) {  (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);  ```  To be: ``` function earned(address account) public view returns (uint256 earnedReward) {  uint256 rewardNumerator = balanceOfRewards(account);  uint256 rewardDenominator = rewardToken.balanceOf(address(this)); ```  
# Handle  Meta0xNull   # Vulnerability details  ## Impact A wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or Users'FUND Locked inside the Contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L63-L77  ## Tools Used Manual Review  ## Recommended Mitigation Steps requires Addresses is not zero.  require(_admin != address(0), "Address Can't Be Zero")  
# Handle  Meta0xNull   # Vulnerability details  ## Impact The current ownership transfer process involves the current TIMELOCK_ROLE calling reassignGlobalAdmin().  If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the TIMELOCK_ROLE modifier.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L63-L77  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider implementing a two step process where the TIMELOCK_ROLE nominates an account and the nominated account needs to call an accept_TIMELOCK_ROLE() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.   
# Handle  loop   # Vulnerability details  When invoking `purchaseArbitrageTokens()` is will first check whether the auction is active using: ``` require(auctionActive(currentAuctionId), "No auction running"); ``` `auctionActive()` checks for the following things: ``` auction.active && now >= auction.startingTime; ``` As a result the require statement will fail if either `!auction.active` or `now < auction.startingTime`.   Later on in `purchaseArbitrageTokens()` two more require statements will check the same thing: ``` require(auction.startingTime <= now, "Auction hasn't started yet"); (...)  require(auction.active == true, "Auction is not active"); ``` These will always pass if `auctionActive(currentAuctionId)` is `true` and never be reached if it is `false`, making them redundant.  ## Proof of Concept - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L178 - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L188-L190 - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272  ## Recommended Mitigation Steps Remove redundant require statements  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  Caching the array length in a `for`-loop saves gas as the length does not need to be read on every iteration.  The following loops could be refactored: ``` ./Malt.sol:34:    for (uint256 i = 0; i < minters.length; i = i + 1) { ./Malt.sol:37:    for (uint256 i = 0; i < burners.length; i = i + 1) { ./TransferService.sol:87:    for (uint i = 0; i < verifierList.length - 1; i = i + 1) { ./Auction.sol:407:    for (uint i = 0; i < epochCommitments.length; ++i) { ./libraries/UniswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./AuctionParticipant.sol:107:    for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) { ./MiningService.sol:49:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:69:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:86:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:96:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:142:    for (uint i = 0; i < mines.length - 1; i = i + 1) { ./MiningService.sol:166:    for (uint i = 0; i < mines.length; i = i + 1) { ./DexHandlers/UniswapHandler.sol:317:    for (uint i = 0; i < buyers.length - 1; i = i + 1) { ```  ## Tools used  `grep -rn ".length" .`  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  The functions `setDefaultIncentive` and `setExpansionDamping` in `StabilizerNode.sol` require their arguments to be non-zero, i.e. to be positive, as their argument types are `uint`.  However, the error messages state that the arguments should not be non-negative.  See lines [406](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L406) and [417](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L417).  ## Recommended Mitigation Steps  Change the error messages to something like: "Must be above 0".  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  Function `RewardReinvestor::_bondAccount` tries to bond liquidity to an account, even though it is known whether the liquidity is zero.  ## Proof of Concept  The return value `liquidityCreated` in [line 105](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L105) can be zero. The following function call, `bondToAccount()`, then reverts with "Cannot bond 0".  ## Recommended Mitigation Steps  Gas could be saved if the function would revert earlier, i.e. in [line 106](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L106), if the `liquidityCreated` is zero.  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description There is multiple instances within the **Malt** protocol codebase that do not append messages to the require statements.  ## Impact add a custom message to the require statement to create a better sense of what's is the reason of failure.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L681 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L56 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L76 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L78 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L119  ## Tools Used manual code review.  ## Recommended Mitigation Steps append custom message to the require statements.  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description On contract **AuctionEscapeHatch** there is a function labeled as Public, However this function is not used within the contracts of **Malt** protocol.  ## Impact Improve coding style quality for developers and audit.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L94  ## Tools Used manual code review.  ## Recommended Mitigation Steps Evaluate functions labeled as public and set to external if needed just like the rest of functions inside this contract.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Caching the references to "currentAuctionID" will decrease gas usage.   ## Proof of Concept  The state variable "currentAuctionID" is read 7 times in function "_checkAuctionFinalization" here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L746-L762  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to cache the variable:    ```   function _checkAuctionFinalization(bool isInternal) internal {      uint256 currentId = currentAuctionId;     if (isInternal && !isAuctionFinished(currentId)) {       // Auction is still in progress after internal auction purchasing.       _resetAuctionMaxCommitments();     }      if (isAuctionFinished(currentId)) {       if (auctionActive(currentId)) {         _endAuction(currentId);       }        if (!isAuctionFinalized(currentId)) {         _finalizeAuction(currentId);       }       currentAuctionId = currentId + 1;     }   } ```   
# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticipant.sol, the function `setReplenishingIndex` is an admin function that allows manually setting `replenishingIndex`. As I have shown in my two previous findings, I believe that this function could be called frequently. In my opinion (and Murphy's law would agree), this implies that eventually an admin will accidentally set `replenishingIndex` incorrectly with this function.  Right now, `setReplenishingIndex` does not allow the admin to set `replenishingIndex` to a value smaller than it currently is. So, if an admin were to accidentally set this value too high, then it would be impossible to set it back to a lower value (the higher the value set, the worse this issue). All of the unclaimed tokens on auctions at smaller indices would be locked forever.  ## Proof of Concept See code for `setReplenishingIndex` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L132  ## Tools Used Inspection  ## Recommended Mitigation Steps Remove the require statement on line 136, so that an admin can set the index to a smaller value.  
# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticpant.sol, every time `purchaseArbitrageTokens` is called, the current auction is pushed to `auctionIds`. If this function were to be called on the same auction multiple times, then the same auction id would be pushed multiple times into this array, and the `claim` function would have issues with `replenishingIndex`.   Specifically, even if `replenishingIndex` was incremented once in `claim`, it is still possible that the auction at the next index will never reward any more tokens to the participant, so the contract would need manual intervention to set `replenishingIndex` (due to the if statement on lines 79-82 that does nothing if there is no claimable yield).   It is likely that `purchaseArbitrageTokens` would be called multiple times on the same auction. In fact, the commented out code for `handleDeficit` (in ImpliedCollateralService.sol) even suggests that the purchases might happen within the same transaction. So this issue will likely be an issue on most auctions and would require manual setting of `replenishingIndex`.  NOTE: This is a separate issue from the one I just submitted previously relating to `replenishingIndex`. The previous issue was related to an edge case where `replenishingIndex` might need to be incremented by one if there are never going to be more claims, while this issue is due to duplicate auction ids.  ## Proof of Concept See code for `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L40  Notice that `currentAuction` is always appended to `auctionIds`.   ## Tools Used Inspection  ## Recommended Mitigation Steps Add a check to the function to `purchaseArbitrageTokens` to ensure that duplicate ids are not added. For example, this can be achieved by changing auctionIds to a mapping instead of an array.  
# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticipant.sol, the `claim` function is called to claim arb tokens from auctions the participant has entered. This is achieved through the global variable `replenishingIndex` which keeps track of which auction `claim` should be claiming from next. The logic for incrementing `replenishingIndex` is at the end of claim.   I agree with the current logic at the end of the function. The comment on lines 96/97 says "Don't increment replenishingIndex if replenishingAuctionId == auctionId as claimable could be 0 due to the debt not being 100% replenished". Notice the keyword "could" - it is possible that replenishingAuctionId == auctionId but we will never be able to claim any more arb tokens from this contract, and in this case `replenishingIndex` will NOT be incremented.  In this case, all subsequent calls to `claim` will simply do nothing. Line 77 will have `claimableTokens` be 0, and then the function will immediately return since it thinks it needs to wait longer to get more tokens, which will never happen. In this case, a manual intervention by an admin would be required to set `replenishingIndex', which is obviously annoying and should be avoided. Since `claim` is an external function, a malicious user/troll could intentionally call `claim` at the worst times to trigger this issue to happen. In this case, manual intervention would be required quite often.  The following logic should be added immediately after line 77 to account for this issue:  if (claimableTokens == 0 && replenishingId > auctionId) { // in this case, we will never receive any more tokens from this auction     replenishingIndex = replenishingIndex + 1;     auctionId = auctionIds[replenishingIndex]; }  // retry check for 0 claimable amount  ## Proof of Concept See the code for `claim` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L65  Other than manual intervention, the only place where `replenishingIndex` is set is at the end of `claim`.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add the code described above.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Variables are being assigned their default value which is unnecessary. Removing the assignment will save gas when deploying and improve code clarity.  ## Proof of Concept  State: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L19  Local: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L351 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L626 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L92 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L108 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L117 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L124 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionPool.sol#L115 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20VestedMine.sol#L90 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L94 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L125 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L149-L150 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L112  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unneeded assignments.  Or if you feel it is important to show the default assignment will occur then replace the assignments with a comment.  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODOs are here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L716 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L68 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L18 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L73 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L98 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L438 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L72 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L81 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L114 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L200 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L251 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L328  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODOs before deploying.  
# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been seen that malt price return value has not been checked on the function.  If oracle is returned price as a 0, fullReturn will be zero on the earlyExitReturn function.  ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L124" 2. The return value maltMarketPrice() function has not been checked.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to add return value check. The maltPrice should be more than zero for the calculation.  """ require(dexHandler.maltMarketPrice()>0, "Price should be more than zero"); """  
# Handle  hyh   # Vulnerability details  ## Impact  Being instantiated with wrong configuration, the contract is inoperable and deploy gas costs will be lost. If misconfiguration is noticed too late the various types of malfunctions become possible.  ## Proof of Concept  The checks for zero addresses during contract construction and initialization are considered to be the best-practice.  Now basically all the contract do not check for correctness of constructor arguments:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Malt.sol#L29  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardSystem/RewardOverflowPool.sol#L25  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L25  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ForfeitHandler.sol#L31  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L30  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L47  ...  ## Recommended Mitigation Steps  Add zero-address checks and key non-address variables checks in all contract constructors. Small increase of gas costs are far out weighted by wrong deploy costs savings and additional coverage against misconfiguration.   
# Handle  hyh   # Vulnerability details  ## Impact  ERC20 balanceOf call is costly. Malt balance is read twice in sellMalt call, which isn't needed, so gas is overspent here.  ## Proof of Concept  Malt balanceOf(address(this)) is called twice: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L86 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L150  ## Recommended Mitigation Steps  It's recommended to make internal version of costBasis that takes Malt balance as an argument.  Now: ``` uint256 totalMaltBalance = malt.balanceOf(address(this)); ... (...) = costBasis(); ... function costBasis() public view returns (uint256 cost, uint256 decimals) { ... uint256 maltBalance = malt.balanceOf(address(this)); ... ``` To be: ``` uint256 totalMaltBalance = malt.balanceOf(address(this)); ... (...) = _costBasis(totalMaltBalance); ... function _costBasis(uint256 maltBalance) internal view returns (...) { ... function costBasis() public view returns (...) {  return _costBasis(malt.balanceOf(address(this))); } ```  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on function call and calculations  ## Proof of Concept  First, save Malt and Collateral tokens decimals difference to storage variable. As neither Malt, nor Collateral token decimals change since initial setup, both can be saved and accessed as a storage variable instead of calling ```decimals()``` function and calculating the difference each time.  Second, now sellMalt calls costBasis, which already retrieved decimals and their difference, but sellMalt ignores those, retrieving them from functions/storage again. This could be unified as discussed below.  sellMalt: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L77 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L109  costBasis: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L146   ## Recommended Mitigation Steps   Save both decimals values to contract storage variables and use them instead of ```decimals()``` function. As the calculations use decimals difference it might be enough to save and use the difference only. In any case saving is preferred to calling as the latter spend gas on call and storage access anyway.   Also, return the difference along with decimals from costBasis and use them in sellMalt instead of obtaining afresh. I.e. first reuse ```costBasis``` returned ```decimals``` instead of ```collateralToken.decimals()```, then add ```maltDecimals``` and the difference, whether ```maltDecimals - decimals``` or ```decimals - maltDecimals``` to its output and use in rewards / soldBasis calculations. Function arguments and returned values are memory and are cheaper than another storage access.  Now: ``` (uint256 basis,) = costBasis(); ... uint256 maltDecimals = malt.decimals(); uint256 decimals = collateralToken.decimals(); ... uint256 diff = maltDecimals - decimals;  ``` To be: ``` (uint256 basis, uint256 decimals, uint256 maltDecimals, uint256 diff) = costBasis(); ... ```  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description  The event **SetAnnualYield** on Contract **StabilizerNode** is defined but never emitted inside the Contract.  ## Impact Unused events in the codebase can be confusing, each declared event should have a corresponding emit statement.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L73  ## Tools Used manual code review.  ## Recommended Mitigation Steps it's better to remove unused events from the code to improve coding quality, Also monitoring will be effected since no emit statements is there.  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and operations.  ## Proof of Concept  ```amountOut``` is calculated in 3 steps, which can be made simpler. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L302-305  ## Recommended Mitigation Steps  Now: ``` uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price); uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price); uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens); ```  To be (```amountTokens``` and ```redeemedTokens``` aren't used elsewhere): ```  /* * uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price); * uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price); * uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens); */ uint256 redeemed = commitment.redeemed.mul(auction.pegPrice); uint256 amountOut = commitment.commitment.mul(claimablePerc).sub(redeemed).div(price); ```   
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description On contract **Permissions.sol** there is multiple functions to withdraws funds, these functions currently do not check for zero value address before doing the transaction.  ## Impact Loss of funds, ETHs and ERC20.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L80 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L88 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L97 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L104  ## Tools Used manual code review.  ## Recommended Mitigation Steps use require() statement to validate address address(0) before sending the funds.  
# Handle  jayjonah8   # Vulnerability details  ## Impact In the AuctionEscapeHatch.sol file both earlyExitReturn() and _calculateMaltRequiredForExit call the getAuctionCore() function which has 10 possible return values most of which are not used.  It gets the wrong value back for the "active"  variable since it's the 10th argument but both functions have it as the 9th return value where "preAuctionReserveRatio" should be because of one missing comma.  This is serious because these both are functions which deal with allowing a user to exit their arbitrage token position early.  This can result in a loss of user funds.    ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L100 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L174 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L527   ## Tools Used Manual code review   ## Recommended Mitigation Steps In AuctionEscapeHatch.sol change the following in _calculateMaltRequiredForExit() and earlyExitReturn() functions:  From:   (,,,,,      uint256 pegPrice,      ,      uint256 auctionEndTime,      bool active     ) = auction.getAuctionCore(_auctionId);  To:   (,,,,,      uint256 pegPrice,      ,      uint256 auctionEndTime,      ,      bool active     ) = auction.getAuctionCore(_auctionId);   
# Handle  defsec   # Vulnerability details  ## Impact  SafeMath library functions are not always used in arithmetic operations in the contracts, which could potentially cause integer underflow/overflows. Although in the reference lines of code, there are upper limits on the variables to ensure an integer underflow/overflow could not happen, using SafeMath is always a best practice, which prevents underflow/overflows completely (even if there were no assumptions on the variables) and increases code consistency as well.   ## Proof of Concept  1. Navigate to the following contracts.  ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L795  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L821  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L64  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L76  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L188  ```  2. SafeMath functions are not used in the every functionality.   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider using the SafeMath library functions in the referenced lines of code.   
# Handle  defsec   # Vulnerability details  ## Impact  The admin only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in the contracts.   ## Proof of Concept  Missing events  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/SwingTrader.sol#L169  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L1000  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L1008  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L992  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L984  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L976  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L968  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L960  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L937  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L930  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L923  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L916  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionParticipant.sol#L132  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L226  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L234  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L218   See similar High-severity H03 finding OpenZeppelins Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelins Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)  ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all admin/privileged functions that change critical parameters.  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and operations.  ## Proof of Concept  ```claimablePerc``` is calculated in two steps, which can be made simpler. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L294  ## Recommended Mitigation Steps  Now: ``` uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice); uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens); ```  To be (```totalTokens``` isn't used elsewhere): ``` uint256 claimablePerc = auction.claimableTokens.mul(auction.finalPrice).div(auction.commitments); ```  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  As there is a check in the beginning of the function that includes the ```auction.finalPrice == 0``` condition: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L285  ## Recommended Mitigation Steps  The same condition down the line is never true and its check is redundant: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L298  
# Handle  sabtikw   # Vulnerability details  ## Impact  storage variables are initialized in the contract and overwritten in the initializer function.   ## Proof of Concept Auction.sol L#89 L#164 auctionLength AuctionBurnReserveSkew.sol L#25 auctionAverageLookback MaltDataLab.sol L#69 priceTarget  ## Tools Used  manual review   ## Recommended Mitigation Steps  remove initialization outside of initializer function  
# Handle  defsec   # Vulnerability details  ## Impact  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  ## Proof of Concept  1. Navigate to the following contracts.  ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L167  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionParticipant.sol#L59  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L252  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/RewardReinvestor.sol#L107 ``` 2.  When trying to re-approve an already approved token, all transactions revert and the protocol cannot be used.  ## Tools Used  None  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Cheaper storage.  ## Proof of Concept  The struct AuctionData file Auction.sol is optimizable. It looks like this:  ``` struct AuctionData {   // The full amount of commitments required to return to peg   uint256 fullRequirement;   // total maximum desired commitments to this auction   uint256 maxCommitments;   // Quantity of sale currency committed to this auction   uint256 commitments;   // Malt purchased and burned using current commitments   uint256 maltPurchased;   // Desired starting price for the auction   uint256 startingPrice;   // Desired lowest price for the arbitrage token   uint256 endingPrice;   // Price of arbitrage tokens at conclusion of auction. This is either   // when the duration elapses or the maxCommitments is reached   uint256 finalPrice;   // The peg price for the liquidity pool   uint256 pegPrice;   // Time when auction started   uint256 startingTime;   uint256 endingTime;   // Is the auction currently accepting commitments?   bool active;   // The reserve ratio at the start of the auction   uint256 preAuctionReserveRatio;   // Has this auction been finalized? Meaning any additional stabilizing   // has been done   bool finalized;   // The amount of arb tokens that have been executed and are now claimable   uint256 claimableTokens;   // The finally calculated realBurnBudget   uint256 finalBurnBudget;   // The amount of Malt purchased with realBurnBudget   uint256 finalPurchased;   // A map of all commitments to this auction by specific accounts   mapping(address => AccountCommitment) accountCommitments; } ``` But `active` and `finalized`, the unique boolean values, should be together, otherwise they will spend two slots instead of one. ```   uint256 preAuctionReserveRatio;   bool active;   bool finalized; ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps  
# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Use `indexed` on address to filter through logs better https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L105 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L112   
# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding. Some variables are in form of bps https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L90  while some are not https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L91 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L92  As a good programming practice, should use bps everywhere if you accepting it as a unit    
# Handle  jayjonah8   # Vulnerability details  ## Impact In MovingAverage.sol the safeMath.sol library is imported but I counted at least 25 places in the file where it should be used (Nearly the entire file).  This can result in values wrapping around which has caused devastating effects on many protocols in the past.  These values directly effect the exchangeRate variable given in the stabilize() function in StabilizerNode.sol so they must be treated with care.   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MovingAverage.sol#L3  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156  ## Tools Used Manual code review   ## Recommended Mitigation Steps The MovingAverage.sol file should be completely reviewed making use of safeMath through out the entire file.  
# Handle  defsec   # Vulnerability details  ## Impact  After pragma version, 0.7.0, the contract should use block.timestamp.  ## Proof of Concept  1. Navigate to the following contract.  "https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L153"  "https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L178"  2. Now is used instead of block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  It is recommended to use block.timestamp instead of now.  
# Handle  jayjonah8   # Vulnerability details  ## Impact The executeTransaction() function in Timelock.sol does not include a check if the contract being called actually exists. The extcodesize is not used when using .call on addresses directly as per the solidity docs.  This is important because the EVM allows calls to a non-existing contract to always succeed.   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Timelock.sol#L191  solidity docs: https://docs.soliditylang.org/en/v0.8.10/units-and-global-variables.html#address-related  "Due to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity includes an extra check using the extcodesize opcode when performing external calls. This ensures that the contract that is about to be called either actually exists (it contains code) or an exception is raised. The low-level calls which operate on addresses rather than contract instances (i.e. .call(), .delegatecall(), .staticcall(), .send() and .transfer()) do not include this check, which makes them cheaper in terms of gas but also less safe."   ## Tools Used Manual code review  ## Recommended Mitigation Steps A check should be included to make sure the contract being called actually exists to avoid making possible errors in the executeTransaction() function  
# Handle  TomFrench   # Vulnerability details  ## Impact  Greater costs of epoch advancement  ## Proof of Concept  The `Advance` event emits the block number and timestamp in its data  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L24  These fields are attached to events by default so it's unnecessary to manually emit them (and pay the associated gas costs)  ## Recommended Mitigation Steps  Remove `block` and `timestamp` fields from `Advance` event  
# Handle  TomFrench   # Vulnerability details  ## Impact  Unintended advancement incentives being paid out to third party  ## Proof of Concept  `DAO.sol` incentives outside parties to advance the epoch by minting 100 MALT tokens for calling the `advance` function. This is limited by checking that the start timestamp of the next epoch has passed.   https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63  This start timestamp is calculated by multiplying the new epoch number by the length of an epoch and adding it to the genesis timestamp.  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L65-L67  This method makes no accommodation for the fact that previous epochs may have been set to be a different length to what they are currently.  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L111-L114  In the case where the epoch length is reduced, `DAO` will think that the epoch number can be incremented potentially many times. Provided the `advanceIncentive` is worth more than the gas necessary to advance the epoch will be rapidly advanced potentially many times paying out unnecessary incentives.  ## Recommended Mitigation Steps  Rather than calculating from the genesis timestamp, store the last time that the epoch length was modified and calculate from there.  
# Handle  gzeon   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L61 ```     return (       maltDataLab.maltPriceAverage(priceLookback) > priceTarget * (10000 - thresholdBps) / 10000,       "The price of Malt is below peg. Wait for peg to be regained or purchase arbitrage tokens."     ); ``` when the condition is true (which should be the majority of time), the reason string is unnecessary. Only return the string when the condition is false.  
# Handle  Koustre   # Vulnerability details  ## Impact In UniswapHandler, in the function ```removeBuyer``` there is a for loop over an unbounded Buyers array, which if the buyers array gets too large can cause a denial of service and prevents the contract from being able to remove buyer roles from users/contracts. This would allow users/contracts to circumvent recovery mode and to continue to purchase and sell tokens using the contract.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used - Manual Study ## Recommended Mitigation Steps - remove unbounded for loop  
# Handle  harleythedog   # Vulnerability details  ## Impact In ForfeitHandler.sol, there are two values `swingTraderRewardCut ` and `treasuryRewardCut `, and these values always sum to 1000. Instead of having to go through all of the logic of setting these values independently and always ensuring that they sum to 1000, it would be simpler (and definitely save a lot of gas) if you simply removed everything related to `treasuryRewardCut` and always just used `1000-swingTraderRewardCut` in its place.  This also is more similar to what is done in StabilizerNode.sol where `treasuryCut` is simply what is left over after other components have taken their cut.  ## Proof of Concept See ForfeitHandler.sol here: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ForfeitHandler.sol  ## Tools Used Inspection  ## Recommended Mitigation Steps Simplify logic and save gas by removing `treasuryRewardCut`.  
# Handle  harleythedog   # Vulnerability details  ## Impact In UniswapHandler.sol within the `removeBuyer` function, there is a statement on line 308: ``` address buyer; ```  This variable is not used at all in the rest of the function, so this statement can be removed to save gas.  ## Proof of Concept See statement here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L308  ## Tools Used Inspection  ## Recommended Mitigation Steps Remove unnecessary line to save gas  
# Handle  gzeon   # Vulnerability details  ## Impact When malt is under-peg and the swing trader module do not have enough capital to buy back to peg, a Dutch auction is triggered to sell arb token. The price of the Dutch auction decrease linearly toward endprice until _endAuction() is called. https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L589  _endAuction() is called in   1. When auction.commitments >= auction.maxCommitments https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L212  2. On stabilize() -> checkAuctionFinalization() -> _checkAuctionFinalization() https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L146 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754  3. On stabilize() ->_startAuction() -> triggerAuction() -> _checkAuctionFinalization() https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L170 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754  It is possible manipulate the dutch auction by preventing _endAuction() being called.  ## Proof of Concept Consider someone call purchaseArbitrageTokens with auction.maxCommitments minus 1 wei, `_endAuction` won't be called because auction.commitments < auction.maxCommitments. Further purchase would revert because `purchaseAndBurn` (https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L184) would likely revert since swapping 1 wei in most AMM will fail due to rounding error. Even if it does not revert, there is no incentive to waste gas to purchase 1 wei of token.  As such, the only way for the auction to finalize is to call stabilize().  However, this is not immediately possible because it require  `block.timestamp >= stabilizeWindowEnd` where `stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod` stabilizeBackoffPeriod is initially set to 5 minutes in the contract  After 5 minute, stabilize() can be called by anyone. By using this exploit, an attacker can guarantee he can purchase at (startingPrice+endingPrice)/2 or lower, given the default 10 minute auctionLength and 5 minute stabilizeBackoffPeriod. (unless a privileged user call stabilize() which override the stability window)  Also note that stabilize() might not be called since there is no incentive.  ## Recommended Mitigation Steps 1. Incentivize stabilize() or incentivize a permission-less call to _endAuction() 2. Lock-in auction price when user commit purchase  
# Handle  leastwood   # Vulnerability details  ## Impact  `MaltDataLab` integrates several `MovingAverage` contracts to fetch sensitive data for the Malt protocol. Primary data used by the protocol consists of the real value for LP tokens, the average price for Malt and average reserve ratios. `trackMaltPrice`, `trackPoolReserves` and `trackPool` are called by a restricted role denoted as the `UPDATER_ROLE` and represented by an EOA account and not another contract. Hence, the EOA account must consistently update the aforementioned functions to ensure the most up-to-date values. However, miners can censor calls to `MaltDataLab` and effectively extract value from other areas of the protocol which use stale values.  ## Proof of Concept  Consider the following attack vector: - The price of Malt exceeds the lower bound threshold and hence `stabilize` can be called by any user. - The `_stabilityWindowOverride` function is satisfied, hence the function will execute. - The state variable, `exchangeRate`, queries `maltPriceAverage` which may use an outdated exchange rate. - `_startAuction` is executed which rewards `msg.sender` with 100 Malt as an incentive for triggering an auction. - As the price is not subsequently updated, a malicious attacker could collude with a miner to censor further pool updates and continue calling `stabilize` on every `fastAveragePeriod` interval to extract incentive payments. - If the payments exceed what the `UPDATER_ROLE` is willing to pay to call `trackMaltPrice`, a user is able to sustain this attack.  This threatens the overall stability of the protocol and should be properly handled to prevent such attacks. However, the fact that `MaltDataLab` uses a series of spot price data points to calculate the `MovingAverage` also creates an area of concern as well-funded actors could still manipulate the `MovingAverage` contract by sandwiching calls to `trackMaltPrice`, `trackPool` and `trackPoolReserves`.  `trackMaltPrice`, `trackPool`, and `trackPoolReserves` should be added to the following areas of the code where applicable. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L159 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L173 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L177 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L881 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L710 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L190 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L105  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding calls to `trackMaltPrice`, `trackPoolReserves` and `trackPool` wherever the values are impacted by the protocol. This should ensure the protocol is tracking the most up-to-date values. Assuming the cumulative values are used in the `MovingAverage` contracts, then sensitive calls utilising `MaltDataLab` should be protected from flashloan attacks. However, currently this is not the case, rather `MovingAverage` consists of a series of spot price data points which can be manipulated by well-funded actors or via a flashloan. Therefore, there needs to be necessary changes made to `MaltDataLab` to use cumulative price updates as its moving average instead of spot price.  
# Handle  stonesandtrees   # Vulnerability details  ## Impact All of the `rewardToken` in a given AMM pool can be removed from the AMM pool and distributed as LP rewards.  ## Proof of Concept In the `stabilize` method in the `StabilizerNode` the initial check to see if the Malt price needs to be stabilized it uses a short period TWAP: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156  However, if the price is above the threshold for stabilization then the trade size required to stabilize looks at the AMM pool directly which is vulnerable to flashloan manipulation.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L250-L275  Attack: 1. Wait for TWAP to rise above the stabilization threshold 2. Flashloan remove all but a tiny amount of Malt from the pool. 3. Call `stabilize`. This will pass the TWAP check and execute `_distributeSupply` which in turn ultimately calls `_calculateTradeSize` in the `UniswapHandler`. This calculation will determine that almost all of the `rewardToken` needs to be removed from the pool to return the price to peg.  4. Malt will mint enough Malt to remove a lot of the `rewardToken` from the pool. 5. The protocol will now distribute that received `rewardToken` as rewards. 0.3% of which goes directly to the attacker and the rest goes to LP rewards, swing trader and the treasury.  The amount of money that can be directly stolen by a malicious actor is small but it can cause a lot of pain for the protocol as the pool will be destroyed and confusion around rewards will be created.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use a short TWAP to calculate the trade size instead of reading directly from the pool.  
# Handle  pauliax   # Vulnerability details  ## Impact Consider caching decimals when initializing malt and collateralToken to avoid repeated external calls, as they are not supposed to change unless initialized again: ```solidity   uint256 maltDecimals = malt.decimals();   uint256 decimals = collateralToken.decimals(); ```   
# Handle  hyh   # Vulnerability details  ## Impact  BONDING_ROLE cannot be managed after it was initialized.  ## Proof of Concept  ```setBonding``` set the wrong role via _swapRole:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L116  ## Recommended Mitigation Steps  Set ```BONDING_ROLE``` instead of ```REINVESTOR_ROLE``` in ```setBonding``` function:  Now: ``` function setBonding(address _bonding)  public  onlyRole(ADMIN_ROLE, "Must have admin privs") {  require(_bonding != address(0), "Cannot use address 0");  _swapRole(_bonding, bonding, REINVESTOR_ROLE);  bonding = _bonding; } ```  To be: ``` function setBonding(address _bonding)  public  onlyRole(ADMIN_ROLE, "Must have admin privs") {  require(_bonding != address(0), "Cannot use address 0");  _swapRole(_bonding, bonding, BONDING_ROLE);  bonding = _bonding; } ```  
# Handle  pauliax   # Vulnerability details  ## Impact contract PoolTransferVerification sets thresholdBps but in calculations uses only ```(10000 - thresholdBps)```. Consider pre-calculating to avoid re-evaluation again and again when this function is invoked.  
# Handle  pauliax   # Vulnerability details  ## Impact Function purchaseArbitrageTokens should validate that amount > 0, otherwise it may be possible to spam accountCommitmentEpochs with 0 amounts: ```solidity   if (auction.accountCommitments[msg.sender].commitment == 0) {     accountCommitmentEpochs[msg.sender].push(currentAuctionId);   } ```  ## Recommended Mitigation Steps require amount > 0  
# Handle  pauliax   # Vulnerability details  ## Impact There are several loops in the contract which can eventually grow so large as to make future operations of the contract cost too much gas to fit in a block, e.g.: ```solidity   for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) // function outstandingArbTokens()   while (true) // function allocateArbRewards ```  ## Recommended Mitigation Steps Consider introducing a reasonable upper limit based on block gas limits. Also, you can consider using EnumerableSet (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol) where possible, e.g. 'buyers' or 'verifierList'.  
# Handle  pauliax   # Vulnerability details  ## Impact I think this if check is incorrect, because in theory maxAmount parameter can be greater than totalMaltBalance: ```solidity     if (rewards <= deployedCapital && maxAmount != totalMaltBalance) {       // If all malt is spent we want to reset deployed capital       deployedCapital = deployedCapital - rewards;     } else {       deployedCapital = 0;     } ```  ## Recommended Mitigation Steps If my assumption is correct, the check should use balance, not maxAmount: ``solidity   balance != totalMaltBalance ``` Another possible solution: ``solidity   maxAmount <= totalMaltBalance ``` However, I think the best approach would be to eliminate 'balance' altogether: ```solidity   uint256 totalMaltBalance = malt.balanceOf(address(this));    if (totalMaltBalance == 0) {     return 0;   }    (uint256 basis,) = costBasis();    if (maxAmount > totalMaltBalance) {     maxAmount = totalMaltBalance;   }    malt.safeTransfer(address(dexHandler), maxAmount);   uint256 rewards = dexHandler.sellMalt();    if (rewards <= deployedCapital && maxAmount < totalMaltBalance) {     // If all malt is spent we want to reset deployed capital     deployedCapital = deployedCapital - rewards;   } else {     deployedCapital = 0;   }   ```  
# Handle  pauliax   # Vulnerability details  ## Impact These checks should be inclusive: ```solidity        require(amountOut > minOut, "EarlyExit: Insufficient output");   require(_bps > 0 && _bps < 1000, "Must be between 0-100%");   require(newThreshold > 0 && newThreshold < 10000, "Threshold must be between 0-100%");   require(_distance > 0 && _distance < 1000, "Override must be between 0-100%"); ```  ## Recommended Mitigation Steps Replace > with >= and < with <= where necesseary.  
# Handle  hyh   # Vulnerability details  ## Impact  A condition requires that calculated retrievable amount shouldn't be too big. If it is the function fails and the remaining portion of commitment is frozen.  As the amount is calculated by the system a user cannot do anything to retrieve remaining part of commitment, if any.  ## Proof of Concept  ```claimArbitrage``` fails if calculated redemption is higher than remaining commitment: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L230  ```userClaimableArbTokens``` calculated amount can be bigger than remaining user funds: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L279  ## Recommended Mitigation Steps  If the freezing of remainder amount is not intentional then substitute require with ceiling the amount to be retrieved with the remaining part.  Now: ``` require(redemption <= remaining.add(1), "Cannot claim more tokens than available"); ```  To be: ``` if (redemption > remaining) {  redemption = remaining; } ```   
# Handle  pauliax   # Vulnerability details  ## Impact When auction.endingTime == now, function purchaseArbitrageTokens thinks that auction is still active, while isAuctionFinished and earlyExitReturn think that it has ended: purchaseArbitrageTokens: ```solidity   require(auction.endingTime >= now, "Auction is already over"); ``` isAuctionFinished: ```solidity   return auction.endingTime > 0 && (now >= auction.endingTime || ...); ``` earlyExitReturn: ```solidity   if(active || block.timestamp < auctionEndTime) {     return 0;   } ```  ## Recommended Mitigation Steps Consider unifying it across the functions.  
# Handle  pauliax   # Vulnerability details  ## Impact In functions transferAndCall and transferWithPermit the condition should be AND, not OR: ```solidity   require(to != address(0) || to != address(this)); ```  ## Recommended Mitigation Steps ```solidity   require(to != address(0) && to != address(this)); ```   
# Handle  pauliax   # Vulnerability details  ## Impact The variable DOMAIN_SEPARATOR in contract ERC20Permit is assigned in the constructor and will not change after being initialized. However, if a hard fork happens after the contract deployment, the domain would become invalid on one of the forked chains due to the block.chainid has changed.  Also, you don't need an assmebly to retrieve chainid, you can get it from a built in variable block.chainid.  Similar issues were reported in a previous contest and were assigned a severity of low:  https://github.com/code-423n4/2021-06-realitycards-findings/issues/166  https://github.com/code-423n4/2021-09-swivel-findings/issues/98  ## Recommended Mitigation Steps An elegant solution that you may consider applying is from Sushi Trident: https://github.com/sushiswap/trident/blob/concentrated/contracts/pool/concentrated/TridentNFT.sol#L47-L62  
# Handle  pauliax   # Vulnerability details  ## Impact Inaccurate revert messages: ```solidity           _delay >= 0 && _delay < gracePeriod,   "Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod"    require(startEpoch < endEpoch, "Start cannot be before the end");   require(rewardAmount <= rewardEarned, "< earned");   require(bondedBalance > 0, "< bonded balance");   require(amount <= bondedBalance, "< bonded balance"); ```   
# Handle  ScopeLift   # Vulnerability details  ## Impact  Inside `provideReinvest` and `_bondAccount` gas can be saved by using the standard transfer method on the Malt token, since we know its implementation is correct and will return true/false.  ## Proof of Concept  N/A  ## Tools Used  N/A  ## Recommended Mitigation Steps  Replace `malt.safeTransfer(address(dexHandler), balance);` with something like:  ```solidity require(malt.transfer(address(dexHandler), balance), 'malt transfer failed'); ```   
# Handle  ScopeLift   # Vulnerability details  ## Impact  The internal `_withdraw` method does not follow the checks-effects-interactions pattern. A malicious token, or one that implemented transfer hooks, could re-enter the public calling function (such as `withdraw()`) before proper internal accounting was completed. Because the `earned` function looks up the `_userWithdrawn` mapping, which is not yet updated when the transfer occurs, it would be possible for a malicious contract to re-enter `_withdraw` repeatedly and drain the pool.  ## Proof of Concept  N/A  ## Tools Used  N/A  ## Recommended Mitigation Steps  The internal accounting should be done before the transfer occurs:  ```solidity function _withdraw(address account, uint256 amountReward, address to) internal {     _userWithdrawn[account] += amountReward;     _globalWithdrawn += amountReward;f     rewardToken.safeTransfer(to, amountReward);      emit Withdraw(account, amountReward, to);   } ```   
# Handle  ScopeLift   # Vulnerability details  ## Impact  There are four functions that can have stricter function mutability declarations. Using a stricter declaration can help the compiler save gas when it knows whether reads and writes will occur in a function  ## Proof of Concept  N/A  ## Tools Used  solc  ## Recommended Mitigation Steps  Implement the changes suggested by the Solidity compiler. For examples like `AbstractTransferVerification`, the solidity compiler is wrong because it doesn't know you plan to override this function declaration. Instead, `AbstractTransferVerification` could be an interface without a function definition  ``` contracts/AbstractTransferVerification.sol:9:3: Warning: Function state mutability can be restricted to pure   function verifyTransfer(address from, address to, uint256 amount) public view virtual returns (bool, string memory) {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/AuctionEscapeHatch.sol:168:3: Warning: Function state mutability can be restricted to view   function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/AuctionParticipant.sol:127:3: Warning: Function state mutability can be restricted to pure   function _handleRewardDistribution(uint256 rewarded) virtual internal {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/MaltDataLab.sol:202:3: Warning: Function state mutability can be restricted to pure   function _normalizedPrice(   ^ (Relevant source part starts here and spans across multiple lines). ```  
# Handle  ScopeLift   # Vulnerability details  ## Impact  On lines 85 and 101, ETH is transferred using a `.call` to an address provided as an input, but there is no verification that the call call succeeded. This can result in a call to `emergencyWithdrawGAS` or `partialWithdrawGAS` appearing successful but in reality it failed. This can happen when the provided `destination` address is a contract that cannot receive ETH, or if the `amount` provided is larger than the contract's balance  ## Proof of Concept  Enter the following in remix, deploy the `Receiver` contract, and send 1 ETH when deploying the `Permissions` contract. Call `emergencyWithdrawGAS` with the receiver address and you'll see it reverts. This would not be caught in the current code  ```solidity pragma solidity ^0.8.0;  contract Receivier{}  contract Permissions {     constructor() payable {}      function emergencyWithdrawGAS(address payable destination) external {         (bool ok, ) = destination.call{value: address(this).balance}('');         require(ok, "call failed");     } } ```  ## Tools Used  Remix  ## Recommended Mitigation Steps  In `emergencyWithdrawGAS`:  ```diff - destination.call{value: address(this).balance}(''); + (bool ok, ) = destination.call{value: address(this).balance}(''); + require(ok, "call failed"); ```  And similar for `partialWithdrawGAS`  
# Handle  ScopeLift   # Vulnerability details  ## Estimated risk level Gas Optimization  ## Impact Instantiating an array of length n is better than `push(0)`  n times and saves 20k gas in tests.  ## Proof of Concept  ## Tools Used   ## Recommended Mitigation Steps change the initializer  ```diff ## Saves ~20,000 gas on initialize  diff --git a/src/contracts/AuctionBurnReserveSkew.sol b/src/contracts/AuctionBurnReserveSkew.sol index 4ed6fa6..87d5959 100644 --- a/src/contracts/AuctionBurnReserveSkew.sol +++ b/src/contracts/AuctionBurnReserveSkew.sol @@ -51,9 +51,7 @@ contract AuctionBurnReserveSkew is Initializable, Permissions {      auction = IAuction(_auction);      auctionAverageLookback = _period;   -    for (uint i = 0; i < _period; i++) { -      pegObservations.push(0); -    } +    pegObservations = new uint256[](_period);    }      function consult(uint256 excess) public view returns (uint256) { ```  
# Handle  gzeon   # Vulnerability details  ## Impact One of the innovative feature of Malt is to block buying while under peg. The buy block can be bypassed by swapping to the whitelisted UniswapHandler, and then extract the token by abusing the add and remove liquidity function. This is considered a high severity issue because it undermine to protocol's ability to generate profit by the privileged role as designed and allow potential risk-free MEV.  ## Proof of Concept 1) User swap dai into malt and send malt directly to uniswapHandler, this is possible becuase uniswapHandler is whitelisted `swapExactTokensForTokens(amountDai, 0, [dai.address, malt.address], uniswapHandler.address, new Date().getTime() + 10000);` 2) User send matching amount of dai to uniswapHandler 3) User call addLiquidity() and get back LP token 4) User call removeLiquidity() and get back both dai and malt  ## Recommended Mitigation Steps According to documentation in https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol > Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode. , this should be exploitable. Meanwhile the current implementation did not actually allow remove liquidity during recovery mode (refer to issue "Unable to remove liquidity in Recovery Mode") This exploit can be mitigated by disabling addLiquidity() when the protocol is in recovery mode  
# Handle  gzeon   # Vulnerability details  ## Impact According to https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol > When the Malt price TWAP drops below a specified threshold (eg 2% below peg) then the protocol will revert any transaction that tries to remove Malt from the AMM pool (ie buying Malt or removing liquidity). Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode.  However, in https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L236 liquidity removed is directly sent to msg.sender, which would revert if it is not whitelisted https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L53  ## Recommended Mitigation Steps Liquidity should be removed to UniswapHandler contract, then the proceed is sent to msg.sender  
# Handle  WatchPug   # Vulnerability details  Based on the context, `maltDataLab.trackReserveRatio()` should be called once a market buy/sell is made.  However, in `_distributeSupply()` when `swingAmount >= tradeSize`, after a market sell, the function returned without `maltDataLab.trackReserveRatio()`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L145-L174  ```solidity=145{168,170,172}   function stabilize() external notSameBlock {     auction.checkAuctionFinalization();      require(       block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),       "Can't call stabilize"     );     stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;      rewardThrottle.checkRewardUnderflow();      uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);      if (!_shouldAdjustSupply(exchangeRate)) {       maltDataLab.trackReserveRatio();        lastStabilize = block.timestamp;       return;     }      emit Stabilize(block.timestamp, exchangeRate);      if (exchangeRate > maltDataLab.priceTarget()) {       _distributeSupply();     } else {       _startAuction();     }      lastStabilize = block.timestamp;   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L211-L246  ```solidity=211{228-230,244}   function _distributeSupply() internal {     if (supplyDistributionController != address(0)) {       bool success = ISupplyDistributionController(supplyDistributionController).check();       if (!success) {         return;       }     }      uint256 priceTarget = maltDataLab.priceTarget();     uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);      if (tradeSize == 0) {       return;     }      uint256 swingAmount = swingTrader.sellMalt(tradeSize); // @Auditor: At this time, a market operation occurred, affecting the reserveRatio      if (swingAmount >= tradeSize) {       return;     }      tradeSize = tradeSize - swingAmount;      malt.mint(address(dexHandler), tradeSize);     emit MintMalt(tradeSize);     uint256 rewards = dexHandler.sellMalt();      auctionBurnReserveSkew.addAbovePegObservation(tradeSize);      uint256 remaining = _replenishLiquidityExtension(rewards);      _distributeRewards(remaining);      maltDataLab.trackReserveRatio();     impliedCollateralService.claim();   } ```  ### Recommendation  Consider moving `maltDataLab.trackReserveRatio()` from `_distributeSupply()`, `_startAuction()` to `stabilize()` before L173.  
# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L135-L141  ```solidity=135   function _notSameBlock() internal {     require(       block.number > lastBlock[_msgSender()],       "Can't carry out actions in the same block"     );     lastBlock[_msgSender()] = block.number;   } ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L223-L223 ```solidity=223 require(!auction.active, "Cannot claim tokens on an active auction"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L230-L230 ```solidity=230 require(redemption <= remaining.add(1), "Cannot claim more tokens than available"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L659-L659 ```solidity=659 require(auction.startingTime > 0, "No auction available for the given id"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L177-L177 ```solidity=177 require(!active, "Cannot exit early on an active auction"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L136-L136 ```solidity=136 require(_index > replenishingIndex, "Cannot replenishingIndex to old value"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L56-L56 ```solidity=56 require(block.timestamp >= getEpochStartTime(epoch + 1), "Cannot advance epoch until start of new epoch"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L81-L81 ```solidity=81 require(balance >= value, "ERC20Permit: transfer amount exceeds balance"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L122-L122 ```solidity=122 require(balance >= value, "ERC20Permit: transfer amount exceeds balance"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Malt.sol#L65-L65 ```solidity=65 require(_service != address(0), "Cannot use address 0 as transfer service"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L412-L412 ```solidity=412 require(_sampleLength > 0, "Cannot have 0 second sample length"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L154-L154 ```solidity=154 require(forfeited <= _globals.declaredBalance, "Cannot forfeit more than declared"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L275-L275 ```solidity=275 require(amount <= _globals.declaredBalance, "Can't decrement more than total reward balance"); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L118-L121 ```solidity=118     require(       eta >= block.timestamp.add(delay),       "Timelock::queueTransaction: Estimated execution block must satisfy delay."     ); ```   https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L165-L176 ```solidity=165     require(       queuedTransactions[txHash],       "Timelock::executeTransaction: Transaction hasn't been queued."     );     require(       block.timestamp >= eta,       "Timelock::executeTransaction: Transaction hasn't surpassed time lock."     );     require(       block.timestamp <= eta.add(gracePeriod),       "Timelock::executeTransaction: Transaction is stale."     ); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L195-L198 ```solidity=195     require(       success,       "Timelock::executeTransaction: Transaction execution reverted."     ); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L114-L132  ```solidity=114 function unbondAndBreak(uint256 amount)     external   {     require(amount > 0, "Cannot unbond 0");      uint256 bondedBalance = balanceOfBonded(msg.sender);      require(bondedBalance > 0, "< bonded balance");     require(amount <= bondedBalance, "< bonded balance");      // Avoid leaving dust behind     if (amount.add(1e16) > bondedBalance) {       amount = bondedBalance;     }      miningService.onUnbond(msg.sender, amount);      _unbondAndBreak(amount);   } ```  L121, the check of `bondedBalance > 0` is unnecessary, since the L122 already included the same check.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L118-L127  ```solidity=118{121-122, 124}   function transferAndCall(address to, uint value, bytes calldata data) external returns (bool) {     require(to != address(0) || to != address(this));      uint256 balance = balanceOf(msg.sender);     require(balance >= value, "ERC20Permit: transfer amount exceeds balance");      _transfer(msg.sender, to, value);      return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);   } ```  L121-L122, the check of `balance >= value` is unnecessary, since the L124 already included the same check.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L424-L442  ```solidity=424   function setSampleMemory(uint256 _sampleMemory)     external     onlyRole(ADMIN_ROLE, "Must have admin privs")   {     require(_sampleMemory > 0, "Cannot have sample memroy of 0");      if (_sampleMemory > sampleMemory) {       for (uint i = sampleMemory; i < _sampleMemory; i++) {         samples.push();       }       counter = counter % _sampleMemory;     } else {       activeSamples = _sampleMemory;        // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST     }      sampleMemory = _sampleMemory;   } ```  In the current implementation, when `sampleMemory` is updated, the samples index will be malposition, making `getValueWithLookback()` get the wrong samples, so that returns the wrong value.  ## PoC  -  When initial sampleMemory is `10` -  After `movingAverage.update(1e18)` being called for 120 times -  The admin calls `movingAverage.setSampleMemory(118)` and set sampleMemory to `118`  The current `movingAverage.getValueWithLookback(sampleLength * 10)` returns `0.00000203312 e18`, while it's expeceted to be `1e18`  After `setSampleMemory()`, `getValueWithLookback()` may also return `0`or revert FullMath: FULLDIV_OVERFLOW at L134.  ### Recommendation  Consider removing `setSampleMemory` function.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L136-L141  ```solidity if (profit > 0) {     uint256 lpCut = profit.mul(lpProfitCut).div(1000);      collateralToken.safeTransfer(address(rewardThrottle), lpCut);     rewardThrottle.handleReward();   } ```  Given that `lpProfitCut` can be `0`, checking if `lpProfitCut > 0` can avoid unnecessary code execution (including external calls) and save some gas.  
# Handle  WatchPug   # Vulnerability details  Checking `uint256` variables >= 0 is redundant as they always >= 0.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L169-L172  ```solidity function setLpProfitCut(uint256 _profitCut) public onlyRole(ADMIN_ROLE, "Must have admin privs") {     require(_profitCut >= 0 && _profitCut <= 1000, "Must be between 0 and 100%");     lpProfitCut = _profitCut;     } ```  `_profitCut >= 0` at L170.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77  ```solidity function setDelay(uint256 _delay)     public     onlyRole(GOVERNOR_ROLE, "Must have timelock role")   {     require(       _delay >= 0 && _delay < gracePeriod,       "Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod"     );     delay = _delay;      emit NewDelay(delay);   } ```  `_delay >= 0` at L71.  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L238-L242  ```solidity=238     if (amountTokens > unclaimedArbTokens) {       unclaimedArbTokens = 0;     } else {       unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);     } ```  `unclaimedArbTokens - amountTokens` will never underflow.  ### Recommendation  Change to:  ```solidity=238     if (amountTokens >= unclaimedArbTokens) {       unclaimedArbTokens = 0;     } else {       unclaimedArbTokens -= amountTokens;     } ```    https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L76-L80  ```solidity=76 if (premiumExcess > maxBurnSpend) {   return premiumExcess; }  uint256 usableExcess = maxBurnSpend.sub(premiumExcess); ```  `maxBurnSpend - premiumExcess` will never underflow.  ### Recommendation  Change to:  ```solidity=76 if (premiumExcess > maxBurnSpend) {   return premiumExcess; }  uint256 usableExcess = maxBurnSpend - premiumExcess; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L69-L89  ```solidity=69{76,82-84}   function getRealBurnBudget(     uint256 maxBurnSpend,     uint256 premiumExcess   ) public view returns(uint256) {     // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement     // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn      if (premiumExcess > maxBurnSpend) {       return premiumExcess;     }      uint256 usableExcess = maxBurnSpend.sub(premiumExcess);      if (usableExcess == 0) {       return premiumExcess;     }      uint256 burnable = consult(usableExcess);      return premiumExcess + burnable;   } ```  L82-84 `if (maxBurnSpend == premiumExcess)` can be combined with L76-78.  ### Recommendation  Change to:  ```solidity=69{76}   function getRealBurnBudget(     uint256 maxBurnSpend,     uint256 premiumExcess   ) public view returns(uint256) {     // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement     // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn      if (premiumExcess >= maxBurnSpend) {       return premiumExcess;     }      uint256 usableExcess = maxBurnSpend.sub(premiumExcess);      uint256 burnable = consult(usableExcess);      return premiumExcess + burnable;   } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L131-L140  ```solidity=131     uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;     if (progressionBps > 10000) {         progressionBps = 10000;     }      if (fullReturn > amount) {         // Allow a % of profit to be realised         uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;         return amount + maxProfit;     } ```  If we assume that `maxEarlyExitBps` is 200 and `cooloffPeriod` is 1 day, when `progressionBps` less than 50, `(maxEarlyExitBps * progressionBps / 10000)` will be 0 due to precision loss, which resulted in `maxProfit` is 0.  When `maxEarlyExitBps` is set smaller, the margin of error will be even larger.  # POC  Given:  - Current price of arb token is 0.8 DAI  1. Alice calls `purchaseArbitrageTokens()` and purchase with 8,000 DAI; 2. 7 mins later, the market price of MALT become 0.9 DAI; Alice calls `exitEarly()`, it will mint 8,888.88 Malt and receive 8,000 DAI, while it's expected to 8,890 MALT and 8,000.96 DAI.  ### Recommendation  Change to:  ```solidity if (fullReturn > amount) {     // Allow a % of profit to be realised     uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * 1000 * progressionBps / 10000) / 1000 / 1000;     return amount + maxProfit; } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132  ```solidity=116   function getPegDeltaFrequency() public view returns (uint256) {     uint256 initialIndex = 0;     uint256 index;      if (count > auctionAverageLookback) {       initialIndex = count - auctionAverageLookback;     }      uint256 total = 0;      for (uint256 i = initialIndex; i < count; ++i) {       index = _getIndexOfObservation(i);       total = total + pegObservations[index];     }      return total * 10000 / auctionAverageLookback;   } ```  ### Recommendation  Change to:  ```solidity=116   function getPegDeltaFrequency() public view returns (uint256) {     uint256 availablePegObservationsCount;     {       uint256 auctionAverageLookback_ = auctionAverageLookback;       uint256 count_ = count;       availablePegObservationsCount = count_ > auctionAverageLookback_ ? auctionAverageLookback_ : count_;     }      uint256 total = 0;     for (uint256 i = 0; i < availablePegObservationsCount; ++i) {       total += pegObservations[i];     }     return total * 10000 / availablePegObservationsCount;   } ```  
# Handle  WatchPug   # Vulnerability details  Using `++i` is more gas efficient than `i++`, especially in a loop.  For example:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L54-L56 ```solidity=54 for (uint i = 0; i < _period; i++) {   pegObservations.push(0); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L193-L195 ```solidity=193 for (uint i = auctionAverageLookback; i < _lookback; i++) {   pegObservations.push(0); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L60-L62 ```solidity=60 for (uint i = 0; i < sampleMemory; i++) {   samples.push(); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L187-L195  ```solidity=187 for (uint256 i = 0; i < sampleMemory; i++ ) {   tempCount += 1;   liveSample = samples[_getIndexOfSample(tempCount)];   liveSample.timestamp = currentTimestamp;   liveSample.cumulativeValue = currentCumulative;    currentCumulative += addition;   currentTimestamp += uint64(sampleLength); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L292-L300 ```solidity=292 for (uint256 i = 0; i < sampleMemory; i++ ) {   tempCount += 1;   liveSample = samples[_getIndexOfSample(tempCount)];   liveSample.timestamp = currentTimestamp;   liveSample.cumulativeValue = currentCumulative;    currentCumulative += addition;   currentTimestamp += uint64(sampleLength); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L431-L433 ```solidity=431 for (uint i = sampleMemory; i < _sampleMemory; i++) {   samples.push(); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/libraries/UniswapV2Library.sol#L66-L69 ```solidity=66 for (uint i; i < path.length - 1; i++) {     (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);     amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132  ```solidity=116{131}   function getPegDeltaFrequency() public view returns (uint256) {     uint256 initialIndex = 0;     uint256 index;      if (count > auctionAverageLookback) {       initialIndex = count - auctionAverageLookback;     }      uint256 total = 0;      for (uint256 i = initialIndex; i < count; ++i) {       index = _getIndexOfObservation(i);       total = total + pegObservations[index];     }      return total * 10000 / auctionAverageLookback;   } ```  When `count < auctionAverageLookback`, at L131, it should be `return total * 10000 / count;`. The current implementation will return a smaller value than expected.  The result of `getPegDeltaFrequency()` will be used for calculating `realBurnBudget` for auctions. With the result of `getPegDeltaFrequency()` being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.  
# Handle  WatchPug   # Vulnerability details  The default `upperStabilityThreshold` and `lowerStabilityThreshold` assumes that `rewardToken.decimals()` is 18.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L32-L33  ```solidity=32   uint256 public upperStabilityThreshold = (10**18) / 100; // 1%   uint256 public lowerStabilityThreshold = (10**18) / 100; ```  When the `StabilizerNode.sol` contract is initialized with a rewardToken with decimals of 8 (eg. USDC). `upperThreshold` and `lowerThreshold` will be much larger than expected.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L198-L206 ```solidity   function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {     uint256 decimals = rewardToken.decimals();     uint256 priceTarget = maltDataLab.priceTarget();      uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals); ```  ### Recommendation  Consider changing to:  ```solidity   uint256 public upperStabilityThresholdBps = 100; // 1%   uint256 public lowerStabilityThresholdBps = 100; ```  ```solidity   function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {     uint256 decimals = rewardToken.decimals();     uint256 priceTarget = maltDataLab.priceTarget();      uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10000);     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10000); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardReinvestor.sol#L62-L76  ```solidity=62 function provideReinvest(uint256 rewardLiquidity) external {     _retrieveReward(rewardLiquidity);      uint256 rewardBalance = rewardToken.balanceOf(address(this));      // This is how much malt is required     uint256 maltLiquidity = dexHandler.getOptimalLiquidity(address(malt), address(rewardToken), rewardBalance);      // Transfer the remaining Malt required     malt.safeTransferFrom(msg.sender, address(this), maltLiquidity);      _bondAccount(msg.sender);      emit ProvideReinvest(msg.sender, rewardLiquidity);   } ```  `_retrieveReward` will call `MiningService.sol#withdrawRewardsForAccount()` which uses `amount` as max withdrawnAmount, if there are no enough rewards, the actual rewarded amount will be less than `amount`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MiningService.sol#L155-L179  ```solidity=155 function withdrawRewardsForAccount(address account, uint256 amount)     public     onlyRole(REINVESTOR_ROLE, "Must have reinvestor privs")   {     _withdrawMultiple(account, amount);   }    /*    * INTERNAL FUNCTIONS    */   function _withdrawMultiple(address account, uint256 amount) internal {     for (uint i = 0; i < mines.length; i = i + 1) {       if (!mineActive[mines[i]]) {         continue;       }        uint256 withdrawnAmount = IRewardMine(mines[i]).withdrawForAccount(account, amount, msg.sender);        amount = amount.sub(withdrawnAmount);        if (amount == 0) {         break;       }     }   } ```  ### Recommendation  Consider using `rewardBalance` as the value of the `reward` parameter.  
# Handle  0x0x0x   # Vulnerability details  ## Concept  In `MovingAverage.sol`, `uint64` is used for computation of time etc. But computations with `uint64` does cost more gas and furthermore `block.timestamp` is `uint256`, which is additionally casted to `uint64`. `uint32` is used for indexes, but this can also be changed with `uint256`.  Same applies for `RewardDistributer.sol.`  ## Recommendation  Use `uint256` rather than custom `uint`.  
# Handle  0x0x0x   # Vulnerability details  ## Concept  [https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L200-L212](https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L200-L212):  ```   uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;     if (progressionBps > 10000) {       progressionBps = 10000;     }      if (fullReturn > amount) {       // Allow a % of profit to be realised       uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;       uint256 desiredReturn = amount + maxProfit;       maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;     }       return maltQuantity; ```  `progressionBps` is only used, if there is a profit. Calculations of this parameter should be under if statement checking whether there is a profit to save gas and increase readability as follows:  ```      if (fullReturn > amount) {       // Allow a % of profit to be realised    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;      if (progressionBps > 10000) {        progressionBps = 10000;      }       uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;       uint256 desiredReturn = amount + maxProfit;       maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;     }       return maltQuantity; ```  
# Handle  WatchPug   # Vulnerability details  Unused storage variables in contracts use up storage slots and increase contract size and gas usage at deployment and initialization.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L57-L57 ```solidity=57 address public uniswapV2Factory; ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L80-L86  ```solidity=80 function emergencyWithdrawGAS(address payable destination)     external      onlyRole(TIMELOCK_ROLE, "Only timelock can assign roles")   {     // Transfers the entire balance of the Gas token to destination     destination.call{value: address(this).balance}('');   } ```  The error message "Only timelock can assign roles" can be changed to "Only timelock can emergencyWithdrawGAS".  Other examples include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L104-L110  ```solidity=104 function partialWithdraw(address _token, address destination, uint256 amount)     external      onlyRole(TIMELOCK_ROLE, "Only timelock can assign roles")   {     ERC20 token = ERC20(_token);     token.safeTransfer(destination, amount);   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L94-L94  ```solidity=94 require(_pool != address(0), "Cannot have 0 lookback"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L230-L230  ```solidity=230 require(_period > 0, "Cannot have 0 lookback period"); ```  
# Handle  0x0x0x   # Vulnerability details  ## Impact  In case the reward token is changed, `totalDeclaredReward` will be changed and likely equal to `0`.  Since `_userStakePadding` and `_globalStakePadding` are accumulated, changing the reward token will not reset those values. Thus, it will create problems.  ## Recommendation  I think it would be the best to remove this function.   If you want to keep it, then it must have an event and it should be used by a timelock contract. Furthermore, it has to be used carefully and the new token should be distributed such that padding variables still make sense.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L112-L116  ```solidity=112   function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool) {     _approve(msg.sender, spender, value);      return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);   } ```  ```solidity=208 function _transfer(address sender, address recipient, uint256 amount) internal virtual {     require(sender != address(0), "ERC20: transfer from the zero address");     require(recipient != address(0), "ERC20: transfer to the zero address");      _beforeTokenTransfer(sender, recipient, amount);      _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");     _balances[recipient] = _balances[recipient].add(amount);     emit Transfer(sender, recipient, amount); } ```  Using approve() to manage allowances opens yourself and users of the token up to frontrunning. Best practice, but doesn't usually matter.  [Explanation](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit) of this possible attack vector  See also: [0xProject/0x-monorepo#850](https://github.com/0xProject/0x-monorepo/issues/850)  Using increase/decreaseAllowance instead is recommended.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L154-L154  ```solidity=154 uint64 blockTimestamp = uint64(block.timestamp % 2**64);  ```  Use `uint64(n)` can cut off higher-order bits already, `n % 2**64` is redundant.  See: https://docs.soliditylang.org/en/v0.8.10/types.html#explicit-conversions  ### Recommendation  Change to:  ```solidity=154 uint64 blockTimestamp = uint64(block.timestamp);  ```  
# Handle  0x0x0x   # Vulnerability details  ## Impact  `!= 0` is a cheaper operation compared to `> 0`, when dealing with `uint`.  ## Occurences  ```  ./AbstractRewardMine.sol:147:    if (rewardDenominator > 0) { ./Auction.sol:219:    require(amountTokens > 0, "No claimable Arb tokens"); ./Auction.sol:265:    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments); ./Auction.sol:385:    return auction.startingTime > 0; ./Auction.sol:639:    if (realBurnBudget > 0) { ./Auction.sol:659:    require(auction.startingTime > 0, "No auction available for the given id"); ./Auction.sol:663:    if (auction.maltPurchased > 0) { ./Auction.sol:861:          if (auction.commitments > 0 || !auction.finalized) { ./Auction.sol:894:    require(_length > 0, "Length must be larger than 0"); ./Auction.sol:972:    require(_split > 0 && _split <= 10000, "Must be between 0-100%"); ./Auction.sol:980:    require(_maxEnd > 0 && _maxEnd <= 1000, "Must be between 0-100%"); ./Auction.sol:988:    require(_lookback > 0, "Must be above 0"); ./Auction.sol:996:    require(_lookback > 0, "Must be above 0"); ./Auction.sol:1004:    require(_bps > 0 && _bps < 1000, "Must be between 0-100%"); ./Auction.sol:1012:    require(_threshold > 0, "Must be between greater than 0"); ./AuctionBurnReserveSkew.sol:109:    if (aggregate.maxCommitments > 0) { ./AuctionBurnReserveSkew.sol:190:    require(_lookback > 0, "Cannot have zero lookback period"); ./AuctionEscapeHatch.sol:191:    require(amount > 0, "Nothing to claim"); ./AuctionEscapeHatch.sol:222:    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, "Must be between 0-100%"); ./AuctionEscapeHatch.sol:230:    require(_period > 0, "Cannot have 0 lookback period"); ./AuctionPool.sol:118:    if (globalRewarded > 0 && userReward > 0) { ./AuctionPool.sol:125:    if (forfeitAmount > 0) { ./AuctionPool.sol:129:    if (declaredRewardDecrease > 0) { ./AuctionPool.sol:141:    if (forfeitedRewards > 0) { ./Bonding.sol:87:    require(amount > 0, "Cannot bond 0"); ./Bonding.sol:97:    require(amount > 0, "Cannot unbond 0"); ./Bonding.sol:101:    require(bondedBalance > 0, "< bonded balance"); ./Bonding.sol:117:    require(amount > 0, "Cannot unbond 0"); ./Bonding.sol:121:    require(bondedBalance > 0, "< bonded balance"); ./Bonding.sol:283:      if (diff > 0) { ./DAO.sol:47:    if (offeringMint > 0) { ./DAO.sol:78:    require(amount > 0, "Cannot have zero amount"); ./DAO.sol:94:    require(_length > 0, "Cannot have zero length epochs"); ./ERC20VestedMine.sol:93:    if (globalRewarded > 0 && userReward > 0) { ./ERC20VestedMine.sol:115:    if (forfeitReward > 0) { ./ERC20VestedMine.sol:119:    if (declaredRewardDecrease > 0) { ./ForfeitHandler.sol:49:    if (swingTraderCut > 0) { ./ForfeitHandler.sol:53:    if (treasuryCut > 0) { ./ImpliedCollateralService.sol:64:    if (maxAmount > 0) { ./ImpliedCollateralService.sol:68:    if (maxAmount > 0) { ./ImpliedCollateralService.sol:71:      // if (maxAmount > 0) { ./ImpliedCollateralService.sol:74:      //   if (maxAmount > 0) { ./LiquidityExtension.sol:161:    require(_ratio > 0 && _ratio <= 100, "Must be between 0 and 100"); ./MaltDataLab.sol:234:    require(_price > 0, "Cannot have 0 price"); ./MaltDataLab.sol:242:    require(_lookback > 0, "Cannot have 0 lookback"); ./MaltDataLab.sol:250:    require(_lookback > 0, "Cannot have 0 lookback"); ./MaltDataLab.sol:258:    require(_lookback > 0, "Cannot have 0 lookback"); ./MovingAverage.sol:385:    if (oldSample.timestamp > 0 && activeSamples > 1) { ./MovingAverage.sol:412:    require(_sampleLength > 0, "Cannot have 0 second sample length"); ./MovingAverage.sol:428:    require(_sampleMemory > 0, "Cannot have sample memroy of 0"); ./PoolTransferVerification.sol:76:    require(newThreshold > 0 && newThreshold < 10000, "Threshold must be between 0-100%"); ./PoolTransferVerification.sol:85:    require(lookback > 0, "Cannot have 0 lookback"); ./RewardReinvestor.sol:93:    require(rewardLiquidity > 0, "Cannot reinvest 0"); ./RewardReinvestor.sol:115:    if (maltBalance > 0) { ./RewardReinvestor.sol:119:    if (rewardTokenBalance > 0) { ./RewardSystem/RewardDistributor.sol:144:    require(reward > 0, "Cannot declare 0 reward"); ./RewardSystem/RewardDistributor.sol:266:    if (amount > 0) { ./RewardSystem/RewardDistributor.sol:277:    if (amount > 0) { ./RewardSystem/RewardOverflowPool.sol:76:    require(_maxFulfillment > 0, "Can't have 0 max fulfillment"); ./RewardSystem/RewardThrottle.sol:85:    if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) { ./RewardSystem/RewardThrottle.sol:89:      if (remainder > 0) { ./RewardSystem/RewardThrottle.sol:271:          if (underflow > 0) { ./RewardSystem/RewardThrottle.sol:323:    require(_smoothingPeriod > 0, "No zero smoothing period"); ./StabilizerNode.sol:270:    if (callerCut > 0) { ./StabilizerNode.sol:274:    if (auctionPoolCut > 0) { ./StabilizerNode.sol:278:    if (swingTraderCut > 0) { ./StabilizerNode.sol:282:    if (treasuryCut > 0) { ./StabilizerNode.sol:286:    if (daoCut > 0) { ./StabilizerNode.sol:290:    if (lpCut > 0) { ./StabilizerNode.sol:359:    require(_period > 0, "Must be greater than 0"); ./StabilizerNode.sol:406:    require(_incentive > 0, "No negative incentive"); ./StabilizerNode.sol:417:    require(amount > 0, "No negative damping"); ./StabilizerNode.sol:449:    require(_upper > 0 && _lower > 0, "Must be above 0"); ./StabilizerNode.sol:488:    require(_maxContribution > 0 && _maxContribution <= 100, "Must be between 0 and 100"); ./StabilizerNode.sol:552:    require(_period > 0, "Cannot have 0 period"); ./StabilizerNode.sol:561:    require(_distance > 0 && _distance < 1000, "Override must be between 0-100%"); ./StabilizerNode.sol:570:    require(_period > 0, "Cannot have 0 period"); ./SwingTrader.sol:136:    if (profit > 0) { ./libraries/SafeBurnMintableERC20.sol:70:        if (returndata.length > 0) { // Return data is optional ./libraries/UniswapV2Library.sol:37:        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); ./libraries/UniswapV2Library.sol:38:        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:44:        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); ./libraries/UniswapV2Library.sol:45:        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:54:        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); ./libraries/UniswapV2Library.sol:55:        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) {  ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L356-L360  ```solidity=356   function _getCurrentSample() private view returns (Sample storage currentSample) {     // Active sample is always counter - 1. Counter is the in progress sample     uint32 currentSampleIndex = _getIndexOfSample(counter - 1);     currentSample = samples[currentSampleIndex];   } ```  The local variable `currentSampleIndex` is used only once. Making the expression inline can save gas.  Similar issue exists in `_getFirstSample()`, `_getNthSample()`, `AuctionBurnReserveSkew.sol#getRealBurnBudget()`, `MovingAverage.sol#_getFirstSample()`.  ### Recommendation  Change to:  ```solidity=356   function _getCurrentSample() private view returns (Sample storage currentSample) {     // Active sample is always counter - 1. Counter is the in progress sample     currentSample = samples[_getIndexOfSample(counter - 1)];   } ```  
# Handle  0x0x0x   # Vulnerability details  ## Vulnerability  `AuctionEschapeHatch.sol#exitEarly` takes as input `amount` to represent how much of the   When the user exits an auction with profit, to apply the profit penalty less `maltQuantity` is liquidated compared to how much malt token the liquidated amount corresponds to. The problem is `auction.amendAccountParticipation()` simply subtracts the malt quantity with penalty and full `amount` from users auction stats. This causes a major problem, since in `_calculateMaltRequiredForExit` those values are used for calculation by calculating maltQuantity as follow:  `uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);`   The ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking (since penalty is applied to substracted `maltQuantity` from `userMaltPurchased`), by doing so a user can earn more than it should. Since after each profit taking users commitment corresponds to proportionally more malt, the user can even reduce profit penalties by dividing `exitEarly` calls in several calls.  In other words, the ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking and user can claim more malt with less commitment. Furthermore after all `userMaltPurchased` is claimed the user can have `userCommitment` left over, which can be used to `claimArbitrage`, when possible.  ## Mitigation Step  Make sure which values are used for what and update values which doesn't create problems like this. Rethink about how to track values of an auction correctly.  
# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style of function names does not follow the best practices:  - MaltDAO#incrementEpoch()      https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L106-L119  ```solidity=106{107} /* Internal methods */ function incrementEpoch() internal {     epoch = epoch.add(1); }  function _setEpochLength(uint256 length) internal {     epochLength = length;     emit SetEpochLength(length); }  function _setMaltToken(address _malt) internal {     malt = IBurnMintableERC20(_malt);     emit SetMaltToken(_malt); } ```  
# Handle  WatchPug   # Vulnerability details  The purpose of a Timelock contract is to put a limit on the privileges of the `governor`, by forcing a two step process with a preset delay time.  However, we found that the current implementation actually won't serve that purpose as it allows the `governor` to execute any transactions without any constraints.  To do that, the current governor can call `Timelock#setGovernor(address _governor)` and set a new `governor` effective immediately.  And the new `governor` can then call `Timelock#setDelay()` and change the delay to `0`, also effective immediately.  The new `governor` can now use all the privileges without a delay, including granting minter role to any address and mint unlimited amount of MALT.  In conclusion, a Timelock contract is supposed to guard the protocol from lost private key or malicious actions. The current implementation won't fulfill that mission.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L98-L105 ```solidity=98{100,102-103}   function setGovernor(address _governor)     public     onlyRole(GOVERNOR_ROLE, "Must have timelock role")   {     _swapRole(_governor, governor, GOVERNOR_ROLE);     governor = _governor;     emit NewGovernor(_governor);   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77 ```solidity=66{71,74}   function setDelay(uint256 _delay)     public     onlyRole(GOVERNOR_ROLE, "Must have timelock role")   {     require(       _delay >= 0 && _delay < gracePeriod,       "Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod"     );     delay = _delay;      emit NewDelay(delay);   } ```   ## Recommendation  Consider making `setGovernor` and `setDelay` only callable from the Timelock contract itself.  Specificaly, changing from `onlyRole(GOVERNOR_ROLE, "Must have timelock role")` to `require(msg.sender == address(this), "...")`.  Also, consider changing `_adminSetup(_admin)` in `Timelock#initialize()` to `_adminSetup(address(this))`, so that all roles are managed by the timelock itself as well.  
# Handle  cmichel   # Vulnerability details  When adding liquidity through `UniswapHandler.addLiquidity`, the entire contract balances are used to add liquidity and the min amounts are set to 95% of these balances. If the balances in this contract are unbalanced (the ratio is not similar to the current Uniswap pool reserve ratios) then this function will revert and no liquidity is added.  See `UniswapHandler.buyMalt`:  ```solidity (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(   address(malt),   address(rewardToken),   maltBalance, // @audit-info amountADesired   rewardBalance,   // @audit assumes that whatever is in this contract is already balanced. good assumption?   maltBalance.mul(95).div(100), // @audit-info amountAMin   rewardBalance.mul(95).div(100),   msg.sender, // transfer LP tokens to sender   now ); ```  ## Impact If the contract has unbalanced balances, then the `router.addLiquidity` call will revert. Note that an attacker could even send tokens to this contract to make them unbalanced and revert, resulting in a griefing attack.  ## Recommended Mitigation Steps It needs to be ensured that the balances in the contract are always balanced and match the current reserve ratio. It might be better to avoid directly using the balances which can be manipulated by transferring tokens to the contract and accepting parameters instead of how many tokens to provide liquidity with from the caller side.  
# Handle  cmichel   # Vulnerability details  The `UniswapHandler.maltMarketPrice` function returns a tuple of the `price` and the `decimals` of the price. However, the returned `decimals` do not match the computed `price` for the `else if (rewardDecimals < maltDecimals)` branch:  ```solidity else if (rewardDecimals < maltDecimals) {   uint256 diff = maltDecimals - rewardDecimals;   price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);   decimals = maltDecimals; } ```  Note that `rewardReserves` are in reward token decimals, `maltReserves` is a malt balance amount (18 decimals). Then, the returned amount is in `rewardDecimals + diffDecimals + rewardDecimals - maltDecimals = maltDecimals + rewardDecimals - maltDecimals = rewardDecimals`. However `decimals = maltDecimals` is wrongly returned.  ## Impact Callers to this function will receive a price in unexpected decimals and might inflate or deflate the actual amount. Luckily, the `AuctionEscapeHatch` decides to completely ignore the returned `decimals` and as all prices are effectively in `rewardDecimals`, even if stated in `maltDecimals`, it currently does not seem to lead to an issue.  ## Recommendation Fix the function by returning `rewardDecimals` instead of `maltDecimals` in the `rewardDecimals < maltDecimals` branch.  
# Handle  cmichel   # Vulnerability details  The `MovingAverage.sol` contract defines several variables that in the end make the `samples` array act as a ring buffer: - `sampleMemory`: The total length (buffer size) of the `samples` array. `samples` is initialized with `sampleMemory` zero observations. - `counter`: The pending sample index (modulo `sampleMemory`)  The `_getFirstSample` function computes the first sample as `(counter + 1) % sampleMemory` which returns the correct index only _if the ring buffer is full_, i.e., it wraps around. (in the `counter + 1 >= sampleMemory`).  If the `samples` array does not wrap around yet, the zero index should be returned instead.  ## Impact Returning `counter + 1` if `counter + 1 < sampleMemory` returns a zero initialized `samples` observation index. This then leads to a wrong computation of the TWAP.  ## Recommended Mitigation Steps Add an additional check for `if (counter + 1 < sampleMemory) return 0` in `_getFirstSample`.  
# Handle  cmichel   # Vulnerability details  Certain ERC20 tokens make modifications to their ERC20's `transfer` or `balanceOf` functions. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.  ## Impact The `Bonding._bond()` function will revert in the `_balanceCheck` when transferring a fee-on-transfer token as it assumes the entire `amount` was received.  ## Recommended Mitigation Steps To support fee-on-transfer tokens, measure the asset change right before and after the asset-transferring calls and use the difference as the actual bonded amount.  
# Handle  cmichel   # Vulnerability details  The `Permissions.reassignGlobalAdmin` function is supposed to only be run with the `TIMELOCK_ROLE` role, see `onlyRole(TIMELOCK_ROLE, "Only timelock can assign roles")`.  However, the `TIMELOCK_ROLE` is not the admin of all the reassigned roles and the `revokeRole(role, oldAccount)` calls will fail as it requires the `ADMIN_ROLE`.  ## Recommended Mitigation Steps The idea might have been that only the `TIMELOCK` should be able to call this function, and usually it is also an admin, but the function strictly does not work if the caller _only_ has the `TIMELOCK` roll and will revert in this case. Maybe governance decided to remove the admin role from the Timelock, which makes it impossible to call `reassignGlobalAdmin` anymore as both the timelock and admin are locked out.  
# Handle  cmichel   # Vulnerability details  The initial `SetTransferService` event in `Malt.initialize` is not emitted.  ## Impact Off-chain programs might not correctly track the initial `transferService` variable as the initial event is missing.  ## Recommended Mitigation Steps Emit it in `initialize`.  
# Handle  cmichel   # Vulnerability details  The `ERC20.approve()` function returns a boolean value indicating success. This parameter needs to be checked for success. Some tokens do **not** revert if the transfer failed but return `false` instead.  In addition, some tokens (like [USDT L199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ```solidity IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  This issue exists for example in `AuctionParticipant.purchaseArbitrageTokens`:  ```solidity auctionRewardToken.approve(address(auction), balance); ```  As well as in `UniswapHandler.buyMalt`:  ```solidity rewardToken.approve(address(router), rewardBalance); ```  ## Impact Tokens that don't correctly implement the latest EIP20 spec, by either returning `false` on failure or reverting if approved from a non-zero value, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelins `SafeERC20` versions with the `safeApprove(0)` functions that handle the return value check as well as non-standard-compliant tokens.  
# Handle  cmichel   # Vulnerability details  The `initialize` function that initializes important contract state can be called by anyone. See: - `ERC20VestedMine.initialize` - `AuctionPool.initialize` - all contracts that extend `Permissions`  ## Impact The attacker can initialize the contract before the legitimate deployer, hoping that the victim continues to use the same contract. In the best case for the victim, they notice it and have to redeploy their contract costing gas.  ## Recommended Mitigation Steps Use the constructor to initialize non-proxied contracts. For initializing proxy contracts deploy contracts using a factory contract that immediately calls `initialize` after deployment or make sure to call it immediately after deployment and verify the transaction succeeded.  
# Handle  WatchPug   # Vulnerability details  It's a best practice for the contract implementations to inherit their interface definition.  Doing so would improve the contract's clarity, and force the implementation to comply with the defined interface.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/TransferService.sol#L14-L14 ```solidity=14 contract TransferService is Initializable, Permissions { ```  `TransferService` should inherit `ITransferService`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L20-L20  ```solidity=20 contract UniswapHandler is Initializable, Permissions { ```  `UniswapHandler` should inherit `IDexHandler`.  
# Handle  harleythedog   # Vulnerability details  ## Impact In Bonding.sol, the internal function `_unbondAndBreak` transfers a user's stake tokens to the dexHandler and then calls `removeLiquidity` on the dexHandler. Within the Uniswap handler (which is the only handler so far) `removeLiquidity` takes special care in the edge case where `router.removeLiquidity` returns zero tokens. Specifically, the Uniswap handler has this code: ``` if (amountMalt == 0 || amountReward == 0) {  liquidityBalance = lpToken.balanceOf(address(this));  lpToken.safeTransfer(msg.sender, liquidityBalance);  return (amountMalt, amountReward); } ```  If this edge case does indeed happen (i.e. if something is preventing the Uniswap router from removing liquidity at the moment), then the Uniswap handler will transfer the LP tokens back to Bonding.sol. However, Bonding.sol does not have any logic to recognize that this happened, so the LP tokens will become stuck in the contract and the user will never get any of their value back. This could be very bad if the user unbonds a lot of LP and they don't get any of it back.  ## Proof of Concept See `_unbondAndBreak` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L226  Notice how the edge case where `amountMalt == 0 || amountReward == 0` is not considered in this function, but it is considered in the Uniswap handler's `removeLiquidity` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L240  ## Tools Used Inspection.  ## Recommended Mitigation Steps Add a similar edge case check to `_unbondAndBreak`. In the case where LP tokens are transferred back to Bonding.sol instead of malt/reward, these LP tokens should be forwarded back to the user since the value is rightfully theirs.  
# Handle  leastwood   # Vulnerability details  ## Impact  The `permit` function is intended to facilitate approvals though signature verification. This helps to merge the two-step token transfer process consisting of an initial token approval and subsequent transfer. The `permit` function emits an `Approval` event, however, the `_approve` function also emits the same `Approval` event. As a result, off-chain scripts monitoring the blockchain for such events will see the same event emitted twice which may cause unintended issues.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ERC20Permit.sol#L58-L59 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L314  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider not emitting an `Approval` event in `permit`.  
# Handle  leastwood   # Vulnerability details  ## Impact  `_distributeRewards` attempts to reward LP token holders when the price of Malt exceeds its price target. Malt Finance is able to being Malt back to its peg by selling Malt and distributing rewards tokens to LP token holders. An external call to `Auction` is made via the `allocateArbRewards` function. Prior to this call, the `StabilizerNode` approves the contract for a fixed amount of tokens, however, the `allocateArbRewards` function does not necessarily utilise this entire amount. Hence, dust token approval amounts may accrue from within the `StabilizerNode` contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L252-L253 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L809-L871  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider resetting the approval amount if the input `rewarded` amount to `allocateArbRewards` is less than the output amount.  
# Handle  leastwood   # Vulnerability details  ## Impact  `addLiquidity` is called when users reinvest their tokens through bonding events. The `RewardReinvestor` first transfers Malt and rewards tokens before adding liquidity to the token pool. `addLiquidity` provides protections against slippage by a margin of 5%, and any dust token amounts are transferred back to the caller. In this instance, the caller is the `RewardReinvestor` contract which further distributes the dust token amounts to the protocol's treasury. However, the token approval for this outcome is not handled properly. Dust approval amounts can accrue over time, leading to large Uniswap approval amounts by the `UniswapHandler` contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L212-L214 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L216-L218  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider resetting the approval amount if either `maltUsed < maltBalance` or `rewardUsed < rewardBalance` in `addLiquidity`.  
# Handle  harleythedog   # Vulnerability details  ## Impact There are several ERC20 tokens that take a small fee on transfers/transferFroms (known as "fee-on-transfer" tokens). Most notably, USDT is an ERC20 token that has togglable transfer fees, but for now the fee is set to 0 (see the contract here: https://etherscan.io/address/0xdAC17F958D2ee523a2206206994597C13D831ec7#code). For these tokens, it should not be assumed that if you transfer `x` tokens to an address, that the address actually receives `x` tokens. In the current test environment, DAI is the only `collateralToken` available, so there are no issues. However, it has been noted that more pools will be added in the future, so special care will need to be taken if fee-on-transfer tokens (like USDT) are planned to be used as `collateralTokens`.  For example, consider the function `purchaseArbitrageTokens` in Auction.sol. This function transfers `realCommitment` amount of `collateralToken` to the liquidityExtension, and then calls `purchaseAndBurn(realCommitment)` on the liquidityExtension. The very first line of `purchaseAndBurn(amount)` is `require(collateralToken.balanceOf(address(this)) >= amount, "Insufficient balance");`. In the case of fee-on-transfer tokens, this line will revert due to the small fee taken. This means that all calls to `purchaseArbitrageTokens` will fail, which would be very bad when the price goes below peg, since no one would be able to participate in this auction.  ## Proof of Concept See `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177  See `purchaseAndBurn` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L117  ## Tools Used Inspection  ## Recommended Mitigation Steps Add logic to transfers/transferFroms to calculate exactly how many tokens were actually sent to a specific address. In the example given with `purchaseArbitrageTokens`, instead of calling `purchaseAndBurn` with `realCommitment`, the contract should use the difference in the liquidityExtension balance after the transfer minus the liquidityExtension  balance before the transfer.  
# Handle  thank_you   # Vulnerability details  ## Impact UniswapHandler utilizes UniswapV2Router to swap, add liquidity, and remove liquidity with the UniswapV2Pair contract. In order to utilize these functionalities, UniswapHandler must call various UniswapV2Router methods.  - addLiquidity - removeLiquidity - swapExactTokensForTokens (swaps for both DAI and Malt)  In all three methods, UniswapV2Router requires the callee to provide input arguments that define how much the amount out minimum UniswapHandler will allow for a trade. This argument is designed to prevent slippage and more importantly, sandwich attacks.  UniswapHandler correctly handles price slippage when calling [addLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L201). However, that is not the case for [removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L230) and swapExactTokensForTokens [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) and [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L173). For both methods, 0 is passed in as the amount out minimum allowed for a trade. This allows for anyone watching the mempool to sandwich attack UniswapHandler (or any contract that calls UniswapHandler) in such a way that allows the hacker to profit off of a guaranteed trade.  How does this work? Let's assume UniswapHandler makes a call to [UniswapV2Router#swapExactTokensForTokens](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) to trade DAI for Malt. Any hacker who watches the mempool and sees this transaction can immediately buy as much Malt as they want. This raises the price of Malt. Since UniswapHandler is willing to accept any amount out minimum (the number is set to [zero](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L150)), then the UniswapHandler will always trade DAI for Malt. This second transaction raises the price of Malt even further. Finally, the hacker trades their Malt for DAI, receiving a profit due to the artificially inflated price of Malt from the sandwich attack.  It's important to note that anyone has access to the UniswapV2Router contract. There are no known ACL controls on UniswapV2Router. This sandwich attack can impact even the `buyMalt` function.  The following functions when called are vulnerable to frontrunning attacks:  - [UniswapHandler#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L131) - [UniswapHandler#sellMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L160) - [UniswapHandler#removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221)  And by extension the following contract functions since they also call the UniswapHandler function calls:  - [Bonding#unbondAndBreak](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L114) - [LiquidityExtension#purchaseAndBurn](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117) - [RewardReinvestor#splitReinvest](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L78) - [StabilizerNode#stabilize](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145) - [SwingTrader#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L50)   ## Proof of Concept Refer to the impact section for affected code and links to the appropriate LoC.  ## Tools Used N/A  ## Recommended Mitigation Steps The UniswapV2Router and UniswapV2Pair contract should allow only the UniswapHandler contract to call either contract. In addition, price slippage checks should be implemented whenever removing liquidity or swapping tokens. This ensures that a frontrunning attack can't occur.   ## Anything Else We Should Know I wish I had more time to work on this bug but unfortunately I have several current clients who require significant time from me. I'm happy to pursue this beyond the initial submission, in particular building a concrete PoC. I think the most important takeaway from this bug find is that anyone can purchase Malt at any time and anyone can manipulate the Malt reserve. This in turn impacts other functionalities that rely on the Malt reserve to make price/token calculations such as exiting an auction early or reinvesting rewards.  
# Handle  0xwags   # Vulnerability details  ## Impact Since users forfeited awards will be shared between either the treasury and the swing trader, there should be a zero address in the initialize() function to ensure rewards are not lost and thereby affecting  Malt's collateralisation and other such funding mechanism.   This will have implications for safetransfer() functions in lines 50 & 54 in handleForfeit().   ## Tools Used Manual Analysis.   ## Recommended Mitigation Steps  require(treasuryMultisig&& swingTrader ! =address(0), "0x0");  
# Handle  leastwood   # Vulnerability details  ## Impact  `_calculateMaltRequiredForExit` in `AuctionEscapeHatch` currently uses Malt's spot price to calculate the quantity to return to the exiting user. This spot price simply tracks the Uniswap pool's reserves which can easily be manipulated via a flash loan attack to extract funds from the protocol.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L65-L92 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L193 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L80-L109 https://shouldiusespotpriceasmyoracle.com/  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing/integrating a TWAP oracle to track the price of Malt.  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Reuse the function argument in the event emit instead of the storage variable. This saves a SLOAD.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L82   ## Tools Used  ## Recommended Mitigation Steps - L76 write: emit NewDelay(_delay); - L92: write: emit NewGracePeriod(_gracePeriod);  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Move the initialization of sampleDiff below the if block to save gas in the case of return of the if block.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L128  ## Tools Used  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact move the sampleDiff (L86) below the if statement L88 to save the declaration/initialization of sampleDiff in the case the if block gets executed and the function returns early  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L86 ## Tools Used  ## Recommended Mitigation Steps - move the declaration/initialization of of sampleDiff below the if statement  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Reuse _sampleMemory instead of the storage variable sampleMemory in the condition statement of the loop to save gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L60 ## Tools Used  ## Recommended Mitigation Steps - rewrite L60 as: for (uint i = 0; i < _sampleMemory ; i++)  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L167  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L219  Before call _distributeSupply function, it already get priceTarget, But in _distributeSupply, it again call external call to get price target. This will use higher gas.   ## Tools Used Manual  ## Recommended Mitigation Steps Send price target in _distributeSupply() function argument, and please review all duplicated external calls and optimize them.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact In removeVerifier function, it loop until last index - 1 to find source index. If you added many verifiers, then the gas cost of removeVerifier will be very high, and it can be reverted due to gas limit as well.   ## Tools Used Manual  ## Recommended Mitigation Steps Store index of address in addVerifier function, and remove loop in removeVerifier, and use stored index.  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L62 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L78  In addVerifier and removeVerifier functions of TransferService.sol, it just returns instead of revert if it is unable to change data. Revert transaction to avoid creating unnecessary transaction and save transaction cost.   ## Tools Used Manual  ## Recommended Mitigation Steps Revert transaction instead of return.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function bondToAccount() of Bonding.sol has a check based on _notSameBlock()  _notSameBlock() makes sure the same msg.sender cannot do 2 actions within the same block.  However this can be circumvented in this case: Suppose you call bondToAccount() via a (custom) smart contract, then the msg.sender will be the address of the smart contract. For a pseudo code proof of concept see below.  I'm not sure what the deeper reason is for the _notSameBlock() in bondToAccount(). But if it is important then circumventing this check it will pose a risk.  ## Proof of Concept call function attack1.attack() ```JS contract attack1 {    function attack(address account, uint256 amount) {          call attack2.forward(account, amount);          call any other function of malt   } }  contract attack2 {    function forward(address account, uint256 amount) {        call bonding.bondToAccount(account, amount); // uses msg.sender of attack2    } } ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Bonding.sol#L81-L92  ```JS function bondToAccount(address account, uint256 amount) public {     if (msg.sender != offering) {          _notSameBlock();     }     ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Permissions.sol#L135-L141 ```JS function _notSameBlock() internal {     require( block.number > lastBlock[_msgSender()],"Can't carry out actions in the same block" );     lastBlock[_msgSender()] = block.number;   } ```  ## Tools Used  ## Recommended Mitigation Steps Add access controls to the function bondToAccount() An end-user could still call bond()   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setAuctionAverageLookback of AuctionBurnReserveSkew.sol change auctionAverageLookback  However there is also the variable "count" that is used in amongst others, addAbovePegObservation(). The modulo of count with auctionAverageLookback is calculated via _getIndexOfObservation(). When you change auctionAverageLookback then the modulo will result in a different value, so you end up in a different location of the circular buffer.  You should probably adapt count as well in the function setAuctionAverageLookback() (see also function setSampleMemory of MovingAverage.sol where a similar pattern is used)  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L186-L200  ```JS function setAuctionAverageLookback(uint256 _lookback) external onlyRole(ADMIN_ROLE, "Must have admin role") { ..     if (_lookback > auctionAverageLookback) {       for (uint i = auctionAverageLookback; i < _lookback; i++) {         pegObservations.push(0);       }     }      auctionAverageLookback = _lookback;  ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L143-L153 ```JS  function addAbovePegObservation(uint256 amount)  public onlyRole(STABILIZER_NODE_ROLE, "Must be a stabilizer node to call this method") {     uint256 index = _getIndexOfObservation(count);     ...     pegObservations[index] = 1;     count = count + 1; ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L134-L136 ```JS  function _getIndexOfObservation(uint _index) internal view returns (uint index) {     return _index % auctionAverageLookback;   } ```  ## Tools Used  ## Recommended Mitigation Steps Doublecheck the theory above and if you agree: Add the following statement in the function  setAuctionAverageLookback(), before auctionAverageLookback is updated.  ```JS  count = count  % auctionAverageLookback ; // the old version of auctionAverageLookback  ```   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setSampleMemory of MovingAverage.sol takes the modulo of counter with the new value of _sampleMemory: "counter = counter % _sampleMemory;"  Suppose: counter =15 ; sampleMemory=10 and  _sampleMemory=12 Then:   counter = counter % _sampleMemory ==> 3,  which means processing will continue at position 3.  However I think it should use: counter = counter % sampleMemory,  so it will continue at position 5  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/MovingAverage.sol#L424-L442  ```JS function setSampleMemory(uint256 _sampleMemory) external onlyRole(ADMIN_ROLE, "Must have admin privs")  {   ...     if (_sampleMemory > sampleMemory) {       ...       counter = counter % _sampleMemory;     } else {    }     sampleMemory = _sampleMemory; } ```  ## Tools Used  ## Recommended Mitigation Steps Doublecheck the theory above and if you agree: change ```JS  counter = counter % _sampleMemory; ``` to ```JS  counter = counter %  sampleMemory; ```   
# Handle  gpersoon   # Vulnerability details  ## Impact The function setStabilityThresholds of StabilizerNode.sol set the values for upperStabilityThreshold and lowerStabilityThreshold, however there is no check for a maximum value. This means that in function _shouldAdjustSupply() the values for upperThreshold and lowerThreshold  could get larger than priceTarget. When they are subtracted from priceTarget a revert will occur.  Thus it is useful the make sure that upperStabilityThreshold and lowerStabilityThreshold don't get too large.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L445-L454  ```JS function setStabilityThresholds(uint256 _upper, uint256 _lower) external onlyRole(ADMIN_ROLE, "Must have admin role") {     require(_upper > 0 && _lower > 0, "Must be above 0");     upperStabilityThreshold = _upper;     lowerStabilityThreshold = _lower; ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L198-L206  ```JS function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {    ...     uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals); // upperStabilityThreshold could be > 10**dec => upperThreshold could be > priceTarget     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);  // lowerStabilityThreshold could be > 10**dec => lowerThreshold could be > priceTarget      return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold); // can revert   } ```  ## Tools Used  ## Recommended Mitigation Steps In function setStabilityThresholds() check for a maximum value of upperStabilityThreshold and lowerStabilityThreshold  
# Handle  leastwood   # Vulnerability details  ## Impact  `_startAuction` utilises the `SwingTrader` contract to purchase Malt. If `SwingTrader` has insufficient capital to return the price of Malt back to its target price, an auction is triggered with the remaining amount. However, no auction is triggered if the current auction exists, but `msg.sender` is still rewarded for their call to `stabilize`.  ## Proof of Concept  `_shouldAdjustSupply` initially checks if the current auction is active, however, it does not check if the current auction exists. There is a key distinction between the `auctionActive` and `auctionExists` functions which are not used consistently. Hence, an auction which is inactive but exists would satisfy the edge case and result in `triggerAuction` simply returning.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L382-L386 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L342-L344 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L873-L888  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider using `auctionExists` and `auctionActive` consistently in `StabilizerNode` and `Auction` to ensure this edge case cannot be abused.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function setAdvanceIncentive of DAO.sol doesn't check for a maximum value of incentive. If incentivewould be very large, then advanceIncentive would be very large and the function advance() would mint a large amount of malt.  The function setAdvanceIncentive() can only be called by an admin, but a mistake could be made. Also if an admin would want to do a rug pull, this would be an ideal place to do it.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L98-L104  ```JS   function setAdvanceIncentive(uint256 incentive)  externalonlyRole(ADMIN_ROLE, "Must have admin role") {    ...     advanceIncentive = incentive; ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63  ```JS function advance() external { ...     malt.mint(msg.sender, advanceIncentive * 1e18);  ```  ## Tools Used  ## Recommended Mitigation Steps Check for a reasonable maximum value in advance()  
# Handle  leastwood   # Vulnerability details  ## Impact  `purchaseArbitrageTokens` enables users to commit collateral tokens and in return receive arbitrage tokens which are redeemable in the future for Malt tokens. Each auction specifies a commitment cap which when reached, prevents users from participating in the auction. However, `realCommitment` can be ignored by directly sending the `LiquidityExtension` contract collateral tokens and subsequently calling `purchaseArbitrageTokens`.  ## Proof of Concept  Consider the following scenario: - An auction is currently active. - A user sends collateral tokens to the `LiquidityExtension` contract. - The same user calls `purchaseArbitrageTokens` with amount `0`. - The `purchaseAndBurn` call returns a positive `purchased` amount which is subsequently used in auction calculations.  As a result, a user could effectively influence the average malt price used throughout the `Auction` contract.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L177-L214 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117-L128  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding a check to ensure that `realCommitment != 0` in `purchaseArbitrageTokens`.  
# Handle  gpersoon   # Vulnerability details  ## Impact In the contract Timelock.sol the following onlyRole expression occurs a few times, referring GOVERNER and timelock: onlyRole(GOVERNOR_ROLE, "Must have timelock role")  Whereas several other onlyRole expressions are referring to governor: onlyRole(GOVERNOR_ROLE, "Timelock::...: Call must come from governor.")  Either the role should be TIMELOCK_ROLE or the messages should refer consistently to governor. Otherwise it might be more difficult to solve error messages from reverts.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L68  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L84  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L100  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L115  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L140  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L159  ## Tools Used  ## Recommended Mitigation Steps Make the error messages consistent   
# Handle  leastwood   # Vulnerability details  ## Impact  Malt Finance uses solidity version `>=0.6.6` throughout all of its contracts. This solidity version provides no protections against arithmetic underflows and overflows. As a result, it is incredibly difficult to guarantee that the protocol enforces the necessary arithmetic checks during sensitive actions.  There are several instances where the OpenZeppelin's `SafeMath` library is not used. This exposes the protocol to potential exploits via arithmetic underflows and overflows. The liveness of the protocol depends on safety guarantees that are not provided/enforced. Therefore, this issue should be deemed high severity.  ## Proof of Concept  Solidity version shown in all contracts.  ## Tools Used  Manual code review. https://docs.soliditylang.org/en/v0.8.10/080-breaking-changes.html  ## Recommended Mitigation Steps  Consider updating the smart contract suite to use the latest solidity version or at the very least integrate OpenZeppelin's `SafeMath` library in all areas of the code containing arithmetic operations.  
# Handle  nathaniel   # Vulnerability details  ## Impact No vulnerability, however as `setupPartipant` would only ever be executed by the constructor in its deriving contracts, it would make sense if it was internal instead of public. If it was not executed in the constructor of the deriving contract, then at least it is safer with internal visibility.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionParticipant.sol#L30   
# Handle  nathaniel   # Vulnerability details  ## Impact The code in `getCollateralValueInMalt` of ImpliedCollateralService.sol, can leverage the `totalUsefulCollateral` function, reducing code size and gas cost when calling the contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L104-L124  ## Tools Used manual  ## Recommended Mitigation Steps Remove L108-L110, then in the return of `getCollateralValueInMalt` return `totalUsefulCollateral().mul(target).div(maltPrice) + swingTraderMaltBalance`  
# Handle  nathaniel   # Vulnerability details  ## Impact A large portion of the `unbond` and `unbondAndBreak` code of Bonding.sol is the same, to reduce code bloat and gas when calling the contract   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L97-L109  ## Tools Used Manual  ## Recommended Mitigation Steps I would suggest wrapping the duplicated code into an internal function called by `unbond` and `unbondAndBreak`.  
# Handle  hyh   # Vulnerability details  ## Impact  If Malt token be set to have lower decimals the incentives will be too big to be issued and DAO advance epoch and StabilizerNode auction start functions will fail, the system will have to be redeployed.  For example, if Malt was set to have 6 decimals like USDC, then 100*1e18 StabilizerNode defaultIncentive will be 100 trillions Malt.  ## Proof of Concept  Now some parts of the system use ```malt.decimals()``` (SwingTrader, UniswapHandler), some (StabilizerNode, DAO) use 18.  DAO advanceIncentive:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DAO.sol#L60   StabilizerNode defaultIncentive:  stabilize function https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145  calls _startAuction in low exchangeRate case, minting defaultIncentive * 10**18 = 100 * 1e18 Malt to the sender as a caller fee. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L344   ## Recommended Mitigation Steps  If Malt decimals are meant to be set to 18, add a constant variable and use it across the system to save gas.  If the flexibility is desired ```malt.decimals()``` to be used, in a form of contract storage variable for gas optimization (```decimals()``` can be saved to storage once on initialization, and read from there afterwards).   
# Handle  robee   # Vulnerability details  This issue is about arithmetic computation that could have been done more percise.  The following are places in the codebase in which you multiplied after the divisions.  Doing the multiplications at start lead to more accurate calculations.  This is a list of places in the code that this appears (Solidity file, line number, actual line):           DAO.sol, 105,   /* Internal methods */          UniswapHandler.sol, 265,         buyBase.div(priceTarget).mul(buyBase).mul(997)          RewardDistributor.sol, 113,   /* PUBLIC VIEW FUNCTIONS */          RewardDistributor.sol, 118,   /* INTERNAL VIEW FUNCTIONS */          RewardDistributor.sol, 129,   /* INTERNAL FUNCTIONS */   
# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function getRewardOwnershipFraction in AbstractRewardMine.sol could be set external         The function balanceOfStakePadding in AbstractRewardMine.sol could be set external         The function withdrawnBalance in AbstractRewardMine.sol could be set external         The function earned in AbstractRewardMine.sol could be set external         The function setMiningService in AbstractRewardMine.sol could be set external         The function totalReleasedReward in AbstractRewardMine.sol could be set external         The function totalStakePadding in AbstractRewardMine.sol could be set external         The function totalBonded in AbstractRewardMine.sol could be set external         The function totalWithdrawn in AbstractRewardMine.sol could be set external         The function setRewardToken in AbstractRewardMine.sol could be set external         The function onBond in AbstractRewardMine.sol could be set external         The function withdrawAll in AbstractRewardMine.sol could be set external         The function onUnbond in AbstractRewardMine.sol could be set external         The function balanceOfBonded in AbstractRewardMine.sol could be set external         The function verifyTransfer in AbstractTransferVerification.sol could be set external         The function getAuctionCore in Auction.sol could be set external         The function getAuctionPrices in Auction.sol could be set external         The function getAuction in Auction.sol could be set external         The function auctionActive in Auction.sol could be set external         The function getAuctionCommitments in Auction.sol could be set external         The function isAuctionFinalized in Auction.sol could be set external         The function balanceOfArbTokens in Auction.sol could be set external         The function auctionExists in Auction.sol could be set external         The function consult in AuctionBurnReserveSkew.sol could be set external         The function getAverageParticipation in AuctionBurnReserveSkew.sol could be set external         The function addAbovePegObservation in AuctionBurnReserveSkew.sol could be set external         The function getPegDeltaFrequency in AuctionBurnReserveSkew.sol could be set external         The function addBelowPegObservation in AuctionBurnReserveSkew.sol could be set external         The function getRealBurnBudget in AuctionBurnReserveSkew.sol could be set external         The function earlyExitReturn in AuctionEscapeHatch.sol could be set external         The function setReplenishingIndex in AuctionParticipant.sol could be set external         The function usableBalance in AuctionParticipant.sol could be set external         The function outstandingArbTokens in AuctionParticipant.sol could be set external         The function getAllAuctionIds in AuctionParticipant.sol could be set external         The function setupParticipant in AuctionParticipant.sol could be set external         The function usableBalance in AuctionPool.sol could be set external         The function setBonding in AuctionPool.sol could be set external         The function totalReleasedReward in AuctionPool.sol could be set external         The function totalBonded in AuctionPool.sol could be set external         The function setForfeitDestination in AuctionPool.sol could be set external         The function onUnbond in AuctionPool.sol could be set external         The function totalDeclaredReward in AuctionPool.sol could be set external         The function balanceOfBonded in AuctionPool.sol could be set external         The function setMiningService in Bonding.sol could be set external         The function epochData in Bonding.sol could be set external         The function totalBonded in Bonding.sol could be set external         The function bondedEpoch in Bonding.sol could be set external         The function setDAO in Bonding.sol could be set external         The function setDexHandler in Bonding.sol could be set external         The function setCurrentEpoch in Bonding.sol could be set external         The function bondToAccount in Bonding.sol could be set external         The function averageBondedValue in Bonding.sol could be set external         The function balanceOfBonded in Bonding.sol could be set external         The function deploy in Create2Deployer.sol could be set external         The function getEpochStartTime in DAO.sol could be set external         The function epochsPerYear in DAO.sol could be set external         The function mint in DAO.sol could be set external         The function setEpochLength in DAO.sol could be set external         The function setMaltToken in DAO.sol could be set external         The function maltMarketPrice in UniswapHandler.sol could be set external         The function reserves in UniswapHandler.sol could be set external         The function constructor in ERC20Permit.sol could be set external         The function setBonding in ERC20VestedMine.sol could be set external         The function totalReleasedReward in ERC20VestedMine.sol could be set external         The function totalBonded in ERC20VestedMine.sol could be set external         The function setDistributor in ERC20VestedMine.sol could be set external         The function onUnbond in ERC20VestedMine.sol could be set external         The function totalDeclaredReward in ERC20VestedMine.sol could be set external         The function balanceOfBonded in ERC20VestedMine.sol could be set external         The function handleForfeit in ForfeitHandler.sol could be set external         The function totalUsefulCollateral in ImpliedCollateralService.sol could be set external         The function getCollateralValueInMalt in ImpliedCollateralService.sol could be set external         The function collateralDeficit in LiquidityExtension.sol could be set external         The function reserveRatio in LiquidityExtension.sol could be set external         The function hasMinimumReserves in LiquidityExtension.sol could be set external         The function constructor in Malt.sol could be set external         The function burn in Malt.sol could be set external         The function mint in Malt.sol could be set external         The function smoothedMaltPrice in MaltDataLab.sol could be set external         The function trackReserveRatio in MaltDataLab.sol could be set external         The function maltInPoolAverage in MaltDataLab.sol could be set external         The function smoothedMaltInPool in MaltDataLab.sol could be set external         The function reserveRatioAverage in MaltDataLab.sol could be set external         The function maltPriceAverage in MaltDataLab.sol could be set external         The function smoothedReserves in MaltDataLab.sol could be set external         The function smoothedReserveRatio in MaltDataLab.sol could be set external         The function balanceOfRewards in MiningService.sol could be set external         The function removeRewardMine in MiningService.sol could be set external         The function earned in MiningService.sol could be set external         The function withdrawRewardsForAccount in MiningService.sol could be set external         The function setReinvestor in MiningService.sol could be set external         The function withdrawAccountRewards in MiningService.sol could be set external         The function setBonding in MiningService.sol could be set external         The function isMineActive in MiningService.sol could be set external         The function onBond in MiningService.sol could be set external         The function numberOfMines in MiningService.sol could be set external         The function onUnbond in MiningService.sol could be set external         The function addRewardMine in MiningService.sol could be set external         The function getValue in MovingAverage.sol could be set external         The function getValueWithLookback in MovingAverage.sol could be set external         The function isWhitelisted in PoolTransferVerification.sol could be set external         The function setPool in PoolTransferVerification.sol could be set external         The function addToWhitelist in PoolTransferVerification.sol could be set external         The function verifyTransfer in PoolTransferVerification.sol could be set external         The function setThreshold in PoolTransferVerification.sol could be set external         The function setPriceLookback in PoolTransferVerification.sol could be set external         The function removeFromWhitelist in PoolTransferVerification.sol could be set external         The function setForfeitor in RewardDistributor.sol could be set external         The function addFocalLengthUpdater in RewardDistributor.sol could be set external         The function setRewardMine in RewardDistributor.sol could be set external         The function setBonding in RewardDistributor.sol could be set external         The function forfeit in RewardDistributor.sol could be set external         The function vest in RewardDistributor.sol could be set external         The function setThrottler in RewardDistributor.sol could be set external         The function setRewardToken in RewardDistributor.sol could be set external         The function removeFocalLengthUpdater in RewardDistributor.sol could be set external         The function decrementRewards in RewardDistributor.sol could be set external         The function totalDeclaredReward in RewardDistributor.sol could be set external         The function setFocalLength in RewardDistributor.sol could be set external         The function averageAPR in RewardThrottle.sol could be set external         The function targetEpochProfit in RewardThrottle.sol could be set external         The function epochData in RewardThrottle.sol could be set external         The function targetAPR in RewardThrottle.sol could be set external         The function getTargets in RewardThrottle.sol could be set external         The function handleReward in RewardThrottle.sol could be set external         The function checkRewardUnderflow in RewardThrottle.sol could be set external         The function epochAPR in RewardThrottle.sol could be set external         The function costBasis in SwingTrader.sol could be set external         The function setLpProfitCut in SwingTrader.sol could be set external         The function addVerifier in TransferService.sol could be set external         The function numberOfVerifiers in TransferService.sol could be set external         The function verifyTransfer in TransferService.sol could be set external         The function removeVerifier in TransferService.sol could be set external   
# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           AbstractRewardMine.sol Variable miningService is read 3 times in the function:  setMiningService         Auction.sol Variable currentAuctionId is read 3 times in the function:  purchaseArbitrageTokens         Auction.sol Variable nextCommitmentId is read 2 times in the function:  purchaseArbitrageTokens         Auction.sol Variable currentAuctionId is read 4 times in the function:  _checkAuctionFinalization         Auction.sol Variable replenishingAuctionId is read 4 times in the function:  allocateArbRewards         Auction.sol Variable stabilizerNode is read 2 times in the function:  setStabilizerNode         Auction.sol Variable amender is read 2 times in the function:  setAuctionAmender         AuctionBurnReserveSkew.sol Variable auctionAverageLookback is read 2 times in the function:  getPegDeltaFrequency         AuctionBurnReserveSkew.sol Variable count is read 2 times in the function:  addAbovePegObservation         AuctionBurnReserveSkew.sol Variable count is read 2 times in the function:  addBelowPegObservation         AuctionBurnReserveSkew.sol Variable stabilizerNode is read 2 times in the function:  setNewStabilizerNode         AuctionParticipant.sol Variable replenishingIndex is read 2 times in the function:  claim         AuctionParticipant.sol Variable replenishingIndex is read 2 times in the function:  setReplenishingIndex         AuctionPool.sol Variable forfeitedRewards is read 2 times in the function:  _checkForForfeit         AuctionPool.sol Variable forfeitedRewards is read 3 times in the function:  _handleRewardDistribution         UniswapHandler.sol Variable router is read 2 times in the function:  addLiquidity         MaltDataLab.sol Variable UPDATER_ROLE is read 2 times in the function:  initialize         MiningService.sol Variable reinvestor is read 2 times in the function:  setReinvestor         MiningService.sol Variable bonding is read 2 times in the function:  setBonding         MovingAverage.sol Variable UPDATER_ROLE is read 2 times in the function:  initialize         MovingAverage.sol Variable cumulativeValue is read 11 times in the function:  update         MovingAverage.sol Variable blockTimestampLast is read 5 times in the function:  update         MovingAverage.sol Variable activeSamples is read 2 times in the function:  update         MovingAverage.sol Variable sampleLength is read 3 times in the function:  update         MovingAverage.sol Variable cumulativeValue is read 10 times in the function:  updateCumulative         MovingAverage.sol Variable blockTimestampLast is read 4 times in the function:  updateCumulative         MovingAverage.sol Variable activeSamples is read 2 times in the function:  updateCumulative         MovingAverage.sol Variable sampleLength is read 2 times in the function:  updateCumulative         MovingAverage.sol Variable activeSamples is read 2 times in the function:  _createNewSample         MovingAverage.sol Variable counter is read 2 times in the function:  setSampleMemory         RewardReinvestor.sol Variable dexHandler is read 2 times in the function:  _bondAccount         RewardReinvestor.sol Variable treasury is read 2 times in the function:  _bondAccount         RewardDistributor.sol Variable FOCAL_LENGTH_UPDATER_ROLE is read 2 times in the function:  initialize         RewardDistributor.sol Variable focalLength is read 2 times in the function:  _resetFocalPoint         RewardDistributor.sol Variable focalID is read 3 times in the function:  _incrementFocalPoint         RewardDistributor.sol Variable throttler is read 2 times in the function:  setThrottler         RewardDistributor.sol Variable rewardMine is read 2 times in the function:  setRewardMine         RewardOverflowPool.sol Variable throttler is read 2 times in the function:  setThrottler         RewardThrottle.sol Variable _activeEpoch is read 3 times in the function:  handleReward         StabilizerNode.sol Variable stabilizeWindowEnd is read 2 times in the function:  stabilize         StabilizerNode.sol Variable lastStabilize is read 2 times in the function:  stabilize         StabilizerNode.sol Variable liquidityExtension is read 2 times in the function:  _replenishLiquidityExtension         StabilizerNode.sol Variable auction is read 2 times in the function:  setAuctionContract         SwingTrader.sol Variable deployedCapital is read 2 times in the function:  buyMalt         SwingTrader.sol Variable deployedCapital is read 2 times in the function:  sellMalt   
# Handle  robee   # Vulnerability details  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.  The format is <solidity file>, <in which function we found it>, <unused local variable name>:           AbstractRewardMine.sol, _handleStakePadding, totalRewardedWithStakePadding         AbstractRewardMine.sol, _handleStakePadding, INITIAL_STAKE_SHARE_MULTIPLE         AbstractRewardMine.sol, _handleStakePadding, bondedTotal         Auction.sol, _finalizeAuction, avgMaltPrice         AuctionParticipant.sol, claim, replenishingId         AuctionParticipant.sol, claim, claimableTokens         AuctionParticipant.sol, claim, claimable         Create2Deployer.sol, deploy, addr         UniswapHandler.sol, removeBuyer, buyer         MaltDataLab.sol, trackPoolReserves, rewardDecimals         MovingAverage.sol, update, elapsedSamples         MovingAverage.sol, updateCumulative, elapsedSamples         StabilizerNode.sol, stabilize, exchangeRate         StabilizerNode.sol, _startAuction, decimals         SwingTrader.sol, sellMalt, maltDecimals         SwingTrader.sol, costBasis, maltDecimals         TransferService.sol, removeVerifier, verifier   
# Handle  robee   # Vulnerability details  In the following files, there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           AuctionBurnReserveSkew.sol, line 4, import "@openzeppelin/contracts/access/AccessControl.sol";         AuctionParticipant.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         AuctionParticipant.sol, line 3, import "@openzeppelin/upgrades/contracts/Initializable.sol";         AuctionPool.sol, line 9, import "./interfaces/IAuction.sol";         AuctionPool.sol, line 10, import "./interfaces/IBurnMintableERC20.sol";         AuctionPool.sol, line 11, import "./interfaces/IDexHandler.sol";         Bonding.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         ERC20VestedMine.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         ImpliedCollateralService.sol, line 12, import "./interfaces/IRewardThrottle.sol";         LiquidityExtension.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         LiquidityExtension.sol, line 3, import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";         MaltDataLab.sol, line 7, import "./interfaces/IStabilizerNode.sol";         MaltDataLab.sol, line 9, import "./interfaces/IDAO.sol";         MiningService.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         MiningService.sol, line 3, import "@openzeppelin/contracts/token/ERC20/ERC20.sol";         PoolTransferVerification.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         PoolTransferVerification.sol, line 6, import "./Permissions.sol";         RewardDistributor.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         RewardDistributor.sol, line 11, import "hardhat/console.sol";         RewardOverflowPool.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         RewardThrottle.sol, line 2, import "@openzeppelin/contracts/math/SafeMath.sol";         RewardThrottle.sol, line 13, import "hardhat/console.sol";         SwingTrader.sol, line 8, import "./interfaces/IAuction.sol";         TransferService.sol, line 4, import "./interfaces/IMaltDataLab.sol";   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Remove L151 count = count + 1; and change L147 to uint256 index = _getIndexOfObservation(count++); so we save at least a SLOAD.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L143  ## Tools Used  ## Recommended Mitigation Steps Remove L151 count = count + 1; and change L147 to uint256 index = _getIndexOfObservation(count++);  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact After teh if statement on L74, we have premiumExcess <= maxBurnSpend and therefore don't need to do a save subtraction (underflow check) on L80.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L69  ## Tools Used  ## Recommended Mitigation Steps - rewrite L80 as: uint256 usableExcess = maxBurnSpend - premiumExcess;  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Else block on L805 satisfies amountArbTokens <= unclaimedArbTokens and therefore no safe subtraction (underflow check) is needed (saves gas).  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L786  ## Tools Used  ## Recommended Mitigation Steps - rewrite L805 as: unclaimedArbTokens = unclaimedArbTokens - amountArbTokens;  
# Handle  GiveMeTestEther   # Vulnerability details  # Vulnerability details  ## Impact The else block on L241 satisfies amountTokens <= unclaimedArbTokens and therefore we don't need to do a safe subtraction (underflow check).  The else block on L247 satisfies amountTokens <= claimableArbitrageRewards and therefore we don't need to do a safe subtraction (underflow check).     ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L216 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L247  ## Tools Used  ## Recommended Mitigation Steps - rewrite L241 as: unclaimedArbTokens = unclaimedArbTokens - amountTokens; - rewrite L274 as: claimableArbitrageRewards = claimableArbitrageRewards - amountTokens-;   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact L209 nextCommitmentId = nextCommitmentId + 1; can be removed and L202 can be changed to nextCommitmentId++; to save a SLOAD  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Storage variable _activeEpoch is read a lot and can be cached in a local variable (epochTmp, maybe choose a better name =)) to save gas. Also the State struct can be loaded into a State storage (currentState, maybe also choose a better name) variable such that we don't have to access the storage array each time.   In the gas optimized code of "Recommended Mitigation Steps" section, the _activeEpoch only gets read once. Also note after the first "if" we write epoch to the storage variable "_activeEpoch" but then also write epoch to the local var "epochTmp" so we can use this local var in the whole function.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L63  ## Tools Used  ## Recommended Mitigation Steps   function handleReward() public {     uint256 balance = rewardToken.balanceOf(address(this));      uint256 epoch = dao.epoch();     uint256 epochTmp = _activeEpoch;     State storage currentState;      checkRewardUnderflow();      if (epoch > epochTmp) {       _activeEpoch = epoch;       epochTmp = epoch;        currentState = _state[epochTmp];        currentState.bondedValue = bonding.averageBondedValue(epochTmp);        currentState.profit = balance;       currentState.rewarded = 0;       currentState.throttle = throttle;     } else {       currentState = _state[epochTmp];       currentState.profit = currentState.profit.add(balance);       currentState.throttle = throttle;      }      // Fetch targetAPR before we update current epoch state     uint256 aprTarget = targetAPR();      // Distribute balance to the correct places     if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) {       uint256 remainder = _getRewardOverflow(balance, aprTarget);       emit RewardOverflow(epochTmp, remainder);        if (remainder > 0) {         rewardToken.safeTransfer(address(overflowPool), remainder);          if (balance > remainder) {           _sendToDistributor(balance - remainder, epochTmp);         }       }     } else {       _sendToDistributor(balance, epochTmp);     }      emit HandleReward(epoch, balance);   }  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Require statement conditions checks that no underflow can happen, therefore we don't need to use safe subtraction (underflow check).  - L275:  require(amount <= _globals.declaredBalance, "Can't decrement more than total reward balance"); - L278:  _globals.declaredBalance = _globals.declaredBalance.sub(amount); => Rewrite L278 as:  _globals.declaredBalance = _globals.declaredBalance - amount;  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L271 ## Tools Used  ## Recommended Mitigation Steps - rewrite L278 as:  _globals.declaredBalance = _globals.declaredBalance - amount;  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact L185:  focalID = focalID + 1; can be removed and L197 can be adapted to:  _resetFocalPoint(++focalID, newEndTime); to save at least one warm storage read (100 gas)  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L180 ## Tools Used  ## Recommended Mitigation Steps  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Require condition checks already underflow condition. There for no underflow check is needed.  - L154: require(forfeited <= _globals.declaredBalance, "Cannot forfeit more than declared"); - L156:_globals.declaredBalance = _globals.declaredBalance.sub(forfeited);  Therefore L156 can be written as: _globals.declaredBalance = _globals.declaredBalance - forfeited;   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L153 ## Tools Used  ## Recommended Mitigation Steps - L156 can be written as: _globals.declaredBalance = _globals.declaredBalance - forfeited;  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on operations.  ## Proof of Concept  The function contains two non-intersecting logic pathways, which can be separated to lighten calculations.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L179   ## Recommended Mitigation Steps  Now: ``` function _handleStakePadding(address account, uint256 amount) internal {  uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());   uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;   uint256 bondedTotal = totalBonded();   uint256 newStakePadding = bondedTotal == 0 ?   totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :   totalRewardedWithStakePadding.mul(amount).div(bondedTotal);   _addToStakePadding(account, newStakePadding); } ```  To be: ``` function _handleStakePadding(address account, uint256 amount) internal {  uint256 bondedTotal = totalBonded();    uint256 newStakePadding;  if (bondedTotal == 0) {   uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;   newStakePadding = totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0;  } else {   newStakePadding = (totalDeclaredReward().add(totalStakePadding())).mul(amount).div(bondedTotal);  }   if (newStakePadding > 0)   _addToStakePadding(account, newStakePadding); } ```  
# Handle  jayjonah8   # Vulnerability details  ## Impact The setupParticipant() function in AuctionParticipant.sol does not have require statements to protect again contracts that do not yet exist.  It sets the addresses for " _impliedCollateralService", "_rewardToken", and "_auction" and can only be called once so its vital to have this guard in place.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionParticipant.sol#L26  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add require checks for the addresses that are passed in the setupParticipant() function checking if they exist like: require("address" != address(0), "contract does not exist")  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and function calls.  ## Proof of Concept  totalDeclaredReward is called by _handleStakePadding twice: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L180  While totalDeclaredReward does expensive balanceOf call: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L97  ## Recommended Mitigation Steps  It is viable to at least remove its double usage:  Now: ``` uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding()); ... uint256 newStakePadding = bondedTotal == 0 ?  totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :  totalRewardedWithStakePadding.mul(amount).div(bondedTotal); ```  To be: ``` uint256 declaredRewardTotal =  rewardToken.balanceOf(address(this)); uint256 totalRewardedWithStakePadding = declaredRewardTotal.add(totalStakePadding()); ... uint256 newStakePadding = bondedTotal == 0 ?  declaredRewardTotal == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 : totalRewardedWithStakePadding.mul(amount).div(bondedTotal); ```  
# Handle  Meta0xNull   # Vulnerability details  ## Impact Is Not Uncommon Normal Users Accidentally Send Tokens into Contract.  ENS Airdrop is a Good Example Normal Users Accidentally Send Tokens into Contract: https://discuss.ens.domains/t/social-amend-airdrop-proposal-to-include-accidentally-returned-funds/6975  In UniswapHandler.sol, sellMalt(), addLiquidity() and removeLiquidity() Have No Access Control. When Normal Users Accidently Deposit Tokens into the Contract, Any Random Persons/Bot Can Withdraw the Tokens because it will safeTransfer to msg.sender who find out there is token balance in the contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L185-L219 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221-L245  ## Tools Used Manual Review  ## Recommended Mitigation Steps Add relevant access control, probably Only StabilizerNode and Admin have Access to this contract various functions like sellMalt(), addLiquidity() and removeLiquidity() etc.   
# Handle  Meta0xNull   # Vulnerability details  ## Impact removeVerifier() loops follows this for-each pattern: for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` }  In such for loops, the array.length is read on every iteration, instead of caching it once in a local variable and read it again using the local variable.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L87-L88  ## Tools Used Manual Review  ## Recommended Mitigation Steps Read these values from memory once, cache them in local variables and then read them again using the local variables. For example:  Before: for (uint i = 0; i < verifierList.length - 1; i = i + 1) { if (verifierList[i] == _address) {  After: uint256 verifierList_temp = verifierList  for (uint i = 0; i < verifierList_temp.length - 1; i = i + 1) { if (verifierList_temp[i] == _address) {  
# Handle  Meta0xNull   # Vulnerability details  ## Impact The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L87 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionBurnReserveSkew.sol#L54 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Malt.sol#L34-L37 More...  ## Tools Used Manual Review  ## Recommended Mitigation Steps Remove explicit 0 initialization of for loop index variable.   Before: for (uint i = 0; After for (uint i;  
# Handle  Meta0xNull   # Vulnerability details  ## Impact      * [WARNING]      * ====      * This function should only be called from the constructor when setting      * up the initial roles for the system.      *      * Using this function in any other way is effectively circumventing the admin      * system imposed by {AccessControl}.      * ====      *      * NOTE: This function is deprecated in favor of {_grantRole}.  There are multiple contracts that import Permissions.sol and using Deprecated Function _setupRole() with Security Problem that Applicable to all these contracts because all of the contracts use initialize() Rather Than Constructor.   ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L174-L186 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L53 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L117 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L121  ## Tools Used Manual Review  ## Recommended Mitigation Steps Replace _setupRole() with _grantRole()  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on function calls.  ## Proof of Concept  ```earned``` function calls public ```getRewardOwnershipFraction``` function: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L144  ## Recommended Mitigation Steps  Now: ``` function totalDeclaredReward() virtual public view returns (uint256) {  return rewardToken.balanceOf(address(this)); } function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {  numerator = balanceOfRewards(account);  denominator = totalDeclaredReward(); } ... function earned(address account) public view returns (uint256 earnedReward) {  (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);  ```  To be: ``` function earned(address account) public view returns (uint256 earnedReward) {  uint256 rewardNumerator = balanceOfRewards(account);  uint256 rewardDenominator = rewardToken.balanceOf(address(this)); ```  
# Handle  Meta0xNull   # Vulnerability details  ## Impact A wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or Users'FUND Locked inside the Contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L63-L77  ## Tools Used Manual Review  ## Recommended Mitigation Steps requires Addresses is not zero.  require(_admin != address(0), "Address Can't Be Zero")  
# Handle  Meta0xNull   # Vulnerability details  ## Impact The current ownership transfer process involves the current TIMELOCK_ROLE calling reassignGlobalAdmin().  If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the TIMELOCK_ROLE modifier.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L63-L77  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider implementing a two step process where the TIMELOCK_ROLE nominates an account and the nominated account needs to call an accept_TIMELOCK_ROLE() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.   
# Handle  loop   # Vulnerability details  When invoking `purchaseArbitrageTokens()` is will first check whether the auction is active using: ``` require(auctionActive(currentAuctionId), "No auction running"); ``` `auctionActive()` checks for the following things: ``` auction.active && now >= auction.startingTime; ``` As a result the require statement will fail if either `!auction.active` or `now < auction.startingTime`.   Later on in `purchaseArbitrageTokens()` two more require statements will check the same thing: ``` require(auction.startingTime <= now, "Auction hasn't started yet"); (...)  require(auction.active == true, "Auction is not active"); ``` These will always pass if `auctionActive(currentAuctionId)` is `true` and never be reached if it is `false`, making them redundant.  ## Proof of Concept - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L178 - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L188-L190 - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272  ## Recommended Mitigation Steps Remove redundant require statements  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  Caching the array length in a `for`-loop saves gas as the length does not need to be read on every iteration.  The following loops could be refactored: ``` ./Malt.sol:34:    for (uint256 i = 0; i < minters.length; i = i + 1) { ./Malt.sol:37:    for (uint256 i = 0; i < burners.length; i = i + 1) { ./TransferService.sol:87:    for (uint i = 0; i < verifierList.length - 1; i = i + 1) { ./Auction.sol:407:    for (uint i = 0; i < epochCommitments.length; ++i) { ./libraries/UniswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./AuctionParticipant.sol:107:    for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) { ./MiningService.sol:49:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:69:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:86:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:96:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:142:    for (uint i = 0; i < mines.length - 1; i = i + 1) { ./MiningService.sol:166:    for (uint i = 0; i < mines.length; i = i + 1) { ./DexHandlers/UniswapHandler.sol:317:    for (uint i = 0; i < buyers.length - 1; i = i + 1) { ```  ## Tools used  `grep -rn ".length" .`  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  The functions `setDefaultIncentive` and `setExpansionDamping` in `StabilizerNode.sol` require their arguments to be non-zero, i.e. to be positive, as their argument types are `uint`.  However, the error messages state that the arguments should not be non-negative.  See lines [406](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L406) and [417](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L417).  ## Recommended Mitigation Steps  Change the error messages to something like: "Must be above 0".  
# Handle  pmerkleplant   # Vulnerability details  ## Impact  Function `RewardReinvestor::_bondAccount` tries to bond liquidity to an account, even though it is known whether the liquidity is zero.  ## Proof of Concept  The return value `liquidityCreated` in [line 105](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L105) can be zero. The following function call, `bondToAccount()`, then reverts with "Cannot bond 0".  ## Recommended Mitigation Steps  Gas could be saved if the function would revert earlier, i.e. in [line 106](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L106), if the `liquidityCreated` is zero.  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description There is multiple instances within the **Malt** protocol codebase that do not append messages to the require statements.  ## Impact add a custom message to the require statement to create a better sense of what's is the reason of failure.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L681 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L56 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L76 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L78 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L119  ## Tools Used manual code review.  ## Recommended Mitigation Steps append custom message to the require statements.  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description On contract **AuctionEscapeHatch** there is a function labeled as Public, However this function is not used within the contracts of **Malt** protocol.  ## Impact Improve coding style quality for developers and audit.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L94  ## Tools Used manual code review.  ## Recommended Mitigation Steps Evaluate functions labeled as public and set to external if needed just like the rest of functions inside this contract.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Caching the references to "currentAuctionID" will decrease gas usage.   ## Proof of Concept  The state variable "currentAuctionID" is read 7 times in function "_checkAuctionFinalization" here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L746-L762  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to cache the variable:    ```   function _checkAuctionFinalization(bool isInternal) internal {      uint256 currentId = currentAuctionId;     if (isInternal && !isAuctionFinished(currentId)) {       // Auction is still in progress after internal auction purchasing.       _resetAuctionMaxCommitments();     }      if (isAuctionFinished(currentId)) {       if (auctionActive(currentId)) {         _endAuction(currentId);       }        if (!isAuctionFinalized(currentId)) {         _finalizeAuction(currentId);       }       currentAuctionId = currentId + 1;     }   } ```   
# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticipant.sol, the function `setReplenishingIndex` is an admin function that allows manually setting `replenishingIndex`. As I have shown in my two previous findings, I believe that this function could be called frequently. In my opinion (and Murphy's law would agree), this implies that eventually an admin will accidentally set `replenishingIndex` incorrectly with this function.  Right now, `setReplenishingIndex` does not allow the admin to set `replenishingIndex` to a value smaller than it currently is. So, if an admin were to accidentally set this value too high, then it would be impossible to set it back to a lower value (the higher the value set, the worse this issue). All of the unclaimed tokens on auctions at smaller indices would be locked forever.  ## Proof of Concept See code for `setReplenishingIndex` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L132  ## Tools Used Inspection  ## Recommended Mitigation Steps Remove the require statement on line 136, so that an admin can set the index to a smaller value.  
# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticpant.sol, every time `purchaseArbitrageTokens` is called, the current auction is pushed to `auctionIds`. If this function were to be called on the same auction multiple times, then the same auction id would be pushed multiple times into this array, and the `claim` function would have issues with `replenishingIndex`.   Specifically, even if `replenishingIndex` was incremented once in `claim`, it is still possible that the auction at the next index will never reward any more tokens to the participant, so the contract would need manual intervention to set `replenishingIndex` (due to the if statement on lines 79-82 that does nothing if there is no claimable yield).   It is likely that `purchaseArbitrageTokens` would be called multiple times on the same auction. In fact, the commented out code for `handleDeficit` (in ImpliedCollateralService.sol) even suggests that the purchases might happen within the same transaction. So this issue will likely be an issue on most auctions and would require manual setting of `replenishingIndex`.  NOTE: This is a separate issue from the one I just submitted previously relating to `replenishingIndex`. The previous issue was related to an edge case where `replenishingIndex` might need to be incremented by one if there are never going to be more claims, while this issue is due to duplicate auction ids.  ## Proof of Concept See code for `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L40  Notice that `currentAuction` is always appended to `auctionIds`.   ## Tools Used Inspection  ## Recommended Mitigation Steps Add a check to the function to `purchaseArbitrageTokens` to ensure that duplicate ids are not added. For example, this can be achieved by changing auctionIds to a mapping instead of an array.  
# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticipant.sol, the `claim` function is called to claim arb tokens from auctions the participant has entered. This is achieved through the global variable `replenishingIndex` which keeps track of which auction `claim` should be claiming from next. The logic for incrementing `replenishingIndex` is at the end of claim.   I agree with the current logic at the end of the function. The comment on lines 96/97 says "Don't increment replenishingIndex if replenishingAuctionId == auctionId as claimable could be 0 due to the debt not being 100% replenished". Notice the keyword "could" - it is possible that replenishingAuctionId == auctionId but we will never be able to claim any more arb tokens from this contract, and in this case `replenishingIndex` will NOT be incremented.  In this case, all subsequent calls to `claim` will simply do nothing. Line 77 will have `claimableTokens` be 0, and then the function will immediately return since it thinks it needs to wait longer to get more tokens, which will never happen. In this case, a manual intervention by an admin would be required to set `replenishingIndex', which is obviously annoying and should be avoided. Since `claim` is an external function, a malicious user/troll could intentionally call `claim` at the worst times to trigger this issue to happen. In this case, manual intervention would be required quite often.  The following logic should be added immediately after line 77 to account for this issue:  if (claimableTokens == 0 && replenishingId > auctionId) { // in this case, we will never receive any more tokens from this auction     replenishingIndex = replenishingIndex + 1;     auctionId = auctionIds[replenishingIndex]; }  // retry check for 0 claimable amount  ## Proof of Concept See the code for `claim` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L65  Other than manual intervention, the only place where `replenishingIndex` is set is at the end of `claim`.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add the code described above.  
# Handle  ye0lde   # Vulnerability details  ## Impact  Variables are being assigned their default value which is unnecessary. Removing the assignment will save gas when deploying and improve code clarity.  ## Proof of Concept  State: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L19  Local: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L351 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L626 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L92 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L108 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L117 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L124 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionPool.sol#L115 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20VestedMine.sol#L90 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L94 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L125 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L149-L150 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L112  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unneeded assignments.  Or if you feel it is important to show the default assignment will occur then replace the assignments with a comment.  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODOs are here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L716 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L68 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L18 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L73 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L98 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L438 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L72 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L81 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L114 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L200 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L251 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L328  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODOs before deploying.  
# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been seen that malt price return value has not been checked on the function.  If oracle is returned price as a 0, fullReturn will be zero on the earlyExitReturn function.  ## Proof of Concept  1. Navigate to "https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L124" 2. The return value maltMarketPrice() function has not been checked.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to add return value check. The maltPrice should be more than zero for the calculation.  """ require(dexHandler.maltMarketPrice()>0, "Price should be more than zero"); """  
# Handle  hyh   # Vulnerability details  ## Impact  Being instantiated with wrong configuration, the contract is inoperable and deploy gas costs will be lost. If misconfiguration is noticed too late the various types of malfunctions become possible.  ## Proof of Concept  The checks for zero addresses during contract construction and initialization are considered to be the best-practice.  Now basically all the contract do not check for correctness of constructor arguments:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Malt.sol#L29  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardSystem/RewardOverflowPool.sol#L25  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L25  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ForfeitHandler.sol#L31  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L30  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L47  ...  ## Recommended Mitigation Steps  Add zero-address checks and key non-address variables checks in all contract constructors. Small increase of gas costs are far out weighted by wrong deploy costs savings and additional coverage against misconfiguration.   
# Handle  hyh   # Vulnerability details  ## Impact  ERC20 balanceOf call is costly. Malt balance is read twice in sellMalt call, which isn't needed, so gas is overspent here.  ## Proof of Concept  Malt balanceOf(address(this)) is called twice: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L86 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L150  ## Recommended Mitigation Steps  It's recommended to make internal version of costBasis that takes Malt balance as an argument.  Now: ``` uint256 totalMaltBalance = malt.balanceOf(address(this)); ... (...) = costBasis(); ... function costBasis() public view returns (uint256 cost, uint256 decimals) { ... uint256 maltBalance = malt.balanceOf(address(this)); ... ``` To be: ``` uint256 totalMaltBalance = malt.balanceOf(address(this)); ... (...) = _costBasis(totalMaltBalance); ... function _costBasis(uint256 maltBalance) internal view returns (...) { ... function costBasis() public view returns (...) {  return _costBasis(malt.balanceOf(address(this))); } ```  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on function call and calculations  ## Proof of Concept  First, save Malt and Collateral tokens decimals difference to storage variable. As neither Malt, nor Collateral token decimals change since initial setup, both can be saved and accessed as a storage variable instead of calling ```decimals()``` function and calculating the difference each time.  Second, now sellMalt calls costBasis, which already retrieved decimals and their difference, but sellMalt ignores those, retrieving them from functions/storage again. This could be unified as discussed below.  sellMalt: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L77 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L109  costBasis: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L146   ## Recommended Mitigation Steps   Save both decimals values to contract storage variables and use them instead of ```decimals()``` function. As the calculations use decimals difference it might be enough to save and use the difference only. In any case saving is preferred to calling as the latter spend gas on call and storage access anyway.   Also, return the difference along with decimals from costBasis and use them in sellMalt instead of obtaining afresh. I.e. first reuse ```costBasis``` returned ```decimals``` instead of ```collateralToken.decimals()```, then add ```maltDecimals``` and the difference, whether ```maltDecimals - decimals``` or ```decimals - maltDecimals``` to its output and use in rewards / soldBasis calculations. Function arguments and returned values are memory and are cheaper than another storage access.  Now: ``` (uint256 basis,) = costBasis(); ... uint256 maltDecimals = malt.decimals(); uint256 decimals = collateralToken.decimals(); ... uint256 diff = maltDecimals - decimals;  ``` To be: ``` (uint256 basis, uint256 decimals, uint256 maltDecimals, uint256 diff) = costBasis(); ... ```  
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description  The event **SetAnnualYield** on Contract **StabilizerNode** is defined but never emitted inside the Contract.  ## Impact Unused events in the codebase can be confusing, each declared event should have a corresponding emit statement.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L73  ## Tools Used manual code review.  ## Recommended Mitigation Steps it's better to remove unused events from the code to improve coding quality, Also monitoring will be effected since no emit statements is there.  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and operations.  ## Proof of Concept  ```amountOut``` is calculated in 3 steps, which can be made simpler. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L302-305  ## Recommended Mitigation Steps  Now: ``` uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price); uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price); uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens); ```  To be (```amountTokens``` and ```redeemedTokens``` aren't used elsewhere): ```  /* * uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price); * uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price); * uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens); */ uint256 redeemed = commitment.redeemed.mul(auction.pegPrice); uint256 amountOut = commitment.commitment.mul(claimablePerc).sub(redeemed).div(price); ```   
# Handle  BouSalman   # Vulnerability details  ## Vulnerability description On contract **Permissions.sol** there is multiple functions to withdraws funds, these functions currently do not check for zero value address before doing the transaction.  ## Impact Loss of funds, ETHs and ERC20.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L80 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L88 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L97 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L104  ## Tools Used manual code review.  ## Recommended Mitigation Steps use require() statement to validate address address(0) before sending the funds.  
# Handle  jayjonah8   # Vulnerability details  ## Impact In the AuctionEscapeHatch.sol file both earlyExitReturn() and _calculateMaltRequiredForExit call the getAuctionCore() function which has 10 possible return values most of which are not used.  It gets the wrong value back for the "active"  variable since it's the 10th argument but both functions have it as the 9th return value where "preAuctionReserveRatio" should be because of one missing comma.  This is serious because these both are functions which deal with allowing a user to exit their arbitrage token position early.  This can result in a loss of user funds.    ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L100 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L174 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L527   ## Tools Used Manual code review   ## Recommended Mitigation Steps In AuctionEscapeHatch.sol change the following in _calculateMaltRequiredForExit() and earlyExitReturn() functions:  From:   (,,,,,      uint256 pegPrice,      ,      uint256 auctionEndTime,      bool active     ) = auction.getAuctionCore(_auctionId);  To:   (,,,,,      uint256 pegPrice,      ,      uint256 auctionEndTime,      ,      bool active     ) = auction.getAuctionCore(_auctionId);   
# Handle  defsec   # Vulnerability details  ## Impact  SafeMath library functions are not always used in arithmetic operations in the contracts, which could potentially cause integer underflow/overflows. Although in the reference lines of code, there are upper limits on the variables to ensure an integer underflow/overflow could not happen, using SafeMath is always a best practice, which prevents underflow/overflows completely (even if there were no assumptions on the variables) and increases code consistency as well.   ## Proof of Concept  1. Navigate to the following contracts.  ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L795  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L821  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L64  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L76  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L188  ```  2. SafeMath functions are not used in the every functionality.   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider using the SafeMath library functions in the referenced lines of code.   
# Handle  defsec   # Vulnerability details  ## Impact  The admin only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in the contracts.   ## Proof of Concept  Missing events  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/SwingTrader.sol#L169  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L1000  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L1008  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L992  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L984  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L976  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L968  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L960  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L937  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L930  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L923  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L916  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionParticipant.sol#L132  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L226  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L234  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L218   See similar High-severity H03 finding OpenZeppelins Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelins Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)  ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all admin/privileged functions that change critical parameters.  
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and operations.  ## Proof of Concept  ```claimablePerc``` is calculated in two steps, which can be made simpler. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L294  ## Recommended Mitigation Steps  Now: ``` uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice); uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens); ```  To be (```totalTokens``` isn't used elsewhere): ``` uint256 claimablePerc = auction.claimableTokens.mul(auction.finalPrice).div(auction.commitments); ```  
# Handle  hyh   # Vulnerability details  ## Proof of Concept  As there is a check in the beginning of the function that includes the ```auction.finalPrice == 0``` condition: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L285  ## Recommended Mitigation Steps  The same condition down the line is never true and its check is redundant: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L298  
# Handle  sabtikw   # Vulnerability details  ## Impact  storage variables are initialized in the contract and overwritten in the initializer function.   ## Proof of Concept Auction.sol L#89 L#164 auctionLength AuctionBurnReserveSkew.sol L#25 auctionAverageLookback MaltDataLab.sol L#69 priceTarget  ## Tools Used  manual review   ## Recommended Mitigation Steps  remove initialization outside of initializer function  
# Handle  defsec   # Vulnerability details  ## Impact  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  ## Proof of Concept  1. Navigate to the following contracts.  ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L167  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionParticipant.sol#L59  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L252  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/RewardReinvestor.sol#L107 ``` 2.  When trying to re-approve an already approved token, all transactions revert and the protocol cannot be used.  ## Tools Used  None  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Cheaper storage.  ## Proof of Concept  The struct AuctionData file Auction.sol is optimizable. It looks like this:  ``` struct AuctionData {   // The full amount of commitments required to return to peg   uint256 fullRequirement;   // total maximum desired commitments to this auction   uint256 maxCommitments;   // Quantity of sale currency committed to this auction   uint256 commitments;   // Malt purchased and burned using current commitments   uint256 maltPurchased;   // Desired starting price for the auction   uint256 startingPrice;   // Desired lowest price for the arbitrage token   uint256 endingPrice;   // Price of arbitrage tokens at conclusion of auction. This is either   // when the duration elapses or the maxCommitments is reached   uint256 finalPrice;   // The peg price for the liquidity pool   uint256 pegPrice;   // Time when auction started   uint256 startingTime;   uint256 endingTime;   // Is the auction currently accepting commitments?   bool active;   // The reserve ratio at the start of the auction   uint256 preAuctionReserveRatio;   // Has this auction been finalized? Meaning any additional stabilizing   // has been done   bool finalized;   // The amount of arb tokens that have been executed and are now claimable   uint256 claimableTokens;   // The finally calculated realBurnBudget   uint256 finalBurnBudget;   // The amount of Malt purchased with realBurnBudget   uint256 finalPurchased;   // A map of all commitments to this auction by specific accounts   mapping(address => AccountCommitment) accountCommitments; } ``` But `active` and `finalized`, the unique boolean values, should be together, otherwise they will spend two slots instead of one. ```   uint256 preAuctionReserveRatio;   bool active;   bool finalized; ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps  
# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Use `indexed` on address to filter through logs better https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L105 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L112   
# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding. Some variables are in form of bps https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L90  while some are not https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L91 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L92  As a good programming practice, should use bps everywhere if you accepting it as a unit    
# Handle  jayjonah8   # Vulnerability details  ## Impact In MovingAverage.sol the safeMath.sol library is imported but I counted at least 25 places in the file where it should be used (Nearly the entire file).  This can result in values wrapping around which has caused devastating effects on many protocols in the past.  These values directly effect the exchangeRate variable given in the stabilize() function in StabilizerNode.sol so they must be treated with care.   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MovingAverage.sol#L3  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156  ## Tools Used Manual code review   ## Recommended Mitigation Steps The MovingAverage.sol file should be completely reviewed making use of safeMath through out the entire file.  
# Handle  defsec   # Vulnerability details  ## Impact  After pragma version, 0.7.0, the contract should use block.timestamp.  ## Proof of Concept  1. Navigate to the following contract.  "https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L153"  "https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L178"  2. Now is used instead of block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  It is recommended to use block.timestamp instead of now.  
# Handle  jayjonah8   # Vulnerability details  ## Impact The executeTransaction() function in Timelock.sol does not include a check if the contract being called actually exists. The extcodesize is not used when using .call on addresses directly as per the solidity docs.  This is important because the EVM allows calls to a non-existing contract to always succeed.   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Timelock.sol#L191  solidity docs: https://docs.soliditylang.org/en/v0.8.10/units-and-global-variables.html#address-related  "Due to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity includes an extra check using the extcodesize opcode when performing external calls. This ensures that the contract that is about to be called either actually exists (it contains code) or an exception is raised. The low-level calls which operate on addresses rather than contract instances (i.e. .call(), .delegatecall(), .staticcall(), .send() and .transfer()) do not include this check, which makes them cheaper in terms of gas but also less safe."   ## Tools Used Manual code review  ## Recommended Mitigation Steps A check should be included to make sure the contract being called actually exists to avoid making possible errors in the executeTransaction() function  
# Handle  TomFrench   # Vulnerability details  ## Impact  Greater costs of epoch advancement  ## Proof of Concept  The `Advance` event emits the block number and timestamp in its data  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L24  These fields are attached to events by default so it's unnecessary to manually emit them (and pay the associated gas costs)  ## Recommended Mitigation Steps  Remove `block` and `timestamp` fields from `Advance` event  
# Handle  TomFrench   # Vulnerability details  ## Impact  Unintended advancement incentives being paid out to third party  ## Proof of Concept  `DAO.sol` incentives outside parties to advance the epoch by minting 100 MALT tokens for calling the `advance` function. This is limited by checking that the start timestamp of the next epoch has passed.   https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63  This start timestamp is calculated by multiplying the new epoch number by the length of an epoch and adding it to the genesis timestamp.  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L65-L67  This method makes no accommodation for the fact that previous epochs may have been set to be a different length to what they are currently.  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L111-L114  In the case where the epoch length is reduced, `DAO` will think that the epoch number can be incremented potentially many times. Provided the `advanceIncentive` is worth more than the gas necessary to advance the epoch will be rapidly advanced potentially many times paying out unnecessary incentives.  ## Recommended Mitigation Steps  Rather than calculating from the genesis timestamp, store the last time that the epoch length was modified and calculate from there.  
