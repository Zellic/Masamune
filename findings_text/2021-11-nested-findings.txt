# Handle  pauliax   # Vulnerability details  ## Impact function "mintWithMetadata" does not need onlyFactory modifier as it will be checked in function "mint" later.   
# Handle  hyh   # Vulnerability details  ## Impact  Array bounds check violation will happen if the function be called with arrays of different lengths.  ## Proof of Concept  Loop is performed by names array, while both arrays are accessed: ``` for (uint256 i = 0; i < names.length; i++) {   if (operators[names[i]] != destinations[i]) { ``` https://github.com/code-423n4/2021-11-nested/blob/main/contracts/OperatorResolver.sol#L27  ## Recommended Mitigation Steps  Add a check: ``` require(names.length == destinations.length, "OperatorResolver::areAddressesImported: Input lengths must match"); ```  
# Handle  pauliax   # Vulnerability details  ## Impact I think it is not necessary to have function _burnNST as a separate private function. It is called only once and has just one LOC so it just incurs in extra gas cost which can be avoided by moving this line to function trigger and getting rid of _burnNST.   
# Handle  pauliax   # Vulnerability details  ## Impact This can be simplified to reduce gas costs by eliminating math operation: ```solidity   // before   require(_accountIndex + 1 <= shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");   // after   require(_accountIndex < shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");  ```  
# Handle  pauliax   # Vulnerability details  ## Impact INestedToken is declared as an abstract contract, yet it contains no function bodies and is located under the interfaces directory, so I think it should be declared as an interface.  ## Recommended Mitigation Steps Consider making INestedToken an interface.  
# Handle  hyh   # Vulnerability details  ```setFactory``` should be named ```addFactory``` as it doesn't set the only factory, but adds to the list of factories  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L133  
# Handle  pauliax   # Vulnerability details  ## Impact NestedRecords contains no removeFactory function so there is no way to revoke a factory in case you no longer want to support it. This function is present in NestedAsset contract so I thought you might want to also have it here.  ## Recommended Mitigation Steps Consider if you are missing removeFactory or is this an intended functionality.   
# Handle  hyh   # Vulnerability details  ## Impact  NFT token operations will fail if wrong reserve is used.  ## Proof of Concept  ```NestedFactory``` ```reserve``` is used in ```addtokens``` and ```withdraw``` function for a given NFT, but the NFT to reserve contract correspondence isn't checked.  addtokens: https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L119  withdraw: https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L241  ## Recommended Mitigation Steps  Add the ```require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "...")``` check in the beginning of the functions.  
# Handle  hyh   # Vulnerability details  ## Impact  Whenever condition of the ```_handleUnderSpending``` function fails function call gas costs are wasted. The cost of checking the condition is paid anyway, while when it doesn't hold the function call costs are avoidable.  ## Proof of Concept  ```_handleUnderSpending``` checks for ```_amountToSpent - _amountSpent > 0```.  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L481  ## Recommended Mitigation Steps  When the check condition is false ```_handleUnderSpending``` shouldn't be called and this way the check with corresponding variables to be placed in caller functions:  _submitInOrders https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L306  _safeSubmitOrder https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L415  
# Handle  0xngndev   # Vulnerability details  ## Impact In `FeeSplitter.sol` by doing a small refactory gas can be saved in case of a revert in the functions: `getAmountDue` and `_releaseToken` . We can swap the order of two lines so we return earlier in case of a bad input, this way we save some gas because the evm would execute less opcodes before reverting.  ## Mitigation steps getAmountDue: Swap line 83 with 84 to avoid computing unnecessary logic. Remove the "else"  and combine it with line 83. Something like this:  ```   function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];     if (_tokenRecords.totalShares == 0) return 0;         uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));         uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /             _tokenRecords.totalShares -             _tokenRecords.released[_account];         return amountDue;     } ``` _releaseToken: move line 252 after the require in line 254. Like this:  ```   function _releaseToken(address _account, IERC20 _token) private returns (uint256) {         uint256 amountToRelease = getAmountDue(_account, _token);         require(amountToRelease != 0, "FeeSplitter: NO_PAYMENT_DUE");         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];          _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;         _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;          return amountToRelease;     } ```   
# Handle  defsec   # Vulnerability details  ## Impact The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  1. Navigate to the following contracts.  "https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L135" "https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L111" "https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L32"  ## Tools Used  Code review  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.    
# Handle  cmichel   # Vulnerability details  The `NestedFactory._handleUnderSpending` function implements a condition as `_amountToSpent - _amountSpent > 0` instead of `_amountToSpent > _amountSpent`. The former reverts if `_amountSpent > _amountToSpent` while the latter doesn't.  It's unclear which behavior is preferred.  ## Recommended Mitigation Steps Think about if `_amountSpent > _amountToSpent` should revert or not. If not, the `if` condition can be rewritten as `_amountSpent > _amountToSpent` which would also save gas.  
# Handle  cmichel   # Vulnerability details  The `NestedFactory.addOperator` function pushes the `operator` even if it already exists in `operators`.  ## Impact When this duplicated operator is removed through a `removeOperator` call, only the first instance is removed. The operator can now still be called which can lead to unexpected behavior.  ## Recommended Mitigation Steps Check if the operator already exists before adding it.  
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for non-zero values: - `NestedFactory.constructor`: address parameters could be zero or not a contract - `NestedReserve.constructor`: address parameters could be zero or not a contract - `NestedBuybacker.constructor`: address parameters could be zero or not a contract  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.   
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/FeeSplitter.sol#L152-L162  ```solidity=152 function sendFeesWithRoyalties(     address _royaltiesTarget,     IERC20 _token,     uint256 _amount ) external nonReentrant {     require(_royaltiesTarget != address(0), "FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS");      _sendFees(_token, _amount, totalWeights);     _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token)); } ```  ### Recommendation  Change to:  ```solidity=152 function sendFeesWithRoyalties(     address _royaltiesTarget,     IERC20 _token,     uint256 _amount ) external nonReentrant {     require(_royaltiesTarget != address(0), "FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS");      uint256 _totalWeights = totalWeights;      _sendFees(_token, _amount, _totalWeights);     _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, _totalWeights), address(_token)); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L553-L559  ```solidity=553 /// @dev Calculate the fees for a specific user and amount (1%) /// @param _user The user address /// @param _amount The amount /// @return The fees amount function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {     return _amount / 100; } ```  The function `_calculateFees()` is a rather simple function, replacing it with inline expression `_amount / 100` can save some gas.  
# Handle  WatchPug   # Vulnerability details  `releaseToken()` has `nonReentrant` modifier, making `releaseTokens()` to set storage `_status` multiple times in the for loop.  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/FeeSplitter.sol#L116-L129  ```solidity=116 function releaseToken(IERC20 _token) public nonReentrant {     uint256 amount = _releaseToken(_msgSender(), _token);     _token.safeTransfer(_msgSender(), amount);     emit PaymentReleased(_msgSender(), address(_token), amount); }  /// @notice Call releaseToken() for multiple tokens /// @param _tokens ERC20 tokens to release function releaseTokens(IERC20[] memory _tokens) external {     for (uint256 i = 0; i < _tokens.length; i++) {         releaseToken(_tokens[i]);     } } ```  ### Recommendation  Change to:  ```solidity=116 function releaseToken(IERC20 _token) public nonReentrant {     _releaseTokenAndTransfer(_token); }  /// @notice Call releaseToken() for multiple tokens /// @param _tokens ERC20 tokens to release function releaseTokens(IERC20[] memory _tokens) external {     for (uint256 i = 0; i < _tokens.length; i++) {         _releaseTokenAndTransfer(_tokens[i]);     } }  function _releaseTokenAndTransfer(IERC20 _token) private {     uint256 amount = _releaseToken(_msgSender(), _token);     _token.safeTransfer(_msgSender(), amount);     emit PaymentReleased(_msgSender(), address(_token), amount); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedRecords.sol#L56-L79  ```solidity=56{67} /// @notice Add a record for NFT data into our mappings /// @param _nftId The id of the NFT /// @param _token The address of the token /// @param _amount The amount of tokens bought /// @param _reserve The address of the reserve function createRecord(     uint256 _nftId,     address _token,     uint256 _amount,     address _reserve ) public onlyFactory {     require(records[_nftId].tokens.length < maxHoldingsCount, "NestedRecords: TOO_MANY_ORDERS");     require(         _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)),         "NestedRecords: INVALID_RESERVE"     );      Holding memory holding = records[_nftId].holdings[_token];     require(!holding.isActive, "NestedRecords: HOLDING_EXISTS");      records[_nftId].holdings[_token] = Holding({ token: _token, amount: _amount, isActive: true });     records[_nftId].tokens.push(_token);     records[_nftId].reserve = _reserve; } ```  The error message "NestedRecords: TOO_MANY_ORDERS" should be changed to "NestedRecords: TOO_MANY_TOKENS".  
# Handle  GreyArt   # Vulnerability details  ## Impact  A user that mistakenly calls either `create()` or `addToken()` with WETH (or another ERC20) as the input token, but includes native ETH with the function call will have his native ETH permanently locked in the contract.  ## Recommended Mitigation Steps  It is best to ensure that `msg.value = 0` in `_transferInputTokens()` for the scenario mentioned above.  ```jsx } else if (address(_inputToken) == ETH) {  ... } else {  require(msg.value == 0, "NestedFactory::_transferInputTokens: ETH sent for non-ETH transfer");   _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  `_submitOutOrders()` is invoked by 2 functions `sellTokensToNft()` and `sellTokensToWallet()`, both of which specify the `_fromReserve` parameter to be `true`. This parameter is therefore unneeded.  ## Recommended Mitigation Steps  ```jsx function _submitOutOrders(   uint256 _nftId,   IERC20 _outputToken,   uint256[] memory _inputTokenAmounts,   Order[] calldata _orders,   bool _reserved ) private returns (uint256 feesAmount, uint256 amountBought) {  ...    IERC20 _inputToken = _transferInputTokens(     _nftId,     IERC20(_orders[i].token),     _inputTokenAmounts[i],     true  ); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  `createRecord()` is only invoked by `store()`. Its visibility can therefore be made internal / private.  ## Recommended Mitigation Steps  ```jsx function createRecord(   uint256 _nftId,   address _token,   uint256 _amount,  address _reserve ) internal onlyFactory {...} ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  The `transferFromFactory()` function is missing the `valid(address(_token))` modifier that is present in the `transfer()` and `withdraw()` functions.  It is in our opinion that these sanity checks on the token address are redundant, because the transaction will revert anyway in the SafeERC20 library.  ## Recommended Mitigation Steps  Either add in the modifier check for the `transferFromFactory()` function. Alternatively, remove them from all the functions as a gas optimization.  
# Handle  GreyArt   # Vulnerability details  ## Impact  The `name` and `destination` local variables in the `rebuildCache` function are declared multiple times within the loop. It'll be cheaper to declare them once outside the loop and reuse the variables inside.   ## Recommended Mitigation Steps  ```jsx bytes32 name; address destination; // The resolver must call this function whenever it updates its state for (uint256 i = 0; i < requiredAddresses.length; i++) {  name = requiredAddresses[i];  // Note: can only be invoked once the resolver has all the targets needed added  destination = resolver.getAddress(name);   ... } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  It is unnecessary to store the `token` variable in the `Holding` struct because the token is used as the key to access the `Holding` struct.  ## Recommended Mitigation Steps  Remove the `token` variable in the `Holding` struct.  ```jsx /// @dev Info about assets stored in reserves struct Holding {   uint256 amount;   bool isActive; } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  The `importOperators()` declares the `name` and `destination` variables multiple times. It'll be cheaper to declare them once outside the loop and reuse the variables inside.   ## Recommended Mitigation Steps  ```jsx bytes32 name; address destination;  for (uint256 i = 0; i < names.length; i++) {  name = names[i];  destination = destinations[i];   operators[name] = destination;   emit OperatorImported(name, destination); } ```  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedBuybacker.sol#L15  There is only NST.safeTransfer used, and NST is INestedToken interface. SafeERC20 is not used for IERC20 interface.  ## Tools Used  ## Recommended Mitigation Steps Remove Line 79  
# Handle  xYrYuYx   # Vulnerability details  ## Impact `calldata` use less gas than `memory` in function arguments  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L124  ## Tools Used Manual  ## Recommended Mitigation Steps Use `calldata` keyword in function argument instead of `memory`  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  Unused named return: https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L69  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named return  
# Handle  ye0lde   # Vulnerability details  ## Impact  The functions below fail to perform input validation on arrays to verify the lengths match.  A mismatch could lead to an exception or undefined behavior.  ## Proof of Concept  names, destinations https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/OperatorResolver.sol#L27-L39  _inputTokenAmounts, orders https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L321-L337  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add input validation to check that the length of both arrays match.  
# Handle  pants   # Vulnerability details  MixinOperatorResolver.rebuildCache (addressCache[name]), isResolverCached (addressCache[name])  You can cache the value after the first read into a local variable to save the other SLOAD and also the "out of bounds" check.  
# Handle  pants   # Vulnerability details  NestedRecords line 22 - you can save storage by reordering Holding struct fields in the following way:  original:     struct Holding {         address token;         uint256 amount;         bool isActive;     }  change to:      struct Holding {         uint256 amount;         address token;         bool isActive;     }   
# Handle  palina   # Vulnerability details  ## Impact Function performing important changes to contract state should emit events to facilitate monitoring of the protocol operation (e.g., NestedRecords::setReserve(), deleteAsset(), removeNFT()).  ## Proof of Concept setReserve(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L201 deleteAsset(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L207 removeNFT(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L221  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider emitting events on the discussed changes. E.g.,  event ReserveUpdated(address newReserve); ... function setReserve(...) {     emit ReserveUpdated(_nextReserve); }  
# Handle  elprofesor   # Vulnerability details  ## Impact The use of `_token.transfer()` in `NestedFactory.unlockTokens` may have unintended consequences. ERC20 tokens can implement contra to the EIP20 spec (USDT for instance returns VOID). This may result in tokens that return anything from false to void and these return values would not throw on failure. As a result transfer's in `unlockTokens` may not appropriately throw on failure.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L271-L273  ## Recommended Mitigation Steps We recommend using OpenZeppelinâ€™s SafeERC20 versions with the `safeTransfer` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  palina   # Vulnerability details  ## Impact The Nestedbuybacker::triggerForToken() function does not check the return value of the `ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData);` call, which returns a boolean. Even if the swap in the fillQuote() is not successful and no NST was bought, the function proceeds with the trigger() function execution. trigger() also does not check if the `balance` variable (indicating the amount of NST bought) is positive, although there is (at best) no point in executing the rest of the function if there's no NST in the contract.  ## Proof of Concept Unchecked result of the fillQuote() call: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L101 Missing validation in trigger(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L108  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add a return value check in the triggerForToken() function: `bool success = ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData); require(success);` and/or a `balance` value validation in trigger(): `uint256 balance = NST.balanceOf(address(this)); require(balance > 0);`  
# Handle  palina   # Vulnerability details  ## Impact Functions that are only called from outside the contract can be declared external instead of public since they are more gas-efficient.  ## Proof of Concept NestedBuybacker::setBurnPart(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L81, MixinOperatorResolver::rebuildCache(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/MixinOperatorResolver.sol#L29  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change the 'public' visibility modifier into 'external'.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Function `getAmountDue` in `FeeSplitter.sol` defines the variable  `totalReceived` in [line 83](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L83) eventhough it is already known if the variable is even necessary.  The variable is uneccessary if `_tokenRecords.totalShares == 0`. Not declaring it, if not necessary, saves gas.  ## Recommended Mitigation Steps Rewrite the function to something like: ``` TokenRecords storage _tokenRecords = tokenRecords[address(_token)]; if (_tokenRecords.totalShares == 0) return 0; uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this)); // Rest same as before ```  
# Handle  pmerkleplant   # Vulnerability details  Function `triggerForToken` in `NestedBuybacker.sol` makes a `balanceOf` call on the `_sellToken`, see [line 100](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedBuybacker.sol#L100).  However, the result of the call is never used.  It would save gas to remove the unnecessary call and variable declaration.  
# Handle  loop   # Vulnerability details  The `removeFactory` has an unnecessary `==true` comparison in its require statement. Since require already checks if the condition is `true`, there is no need for it to be compared.  ## Impact Removing `== true` saves a tiny amount of gas if `removeFactory` is called.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L142  
# Handle  Meta0xNull   # Vulnerability details  ## Impact _sendFees() repeat Read Storage variable shareholders. Every Storage read is expensive.   ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L227-L232  ## Tools Used Manual Review  ## Recommended Mitigation Steps Read the values from storage once, cache them in local variables and then read them again using the local variables. For example:  Shareholder[] shareholders_temp = shareholders;         for (uint256 i = 0; i < shareholders_temp.length; i++) {             _addShares(                 shareholders_temp[i].account,                 _computeShareCount(_amount, shareholders_temp[i].weight, _totalWeights),                 address(_token)             );  
# Handle  PierrickGT   # Vulnerability details  ## Impact In [setMaxAllowance](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/libraries/ExchangeHelpers.sol#L34), `safeApprove` is used to increase allowance. As stated in the following Pull Request, `safeApprove` has been deprecated in favor of `safeIncreaseAllowance` and `safeDecreaseAllowance`.  https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2268/files  This is because `safeApprove` shouldn't check for allowance, as explained in the issue below:  https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219  `approve` is actually vulnerable to a sandwich attack as explained in the following document and this check for allowance doesn't actually avoid it.  https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit  ## Proof of Concept `safeIncreaseAllowance` should be used to increase allowance and `safeDecreaseAllowance` to decrease allowance to 0. We can also gain in code clarity by refactoring the `if else` statement and calling `_token.safeIncreaseAllowance(_spender, type(uint256).max);` only once.  ## Recommended Mitigation Steps The following changes are recommended.  ``` function setMaxAllowance(IERC20 _token, address _spender) internal {     uint256 _currentAllowance = _token.allowance(address(this), _spender);      if (_currentAllowance != type(uint256).max) {         // Decrease to 0 first for tokens mitigating the race condition         _token.safeDecreaseAllowance(_spender, _currentAllowance);     }      _token.safeIncreaseAllowance(_spender, type(uint256).max); } ```  
# Handle  PierrickGT   # Vulnerability details  ## Impact In [deleteAsset](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedRecords.sol#L213), `tokens` is declared once in the function and then a second time in the function `freeToken`.  ## Proof of Concept The `freeToken` function being used only in `deleteAsset`, the code from this function can be moved to `deleteAsset` and the function removed. This way, we don't have to pass `tokens` to the `freeToken` function and we avoid declaring it here a second time.  ## Recommended Mitigation Steps The following change is recommended.  ``` function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory {     address[] storage tokens = records[_nftId].tokens;     address token = tokens[_tokenIndex];     Holding memory holding = records[_nftId].holdings[token];      require(holding.isActive, "NestedRecords: HOLDING_INACTIVE");      delete records[_nftId].holdings[token];     tokens[_tokenIndex] = tokens[tokens.length - 1];     tokens.pop(); } ```  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact OperatorHelpers.sol: function decodeDataAndRequire state mutability can be restricted to pure We don't read any storage variables, only use the arguments therefore, it can be restricted to pure.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/libraries/OperatorHelpers.sol#L45  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps set function state mutability to pure  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Empty/useless file OwnableOperator.sol is against best practices / code housekeeping.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/operators/OwnableOperator.sol  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Delete file  
# Handle  GiveMeTestEther   # Vulnerability details   ## Impact FeeSplitter.so: totalWeights is the sum of shareholder weights and royaltiesWeight, therefore a subtraction of a shareholder weight or royaltiesWeight can be done unchecked because we can't underflow and save gas.   ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L143  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L169  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L143 can be rewritten as:      function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {         _sendFees(_token, _amount, unchecked {totalWeights - royaltiesWeight});     }  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L169 can be written as unchecked { _totalWeights -= shareholders[_accountIndex].weight; }  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  The pattern of adding/subtracting a variable to/from another value is sometimes written as x += y; and sometimes as x = x + y; (x -= y; and sometimes x = x - y;) The shorter version x += y;/x -= y; increases readability.  ## Proof of Concept  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L241  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L256  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L229  and possible others  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps use the x += y; / x -= y; pattern   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Comment in FeeSplitter  "/// @dev Emitted when a payment is released" for the PaymentReceived event should say "received" instead of "released".  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L25  ## Tools Used Manal Analysis  ## Recommended Mitigation Steps Change line to: /// @dev Emitted when a payment is received  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact The storage variable totalWeights can be set 0 by onlyOwner and therefore we would have a division by zero in the function "_computeShareCount" https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L268  ## Proof of Concept -Assumption we have one shareholder with weight S1 > 0 and royaltiesWeight > 0. -With the function updateShareholder the onlyOwner sets the S1 of our shareholder to 0.  - updateShareholder: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L166  - require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO") condition is met because _totalWeights is the sum of all shareholder weights + royaltiesWeight, and royaltiesWeight is > 0 - With the function setRoyaltiesWeight the onlyOwner sets the royaltiesWeight to 0.  - setRoyaltiesWeight: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94 - => setRoyaltiesWeight is 0 and totalWeights is 0   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps At the end of the function setRoyaltiesWeight check for 0 weight with a require: require(totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO"); https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Functions that are only executable by privileged users (e.g. onlyOwner) and have an impact (e.g. financial, trust) on other users should emit events.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L103 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L166  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L74 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L79 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L271  and possible other  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Emit events for privileged actions  
# Handle  0xngndev   # Vulnerability details  ## Impact Found the same small typo at NestedBuybacker.sol#constructor::line 54 and at NestedBuybacker.sol#constructor::line 87.  The error messages says: "NestedBuybacker::constructor: Burn part to high" It should be "too high".  
# Handle  TomFrench   # Vulnerability details  ## Impact  Deployment + runtime gas cost increase  ## Proof of Concept  On each time we calculate the address of `ZeroExStorage` we hash the entirety of the creation code for `ZeroExStorage`. This means that not only do we have to perform a large hash operation over the entire creation bytecode of this contract, we need to store all of this bytecode in the `ZeroExOperator`'s deployed bytecode.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L61  This hash could be calculated once at deployment and then have this used cheaply each time, reducing both deployment and runtime costs.  ## Recommended Mitigation Steps  Store `keccak256(type(ZeroExStorage).creationCode)` in an `immutable` (not `constant` as this still results in hashing being applied each time) variable.  
# Handle  TomFrench   # Vulnerability details  ## Impact  NFTs can't be managed from future versions of `NestedFactory` without manual migration or removing support for the previous `NestedFactory`.  ## Proof of Concept  From discussion with NestedFinance team members, it's desired that multiple `NestedFactories` can interact with the NFT portfolios and be interoperable into the future.  NestedFinance has two singleton contracts which store the state of NFTs `NestedAsset` and `NestedRecords`  `NestedAsset` allows multiple factories to interact with a given NFT ([asset](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedAsset.sol#L18-L19)) `NestedRecords` lists a single reserve which holds an NFT's assets ([records](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L32))  This is fine however `NestedFactory` and `NestedReserve` are linked together 1:1 ([factory](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L31), [reserve](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L14))  This means that each NFT can only be managed by a single factory as calls from other factories to the relevant reserve will revert due to insufficient permissions. Should I want to update to use the newest factory I would have to manually migrate my portfolio across.  ## Recommended Mitigation Steps  Allow `NestedReserve` to have multiple factories connect to it. Make sure to have the `NestedReserve` secure from reentrancy attacks utilising multiple factories in parallel.   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  Functions in the same contract with the same access modifier (e.g. onlyOwner or onlyFactory) have have a mix of public and external visibility.  Set their visibility to external to save gas.  Affected contracts (see ): - NestedRecords - NestedFactory - FeeSplitter - NestedAsset   ## Tools Used Visial Studio Code + Solidity Visual Developer (Plugin)  ## Recommended Mitigation Steps  Set the visibility to external to save gas.   Extract from Solidity Visual Developer (Plugin) of the Contracts and visibility:  |  Contract  |         Type        |       Bases      |                  |                 | |:----------:|:-------------------:|:----------------:|:----------------:|:---------------:| |     â””      |  **Function Name**  |  **Visibility**  |  **Mutability**  |  **Modifiers**  | |||||| | **NestedRecords** | Implementation | Ownable ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  |NOâ—ï¸ | | â”” | createRecord | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | updateHoldingAmount | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | getAssetTokens | Public â—ï¸ |   |NOâ—ï¸ | | â”” | freeHolding | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | store | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | getAssetHolding | External â—ï¸ |   |NOâ—ï¸ | | â”” | setFactory | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | updateLockTimestamp | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | setMaxHoldingsCount | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | getAssetReserve | External â—ï¸ |   |NOâ—ï¸ | | â”” | getAssetTokensLength | External â—ï¸ |   |NOâ—ï¸ | | â”” | getLockTimestamp | External â—ï¸ |   |NOâ—ï¸ | | â”” | setReserve | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | removeNFT | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | deleteAsset | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | freeToken | Private ğŸ” | ğŸ›‘  | | |||||| | **NestedFactory** | Implementation | INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  | MixinOperatorResolver | | â”” | <Receive Ether> | External â—ï¸ |  ğŸ’µ |NOâ—ï¸ | | â”” | resolverAddressesRequired | Public â—ï¸ |   |NOâ—ï¸ | | â”” | addOperator | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | removeOperator | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | setReserve | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | setFeeSplitter | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | create | External â—ï¸ |  ğŸ’µ | nonReentrant | | â”” | addTokens | External â—ï¸ |  ğŸ’µ | nonReentrant onlyTokenOwner | | â”” | swapTokenForTokens | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | sellTokensToNft | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | sellTokensToWallet | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | destroy | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | withdraw | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | increaseLockTimestamp | External â—ï¸ | ğŸ›‘  | onlyTokenOwner | | â”” | unlockTokens | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | _submitInOrders | Private ğŸ” | ğŸ›‘  | | | â”” | _submitOutOrders | Private ğŸ” | ğŸ›‘  | | | â”” | _submitOrder | Private ğŸ” | ğŸ›‘  | | | â”” | _safeSubmitOrder | Private ğŸ” | ğŸ›‘  | | | â”” | _transferToReserveAndStore | Private ğŸ” | ğŸ›‘  | | | â”” | _transferInputTokens | Private ğŸ” | ğŸ›‘  | | | â”” | _handleUnderSpending | Private ğŸ” | ğŸ›‘  | | | â”” | _transferFeeWithRoyalty | Private ğŸ” | ğŸ›‘  | | | â”” | _decreaseHoldingAmount | Private ğŸ” | ğŸ›‘  | | | â”” | _safeTransferAndUnwrap | Private ğŸ” | ğŸ›‘  | | | â”” | _safeTransferWithFees | Private ğŸ” | ğŸ›‘  | | | â”” | _calculateFees | Private ğŸ” |   | | |||||| | **FeeSplitter** | Implementation | Ownable, ReentrancyGuard ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  |NOâ—ï¸ | | â”” | <Receive Ether> | External â—ï¸ |  ğŸ’µ |NOâ—ï¸ | | â”” | getAmountDue | Public â—ï¸ |   |NOâ—ï¸ | | â”” | setRoyaltiesWeight | Public â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | setShareholders | Public â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | releaseToken | Public â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | releaseTokens | External â—ï¸ | ğŸ›‘  |NOâ—ï¸ | | â”” | releaseETH | External â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | sendFees | External â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | sendFeesWithRoyalties | External â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | updateShareholder | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | totalShares | External â—ï¸ |   |NOâ—ï¸ | | â”” | totalReleased | External â—ï¸ |   |NOâ—ï¸ | | â”” | shares | External â—ï¸ |   |NOâ—ï¸ | | â”” | released | External â—ï¸ |   |NOâ—ï¸ | | â”” | findShareholder | External â—ï¸ |   |NOâ—ï¸ | | â”” | _sendFees | Private ğŸ” | ğŸ›‘  | | | â”” | _addShares | Private ğŸ” | ğŸ›‘  | | | â”” | _releaseToken | Private ğŸ” | ğŸ›‘  | | | â”” | _addShareholder | Private ğŸ” | ğŸ›‘  | | | â”” | _computeShareCount | Private ğŸ” |   | | |||||| | **NestedAsset** | Implementation | ERC721Enumerable, Ownable ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  | ERC721 | | â”” | tokenURI | Public â—ï¸ |   |NOâ—ï¸ | | â”” | originalOwner | Public â—ï¸ |   |NOâ—ï¸ | | â”” | mint | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | mintWithMetadata | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | backfillTokenURI | External â—ï¸ | ğŸ›‘  | onlyFactory onlyTokenOwner | | â”” | burn | External â—ï¸ | ğŸ›‘  | onlyFactory onlyTokenOwner | | â”” | setFactory | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | removeFactory | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | _setTokenURI | Internal ğŸ”’ | ğŸ›‘  | |   Legend  |  Symbol  |  Meaning  | |:--------:|-----------| |    ğŸ›‘    | Function can modify state | |    ğŸ’µ    | Function is payable |   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Calculation of the weights in the function "setRoyaltiesWeight" of FeeSplitter.sol (row 95) can be done more gas efficient.      function setRoyaltiesWeight(uint256 _weight) public onlyOwner {         totalWeights -= royaltiesWeight;         royaltiesWeight = _weight;         totalWeights += _weight;     }  can be rewritten as      function setRoyaltiesWeight(uint256 _weight) public onlyOwner {         totalWeights = totalWeights - royaltiesWeight + _weight;         royaltiesWeight = _weight;     }  => write only once to the storage of totalWeights.  ## Proof of Concept  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps see above  
# Handle  TomFrench   # Vulnerability details  ## Impact  `NestedReserve.transferFromFactory` is unused and so increases deployment costs for no gain  ## Proof of Concept  `NestedReserve` has a `transferFromFactory` which can be seen not to be used in the codebase (and in the case the `NestedFactory` needs to send tokens to the reserve it can do so directly.)  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L55-L60  ## Recommended Mitigation Steps  Remove this function.  
# Handle  0xngndev   # Vulnerability details  ## Impact Running a quick contract size check in the NestedFactory contract, I noticed it sat at 27590 bytes, exceeding the allowed 24576 bytes to deploy on mainnet. I removed the require messages alone in that contract and found the contract size dropped to 23172 bytes. Considering you are using large require messages in all the codebase, I would suggest considering a change of approach as to how you expose the error messages. I'll add my suggestions below.  ## Recommended Mitigation Steps Two ways: 1) Shorten the length of the string messages to just the error instead of including the contract and the function. UniswapV3 repo may be a good example of how to do this. You can always explain errors further in the natspec, or in your documentation (you can make a common errors section). 2) Change require statements for if (...) revert CustomError(). Per solidity docs:  "Using a custom error instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs."  Link: https://docs.soliditylang.org/en/v0.8.10/control-structures.html?highlight=error#revert  ## Tools Used dapptools make size  
# Handle  0x0x0x   # Vulnerability details  ## Explanation  `updateShareholder` in `FeeSplitter.sol` can be implemented more efficiently. The updated version consumes less gas and also has the second `require` statement earlier, which reduces  the gas cost in case the statement of second `require` is not fullfilled.   `FeeSplitter.sol` : L166-174: ```     function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {         require(_accountIndex + 1 <= shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");         uint256 _totalWeights = totalWeights;         _totalWeights -= shareholders[_accountIndex].weight;         shareholders[_accountIndex].weight = _weight;         _totalWeights += _weight;         require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO");         totalWeights = _totalWeights;     } ``` can be replaced with: ```     function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {         require(_accountIndex + 1 <= shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");         totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;         require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO");         shareholders[_accountIndex].weight = _weight;     } ``` ## Tools Used  Manual analysis  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept For unsigned integers, it is cheaper to check ` != 0` than ` > 0`. Both provide the same logic. ## Occurences ``` contracts/FeeSplitter.sol:105:        require(_accounts.length > 0 && _accounts.length == _weights.length, "FeeSplitter: ARRAY_LENGTHS_ERR"); contracts/FeeSplitter.sol:172:        require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO"); contracts/FeeSplitter.sol:263:        require(_weight > 0, "FeeSplitter: ZERO_WEIGHT"); contracts/NestedBuybacker.sol:97:        if (feeSplitter.getAmountDue(address(this), _sellToken) > 0) { contracts/NestedFactory.sol:69:        require(i > 0, "NestedFactory::removeOperator: Cant remove non-existent operator"); contracts/NestedFactory.sol:94:        require(_orders.length > 0, "NestedFactory::create: Missing orders"); contracts/NestedFactory.sol:110:        require(_orders.length > 0, "NestedFactory::addTokens: Missing orders"); contracts/NestedFactory.sol:124:        require(_orders.length > 0, "NestedFactory::swapTokenForTokens: Missing orders"); contracts/NestedFactory.sol:143:        require(_orders.length > 0, "NestedFactory::sellTokensToNft: Missing orders"); contracts/NestedFactory.sol:163:        require(_orders.length > 0, "NestedFactory::sellTokensToWallet: Missing orders"); contracts/NestedFactory.sol:194:        require(_orders.length > 0, "NestedFactory::destroy: Missing orders"); contracts/NestedFactory.sol:333:            if (_inputTokenAmounts[i] - amountSpent > 0) { contracts/NestedFactory.sol:467:        if (_amountToSpent - _amountSpent > 0) { contracts/NestedRecords.sol:171:        require(_maxHoldingsCount > 0, "NestedRecords: INVALID_MAX_HOLDINGS"); contracts/operators/Flat/FlatOperator.sol:18:        require(amount > 0, "FlatOperator::commitAndRevert: Amount must be greater than zero"); contracts/operators/ZeroEx/ZeroExOperator.sol:42:        assert(amountBought > 0); contracts/operators/ZeroEx/ZeroExOperator.sol:43:        assert(amountSold > 0); ```  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept Example: ``` for (uint i = 0; i < arr.length; i++) { //Operations not effecting the length of the array. } ``` Loading length of array costs gas. Therefore, the length should be cached, if the length of the array doesn't change inside the loop. Recommended implementation: ``` uint length = arr.length; for (uint i = 0; i < length; i++) { //Operations not effecting the length of the array. } ``` By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Occurences ``` contracts/FeeSplitter.sol:108:        for (uint256 i = 0; i < _accounts.length; i++) { contracts/FeeSplitter.sol:125:        for (uint256 i = 0; i < _tokens.length; i++) { contracts/FeeSplitter.sol:210:        for (uint256 i = 0; i < shareholders.length; i++) { contracts/FeeSplitter.sol:227:        for (uint256 i = 0; i < shareholders.length; i++) { contracts/MixinOperatorResolver.sol:32:        for (uint256 i = 0; i < requiredAddresses.length; i++) { contracts/MixinOperatorResolver.sol:48:        for (uint256 i = 0; i < requiredAddresses.length; i++) { contracts/NestedFactory.sol:203:        for (uint256 i = 0; i < tokens.length; i++) { contracts/NestedFactory.sol:280:        for (uint256 i = 0; i < _orders.length; i++) { contracts/NestedFactory.sol:316:        for (uint256 i = 0; i < _orders.length; i++) { contracts/OperatorResolver.sol:33:        for (uint256 i = 0; i < names.length; i++) { contracts/OperatorResolver.sol:45:        for (uint256 i = 0; i < names.length; i++) { contracts/OperatorResolver.sol:56:        for (uint256 i = 0; i < destinations.length; i++) { ```  
# Handle  PierrickGT   # Vulnerability details  ## Impact In [_transferToReserveAndStore](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L426), `_token` is casted 3 times to `IERC20` and `reserve` is loaded and casted to `address` 4 times. We can simplify the function and save on gas.  ## Proof of Concept `_token` should be passed to the function as an `IERC20`, this way we avoid to cast it 3 times. `reserve` should be stored in a variable to avoid 3 unnecessary sloads and casting.  ## Recommended Mitigation Steps The following changes are recommended.  ```     function _transferToReserveAndStore(         IERC20 _token,         uint256 _amount,         uint256 _nftId     ) private {         address reserveAddress = address(reserve);         uint256 balanceReserveBefore = _token.balanceOf(reserveAddress);          // Send output to reserve         _token.safeTransfer(reserveAddress, _amount);          uint256 balanceReserveAfter = _token.balanceOf(reserveAddress);          nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddress);     } ```  After this subsequent change, `_outputToken` will need to be casted to `IERC20` on [L386](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L386).  `_transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);`  And no need to cast `_outputToken` anymore on [L357](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L357).  `_transferToReserveAndStore(_outputToken, amountBought - feesAmount, _nftId);`  
# Handle  TomFrench   # Vulnerability details  ## Impact  Potential for a broken deploy of operators which use a storage contract (not in the case of `ZeroExOperator` however)  ## Proof of Concept  `ZeroExOperator` uses a create2 salt of `bytes32("nested.zeroex.operator")` to deploy its storage contract and this salt must be used to recompute this address in future.  It's then important to enforce that both steps use the same salt, however this is not strictly enforced. Currently a change to one must be manually updated in the other, if this was not done then calculation of the storage address would be incorrect.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L15  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L60  This is not an issue in the current case but this is a potential footgun for future operators which use storage.  ## Recommended Mitigation Steps  Place `bytes32("nested.zeroex.operator")` into a constant variable and use this variable instead.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Reduced ease of verifying correctness  ## Proof of Concept  `ZeroExOperator` uses the `Create2` library to deploy `ZeroExOperatorStorage`. `Create2` also exposes a `computeAddress` function which can be used to recalculate the address of `ZeroExOperatorStorage` but `ZeroExOperator` instead uses a homebrew calculation in `storageAddress`.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L55-L65  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/57630d2a6466dff65aa7ca67b3fa23d5e6d1474a/contracts/utils/Create2.sol#L57-L64  The implementation is identical but using standard library code avoids the need for verification and minimises possible mistakes.  ## Recommended Mitigation Steps  Replace `storageAddress` with  ```     function storageAddress(address own) public pure returns (address) {        return Create2.computeAddress(             bytes32("nested.zeroex.operator"),             keccak256(type(ZeroExStorage).creationCode)             own,         );     }  ```  
# Handle  TomFrench   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  In the `receive` function of `FeeSplitter` we check that the address sending ETH is the WETH contract: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L74  As we can safely say that the WETH contract will never send a metatransaction, we can just use msg.sender and avoid the extra gas costs of `_msgSender()`  ## Recommended Mitigation Steps  Replace `_msgSender()` with `msg.sender`  
# Handle  pauliax   # Vulnerability details  ## Impact function "mintWithMetadata" does not need onlyFactory modifier as it will be checked in function "mint" later.   
# Handle  hyh   # Vulnerability details  ## Impact  Array bounds check violation will happen if the function be called with arrays of different lengths.  ## Proof of Concept  Loop is performed by names array, while both arrays are accessed: ``` for (uint256 i = 0; i < names.length; i++) {   if (operators[names[i]] != destinations[i]) { ``` https://github.com/code-423n4/2021-11-nested/blob/main/contracts/OperatorResolver.sol#L27  ## Recommended Mitigation Steps  Add a check: ``` require(names.length == destinations.length, "OperatorResolver::areAddressesImported: Input lengths must match"); ```  
# Handle  pauliax   # Vulnerability details  ## Impact I think it is not necessary to have function _burnNST as a separate private function. It is called only once and has just one LOC so it just incurs in extra gas cost which can be avoided by moving this line to function trigger and getting rid of _burnNST.   
# Handle  pauliax   # Vulnerability details  ## Impact This can be simplified to reduce gas costs by eliminating math operation: ```solidity   // before   require(_accountIndex + 1 <= shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");   // after   require(_accountIndex < shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");  ```  
# Handle  pauliax   # Vulnerability details  ## Impact INestedToken is declared as an abstract contract, yet it contains no function bodies and is located under the interfaces directory, so I think it should be declared as an interface.  ## Recommended Mitigation Steps Consider making INestedToken an interface.  
# Handle  hyh   # Vulnerability details  ```setFactory``` should be named ```addFactory``` as it doesn't set the only factory, but adds to the list of factories  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L133  
# Handle  pauliax   # Vulnerability details  ## Impact NestedRecords contains no removeFactory function so there is no way to revoke a factory in case you no longer want to support it. This function is present in NestedAsset contract so I thought you might want to also have it here.  ## Recommended Mitigation Steps Consider if you are missing removeFactory or is this an intended functionality.   
# Handle  hyh   # Vulnerability details  ## Impact  NFT token operations will fail if wrong reserve is used.  ## Proof of Concept  ```NestedFactory``` ```reserve``` is used in ```addtokens``` and ```withdraw``` function for a given NFT, but the NFT to reserve contract correspondence isn't checked.  addtokens: https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L119  withdraw: https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L241  ## Recommended Mitigation Steps  Add the ```require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "...")``` check in the beginning of the functions.  
# Handle  hyh   # Vulnerability details  ## Impact  Whenever condition of the ```_handleUnderSpending``` function fails function call gas costs are wasted. The cost of checking the condition is paid anyway, while when it doesn't hold the function call costs are avoidable.  ## Proof of Concept  ```_handleUnderSpending``` checks for ```_amountToSpent - _amountSpent > 0```.  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L481  ## Recommended Mitigation Steps  When the check condition is false ```_handleUnderSpending``` shouldn't be called and this way the check with corresponding variables to be placed in caller functions:  _submitInOrders https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L306  _safeSubmitOrder https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L415  
# Handle  0xngndev   # Vulnerability details  ## Impact In `FeeSplitter.sol` by doing a small refactory gas can be saved in case of a revert in the functions: `getAmountDue` and `_releaseToken` . We can swap the order of two lines so we return earlier in case of a bad input, this way we save some gas because the evm would execute less opcodes before reverting.  ## Mitigation steps getAmountDue: Swap line 83 with 84 to avoid computing unnecessary logic. Remove the "else"  and combine it with line 83. Something like this:  ```   function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];     if (_tokenRecords.totalShares == 0) return 0;         uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));         uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /             _tokenRecords.totalShares -             _tokenRecords.released[_account];         return amountDue;     } ``` _releaseToken: move line 252 after the require in line 254. Like this:  ```   function _releaseToken(address _account, IERC20 _token) private returns (uint256) {         uint256 amountToRelease = getAmountDue(_account, _token);         require(amountToRelease != 0, "FeeSplitter: NO_PAYMENT_DUE");         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];          _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;         _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;          return amountToRelease;     } ```   
# Handle  defsec   # Vulnerability details  ## Impact The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  1. Navigate to the following contracts.  "https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L135" "https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L111" "https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L32"  ## Tools Used  Code review  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.    
# Handle  cmichel   # Vulnerability details  The `NestedFactory._handleUnderSpending` function implements a condition as `_amountToSpent - _amountSpent > 0` instead of `_amountToSpent > _amountSpent`. The former reverts if `_amountSpent > _amountToSpent` while the latter doesn't.  It's unclear which behavior is preferred.  ## Recommended Mitigation Steps Think about if `_amountSpent > _amountToSpent` should revert or not. If not, the `if` condition can be rewritten as `_amountSpent > _amountToSpent` which would also save gas.  
# Handle  cmichel   # Vulnerability details  The `NestedFactory.addOperator` function pushes the `operator` even if it already exists in `operators`.  ## Impact When this duplicated operator is removed through a `removeOperator` call, only the first instance is removed. The operator can now still be called which can lead to unexpected behavior.  ## Recommended Mitigation Steps Check if the operator already exists before adding it.  
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for non-zero values: - `NestedFactory.constructor`: address parameters could be zero or not a contract - `NestedReserve.constructor`: address parameters could be zero or not a contract - `NestedBuybacker.constructor`: address parameters could be zero or not a contract  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.   
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/FeeSplitter.sol#L152-L162  ```solidity=152 function sendFeesWithRoyalties(     address _royaltiesTarget,     IERC20 _token,     uint256 _amount ) external nonReentrant {     require(_royaltiesTarget != address(0), "FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS");      _sendFees(_token, _amount, totalWeights);     _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token)); } ```  ### Recommendation  Change to:  ```solidity=152 function sendFeesWithRoyalties(     address _royaltiesTarget,     IERC20 _token,     uint256 _amount ) external nonReentrant {     require(_royaltiesTarget != address(0), "FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS");      uint256 _totalWeights = totalWeights;      _sendFees(_token, _amount, _totalWeights);     _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, _totalWeights), address(_token)); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L553-L559  ```solidity=553 /// @dev Calculate the fees for a specific user and amount (1%) /// @param _user The user address /// @param _amount The amount /// @return The fees amount function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {     return _amount / 100; } ```  The function `_calculateFees()` is a rather simple function, replacing it with inline expression `_amount / 100` can save some gas.  
# Handle  WatchPug   # Vulnerability details  `releaseToken()` has `nonReentrant` modifier, making `releaseTokens()` to set storage `_status` multiple times in the for loop.  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/FeeSplitter.sol#L116-L129  ```solidity=116 function releaseToken(IERC20 _token) public nonReentrant {     uint256 amount = _releaseToken(_msgSender(), _token);     _token.safeTransfer(_msgSender(), amount);     emit PaymentReleased(_msgSender(), address(_token), amount); }  /// @notice Call releaseToken() for multiple tokens /// @param _tokens ERC20 tokens to release function releaseTokens(IERC20[] memory _tokens) external {     for (uint256 i = 0; i < _tokens.length; i++) {         releaseToken(_tokens[i]);     } } ```  ### Recommendation  Change to:  ```solidity=116 function releaseToken(IERC20 _token) public nonReentrant {     _releaseTokenAndTransfer(_token); }  /// @notice Call releaseToken() for multiple tokens /// @param _tokens ERC20 tokens to release function releaseTokens(IERC20[] memory _tokens) external {     for (uint256 i = 0; i < _tokens.length; i++) {         _releaseTokenAndTransfer(_tokens[i]);     } }  function _releaseTokenAndTransfer(IERC20 _token) private {     uint256 amount = _releaseToken(_msgSender(), _token);     _token.safeTransfer(_msgSender(), amount);     emit PaymentReleased(_msgSender(), address(_token), amount); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedRecords.sol#L56-L79  ```solidity=56{67} /// @notice Add a record for NFT data into our mappings /// @param _nftId The id of the NFT /// @param _token The address of the token /// @param _amount The amount of tokens bought /// @param _reserve The address of the reserve function createRecord(     uint256 _nftId,     address _token,     uint256 _amount,     address _reserve ) public onlyFactory {     require(records[_nftId].tokens.length < maxHoldingsCount, "NestedRecords: TOO_MANY_ORDERS");     require(         _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)),         "NestedRecords: INVALID_RESERVE"     );      Holding memory holding = records[_nftId].holdings[_token];     require(!holding.isActive, "NestedRecords: HOLDING_EXISTS");      records[_nftId].holdings[_token] = Holding({ token: _token, amount: _amount, isActive: true });     records[_nftId].tokens.push(_token);     records[_nftId].reserve = _reserve; } ```  The error message "NestedRecords: TOO_MANY_ORDERS" should be changed to "NestedRecords: TOO_MANY_TOKENS".  
# Handle  GreyArt   # Vulnerability details  ## Impact  A user that mistakenly calls either `create()` or `addToken()` with WETH (or another ERC20) as the input token, but includes native ETH with the function call will have his native ETH permanently locked in the contract.  ## Recommended Mitigation Steps  It is best to ensure that `msg.value = 0` in `_transferInputTokens()` for the scenario mentioned above.  ```jsx } else if (address(_inputToken) == ETH) {  ... } else {  require(msg.value == 0, "NestedFactory::_transferInputTokens: ETH sent for non-ETH transfer");   _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  `_submitOutOrders()` is invoked by 2 functions `sellTokensToNft()` and `sellTokensToWallet()`, both of which specify the `_fromReserve` parameter to be `true`. This parameter is therefore unneeded.  ## Recommended Mitigation Steps  ```jsx function _submitOutOrders(   uint256 _nftId,   IERC20 _outputToken,   uint256[] memory _inputTokenAmounts,   Order[] calldata _orders,   bool _reserved ) private returns (uint256 feesAmount, uint256 amountBought) {  ...    IERC20 _inputToken = _transferInputTokens(     _nftId,     IERC20(_orders[i].token),     _inputTokenAmounts[i],     true  ); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  `createRecord()` is only invoked by `store()`. Its visibility can therefore be made internal / private.  ## Recommended Mitigation Steps  ```jsx function createRecord(   uint256 _nftId,   address _token,   uint256 _amount,  address _reserve ) internal onlyFactory {...} ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  The `transferFromFactory()` function is missing the `valid(address(_token))` modifier that is present in the `transfer()` and `withdraw()` functions.  It is in our opinion that these sanity checks on the token address are redundant, because the transaction will revert anyway in the SafeERC20 library.  ## Recommended Mitigation Steps  Either add in the modifier check for the `transferFromFactory()` function. Alternatively, remove them from all the functions as a gas optimization.  
# Handle  GreyArt   # Vulnerability details  ## Impact  The `name` and `destination` local variables in the `rebuildCache` function are declared multiple times within the loop. It'll be cheaper to declare them once outside the loop and reuse the variables inside.   ## Recommended Mitigation Steps  ```jsx bytes32 name; address destination; // The resolver must call this function whenever it updates its state for (uint256 i = 0; i < requiredAddresses.length; i++) {  name = requiredAddresses[i];  // Note: can only be invoked once the resolver has all the targets needed added  destination = resolver.getAddress(name);   ... } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  It is unnecessary to store the `token` variable in the `Holding` struct because the token is used as the key to access the `Holding` struct.  ## Recommended Mitigation Steps  Remove the `token` variable in the `Holding` struct.  ```jsx /// @dev Info about assets stored in reserves struct Holding {   uint256 amount;   bool isActive; } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  The `importOperators()` declares the `name` and `destination` variables multiple times. It'll be cheaper to declare them once outside the loop and reuse the variables inside.   ## Recommended Mitigation Steps  ```jsx bytes32 name; address destination;  for (uint256 i = 0; i < names.length; i++) {  name = names[i];  destination = destinations[i];   operators[name] = destination;   emit OperatorImported(name, destination); } ```  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedBuybacker.sol#L15  There is only NST.safeTransfer used, and NST is INestedToken interface. SafeERC20 is not used for IERC20 interface.  ## Tools Used  ## Recommended Mitigation Steps Remove Line 79  
# Handle  xYrYuYx   # Vulnerability details  ## Impact `calldata` use less gas than `memory` in function arguments  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L124  ## Tools Used Manual  ## Recommended Mitigation Steps Use `calldata` keyword in function argument instead of `memory`  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  Unused named return: https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L69  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named return  
# Handle  ye0lde   # Vulnerability details  ## Impact  The functions below fail to perform input validation on arrays to verify the lengths match.  A mismatch could lead to an exception or undefined behavior.  ## Proof of Concept  names, destinations https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/OperatorResolver.sol#L27-L39  _inputTokenAmounts, orders https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L321-L337  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add input validation to check that the length of both arrays match.  
# Handle  pants   # Vulnerability details  MixinOperatorResolver.rebuildCache (addressCache[name]), isResolverCached (addressCache[name])  You can cache the value after the first read into a local variable to save the other SLOAD and also the "out of bounds" check.  
# Handle  pants   # Vulnerability details  NestedRecords line 22 - you can save storage by reordering Holding struct fields in the following way:  original:     struct Holding {         address token;         uint256 amount;         bool isActive;     }  change to:      struct Holding {         uint256 amount;         address token;         bool isActive;     }   
# Handle  palina   # Vulnerability details  ## Impact Function performing important changes to contract state should emit events to facilitate monitoring of the protocol operation (e.g., NestedRecords::setReserve(), deleteAsset(), removeNFT()).  ## Proof of Concept setReserve(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L201 deleteAsset(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L207 removeNFT(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L221  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider emitting events on the discussed changes. E.g.,  event ReserveUpdated(address newReserve); ... function setReserve(...) {     emit ReserveUpdated(_nextReserve); }  
# Handle  elprofesor   # Vulnerability details  ## Impact The use of `_token.transfer()` in `NestedFactory.unlockTokens` may have unintended consequences. ERC20 tokens can implement contra to the EIP20 spec (USDT for instance returns VOID). This may result in tokens that return anything from false to void and these return values would not throw on failure. As a result transfer's in `unlockTokens` may not appropriately throw on failure.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L271-L273  ## Recommended Mitigation Steps We recommend using OpenZeppelinâ€™s SafeERC20 versions with the `safeTransfer` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  palina   # Vulnerability details  ## Impact The Nestedbuybacker::triggerForToken() function does not check the return value of the `ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData);` call, which returns a boolean. Even if the swap in the fillQuote() is not successful and no NST was bought, the function proceeds with the trigger() function execution. trigger() also does not check if the `balance` variable (indicating the amount of NST bought) is positive, although there is (at best) no point in executing the rest of the function if there's no NST in the contract.  ## Proof of Concept Unchecked result of the fillQuote() call: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L101 Missing validation in trigger(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L108  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add a return value check in the triggerForToken() function: `bool success = ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData); require(success);` and/or a `balance` value validation in trigger(): `uint256 balance = NST.balanceOf(address(this)); require(balance > 0);`  
# Handle  palina   # Vulnerability details  ## Impact Functions that are only called from outside the contract can be declared external instead of public since they are more gas-efficient.  ## Proof of Concept NestedBuybacker::setBurnPart(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L81, MixinOperatorResolver::rebuildCache(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/MixinOperatorResolver.sol#L29  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change the 'public' visibility modifier into 'external'.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Function `getAmountDue` in `FeeSplitter.sol` defines the variable  `totalReceived` in [line 83](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L83) eventhough it is already known if the variable is even necessary.  The variable is uneccessary if `_tokenRecords.totalShares == 0`. Not declaring it, if not necessary, saves gas.  ## Recommended Mitigation Steps Rewrite the function to something like: ``` TokenRecords storage _tokenRecords = tokenRecords[address(_token)]; if (_tokenRecords.totalShares == 0) return 0; uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this)); // Rest same as before ```  
# Handle  pmerkleplant   # Vulnerability details  Function `triggerForToken` in `NestedBuybacker.sol` makes a `balanceOf` call on the `_sellToken`, see [line 100](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedBuybacker.sol#L100).  However, the result of the call is never used.  It would save gas to remove the unnecessary call and variable declaration.  
# Handle  loop   # Vulnerability details  The `removeFactory` has an unnecessary `==true` comparison in its require statement. Since require already checks if the condition is `true`, there is no need for it to be compared.  ## Impact Removing `== true` saves a tiny amount of gas if `removeFactory` is called.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L142  
# Handle  Meta0xNull   # Vulnerability details  ## Impact _sendFees() repeat Read Storage variable shareholders. Every Storage read is expensive.   ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L227-L232  ## Tools Used Manual Review  ## Recommended Mitigation Steps Read the values from storage once, cache them in local variables and then read them again using the local variables. For example:  Shareholder[] shareholders_temp = shareholders;         for (uint256 i = 0; i < shareholders_temp.length; i++) {             _addShares(                 shareholders_temp[i].account,                 _computeShareCount(_amount, shareholders_temp[i].weight, _totalWeights),                 address(_token)             );  
# Handle  PierrickGT   # Vulnerability details  ## Impact In [setMaxAllowance](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/libraries/ExchangeHelpers.sol#L34), `safeApprove` is used to increase allowance. As stated in the following Pull Request, `safeApprove` has been deprecated in favor of `safeIncreaseAllowance` and `safeDecreaseAllowance`.  https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2268/files  This is because `safeApprove` shouldn't check for allowance, as explained in the issue below:  https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219  `approve` is actually vulnerable to a sandwich attack as explained in the following document and this check for allowance doesn't actually avoid it.  https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit  ## Proof of Concept `safeIncreaseAllowance` should be used to increase allowance and `safeDecreaseAllowance` to decrease allowance to 0. We can also gain in code clarity by refactoring the `if else` statement and calling `_token.safeIncreaseAllowance(_spender, type(uint256).max);` only once.  ## Recommended Mitigation Steps The following changes are recommended.  ``` function setMaxAllowance(IERC20 _token, address _spender) internal {     uint256 _currentAllowance = _token.allowance(address(this), _spender);      if (_currentAllowance != type(uint256).max) {         // Decrease to 0 first for tokens mitigating the race condition         _token.safeDecreaseAllowance(_spender, _currentAllowance);     }      _token.safeIncreaseAllowance(_spender, type(uint256).max); } ```  
# Handle  PierrickGT   # Vulnerability details  ## Impact In [deleteAsset](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedRecords.sol#L213), `tokens` is declared once in the function and then a second time in the function `freeToken`.  ## Proof of Concept The `freeToken` function being used only in `deleteAsset`, the code from this function can be moved to `deleteAsset` and the function removed. This way, we don't have to pass `tokens` to the `freeToken` function and we avoid declaring it here a second time.  ## Recommended Mitigation Steps The following change is recommended.  ``` function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory {     address[] storage tokens = records[_nftId].tokens;     address token = tokens[_tokenIndex];     Holding memory holding = records[_nftId].holdings[token];      require(holding.isActive, "NestedRecords: HOLDING_INACTIVE");      delete records[_nftId].holdings[token];     tokens[_tokenIndex] = tokens[tokens.length - 1];     tokens.pop(); } ```  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact OperatorHelpers.sol: function decodeDataAndRequire state mutability can be restricted to pure We don't read any storage variables, only use the arguments therefore, it can be restricted to pure.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/libraries/OperatorHelpers.sol#L45  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps set function state mutability to pure  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Empty/useless file OwnableOperator.sol is against best practices / code housekeeping.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/operators/OwnableOperator.sol  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Delete file  
# Handle  GiveMeTestEther   # Vulnerability details   ## Impact FeeSplitter.so: totalWeights is the sum of shareholder weights and royaltiesWeight, therefore a subtraction of a shareholder weight or royaltiesWeight can be done unchecked because we can't underflow and save gas.   ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L143  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L169  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L143 can be rewritten as:      function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {         _sendFees(_token, _amount, unchecked {totalWeights - royaltiesWeight});     }  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L169 can be written as unchecked { _totalWeights -= shareholders[_accountIndex].weight; }  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  The pattern of adding/subtracting a variable to/from another value is sometimes written as x += y; and sometimes as x = x + y; (x -= y; and sometimes x = x - y;) The shorter version x += y;/x -= y; increases readability.  ## Proof of Concept  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L241  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L256  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L229  and possible others  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps use the x += y; / x -= y; pattern   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Comment in FeeSplitter  "/// @dev Emitted when a payment is released" for the PaymentReceived event should say "received" instead of "released".  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L25  ## Tools Used Manal Analysis  ## Recommended Mitigation Steps Change line to: /// @dev Emitted when a payment is received  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact The storage variable totalWeights can be set 0 by onlyOwner and therefore we would have a division by zero in the function "_computeShareCount" https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L268  ## Proof of Concept -Assumption we have one shareholder with weight S1 > 0 and royaltiesWeight > 0. -With the function updateShareholder the onlyOwner sets the S1 of our shareholder to 0.  - updateShareholder: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L166  - require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO") condition is met because _totalWeights is the sum of all shareholder weights + royaltiesWeight, and royaltiesWeight is > 0 - With the function setRoyaltiesWeight the onlyOwner sets the royaltiesWeight to 0.  - setRoyaltiesWeight: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94 - => setRoyaltiesWeight is 0 and totalWeights is 0   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps At the end of the function setRoyaltiesWeight check for 0 weight with a require: require(totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO"); https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Functions that are only executable by privileged users (e.g. onlyOwner) and have an impact (e.g. financial, trust) on other users should emit events.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L103 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L166  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L74 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L79 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L271  and possible other  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Emit events for privileged actions  
# Handle  0xngndev   # Vulnerability details  ## Impact Found the same small typo at NestedBuybacker.sol#constructor::line 54 and at NestedBuybacker.sol#constructor::line 87.  The error messages says: "NestedBuybacker::constructor: Burn part to high" It should be "too high".  
# Handle  TomFrench   # Vulnerability details  ## Impact  Deployment + runtime gas cost increase  ## Proof of Concept  On each time we calculate the address of `ZeroExStorage` we hash the entirety of the creation code for `ZeroExStorage`. This means that not only do we have to perform a large hash operation over the entire creation bytecode of this contract, we need to store all of this bytecode in the `ZeroExOperator`'s deployed bytecode.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L61  This hash could be calculated once at deployment and then have this used cheaply each time, reducing both deployment and runtime costs.  ## Recommended Mitigation Steps  Store `keccak256(type(ZeroExStorage).creationCode)` in an `immutable` (not `constant` as this still results in hashing being applied each time) variable.  
# Handle  TomFrench   # Vulnerability details  ## Impact  NFTs can't be managed from future versions of `NestedFactory` without manual migration or removing support for the previous `NestedFactory`.  ## Proof of Concept  From discussion with NestedFinance team members, it's desired that multiple `NestedFactories` can interact with the NFT portfolios and be interoperable into the future.  NestedFinance has two singleton contracts which store the state of NFTs `NestedAsset` and `NestedRecords`  `NestedAsset` allows multiple factories to interact with a given NFT ([asset](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedAsset.sol#L18-L19)) `NestedRecords` lists a single reserve which holds an NFT's assets ([records](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L32))  This is fine however `NestedFactory` and `NestedReserve` are linked together 1:1 ([factory](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L31), [reserve](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L14))  This means that each NFT can only be managed by a single factory as calls from other factories to the relevant reserve will revert due to insufficient permissions. Should I want to update to use the newest factory I would have to manually migrate my portfolio across.  ## Recommended Mitigation Steps  Allow `NestedReserve` to have multiple factories connect to it. Make sure to have the `NestedReserve` secure from reentrancy attacks utilising multiple factories in parallel.   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  Functions in the same contract with the same access modifier (e.g. onlyOwner or onlyFactory) have have a mix of public and external visibility.  Set their visibility to external to save gas.  Affected contracts (see ): - NestedRecords - NestedFactory - FeeSplitter - NestedAsset   ## Tools Used Visial Studio Code + Solidity Visual Developer (Plugin)  ## Recommended Mitigation Steps  Set the visibility to external to save gas.   Extract from Solidity Visual Developer (Plugin) of the Contracts and visibility:  |  Contract  |         Type        |       Bases      |                  |                 | |:----------:|:-------------------:|:----------------:|:----------------:|:---------------:| |     â””      |  **Function Name**  |  **Visibility**  |  **Mutability**  |  **Modifiers**  | |||||| | **NestedRecords** | Implementation | Ownable ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  |NOâ—ï¸ | | â”” | createRecord | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | updateHoldingAmount | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | getAssetTokens | Public â—ï¸ |   |NOâ—ï¸ | | â”” | freeHolding | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | store | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | getAssetHolding | External â—ï¸ |   |NOâ—ï¸ | | â”” | setFactory | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | updateLockTimestamp | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | setMaxHoldingsCount | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | getAssetReserve | External â—ï¸ |   |NOâ—ï¸ | | â”” | getAssetTokensLength | External â—ï¸ |   |NOâ—ï¸ | | â”” | getLockTimestamp | External â—ï¸ |   |NOâ—ï¸ | | â”” | setReserve | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | removeNFT | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | deleteAsset | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | freeToken | Private ğŸ” | ğŸ›‘  | | |||||| | **NestedFactory** | Implementation | INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  | MixinOperatorResolver | | â”” | <Receive Ether> | External â—ï¸ |  ğŸ’µ |NOâ—ï¸ | | â”” | resolverAddressesRequired | Public â—ï¸ |   |NOâ—ï¸ | | â”” | addOperator | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | removeOperator | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | setReserve | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | setFeeSplitter | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | create | External â—ï¸ |  ğŸ’µ | nonReentrant | | â”” | addTokens | External â—ï¸ |  ğŸ’µ | nonReentrant onlyTokenOwner | | â”” | swapTokenForTokens | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | sellTokensToNft | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | sellTokensToWallet | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | destroy | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | withdraw | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | increaseLockTimestamp | External â—ï¸ | ğŸ›‘  | onlyTokenOwner | | â”” | unlockTokens | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | _submitInOrders | Private ğŸ” | ğŸ›‘  | | | â”” | _submitOutOrders | Private ğŸ” | ğŸ›‘  | | | â”” | _submitOrder | Private ğŸ” | ğŸ›‘  | | | â”” | _safeSubmitOrder | Private ğŸ” | ğŸ›‘  | | | â”” | _transferToReserveAndStore | Private ğŸ” | ğŸ›‘  | | | â”” | _transferInputTokens | Private ğŸ” | ğŸ›‘  | | | â”” | _handleUnderSpending | Private ğŸ” | ğŸ›‘  | | | â”” | _transferFeeWithRoyalty | Private ğŸ” | ğŸ›‘  | | | â”” | _decreaseHoldingAmount | Private ğŸ” | ğŸ›‘  | | | â”” | _safeTransferAndUnwrap | Private ğŸ” | ğŸ›‘  | | | â”” | _safeTransferWithFees | Private ğŸ” | ğŸ›‘  | | | â”” | _calculateFees | Private ğŸ” |   | | |||||| | **FeeSplitter** | Implementation | Ownable, ReentrancyGuard ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  |NOâ—ï¸ | | â”” | <Receive Ether> | External â—ï¸ |  ğŸ’µ |NOâ—ï¸ | | â”” | getAmountDue | Public â—ï¸ |   |NOâ—ï¸ | | â”” | setRoyaltiesWeight | Public â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | setShareholders | Public â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | releaseToken | Public â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | releaseTokens | External â—ï¸ | ğŸ›‘  |NOâ—ï¸ | | â”” | releaseETH | External â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | sendFees | External â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | sendFeesWithRoyalties | External â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | updateShareholder | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | totalShares | External â—ï¸ |   |NOâ—ï¸ | | â”” | totalReleased | External â—ï¸ |   |NOâ—ï¸ | | â”” | shares | External â—ï¸ |   |NOâ—ï¸ | | â”” | released | External â—ï¸ |   |NOâ—ï¸ | | â”” | findShareholder | External â—ï¸ |   |NOâ—ï¸ | | â”” | _sendFees | Private ğŸ” | ğŸ›‘  | | | â”” | _addShares | Private ğŸ” | ğŸ›‘  | | | â”” | _releaseToken | Private ğŸ” | ğŸ›‘  | | | â”” | _addShareholder | Private ğŸ” | ğŸ›‘  | | | â”” | _computeShareCount | Private ğŸ” |   | | |||||| | **NestedAsset** | Implementation | ERC721Enumerable, Ownable ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  | ERC721 | | â”” | tokenURI | Public â—ï¸ |   |NOâ—ï¸ | | â”” | originalOwner | Public â—ï¸ |   |NOâ—ï¸ | | â”” | mint | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | mintWithMetadata | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | backfillTokenURI | External â—ï¸ | ğŸ›‘  | onlyFactory onlyTokenOwner | | â”” | burn | External â—ï¸ | ğŸ›‘  | onlyFactory onlyTokenOwner | | â”” | setFactory | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | removeFactory | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | _setTokenURI | Internal ğŸ”’ | ğŸ›‘  | |   Legend  |  Symbol  |  Meaning  | |:--------:|-----------| |    ğŸ›‘    | Function can modify state | |    ğŸ’µ    | Function is payable |   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Calculation of the weights in the function "setRoyaltiesWeight" of FeeSplitter.sol (row 95) can be done more gas efficient.      function setRoyaltiesWeight(uint256 _weight) public onlyOwner {         totalWeights -= royaltiesWeight;         royaltiesWeight = _weight;         totalWeights += _weight;     }  can be rewritten as      function setRoyaltiesWeight(uint256 _weight) public onlyOwner {         totalWeights = totalWeights - royaltiesWeight + _weight;         royaltiesWeight = _weight;     }  => write only once to the storage of totalWeights.  ## Proof of Concept  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps see above  
# Handle  TomFrench   # Vulnerability details  ## Impact  `NestedReserve.transferFromFactory` is unused and so increases deployment costs for no gain  ## Proof of Concept  `NestedReserve` has a `transferFromFactory` which can be seen not to be used in the codebase (and in the case the `NestedFactory` needs to send tokens to the reserve it can do so directly.)  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L55-L60  ## Recommended Mitigation Steps  Remove this function.  
# Handle  0xngndev   # Vulnerability details  ## Impact Running a quick contract size check in the NestedFactory contract, I noticed it sat at 27590 bytes, exceeding the allowed 24576 bytes to deploy on mainnet. I removed the require messages alone in that contract and found the contract size dropped to 23172 bytes. Considering you are using large require messages in all the codebase, I would suggest considering a change of approach as to how you expose the error messages. I'll add my suggestions below.  ## Recommended Mitigation Steps Two ways: 1) Shorten the length of the string messages to just the error instead of including the contract and the function. UniswapV3 repo may be a good example of how to do this. You can always explain errors further in the natspec, or in your documentation (you can make a common errors section). 2) Change require statements for if (...) revert CustomError(). Per solidity docs:  "Using a custom error instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs."  Link: https://docs.soliditylang.org/en/v0.8.10/control-structures.html?highlight=error#revert  ## Tools Used dapptools make size  
# Handle  0x0x0x   # Vulnerability details  ## Explanation  `updateShareholder` in `FeeSplitter.sol` can be implemented more efficiently. The updated version consumes less gas and also has the second `require` statement earlier, which reduces  the gas cost in case the statement of second `require` is not fullfilled.   `FeeSplitter.sol` : L166-174: ```     function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {         require(_accountIndex + 1 <= shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");         uint256 _totalWeights = totalWeights;         _totalWeights -= shareholders[_accountIndex].weight;         shareholders[_accountIndex].weight = _weight;         _totalWeights += _weight;         require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO");         totalWeights = _totalWeights;     } ``` can be replaced with: ```     function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {         require(_accountIndex + 1 <= shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");         totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;         require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO");         shareholders[_accountIndex].weight = _weight;     } ``` ## Tools Used  Manual analysis  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept For unsigned integers, it is cheaper to check ` != 0` than ` > 0`. Both provide the same logic. ## Occurences ``` contracts/FeeSplitter.sol:105:        require(_accounts.length > 0 && _accounts.length == _weights.length, "FeeSplitter: ARRAY_LENGTHS_ERR"); contracts/FeeSplitter.sol:172:        require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO"); contracts/FeeSplitter.sol:263:        require(_weight > 0, "FeeSplitter: ZERO_WEIGHT"); contracts/NestedBuybacker.sol:97:        if (feeSplitter.getAmountDue(address(this), _sellToken) > 0) { contracts/NestedFactory.sol:69:        require(i > 0, "NestedFactory::removeOperator: Cant remove non-existent operator"); contracts/NestedFactory.sol:94:        require(_orders.length > 0, "NestedFactory::create: Missing orders"); contracts/NestedFactory.sol:110:        require(_orders.length > 0, "NestedFactory::addTokens: Missing orders"); contracts/NestedFactory.sol:124:        require(_orders.length > 0, "NestedFactory::swapTokenForTokens: Missing orders"); contracts/NestedFactory.sol:143:        require(_orders.length > 0, "NestedFactory::sellTokensToNft: Missing orders"); contracts/NestedFactory.sol:163:        require(_orders.length > 0, "NestedFactory::sellTokensToWallet: Missing orders"); contracts/NestedFactory.sol:194:        require(_orders.length > 0, "NestedFactory::destroy: Missing orders"); contracts/NestedFactory.sol:333:            if (_inputTokenAmounts[i] - amountSpent > 0) { contracts/NestedFactory.sol:467:        if (_amountToSpent - _amountSpent > 0) { contracts/NestedRecords.sol:171:        require(_maxHoldingsCount > 0, "NestedRecords: INVALID_MAX_HOLDINGS"); contracts/operators/Flat/FlatOperator.sol:18:        require(amount > 0, "FlatOperator::commitAndRevert: Amount must be greater than zero"); contracts/operators/ZeroEx/ZeroExOperator.sol:42:        assert(amountBought > 0); contracts/operators/ZeroEx/ZeroExOperator.sol:43:        assert(amountSold > 0); ```  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept Example: ``` for (uint i = 0; i < arr.length; i++) { //Operations not effecting the length of the array. } ``` Loading length of array costs gas. Therefore, the length should be cached, if the length of the array doesn't change inside the loop. Recommended implementation: ``` uint length = arr.length; for (uint i = 0; i < length; i++) { //Operations not effecting the length of the array. } ``` By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Occurences ``` contracts/FeeSplitter.sol:108:        for (uint256 i = 0; i < _accounts.length; i++) { contracts/FeeSplitter.sol:125:        for (uint256 i = 0; i < _tokens.length; i++) { contracts/FeeSplitter.sol:210:        for (uint256 i = 0; i < shareholders.length; i++) { contracts/FeeSplitter.sol:227:        for (uint256 i = 0; i < shareholders.length; i++) { contracts/MixinOperatorResolver.sol:32:        for (uint256 i = 0; i < requiredAddresses.length; i++) { contracts/MixinOperatorResolver.sol:48:        for (uint256 i = 0; i < requiredAddresses.length; i++) { contracts/NestedFactory.sol:203:        for (uint256 i = 0; i < tokens.length; i++) { contracts/NestedFactory.sol:280:        for (uint256 i = 0; i < _orders.length; i++) { contracts/NestedFactory.sol:316:        for (uint256 i = 0; i < _orders.length; i++) { contracts/OperatorResolver.sol:33:        for (uint256 i = 0; i < names.length; i++) { contracts/OperatorResolver.sol:45:        for (uint256 i = 0; i < names.length; i++) { contracts/OperatorResolver.sol:56:        for (uint256 i = 0; i < destinations.length; i++) { ```  
# Handle  PierrickGT   # Vulnerability details  ## Impact In [_transferToReserveAndStore](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L426), `_token` is casted 3 times to `IERC20` and `reserve` is loaded and casted to `address` 4 times. We can simplify the function and save on gas.  ## Proof of Concept `_token` should be passed to the function as an `IERC20`, this way we avoid to cast it 3 times. `reserve` should be stored in a variable to avoid 3 unnecessary sloads and casting.  ## Recommended Mitigation Steps The following changes are recommended.  ```     function _transferToReserveAndStore(         IERC20 _token,         uint256 _amount,         uint256 _nftId     ) private {         address reserveAddress = address(reserve);         uint256 balanceReserveBefore = _token.balanceOf(reserveAddress);          // Send output to reserve         _token.safeTransfer(reserveAddress, _amount);          uint256 balanceReserveAfter = _token.balanceOf(reserveAddress);          nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddress);     } ```  After this subsequent change, `_outputToken` will need to be casted to `IERC20` on [L386](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L386).  `_transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);`  And no need to cast `_outputToken` anymore on [L357](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L357).  `_transferToReserveAndStore(_outputToken, amountBought - feesAmount, _nftId);`  
# Handle  TomFrench   # Vulnerability details  ## Impact  Potential for a broken deploy of operators which use a storage contract (not in the case of `ZeroExOperator` however)  ## Proof of Concept  `ZeroExOperator` uses a create2 salt of `bytes32("nested.zeroex.operator")` to deploy its storage contract and this salt must be used to recompute this address in future.  It's then important to enforce that both steps use the same salt, however this is not strictly enforced. Currently a change to one must be manually updated in the other, if this was not done then calculation of the storage address would be incorrect.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L15  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L60  This is not an issue in the current case but this is a potential footgun for future operators which use storage.  ## Recommended Mitigation Steps  Place `bytes32("nested.zeroex.operator")` into a constant variable and use this variable instead.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Reduced ease of verifying correctness  ## Proof of Concept  `ZeroExOperator` uses the `Create2` library to deploy `ZeroExOperatorStorage`. `Create2` also exposes a `computeAddress` function which can be used to recalculate the address of `ZeroExOperatorStorage` but `ZeroExOperator` instead uses a homebrew calculation in `storageAddress`.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L55-L65  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/57630d2a6466dff65aa7ca67b3fa23d5e6d1474a/contracts/utils/Create2.sol#L57-L64  The implementation is identical but using standard library code avoids the need for verification and minimises possible mistakes.  ## Recommended Mitigation Steps  Replace `storageAddress` with  ```     function storageAddress(address own) public pure returns (address) {        return Create2.computeAddress(             bytes32("nested.zeroex.operator"),             keccak256(type(ZeroExStorage).creationCode)             own,         );     }  ```  
# Handle  TomFrench   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  In the `receive` function of `FeeSplitter` we check that the address sending ETH is the WETH contract: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L74  As we can safely say that the WETH contract will never send a metatransaction, we can just use msg.sender and avoid the extra gas costs of `_msgSender()`  ## Recommended Mitigation Steps  Replace `_msgSender()` with `msg.sender`  
# Handle  pauliax   # Vulnerability details  ## Impact function "mintWithMetadata" does not need onlyFactory modifier as it will be checked in function "mint" later.   
# Handle  hyh   # Vulnerability details  ## Impact  Array bounds check violation will happen if the function be called with arrays of different lengths.  ## Proof of Concept  Loop is performed by names array, while both arrays are accessed: ``` for (uint256 i = 0; i < names.length; i++) {   if (operators[names[i]] != destinations[i]) { ``` https://github.com/code-423n4/2021-11-nested/blob/main/contracts/OperatorResolver.sol#L27  ## Recommended Mitigation Steps  Add a check: ``` require(names.length == destinations.length, "OperatorResolver::areAddressesImported: Input lengths must match"); ```  
# Handle  pauliax   # Vulnerability details  ## Impact I think it is not necessary to have function _burnNST as a separate private function. It is called only once and has just one LOC so it just incurs in extra gas cost which can be avoided by moving this line to function trigger and getting rid of _burnNST.   
# Handle  pauliax   # Vulnerability details  ## Impact This can be simplified to reduce gas costs by eliminating math operation: ```solidity   // before   require(_accountIndex + 1 <= shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");   // after   require(_accountIndex < shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");  ```  
# Handle  pauliax   # Vulnerability details  ## Impact INestedToken is declared as an abstract contract, yet it contains no function bodies and is located under the interfaces directory, so I think it should be declared as an interface.  ## Recommended Mitigation Steps Consider making INestedToken an interface.  
# Handle  hyh   # Vulnerability details  ```setFactory``` should be named ```addFactory``` as it doesn't set the only factory, but adds to the list of factories  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L133  
# Handle  pauliax   # Vulnerability details  ## Impact NestedRecords contains no removeFactory function so there is no way to revoke a factory in case you no longer want to support it. This function is present in NestedAsset contract so I thought you might want to also have it here.  ## Recommended Mitigation Steps Consider if you are missing removeFactory or is this an intended functionality.   
# Handle  hyh   # Vulnerability details  ## Impact  NFT token operations will fail if wrong reserve is used.  ## Proof of Concept  ```NestedFactory``` ```reserve``` is used in ```addtokens``` and ```withdraw``` function for a given NFT, but the NFT to reserve contract correspondence isn't checked.  addtokens: https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L119  withdraw: https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L241  ## Recommended Mitigation Steps  Add the ```require(nestedRecords.getAssetReserve(_nftId) == address(reserve), "...")``` check in the beginning of the functions.  
# Handle  hyh   # Vulnerability details  ## Impact  Whenever condition of the ```_handleUnderSpending``` function fails function call gas costs are wasted. The cost of checking the condition is paid anyway, while when it doesn't hold the function call costs are avoidable.  ## Proof of Concept  ```_handleUnderSpending``` checks for ```_amountToSpent - _amountSpent > 0```.  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L481  ## Recommended Mitigation Steps  When the check condition is false ```_handleUnderSpending``` shouldn't be called and this way the check with corresponding variables to be placed in caller functions:  _submitInOrders https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L306  _safeSubmitOrder https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L415  
# Handle  0xngndev   # Vulnerability details  ## Impact In `FeeSplitter.sol` by doing a small refactory gas can be saved in case of a revert in the functions: `getAmountDue` and `_releaseToken` . We can swap the order of two lines so we return earlier in case of a bad input, this way we save some gas because the evm would execute less opcodes before reverting.  ## Mitigation steps getAmountDue: Swap line 83 with 84 to avoid computing unnecessary logic. Remove the "else"  and combine it with line 83. Something like this:  ```   function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];     if (_tokenRecords.totalShares == 0) return 0;         uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));         uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /             _tokenRecords.totalShares -             _tokenRecords.released[_account];         return amountDue;     } ``` _releaseToken: move line 252 after the require in line 254. Like this:  ```   function _releaseToken(address _account, IERC20 _token) private returns (uint256) {         uint256 amountToRelease = getAmountDue(_account, _token);         require(amountToRelease != 0, "FeeSplitter: NO_PAYMENT_DUE");         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];          _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;         _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;          return amountToRelease;     } ```   
# Handle  defsec   # Vulnerability details  ## Impact The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  1. Navigate to the following contracts.  "https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L135" "https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L111" "https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L32"  ## Tools Used  Code review  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.    
# Handle  cmichel   # Vulnerability details  The `NestedFactory._handleUnderSpending` function implements a condition as `_amountToSpent - _amountSpent > 0` instead of `_amountToSpent > _amountSpent`. The former reverts if `_amountSpent > _amountToSpent` while the latter doesn't.  It's unclear which behavior is preferred.  ## Recommended Mitigation Steps Think about if `_amountSpent > _amountToSpent` should revert or not. If not, the `if` condition can be rewritten as `_amountSpent > _amountToSpent` which would also save gas.  
# Handle  cmichel   # Vulnerability details  The `NestedFactory.addOperator` function pushes the `operator` even if it already exists in `operators`.  ## Impact When this duplicated operator is removed through a `removeOperator` call, only the first instance is removed. The operator can now still be called which can lead to unexpected behavior.  ## Recommended Mitigation Steps Check if the operator already exists before adding it.  
# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for non-zero values: - `NestedFactory.constructor`: address parameters could be zero or not a contract - `NestedReserve.constructor`: address parameters could be zero or not a contract - `NestedBuybacker.constructor`: address parameters could be zero or not a contract  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.   
# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/FeeSplitter.sol#L152-L162  ```solidity=152 function sendFeesWithRoyalties(     address _royaltiesTarget,     IERC20 _token,     uint256 _amount ) external nonReentrant {     require(_royaltiesTarget != address(0), "FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS");      _sendFees(_token, _amount, totalWeights);     _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token)); } ```  ### Recommendation  Change to:  ```solidity=152 function sendFeesWithRoyalties(     address _royaltiesTarget,     IERC20 _token,     uint256 _amount ) external nonReentrant {     require(_royaltiesTarget != address(0), "FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS");      uint256 _totalWeights = totalWeights;      _sendFees(_token, _amount, _totalWeights);     _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, _totalWeights), address(_token)); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L553-L559  ```solidity=553 /// @dev Calculate the fees for a specific user and amount (1%) /// @param _user The user address /// @param _amount The amount /// @return The fees amount function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {     return _amount / 100; } ```  The function `_calculateFees()` is a rather simple function, replacing it with inline expression `_amount / 100` can save some gas.  
# Handle  WatchPug   # Vulnerability details  `releaseToken()` has `nonReentrant` modifier, making `releaseTokens()` to set storage `_status` multiple times in the for loop.  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/FeeSplitter.sol#L116-L129  ```solidity=116 function releaseToken(IERC20 _token) public nonReentrant {     uint256 amount = _releaseToken(_msgSender(), _token);     _token.safeTransfer(_msgSender(), amount);     emit PaymentReleased(_msgSender(), address(_token), amount); }  /// @notice Call releaseToken() for multiple tokens /// @param _tokens ERC20 tokens to release function releaseTokens(IERC20[] memory _tokens) external {     for (uint256 i = 0; i < _tokens.length; i++) {         releaseToken(_tokens[i]);     } } ```  ### Recommendation  Change to:  ```solidity=116 function releaseToken(IERC20 _token) public nonReentrant {     _releaseTokenAndTransfer(_token); }  /// @notice Call releaseToken() for multiple tokens /// @param _tokens ERC20 tokens to release function releaseTokens(IERC20[] memory _tokens) external {     for (uint256 i = 0; i < _tokens.length; i++) {         _releaseTokenAndTransfer(_tokens[i]);     } }  function _releaseTokenAndTransfer(IERC20 _token) private {     uint256 amount = _releaseToken(_msgSender(), _token);     _token.safeTransfer(_msgSender(), amount);     emit PaymentReleased(_msgSender(), address(_token), amount); } ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedRecords.sol#L56-L79  ```solidity=56{67} /// @notice Add a record for NFT data into our mappings /// @param _nftId The id of the NFT /// @param _token The address of the token /// @param _amount The amount of tokens bought /// @param _reserve The address of the reserve function createRecord(     uint256 _nftId,     address _token,     uint256 _amount,     address _reserve ) public onlyFactory {     require(records[_nftId].tokens.length < maxHoldingsCount, "NestedRecords: TOO_MANY_ORDERS");     require(         _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)),         "NestedRecords: INVALID_RESERVE"     );      Holding memory holding = records[_nftId].holdings[_token];     require(!holding.isActive, "NestedRecords: HOLDING_EXISTS");      records[_nftId].holdings[_token] = Holding({ token: _token, amount: _amount, isActive: true });     records[_nftId].tokens.push(_token);     records[_nftId].reserve = _reserve; } ```  The error message "NestedRecords: TOO_MANY_ORDERS" should be changed to "NestedRecords: TOO_MANY_TOKENS".  
# Handle  GreyArt   # Vulnerability details  ## Impact  A user that mistakenly calls either `create()` or `addToken()` with WETH (or another ERC20) as the input token, but includes native ETH with the function call will have his native ETH permanently locked in the contract.  ## Recommended Mitigation Steps  It is best to ensure that `msg.value = 0` in `_transferInputTokens()` for the scenario mentioned above.  ```jsx } else if (address(_inputToken) == ETH) {  ... } else {  require(msg.value == 0, "NestedFactory::_transferInputTokens: ETH sent for non-ETH transfer");   _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  `_submitOutOrders()` is invoked by 2 functions `sellTokensToNft()` and `sellTokensToWallet()`, both of which specify the `_fromReserve` parameter to be `true`. This parameter is therefore unneeded.  ## Recommended Mitigation Steps  ```jsx function _submitOutOrders(   uint256 _nftId,   IERC20 _outputToken,   uint256[] memory _inputTokenAmounts,   Order[] calldata _orders,   bool _reserved ) private returns (uint256 feesAmount, uint256 amountBought) {  ...    IERC20 _inputToken = _transferInputTokens(     _nftId,     IERC20(_orders[i].token),     _inputTokenAmounts[i],     true  ); } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  `createRecord()` is only invoked by `store()`. Its visibility can therefore be made internal / private.  ## Recommended Mitigation Steps  ```jsx function createRecord(   uint256 _nftId,   address _token,   uint256 _amount,  address _reserve ) internal onlyFactory {...} ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  The `transferFromFactory()` function is missing the `valid(address(_token))` modifier that is present in the `transfer()` and `withdraw()` functions.  It is in our opinion that these sanity checks on the token address are redundant, because the transaction will revert anyway in the SafeERC20 library.  ## Recommended Mitigation Steps  Either add in the modifier check for the `transferFromFactory()` function. Alternatively, remove them from all the functions as a gas optimization.  
# Handle  GreyArt   # Vulnerability details  ## Impact  The `name` and `destination` local variables in the `rebuildCache` function are declared multiple times within the loop. It'll be cheaper to declare them once outside the loop and reuse the variables inside.   ## Recommended Mitigation Steps  ```jsx bytes32 name; address destination; // The resolver must call this function whenever it updates its state for (uint256 i = 0; i < requiredAddresses.length; i++) {  name = requiredAddresses[i];  // Note: can only be invoked once the resolver has all the targets needed added  destination = resolver.getAddress(name);   ... } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  It is unnecessary to store the `token` variable in the `Holding` struct because the token is used as the key to access the `Holding` struct.  ## Recommended Mitigation Steps  Remove the `token` variable in the `Holding` struct.  ```jsx /// @dev Info about assets stored in reserves struct Holding {   uint256 amount;   bool isActive; } ```  
# Handle  GreyArt   # Vulnerability details  ## Impact  The `importOperators()` declares the `name` and `destination` variables multiple times. It'll be cheaper to declare them once outside the loop and reuse the variables inside.   ## Recommended Mitigation Steps  ```jsx bytes32 name; address destination;  for (uint256 i = 0; i < names.length; i++) {  name = names[i];  destination = destinations[i];   operators[name] = destination;   emit OperatorImported(name, destination); } ```  
# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedBuybacker.sol#L15  There is only NST.safeTransfer used, and NST is INestedToken interface. SafeERC20 is not used for IERC20 interface.  ## Tools Used  ## Recommended Mitigation Steps Remove Line 79  
# Handle  xYrYuYx   # Vulnerability details  ## Impact `calldata` use less gas than `memory` in function arguments  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L124  ## Tools Used Manual  ## Recommended Mitigation Steps Use `calldata` keyword in function argument instead of `memory`  
# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  Unused named return: https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L69  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named return  
# Handle  ye0lde   # Vulnerability details  ## Impact  The functions below fail to perform input validation on arrays to verify the lengths match.  A mismatch could lead to an exception or undefined behavior.  ## Proof of Concept  names, destinations https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/OperatorResolver.sol#L27-L39  _inputTokenAmounts, orders https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L321-L337  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add input validation to check that the length of both arrays match.  
# Handle  pants   # Vulnerability details  MixinOperatorResolver.rebuildCache (addressCache[name]), isResolverCached (addressCache[name])  You can cache the value after the first read into a local variable to save the other SLOAD and also the "out of bounds" check.  
# Handle  pants   # Vulnerability details  NestedRecords line 22 - you can save storage by reordering Holding struct fields in the following way:  original:     struct Holding {         address token;         uint256 amount;         bool isActive;     }  change to:      struct Holding {         uint256 amount;         address token;         bool isActive;     }   
# Handle  palina   # Vulnerability details  ## Impact Function performing important changes to contract state should emit events to facilitate monitoring of the protocol operation (e.g., NestedRecords::setReserve(), deleteAsset(), removeNFT()).  ## Proof of Concept setReserve(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L201 deleteAsset(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L207 removeNFT(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L221  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider emitting events on the discussed changes. E.g.,  event ReserveUpdated(address newReserve); ... function setReserve(...) {     emit ReserveUpdated(_nextReserve); }  
# Handle  elprofesor   # Vulnerability details  ## Impact The use of `_token.transfer()` in `NestedFactory.unlockTokens` may have unintended consequences. ERC20 tokens can implement contra to the EIP20 spec (USDT for instance returns VOID). This may result in tokens that return anything from false to void and these return values would not throw on failure. As a result transfer's in `unlockTokens` may not appropriately throw on failure.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L271-L273  ## Recommended Mitigation Steps We recommend using OpenZeppelinâ€™s SafeERC20 versions with the `safeTransfer` function that handles the return value check as well as non-standard-compliant tokens.  
# Handle  palina   # Vulnerability details  ## Impact The Nestedbuybacker::triggerForToken() function does not check the return value of the `ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData);` call, which returns a boolean. Even if the swap in the fillQuote() is not successful and no NST was bought, the function proceeds with the trigger() function execution. trigger() also does not check if the `balance` variable (indicating the amount of NST bought) is positive, although there is (at best) no point in executing the rest of the function if there's no NST in the contract.  ## Proof of Concept Unchecked result of the fillQuote() call: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L101 Missing validation in trigger(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L108  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add a return value check in the triggerForToken() function: `bool success = ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData); require(success);` and/or a `balance` value validation in trigger(): `uint256 balance = NST.balanceOf(address(this)); require(balance > 0);`  
# Handle  palina   # Vulnerability details  ## Impact Functions that are only called from outside the contract can be declared external instead of public since they are more gas-efficient.  ## Proof of Concept NestedBuybacker::setBurnPart(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L81, MixinOperatorResolver::rebuildCache(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/MixinOperatorResolver.sol#L29  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change the 'public' visibility modifier into 'external'.  
# Handle  pmerkleplant   # Vulnerability details  ## Impact Function `getAmountDue` in `FeeSplitter.sol` defines the variable  `totalReceived` in [line 83](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L83) eventhough it is already known if the variable is even necessary.  The variable is uneccessary if `_tokenRecords.totalShares == 0`. Not declaring it, if not necessary, saves gas.  ## Recommended Mitigation Steps Rewrite the function to something like: ``` TokenRecords storage _tokenRecords = tokenRecords[address(_token)]; if (_tokenRecords.totalShares == 0) return 0; uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this)); // Rest same as before ```  
# Handle  pmerkleplant   # Vulnerability details  Function `triggerForToken` in `NestedBuybacker.sol` makes a `balanceOf` call on the `_sellToken`, see [line 100](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedBuybacker.sol#L100).  However, the result of the call is never used.  It would save gas to remove the unnecessary call and variable declaration.  
# Handle  loop   # Vulnerability details  The `removeFactory` has an unnecessary `==true` comparison in its require statement. Since require already checks if the condition is `true`, there is no need for it to be compared.  ## Impact Removing `== true` saves a tiny amount of gas if `removeFactory` is called.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L142  
# Handle  Meta0xNull   # Vulnerability details  ## Impact _sendFees() repeat Read Storage variable shareholders. Every Storage read is expensive.   ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L227-L232  ## Tools Used Manual Review  ## Recommended Mitigation Steps Read the values from storage once, cache them in local variables and then read them again using the local variables. For example:  Shareholder[] shareholders_temp = shareholders;         for (uint256 i = 0; i < shareholders_temp.length; i++) {             _addShares(                 shareholders_temp[i].account,                 _computeShareCount(_amount, shareholders_temp[i].weight, _totalWeights),                 address(_token)             );  
# Handle  PierrickGT   # Vulnerability details  ## Impact In [setMaxAllowance](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/libraries/ExchangeHelpers.sol#L34), `safeApprove` is used to increase allowance. As stated in the following Pull Request, `safeApprove` has been deprecated in favor of `safeIncreaseAllowance` and `safeDecreaseAllowance`.  https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2268/files  This is because `safeApprove` shouldn't check for allowance, as explained in the issue below:  https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219  `approve` is actually vulnerable to a sandwich attack as explained in the following document and this check for allowance doesn't actually avoid it.  https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit  ## Proof of Concept `safeIncreaseAllowance` should be used to increase allowance and `safeDecreaseAllowance` to decrease allowance to 0. We can also gain in code clarity by refactoring the `if else` statement and calling `_token.safeIncreaseAllowance(_spender, type(uint256).max);` only once.  ## Recommended Mitigation Steps The following changes are recommended.  ``` function setMaxAllowance(IERC20 _token, address _spender) internal {     uint256 _currentAllowance = _token.allowance(address(this), _spender);      if (_currentAllowance != type(uint256).max) {         // Decrease to 0 first for tokens mitigating the race condition         _token.safeDecreaseAllowance(_spender, _currentAllowance);     }      _token.safeIncreaseAllowance(_spender, type(uint256).max); } ```  
# Handle  PierrickGT   # Vulnerability details  ## Impact In [deleteAsset](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedRecords.sol#L213), `tokens` is declared once in the function and then a second time in the function `freeToken`.  ## Proof of Concept The `freeToken` function being used only in `deleteAsset`, the code from this function can be moved to `deleteAsset` and the function removed. This way, we don't have to pass `tokens` to the `freeToken` function and we avoid declaring it here a second time.  ## Recommended Mitigation Steps The following change is recommended.  ``` function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory {     address[] storage tokens = records[_nftId].tokens;     address token = tokens[_tokenIndex];     Holding memory holding = records[_nftId].holdings[token];      require(holding.isActive, "NestedRecords: HOLDING_INACTIVE");      delete records[_nftId].holdings[token];     tokens[_tokenIndex] = tokens[tokens.length - 1];     tokens.pop(); } ```  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact OperatorHelpers.sol: function decodeDataAndRequire state mutability can be restricted to pure We don't read any storage variables, only use the arguments therefore, it can be restricted to pure.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/libraries/OperatorHelpers.sol#L45  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps set function state mutability to pure  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Empty/useless file OwnableOperator.sol is against best practices / code housekeeping.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/operators/OwnableOperator.sol  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Delete file  
# Handle  GiveMeTestEther   # Vulnerability details   ## Impact FeeSplitter.so: totalWeights is the sum of shareholder weights and royaltiesWeight, therefore a subtraction of a shareholder weight or royaltiesWeight can be done unchecked because we can't underflow and save gas.   ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L143  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L169  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L143 can be rewritten as:      function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {         _sendFees(_token, _amount, unchecked {totalWeights - royaltiesWeight});     }  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L169 can be written as unchecked { _totalWeights -= shareholders[_accountIndex].weight; }  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  The pattern of adding/subtracting a variable to/from another value is sometimes written as x += y; and sometimes as x = x + y; (x -= y; and sometimes x = x - y;) The shorter version x += y;/x -= y; increases readability.  ## Proof of Concept  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L241  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L256  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L229  and possible others  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps use the x += y; / x -= y; pattern   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Comment in FeeSplitter  "/// @dev Emitted when a payment is released" for the PaymentReceived event should say "received" instead of "released".  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L25  ## Tools Used Manal Analysis  ## Recommended Mitigation Steps Change line to: /// @dev Emitted when a payment is received  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact The storage variable totalWeights can be set 0 by onlyOwner and therefore we would have a division by zero in the function "_computeShareCount" https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L268  ## Proof of Concept -Assumption we have one shareholder with weight S1 > 0 and royaltiesWeight > 0. -With the function updateShareholder the onlyOwner sets the S1 of our shareholder to 0.  - updateShareholder: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L166  - require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO") condition is met because _totalWeights is the sum of all shareholder weights + royaltiesWeight, and royaltiesWeight is > 0 - With the function setRoyaltiesWeight the onlyOwner sets the royaltiesWeight to 0.  - setRoyaltiesWeight: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94 - => setRoyaltiesWeight is 0 and totalWeights is 0   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps At the end of the function setRoyaltiesWeight check for 0 weight with a require: require(totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO"); https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94  
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Functions that are only executable by privileged users (e.g. onlyOwner) and have an impact (e.g. financial, trust) on other users should emit events.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L103 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L166  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L74 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L79 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L271  and possible other  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Emit events for privileged actions  
# Handle  0xngndev   # Vulnerability details  ## Impact Found the same small typo at NestedBuybacker.sol#constructor::line 54 and at NestedBuybacker.sol#constructor::line 87.  The error messages says: "NestedBuybacker::constructor: Burn part to high" It should be "too high".  
# Handle  TomFrench   # Vulnerability details  ## Impact  Deployment + runtime gas cost increase  ## Proof of Concept  On each time we calculate the address of `ZeroExStorage` we hash the entirety of the creation code for `ZeroExStorage`. This means that not only do we have to perform a large hash operation over the entire creation bytecode of this contract, we need to store all of this bytecode in the `ZeroExOperator`'s deployed bytecode.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L61  This hash could be calculated once at deployment and then have this used cheaply each time, reducing both deployment and runtime costs.  ## Recommended Mitigation Steps  Store `keccak256(type(ZeroExStorage).creationCode)` in an `immutable` (not `constant` as this still results in hashing being applied each time) variable.  
# Handle  TomFrench   # Vulnerability details  ## Impact  NFTs can't be managed from future versions of `NestedFactory` without manual migration or removing support for the previous `NestedFactory`.  ## Proof of Concept  From discussion with NestedFinance team members, it's desired that multiple `NestedFactories` can interact with the NFT portfolios and be interoperable into the future.  NestedFinance has two singleton contracts which store the state of NFTs `NestedAsset` and `NestedRecords`  `NestedAsset` allows multiple factories to interact with a given NFT ([asset](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedAsset.sol#L18-L19)) `NestedRecords` lists a single reserve which holds an NFT's assets ([records](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L32))  This is fine however `NestedFactory` and `NestedReserve` are linked together 1:1 ([factory](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L31), [reserve](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L14))  This means that each NFT can only be managed by a single factory as calls from other factories to the relevant reserve will revert due to insufficient permissions. Should I want to update to use the newest factory I would have to manually migrate my portfolio across.  ## Recommended Mitigation Steps  Allow `NestedReserve` to have multiple factories connect to it. Make sure to have the `NestedReserve` secure from reentrancy attacks utilising multiple factories in parallel.   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  Functions in the same contract with the same access modifier (e.g. onlyOwner or onlyFactory) have have a mix of public and external visibility.  Set their visibility to external to save gas.  Affected contracts (see ): - NestedRecords - NestedFactory - FeeSplitter - NestedAsset   ## Tools Used Visial Studio Code + Solidity Visual Developer (Plugin)  ## Recommended Mitigation Steps  Set the visibility to external to save gas.   Extract from Solidity Visual Developer (Plugin) of the Contracts and visibility:  |  Contract  |         Type        |       Bases      |                  |                 | |:----------:|:-------------------:|:----------------:|:----------------:|:---------------:| |     â””      |  **Function Name**  |  **Visibility**  |  **Mutability**  |  **Modifiers**  | |||||| | **NestedRecords** | Implementation | Ownable ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  |NOâ—ï¸ | | â”” | createRecord | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | updateHoldingAmount | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | getAssetTokens | Public â—ï¸ |   |NOâ—ï¸ | | â”” | freeHolding | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | store | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | getAssetHolding | External â—ï¸ |   |NOâ—ï¸ | | â”” | setFactory | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | updateLockTimestamp | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | setMaxHoldingsCount | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | getAssetReserve | External â—ï¸ |   |NOâ—ï¸ | | â”” | getAssetTokensLength | External â—ï¸ |   |NOâ—ï¸ | | â”” | getLockTimestamp | External â—ï¸ |   |NOâ—ï¸ | | â”” | setReserve | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | removeNFT | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | deleteAsset | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | freeToken | Private ğŸ” | ğŸ›‘  | | |||||| | **NestedFactory** | Implementation | INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  | MixinOperatorResolver | | â”” | <Receive Ether> | External â—ï¸ |  ğŸ’µ |NOâ—ï¸ | | â”” | resolverAddressesRequired | Public â—ï¸ |   |NOâ—ï¸ | | â”” | addOperator | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | removeOperator | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | setReserve | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | setFeeSplitter | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | create | External â—ï¸ |  ğŸ’µ | nonReentrant | | â”” | addTokens | External â—ï¸ |  ğŸ’µ | nonReentrant onlyTokenOwner | | â”” | swapTokenForTokens | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | sellTokensToNft | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | sellTokensToWallet | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | destroy | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | withdraw | External â—ï¸ | ğŸ›‘  | nonReentrant onlyTokenOwner isUnlocked | | â”” | increaseLockTimestamp | External â—ï¸ | ğŸ›‘  | onlyTokenOwner | | â”” | unlockTokens | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | _submitInOrders | Private ğŸ” | ğŸ›‘  | | | â”” | _submitOutOrders | Private ğŸ” | ğŸ›‘  | | | â”” | _submitOrder | Private ğŸ” | ğŸ›‘  | | | â”” | _safeSubmitOrder | Private ğŸ” | ğŸ›‘  | | | â”” | _transferToReserveAndStore | Private ğŸ” | ğŸ›‘  | | | â”” | _transferInputTokens | Private ğŸ” | ğŸ›‘  | | | â”” | _handleUnderSpending | Private ğŸ” | ğŸ›‘  | | | â”” | _transferFeeWithRoyalty | Private ğŸ” | ğŸ›‘  | | | â”” | _decreaseHoldingAmount | Private ğŸ” | ğŸ›‘  | | | â”” | _safeTransferAndUnwrap | Private ğŸ” | ğŸ›‘  | | | â”” | _safeTransferWithFees | Private ğŸ” | ğŸ›‘  | | | â”” | _calculateFees | Private ğŸ” |   | | |||||| | **FeeSplitter** | Implementation | Ownable, ReentrancyGuard ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  |NOâ—ï¸ | | â”” | <Receive Ether> | External â—ï¸ |  ğŸ’µ |NOâ—ï¸ | | â”” | getAmountDue | Public â—ï¸ |   |NOâ—ï¸ | | â”” | setRoyaltiesWeight | Public â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | setShareholders | Public â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | releaseToken | Public â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | releaseTokens | External â—ï¸ | ğŸ›‘  |NOâ—ï¸ | | â”” | releaseETH | External â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | sendFees | External â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | sendFeesWithRoyalties | External â—ï¸ | ğŸ›‘  | nonReentrant | | â”” | updateShareholder | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | totalShares | External â—ï¸ |   |NOâ—ï¸ | | â”” | totalReleased | External â—ï¸ |   |NOâ—ï¸ | | â”” | shares | External â—ï¸ |   |NOâ—ï¸ | | â”” | released | External â—ï¸ |   |NOâ—ï¸ | | â”” | findShareholder | External â—ï¸ |   |NOâ—ï¸ | | â”” | _sendFees | Private ğŸ” | ğŸ›‘  | | | â”” | _addShares | Private ğŸ” | ğŸ›‘  | | | â”” | _releaseToken | Private ğŸ” | ğŸ›‘  | | | â”” | _addShareholder | Private ğŸ” | ğŸ›‘  | | | â”” | _computeShareCount | Private ğŸ” |   | | |||||| | **NestedAsset** | Implementation | ERC721Enumerable, Ownable ||| | â”” | <Constructor> | Public â—ï¸ | ğŸ›‘  | ERC721 | | â”” | tokenURI | Public â—ï¸ |   |NOâ—ï¸ | | â”” | originalOwner | Public â—ï¸ |   |NOâ—ï¸ | | â”” | mint | Public â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | mintWithMetadata | External â—ï¸ | ğŸ›‘  | onlyFactory | | â”” | backfillTokenURI | External â—ï¸ | ğŸ›‘  | onlyFactory onlyTokenOwner | | â”” | burn | External â—ï¸ | ğŸ›‘  | onlyFactory onlyTokenOwner | | â”” | setFactory | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | removeFactory | External â—ï¸ | ğŸ›‘  | onlyOwner | | â”” | _setTokenURI | Internal ğŸ”’ | ğŸ›‘  | |   Legend  |  Symbol  |  Meaning  | |:--------:|-----------| |    ğŸ›‘    | Function can modify state | |    ğŸ’µ    | Function is payable |   
# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Calculation of the weights in the function "setRoyaltiesWeight" of FeeSplitter.sol (row 95) can be done more gas efficient.      function setRoyaltiesWeight(uint256 _weight) public onlyOwner {         totalWeights -= royaltiesWeight;         royaltiesWeight = _weight;         totalWeights += _weight;     }  can be rewritten as      function setRoyaltiesWeight(uint256 _weight) public onlyOwner {         totalWeights = totalWeights - royaltiesWeight + _weight;         royaltiesWeight = _weight;     }  => write only once to the storage of totalWeights.  ## Proof of Concept  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps see above  
# Handle  TomFrench   # Vulnerability details  ## Impact  `NestedReserve.transferFromFactory` is unused and so increases deployment costs for no gain  ## Proof of Concept  `NestedReserve` has a `transferFromFactory` which can be seen not to be used in the codebase (and in the case the `NestedFactory` needs to send tokens to the reserve it can do so directly.)  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L55-L60  ## Recommended Mitigation Steps  Remove this function.  
# Handle  0xngndev   # Vulnerability details  ## Impact Running a quick contract size check in the NestedFactory contract, I noticed it sat at 27590 bytes, exceeding the allowed 24576 bytes to deploy on mainnet. I removed the require messages alone in that contract and found the contract size dropped to 23172 bytes. Considering you are using large require messages in all the codebase, I would suggest considering a change of approach as to how you expose the error messages. I'll add my suggestions below.  ## Recommended Mitigation Steps Two ways: 1) Shorten the length of the string messages to just the error instead of including the contract and the function. UniswapV3 repo may be a good example of how to do this. You can always explain errors further in the natspec, or in your documentation (you can make a common errors section). 2) Change require statements for if (...) revert CustomError(). Per solidity docs:  "Using a custom error instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs."  Link: https://docs.soliditylang.org/en/v0.8.10/control-structures.html?highlight=error#revert  ## Tools Used dapptools make size  
# Handle  0x0x0x   # Vulnerability details  ## Explanation  `updateShareholder` in `FeeSplitter.sol` can be implemented more efficiently. The updated version consumes less gas and also has the second `require` statement earlier, which reduces  the gas cost in case the statement of second `require` is not fullfilled.   `FeeSplitter.sol` : L166-174: ```     function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {         require(_accountIndex + 1 <= shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");         uint256 _totalWeights = totalWeights;         _totalWeights -= shareholders[_accountIndex].weight;         shareholders[_accountIndex].weight = _weight;         _totalWeights += _weight;         require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO");         totalWeights = _totalWeights;     } ``` can be replaced with: ```     function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {         require(_accountIndex + 1 <= shareholders.length, "FeeSplitter: INVALID_ACCOUNT_INDEX");         totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;         require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO");         shareholders[_accountIndex].weight = _weight;     } ``` ## Tools Used  Manual analysis  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept For unsigned integers, it is cheaper to check ` != 0` than ` > 0`. Both provide the same logic. ## Occurences ``` contracts/FeeSplitter.sol:105:        require(_accounts.length > 0 && _accounts.length == _weights.length, "FeeSplitter: ARRAY_LENGTHS_ERR"); contracts/FeeSplitter.sol:172:        require(_totalWeights > 0, "FeeSplitter: TOTAL_WEIGHTS_ZERO"); contracts/FeeSplitter.sol:263:        require(_weight > 0, "FeeSplitter: ZERO_WEIGHT"); contracts/NestedBuybacker.sol:97:        if (feeSplitter.getAmountDue(address(this), _sellToken) > 0) { contracts/NestedFactory.sol:69:        require(i > 0, "NestedFactory::removeOperator: Cant remove non-existent operator"); contracts/NestedFactory.sol:94:        require(_orders.length > 0, "NestedFactory::create: Missing orders"); contracts/NestedFactory.sol:110:        require(_orders.length > 0, "NestedFactory::addTokens: Missing orders"); contracts/NestedFactory.sol:124:        require(_orders.length > 0, "NestedFactory::swapTokenForTokens: Missing orders"); contracts/NestedFactory.sol:143:        require(_orders.length > 0, "NestedFactory::sellTokensToNft: Missing orders"); contracts/NestedFactory.sol:163:        require(_orders.length > 0, "NestedFactory::sellTokensToWallet: Missing orders"); contracts/NestedFactory.sol:194:        require(_orders.length > 0, "NestedFactory::destroy: Missing orders"); contracts/NestedFactory.sol:333:            if (_inputTokenAmounts[i] - amountSpent > 0) { contracts/NestedFactory.sol:467:        if (_amountToSpent - _amountSpent > 0) { contracts/NestedRecords.sol:171:        require(_maxHoldingsCount > 0, "NestedRecords: INVALID_MAX_HOLDINGS"); contracts/operators/Flat/FlatOperator.sol:18:        require(amount > 0, "FlatOperator::commitAndRevert: Amount must be greater than zero"); contracts/operators/ZeroEx/ZeroExOperator.sol:42:        assert(amountBought > 0); contracts/operators/ZeroEx/ZeroExOperator.sol:43:        assert(amountSold > 0); ```  
# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept Example: ``` for (uint i = 0; i < arr.length; i++) { //Operations not effecting the length of the array. } ``` Loading length of array costs gas. Therefore, the length should be cached, if the length of the array doesn't change inside the loop. Recommended implementation: ``` uint length = arr.length; for (uint i = 0; i < length; i++) { //Operations not effecting the length of the array. } ``` By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Occurences ``` contracts/FeeSplitter.sol:108:        for (uint256 i = 0; i < _accounts.length; i++) { contracts/FeeSplitter.sol:125:        for (uint256 i = 0; i < _tokens.length; i++) { contracts/FeeSplitter.sol:210:        for (uint256 i = 0; i < shareholders.length; i++) { contracts/FeeSplitter.sol:227:        for (uint256 i = 0; i < shareholders.length; i++) { contracts/MixinOperatorResolver.sol:32:        for (uint256 i = 0; i < requiredAddresses.length; i++) { contracts/MixinOperatorResolver.sol:48:        for (uint256 i = 0; i < requiredAddresses.length; i++) { contracts/NestedFactory.sol:203:        for (uint256 i = 0; i < tokens.length; i++) { contracts/NestedFactory.sol:280:        for (uint256 i = 0; i < _orders.length; i++) { contracts/NestedFactory.sol:316:        for (uint256 i = 0; i < _orders.length; i++) { contracts/OperatorResolver.sol:33:        for (uint256 i = 0; i < names.length; i++) { contracts/OperatorResolver.sol:45:        for (uint256 i = 0; i < names.length; i++) { contracts/OperatorResolver.sol:56:        for (uint256 i = 0; i < destinations.length; i++) { ```  
# Handle  PierrickGT   # Vulnerability details  ## Impact In [_transferToReserveAndStore](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L426), `_token` is casted 3 times to `IERC20` and `reserve` is loaded and casted to `address` 4 times. We can simplify the function and save on gas.  ## Proof of Concept `_token` should be passed to the function as an `IERC20`, this way we avoid to cast it 3 times. `reserve` should be stored in a variable to avoid 3 unnecessary sloads and casting.  ## Recommended Mitigation Steps The following changes are recommended.  ```     function _transferToReserveAndStore(         IERC20 _token,         uint256 _amount,         uint256 _nftId     ) private {         address reserveAddress = address(reserve);         uint256 balanceReserveBefore = _token.balanceOf(reserveAddress);          // Send output to reserve         _token.safeTransfer(reserveAddress, _amount);          uint256 balanceReserveAfter = _token.balanceOf(reserveAddress);          nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddress);     } ```  After this subsequent change, `_outputToken` will need to be casted to `IERC20` on [L386](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L386).  `_transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);`  And no need to cast `_outputToken` anymore on [L357](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L357).  `_transferToReserveAndStore(_outputToken, amountBought - feesAmount, _nftId);`  
# Handle  TomFrench   # Vulnerability details  ## Impact  Potential for a broken deploy of operators which use a storage contract (not in the case of `ZeroExOperator` however)  ## Proof of Concept  `ZeroExOperator` uses a create2 salt of `bytes32("nested.zeroex.operator")` to deploy its storage contract and this salt must be used to recompute this address in future.  It's then important to enforce that both steps use the same salt, however this is not strictly enforced. Currently a change to one must be manually updated in the other, if this was not done then calculation of the storage address would be incorrect.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L15  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L60  This is not an issue in the current case but this is a potential footgun for future operators which use storage.  ## Recommended Mitigation Steps  Place `bytes32("nested.zeroex.operator")` into a constant variable and use this variable instead.  
# Handle  TomFrench   # Vulnerability details  ## Impact  Reduced ease of verifying correctness  ## Proof of Concept  `ZeroExOperator` uses the `Create2` library to deploy `ZeroExOperatorStorage`. `Create2` also exposes a `computeAddress` function which can be used to recalculate the address of `ZeroExOperatorStorage` but `ZeroExOperator` instead uses a homebrew calculation in `storageAddress`.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L55-L65  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/57630d2a6466dff65aa7ca67b3fa23d5e6d1474a/contracts/utils/Create2.sol#L57-L64  The implementation is identical but using standard library code avoids the need for verification and minimises possible mistakes.  ## Recommended Mitigation Steps  Replace `storageAddress` with  ```     function storageAddress(address own) public pure returns (address) {        return Create2.computeAddress(             bytes32("nested.zeroex.operator"),             keccak256(type(ZeroExStorage).creationCode)             own,         );     }  ```  
# Handle  TomFrench   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  In the `receive` function of `FeeSplitter` we check that the address sending ETH is the WETH contract: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L74  As we can safely say that the WETH contract will never send a metatransaction, we can just use msg.sender and avoid the extra gas costs of `_msgSender()`  ## Recommended Mitigation Steps  Replace `_msgSender()` with `msg.sender`  
