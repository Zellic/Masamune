# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-periphery.sol#L522-L526 https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-periphery.sol#L198-L217   # Vulnerability details  # The LP pair underlying price quote could be manipulated   ## Impact  The underlying price for LP pool pair can be manipulated. This kind of price mainpulation happened before, can be found here: [Warp Fincance event](https://rekt.news/warp-finance-rekt/).  Whick may lead to the exploit of the pool by a malicious user.  ## Proof of Concept  file: lending-market-v2/contracts/Stableswap/BaseV1-periphery.sol 522-526， 198-217: ```             uint price0 = (token0 != USDC) ? IBaseV1Pair(pairFor(USDC, token0, stable0)).quote(token0, 1, 8) : 1;             uint price1 = (token1 != USDC) ? IBaseV1Pair(pairFor(USDC, token1, stable1)).quote(token1, 1, 8) : 1;             // how much of each asset is 1 LP token redeemable for             (uint amt0, uint amt1) = quoteRemoveLiquidity(token0, token1, stablePair, 1);             price = amt0 * price0 + amt1 * price1;       function quoteRemoveLiquidity(         address tokenA,         address tokenB,         bool stable,         uint liquidity     ) public view returns (uint amountA, uint amountB) {         // create the pair if it doesn"t exist yet         address _pair = IBaseV1Factory(factory).getPair(tokenA, tokenB, stable);          if (_pair == address(0)) {             return (0,0);         }          (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);         uint _totalSupply = erc20(_pair).totalSupply();          amountA = liquidity * reserveA / _totalSupply; // using balances ensures pro-rata distribution         amountB = liquidity * reserveB / _totalSupply; // using balances ensures pro-rata distribution      } ```  The price of the LP pair is determined by the TVL of the pool, given by: `amt0 * price0 + amt1 * price1`. However, when a malicious user dumps large amount of any token into the pool, the whole TVL will be significantly increased, which leads to inproper calculation of the price.   ## Tools Used mannual analysis  ## Recommended Mitigation Steps  A differenct approach to calculate the LP price can be found [here](https://cmichel.io/pricing-lp-tokens/).   
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/NoteInterest.sol#L145-L147   # Vulnerability details  ## Impact When casting to ``int`` from ``uint``, the overflow might happen.  ## Proof of Concept https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/NoteInterest.sol#L145-L147   ```             uint twapMantissa = oracle.getUnderlyingPrice(cNote); // returns price as mantissa             //uint ir = (1 - twapMantissa).mul(adjusterCoefficient).add(baseRatePerYear);             int diff = BASE - int(twapMantissa); //possible annoyance if 1e18 - twapMantissa > 2**255, differ ```  ``int(twapMantissa)`` can overflow depending on the value of ``uint twapMantissa``. Even if this is not expected, handling this case should be good.  ## Tools Used Static analysis  ## Recommended Mitigation Steps Consider using the logic of ``toInt256`` provided by OpenZeppelin.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol#L1130-L1134  
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/Stableswap/BaseV1-periphery.sol#L489   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Underlying asset price oracle for CToken in BaseV1-periphery is inaccuarte  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ```     function getUnderlyingPrice(CToken ctoken) external override view returns(uint price) {         IBaseV1Pair pair;         uint8 stable;         bool stablePair;         address underlying;          if (compareStrings(ctoken.symbol(), "cCANTO")) {             stable = 0;             underlying = address(wcanto);         }          //set price statically to 1 when the Comptroller is retrieving Price         else if (compareStrings(ctoken.symbol(), "cNOTE") && msg.sender == Comptroller) {             return 1; // Note price is fixed to 1         } ```  we should not be return 1. 1 is 1 wei. we should be 10 ** 18  ## Tools Used VIM  ## Recommended Mitigation Steps  we can return 10 ** 18  
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-core.sol#L72   # Vulnerability details  ## Impact TWAP oracle easily manipulated  ## Proof of Concept periodSize is set to 0 meaning that the oracle will take a new observation every single block, which would allow an attacker to easily flood the TWAP oracle and manipulate the price  ## Tools Used  ## Recommended Mitigation Steps Increase periodSize to be greater than 0, 1800 is typically standard  
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CErc20Delegator.sol#L237 https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CErc20Delegator.sol#L246   # Vulnerability details  ## Impact  When using CToken implementation with CErc20Delegator, the functions `borrowRatePerBlock` and `supplyRatePerBlock` will revert when the underlying functions try to update some states.  ## Detail  The v1 of [borrowRatePerBlock](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CToken.sol#L208) and [supplyRatePerBlock](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CToken.sol#L216) were view functions, but they are not anymore. The `CErc20Delegator` is still using `delegateToViewImplementation` for those functions. Those functions can be used, as long as the implementation does not update any state variables, i.e. [the block number increase since the last update is less or equal to the `updateFrequency`](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/NoteInterest.sol#L141). However, when these functions are called after sufficient blocks are mined, they are going to revert. Although one can still call the implementation using [`delegateToImplementation`](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CErc20Delegator.sol#L437), it is not a good usability, especially if those functions are used for external user interface.   ## Proof Of Concept  [gist for the test](https://gist.github.com/zzzitron/37fb99cebed786b4c983d20a76e8793e#file-2022-06-newblockchain-v2-poc-ctoken-test-ts-L49-L62)  The gist shows a simple test. It calls `borrowRatePerBlock` and `supplyRatePerBlock` first time, it suceeds. Then, it mines for more than 300 times, which is the `updateFrequency` parameter. Then it calls again then fails.  Notes on the test file: - The setup is taken from `tests/Treasury/Accountant.test.ts` - using `solidity` from ethereum-waffle for chai to use `reverted`   ```   // in hardhat.config.js   import chai from "chai";   import { solidity } from "ethereum-waffle";    chai.use(solidity);   ```  ## Tools Used  hardhat   ## Recommended Mitigation Steps  Instead of using `delegateToViewImplementation` use `delegateToImplementation`. Alternatively, implement view functions to query these rates in `NoteInterest.sol` and `CToken.sol`. It will enable to query the rates without spending gas.  
# Lines of code  https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/CNote.sol#L148   # Vulnerability details  ## Impact The `CNote.doTransferOut` method is susceptible to denial of service.  ## Proof of Concept The logic of the `doTransferOut` method in `CNote` is as follows: ```javascript     function doTransferOut(address payable to, uint amount) virtual override internal {         require(address(_accountant) != address(0));         EIP20Interface token = EIP20Interface(underlying);         if (to != address(_accountant)) {             uint err = _accountant.supplyMarket(amount);             if (err != 0) { revert AccountantRedeemError(amount); }         }            token.transfer(to, amount);         bool success;         assembly {             switch returndatasize()                 case 0 { success := not(0) }                 case 32 {                      returndatacopy(0, 0, 32)                     success := mload(0)                 }                 default { revert(0, 0) }         }          require(success, "TOKEN_TRANSFER_OUT_FAILED");         require(token.balanceOf(address(this)) == 0, "cNote::doTransferOut: TransferOut Failed"); // <-- ERROR     } ```  The `doTransferOut` method receives an `amount` which is transferred to `to`, after it the balance of the contract token is checked to be equal to zero or the transaction will be reverted.  In the following cases a denial of service will occur: - In the case that is used an `amount` different than the balance, the transaction will be reverted. - **In the case that an attacker front-runs the transaction and sends one token more than the established by the `_accountant`.** - In case of increasing balance tokens like `mDai` that constantly change their balance, the established by the `_accountant` will be different when the transaction is persisted.  ## Recommended Mitigation Steps - Use balance differences instead of the 0 check.  
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/NoteInterest.sol#L118 https://github.com/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/CToken.sol#L209   # Vulnerability details  ## Impact According to the documentation in `InterestRateModel`, `getBorrowRate` has to return the borrow rate per block and the function `borrowRatePerBlock` in `CToken` directly returns the value of `getBorrowRate`. However, the rate per year is returned for `NoteInterest`. Therefore, using `NoteInterest` as an interest model will result in completely wrong values.   ## Recommended Mitigation Steps Return `baseRatePerBlock`.  
# Lines of code  https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/Accountant/AccountantDelegate.sol#L101   # Vulnerability details  ## Impact The `sweepInterest` method is susceptible to denial of service.  ## Proof of Concept The logic of the `sweepInterest` method relative to the `treasury` is as follows: ```javascript   bool success = cnote.transfer(treasury, amtToSweep);   if (!success) { revert  SweepError(treasury , amtToSweep); }   TreasuryInterface Treas = TreasuryInterface(treasury);   Treas.redeem(address(cnote),amtToSweep);   require(cnote.balanceOf(treasury) == 0, "AccountantDelegate::sweepInterestError"); ```  As you can see, `amtToSweep` is passed to it and `redeem` that amount. Later it is checked that the balance of `cnote` in the `treasury` address must be 0. However, all calculations related to `amtToSweep` come out of the balance of [address(this)](https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/Accountant/AccountantDelegate.sol#L83-L84) so if a third party sends a single token `cnote` to the address of `treasury` the method will be denied.  ## Recommended Mitigation Steps - Check that the balance is the same after and before the `bool success = cnote.transfer(treasury, amtToSweep);`  
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Accountant/AccountantDelegate.sol#L80-L99   # Vulnerability details  ## Impact In the sweepInterest function of the AccountantDelegate contract, the number of cnote sent to treasury should be cNoteToSweep instead of amtToSweep, as amtToSweep will normally be smaller than cNoteToSweep, which will cause the interest to be locked in the in the contract. ```   uint amtToSweep = sub_(cNoteAmt, noteDiff); // amount to sweep in Note,    uint cNoteToSweep = div_(amtToSweep, exRate); // amount of cNote to sweep = amtToSweep(Note) / exRate    cNoteToSweep = (cNoteToSweep > cNoteBal) ? cNoteBal :  cNoteToSweep;    bool success = cnote.transfer(treasury, amtToSweep);   if (!success) {    revert  SweepError(treasury , amtToSweep); //handles if transfer of tokens is not successful   }    TreasuryInterface Treas = TreasuryInterface(treasury);   Treas.redeem(address(cnote),amtToSweep); ``` ## Proof of Concept https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Accountant/AccountantDelegate.sol#L80-L99  ## Tools Used None ## Recommended Mitigation Steps ```diff   uint amtToSweep = sub_(cNoteAmt, noteDiff); // amount to sweep in Note,    uint cNoteToSweep = div_(amtToSweep, exRate); // amount of cNote to sweep = amtToSweep(Note) / exRate    cNoteToSweep = (cNoteToSweep > cNoteBal) ? cNoteBal :  cNoteToSweep;  -  bool success = cnote.transfer(treasury, amtToSweep); +               bool success = cnote.transfer(treasury, cNoteToSweep);   if (!success) { -   revert  SweepError(treasury , amtToSweep); //handles if transfer of tokens is not successful +                       revert  SweepError(treasury , cNoteToSweep); //handles if transfer of tokens is not successful   }    TreasuryInterface Treas = TreasuryInterface(treasury); -  Treas.redeem(address(cnote),amtToSweep); +               Treas.redeem(address(cnote),cNoteToSweep); ```  
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-periphery.sol#L522-L526 https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-periphery.sol#L198-L217   # Vulnerability details  # The LP pair underlying price quote could be manipulated   ## Impact  The underlying price for LP pool pair can be manipulated. This kind of price mainpulation happened before, can be found here: [Warp Fincance event](https://rekt.news/warp-finance-rekt/).  Whick may lead to the exploit of the pool by a malicious user.  ## Proof of Concept  file: lending-market-v2/contracts/Stableswap/BaseV1-periphery.sol 522-526， 198-217: ```             uint price0 = (token0 != USDC) ? IBaseV1Pair(pairFor(USDC, token0, stable0)).quote(token0, 1, 8) : 1;             uint price1 = (token1 != USDC) ? IBaseV1Pair(pairFor(USDC, token1, stable1)).quote(token1, 1, 8) : 1;             // how much of each asset is 1 LP token redeemable for             (uint amt0, uint amt1) = quoteRemoveLiquidity(token0, token1, stablePair, 1);             price = amt0 * price0 + amt1 * price1;       function quoteRemoveLiquidity(         address tokenA,         address tokenB,         bool stable,         uint liquidity     ) public view returns (uint amountA, uint amountB) {         // create the pair if it doesn"t exist yet         address _pair = IBaseV1Factory(factory).getPair(tokenA, tokenB, stable);          if (_pair == address(0)) {             return (0,0);         }          (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);         uint _totalSupply = erc20(_pair).totalSupply();          amountA = liquidity * reserveA / _totalSupply; // using balances ensures pro-rata distribution         amountB = liquidity * reserveB / _totalSupply; // using balances ensures pro-rata distribution      } ```  The price of the LP pair is determined by the TVL of the pool, given by: `amt0 * price0 + amt1 * price1`. However, when a malicious user dumps large amount of any token into the pool, the whole TVL will be significantly increased, which leads to inproper calculation of the price.   ## Tools Used mannual analysis  ## Recommended Mitigation Steps  A differenct approach to calculate the LP price can be found [here](https://cmichel.io/pricing-lp-tokens/).   
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/NoteInterest.sol#L145-L147   # Vulnerability details  ## Impact When casting to ``int`` from ``uint``, the overflow might happen.  ## Proof of Concept https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/NoteInterest.sol#L145-L147   ```             uint twapMantissa = oracle.getUnderlyingPrice(cNote); // returns price as mantissa             //uint ir = (1 - twapMantissa).mul(adjusterCoefficient).add(baseRatePerYear);             int diff = BASE - int(twapMantissa); //possible annoyance if 1e18 - twapMantissa > 2**255, differ ```  ``int(twapMantissa)`` can overflow depending on the value of ``uint twapMantissa``. Even if this is not expected, handling this case should be good.  ## Tools Used Static analysis  ## Recommended Mitigation Steps Consider using the logic of ``toInt256`` provided by OpenZeppelin.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol#L1130-L1134  
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/Stableswap/BaseV1-periphery.sol#L489   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Underlying asset price oracle for CToken in BaseV1-periphery is inaccuarte  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ```     function getUnderlyingPrice(CToken ctoken) external override view returns(uint price) {         IBaseV1Pair pair;         uint8 stable;         bool stablePair;         address underlying;          if (compareStrings(ctoken.symbol(), "cCANTO")) {             stable = 0;             underlying = address(wcanto);         }          //set price statically to 1 when the Comptroller is retrieving Price         else if (compareStrings(ctoken.symbol(), "cNOTE") && msg.sender == Comptroller) {             return 1; // Note price is fixed to 1         } ```  we should not be return 1. 1 is 1 wei. we should be 10 ** 18  ## Tools Used VIM  ## Recommended Mitigation Steps  we can return 10 ** 18  
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-core.sol#L72   # Vulnerability details  ## Impact TWAP oracle easily manipulated  ## Proof of Concept periodSize is set to 0 meaning that the oracle will take a new observation every single block, which would allow an attacker to easily flood the TWAP oracle and manipulate the price  ## Tools Used  ## Recommended Mitigation Steps Increase periodSize to be greater than 0, 1800 is typically standard  
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CErc20Delegator.sol#L237 https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CErc20Delegator.sol#L246   # Vulnerability details  ## Impact  When using CToken implementation with CErc20Delegator, the functions `borrowRatePerBlock` and `supplyRatePerBlock` will revert when the underlying functions try to update some states.  ## Detail  The v1 of [borrowRatePerBlock](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CToken.sol#L208) and [supplyRatePerBlock](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CToken.sol#L216) were view functions, but they are not anymore. The `CErc20Delegator` is still using `delegateToViewImplementation` for those functions. Those functions can be used, as long as the implementation does not update any state variables, i.e. [the block number increase since the last update is less or equal to the `updateFrequency`](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/NoteInterest.sol#L141). However, when these functions are called after sufficient blocks are mined, they are going to revert. Although one can still call the implementation using [`delegateToImplementation`](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CErc20Delegator.sol#L437), it is not a good usability, especially if those functions are used for external user interface.   ## Proof Of Concept  [gist for the test](https://gist.github.com/zzzitron/37fb99cebed786b4c983d20a76e8793e#file-2022-06-newblockchain-v2-poc-ctoken-test-ts-L49-L62)  The gist shows a simple test. It calls `borrowRatePerBlock` and `supplyRatePerBlock` first time, it suceeds. Then, it mines for more than 300 times, which is the `updateFrequency` parameter. Then it calls again then fails.  Notes on the test file: - The setup is taken from `tests/Treasury/Accountant.test.ts` - using `solidity` from ethereum-waffle for chai to use `reverted`   ```   // in hardhat.config.js   import chai from "chai";   import { solidity } from "ethereum-waffle";    chai.use(solidity);   ```  ## Tools Used  hardhat   ## Recommended Mitigation Steps  Instead of using `delegateToViewImplementation` use `delegateToImplementation`. Alternatively, implement view functions to query these rates in `NoteInterest.sol` and `CToken.sol`. It will enable to query the rates without spending gas.  
# Lines of code  https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/CNote.sol#L148   # Vulnerability details  ## Impact The `CNote.doTransferOut` method is susceptible to denial of service.  ## Proof of Concept The logic of the `doTransferOut` method in `CNote` is as follows: ```javascript     function doTransferOut(address payable to, uint amount) virtual override internal {         require(address(_accountant) != address(0));         EIP20Interface token = EIP20Interface(underlying);         if (to != address(_accountant)) {             uint err = _accountant.supplyMarket(amount);             if (err != 0) { revert AccountantRedeemError(amount); }         }            token.transfer(to, amount);         bool success;         assembly {             switch returndatasize()                 case 0 { success := not(0) }                 case 32 {                      returndatacopy(0, 0, 32)                     success := mload(0)                 }                 default { revert(0, 0) }         }          require(success, "TOKEN_TRANSFER_OUT_FAILED");         require(token.balanceOf(address(this)) == 0, "cNote::doTransferOut: TransferOut Failed"); // <-- ERROR     } ```  The `doTransferOut` method receives an `amount` which is transferred to `to`, after it the balance of the contract token is checked to be equal to zero or the transaction will be reverted.  In the following cases a denial of service will occur: - In the case that is used an `amount` different than the balance, the transaction will be reverted. - **In the case that an attacker front-runs the transaction and sends one token more than the established by the `_accountant`.** - In case of increasing balance tokens like `mDai` that constantly change their balance, the established by the `_accountant` will be different when the transaction is persisted.  ## Recommended Mitigation Steps - Use balance differences instead of the 0 check.  
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/NoteInterest.sol#L118 https://github.com/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/CToken.sol#L209   # Vulnerability details  ## Impact According to the documentation in `InterestRateModel`, `getBorrowRate` has to return the borrow rate per block and the function `borrowRatePerBlock` in `CToken` directly returns the value of `getBorrowRate`. However, the rate per year is returned for `NoteInterest`. Therefore, using `NoteInterest` as an interest model will result in completely wrong values.   ## Recommended Mitigation Steps Return `baseRatePerBlock`.  
# Lines of code  https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/Accountant/AccountantDelegate.sol#L101   # Vulnerability details  ## Impact The `sweepInterest` method is susceptible to denial of service.  ## Proof of Concept The logic of the `sweepInterest` method relative to the `treasury` is as follows: ```javascript   bool success = cnote.transfer(treasury, amtToSweep);   if (!success) { revert  SweepError(treasury , amtToSweep); }   TreasuryInterface Treas = TreasuryInterface(treasury);   Treas.redeem(address(cnote),amtToSweep);   require(cnote.balanceOf(treasury) == 0, "AccountantDelegate::sweepInterestError"); ```  As you can see, `amtToSweep` is passed to it and `redeem` that amount. Later it is checked that the balance of `cnote` in the `treasury` address must be 0. However, all calculations related to `amtToSweep` come out of the balance of [address(this)](https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/Accountant/AccountantDelegate.sol#L83-L84) so if a third party sends a single token `cnote` to the address of `treasury` the method will be denied.  ## Recommended Mitigation Steps - Check that the balance is the same after and before the `bool success = cnote.transfer(treasury, amtToSweep);`  
# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Accountant/AccountantDelegate.sol#L80-L99   # Vulnerability details  ## Impact In the sweepInterest function of the AccountantDelegate contract, the number of cnote sent to treasury should be cNoteToSweep instead of amtToSweep, as amtToSweep will normally be smaller than cNoteToSweep, which will cause the interest to be locked in the in the contract. ```   uint amtToSweep = sub_(cNoteAmt, noteDiff); // amount to sweep in Note,    uint cNoteToSweep = div_(amtToSweep, exRate); // amount of cNote to sweep = amtToSweep(Note) / exRate    cNoteToSweep = (cNoteToSweep > cNoteBal) ? cNoteBal :  cNoteToSweep;    bool success = cnote.transfer(treasury, amtToSweep);   if (!success) {    revert  SweepError(treasury , amtToSweep); //handles if transfer of tokens is not successful   }    TreasuryInterface Treas = TreasuryInterface(treasury);   Treas.redeem(address(cnote),amtToSweep); ``` ## Proof of Concept https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Accountant/AccountantDelegate.sol#L80-L99  ## Tools Used None ## Recommended Mitigation Steps ```diff   uint amtToSweep = sub_(cNoteAmt, noteDiff); // amount to sweep in Note,    uint cNoteToSweep = div_(amtToSweep, exRate); // amount of cNote to sweep = amtToSweep(Note) / exRate    cNoteToSweep = (cNoteToSweep > cNoteBal) ? cNoteBal :  cNoteToSweep;  -  bool success = cnote.transfer(treasury, amtToSweep); +               bool success = cnote.transfer(treasury, cNoteToSweep);   if (!success) { -   revert  SweepError(treasury , amtToSweep); //handles if transfer of tokens is not successful +                       revert  SweepError(treasury , cNoteToSweep); //handles if transfer of tokens is not successful   }    TreasuryInterface Treas = TreasuryInterface(treasury); -  Treas.redeem(address(cnote),amtToSweep); +               Treas.redeem(address(cnote),cNoteToSweep); ```  
