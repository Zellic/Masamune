# Handle  cmichel   # Vulnerability details  Several different signature modes can be used and `Identity.execute` forwards the `signature` parameter to the `SignatureValidator` library. The returned `signer` is then used for the `privileges` check:  ```solidity address signer = SignatureValidator.recoverAddrImpl(hash, signature, true); // signer will be QuickAccountContract require(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE'); ```  It's possible to create a smart contract mode signature (`SignatureMode.SmartWallet`) for arbitrary transactions as the `QuickAccManager.isValidSignature` uses an attacker-controlled `id` identity contract for the privileges check. An attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid:  ```solidity // @audit id is attacker-controlled (address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes)); // @audit this may not be used for authorization, attacker can return desired value if (Identity(id).privileges(address(this)) == accHash) {   // bytes4(keccak256("isValidSignature(bytes32,bytes)")   return 0x1626ba7e; } else {   return 0xffffffff; } ```  ## POC  Assume an `Identity` contract is set up with a `QuickAccManager` as the `privileges` account, i.e. `privileges[accHash] != 0`.  We can construct a `SignatureMode.SmartWallet` signature for an _arbitrary_ hash: 1. Call `Identity.execute(txns, spoofedSignature)` where `spoofedSignature = abi.encode(attackerContract, timelock=0, sig1=0, sig2=0, address(quickAccountManager), SignatureMode.SmartWallet)` 2. This will call `recoverAddrImpl(txnsHash, spoofedSignature, true)`, decode the bytes **at the end** of `spoofedSignature` and determine `mode = SignatureMode.SmartWallet` and `wallet = quickAccountManager`. It will cut off these arguments and call `quickAccountManager.isValidSignature(txnsHash, (attackerContract, 0, 0, 0))` 3. The `QuickAccManager` will decode the signature, construct `accHash` which is the hash of all zeroes (due to failed signatures returning 0). It will then call `attacker.privileges(address(this))` and the attacker contract can return the `accHash` that matches an account hash of failed signatures, i.e., `keccak256(abi.encode(QuickAccount(0,0,0)))`. The comparison is satisfied and it returns the success value. 4. The checks in `Identity.execute` pass and the transactions `txns` are executed.  ## Impact Any `Identity` contract using `QuickAccManager` can be exploited. Funds can then be stolen from the wallet.  ## Recommendation The issue is that `QuickAccManager` blindly trusts the values in `signature`. It might be enough to remove the `id` from the `signature` and use `msg.sender` as the identity instead: `Identity(msg.sender).privileges(address(this)) == accHash`. This seems to work with the current `Identity` implementation but might not work if this is extended and the `isValidSignature` is called from another contract and wants to verify a signature on a different identity. In that case, the `Identity/SignatureValidator` may not blindly forward the attacker-supplied signature and instead needs to re-encode the parameters with trusted values before calling `QuickAccManager`.   
