# Lines of code  https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L151 https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L353-L377   # Vulnerability details  When creating a new governance proposal, the `proposalId` is generated by hashing the proposal data (`_targets, _values, _calldatas, descriptionHash`). To prevent duplicated proposals, the current `Governor` implementation checks if the `proposalId` exists already. If it exists, the call will revert with the `PROPOSAL_EXISTS` error.  ## Impact  Anyone can prevent others from creating governance proposals by front-running the create proposal transaction with the same data, followed by an immediate call to the `Governor.cancel` function.  This will prevent creating a proposal with the same proposal data. A proposal creator would have to slightly change the proposal to try to create it again (however, it can be prevented again due to the aforementioned issue)  ## Proof of Concept  [governance/governor/Governor.propose](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L151)  ```solidity function propose(     address[] memory _targets,     uint256[] memory _values,     bytes[] memory _calldatas,     string memory _description ) external returns (bytes32) {     [..]      // Compute the description hash     bytes32 descriptionHash = keccak256(bytes(_description));      // Compute the proposal id     bytes32 proposalId = hashProposal(_targets, _values, _calldatas, descriptionHash);      // Get the pointer to store the proposal     Proposal storage proposal = proposals[proposalId];      // Ensure the proposal doesn't already exist     if (proposal.voteStart != 0) revert PROPOSAL_EXISTS(proposalId); // @audit-info Reverts in case the proposals with the same data exists already      [..] } ```  [governance/governor/Governor.cancel](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/governance/governor/Governor.sol#L353-L377)  Cancelling a proposal updates the `proposal.canceled` boolean property to `true`. `proposal.voteStart` is left unchanged (`!= 0`).  ```solidity /// @notice Cancels a proposal /// @param _proposalId The proposal id function cancel(bytes32 _proposalId) external {     // Ensure the proposal hasn't been executed     if (state(_proposalId) == ProposalState.Executed) revert PROPOSAL_ALREADY_EXECUTED();      // Get a copy of the proposal     Proposal memory proposal = proposals[_proposalId];      // Cannot realistically underflow and `getVotes` would revert     unchecked {         // Ensure the caller is the proposer or the proposer's voting weight has dropped below the proposal threshold         if (msg.sender != proposal.proposer && getVotes(proposal.proposer, block.timestamp - 1) > proposal.proposalThreshold)             revert INVALID_CANCEL();     }      // Update the proposal as canceled     proposals[_proposalId].canceled = true;      // If the proposal was queued:     if (settings.treasury.isQueued(_proposalId)) {         // Cancel the proposal         settings.treasury.cancel(_proposalId);     }      emit ProposalCanceled(_proposalId); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider adding a per-account nonce storage variable (e.g. `mapping(address => uint256) internal proposalCreatorNonces;` to the `Governor` contract and include the `proposalCreatorNonces[msg.sender]++` nonce within the computed proposal id. 
