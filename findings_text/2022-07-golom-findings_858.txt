# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893-L908 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1004-L1030 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236   # Vulnerability details  Golom is impacted by a known issue with the veNFT contract that causes the `merge` and `withdraw` functions to revert when called by an approved spender rather than the token owner.  `merge` and `withdraw` may both be called by either the token owner or an approved spender. Note that both of these functions check `_isApprovedOrOwner`:  [`VoteEscrowCore#merge`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893-L908)  ```solidity     function merge(uint256 _from, uint256 _to) external {         require(attachments[_from] == 0 && !voted[_from], 'attached');         require(_from != _to);         require(_isApprovedOrOwner(msg.sender, _from));         require(_isApprovedOrOwner(msg.sender, _to));          LockedBalance memory _locked0 = locked[_from];         LockedBalance memory _locked1 = locked[_to];         uint256 value0 = uint256(int256(_locked0.amount));         uint256 end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;          locked[_from] = LockedBalance(0, 0);         _checkpoint(_from, _locked0, LockedBalance(0, 0));         _burn(_from);         _deposit_for(_to, value0, end, _locked1, DepositType.MERGE_TYPE);     } ```  [`VoteEscrowCore#withdraw`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1004-L1030)  ```solidity     /// @notice Withdraw all tokens for `_tokenId`     /// @dev Only possible if the lock has expired     function withdraw(uint256 _tokenId) external nonreentrant {         assert(_isApprovedOrOwner(msg.sender, _tokenId));         require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');          LockedBalance memory _locked = locked[_tokenId];         require(block.timestamp >= _locked.end, "The lock didn't expire");         uint256 value = uint256(int256(_locked.amount));          locked[_tokenId] = LockedBalance(0, 0);         uint256 supply_before = supply;         supply = supply_before - value;          // old_locked can have either expired <= timestamp or zero end         // _locked has only 0 end         // Both can have >= 0 amount         _checkpoint(_tokenId, _locked, LockedBalance(0, 0));          assert(IERC20(token).transfer(msg.sender, value));          // Burn the NFT         _burn(_tokenId);          emit Withdraw(msg.sender, _tokenId, value, block.timestamp);         emit Supply(supply_before, supply_before - value);     } ```  However, both functions make internal calls to `_burn`, which does **not** handle the case of an approved caller correctly. The call to `_removeTokenFrom` on [L1234](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1234-L1235) passes `msg.sender` rather than the token `owner`, which will revert:  [`VoteEscrowCore#_burn`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236)  ```solidity     function _burn(uint256 _tokenId) internal {         require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');          address owner = ownerOf(_tokenId);          // Clear approval         approve(address(0), _tokenId);         // Remove token         _removeTokenFrom(msg.sender, _tokenId);         emit Transfer(owner, address(0), _tokenId);     } ```  **Impact:** Approved callers cannot `merge` or `withdraw` veNFTs. `merge` and `withdraw` may only be called by the token owner.  **Suggestion:**  Update `_burn` to pass token owner address rather than `msg.sender`:  ```solidity     function _burn(uint256 _tokenId) internal {         require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');          address owner = ownerOf(_tokenId);          // Clear approval         approve(address(0), _tokenId);         // Remove token         _removeTokenFrom(owner, _tokenId);         emit Transfer(owner, address(0), _tokenId);     } ```
