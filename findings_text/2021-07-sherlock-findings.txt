# Handle  shw   # Vulnerability details  ## Impact  The `_accrueSherX` function of `LibSherX` and the `payOffDebtAll` function of `LibPool` can be called multiple times in the same block (from different users and transactions). If the current block number is the same as the last-recorded one, it is possible to save gas by early returning at the beginning of the functions.  ## Proof of Concept  Referenced code: [LibSherX.sol#L123-L141](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L123-L141) [LibPool.sol#L84-L95](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L84-L95)  ## Recommended Mitigation Steps  For example, consider re-writing `_accrueSherX` as follows:  ```solidity function _accrueSherX(IERC20 _token, uint256 sherXPerBlock) private returns (uint256 sherX) {   PoolStorage.Base storage ps = PoolStorage.ps(_token);   if (block.number == ps.sherXLastAccrued) {     return 0;   }   sherX = block.number.sub(ps.sherXLastAccrued).mul(sherXPerBlock).mul(ps.sherXWeight).div(     uint16(-1)   );   // need to settle before return, as updating the sherxperlblock/weight   // after it was 0 will result in a too big amount (accured will be < block.number)   ps.sherXLastAccrued = uint40(block.number);   if (address(_token) == address(this)) {     ps.stakeBalance = ps.stakeBalance.add(sherX);   } else {     ps.unallocatedSherX = ps.unallocatedSherX.add(sherX);     ps.sWeight = ps.sWeight.add(sherX);   } } ```  
# Handle  shw   # Vulnerability details  ## Impact  A storage read cost more gas than a memory read. State variables that do not change during a loop can be stored in local variables and be read from memory multiple times to save gas.  ## Proof of Concept  Referenced code: [LibPool.sol#L89](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L89) [LibSherX.sol#L60](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L60) [LibSherX.sol#L94](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L94) [PoolBase.sol#L131](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L131) [SherX.sol#L76](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L76) [SherX.sol#L98](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L98) [SherX.sol#L152](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L152) [SherX.sol#L184](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L184) [SherX.sol#L243](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L243) [Gov.sol#L190](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L190)  ## Recommended Mitigation Steps  For example, consider re-writing the `harvestFor(address)` function of `SherX` as follows:  ```solidity function harvestFor(address _user) public override {   GovStorage.Base storage gs = GovStorage.gs();   uint256 len = gs.tokensStaker.length;   for (uint256 i; i < len; i++) {     PoolStorage.Base storage ps = PoolStorage.ps(gs.tokensStaker[i]);     harvestFor(_user, ps.lockToken);   } } ```  
# Handle  shw   # Vulnerability details  ## Impact  In the `PoolStorage` library, declaring the `POOL_STORAGE_PREFIX` constant with type `bytes32`, and change `abi.encode` ti `abi.encodePacked` at line 87 can save gas.  ## Proof of Concept  Referenced code: [PoolStorage.sol#L14](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/storage/PoolStorage.sol#L14) [PoolStorage.sol#L87](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/storage/PoolStorage.sol#L87)  Related links: [Change `string` to `byteX` if possible](https://medium.com/layerx/how-to-reduce-gas-cost-in-solidity-f2e5321e0395#2a78) [Solidity-Encode-Gas-Comparison](https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison)  ## Recommended Mitigation Steps  See above  
# Handle  shw   # Vulnerability details  ## Impact  The `calcUnderlyingInStoredUSD()` function of `SherX` should return `calcUnderlyingInStoredUSD(getSherXBalance())` instead of `calcUnderlyingInStoredUSD(sx20.balances[msg.sender])` since there could be SherX unallocated to the user at the time of the function call. A similar function, `calcUnderlying()`, calculates the user's underlying tokens based on the user's current balance plus the unallocated ones.  ## Proof of Concept  Referenced code: [SherX.sol#L141](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L141)  ## Recommended Mitigation Steps  Change `sx20.balances[msg.sender]` to `getSherXBalance()` at line 141.  
# Handle  shw   # Vulnerability details  The `getInitialUnstakeEntry` function of `PoolBase` returns the first active unstaking entry of a staker, which requires the current block to be strictly before the last block in the unstaking window. However, the `unstake` function allows the current block to be exactly the same as the last block (same logic in `unstakeWindowExpiry`).  ## Proof of Concept  Referenced code: [PoolBase.sol#L136](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L136) [PoolBase.sol#L344](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L344) [PoolBase.sol#L364](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L364)  ## Recommended Mitigation Steps  Change the `<=` comparison at line 136 to `<` for consistency.  
# Handle  shw   # Vulnerability details  ## Impact  A possible divide-by-zero error could happen in the `getSherXPerBlock(uint256, IERC20)` function of `PoolBase` when the `totalSupply` of `lockToken` and `_lock` are both 0.  ## Proof of Concept  Referenced code: [PoolBase.sol#L215](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L215)  ## Recommended Mitigation Steps  Check if `baseData().lockToken.totalSupply().add(_lock)` equals to 0 before line 214. If so, then return 0.  
# Handle  0xsanson   # Vulnerability details  ## Impact The value `10e17` can be confusing, since it doesn't clearly appear from where the exponent 17 comes from (people may ctrl+f or grep the code for other instances of it without results). Indeed throughout the code the expression `10**18` is used.  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L185  ## Tools Used editor  ## Recommended Mitigation Steps Better ways of writing it are `1e18` or `10**18`.  
# Handle  0xsanson   # Vulnerability details  ## Impact In the function `_doSherX` in Payout.sol, the natSpec comment @return states that `sherUsd` is the 'Total amount of USD of the underlying tokens that are being transferred'. I think that's a typo, and it's supposed to be the amount *excluded* from being transferred.  ## Proof of Concept Payout.sol L71  ## Tools Used editor  ## Recommended Mitigation Steps Correct the statement.  
# Handle  0xsanson   # Vulnerability details  ## Impact In the `calcUnderlying` function of LibSherX.sol, the value `gs.tokensSherX.length` can be written down once to save gas (around 300-500 when called in the present tests).  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L55-L60  ## Tools Used hardhat gas calculator  ## Recommended Mitigation Steps Suggested adding `uint256 SherXLength = gs.tokensSherX.length;` and replacing this value throughout the function (three instances).  
# Handle  tensors   # Vulnerability details  ## Impact Poorly named variables in Gov.sol  ## Proof of Concept _protocolPremium is a bool while protcolPremium is a mapping to uint. This is confusing a could potentially cause some input errors.  ## Recommended Mitigation Steps Rename variables.  
# Handle  cmichel   # Vulnerability details  Usually, the functions to increase the allowance are called `increaseAllowance` and `decreaseAllowance` but in `SherXERC20` they are called `increaseApproval` and `decreaseApproval`  ## Recommendation Rename these functions to the more common names.  
# Handle  cmichel   # Vulnerability details  The `SherXERC20.initializeSherXERC20` function has `initialize` in its name which indicates that it should only be called once to initialize the storage. But it can be repeatedly called to overwrite and update the ERC20 name and symbol.  ## Recommendation Consider an `initializer` modifier or reverting if `name` or `symbol` is already set.  
# Handle  cmichel   # Vulnerability details  The `setWeights` function only stores the `uint16` part of `_weights[i]` in storage (`ps.sherXWeight = uint16(_weights[i])`). However, to calculate `weightAdd/weightSub` the full value (not truncated to 16 bits) is used. This can lead to discrepancies as the actually added part is different from the one tracked in the `weightAdd` variable.   
# Handle  cmichel   # Vulnerability details  The `PoolBase.unstakeWindowExpiry` function allows unstaking tokens of other users. While the tokens are sent to the correct address, this can lead to issues with smart contracts that might rely on claiming the tokens themselves.  For example, suppose the `_to` address corresponds to a smart contract that has a function of the following form:  ```solidity function withdrawAndDoSomething() {     uint256 amount = token.balanceOf(address(this));     contract.unstakeWindowExpiry(address(this), id, token);     amount = amount - token.balanceOf(address(this));     token.transfer(externalWallet, amount) } ```  If the contract has no other functions to transfer out funds, they may be locked forever in this contract.  
# Handle  a_delamo   # Vulnerability details  ## Impact  The following functions are public, but they could be decla  ``` getUnactivatedStakersPoolBalance(IERC20) should be declared external:         - PoolBase.getUnactivatedStakersPoolBalance(IERC20) (contracts/facets/PoolBase.sol#146-148) getTotalUnmintedSherX(IERC20) should be declared external:         - PoolBase.getTotalUnmintedSherX(IERC20) (contracts/facets/PoolBase.sol#170-173) accruedDebt(bytes32,IERC20) should be declared external:         - LibPool.accruedDebt(bytes32,IERC20) (contracts/libraries/LibPool.sol#31-34) getTotalAccruedDebt(IERC20) should be declared external:         - LibPool.getTotalAccruedDebt(IERC20) (contracts/libraries/LibPool.sol#36-39) accrueSherX(IERC20) should be declared external:         - LibSherX.accrueSherX(IERC20) (contracts/libraries/LibSherX.sol#75-81) accrueSherXWatsons() should be declared external:         - LibSherX.accrueSherXWatsons() (contracts/libraries/LibSherX.sol#83-86) deposit() should be declared external:         - AaveV2.deposit() (contracts/strategies/AaveV2.sol#75-81) ```   ## Tools Used  Slither     
# Handle  cmichel   # Vulnerability details  The `_doSherX` function does not return the correct precision of `sherUsd` and it is **not** the "Total amount of USD of the underlying tokens that are being transferred" that the documentation mentions.  ```solidity sherUsd = amounts[i].mul(sx.tokenUSD[tokens[i]]); ```  Instead, the amount is inflated by `1e18`, it should divide the amount by `1e18` to get a USD value with 18 decimal precision.  The severity is low as the calling site in `payout` makes up for it by dividing by `1e18` in the `deduction` computation.  We still recommend returning the correct amount in `_doSherX` already to match the documentation and avoid any future errors when using its unintuitive return value.  
# Handle  cmichel   # Vulnerability details  The `Gov.tokenInit` skips the underlying token check if the `_token` is SHERX:  ```solidity if (address(_token) != address(this)) {   require(_lock.underlying() == _token, 'UNDERLYING'); } ```  ## Impact This check should still be performed even for `_token == address(this) // SHERX`, otherwise, the lock can have a different underlying and potentially pay out wrong tokens.  ## Recommendation Verify the underlying of all locks.  
# Handle  cmichel   # Vulnerability details  The `SherXERC20.transferFrom` function reads the allowance from memory twice. It should be read once, cached, and then use that value for the `if(cachedAllowance ...)` and for the `newApproval = ...` expressions.  
# Handle  cmichel   # Vulnerability details  The `SherXERC20.increaseApproval` function reads the allowance from memory twice. It should be read once and then cached and for the event you the `cache + _amount` value.  
# Handle  hrkrshnn   # Vulnerability details  ## A critical bug in bps function: PoolBase.sol  ``` solidity function bps() internal pure returns (IERC20 rt) {   // These fields are not accessible from assembly   bytes memory array = msg.data;   uint256 index = msg.data.length;    // solhint-disable-next-line no-inline-assembly   assembly {     // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.     rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)   } } ```  The above function is designed to expect the token at the end of `calldata`, but a malicious user can inject extra values at the end of `calldata` and fake return values.  The following contract demonstrates an example:  ``` solidity pragma solidity 0.8.6;  interface IERC20 {}  error StaticCallFailed();  contract BadEncoding {     /// Will return address(1). But address(0) is expected!     function f() external view returns (address) {         address actual = address(0);         address injected = address(1);          (bool success, bytes memory ret) = address(this).staticcall(abi.encodeWithSelector(this.g.selector, actual, injected));          if (!success) revert StaticCallFailed();          return abi.decode(ret, (address));     }     function g(IERC20 _token) external pure returns (IERC20) {         // to get rid of the unused warning         _token;         // Does it always match _token?         return bps();     }     // From Sherlock Protocol: PoolBase.sol     function bps() internal pure returns (IERC20 rt) {         // These fields are not accessible from assembly         bytes memory array = msg.data;         uint256 index = msg.data.length;          // solhint-disable-next-line no-inline-assembly         assembly {             // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.             rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)         }     } } ```  ### An example exploit  This can be used to exploit the protocol:  ``` solidity function unstake(   uint256 _id,   address _receiver,   IERC20 _token ) external override returns (uint256 amount) {   PoolStorage.Base storage ps = baseData();   require(_receiver != address(0), 'RECEIVER');   GovStorage.Base storage gs = GovStorage.gs();   PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];   require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');   // period is including   require(withdraw.blockInitiated + gs.unstakeCooldown < uint40(block.number), 'COOLDOWN_ACTIVE');   require(     withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow >= uint40(block.number),     'UNSTAKE_WINDOW_EXPIRED'   );   amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());    ps.stakeBalance = ps.stakeBalance.sub(amount);   delete ps.unstakeEntries[msg.sender][_id];   ps.lockToken.burn(address(this), withdraw.lock);   _token.safeTransfer(_receiver, amount); } ```  State token `Token1`. Let's say there is a more expensive token `Token2`.  Here's an example exploit:  ``` solidity bytes memory exploitPayload = abi.encodeWithSignature(     PoolBase.unstake.selector,     (uint256(_id), address(_receiver), address(Token2), address(Token1)) ); poolAddress.call(exploitPayload); ```  All the calculations on `ps` would be done on `Token2`, but at the end, because of, `_token.safeTransfer(_receiver, amount);`, `Token2` would be transferred. Assuming that `Token2` is more expensive than `Token1`, the attacker makes a profit.  Similarly, the same technique can be used at a lot of other places. Even if this exploit is not profitable, the fact that the computations can be done on two different tokens is buggy.  There are several other places where the same pattern is used. All of them needs to be fixed. I've not written an exhaustive list.   
# Handle  hrkrshnn   # Vulnerability details  ## Use `type(uintX).max` instead of `uintX(-1)`  ``` diff modified   contracts/facets/Gov.sol @@ -55,7 +55,7 @@ contract Gov is IGov {      GovStorage.Base storage gs = GovStorage.gs();      SherXStorage.Base storage sx = SherXStorage.sx();  -    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(uint16(-1)); +    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(type(uint16).max);    }     function getWatsonsUnmintedSherX() external view override returns (uint256) { ```  Use `type(integerType).max` for such cases. There are also other places that could use this.  ## Have NatSpec comments for all functions ## Avoid the diamond standard  The most significant optimization that can be done in the contract is to get rid of the diamond standard, because, proxy architectures are inherently expensive. Unless there are specific reasons, such as contract size limits, a diamond makes the contract unnecessary complex. Also, try to avoid upgradability if you can afford it.   
# Handle  hrkrshnn   # Vulnerability details  ## Change memory to calldata and caching in loop  ``` diff modified   contracts/facets/Manager.sol @@ -139,16 +139,17 @@ contract Manager is IManager {     function setProtocolPremiumAndTokenPrice(      bytes32 _protocol, -    IERC20[] memory _token, -    uint256[] memory _premium, -    uint256[] memory _newUsd +    IERC20[] calldata _token, +    uint256[] calldata _premium, +    uint256[] calldata _newUsd    ) external override onlyGovMain {      require(_token.length == _premium.length, 'LENGTH_1');      require(_token.length == _newUsd.length, 'LENGTH_2');       (uint256 usdPerBlock, uint256 usdPool) = _getData();  -    for (uint256 i; i < _token.length; i++) { +    uint length = _token.length; +    for (uint256 i; i < length; i++) {        LibPool.payOffDebtAll(_token[i]);        (usdPerBlock, usdPool) = _setProtocolPremiumAndTokenPrice(          _protocol, ```  About caching in loop, see my other report on why it's needed.  For the old code, i.e., having an array in memory, there is an unnecessary copy from `calldata` to `memory`. In the proposed patch, this unnecessary copy is avoided and values are directly read from `calldata` by using `calldataload(...)` instead of going via `calldatacopy(...)`, then `mload(...)`). Saves memory expansion cost, and cost of copying from `calldata` to `memory`.  There are several other places throughout the codebase where the same optimization can be used. I've not provided an exhaustive list.   
# Handle  hrkrshnn   # Vulnerability details  ## Caching in for loops  ``` diff modified   contracts/facets/PoolBase.sol @@ -128,19 +128,21 @@ contract PoolBase is IPoolBase {    {      PoolStorage.Base storage ps = baseData();      GovStorage.Base storage gs = GovStorage.gs(); -    for (uint256 i = 0; i < ps.unstakeEntries[_staker].length; i++) { -      if (ps.unstakeEntries[_staker][i].blockInitiated == 0) { +    PoolStorage.UnstakeEntry[] storage entries = ps.unstakeEntries[_staker]; +    uint length = entries.length; +    for (uint256 i = 0; i < length; i++) { +      if (entries[i].blockInitiated == 0) {          continue;        }        if ( -        ps.unstakeEntries[_staker][i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <= +        entries[i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <=          uint40(block.number)        ) {          continue;        }        return i;      } -    return ps.unstakeEntries[_staker].length; +    return length;    } ```  Caching expensive state variables would avoid re-reading from storage. Solidity's optimizer currently will not be able to cache this value (the IR based codegen and the Yul optimizer can do it; but that is not activated by default).   
# Handle  hrkrshnn   # Vulnerability details  ## Packing the struct  ``` diff modified   contracts/storage/GovStorage.sol @@ -14,15 +14,17 @@ library GovStorage {    struct Base {      // The address appointed as the govMain entity      address govMain; +    // The amount of blocks the cooldown period takes +    uint40 unstakeCooldown; +    // The amount of blocks for the window of opportunity of unstaking +    uint40 unstakeWindow; +    // Check if the protocol is included in the solution at all +    uint16 watsonsSherxWeight; +    // The last block the total amount of rewards were accrued.      // NOTE: UNUSED      mapping(bytes32 => address) protocolManagers;      // Based on the protocol identifier, get the address of the protocol that is able the withdraw balances      mapping(bytes32 => address) protocolAgents; -    // The amount of blocks the cooldown period takes -    uint40 unstakeCooldown; -    // The amount of blocks for the window of opportunity of unstaking -    uint40 unstakeWindow; -    // Check if the protocol is included in the solution at all      mapping(bytes32 => bool) protocolIsCovered;      // The array of tokens the accounts are able to stake in      IERC20[] tokensStaker; @@ -33,8 +35,6 @@ library GovStorage {      address watsonsAddress;      // How much sherX is distributed to this account      // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this acocunt -    uint16 watsonsSherxWeight; -    // The last block the total amount of rewards were accrued.      uint40 watsonsSherxLastAccrued;    } ```  In the current layout, the members `govMain`, `unstakeCooldown`, `unstakeWindow`, `watsonsSherxWeight` all can be packed to a single slot or exactly 256 bits. This can save gas if both such elements are read or written at the same time (please use at least 0.8.2, since it has some improvements centred around optimizing packed Structs).  In the previous layout:  1.  `govMain` would have a slot of its own. 2.  `unstakeCooldown` and `unstakeWindow` would be packed together in a     single slot. 3.  `watsonsSherxWeight` and `watsonsSherxLastAccrued` would be packed     together in a single slot.  Note that gas savings are mainly relevant in the following cases:  1.  Compiler can optimize certain reads and writes to the same slot. 2.  Berlin EIP-2929 based gas accounting, i.e., if the same tx leaves     one of the slot warm. 3.  Berlin EIP-2930 for access lists. Instead of having to making three     different slots warm (in the original code), one only has to make     two slots warm, if necessary.  If none of these applies for your case, this suggestion may be ignored.  ## Packing for PoolStorage  ``` diff modified   contracts/storage/PoolStorage.sol @@ -15,20 +15,35 @@ library PoolStorage {     struct Base {      address govPool; +    // The last block the total amount of rewards were accrued. +    // Accrueing SherX increases the `unallocatedSherX` variable +    uint40 sherXLastAccrued; +    // Protocol debt can only be settled at once for all the protocols at the same time +    // This variable is the block number the last time all the protocols debt was settled +    uint40 totalPremiumLastPaid; + +    // How much sherX is distributed to stakers of this token +    // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this pool +    uint16 sherXWeight;      //      // Staking      //      // Indicates if stakers can stake funds in the pool      bool stakes; -    // Address of the lockToken. Representing stakes in this pool -    ILock lockToken;      // Variable used to calculate the fee when activating the cooldown      // Max value is uint32(-1) which creates a 100% fee on the withdrawal      uint32 activateCooldownFee; +    // Address of the lockToken. Representing stakes in this pool +    // Indicates if protocol are able to pay premiums with this token +    // If this value is true, the token is also included as underlying of the SherX +    bool premiums; + +    ILock lockToken;      // The total amount staked by the stakers in this pool, including value of `firstMoneyOut`      // if you exclude the `firstMoneyOut` from this value, you get the actual amount of tokens staked      // This value is also excluding funds deposited in a strategy.      uint256 stakeBalance; +      // All the withdrawals by an account      // The values of the struct are all deleted if expiry() or unstake() function is called      mapping(address => UnstakeEntry[]) unstakeEntries; @@ -39,12 +54,6 @@ library PoolStorage {      // SherX could be minted before the stakers call the harvest() function      // Minted SherX that is assigned as reward for the pool will be added to this value      uint256 unallocatedSherX; -    // How much sherX is distributed to stakers of this token -    // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this pool -    uint16 sherXWeight; -    // The last block the total amount of rewards were accrued. -    // Accrueing SherX increases the `unallocatedSherX` variable -    uint40 sherXLastAccrued;      // Non-native variables      // These variables are used to calculate the right amount of SherX rewards for the token staked      mapping(address => uint256) sWithdrawn; @@ -52,9 +61,6 @@ library PoolStorage {      //      // Protocol payments      // -    // Indicates if protocol are able to pay premiums with this token -    // If this value is true, the token is also included as underlying of the SherX -    bool premiums;      // Storing the protocol token balance based on the protocols bytes32 indentifier      mapping(bytes32 => uint256) protocolBalance;      // Storing the protocol premium, the amount of debt the protocol builds up per block. @@ -62,9 +68,6 @@ library PoolStorage {      mapping(bytes32 => uint256) protocolPremium;      // The sum of all the protocol premiums, the total amount of debt that builds up in this token. (per block)      uint256 totalPremiumPerBlock; -    // Protocol debt can only be settled at once for all the protocols at the same time -    // This variable is the block number the last time all the protocols debt was settled -    uint40 totalPremiumLastPaid;      // How much token (this) is available for sherX holders      uint256 sherXUnderlying;      // Check if the protocol is included in the token pool ```  For the same reasons as before. Taking a quick look at the code, this change should reduce gas. (Might require 0.8.2, though; there was an improvement in the optimizer that would apply to packed structs in storage.)   
# Handle  hrkrshnn   # Vulnerability details  ## Higher value of optimize-runs  ``` diff modified   hardhat.config.js @@ -25,7 +25,7 @@ module.exports = {      settings: {        optimizer: {          enabled: true, -        runs: 200, +        runs: 20000,        },      },    }, ```  This value is a tuning parameter for deploy v/s runtime costs. Higher values optimize for lower runtime cost, which is what you are looking for. The above value is an example, please decide a suitable high value, and run tests.  
# Handle  hrkrshnn   # Vulnerability details  ## Writing a branch less version  ``` diff @@ -76,11 +77,11 @@ contract SherXERC20 is IERC20, ISherXERC20 {      require(_amount != 0, 'AMOUNT');      SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();      uint256 oldValue = sx20.allowances[msg.sender][_spender]; -    if (_amount > oldValue) { -      sx20.allowances[msg.sender][_spender] = 0; -    } else { -      sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount); -    } +    uint256 newValue; +    assembly { +        newValue := mul(gt(oldValue, _amount), sub(oldValue, _amount)) +    } +    sx20.allowances[msg.sender][_spender] = newValue;      emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]);      return true;    } ```  The branch-less version avoids at least two `jumpi`, i.e., at least 20 gas and some additional stack operations, along with deploy costs.  Here's a SMT proof that the transformation is equivalent:  ``` python from z3 import *  # A SMT proof that # # if (_amount > oldValue) { #   sx20.allowances[msg.sender][_spender] = 0; # } else { #   sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount); # } # # is same as # # assembly { #     newValue := mul(gt(oldValue, _amount), sub(oldValue, _amount)) # } # sx20.allowances[msg.sender][_spender] = newValue; #  n_bits = 256 amount = BitVec('amount', n_bits) oldValue = BitVec('oldValue', n_bits) allowance = BitVec('oldValue', n_bits)  old_allowance_computation = If(UGT(amount, oldValue), 0, oldValue - amount)  def GT(x, y):     return If(UGT(x, y), BitVecVal(1, n_bits), BitVecVal(0, n_bits)) def MUL(x, y):     return x * y def SUB(x, y):     return x - y  new_allowance_computation = MUL(GT(oldValue, amount), SUB(oldValue, amount))  solver = Solver() solver.add(old_allowance_computation != new_allowance_computation)  result = solver.check() print(result) # unsat ```   
# Handle  hrkrshnn   # Vulnerability details  ## Caching variable  ``` diff modified   contracts/facets/SherXERC20.sol @@ -66,8 +66,9 @@ contract SherXERC20 is IERC20, ISherXERC20 {      require(_spender != address(0), 'SPENDER');      require(_amount != 0, 'AMOUNT');      SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20(); -    sx20.allowances[msg.sender][_spender] = sx20.allowances[msg.sender][_spender].add(_amount); -    emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]); +    uint256 newAllowance = sx20.allowances[msg.sender][_spender].add(_amount); +    sx20.allowances[msg.sender][_spender] = newAllowance; +    emit Approval(msg.sender, _spender, newAllowance);      return true;    } ```  The above change would avoid a `sload`, and will instead use `dupX`, saving \`100\` gas.   
# Handle  pauliax   # Vulnerability details  ## Impact function withdraw in ILendingPool returns the actual withdrawn amount, however, function withdraw in AaveV2 strategy does not check this return value so e.g. function strategyWithdraw may actually withdraw less but still add the full amount to the staked balance:      ps.strategy.withdraw(_amount);     ps.stakeBalance = ps.stakeBalance.add(_amount);  ## Recommended Mitigation Steps function withdraw in IStrategy should return uint indicating the actual withdrawn amount and functions that use it should account for that.  
# Handle  pauliax   # Vulnerability details  ## Impact There is no difference between functions aBalance and balanceOf in contract AaveV2, they both return aWant, so there is no point in having them separately.  ## Recommended Mitigation Steps Remove internal function aBalance and make balanceOf public.  
# Handle  pauliax   # Vulnerability details  ## Impact contract AaveV2 does not cache the lending pool, it retrieves it when necessary by calling a function getLp(). This is great as the implementation may change, however, this contract also approves an unlimited amount of want in the constructor:    ILendingPool lp = getLp();    want.approve(address(lp), uint256(-1)); so if the implementation changes, the approval will reset. This will break the deposit function as it will try to deposit to this new lending pool with 0 approval.   For reference, function setLendingPoolImpl: https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/configuration/LendingPoolAddressesProvider.sol#L58-L65   Not sure how likely is that lending pool implementation will change so marking this as 'Low'.  ## Recommended Mitigation Steps Before calling lp.deposit check that the approval is sufficient and increase otherwise.  
# Handle  cmichel   # Vulnerability details    
# Handle  jonah1005   # Vulnerability details  ## Impact Using `calldata` for function parameter is a slightly more gas efficient   ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L192-L225 ## Tools Used None ## Recommended Mitigation Steps ref: https://mudit.blog/solidity-gas-optimization-tips/   
# Handle  hickuphh3   # Vulnerability details  ### Impact  This is probably an oversight since `SafeERC20` was imported and `safeTransfer()` was used for ERC20 token transfers. Nevertheless, note that `approve()` will fail for certain token implementations that do not return a boolean value (Eg. OMG and ADX tokens). Hence it is recommend to use `safeApprove()`.  ### Recommended Mitigation Steps  Update to `_token.safeApprove(address(_native), totalToken)` in `tokenUnload()`.  
# Handle  gpersoon   # Vulnerability details  ## Impact When a large payout occurs, it will lower unallocatedSherX. This could mean some parties might not be able to get their Yield.  The first couple of users (for which harvest is called or which transfer tokens) will be able to get their full Yield,  until the moment unallocatedSherX is depleted. The next users don't get any yield at all. This doesn't seem fair.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309 function doYield(ILock token,address from, address to, uint256 amount) private { ... ps.unallocatedSherX = ps.unallocatedSherX.sub(withdrawable_amount);  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108  function payout( address _payout, IERC20[] memory _tokens, uint256[] memory _firstMoneyOut, uint256[] memory _amounts, uint256[] memory _unallocatedSherX,  address _exclude ) external override onlyGovPayout {     // all pools (including SherX pool) can be deducted fmo and balance     // deducting balance will reduce the users underlying value of stake token     // for every pool, _unallocatedSherX can be deducted, this will decrease outstanding SherX rewards     // for users that did not claim them (e.g materialized them and included in SherX pool) ....     // Subtract from unallocated, as the tokens are now allocated to this payout call         ps.unallocatedSherX = ps.unallocatedSherX.sub(unallocatedSherX);  ## Tools Used  ## Recommended Mitigation Steps If unallocatedSherX is insufficient to provide for all the yields, only give the yields partly (so that each user gets their fair share).   
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `setWeights()`, the variables `weightAdd` and `weightSub` are used to ensure that there is no difference in the total weight.  ### Recommended Mitigation Steps  Consider `totalWeightOld` and `totalWeightNew` as the variable names instead as they are more indicative of the intended usage and behaviour.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The only value from poolStorage in `updateData()` is the `sherXUnderlying` value. It is cheaper to pass this `uint256` variable instead of the storage variable itself.  ### Recommended Mitigation Steps  Change `PoolStorage.Base storage ps` to `uint256 sherXUnderlying`, saves about ~160 gas.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `updateData()`,   ```jsx if (sub > add) {   usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18)); } else {   usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18)); } ```  we can calculate the difference between `sub` and `add` in both cases without SafeMath because we already know one is greater than the other.   Also, the logic can be made similar to the `usdPool` calculation since nothing changes in the case where `sub == add`.  The same safemath subtraction avoidance can be implemented for the `usdPool` calculation.  Finally, the variables `sub` and `add` are confusing (makes the code difficult to read because of safemath's add and sub). It is suggested to rename them to `oldUsdPerBlock` and `newUsdPerBlock` respectively.  ### Recommended Mitigation Steps  ```jsx // If oldUsdPerBlock == newUsdPerBlock, nothing changes if (oldUsdPerBlock > newUsdPerBlock) {   usdPerBlock = usdPerBlock.sub((oldUsdPerBlock - newUsdPerBlock).div(10**18)); } else if (oldUsdPerBlock < newUsdPerBlock) {   usdPerBlock = usdPerBlock.add((newUsdPerBlock - oldUsdPerBlock).div(10**18)); }  if (_newUsd > _oldUsd) {  usdPool = usdPool.add((_newUsd - _oldUsd).mul(ps.sherXUnderlying).div(10**18)); } else if (_newUsd < _oldUsd) {  usdPool = usdPool.sub((_oldUsd - _newUsd).mul(ps.sherXUnderlying).div(10**18)); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - `tokens` can be directly be assigned to `gs.tokensSherX`. - Redundant zero Initialization of the array element `amounts[i] = 0;` in the else case of `calcUnderlying()` (L69-L71).  ### Recommended Mitigation Steps  ```jsx function calcUnderlying(uint256 _amount)  external  view returns (IERC20[] memory tokens, uint256[] memory amounts) {  GovStorage.Base storage gs = GovStorage.gs();    tokens = gs.tokensSherX;   amounts = new uint256[](gs.tokensSherX.length);    uint256 total = getTotalSherX();    for (uint256 i; i < gs.tokensSherX.length; i++) {     IERC20 token = tokens[i];     if (total > 0) {       PoolStorage.Base storage ps = PoolStorage.ps(token);       amounts[i] = ps.sherXUnderlying.add(LibPool.getTotalAccruedDebt(token)).mul(_amount).div(         total       );     }   } } ```  Gas reporter reports a gas reduction of ~150 gas. Gas savings should scale with number of underlying collaterals.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `tokenRemove()`, the comment `// NOTE: removed because firstMoneyOut will always be less or equal to stakeBalance` is not intuitive because it is not clear what is removed.  Perhaps `// NOTE: check that firstMoneyOut == 0 not needed since firstMoneyOut <= stakeBalance` will be better.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  For better code readability, it would be good to specify the constants `uint16(-1)`, `uint32(-1)` and `10**18` in a separate contract to be imported in relevant contracts.  - `10e17` was used in payout() instead of the conventional `10**18` defined everywhere else - The docs specified that the cooldown fee and sherX weight are scaled by `10**18`, but they are scaled by `uint32(-1)` and `uint16(-1)` respectively (interfaces natspec is correct).  ### Recommended Mitigation Steps  Consider suggestive constants like `MAX_SHERX_WEIGHT` or `SHERX_DENOM`, `MAX_COOLDOWN_FEE` or `COOLDOWN_FEE_DENOM` and `PRECISION`.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _transfer in SherXERC20.sol allow transfer to address 0. This is usually considered the same as burning the tokens and the Emit is indistinguishable from an Emit of a burn.  However the burn function in LibSherXERC20.sol has extra functionality, which _transfer doesn't have. sx20.totalSupply = sx20.totalSupply.sub(_amount);  So it is safer to prevent _transfer to address 0 (which is also done in the openzeppelin erc20 contract) See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L226  Note: minting from address 0 will not work because that is blocked by the safemath sub in:  sx20.balances[_from] = sx20.balances[_from].sub(_amount);  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherXERC20.sol#L118 function _transfer(address _from, address _to, uint256 _amount) internal {     SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();     sx20.balances[_from] = sx20.balances[_from].sub(_amount);     sx20.balances[_to] = sx20.balances[_to].add(_amount);     emit Transfer(_from, _to, _amount);   }  // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherXERC20.sol#L29 function burn(address _from, uint256 _amount) internal {     SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();     sx20.balances[_from] = sx20.balances[_from].sub(_amount);     sx20.totalSupply = sx20.totalSupply.sub(_amount);     emit Transfer(_from, address(0), _amount);   } ## Tools Used  ## Recommended Mitigation Steps add something like to following to _transfer of SherXERC20.sol:         require(_to!= address(0), "Transfer to the zero address");  Or update sx20.totalSupply if burning a desired operation.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function payout contains an expression with 3 sequential divs. This is generally not recommended because it could lead to rounding errors / loss of precision. Also a div is usually more expensive than a mul. Also an intermediate division by 0 (if SherXERC20Storage.sx20().totalSupply) == 0) could occur.  ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108 function payout( ..  uint256 deduction =  excludeUsd.div(curTotalUsdPool.div(SherXERC20Storage.sx20().totalSupply)).div(10e17);  ## Tools Used  ## Recommended Mitigation Steps Verify the formula and replace with something like: uint256 deduction =  excludeUsd.mul(SherXERC20Storage.sx20().totalSupply).div(  curTotalUsdPool.mul(10e17) )  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _updateData contains variables with the names "sub" and "add". There are also functions with the names "sub" and "add". The resulting code is not very readable:       usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18));       usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18));  Generally it is not recommended to use the same name for variables and functions.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Manager.sol#L386  function _updateData( ..     uint256 sub = _oldPremium.mul(_oldUsd);  ..    uint256 add = _newPremium.mul(_newUsd);      if (sub > add) {       usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18));     } else {       usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18));     }  ## Tools Used  ## Recommended Mitigation Steps Rename the variables "add" and "sub" to different names.   
# Handle  gpersoon   # Vulnerability details  ## Impact On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn't done.  Especially in doYield a first check is done for totalAmount >0, however a few lines later there is an other div(totalAmount) which isn't checked.  The proof of concept show another few examples.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309 function doYield(ILock token,address from,address to,uint256 amount) private { ..     uint256 totalAmount = ps.lockToken.totalSupply(); ..      if (totalAmount > 0) {       ineglible_yield_amount = ps.sWeight.mul(amount).div(totalAmount);     } else {       ineglible_yield_amount = amount;     }     if (from != address(0)) {       uint256 raw_amount = ps.sWeight.mul(userAmount).div(totalAmount);  // totalAmount could be 0, see lines above  // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L295 function activateCooldown(uint256 _amount, IERC20 _token) external override returns (uint256) { ...   uint256 tokenAmount = fee.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());   // ps.lockToken.totalSupply() might be 0  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L351  function unstake( uint256 _id, address _receiver, IERC20 _token ) external override returns (uint256 amount) { ...    amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());  // // ps.lockToken.totalSupply() might be 0  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L67  function stake( PoolStorage.Base storage ps,uint256 _amount, address _receiver ) external returns (uint256 lock) { ...      lock = _amount.mul(totalLock).div(stakeBalance(ps));   // stakeBalance(ps) might be 0  ## Tools Used  ## Recommended Mitigation Steps Make sure division by 0 won't occur by checking the variables beforehand and handling this edge case.  
# Handle  gpersoon   # Vulnerability details  ## Impact A small gas optimization is possible by replacing x > 0 with  x != 0 provide x is an unsigned integer. As the entire code only uses unsigned integers it can be done on all these locations. The proof of concept shows the locations where the "x > 0" construction is used.  ## Proof of Concept  .\facets\Gov.sol:    require(_tokens.length > 0, 'ZERO'); .\facets\Gov.sol:    if (totalToken > 0) { .\facets\Gov.sol:    if (totalFee > 0) { .\facets\Gov.sol:    if (balance > 0) { .\facets\Manager.sol:    if (ps.sherXUnderlying > 0) { .\facets\Manager.sol:    if (usdPerBlock > 0 && _currentTotalSupply == 0) { .\facets\Manager.sol:    } else if (usdPool > 0) { .\facets\Payout.sol:      if (unallocatedSherX > 0) { .\facets\Payout.sol:      if (firstMoneyOut > 0) { .\facets\Payout.sol:    if (totalUnallocatedSherX > 0) { .\facets\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolBase.sol:    if (fee > 0) { .\facets\PoolBase.sol:    if (_forceDebt && accrued > 0) { .\facets\PoolBase.sol:    if (ps.protocolBalance[_protocol] > 0) { .\facets\PoolBase.sol:    if (ps.protocolPremium[_protocol] > 0) { .\facets\PoolOpen.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolStrategy.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolStrategy.sol:    require(_amount > 0, 'AMOUNT'); .\facets\SherX.sol:    if (stakeBalance > 0) { .\facets\SherX.sol:    require(_amount > 0, 'AMOUNT'); .\facets\SherX.sol:    if (totalAmount > 0) { .\facets\SherX.sol:      if (withdrawable_amount > 0) { .\libraries\LibSherX.sol:      if (total > 0) { .\libraries\LibSherX.sol:    if (sherX > 0) { .\libraries\LibSherX.sol:    if (sherX > 0) { .\strategies\AaveV2.sol:    require(amount > 0, 'ZERO_AMOUNT');  ## Tools Used grep  ## Recommended Mitigation Steps replace x > 0 with  x != 0  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function tokenUnload, ps.stakeBalance is only deleted if balance >0 e.g it is deleted if ps.stakeBalance > ps.firstMoneyOut So if ps.stakeBalance ==  ps.firstMoneyOut then ps.stakeBalance will not be deleted. And then a call to tokenRemove will revert, because it checks for ps.stakeBalance to be 0  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L271  function tokenUnload( IERC20 _token, IRemove _native, address _remaining ) external override onlyGovMain { ...     uint256 balance = ps.stakeBalance.sub(ps.firstMoneyOut);     if (balance > 0) {       _token.safeTransfer(_remaining, balance);       delete ps.stakeBalance;     } ..   delete ps.firstMoneyOut;   function tokenRemove(IERC20 _token) external override onlyGovMain {   ...     require(ps.stakeBalance == 0, 'BALANCE_SET');   ## Tools Used  ## Recommended Mitigation Steps Check what to do in this edge case and add the appropriate code.  
# Handle  gpersoon   # Vulnerability details  ## Impact The comment "NOTE: UNUSED" can be interpreted that both protocolManagers and protocolAgents are unused. See proof of concept below. However only protocolManagers is unused.   ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L148 function protocolUpdate( bytes32 _protocol, address _eoaProtocolAgent,address _eoaManager) public override onlyGovMain { ...     // NOTE: UNUSED     gs.protocolManagers[_protocol] = _eoaManager;     gs.protocolAgents[_protocol] = _eoaProtocolAgent;   }  ## Tools Used  ## Recommended Mitigation Steps Change the comment to: // NOTE: protocolManagers UNUSED    
# Handle  gpersoon   # Vulnerability details  ## Impact The function setUnstakeWindow and setCooldown don't check that the input parameter isn't 0. So the values could accidentally be set to 0 (although unlikely). However you wouldn't want the to be 0 because that would allow attacks with flashloans (stake and unstake in the same transaction)  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L124  function setUnstakeWindow(uint40 _unstakeWindow) external override onlyGovMain {     require(_unstakeWindow < 25000000, 'MAX'); // ~ approximate 10 years of blocks     GovStorage.gs().unstakeWindow = _unstakeWindow;   }    function setCooldown(uint40 _period) external override onlyGovMain {     require(_period < 25000000, 'MAX'); // ~ approximate 10 years of blocks     GovStorage.gs().unstakeCooldown = _period;   }  ## Tools Used  ## Recommended Mitigation Steps Check the input parameter of setUnstakeWindow and setCooldown isn't 0     
# Handle  gpersoon   # Vulnerability details  ## Impact The functions getTotalUsdPool and viewAccrueUSDPool have the same implementation. It saves some gas on the deployment to integrate these functions. Also the maintenance will be a bit easier.  ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L42 function getTotalUsdPool() external view override returns (uint256) {     SherXStorage.Base storage sx = SherXStorage.sx();     return sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));   }  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L18   function viewAccrueUSDPool() public view returns (uint256 totalUsdPool) {     SherXStorage.Base storage sx = SherXStorage.sx();     totalUsdPool = sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));   }  ## Tools Used  ## Recommended Mitigation Steps Integrate the functions getTotalUsdPool and viewAccrueUSDPool (e.g. keep one and remove the other and update the references)  
# Handle  gpersoon   # Vulnerability details  ## Impact Several different solidity pragmas are uses for different solidity version. Its cleaner to use the same version everywhere  ## Proof of Concept .\ForeignLock.sol:pragma solidity ^0.7.4; .\NativeLock.sol:pragma solidity ^0.7.4; .\facets\Gov.sol:pragma solidity ^0.7.4; .\facets\GovDev.sol:pragma solidity ^0.7.0; .\facets\Manager.sol:pragma solidity ^0.7.4; .\facets\Payout.sol:pragma solidity ^0.7.4; .\facets\PoolBase.sol:pragma solidity ^0.7.4; .\facets\PoolDevOnly.sol:pragma solidity ^0.7.4; .\facets\PoolOpen.sol:pragma solidity ^0.7.4; .\facets\PoolStrategy.sol:pragma solidity ^0.7.4; .\facets\SherX.sol:pragma solidity ^0.7.4; .\facets\SherXERC20.sol:pragma solidity ^0.7.1; .\interfaces\IGov.sol:pragma solidity ^0.7.4; .\interfaces\IGovDev.sol:pragma solidity ^0.7.4; .\interfaces\ILock.sol:pragma solidity ^0.7.4; .\interfaces\IManager.sol:pragma solidity ^0.7.4; .\interfaces\IPayout.sol:pragma solidity ^0.7.4; .\interfaces\IPoolBase.sol:pragma solidity ^0.7.4; .\interfaces\IPoolStake.sol:pragma solidity ^0.7.4; .\interfaces\IPoolStrategy.sol:pragma solidity ^0.7.4; .\interfaces\IRemove.sol:pragma solidity ^0.7.4; .\interfaces\ISherlock.sol:pragma solidity ^0.7.4; .\interfaces\ISherX.sol:pragma solidity ^0.7.4; .\interfaces\ISherXERC20.sol:pragma solidity ^0.7.1; .\interfaces\IStrategy.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\DataTypes.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IAaveDistributionManager.sol:pragma solidity 0.7.6; .\interfaces\aaveV2\IAaveGovernanceV2.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IAaveIncentivesController.sol:pragma solidity 0.7.6; .\interfaces\aaveV2\IAToken.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IExecutorWithTimelock.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IGovernanceV2Helper.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\ILendingPool.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\ILendingPoolAddressesProvider.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IProposalValidator.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IStakeAave.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\MockAave.sol:pragma solidity ^0.7.4; .\libraries\LibPool.sol:pragma solidity ^0.7.4; .\libraries\LibSherX.sol:pragma solidity ^0.7.4; .\libraries\LibSherXERC20.sol:pragma solidity ^0.7.4; .\storage\GovStorage.sol:pragma solidity ^0.7.0; .\storage\PayoutStorage.sol:pragma solidity ^0.7.0; .\storage\PoolStorage.sol:pragma solidity ^0.7.0; .\storage\SherXERC20Storage.sol:pragma solidity ^0.7.1; .\storage\SherXStorage.sol:pragma solidity ^0.7.0; .\strategies\AaveV2.sol:pragma solidity ^0.7.4; .\util\ERC20Mock.sol:pragma solidity ^0.7.4; .\util\Import.sol:pragma solidity ^0.7.4; .\util\RemoveMock.sol:pragma solidity ^0.7.4; .\util\StrategyMock.sol:pragma solidity ^0.7.4;  ## Tools Used grep  ## Recommended Mitigation Steps  Use the same solidity version everywhere  
# Handle  patitonar   # Vulnerability details  ## Impact Reduce gas cost when reading the underlying variable from NativeLock given that it is only set once in the constructor  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/NativeLock.sol#L14  ## Tools Used Manual review  ## Recommended Mitigation Steps IERC20 public override immutable underlying;  
# Handle  patitonar   # Vulnerability details  ## Impact Reduce bytecode size of AaveV2 by removing Ownable given that there is no functionality for owners  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L21  ## Tools Used Manual Review  ## Recommended Mitigation Steps Update AaveV2 to only extend from IStrategy and remove Ownable import  
# Handle  patitonar   # Vulnerability details  ## Impact Reduce gas costs on constructor by not storing the result of a method invocation in a variable  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L51-L52  ## Tools Used Manual Review  ## Recommended Mitigation Steps Use the result directly. Example: want.approve(address(getLp()), uint256(-1));  
# Handle  bw   # Vulnerability details  ## Impact The `AaveV2.sol` contract made use of a number of `public` variables that were set only in the constructor and would remain constant. These variables were consuming storage slots, which unnecessarily increased the deployment and runtime gas costs of the contract.  ## Proof of Concept  ### Code Diff  ``` diff --git a/contracts/strategies/AaveV2.sol b/contracts/strategies/AaveV2.sol index 1b6ed56..9592986 100644 --- a/contracts/strategies/AaveV2.sol +++ b/contracts/strategies/AaveV2.sol @@ -21,15 +21,15 @@ import '../interfaces/IStrategy.sol';  contract AaveV2 is IStrategy, Ownable {    using SafeMath for uint256;   -  ILendingPoolAddressesProvider public lpAddressProvider = +  ILendingPoolAddressesProvider public constant lpAddressProvider =      ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5); -  IAaveIncentivesController public aaveIncentivesController; +  IAaveIncentivesController public immutable aaveIncentivesController;   -  ERC20 public override want; -  IAToken public aWant; +  ERC20 public immutable override want; +  IAToken public immutable aWant;   -  address public sherlock; -  address public aaveLmReceiver; +  address public immutable sherlock; +  address public immutable aaveLmReceiver;      modifier onlySherlock() {      require(msg.sender == sherlock, 'sherlock'); @@ -49,7 +49,7 @@ contract AaveV2 is IStrategy, Ownable {      aaveLmReceiver = _aaveLmReceiver;        ILendingPool lp = getLp(); -    want.approve(address(lp), uint256(-1)); +    ERC20(_aWant.UNDERLYING_ASSET_ADDRESS()).approve(address(lp), uint256(-1));    } ```  ### Gas Reporter Diff  ``` diff --git a/base.rst b/immutable.rst index 36b3138..79703fc 100644 --- a/base.rst +++ b/immutable.rst @@ -1,199 +1,199 @@  ----------------------------------------------------|---------------------------|-------------|-----------------------------  |                Solc version: 0.7.6                   Optimizer enabled: true    Runs: 200    Block limit: 12450000 gas    ||| -|  Methods                                                         100 gwei/gas                      2058.77 usd/eth        +|  Methods                                                         100 gwei/gas                      2061.52 usd/eth         ||||||  |  Contract        Method                             Min          Max          Avg          # calls        usd (avg)    |||||| -|  AaveV2          claimRewards                          397877       437371       417624              2        85.98   +|  AaveV2          claimRewards                          391566       431060       411313              2        84.79    |||||| -|  AaveV2          deposit                                    -            -       278549              4        57.35   +|  AaveV2          deposit                                    -            -       274205              4        56.53    |||||| -|  AaveV2          withdraw                              260005       294205       277105              2        57.05   +|  AaveV2          withdraw                              253692       287892       270792              2        55.82    |||||| -|  AaveV2          withdrawAll                            59690       275814       167752              2        34.54   +|  AaveV2          withdrawAll                            53349       267370       160360              2        33.06    |||||| |  Deployments                                                                                  % of limit                  ||||| -|  AaveV2                                                      -            -       802248          6.4 %       165.16   +|  AaveV2                                                      -            -       762851          6.1 %       157.26   ```  ### Average Improvements  | Function      | Base      | Immutable | Diff    | |---------------|-----------|-----------|---------| | claimRewards  | 417624    | 411313    | -1.53%  | | deposit       | 278549    | 274205    | -1.58%  | | withdraw      | 277105    | 270792    | -2.33%  | | withdrawAll   | 167752    | 160360    | -4.61%  | | deployment    | 802248    | 762851    | -5.16%  |  By removing the `public` keyword from all variables that are not required (which are only used in the unit tests), the deployment costs can be further reduced to `700206`, which is an 14.57% reduction in gas costs.  ## Tools Used  https://www.npmjs.com/package/hardhat-gas-reporter  ## Recommended Mitigation Steps  Add the `immutable` key word to all variables that are only set during the constructor. Add the `constant` modifier for `lpAddressProvider`.  
# Handle  shw   # Vulnerability details  ## Impact  The `_accrueSherX` function of `LibSherX` and the `payOffDebtAll` function of `LibPool` can be called multiple times in the same block (from different users and transactions). If the current block number is the same as the last-recorded one, it is possible to save gas by early returning at the beginning of the functions.  ## Proof of Concept  Referenced code: [LibSherX.sol#L123-L141](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L123-L141) [LibPool.sol#L84-L95](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L84-L95)  ## Recommended Mitigation Steps  For example, consider re-writing `_accrueSherX` as follows:  ```solidity function _accrueSherX(IERC20 _token, uint256 sherXPerBlock) private returns (uint256 sherX) {   PoolStorage.Base storage ps = PoolStorage.ps(_token);   if (block.number == ps.sherXLastAccrued) {     return 0;   }   sherX = block.number.sub(ps.sherXLastAccrued).mul(sherXPerBlock).mul(ps.sherXWeight).div(     uint16(-1)   );   // need to settle before return, as updating the sherxperlblock/weight   // after it was 0 will result in a too big amount (accured will be < block.number)   ps.sherXLastAccrued = uint40(block.number);   if (address(_token) == address(this)) {     ps.stakeBalance = ps.stakeBalance.add(sherX);   } else {     ps.unallocatedSherX = ps.unallocatedSherX.add(sherX);     ps.sWeight = ps.sWeight.add(sherX);   } } ```  
# Handle  shw   # Vulnerability details  ## Impact  A storage read cost more gas than a memory read. State variables that do not change during a loop can be stored in local variables and be read from memory multiple times to save gas.  ## Proof of Concept  Referenced code: [LibPool.sol#L89](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L89) [LibSherX.sol#L60](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L60) [LibSherX.sol#L94](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L94) [PoolBase.sol#L131](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L131) [SherX.sol#L76](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L76) [SherX.sol#L98](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L98) [SherX.sol#L152](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L152) [SherX.sol#L184](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L184) [SherX.sol#L243](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L243) [Gov.sol#L190](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L190)  ## Recommended Mitigation Steps  For example, consider re-writing the `harvestFor(address)` function of `SherX` as follows:  ```solidity function harvestFor(address _user) public override {   GovStorage.Base storage gs = GovStorage.gs();   uint256 len = gs.tokensStaker.length;   for (uint256 i; i < len; i++) {     PoolStorage.Base storage ps = PoolStorage.ps(gs.tokensStaker[i]);     harvestFor(_user, ps.lockToken);   } } ```  
# Handle  shw   # Vulnerability details  ## Impact  In the `PoolStorage` library, declaring the `POOL_STORAGE_PREFIX` constant with type `bytes32`, and change `abi.encode` ti `abi.encodePacked` at line 87 can save gas.  ## Proof of Concept  Referenced code: [PoolStorage.sol#L14](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/storage/PoolStorage.sol#L14) [PoolStorage.sol#L87](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/storage/PoolStorage.sol#L87)  Related links: [Change `string` to `byteX` if possible](https://medium.com/layerx/how-to-reduce-gas-cost-in-solidity-f2e5321e0395#2a78) [Solidity-Encode-Gas-Comparison](https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison)  ## Recommended Mitigation Steps  See above  
# Handle  shw   # Vulnerability details  ## Impact  The `calcUnderlyingInStoredUSD()` function of `SherX` should return `calcUnderlyingInStoredUSD(getSherXBalance())` instead of `calcUnderlyingInStoredUSD(sx20.balances[msg.sender])` since there could be SherX unallocated to the user at the time of the function call. A similar function, `calcUnderlying()`, calculates the user's underlying tokens based on the user's current balance plus the unallocated ones.  ## Proof of Concept  Referenced code: [SherX.sol#L141](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L141)  ## Recommended Mitigation Steps  Change `sx20.balances[msg.sender]` to `getSherXBalance()` at line 141.  
# Handle  shw   # Vulnerability details  The `getInitialUnstakeEntry` function of `PoolBase` returns the first active unstaking entry of a staker, which requires the current block to be strictly before the last block in the unstaking window. However, the `unstake` function allows the current block to be exactly the same as the last block (same logic in `unstakeWindowExpiry`).  ## Proof of Concept  Referenced code: [PoolBase.sol#L136](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L136) [PoolBase.sol#L344](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L344) [PoolBase.sol#L364](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L364)  ## Recommended Mitigation Steps  Change the `<=` comparison at line 136 to `<` for consistency.  
# Handle  shw   # Vulnerability details  ## Impact  A possible divide-by-zero error could happen in the `getSherXPerBlock(uint256, IERC20)` function of `PoolBase` when the `totalSupply` of `lockToken` and `_lock` are both 0.  ## Proof of Concept  Referenced code: [PoolBase.sol#L215](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L215)  ## Recommended Mitigation Steps  Check if `baseData().lockToken.totalSupply().add(_lock)` equals to 0 before line 214. If so, then return 0.  
# Handle  0xsanson   # Vulnerability details  ## Impact The value `10e17` can be confusing, since it doesn't clearly appear from where the exponent 17 comes from (people may ctrl+f or grep the code for other instances of it without results). Indeed throughout the code the expression `10**18` is used.  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L185  ## Tools Used editor  ## Recommended Mitigation Steps Better ways of writing it are `1e18` or `10**18`.  
# Handle  0xsanson   # Vulnerability details  ## Impact In the function `_doSherX` in Payout.sol, the natSpec comment @return states that `sherUsd` is the 'Total amount of USD of the underlying tokens that are being transferred'. I think that's a typo, and it's supposed to be the amount *excluded* from being transferred.  ## Proof of Concept Payout.sol L71  ## Tools Used editor  ## Recommended Mitigation Steps Correct the statement.  
# Handle  0xsanson   # Vulnerability details  ## Impact In the `calcUnderlying` function of LibSherX.sol, the value `gs.tokensSherX.length` can be written down once to save gas (around 300-500 when called in the present tests).  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L55-L60  ## Tools Used hardhat gas calculator  ## Recommended Mitigation Steps Suggested adding `uint256 SherXLength = gs.tokensSherX.length;` and replacing this value throughout the function (three instances).  
# Handle  tensors   # Vulnerability details  ## Impact Poorly named variables in Gov.sol  ## Proof of Concept _protocolPremium is a bool while protcolPremium is a mapping to uint. This is confusing a could potentially cause some input errors.  ## Recommended Mitigation Steps Rename variables.  
# Handle  cmichel   # Vulnerability details  Usually, the functions to increase the allowance are called `increaseAllowance` and `decreaseAllowance` but in `SherXERC20` they are called `increaseApproval` and `decreaseApproval`  ## Recommendation Rename these functions to the more common names.  
# Handle  cmichel   # Vulnerability details  The `SherXERC20.initializeSherXERC20` function has `initialize` in its name which indicates that it should only be called once to initialize the storage. But it can be repeatedly called to overwrite and update the ERC20 name and symbol.  ## Recommendation Consider an `initializer` modifier or reverting if `name` or `symbol` is already set.  
# Handle  cmichel   # Vulnerability details  The `setWeights` function only stores the `uint16` part of `_weights[i]` in storage (`ps.sherXWeight = uint16(_weights[i])`). However, to calculate `weightAdd/weightSub` the full value (not truncated to 16 bits) is used. This can lead to discrepancies as the actually added part is different from the one tracked in the `weightAdd` variable.   
# Handle  cmichel   # Vulnerability details  The `PoolBase.unstakeWindowExpiry` function allows unstaking tokens of other users. While the tokens are sent to the correct address, this can lead to issues with smart contracts that might rely on claiming the tokens themselves.  For example, suppose the `_to` address corresponds to a smart contract that has a function of the following form:  ```solidity function withdrawAndDoSomething() {     uint256 amount = token.balanceOf(address(this));     contract.unstakeWindowExpiry(address(this), id, token);     amount = amount - token.balanceOf(address(this));     token.transfer(externalWallet, amount) } ```  If the contract has no other functions to transfer out funds, they may be locked forever in this contract.  
# Handle  a_delamo   # Vulnerability details  ## Impact  The following functions are public, but they could be decla  ``` getUnactivatedStakersPoolBalance(IERC20) should be declared external:         - PoolBase.getUnactivatedStakersPoolBalance(IERC20) (contracts/facets/PoolBase.sol#146-148) getTotalUnmintedSherX(IERC20) should be declared external:         - PoolBase.getTotalUnmintedSherX(IERC20) (contracts/facets/PoolBase.sol#170-173) accruedDebt(bytes32,IERC20) should be declared external:         - LibPool.accruedDebt(bytes32,IERC20) (contracts/libraries/LibPool.sol#31-34) getTotalAccruedDebt(IERC20) should be declared external:         - LibPool.getTotalAccruedDebt(IERC20) (contracts/libraries/LibPool.sol#36-39) accrueSherX(IERC20) should be declared external:         - LibSherX.accrueSherX(IERC20) (contracts/libraries/LibSherX.sol#75-81) accrueSherXWatsons() should be declared external:         - LibSherX.accrueSherXWatsons() (contracts/libraries/LibSherX.sol#83-86) deposit() should be declared external:         - AaveV2.deposit() (contracts/strategies/AaveV2.sol#75-81) ```   ## Tools Used  Slither     
# Handle  cmichel   # Vulnerability details  The `_doSherX` function does not return the correct precision of `sherUsd` and it is **not** the "Total amount of USD of the underlying tokens that are being transferred" that the documentation mentions.  ```solidity sherUsd = amounts[i].mul(sx.tokenUSD[tokens[i]]); ```  Instead, the amount is inflated by `1e18`, it should divide the amount by `1e18` to get a USD value with 18 decimal precision.  The severity is low as the calling site in `payout` makes up for it by dividing by `1e18` in the `deduction` computation.  We still recommend returning the correct amount in `_doSherX` already to match the documentation and avoid any future errors when using its unintuitive return value.  
# Handle  cmichel   # Vulnerability details  The `Gov.tokenInit` skips the underlying token check if the `_token` is SHERX:  ```solidity if (address(_token) != address(this)) {   require(_lock.underlying() == _token, 'UNDERLYING'); } ```  ## Impact This check should still be performed even for `_token == address(this) // SHERX`, otherwise, the lock can have a different underlying and potentially pay out wrong tokens.  ## Recommendation Verify the underlying of all locks.  
# Handle  cmichel   # Vulnerability details  The `SherXERC20.transferFrom` function reads the allowance from memory twice. It should be read once, cached, and then use that value for the `if(cachedAllowance ...)` and for the `newApproval = ...` expressions.  
# Handle  cmichel   # Vulnerability details  The `SherXERC20.increaseApproval` function reads the allowance from memory twice. It should be read once and then cached and for the event you the `cache + _amount` value.  
# Handle  hrkrshnn   # Vulnerability details  ## A critical bug in bps function: PoolBase.sol  ``` solidity function bps() internal pure returns (IERC20 rt) {   // These fields are not accessible from assembly   bytes memory array = msg.data;   uint256 index = msg.data.length;    // solhint-disable-next-line no-inline-assembly   assembly {     // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.     rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)   } } ```  The above function is designed to expect the token at the end of `calldata`, but a malicious user can inject extra values at the end of `calldata` and fake return values.  The following contract demonstrates an example:  ``` solidity pragma solidity 0.8.6;  interface IERC20 {}  error StaticCallFailed();  contract BadEncoding {     /// Will return address(1). But address(0) is expected!     function f() external view returns (address) {         address actual = address(0);         address injected = address(1);          (bool success, bytes memory ret) = address(this).staticcall(abi.encodeWithSelector(this.g.selector, actual, injected));          if (!success) revert StaticCallFailed();          return abi.decode(ret, (address));     }     function g(IERC20 _token) external pure returns (IERC20) {         // to get rid of the unused warning         _token;         // Does it always match _token?         return bps();     }     // From Sherlock Protocol: PoolBase.sol     function bps() internal pure returns (IERC20 rt) {         // These fields are not accessible from assembly         bytes memory array = msg.data;         uint256 index = msg.data.length;          // solhint-disable-next-line no-inline-assembly         assembly {             // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.             rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)         }     } } ```  ### An example exploit  This can be used to exploit the protocol:  ``` solidity function unstake(   uint256 _id,   address _receiver,   IERC20 _token ) external override returns (uint256 amount) {   PoolStorage.Base storage ps = baseData();   require(_receiver != address(0), 'RECEIVER');   GovStorage.Base storage gs = GovStorage.gs();   PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];   require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');   // period is including   require(withdraw.blockInitiated + gs.unstakeCooldown < uint40(block.number), 'COOLDOWN_ACTIVE');   require(     withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow >= uint40(block.number),     'UNSTAKE_WINDOW_EXPIRED'   );   amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());    ps.stakeBalance = ps.stakeBalance.sub(amount);   delete ps.unstakeEntries[msg.sender][_id];   ps.lockToken.burn(address(this), withdraw.lock);   _token.safeTransfer(_receiver, amount); } ```  State token `Token1`. Let's say there is a more expensive token `Token2`.  Here's an example exploit:  ``` solidity bytes memory exploitPayload = abi.encodeWithSignature(     PoolBase.unstake.selector,     (uint256(_id), address(_receiver), address(Token2), address(Token1)) ); poolAddress.call(exploitPayload); ```  All the calculations on `ps` would be done on `Token2`, but at the end, because of, `_token.safeTransfer(_receiver, amount);`, `Token2` would be transferred. Assuming that `Token2` is more expensive than `Token1`, the attacker makes a profit.  Similarly, the same technique can be used at a lot of other places. Even if this exploit is not profitable, the fact that the computations can be done on two different tokens is buggy.  There are several other places where the same pattern is used. All of them needs to be fixed. I've not written an exhaustive list.   
# Handle  hrkrshnn   # Vulnerability details  ## Use `type(uintX).max` instead of `uintX(-1)`  ``` diff modified   contracts/facets/Gov.sol @@ -55,7 +55,7 @@ contract Gov is IGov {      GovStorage.Base storage gs = GovStorage.gs();      SherXStorage.Base storage sx = SherXStorage.sx();  -    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(uint16(-1)); +    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(type(uint16).max);    }     function getWatsonsUnmintedSherX() external view override returns (uint256) { ```  Use `type(integerType).max` for such cases. There are also other places that could use this.  ## Have NatSpec comments for all functions ## Avoid the diamond standard  The most significant optimization that can be done in the contract is to get rid of the diamond standard, because, proxy architectures are inherently expensive. Unless there are specific reasons, such as contract size limits, a diamond makes the contract unnecessary complex. Also, try to avoid upgradability if you can afford it.   
# Handle  hrkrshnn   # Vulnerability details  ## Change memory to calldata and caching in loop  ``` diff modified   contracts/facets/Manager.sol @@ -139,16 +139,17 @@ contract Manager is IManager {     function setProtocolPremiumAndTokenPrice(      bytes32 _protocol, -    IERC20[] memory _token, -    uint256[] memory _premium, -    uint256[] memory _newUsd +    IERC20[] calldata _token, +    uint256[] calldata _premium, +    uint256[] calldata _newUsd    ) external override onlyGovMain {      require(_token.length == _premium.length, 'LENGTH_1');      require(_token.length == _newUsd.length, 'LENGTH_2');       (uint256 usdPerBlock, uint256 usdPool) = _getData();  -    for (uint256 i; i < _token.length; i++) { +    uint length = _token.length; +    for (uint256 i; i < length; i++) {        LibPool.payOffDebtAll(_token[i]);        (usdPerBlock, usdPool) = _setProtocolPremiumAndTokenPrice(          _protocol, ```  About caching in loop, see my other report on why it's needed.  For the old code, i.e., having an array in memory, there is an unnecessary copy from `calldata` to `memory`. In the proposed patch, this unnecessary copy is avoided and values are directly read from `calldata` by using `calldataload(...)` instead of going via `calldatacopy(...)`, then `mload(...)`). Saves memory expansion cost, and cost of copying from `calldata` to `memory`.  There are several other places throughout the codebase where the same optimization can be used. I've not provided an exhaustive list.   
# Handle  hrkrshnn   # Vulnerability details  ## Caching in for loops  ``` diff modified   contracts/facets/PoolBase.sol @@ -128,19 +128,21 @@ contract PoolBase is IPoolBase {    {      PoolStorage.Base storage ps = baseData();      GovStorage.Base storage gs = GovStorage.gs(); -    for (uint256 i = 0; i < ps.unstakeEntries[_staker].length; i++) { -      if (ps.unstakeEntries[_staker][i].blockInitiated == 0) { +    PoolStorage.UnstakeEntry[] storage entries = ps.unstakeEntries[_staker]; +    uint length = entries.length; +    for (uint256 i = 0; i < length; i++) { +      if (entries[i].blockInitiated == 0) {          continue;        }        if ( -        ps.unstakeEntries[_staker][i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <= +        entries[i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <=          uint40(block.number)        ) {          continue;        }        return i;      } -    return ps.unstakeEntries[_staker].length; +    return length;    } ```  Caching expensive state variables would avoid re-reading from storage. Solidity's optimizer currently will not be able to cache this value (the IR based codegen and the Yul optimizer can do it; but that is not activated by default).   
# Handle  hrkrshnn   # Vulnerability details  ## Packing the struct  ``` diff modified   contracts/storage/GovStorage.sol @@ -14,15 +14,17 @@ library GovStorage {    struct Base {      // The address appointed as the govMain entity      address govMain; +    // The amount of blocks the cooldown period takes +    uint40 unstakeCooldown; +    // The amount of blocks for the window of opportunity of unstaking +    uint40 unstakeWindow; +    // Check if the protocol is included in the solution at all +    uint16 watsonsSherxWeight; +    // The last block the total amount of rewards were accrued.      // NOTE: UNUSED      mapping(bytes32 => address) protocolManagers;      // Based on the protocol identifier, get the address of the protocol that is able the withdraw balances      mapping(bytes32 => address) protocolAgents; -    // The amount of blocks the cooldown period takes -    uint40 unstakeCooldown; -    // The amount of blocks for the window of opportunity of unstaking -    uint40 unstakeWindow; -    // Check if the protocol is included in the solution at all      mapping(bytes32 => bool) protocolIsCovered;      // The array of tokens the accounts are able to stake in      IERC20[] tokensStaker; @@ -33,8 +35,6 @@ library GovStorage {      address watsonsAddress;      // How much sherX is distributed to this account      // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this acocunt -    uint16 watsonsSherxWeight; -    // The last block the total amount of rewards were accrued.      uint40 watsonsSherxLastAccrued;    } ```  In the current layout, the members `govMain`, `unstakeCooldown`, `unstakeWindow`, `watsonsSherxWeight` all can be packed to a single slot or exactly 256 bits. This can save gas if both such elements are read or written at the same time (please use at least 0.8.2, since it has some improvements centred around optimizing packed Structs).  In the previous layout:  1.  `govMain` would have a slot of its own. 2.  `unstakeCooldown` and `unstakeWindow` would be packed together in a     single slot. 3.  `watsonsSherxWeight` and `watsonsSherxLastAccrued` would be packed     together in a single slot.  Note that gas savings are mainly relevant in the following cases:  1.  Compiler can optimize certain reads and writes to the same slot. 2.  Berlin EIP-2929 based gas accounting, i.e., if the same tx leaves     one of the slot warm. 3.  Berlin EIP-2930 for access lists. Instead of having to making three     different slots warm (in the original code), one only has to make     two slots warm, if necessary.  If none of these applies for your case, this suggestion may be ignored.  ## Packing for PoolStorage  ``` diff modified   contracts/storage/PoolStorage.sol @@ -15,20 +15,35 @@ library PoolStorage {     struct Base {      address govPool; +    // The last block the total amount of rewards were accrued. +    // Accrueing SherX increases the `unallocatedSherX` variable +    uint40 sherXLastAccrued; +    // Protocol debt can only be settled at once for all the protocols at the same time +    // This variable is the block number the last time all the protocols debt was settled +    uint40 totalPremiumLastPaid; + +    // How much sherX is distributed to stakers of this token +    // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this pool +    uint16 sherXWeight;      //      // Staking      //      // Indicates if stakers can stake funds in the pool      bool stakes; -    // Address of the lockToken. Representing stakes in this pool -    ILock lockToken;      // Variable used to calculate the fee when activating the cooldown      // Max value is uint32(-1) which creates a 100% fee on the withdrawal      uint32 activateCooldownFee; +    // Address of the lockToken. Representing stakes in this pool +    // Indicates if protocol are able to pay premiums with this token +    // If this value is true, the token is also included as underlying of the SherX +    bool premiums; + +    ILock lockToken;      // The total amount staked by the stakers in this pool, including value of `firstMoneyOut`      // if you exclude the `firstMoneyOut` from this value, you get the actual amount of tokens staked      // This value is also excluding funds deposited in a strategy.      uint256 stakeBalance; +      // All the withdrawals by an account      // The values of the struct are all deleted if expiry() or unstake() function is called      mapping(address => UnstakeEntry[]) unstakeEntries; @@ -39,12 +54,6 @@ library PoolStorage {      // SherX could be minted before the stakers call the harvest() function      // Minted SherX that is assigned as reward for the pool will be added to this value      uint256 unallocatedSherX; -    // How much sherX is distributed to stakers of this token -    // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this pool -    uint16 sherXWeight; -    // The last block the total amount of rewards were accrued. -    // Accrueing SherX increases the `unallocatedSherX` variable -    uint40 sherXLastAccrued;      // Non-native variables      // These variables are used to calculate the right amount of SherX rewards for the token staked      mapping(address => uint256) sWithdrawn; @@ -52,9 +61,6 @@ library PoolStorage {      //      // Protocol payments      // -    // Indicates if protocol are able to pay premiums with this token -    // If this value is true, the token is also included as underlying of the SherX -    bool premiums;      // Storing the protocol token balance based on the protocols bytes32 indentifier      mapping(bytes32 => uint256) protocolBalance;      // Storing the protocol premium, the amount of debt the protocol builds up per block. @@ -62,9 +68,6 @@ library PoolStorage {      mapping(bytes32 => uint256) protocolPremium;      // The sum of all the protocol premiums, the total amount of debt that builds up in this token. (per block)      uint256 totalPremiumPerBlock; -    // Protocol debt can only be settled at once for all the protocols at the same time -    // This variable is the block number the last time all the protocols debt was settled -    uint40 totalPremiumLastPaid;      // How much token (this) is available for sherX holders      uint256 sherXUnderlying;      // Check if the protocol is included in the token pool ```  For the same reasons as before. Taking a quick look at the code, this change should reduce gas. (Might require 0.8.2, though; there was an improvement in the optimizer that would apply to packed structs in storage.)   
# Handle  hrkrshnn   # Vulnerability details  ## Higher value of optimize-runs  ``` diff modified   hardhat.config.js @@ -25,7 +25,7 @@ module.exports = {      settings: {        optimizer: {          enabled: true, -        runs: 200, +        runs: 20000,        },      },    }, ```  This value is a tuning parameter for deploy v/s runtime costs. Higher values optimize for lower runtime cost, which is what you are looking for. The above value is an example, please decide a suitable high value, and run tests.  
# Handle  hrkrshnn   # Vulnerability details  ## Writing a branch less version  ``` diff @@ -76,11 +77,11 @@ contract SherXERC20 is IERC20, ISherXERC20 {      require(_amount != 0, 'AMOUNT');      SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();      uint256 oldValue = sx20.allowances[msg.sender][_spender]; -    if (_amount > oldValue) { -      sx20.allowances[msg.sender][_spender] = 0; -    } else { -      sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount); -    } +    uint256 newValue; +    assembly { +        newValue := mul(gt(oldValue, _amount), sub(oldValue, _amount)) +    } +    sx20.allowances[msg.sender][_spender] = newValue;      emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]);      return true;    } ```  The branch-less version avoids at least two `jumpi`, i.e., at least 20 gas and some additional stack operations, along with deploy costs.  Here's a SMT proof that the transformation is equivalent:  ``` python from z3 import *  # A SMT proof that # # if (_amount > oldValue) { #   sx20.allowances[msg.sender][_spender] = 0; # } else { #   sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount); # } # # is same as # # assembly { #     newValue := mul(gt(oldValue, _amount), sub(oldValue, _amount)) # } # sx20.allowances[msg.sender][_spender] = newValue; #  n_bits = 256 amount = BitVec('amount', n_bits) oldValue = BitVec('oldValue', n_bits) allowance = BitVec('oldValue', n_bits)  old_allowance_computation = If(UGT(amount, oldValue), 0, oldValue - amount)  def GT(x, y):     return If(UGT(x, y), BitVecVal(1, n_bits), BitVecVal(0, n_bits)) def MUL(x, y):     return x * y def SUB(x, y):     return x - y  new_allowance_computation = MUL(GT(oldValue, amount), SUB(oldValue, amount))  solver = Solver() solver.add(old_allowance_computation != new_allowance_computation)  result = solver.check() print(result) # unsat ```   
# Handle  hrkrshnn   # Vulnerability details  ## Caching variable  ``` diff modified   contracts/facets/SherXERC20.sol @@ -66,8 +66,9 @@ contract SherXERC20 is IERC20, ISherXERC20 {      require(_spender != address(0), 'SPENDER');      require(_amount != 0, 'AMOUNT');      SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20(); -    sx20.allowances[msg.sender][_spender] = sx20.allowances[msg.sender][_spender].add(_amount); -    emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]); +    uint256 newAllowance = sx20.allowances[msg.sender][_spender].add(_amount); +    sx20.allowances[msg.sender][_spender] = newAllowance; +    emit Approval(msg.sender, _spender, newAllowance);      return true;    } ```  The above change would avoid a `sload`, and will instead use `dupX`, saving \`100\` gas.   
# Handle  pauliax   # Vulnerability details  ## Impact function withdraw in ILendingPool returns the actual withdrawn amount, however, function withdraw in AaveV2 strategy does not check this return value so e.g. function strategyWithdraw may actually withdraw less but still add the full amount to the staked balance:      ps.strategy.withdraw(_amount);     ps.stakeBalance = ps.stakeBalance.add(_amount);  ## Recommended Mitigation Steps function withdraw in IStrategy should return uint indicating the actual withdrawn amount and functions that use it should account for that.  
# Handle  pauliax   # Vulnerability details  ## Impact There is no difference between functions aBalance and balanceOf in contract AaveV2, they both return aWant, so there is no point in having them separately.  ## Recommended Mitigation Steps Remove internal function aBalance and make balanceOf public.  
# Handle  pauliax   # Vulnerability details  ## Impact contract AaveV2 does not cache the lending pool, it retrieves it when necessary by calling a function getLp(). This is great as the implementation may change, however, this contract also approves an unlimited amount of want in the constructor:    ILendingPool lp = getLp();    want.approve(address(lp), uint256(-1)); so if the implementation changes, the approval will reset. This will break the deposit function as it will try to deposit to this new lending pool with 0 approval.   For reference, function setLendingPoolImpl: https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/configuration/LendingPoolAddressesProvider.sol#L58-L65   Not sure how likely is that lending pool implementation will change so marking this as 'Low'.  ## Recommended Mitigation Steps Before calling lp.deposit check that the approval is sufficient and increase otherwise.  
# Handle  cmichel   # Vulnerability details    
# Handle  jonah1005   # Vulnerability details  ## Impact Using `calldata` for function parameter is a slightly more gas efficient   ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L192-L225 ## Tools Used None ## Recommended Mitigation Steps ref: https://mudit.blog/solidity-gas-optimization-tips/   
# Handle  hickuphh3   # Vulnerability details  ### Impact  This is probably an oversight since `SafeERC20` was imported and `safeTransfer()` was used for ERC20 token transfers. Nevertheless, note that `approve()` will fail for certain token implementations that do not return a boolean value (Eg. OMG and ADX tokens). Hence it is recommend to use `safeApprove()`.  ### Recommended Mitigation Steps  Update to `_token.safeApprove(address(_native), totalToken)` in `tokenUnload()`.  
# Handle  gpersoon   # Vulnerability details  ## Impact When a large payout occurs, it will lower unallocatedSherX. This could mean some parties might not be able to get their Yield.  The first couple of users (for which harvest is called or which transfer tokens) will be able to get their full Yield,  until the moment unallocatedSherX is depleted. The next users don't get any yield at all. This doesn't seem fair.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309 function doYield(ILock token,address from, address to, uint256 amount) private { ... ps.unallocatedSherX = ps.unallocatedSherX.sub(withdrawable_amount);  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108  function payout( address _payout, IERC20[] memory _tokens, uint256[] memory _firstMoneyOut, uint256[] memory _amounts, uint256[] memory _unallocatedSherX,  address _exclude ) external override onlyGovPayout {     // all pools (including SherX pool) can be deducted fmo and balance     // deducting balance will reduce the users underlying value of stake token     // for every pool, _unallocatedSherX can be deducted, this will decrease outstanding SherX rewards     // for users that did not claim them (e.g materialized them and included in SherX pool) ....     // Subtract from unallocated, as the tokens are now allocated to this payout call         ps.unallocatedSherX = ps.unallocatedSherX.sub(unallocatedSherX);  ## Tools Used  ## Recommended Mitigation Steps If unallocatedSherX is insufficient to provide for all the yields, only give the yields partly (so that each user gets their fair share).   
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `setWeights()`, the variables `weightAdd` and `weightSub` are used to ensure that there is no difference in the total weight.  ### Recommended Mitigation Steps  Consider `totalWeightOld` and `totalWeightNew` as the variable names instead as they are more indicative of the intended usage and behaviour.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The only value from poolStorage in `updateData()` is the `sherXUnderlying` value. It is cheaper to pass this `uint256` variable instead of the storage variable itself.  ### Recommended Mitigation Steps  Change `PoolStorage.Base storage ps` to `uint256 sherXUnderlying`, saves about ~160 gas.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `updateData()`,   ```jsx if (sub > add) {   usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18)); } else {   usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18)); } ```  we can calculate the difference between `sub` and `add` in both cases without SafeMath because we already know one is greater than the other.   Also, the logic can be made similar to the `usdPool` calculation since nothing changes in the case where `sub == add`.  The same safemath subtraction avoidance can be implemented for the `usdPool` calculation.  Finally, the variables `sub` and `add` are confusing (makes the code difficult to read because of safemath's add and sub). It is suggested to rename them to `oldUsdPerBlock` and `newUsdPerBlock` respectively.  ### Recommended Mitigation Steps  ```jsx // If oldUsdPerBlock == newUsdPerBlock, nothing changes if (oldUsdPerBlock > newUsdPerBlock) {   usdPerBlock = usdPerBlock.sub((oldUsdPerBlock - newUsdPerBlock).div(10**18)); } else if (oldUsdPerBlock < newUsdPerBlock) {   usdPerBlock = usdPerBlock.add((newUsdPerBlock - oldUsdPerBlock).div(10**18)); }  if (_newUsd > _oldUsd) {  usdPool = usdPool.add((_newUsd - _oldUsd).mul(ps.sherXUnderlying).div(10**18)); } else if (_newUsd < _oldUsd) {  usdPool = usdPool.sub((_oldUsd - _newUsd).mul(ps.sherXUnderlying).div(10**18)); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - `tokens` can be directly be assigned to `gs.tokensSherX`. - Redundant zero Initialization of the array element `amounts[i] = 0;` in the else case of `calcUnderlying()` (L69-L71).  ### Recommended Mitigation Steps  ```jsx function calcUnderlying(uint256 _amount)  external  view returns (IERC20[] memory tokens, uint256[] memory amounts) {  GovStorage.Base storage gs = GovStorage.gs();    tokens = gs.tokensSherX;   amounts = new uint256[](gs.tokensSherX.length);    uint256 total = getTotalSherX();    for (uint256 i; i < gs.tokensSherX.length; i++) {     IERC20 token = tokens[i];     if (total > 0) {       PoolStorage.Base storage ps = PoolStorage.ps(token);       amounts[i] = ps.sherXUnderlying.add(LibPool.getTotalAccruedDebt(token)).mul(_amount).div(         total       );     }   } } ```  Gas reporter reports a gas reduction of ~150 gas. Gas savings should scale with number of underlying collaterals.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `tokenRemove()`, the comment `// NOTE: removed because firstMoneyOut will always be less or equal to stakeBalance` is not intuitive because it is not clear what is removed.  Perhaps `// NOTE: check that firstMoneyOut == 0 not needed since firstMoneyOut <= stakeBalance` will be better.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  For better code readability, it would be good to specify the constants `uint16(-1)`, `uint32(-1)` and `10**18` in a separate contract to be imported in relevant contracts.  - `10e17` was used in payout() instead of the conventional `10**18` defined everywhere else - The docs specified that the cooldown fee and sherX weight are scaled by `10**18`, but they are scaled by `uint32(-1)` and `uint16(-1)` respectively (interfaces natspec is correct).  ### Recommended Mitigation Steps  Consider suggestive constants like `MAX_SHERX_WEIGHT` or `SHERX_DENOM`, `MAX_COOLDOWN_FEE` or `COOLDOWN_FEE_DENOM` and `PRECISION`.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _transfer in SherXERC20.sol allow transfer to address 0. This is usually considered the same as burning the tokens and the Emit is indistinguishable from an Emit of a burn.  However the burn function in LibSherXERC20.sol has extra functionality, which _transfer doesn't have. sx20.totalSupply = sx20.totalSupply.sub(_amount);  So it is safer to prevent _transfer to address 0 (which is also done in the openzeppelin erc20 contract) See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L226  Note: minting from address 0 will not work because that is blocked by the safemath sub in:  sx20.balances[_from] = sx20.balances[_from].sub(_amount);  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherXERC20.sol#L118 function _transfer(address _from, address _to, uint256 _amount) internal {     SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();     sx20.balances[_from] = sx20.balances[_from].sub(_amount);     sx20.balances[_to] = sx20.balances[_to].add(_amount);     emit Transfer(_from, _to, _amount);   }  // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherXERC20.sol#L29 function burn(address _from, uint256 _amount) internal {     SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();     sx20.balances[_from] = sx20.balances[_from].sub(_amount);     sx20.totalSupply = sx20.totalSupply.sub(_amount);     emit Transfer(_from, address(0), _amount);   } ## Tools Used  ## Recommended Mitigation Steps add something like to following to _transfer of SherXERC20.sol:         require(_to!= address(0), "Transfer to the zero address");  Or update sx20.totalSupply if burning a desired operation.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function payout contains an expression with 3 sequential divs. This is generally not recommended because it could lead to rounding errors / loss of precision. Also a div is usually more expensive than a mul. Also an intermediate division by 0 (if SherXERC20Storage.sx20().totalSupply) == 0) could occur.  ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108 function payout( ..  uint256 deduction =  excludeUsd.div(curTotalUsdPool.div(SherXERC20Storage.sx20().totalSupply)).div(10e17);  ## Tools Used  ## Recommended Mitigation Steps Verify the formula and replace with something like: uint256 deduction =  excludeUsd.mul(SherXERC20Storage.sx20().totalSupply).div(  curTotalUsdPool.mul(10e17) )  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _updateData contains variables with the names "sub" and "add". There are also functions with the names "sub" and "add". The resulting code is not very readable:       usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18));       usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18));  Generally it is not recommended to use the same name for variables and functions.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Manager.sol#L386  function _updateData( ..     uint256 sub = _oldPremium.mul(_oldUsd);  ..    uint256 add = _newPremium.mul(_newUsd);      if (sub > add) {       usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18));     } else {       usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18));     }  ## Tools Used  ## Recommended Mitigation Steps Rename the variables "add" and "sub" to different names.   
# Handle  gpersoon   # Vulnerability details  ## Impact On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn't done.  Especially in doYield a first check is done for totalAmount >0, however a few lines later there is an other div(totalAmount) which isn't checked.  The proof of concept show another few examples.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309 function doYield(ILock token,address from,address to,uint256 amount) private { ..     uint256 totalAmount = ps.lockToken.totalSupply(); ..      if (totalAmount > 0) {       ineglible_yield_amount = ps.sWeight.mul(amount).div(totalAmount);     } else {       ineglible_yield_amount = amount;     }     if (from != address(0)) {       uint256 raw_amount = ps.sWeight.mul(userAmount).div(totalAmount);  // totalAmount could be 0, see lines above  // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L295 function activateCooldown(uint256 _amount, IERC20 _token) external override returns (uint256) { ...   uint256 tokenAmount = fee.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());   // ps.lockToken.totalSupply() might be 0  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L351  function unstake( uint256 _id, address _receiver, IERC20 _token ) external override returns (uint256 amount) { ...    amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());  // // ps.lockToken.totalSupply() might be 0  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L67  function stake( PoolStorage.Base storage ps,uint256 _amount, address _receiver ) external returns (uint256 lock) { ...      lock = _amount.mul(totalLock).div(stakeBalance(ps));   // stakeBalance(ps) might be 0  ## Tools Used  ## Recommended Mitigation Steps Make sure division by 0 won't occur by checking the variables beforehand and handling this edge case.  
# Handle  gpersoon   # Vulnerability details  ## Impact A small gas optimization is possible by replacing x > 0 with  x != 0 provide x is an unsigned integer. As the entire code only uses unsigned integers it can be done on all these locations. The proof of concept shows the locations where the "x > 0" construction is used.  ## Proof of Concept  .\facets\Gov.sol:    require(_tokens.length > 0, 'ZERO'); .\facets\Gov.sol:    if (totalToken > 0) { .\facets\Gov.sol:    if (totalFee > 0) { .\facets\Gov.sol:    if (balance > 0) { .\facets\Manager.sol:    if (ps.sherXUnderlying > 0) { .\facets\Manager.sol:    if (usdPerBlock > 0 && _currentTotalSupply == 0) { .\facets\Manager.sol:    } else if (usdPool > 0) { .\facets\Payout.sol:      if (unallocatedSherX > 0) { .\facets\Payout.sol:      if (firstMoneyOut > 0) { .\facets\Payout.sol:    if (totalUnallocatedSherX > 0) { .\facets\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolBase.sol:    if (fee > 0) { .\facets\PoolBase.sol:    if (_forceDebt && accrued > 0) { .\facets\PoolBase.sol:    if (ps.protocolBalance[_protocol] > 0) { .\facets\PoolBase.sol:    if (ps.protocolPremium[_protocol] > 0) { .\facets\PoolOpen.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolStrategy.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolStrategy.sol:    require(_amount > 0, 'AMOUNT'); .\facets\SherX.sol:    if (stakeBalance > 0) { .\facets\SherX.sol:    require(_amount > 0, 'AMOUNT'); .\facets\SherX.sol:    if (totalAmount > 0) { .\facets\SherX.sol:      if (withdrawable_amount > 0) { .\libraries\LibSherX.sol:      if (total > 0) { .\libraries\LibSherX.sol:    if (sherX > 0) { .\libraries\LibSherX.sol:    if (sherX > 0) { .\strategies\AaveV2.sol:    require(amount > 0, 'ZERO_AMOUNT');  ## Tools Used grep  ## Recommended Mitigation Steps replace x > 0 with  x != 0  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function tokenUnload, ps.stakeBalance is only deleted if balance >0 e.g it is deleted if ps.stakeBalance > ps.firstMoneyOut So if ps.stakeBalance ==  ps.firstMoneyOut then ps.stakeBalance will not be deleted. And then a call to tokenRemove will revert, because it checks for ps.stakeBalance to be 0  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L271  function tokenUnload( IERC20 _token, IRemove _native, address _remaining ) external override onlyGovMain { ...     uint256 balance = ps.stakeBalance.sub(ps.firstMoneyOut);     if (balance > 0) {       _token.safeTransfer(_remaining, balance);       delete ps.stakeBalance;     } ..   delete ps.firstMoneyOut;   function tokenRemove(IERC20 _token) external override onlyGovMain {   ...     require(ps.stakeBalance == 0, 'BALANCE_SET');   ## Tools Used  ## Recommended Mitigation Steps Check what to do in this edge case and add the appropriate code.  
# Handle  gpersoon   # Vulnerability details  ## Impact The comment "NOTE: UNUSED" can be interpreted that both protocolManagers and protocolAgents are unused. See proof of concept below. However only protocolManagers is unused.   ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L148 function protocolUpdate( bytes32 _protocol, address _eoaProtocolAgent,address _eoaManager) public override onlyGovMain { ...     // NOTE: UNUSED     gs.protocolManagers[_protocol] = _eoaManager;     gs.protocolAgents[_protocol] = _eoaProtocolAgent;   }  ## Tools Used  ## Recommended Mitigation Steps Change the comment to: // NOTE: protocolManagers UNUSED    
# Handle  gpersoon   # Vulnerability details  ## Impact The function setUnstakeWindow and setCooldown don't check that the input parameter isn't 0. So the values could accidentally be set to 0 (although unlikely). However you wouldn't want the to be 0 because that would allow attacks with flashloans (stake and unstake in the same transaction)  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L124  function setUnstakeWindow(uint40 _unstakeWindow) external override onlyGovMain {     require(_unstakeWindow < 25000000, 'MAX'); // ~ approximate 10 years of blocks     GovStorage.gs().unstakeWindow = _unstakeWindow;   }    function setCooldown(uint40 _period) external override onlyGovMain {     require(_period < 25000000, 'MAX'); // ~ approximate 10 years of blocks     GovStorage.gs().unstakeCooldown = _period;   }  ## Tools Used  ## Recommended Mitigation Steps Check the input parameter of setUnstakeWindow and setCooldown isn't 0     
# Handle  gpersoon   # Vulnerability details  ## Impact The functions getTotalUsdPool and viewAccrueUSDPool have the same implementation. It saves some gas on the deployment to integrate these functions. Also the maintenance will be a bit easier.  ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L42 function getTotalUsdPool() external view override returns (uint256) {     SherXStorage.Base storage sx = SherXStorage.sx();     return sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));   }  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L18   function viewAccrueUSDPool() public view returns (uint256 totalUsdPool) {     SherXStorage.Base storage sx = SherXStorage.sx();     totalUsdPool = sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));   }  ## Tools Used  ## Recommended Mitigation Steps Integrate the functions getTotalUsdPool and viewAccrueUSDPool (e.g. keep one and remove the other and update the references)  
# Handle  gpersoon   # Vulnerability details  ## Impact Several different solidity pragmas are uses for different solidity version. Its cleaner to use the same version everywhere  ## Proof of Concept .\ForeignLock.sol:pragma solidity ^0.7.4; .\NativeLock.sol:pragma solidity ^0.7.4; .\facets\Gov.sol:pragma solidity ^0.7.4; .\facets\GovDev.sol:pragma solidity ^0.7.0; .\facets\Manager.sol:pragma solidity ^0.7.4; .\facets\Payout.sol:pragma solidity ^0.7.4; .\facets\PoolBase.sol:pragma solidity ^0.7.4; .\facets\PoolDevOnly.sol:pragma solidity ^0.7.4; .\facets\PoolOpen.sol:pragma solidity ^0.7.4; .\facets\PoolStrategy.sol:pragma solidity ^0.7.4; .\facets\SherX.sol:pragma solidity ^0.7.4; .\facets\SherXERC20.sol:pragma solidity ^0.7.1; .\interfaces\IGov.sol:pragma solidity ^0.7.4; .\interfaces\IGovDev.sol:pragma solidity ^0.7.4; .\interfaces\ILock.sol:pragma solidity ^0.7.4; .\interfaces\IManager.sol:pragma solidity ^0.7.4; .\interfaces\IPayout.sol:pragma solidity ^0.7.4; .\interfaces\IPoolBase.sol:pragma solidity ^0.7.4; .\interfaces\IPoolStake.sol:pragma solidity ^0.7.4; .\interfaces\IPoolStrategy.sol:pragma solidity ^0.7.4; .\interfaces\IRemove.sol:pragma solidity ^0.7.4; .\interfaces\ISherlock.sol:pragma solidity ^0.7.4; .\interfaces\ISherX.sol:pragma solidity ^0.7.4; .\interfaces\ISherXERC20.sol:pragma solidity ^0.7.1; .\interfaces\IStrategy.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\DataTypes.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IAaveDistributionManager.sol:pragma solidity 0.7.6; .\interfaces\aaveV2\IAaveGovernanceV2.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IAaveIncentivesController.sol:pragma solidity 0.7.6; .\interfaces\aaveV2\IAToken.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IExecutorWithTimelock.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IGovernanceV2Helper.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\ILendingPool.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\ILendingPoolAddressesProvider.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IProposalValidator.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IStakeAave.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\MockAave.sol:pragma solidity ^0.7.4; .\libraries\LibPool.sol:pragma solidity ^0.7.4; .\libraries\LibSherX.sol:pragma solidity ^0.7.4; .\libraries\LibSherXERC20.sol:pragma solidity ^0.7.4; .\storage\GovStorage.sol:pragma solidity ^0.7.0; .\storage\PayoutStorage.sol:pragma solidity ^0.7.0; .\storage\PoolStorage.sol:pragma solidity ^0.7.0; .\storage\SherXERC20Storage.sol:pragma solidity ^0.7.1; .\storage\SherXStorage.sol:pragma solidity ^0.7.0; .\strategies\AaveV2.sol:pragma solidity ^0.7.4; .\util\ERC20Mock.sol:pragma solidity ^0.7.4; .\util\Import.sol:pragma solidity ^0.7.4; .\util\RemoveMock.sol:pragma solidity ^0.7.4; .\util\StrategyMock.sol:pragma solidity ^0.7.4;  ## Tools Used grep  ## Recommended Mitigation Steps  Use the same solidity version everywhere  
# Handle  patitonar   # Vulnerability details  ## Impact Reduce gas cost when reading the underlying variable from NativeLock given that it is only set once in the constructor  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/NativeLock.sol#L14  ## Tools Used Manual review  ## Recommended Mitigation Steps IERC20 public override immutable underlying;  
# Handle  patitonar   # Vulnerability details  ## Impact Reduce bytecode size of AaveV2 by removing Ownable given that there is no functionality for owners  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L21  ## Tools Used Manual Review  ## Recommended Mitigation Steps Update AaveV2 to only extend from IStrategy and remove Ownable import  
# Handle  patitonar   # Vulnerability details  ## Impact Reduce gas costs on constructor by not storing the result of a method invocation in a variable  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L51-L52  ## Tools Used Manual Review  ## Recommended Mitigation Steps Use the result directly. Example: want.approve(address(getLp()), uint256(-1));  
# Handle  bw   # Vulnerability details  ## Impact The `AaveV2.sol` contract made use of a number of `public` variables that were set only in the constructor and would remain constant. These variables were consuming storage slots, which unnecessarily increased the deployment and runtime gas costs of the contract.  ## Proof of Concept  ### Code Diff  ``` diff --git a/contracts/strategies/AaveV2.sol b/contracts/strategies/AaveV2.sol index 1b6ed56..9592986 100644 --- a/contracts/strategies/AaveV2.sol +++ b/contracts/strategies/AaveV2.sol @@ -21,15 +21,15 @@ import '../interfaces/IStrategy.sol';  contract AaveV2 is IStrategy, Ownable {    using SafeMath for uint256;   -  ILendingPoolAddressesProvider public lpAddressProvider = +  ILendingPoolAddressesProvider public constant lpAddressProvider =      ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5); -  IAaveIncentivesController public aaveIncentivesController; +  IAaveIncentivesController public immutable aaveIncentivesController;   -  ERC20 public override want; -  IAToken public aWant; +  ERC20 public immutable override want; +  IAToken public immutable aWant;   -  address public sherlock; -  address public aaveLmReceiver; +  address public immutable sherlock; +  address public immutable aaveLmReceiver;      modifier onlySherlock() {      require(msg.sender == sherlock, 'sherlock'); @@ -49,7 +49,7 @@ contract AaveV2 is IStrategy, Ownable {      aaveLmReceiver = _aaveLmReceiver;        ILendingPool lp = getLp(); -    want.approve(address(lp), uint256(-1)); +    ERC20(_aWant.UNDERLYING_ASSET_ADDRESS()).approve(address(lp), uint256(-1));    } ```  ### Gas Reporter Diff  ``` diff --git a/base.rst b/immutable.rst index 36b3138..79703fc 100644 --- a/base.rst +++ b/immutable.rst @@ -1,199 +1,199 @@  ----------------------------------------------------|---------------------------|-------------|-----------------------------  |                Solc version: 0.7.6                   Optimizer enabled: true    Runs: 200    Block limit: 12450000 gas    ||| -|  Methods                                                         100 gwei/gas                      2058.77 usd/eth        +|  Methods                                                         100 gwei/gas                      2061.52 usd/eth         ||||||  |  Contract        Method                             Min          Max          Avg          # calls        usd (avg)    |||||| -|  AaveV2          claimRewards                          397877       437371       417624              2        85.98   +|  AaveV2          claimRewards                          391566       431060       411313              2        84.79    |||||| -|  AaveV2          deposit                                    -            -       278549              4        57.35   +|  AaveV2          deposit                                    -            -       274205              4        56.53    |||||| -|  AaveV2          withdraw                              260005       294205       277105              2        57.05   +|  AaveV2          withdraw                              253692       287892       270792              2        55.82    |||||| -|  AaveV2          withdrawAll                            59690       275814       167752              2        34.54   +|  AaveV2          withdrawAll                            53349       267370       160360              2        33.06    |||||| |  Deployments                                                                                  % of limit                  ||||| -|  AaveV2                                                      -            -       802248          6.4 %       165.16   +|  AaveV2                                                      -            -       762851          6.1 %       157.26   ```  ### Average Improvements  | Function      | Base      | Immutable | Diff    | |---------------|-----------|-----------|---------| | claimRewards  | 417624    | 411313    | -1.53%  | | deposit       | 278549    | 274205    | -1.58%  | | withdraw      | 277105    | 270792    | -2.33%  | | withdrawAll   | 167752    | 160360    | -4.61%  | | deployment    | 802248    | 762851    | -5.16%  |  By removing the `public` keyword from all variables that are not required (which are only used in the unit tests), the deployment costs can be further reduced to `700206`, which is an 14.57% reduction in gas costs.  ## Tools Used  https://www.npmjs.com/package/hardhat-gas-reporter  ## Recommended Mitigation Steps  Add the `immutable` key word to all variables that are only set during the constructor. Add the `constant` modifier for `lpAddressProvider`.  
# Handle  shw   # Vulnerability details  ## Impact  The `_accrueSherX` function of `LibSherX` and the `payOffDebtAll` function of `LibPool` can be called multiple times in the same block (from different users and transactions). If the current block number is the same as the last-recorded one, it is possible to save gas by early returning at the beginning of the functions.  ## Proof of Concept  Referenced code: [LibSherX.sol#L123-L141](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L123-L141) [LibPool.sol#L84-L95](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L84-L95)  ## Recommended Mitigation Steps  For example, consider re-writing `_accrueSherX` as follows:  ```solidity function _accrueSherX(IERC20 _token, uint256 sherXPerBlock) private returns (uint256 sherX) {   PoolStorage.Base storage ps = PoolStorage.ps(_token);   if (block.number == ps.sherXLastAccrued) {     return 0;   }   sherX = block.number.sub(ps.sherXLastAccrued).mul(sherXPerBlock).mul(ps.sherXWeight).div(     uint16(-1)   );   // need to settle before return, as updating the sherxperlblock/weight   // after it was 0 will result in a too big amount (accured will be < block.number)   ps.sherXLastAccrued = uint40(block.number);   if (address(_token) == address(this)) {     ps.stakeBalance = ps.stakeBalance.add(sherX);   } else {     ps.unallocatedSherX = ps.unallocatedSherX.add(sherX);     ps.sWeight = ps.sWeight.add(sherX);   } } ```  
# Handle  shw   # Vulnerability details  ## Impact  A storage read cost more gas than a memory read. State variables that do not change during a loop can be stored in local variables and be read from memory multiple times to save gas.  ## Proof of Concept  Referenced code: [LibPool.sol#L89](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L89) [LibSherX.sol#L60](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L60) [LibSherX.sol#L94](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L94) [PoolBase.sol#L131](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L131) [SherX.sol#L76](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L76) [SherX.sol#L98](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L98) [SherX.sol#L152](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L152) [SherX.sol#L184](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L184) [SherX.sol#L243](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L243) [Gov.sol#L190](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L190)  ## Recommended Mitigation Steps  For example, consider re-writing the `harvestFor(address)` function of `SherX` as follows:  ```solidity function harvestFor(address _user) public override {   GovStorage.Base storage gs = GovStorage.gs();   uint256 len = gs.tokensStaker.length;   for (uint256 i; i < len; i++) {     PoolStorage.Base storage ps = PoolStorage.ps(gs.tokensStaker[i]);     harvestFor(_user, ps.lockToken);   } } ```  
# Handle  shw   # Vulnerability details  ## Impact  In the `PoolStorage` library, declaring the `POOL_STORAGE_PREFIX` constant with type `bytes32`, and change `abi.encode` ti `abi.encodePacked` at line 87 can save gas.  ## Proof of Concept  Referenced code: [PoolStorage.sol#L14](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/storage/PoolStorage.sol#L14) [PoolStorage.sol#L87](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/storage/PoolStorage.sol#L87)  Related links: [Change `string` to `byteX` if possible](https://medium.com/layerx/how-to-reduce-gas-cost-in-solidity-f2e5321e0395#2a78) [Solidity-Encode-Gas-Comparison](https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison)  ## Recommended Mitigation Steps  See above  
# Handle  shw   # Vulnerability details  ## Impact  The `calcUnderlyingInStoredUSD()` function of `SherX` should return `calcUnderlyingInStoredUSD(getSherXBalance())` instead of `calcUnderlyingInStoredUSD(sx20.balances[msg.sender])` since there could be SherX unallocated to the user at the time of the function call. A similar function, `calcUnderlying()`, calculates the user's underlying tokens based on the user's current balance plus the unallocated ones.  ## Proof of Concept  Referenced code: [SherX.sol#L141](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L141)  ## Recommended Mitigation Steps  Change `sx20.balances[msg.sender]` to `getSherXBalance()` at line 141.  
# Handle  shw   # Vulnerability details  The `getInitialUnstakeEntry` function of `PoolBase` returns the first active unstaking entry of a staker, which requires the current block to be strictly before the last block in the unstaking window. However, the `unstake` function allows the current block to be exactly the same as the last block (same logic in `unstakeWindowExpiry`).  ## Proof of Concept  Referenced code: [PoolBase.sol#L136](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L136) [PoolBase.sol#L344](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L344) [PoolBase.sol#L364](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L364)  ## Recommended Mitigation Steps  Change the `<=` comparison at line 136 to `<` for consistency.  
# Handle  shw   # Vulnerability details  ## Impact  A possible divide-by-zero error could happen in the `getSherXPerBlock(uint256, IERC20)` function of `PoolBase` when the `totalSupply` of `lockToken` and `_lock` are both 0.  ## Proof of Concept  Referenced code: [PoolBase.sol#L215](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L215)  ## Recommended Mitigation Steps  Check if `baseData().lockToken.totalSupply().add(_lock)` equals to 0 before line 214. If so, then return 0.  
# Handle  0xsanson   # Vulnerability details  ## Impact The value `10e17` can be confusing, since it doesn't clearly appear from where the exponent 17 comes from (people may ctrl+f or grep the code for other instances of it without results). Indeed throughout the code the expression `10**18` is used.  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L185  ## Tools Used editor  ## Recommended Mitigation Steps Better ways of writing it are `1e18` or `10**18`.  
# Handle  0xsanson   # Vulnerability details  ## Impact In the function `_doSherX` in Payout.sol, the natSpec comment @return states that `sherUsd` is the 'Total amount of USD of the underlying tokens that are being transferred'. I think that's a typo, and it's supposed to be the amount *excluded* from being transferred.  ## Proof of Concept Payout.sol L71  ## Tools Used editor  ## Recommended Mitigation Steps Correct the statement.  
# Handle  0xsanson   # Vulnerability details  ## Impact In the `calcUnderlying` function of LibSherX.sol, the value `gs.tokensSherX.length` can be written down once to save gas (around 300-500 when called in the present tests).  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L55-L60  ## Tools Used hardhat gas calculator  ## Recommended Mitigation Steps Suggested adding `uint256 SherXLength = gs.tokensSherX.length;` and replacing this value throughout the function (three instances).  
# Handle  tensors   # Vulnerability details  ## Impact Poorly named variables in Gov.sol  ## Proof of Concept _protocolPremium is a bool while protcolPremium is a mapping to uint. This is confusing a could potentially cause some input errors.  ## Recommended Mitigation Steps Rename variables.  
# Handle  cmichel   # Vulnerability details  Usually, the functions to increase the allowance are called `increaseAllowance` and `decreaseAllowance` but in `SherXERC20` they are called `increaseApproval` and `decreaseApproval`  ## Recommendation Rename these functions to the more common names.  
# Handle  cmichel   # Vulnerability details  The `SherXERC20.initializeSherXERC20` function has `initialize` in its name which indicates that it should only be called once to initialize the storage. But it can be repeatedly called to overwrite and update the ERC20 name and symbol.  ## Recommendation Consider an `initializer` modifier or reverting if `name` or `symbol` is already set.  
# Handle  cmichel   # Vulnerability details  The `setWeights` function only stores the `uint16` part of `_weights[i]` in storage (`ps.sherXWeight = uint16(_weights[i])`). However, to calculate `weightAdd/weightSub` the full value (not truncated to 16 bits) is used. This can lead to discrepancies as the actually added part is different from the one tracked in the `weightAdd` variable.   
# Handle  cmichel   # Vulnerability details  The `PoolBase.unstakeWindowExpiry` function allows unstaking tokens of other users. While the tokens are sent to the correct address, this can lead to issues with smart contracts that might rely on claiming the tokens themselves.  For example, suppose the `_to` address corresponds to a smart contract that has a function of the following form:  ```solidity function withdrawAndDoSomething() {     uint256 amount = token.balanceOf(address(this));     contract.unstakeWindowExpiry(address(this), id, token);     amount = amount - token.balanceOf(address(this));     token.transfer(externalWallet, amount) } ```  If the contract has no other functions to transfer out funds, they may be locked forever in this contract.  
# Handle  a_delamo   # Vulnerability details  ## Impact  The following functions are public, but they could be decla  ``` getUnactivatedStakersPoolBalance(IERC20) should be declared external:         - PoolBase.getUnactivatedStakersPoolBalance(IERC20) (contracts/facets/PoolBase.sol#146-148) getTotalUnmintedSherX(IERC20) should be declared external:         - PoolBase.getTotalUnmintedSherX(IERC20) (contracts/facets/PoolBase.sol#170-173) accruedDebt(bytes32,IERC20) should be declared external:         - LibPool.accruedDebt(bytes32,IERC20) (contracts/libraries/LibPool.sol#31-34) getTotalAccruedDebt(IERC20) should be declared external:         - LibPool.getTotalAccruedDebt(IERC20) (contracts/libraries/LibPool.sol#36-39) accrueSherX(IERC20) should be declared external:         - LibSherX.accrueSherX(IERC20) (contracts/libraries/LibSherX.sol#75-81) accrueSherXWatsons() should be declared external:         - LibSherX.accrueSherXWatsons() (contracts/libraries/LibSherX.sol#83-86) deposit() should be declared external:         - AaveV2.deposit() (contracts/strategies/AaveV2.sol#75-81) ```   ## Tools Used  Slither     
# Handle  cmichel   # Vulnerability details  The `_doSherX` function does not return the correct precision of `sherUsd` and it is **not** the "Total amount of USD of the underlying tokens that are being transferred" that the documentation mentions.  ```solidity sherUsd = amounts[i].mul(sx.tokenUSD[tokens[i]]); ```  Instead, the amount is inflated by `1e18`, it should divide the amount by `1e18` to get a USD value with 18 decimal precision.  The severity is low as the calling site in `payout` makes up for it by dividing by `1e18` in the `deduction` computation.  We still recommend returning the correct amount in `_doSherX` already to match the documentation and avoid any future errors when using its unintuitive return value.  
# Handle  cmichel   # Vulnerability details  The `Gov.tokenInit` skips the underlying token check if the `_token` is SHERX:  ```solidity if (address(_token) != address(this)) {   require(_lock.underlying() == _token, 'UNDERLYING'); } ```  ## Impact This check should still be performed even for `_token == address(this) // SHERX`, otherwise, the lock can have a different underlying and potentially pay out wrong tokens.  ## Recommendation Verify the underlying of all locks.  
# Handle  cmichel   # Vulnerability details  The `SherXERC20.transferFrom` function reads the allowance from memory twice. It should be read once, cached, and then use that value for the `if(cachedAllowance ...)` and for the `newApproval = ...` expressions.  
# Handle  cmichel   # Vulnerability details  The `SherXERC20.increaseApproval` function reads the allowance from memory twice. It should be read once and then cached and for the event you the `cache + _amount` value.  
# Handle  hrkrshnn   # Vulnerability details  ## A critical bug in bps function: PoolBase.sol  ``` solidity function bps() internal pure returns (IERC20 rt) {   // These fields are not accessible from assembly   bytes memory array = msg.data;   uint256 index = msg.data.length;    // solhint-disable-next-line no-inline-assembly   assembly {     // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.     rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)   } } ```  The above function is designed to expect the token at the end of `calldata`, but a malicious user can inject extra values at the end of `calldata` and fake return values.  The following contract demonstrates an example:  ``` solidity pragma solidity 0.8.6;  interface IERC20 {}  error StaticCallFailed();  contract BadEncoding {     /// Will return address(1). But address(0) is expected!     function f() external view returns (address) {         address actual = address(0);         address injected = address(1);          (bool success, bytes memory ret) = address(this).staticcall(abi.encodeWithSelector(this.g.selector, actual, injected));          if (!success) revert StaticCallFailed();          return abi.decode(ret, (address));     }     function g(IERC20 _token) external pure returns (IERC20) {         // to get rid of the unused warning         _token;         // Does it always match _token?         return bps();     }     // From Sherlock Protocol: PoolBase.sol     function bps() internal pure returns (IERC20 rt) {         // These fields are not accessible from assembly         bytes memory array = msg.data;         uint256 index = msg.data.length;          // solhint-disable-next-line no-inline-assembly         assembly {             // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.             rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)         }     } } ```  ### An example exploit  This can be used to exploit the protocol:  ``` solidity function unstake(   uint256 _id,   address _receiver,   IERC20 _token ) external override returns (uint256 amount) {   PoolStorage.Base storage ps = baseData();   require(_receiver != address(0), 'RECEIVER');   GovStorage.Base storage gs = GovStorage.gs();   PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];   require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');   // period is including   require(withdraw.blockInitiated + gs.unstakeCooldown < uint40(block.number), 'COOLDOWN_ACTIVE');   require(     withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow >= uint40(block.number),     'UNSTAKE_WINDOW_EXPIRED'   );   amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());    ps.stakeBalance = ps.stakeBalance.sub(amount);   delete ps.unstakeEntries[msg.sender][_id];   ps.lockToken.burn(address(this), withdraw.lock);   _token.safeTransfer(_receiver, amount); } ```  State token `Token1`. Let's say there is a more expensive token `Token2`.  Here's an example exploit:  ``` solidity bytes memory exploitPayload = abi.encodeWithSignature(     PoolBase.unstake.selector,     (uint256(_id), address(_receiver), address(Token2), address(Token1)) ); poolAddress.call(exploitPayload); ```  All the calculations on `ps` would be done on `Token2`, but at the end, because of, `_token.safeTransfer(_receiver, amount);`, `Token2` would be transferred. Assuming that `Token2` is more expensive than `Token1`, the attacker makes a profit.  Similarly, the same technique can be used at a lot of other places. Even if this exploit is not profitable, the fact that the computations can be done on two different tokens is buggy.  There are several other places where the same pattern is used. All of them needs to be fixed. I've not written an exhaustive list.   
# Handle  hrkrshnn   # Vulnerability details  ## Use `type(uintX).max` instead of `uintX(-1)`  ``` diff modified   contracts/facets/Gov.sol @@ -55,7 +55,7 @@ contract Gov is IGov {      GovStorage.Base storage gs = GovStorage.gs();      SherXStorage.Base storage sx = SherXStorage.sx();  -    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(uint16(-1)); +    return sx.sherXPerBlock.mul(gs.watsonsSherxWeight).div(type(uint16).max);    }     function getWatsonsUnmintedSherX() external view override returns (uint256) { ```  Use `type(integerType).max` for such cases. There are also other places that could use this.  ## Have NatSpec comments for all functions ## Avoid the diamond standard  The most significant optimization that can be done in the contract is to get rid of the diamond standard, because, proxy architectures are inherently expensive. Unless there are specific reasons, such as contract size limits, a diamond makes the contract unnecessary complex. Also, try to avoid upgradability if you can afford it.   
# Handle  hrkrshnn   # Vulnerability details  ## Change memory to calldata and caching in loop  ``` diff modified   contracts/facets/Manager.sol @@ -139,16 +139,17 @@ contract Manager is IManager {     function setProtocolPremiumAndTokenPrice(      bytes32 _protocol, -    IERC20[] memory _token, -    uint256[] memory _premium, -    uint256[] memory _newUsd +    IERC20[] calldata _token, +    uint256[] calldata _premium, +    uint256[] calldata _newUsd    ) external override onlyGovMain {      require(_token.length == _premium.length, 'LENGTH_1');      require(_token.length == _newUsd.length, 'LENGTH_2');       (uint256 usdPerBlock, uint256 usdPool) = _getData();  -    for (uint256 i; i < _token.length; i++) { +    uint length = _token.length; +    for (uint256 i; i < length; i++) {        LibPool.payOffDebtAll(_token[i]);        (usdPerBlock, usdPool) = _setProtocolPremiumAndTokenPrice(          _protocol, ```  About caching in loop, see my other report on why it's needed.  For the old code, i.e., having an array in memory, there is an unnecessary copy from `calldata` to `memory`. In the proposed patch, this unnecessary copy is avoided and values are directly read from `calldata` by using `calldataload(...)` instead of going via `calldatacopy(...)`, then `mload(...)`). Saves memory expansion cost, and cost of copying from `calldata` to `memory`.  There are several other places throughout the codebase where the same optimization can be used. I've not provided an exhaustive list.   
# Handle  hrkrshnn   # Vulnerability details  ## Caching in for loops  ``` diff modified   contracts/facets/PoolBase.sol @@ -128,19 +128,21 @@ contract PoolBase is IPoolBase {    {      PoolStorage.Base storage ps = baseData();      GovStorage.Base storage gs = GovStorage.gs(); -    for (uint256 i = 0; i < ps.unstakeEntries[_staker].length; i++) { -      if (ps.unstakeEntries[_staker][i].blockInitiated == 0) { +    PoolStorage.UnstakeEntry[] storage entries = ps.unstakeEntries[_staker]; +    uint length = entries.length; +    for (uint256 i = 0; i < length; i++) { +      if (entries[i].blockInitiated == 0) {          continue;        }        if ( -        ps.unstakeEntries[_staker][i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <= +        entries[i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <=          uint40(block.number)        ) {          continue;        }        return i;      } -    return ps.unstakeEntries[_staker].length; +    return length;    } ```  Caching expensive state variables would avoid re-reading from storage. Solidity's optimizer currently will not be able to cache this value (the IR based codegen and the Yul optimizer can do it; but that is not activated by default).   
# Handle  hrkrshnn   # Vulnerability details  ## Packing the struct  ``` diff modified   contracts/storage/GovStorage.sol @@ -14,15 +14,17 @@ library GovStorage {    struct Base {      // The address appointed as the govMain entity      address govMain; +    // The amount of blocks the cooldown period takes +    uint40 unstakeCooldown; +    // The amount of blocks for the window of opportunity of unstaking +    uint40 unstakeWindow; +    // Check if the protocol is included in the solution at all +    uint16 watsonsSherxWeight; +    // The last block the total amount of rewards were accrued.      // NOTE: UNUSED      mapping(bytes32 => address) protocolManagers;      // Based on the protocol identifier, get the address of the protocol that is able the withdraw balances      mapping(bytes32 => address) protocolAgents; -    // The amount of blocks the cooldown period takes -    uint40 unstakeCooldown; -    // The amount of blocks for the window of opportunity of unstaking -    uint40 unstakeWindow; -    // Check if the protocol is included in the solution at all      mapping(bytes32 => bool) protocolIsCovered;      // The array of tokens the accounts are able to stake in      IERC20[] tokensStaker; @@ -33,8 +35,6 @@ library GovStorage {      address watsonsAddress;      // How much sherX is distributed to this account      // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this acocunt -    uint16 watsonsSherxWeight; -    // The last block the total amount of rewards were accrued.      uint40 watsonsSherxLastAccrued;    } ```  In the current layout, the members `govMain`, `unstakeCooldown`, `unstakeWindow`, `watsonsSherxWeight` all can be packed to a single slot or exactly 256 bits. This can save gas if both such elements are read or written at the same time (please use at least 0.8.2, since it has some improvements centred around optimizing packed Structs).  In the previous layout:  1.  `govMain` would have a slot of its own. 2.  `unstakeCooldown` and `unstakeWindow` would be packed together in a     single slot. 3.  `watsonsSherxWeight` and `watsonsSherxLastAccrued` would be packed     together in a single slot.  Note that gas savings are mainly relevant in the following cases:  1.  Compiler can optimize certain reads and writes to the same slot. 2.  Berlin EIP-2929 based gas accounting, i.e., if the same tx leaves     one of the slot warm. 3.  Berlin EIP-2930 for access lists. Instead of having to making three     different slots warm (in the original code), one only has to make     two slots warm, if necessary.  If none of these applies for your case, this suggestion may be ignored.  ## Packing for PoolStorage  ``` diff modified   contracts/storage/PoolStorage.sol @@ -15,20 +15,35 @@ library PoolStorage {     struct Base {      address govPool; +    // The last block the total amount of rewards were accrued. +    // Accrueing SherX increases the `unallocatedSherX` variable +    uint40 sherXLastAccrued; +    // Protocol debt can only be settled at once for all the protocols at the same time +    // This variable is the block number the last time all the protocols debt was settled +    uint40 totalPremiumLastPaid; + +    // How much sherX is distributed to stakers of this token +    // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this pool +    uint16 sherXWeight;      //      // Staking      //      // Indicates if stakers can stake funds in the pool      bool stakes; -    // Address of the lockToken. Representing stakes in this pool -    ILock lockToken;      // Variable used to calculate the fee when activating the cooldown      // Max value is uint32(-1) which creates a 100% fee on the withdrawal      uint32 activateCooldownFee; +    // Address of the lockToken. Representing stakes in this pool +    // Indicates if protocol are able to pay premiums with this token +    // If this value is true, the token is also included as underlying of the SherX +    bool premiums; + +    ILock lockToken;      // The total amount staked by the stakers in this pool, including value of `firstMoneyOut`      // if you exclude the `firstMoneyOut` from this value, you get the actual amount of tokens staked      // This value is also excluding funds deposited in a strategy.      uint256 stakeBalance; +      // All the withdrawals by an account      // The values of the struct are all deleted if expiry() or unstake() function is called      mapping(address => UnstakeEntry[]) unstakeEntries; @@ -39,12 +54,6 @@ library PoolStorage {      // SherX could be minted before the stakers call the harvest() function      // Minted SherX that is assigned as reward for the pool will be added to this value      uint256 unallocatedSherX; -    // How much sherX is distributed to stakers of this token -    // The max value is uint16(-1), which means 100% of the total SherX minted is allocated to this pool -    uint16 sherXWeight; -    // The last block the total amount of rewards were accrued. -    // Accrueing SherX increases the `unallocatedSherX` variable -    uint40 sherXLastAccrued;      // Non-native variables      // These variables are used to calculate the right amount of SherX rewards for the token staked      mapping(address => uint256) sWithdrawn; @@ -52,9 +61,6 @@ library PoolStorage {      //      // Protocol payments      // -    // Indicates if protocol are able to pay premiums with this token -    // If this value is true, the token is also included as underlying of the SherX -    bool premiums;      // Storing the protocol token balance based on the protocols bytes32 indentifier      mapping(bytes32 => uint256) protocolBalance;      // Storing the protocol premium, the amount of debt the protocol builds up per block. @@ -62,9 +68,6 @@ library PoolStorage {      mapping(bytes32 => uint256) protocolPremium;      // The sum of all the protocol premiums, the total amount of debt that builds up in this token. (per block)      uint256 totalPremiumPerBlock; -    // Protocol debt can only be settled at once for all the protocols at the same time -    // This variable is the block number the last time all the protocols debt was settled -    uint40 totalPremiumLastPaid;      // How much token (this) is available for sherX holders      uint256 sherXUnderlying;      // Check if the protocol is included in the token pool ```  For the same reasons as before. Taking a quick look at the code, this change should reduce gas. (Might require 0.8.2, though; there was an improvement in the optimizer that would apply to packed structs in storage.)   
# Handle  hrkrshnn   # Vulnerability details  ## Higher value of optimize-runs  ``` diff modified   hardhat.config.js @@ -25,7 +25,7 @@ module.exports = {      settings: {        optimizer: {          enabled: true, -        runs: 200, +        runs: 20000,        },      },    }, ```  This value is a tuning parameter for deploy v/s runtime costs. Higher values optimize for lower runtime cost, which is what you are looking for. The above value is an example, please decide a suitable high value, and run tests.  
# Handle  hrkrshnn   # Vulnerability details  ## Writing a branch less version  ``` diff @@ -76,11 +77,11 @@ contract SherXERC20 is IERC20, ISherXERC20 {      require(_amount != 0, 'AMOUNT');      SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();      uint256 oldValue = sx20.allowances[msg.sender][_spender]; -    if (_amount > oldValue) { -      sx20.allowances[msg.sender][_spender] = 0; -    } else { -      sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount); -    } +    uint256 newValue; +    assembly { +        newValue := mul(gt(oldValue, _amount), sub(oldValue, _amount)) +    } +    sx20.allowances[msg.sender][_spender] = newValue;      emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]);      return true;    } ```  The branch-less version avoids at least two `jumpi`, i.e., at least 20 gas and some additional stack operations, along with deploy costs.  Here's a SMT proof that the transformation is equivalent:  ``` python from z3 import *  # A SMT proof that # # if (_amount > oldValue) { #   sx20.allowances[msg.sender][_spender] = 0; # } else { #   sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount); # } # # is same as # # assembly { #     newValue := mul(gt(oldValue, _amount), sub(oldValue, _amount)) # } # sx20.allowances[msg.sender][_spender] = newValue; #  n_bits = 256 amount = BitVec('amount', n_bits) oldValue = BitVec('oldValue', n_bits) allowance = BitVec('oldValue', n_bits)  old_allowance_computation = If(UGT(amount, oldValue), 0, oldValue - amount)  def GT(x, y):     return If(UGT(x, y), BitVecVal(1, n_bits), BitVecVal(0, n_bits)) def MUL(x, y):     return x * y def SUB(x, y):     return x - y  new_allowance_computation = MUL(GT(oldValue, amount), SUB(oldValue, amount))  solver = Solver() solver.add(old_allowance_computation != new_allowance_computation)  result = solver.check() print(result) # unsat ```   
# Handle  hrkrshnn   # Vulnerability details  ## Caching variable  ``` diff modified   contracts/facets/SherXERC20.sol @@ -66,8 +66,9 @@ contract SherXERC20 is IERC20, ISherXERC20 {      require(_spender != address(0), 'SPENDER');      require(_amount != 0, 'AMOUNT');      SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20(); -    sx20.allowances[msg.sender][_spender] = sx20.allowances[msg.sender][_spender].add(_amount); -    emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]); +    uint256 newAllowance = sx20.allowances[msg.sender][_spender].add(_amount); +    sx20.allowances[msg.sender][_spender] = newAllowance; +    emit Approval(msg.sender, _spender, newAllowance);      return true;    } ```  The above change would avoid a `sload`, and will instead use `dupX`, saving \`100\` gas.   
# Handle  pauliax   # Vulnerability details  ## Impact function withdraw in ILendingPool returns the actual withdrawn amount, however, function withdraw in AaveV2 strategy does not check this return value so e.g. function strategyWithdraw may actually withdraw less but still add the full amount to the staked balance:      ps.strategy.withdraw(_amount);     ps.stakeBalance = ps.stakeBalance.add(_amount);  ## Recommended Mitigation Steps function withdraw in IStrategy should return uint indicating the actual withdrawn amount and functions that use it should account for that.  
# Handle  pauliax   # Vulnerability details  ## Impact There is no difference between functions aBalance and balanceOf in contract AaveV2, they both return aWant, so there is no point in having them separately.  ## Recommended Mitigation Steps Remove internal function aBalance and make balanceOf public.  
# Handle  pauliax   # Vulnerability details  ## Impact contract AaveV2 does not cache the lending pool, it retrieves it when necessary by calling a function getLp(). This is great as the implementation may change, however, this contract also approves an unlimited amount of want in the constructor:    ILendingPool lp = getLp();    want.approve(address(lp), uint256(-1)); so if the implementation changes, the approval will reset. This will break the deposit function as it will try to deposit to this new lending pool with 0 approval.   For reference, function setLendingPoolImpl: https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/configuration/LendingPoolAddressesProvider.sol#L58-L65   Not sure how likely is that lending pool implementation will change so marking this as 'Low'.  ## Recommended Mitigation Steps Before calling lp.deposit check that the approval is sufficient and increase otherwise.  
# Handle  cmichel   # Vulnerability details    
# Handle  jonah1005   # Vulnerability details  ## Impact Using `calldata` for function parameter is a slightly more gas efficient   ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L192-L225 ## Tools Used None ## Recommended Mitigation Steps ref: https://mudit.blog/solidity-gas-optimization-tips/   
# Handle  hickuphh3   # Vulnerability details  ### Impact  This is probably an oversight since `SafeERC20` was imported and `safeTransfer()` was used for ERC20 token transfers. Nevertheless, note that `approve()` will fail for certain token implementations that do not return a boolean value (Eg. OMG and ADX tokens). Hence it is recommend to use `safeApprove()`.  ### Recommended Mitigation Steps  Update to `_token.safeApprove(address(_native), totalToken)` in `tokenUnload()`.  
# Handle  gpersoon   # Vulnerability details  ## Impact When a large payout occurs, it will lower unallocatedSherX. This could mean some parties might not be able to get their Yield.  The first couple of users (for which harvest is called or which transfer tokens) will be able to get their full Yield,  until the moment unallocatedSherX is depleted. The next users don't get any yield at all. This doesn't seem fair.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309 function doYield(ILock token,address from, address to, uint256 amount) private { ... ps.unallocatedSherX = ps.unallocatedSherX.sub(withdrawable_amount);  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108  function payout( address _payout, IERC20[] memory _tokens, uint256[] memory _firstMoneyOut, uint256[] memory _amounts, uint256[] memory _unallocatedSherX,  address _exclude ) external override onlyGovPayout {     // all pools (including SherX pool) can be deducted fmo and balance     // deducting balance will reduce the users underlying value of stake token     // for every pool, _unallocatedSherX can be deducted, this will decrease outstanding SherX rewards     // for users that did not claim them (e.g materialized them and included in SherX pool) ....     // Subtract from unallocated, as the tokens are now allocated to this payout call         ps.unallocatedSherX = ps.unallocatedSherX.sub(unallocatedSherX);  ## Tools Used  ## Recommended Mitigation Steps If unallocatedSherX is insufficient to provide for all the yields, only give the yields partly (so that each user gets their fair share).   
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `setWeights()`, the variables `weightAdd` and `weightSub` are used to ensure that there is no difference in the total weight.  ### Recommended Mitigation Steps  Consider `totalWeightOld` and `totalWeightNew` as the variable names instead as they are more indicative of the intended usage and behaviour.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  The only value from poolStorage in `updateData()` is the `sherXUnderlying` value. It is cheaper to pass this `uint256` variable instead of the storage variable itself.  ### Recommended Mitigation Steps  Change `PoolStorage.Base storage ps` to `uint256 sherXUnderlying`, saves about ~160 gas.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `updateData()`,   ```jsx if (sub > add) {   usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18)); } else {   usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18)); } ```  we can calculate the difference between `sub` and `add` in both cases without SafeMath because we already know one is greater than the other.   Also, the logic can be made similar to the `usdPool` calculation since nothing changes in the case where `sub == add`.  The same safemath subtraction avoidance can be implemented for the `usdPool` calculation.  Finally, the variables `sub` and `add` are confusing (makes the code difficult to read because of safemath's add and sub). It is suggested to rename them to `oldUsdPerBlock` and `newUsdPerBlock` respectively.  ### Recommended Mitigation Steps  ```jsx // If oldUsdPerBlock == newUsdPerBlock, nothing changes if (oldUsdPerBlock > newUsdPerBlock) {   usdPerBlock = usdPerBlock.sub((oldUsdPerBlock - newUsdPerBlock).div(10**18)); } else if (oldUsdPerBlock < newUsdPerBlock) {   usdPerBlock = usdPerBlock.add((newUsdPerBlock - oldUsdPerBlock).div(10**18)); }  if (_newUsd > _oldUsd) {  usdPool = usdPool.add((_newUsd - _oldUsd).mul(ps.sherXUnderlying).div(10**18)); } else if (_newUsd < _oldUsd) {  usdPool = usdPool.sub((_oldUsd - _newUsd).mul(ps.sherXUnderlying).div(10**18)); } ```  
# Handle  hickuphh3   # Vulnerability details  ### Impact  - `tokens` can be directly be assigned to `gs.tokensSherX`. - Redundant zero Initialization of the array element `amounts[i] = 0;` in the else case of `calcUnderlying()` (L69-L71).  ### Recommended Mitigation Steps  ```jsx function calcUnderlying(uint256 _amount)  external  view returns (IERC20[] memory tokens, uint256[] memory amounts) {  GovStorage.Base storage gs = GovStorage.gs();    tokens = gs.tokensSherX;   amounts = new uint256[](gs.tokensSherX.length);    uint256 total = getTotalSherX();    for (uint256 i; i < gs.tokensSherX.length; i++) {     IERC20 token = tokens[i];     if (total > 0) {       PoolStorage.Base storage ps = PoolStorage.ps(token);       amounts[i] = ps.sherXUnderlying.add(LibPool.getTotalAccruedDebt(token)).mul(_amount).div(         total       );     }   } } ```  Gas reporter reports a gas reduction of ~150 gas. Gas savings should scale with number of underlying collaterals.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  In `tokenRemove()`, the comment `// NOTE: removed because firstMoneyOut will always be less or equal to stakeBalance` is not intuitive because it is not clear what is removed.  Perhaps `// NOTE: check that firstMoneyOut == 0 not needed since firstMoneyOut <= stakeBalance` will be better.  
# Handle  hickuphh3   # Vulnerability details  ### Impact  For better code readability, it would be good to specify the constants `uint16(-1)`, `uint32(-1)` and `10**18` in a separate contract to be imported in relevant contracts.  - `10e17` was used in payout() instead of the conventional `10**18` defined everywhere else - The docs specified that the cooldown fee and sherX weight are scaled by `10**18`, but they are scaled by `uint32(-1)` and `uint16(-1)` respectively (interfaces natspec is correct).  ### Recommended Mitigation Steps  Consider suggestive constants like `MAX_SHERX_WEIGHT` or `SHERX_DENOM`, `MAX_COOLDOWN_FEE` or `COOLDOWN_FEE_DENOM` and `PRECISION`.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _transfer in SherXERC20.sol allow transfer to address 0. This is usually considered the same as burning the tokens and the Emit is indistinguishable from an Emit of a burn.  However the burn function in LibSherXERC20.sol has extra functionality, which _transfer doesn't have. sx20.totalSupply = sx20.totalSupply.sub(_amount);  So it is safer to prevent _transfer to address 0 (which is also done in the openzeppelin erc20 contract) See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L226  Note: minting from address 0 will not work because that is blocked by the safemath sub in:  sx20.balances[_from] = sx20.balances[_from].sub(_amount);  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherXERC20.sol#L118 function _transfer(address _from, address _to, uint256 _amount) internal {     SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();     sx20.balances[_from] = sx20.balances[_from].sub(_amount);     sx20.balances[_to] = sx20.balances[_to].add(_amount);     emit Transfer(_from, _to, _amount);   }  // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherXERC20.sol#L29 function burn(address _from, uint256 _amount) internal {     SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();     sx20.balances[_from] = sx20.balances[_from].sub(_amount);     sx20.totalSupply = sx20.totalSupply.sub(_amount);     emit Transfer(_from, address(0), _amount);   } ## Tools Used  ## Recommended Mitigation Steps add something like to following to _transfer of SherXERC20.sol:         require(_to!= address(0), "Transfer to the zero address");  Or update sx20.totalSupply if burning a desired operation.  
# Handle  gpersoon   # Vulnerability details  ## Impact The function payout contains an expression with 3 sequential divs. This is generally not recommended because it could lead to rounding errors / loss of precision. Also a div is usually more expensive than a mul. Also an intermediate division by 0 (if SherXERC20Storage.sx20().totalSupply) == 0) could occur.  ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108 function payout( ..  uint256 deduction =  excludeUsd.div(curTotalUsdPool.div(SherXERC20Storage.sx20().totalSupply)).div(10e17);  ## Tools Used  ## Recommended Mitigation Steps Verify the formula and replace with something like: uint256 deduction =  excludeUsd.mul(SherXERC20Storage.sx20().totalSupply).div(  curTotalUsdPool.mul(10e17) )  
# Handle  gpersoon   # Vulnerability details  ## Impact The function _updateData contains variables with the names "sub" and "add". There are also functions with the names "sub" and "add". The resulting code is not very readable:       usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18));       usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18));  Generally it is not recommended to use the same name for variables and functions.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Manager.sol#L386  function _updateData( ..     uint256 sub = _oldPremium.mul(_oldUsd);  ..    uint256 add = _newPremium.mul(_newUsd);      if (sub > add) {       usdPerBlock = usdPerBlock.sub(sub.sub(add).div(10**18));     } else {       usdPerBlock = usdPerBlock.add(add.sub(sub).div(10**18));     }  ## Tools Used  ## Recommended Mitigation Steps Rename the variables "add" and "sub" to different names.   
# Handle  gpersoon   # Vulnerability details  ## Impact On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn't done.  Especially in doYield a first check is done for totalAmount >0, however a few lines later there is an other div(totalAmount) which isn't checked.  The proof of concept show another few examples.  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309 function doYield(ILock token,address from,address to,uint256 amount) private { ..     uint256 totalAmount = ps.lockToken.totalSupply(); ..      if (totalAmount > 0) {       ineglible_yield_amount = ps.sWeight.mul(amount).div(totalAmount);     } else {       ineglible_yield_amount = amount;     }     if (from != address(0)) {       uint256 raw_amount = ps.sWeight.mul(userAmount).div(totalAmount);  // totalAmount could be 0, see lines above  // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L295 function activateCooldown(uint256 _amount, IERC20 _token) external override returns (uint256) { ...   uint256 tokenAmount = fee.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());   // ps.lockToken.totalSupply() might be 0  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L351  function unstake( uint256 _id, address _receiver, IERC20 _token ) external override returns (uint256 amount) { ...    amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());  // // ps.lockToken.totalSupply() might be 0  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L67  function stake( PoolStorage.Base storage ps,uint256 _amount, address _receiver ) external returns (uint256 lock) { ...      lock = _amount.mul(totalLock).div(stakeBalance(ps));   // stakeBalance(ps) might be 0  ## Tools Used  ## Recommended Mitigation Steps Make sure division by 0 won't occur by checking the variables beforehand and handling this edge case.  
# Handle  gpersoon   # Vulnerability details  ## Impact A small gas optimization is possible by replacing x > 0 with  x != 0 provide x is an unsigned integer. As the entire code only uses unsigned integers it can be done on all these locations. The proof of concept shows the locations where the "x > 0" construction is used.  ## Proof of Concept  .\facets\Gov.sol:    require(_tokens.length > 0, 'ZERO'); .\facets\Gov.sol:    if (totalToken > 0) { .\facets\Gov.sol:    if (totalFee > 0) { .\facets\Gov.sol:    if (balance > 0) { .\facets\Manager.sol:    if (ps.sherXUnderlying > 0) { .\facets\Manager.sol:    if (usdPerBlock > 0 && _currentTotalSupply == 0) { .\facets\Manager.sol:    } else if (usdPool > 0) { .\facets\Payout.sol:      if (unallocatedSherX > 0) { .\facets\Payout.sol:      if (firstMoneyOut > 0) { .\facets\Payout.sol:    if (totalUnallocatedSherX > 0) { .\facets\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolBase.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolBase.sol:    if (fee > 0) { .\facets\PoolBase.sol:    if (_forceDebt && accrued > 0) { .\facets\PoolBase.sol:    if (ps.protocolBalance[_protocol] > 0) { .\facets\PoolBase.sol:    if (ps.protocolPremium[_protocol] > 0) { .\facets\PoolOpen.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolStrategy.sol:    require(_amount > 0, 'AMOUNT'); .\facets\PoolStrategy.sol:    require(_amount > 0, 'AMOUNT'); .\facets\SherX.sol:    if (stakeBalance > 0) { .\facets\SherX.sol:    require(_amount > 0, 'AMOUNT'); .\facets\SherX.sol:    if (totalAmount > 0) { .\facets\SherX.sol:      if (withdrawable_amount > 0) { .\libraries\LibSherX.sol:      if (total > 0) { .\libraries\LibSherX.sol:    if (sherX > 0) { .\libraries\LibSherX.sol:    if (sherX > 0) { .\strategies\AaveV2.sol:    require(amount > 0, 'ZERO_AMOUNT');  ## Tools Used grep  ## Recommended Mitigation Steps replace x > 0 with  x != 0  
# Handle  gpersoon   # Vulnerability details  ## Impact In the function tokenUnload, ps.stakeBalance is only deleted if balance >0 e.g it is deleted if ps.stakeBalance > ps.firstMoneyOut So if ps.stakeBalance ==  ps.firstMoneyOut then ps.stakeBalance will not be deleted. And then a call to tokenRemove will revert, because it checks for ps.stakeBalance to be 0  ## Proof of Concept // https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L271  function tokenUnload( IERC20 _token, IRemove _native, address _remaining ) external override onlyGovMain { ...     uint256 balance = ps.stakeBalance.sub(ps.firstMoneyOut);     if (balance > 0) {       _token.safeTransfer(_remaining, balance);       delete ps.stakeBalance;     } ..   delete ps.firstMoneyOut;   function tokenRemove(IERC20 _token) external override onlyGovMain {   ...     require(ps.stakeBalance == 0, 'BALANCE_SET');   ## Tools Used  ## Recommended Mitigation Steps Check what to do in this edge case and add the appropriate code.  
# Handle  gpersoon   # Vulnerability details  ## Impact The comment "NOTE: UNUSED" can be interpreted that both protocolManagers and protocolAgents are unused. See proof of concept below. However only protocolManagers is unused.   ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L148 function protocolUpdate( bytes32 _protocol, address _eoaProtocolAgent,address _eoaManager) public override onlyGovMain { ...     // NOTE: UNUSED     gs.protocolManagers[_protocol] = _eoaManager;     gs.protocolAgents[_protocol] = _eoaProtocolAgent;   }  ## Tools Used  ## Recommended Mitigation Steps Change the comment to: // NOTE: protocolManagers UNUSED    
# Handle  gpersoon   # Vulnerability details  ## Impact The function setUnstakeWindow and setCooldown don't check that the input parameter isn't 0. So the values could accidentally be set to 0 (although unlikely). However you wouldn't want the to be 0 because that would allow attacks with flashloans (stake and unstake in the same transaction)  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Gov.sol#L124  function setUnstakeWindow(uint40 _unstakeWindow) external override onlyGovMain {     require(_unstakeWindow < 25000000, 'MAX'); // ~ approximate 10 years of blocks     GovStorage.gs().unstakeWindow = _unstakeWindow;   }    function setCooldown(uint40 _period) external override onlyGovMain {     require(_period < 25000000, 'MAX'); // ~ approximate 10 years of blocks     GovStorage.gs().unstakeCooldown = _period;   }  ## Tools Used  ## Recommended Mitigation Steps Check the input parameter of setUnstakeWindow and setCooldown isn't 0     
# Handle  gpersoon   # Vulnerability details  ## Impact The functions getTotalUsdPool and viewAccrueUSDPool have the same implementation. It saves some gas on the deployment to integrate these functions. Also the maintenance will be a bit easier.  ## Proof of Concept //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L42 function getTotalUsdPool() external view override returns (uint256) {     SherXStorage.Base storage sx = SherXStorage.sx();     return sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));   }  //https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L18   function viewAccrueUSDPool() public view returns (uint256 totalUsdPool) {     SherXStorage.Base storage sx = SherXStorage.sx();     totalUsdPool = sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));   }  ## Tools Used  ## Recommended Mitigation Steps Integrate the functions getTotalUsdPool and viewAccrueUSDPool (e.g. keep one and remove the other and update the references)  
# Handle  gpersoon   # Vulnerability details  ## Impact Several different solidity pragmas are uses for different solidity version. Its cleaner to use the same version everywhere  ## Proof of Concept .\ForeignLock.sol:pragma solidity ^0.7.4; .\NativeLock.sol:pragma solidity ^0.7.4; .\facets\Gov.sol:pragma solidity ^0.7.4; .\facets\GovDev.sol:pragma solidity ^0.7.0; .\facets\Manager.sol:pragma solidity ^0.7.4; .\facets\Payout.sol:pragma solidity ^0.7.4; .\facets\PoolBase.sol:pragma solidity ^0.7.4; .\facets\PoolDevOnly.sol:pragma solidity ^0.7.4; .\facets\PoolOpen.sol:pragma solidity ^0.7.4; .\facets\PoolStrategy.sol:pragma solidity ^0.7.4; .\facets\SherX.sol:pragma solidity ^0.7.4; .\facets\SherXERC20.sol:pragma solidity ^0.7.1; .\interfaces\IGov.sol:pragma solidity ^0.7.4; .\interfaces\IGovDev.sol:pragma solidity ^0.7.4; .\interfaces\ILock.sol:pragma solidity ^0.7.4; .\interfaces\IManager.sol:pragma solidity ^0.7.4; .\interfaces\IPayout.sol:pragma solidity ^0.7.4; .\interfaces\IPoolBase.sol:pragma solidity ^0.7.4; .\interfaces\IPoolStake.sol:pragma solidity ^0.7.4; .\interfaces\IPoolStrategy.sol:pragma solidity ^0.7.4; .\interfaces\IRemove.sol:pragma solidity ^0.7.4; .\interfaces\ISherlock.sol:pragma solidity ^0.7.4; .\interfaces\ISherX.sol:pragma solidity ^0.7.4; .\interfaces\ISherXERC20.sol:pragma solidity ^0.7.1; .\interfaces\IStrategy.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\DataTypes.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IAaveDistributionManager.sol:pragma solidity 0.7.6; .\interfaces\aaveV2\IAaveGovernanceV2.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IAaveIncentivesController.sol:pragma solidity 0.7.6; .\interfaces\aaveV2\IAToken.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IExecutorWithTimelock.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IGovernanceV2Helper.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\ILendingPool.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\ILendingPoolAddressesProvider.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IProposalValidator.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\IStakeAave.sol:pragma solidity ^0.7.4; .\interfaces\aaveV2\MockAave.sol:pragma solidity ^0.7.4; .\libraries\LibPool.sol:pragma solidity ^0.7.4; .\libraries\LibSherX.sol:pragma solidity ^0.7.4; .\libraries\LibSherXERC20.sol:pragma solidity ^0.7.4; .\storage\GovStorage.sol:pragma solidity ^0.7.0; .\storage\PayoutStorage.sol:pragma solidity ^0.7.0; .\storage\PoolStorage.sol:pragma solidity ^0.7.0; .\storage\SherXERC20Storage.sol:pragma solidity ^0.7.1; .\storage\SherXStorage.sol:pragma solidity ^0.7.0; .\strategies\AaveV2.sol:pragma solidity ^0.7.4; .\util\ERC20Mock.sol:pragma solidity ^0.7.4; .\util\Import.sol:pragma solidity ^0.7.4; .\util\RemoveMock.sol:pragma solidity ^0.7.4; .\util\StrategyMock.sol:pragma solidity ^0.7.4;  ## Tools Used grep  ## Recommended Mitigation Steps  Use the same solidity version everywhere  
# Handle  patitonar   # Vulnerability details  ## Impact Reduce gas cost when reading the underlying variable from NativeLock given that it is only set once in the constructor  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/NativeLock.sol#L14  ## Tools Used Manual review  ## Recommended Mitigation Steps IERC20 public override immutable underlying;  
# Handle  patitonar   # Vulnerability details  ## Impact Reduce bytecode size of AaveV2 by removing Ownable given that there is no functionality for owners  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L21  ## Tools Used Manual Review  ## Recommended Mitigation Steps Update AaveV2 to only extend from IStrategy and remove Ownable import  
# Handle  patitonar   # Vulnerability details  ## Impact Reduce gas costs on constructor by not storing the result of a method invocation in a variable  ## Proof of Concept https://github.com/code-423n4/2021-07-sherlock/blob/d9c610d2c3e98a412164160a787566818debeae4/contracts/strategies/AaveV2.sol#L51-L52  ## Tools Used Manual Review  ## Recommended Mitigation Steps Use the result directly. Example: want.approve(address(getLp()), uint256(-1));  
# Handle  bw   # Vulnerability details  ## Impact The `AaveV2.sol` contract made use of a number of `public` variables that were set only in the constructor and would remain constant. These variables were consuming storage slots, which unnecessarily increased the deployment and runtime gas costs of the contract.  ## Proof of Concept  ### Code Diff  ``` diff --git a/contracts/strategies/AaveV2.sol b/contracts/strategies/AaveV2.sol index 1b6ed56..9592986 100644 --- a/contracts/strategies/AaveV2.sol +++ b/contracts/strategies/AaveV2.sol @@ -21,15 +21,15 @@ import '../interfaces/IStrategy.sol';  contract AaveV2 is IStrategy, Ownable {    using SafeMath for uint256;   -  ILendingPoolAddressesProvider public lpAddressProvider = +  ILendingPoolAddressesProvider public constant lpAddressProvider =      ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5); -  IAaveIncentivesController public aaveIncentivesController; +  IAaveIncentivesController public immutable aaveIncentivesController;   -  ERC20 public override want; -  IAToken public aWant; +  ERC20 public immutable override want; +  IAToken public immutable aWant;   -  address public sherlock; -  address public aaveLmReceiver; +  address public immutable sherlock; +  address public immutable aaveLmReceiver;      modifier onlySherlock() {      require(msg.sender == sherlock, 'sherlock'); @@ -49,7 +49,7 @@ contract AaveV2 is IStrategy, Ownable {      aaveLmReceiver = _aaveLmReceiver;        ILendingPool lp = getLp(); -    want.approve(address(lp), uint256(-1)); +    ERC20(_aWant.UNDERLYING_ASSET_ADDRESS()).approve(address(lp), uint256(-1));    } ```  ### Gas Reporter Diff  ``` diff --git a/base.rst b/immutable.rst index 36b3138..79703fc 100644 --- a/base.rst +++ b/immutable.rst @@ -1,199 +1,199 @@  ----------------------------------------------------|---------------------------|-------------|-----------------------------  |                Solc version: 0.7.6                   Optimizer enabled: true    Runs: 200    Block limit: 12450000 gas    ||| -|  Methods                                                         100 gwei/gas                      2058.77 usd/eth        +|  Methods                                                         100 gwei/gas                      2061.52 usd/eth         ||||||  |  Contract        Method                             Min          Max          Avg          # calls        usd (avg)    |||||| -|  AaveV2          claimRewards                          397877       437371       417624              2        85.98   +|  AaveV2          claimRewards                          391566       431060       411313              2        84.79    |||||| -|  AaveV2          deposit                                    -            -       278549              4        57.35   +|  AaveV2          deposit                                    -            -       274205              4        56.53    |||||| -|  AaveV2          withdraw                              260005       294205       277105              2        57.05   +|  AaveV2          withdraw                              253692       287892       270792              2        55.82    |||||| -|  AaveV2          withdrawAll                            59690       275814       167752              2        34.54   +|  AaveV2          withdrawAll                            53349       267370       160360              2        33.06    |||||| |  Deployments                                                                                  % of limit                  ||||| -|  AaveV2                                                      -            -       802248          6.4 %       165.16   +|  AaveV2                                                      -            -       762851          6.1 %       157.26   ```  ### Average Improvements  | Function      | Base      | Immutable | Diff    | |---------------|-----------|-----------|---------| | claimRewards  | 417624    | 411313    | -1.53%  | | deposit       | 278549    | 274205    | -1.58%  | | withdraw      | 277105    | 270792    | -2.33%  | | withdrawAll   | 167752    | 160360    | -4.61%  | | deployment    | 802248    | 762851    | -5.16%  |  By removing the `public` keyword from all variables that are not required (which are only used in the unit tests), the deployment costs can be further reduced to `700206`, which is an 14.57% reduction in gas costs.  ## Tools Used  https://www.npmjs.com/package/hardhat-gas-reporter  ## Recommended Mitigation Steps  Add the `immutable` key word to all variables that are only set during the constructor. Add the `constant` modifier for `lpAddressProvider`.  
