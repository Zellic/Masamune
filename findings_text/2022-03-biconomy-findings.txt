# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L265-L291   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L265-L291  ```solidity function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {     uint256 accumulator = 0;     uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;     uint256 counter = block.timestamp;     uint256 i = rewardRateLog[_baseToken].length - 1;     while (true) {         if (lastUpdatedTime >= counter) {             break;         }         unchecked {             accumulator +=                 rewardRateLog[_baseToken][i].rewardsPerSecond *                 (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));         }         counter = rewardRateLog[_baseToken][i].timestamp;         if (i == 0) {             break;         }         --i;     }      // We know that during all the periods that were included in the current iterations,     // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the     // updates to the pool that happened after the lastUpdatedTime.     accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];     return accumulator + poolInfo[_baseToken].accTokenPerShare; } ```  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L286-L292  ```solidity uint256 mintedSharesAmount; // Adding liquidity in the pool for the first time if (totalReserve[token] == 0) {     mintedSharesAmount = BASE_DIVISOR * _amount; } else {     mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token]; } ```  In `HyphenLiquidityFarming`, the `accTokenPerShare` is calculated based on the total staked shares.  However, as the `mintedSharesAmount` can easily become very large on `LiquidityProviders.sol`, all the users can lose their rewards due to precision loss.  ### PoC  Given:  - rewardsPerSecond is `10e18`; - lastRewardTime is 24 hrs ago;  Then:  1. Alice `addTokenLiquidity()` with `1e8 * 1e18` XYZ on B-Chain, totalSharesMinted == `1e44`; 2. Alice `deposit()` to HyphenLiquidityFarming, totalSharesStaked == `1e44`; 3. 24 hrs later, Alice tries to claim the rewards.   `accumulator = rewardsPerSecond * 24 hours` == 864000e18 == 8.64e23  Expected Results: As the sole staker, Alice should get all the `864000e18` rewards.  Actual Results: Alice received 0 rewards.  That's becasue when `totalSharesStaked > 1e36`, `accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];` will be round down to `0`.  When the `totalSharesStaked` is large enough, all users will lose their rewards due to precision loss.  ### Recommendation  1. Consider lowering the `BASE_DIVISOR` so that the initial share price can be higher; 2. Consider making `ACC_TOKEN_PRECISION` larger to prevent precision loss;  See also the Recommendation on [WP-H14].  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L345-L362   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L345-L362  ```solidity function removeLiquidity(uint256 _nftId, uint256 _amount)     external     nonReentrant     onlyValidLpToken(_nftId, _msgSender())     whenNotPaused {     (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);     require(_isSupportedToken(_tokenAddress), "ERR__TOKEN_NOT_SUPPORTED");      require(_amount != 0, "ERR__INVALID_AMOUNT");     require(nftSuppliedLiquidity >= _amount, "ERR__INSUFFICIENT_LIQUIDITY");     whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);     // Claculate how much shares represent input amount     uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);      // Calculate rewards accumulated     uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress); ```  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityProviders.sol#L192-L194  ```solidity=192 function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {     return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress]; } ```  The share price of the liquidity can be manipulated to an extremely low value (1 underlying token worth a huge amount of shares), making it possible for `sharesToTokenAmount(totalNFTShares, _tokenAddress)` to overflow in `removeLiquidity()` and therefore freeze users' funds.   ### PoC  1. Alice `addTokenLiquidity()` with `1e8 * 1e18` XYZ on B-Chain, totalSharesMinted == `1e44`; 2. Alice `sendFundsToUser()` and bridge `1e8 * 1e18` XYZ from B-Chain to A-Chain; 3. Alice `depositErc20()` and bridge `1e8 * 1e18` XYZ from A-Chain to B-Chain; 4. Alice `removeLiquidity()` and withdraw `1e8 * 1e18 - 1` XYZ, then: `totalReserve` == `1 wei` XYZ, and `totalSharesMinted` == `1e26`; 5. Bob `addTokenLiquidity()` with `3.4e7 * 1e18` XYZ; 6. Bob tries to `removeLiquidity()`.  Expected Results: Bob to get back the deposits;  Actual Results: The tx reverted due to overflow at `sharesToTokenAmount()`.  ### Recommendation  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L280-L292  ```solidity=280 function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {     (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);      require(_amount > 0, "ERR__AMOUNT_IS_0");     whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);      uint256 mintedSharesAmount;     // Adding liquidity in the pool for the first time     if (totalReserve[token] == 0) {         mintedSharesAmount = BASE_DIVISOR * _amount;     } else {         mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];     }     ... ```  Consider locking part of the first mint's liquidity to maintain a minimum amount of `totalReserve[token]`, so that the share price can not be easily manipulated.  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/security/Pausable.sol#L65-L68   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/security/Pausable.sol#L65-L68  ```solidity     function renouncePauser() external virtual onlyPauser {         emit PauserChanged(_pauser, address(0));         _pauser = address(0);     } ```  A malicious or compromised `pauser` can call `pause()` and `renouncePauser()` to brick the contract and all the funds can be frozen.  ### PoC  Given:  * Alice (EOA) is the `pauser` of the contract.  1. Alice calls `pause()` ; 2. Alice calls `renouncePauser()`;   As a result, most of the contract's methods are now unavailable, and this cannot be reversed even by the `owner`.  ### Recommendation  Consider removing `renouncePauser()`, or requiring the contract not in `paused` mode when `renouncePauser()`.  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L229-L253   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L229-L253  ```solidity function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {     address msgSender = _msgSender();     uint256 nftsStakedLength = nftIdsStaked[msgSender].length;     uint256 index;     for (index = 0; index < nftsStakedLength; ++index) {         if (nftIdsStaked[msgSender][index] == _nftId) {             break;         }     }      require(index != nftsStakedLength, "ERR__NFT_NOT_STAKED");     nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];     nftIdsStaked[msgSender].pop();      _sendRewardsForNft(_nftId, _to);     delete nftInfo[_nftId];      (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);     amount /= liquidityProviders.BASE_DIVISOR();     totalSharesStaked[baseToken] -= amount;      lpToken.safeTransferFrom(address(this), msgSender, _nftId);      emit LogWithdraw(msgSender, baseToken, _nftId, _to); } ```   https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L122-L165  ```solidity function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {     NFTInfo storage nft = nftInfo[_nftId];     require(nft.isStaked, "ERR__NFT_NOT_STAKED");      (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);     amount /= liquidityProviders.BASE_DIVISOR();      PoolInfo memory pool = updatePool(baseToken);     uint256 pending;     uint256 amountSent;     if (amount > 0) {         pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;         if (rewardTokens[baseToken] == NATIVE) {             uint256 balance = address(this).balance;             if (pending > balance) {                 unchecked {                     nft.unpaidRewards = pending - balance;                 }                 (bool success, ) = _to.call{value: balance}("");                 require(success, "ERR__NATIVE_TRANSFER_FAILED");                 amountSent = balance;             } else {                 nft.unpaidRewards = 0;                 (bool success, ) = _to.call{value: pending}("");                 require(success, "ERR__NATIVE_TRANSFER_FAILED");                 amountSent = pending;             }         } else {             IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);             uint256 balance = rewardToken.balanceOf(address(this));             if (pending > balance) {                 unchecked {                     nft.unpaidRewards = pending - balance;                 }                 amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);             } else {                 nft.unpaidRewards = 0;                 amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);             }         }     }     nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;     emit LogOnReward(_msgSender(), baseToken, amountSent, _to); } ```  When `withdraw()` is called, `_sendRewardsForNft(_nftId, _to)` will be called to send the rewards.  In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` will be recorded and the user can get it back at the next time.  However, at L244, the whole `nftInfo` is being deleted, so that `nft.unpaidRewards` will also get erased.  There is no way for the user to get back this `unpaidRewards` anymore.  ### Recommendation  Consider adding a new parameter named `force` for `withdraw()`, `require(force || unpaidRewards == 0)` before deleting nftInfo.  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L59 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L196:L224 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L229:L253   # Vulnerability details  ## Impact The `nftIdsStaked` variable introduces a hash collision vulnerability into the `LiquidityFarming.sol` contract as it is employing a mapping from address to a variable length of data field. Source: `https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L59`  The easiest attack scenario allows loss of funds for victims as the attackers can stop victims from unstaking their NFT in the `withdraw` function. Two more complicated attack scenarios allow loss of funds as attackers can outright withdraw nfts of victims.   ## Proof of Concept This attack depends very on the address of the victim an attacker would want to attack. Therefore let me just illustrate the problem.  When using an address mapping to some fixed length data field one can rely on keccak to prevent collisions.  When using an address mapping with an attacker controlled length data field an attacker has a somewhat easy path to create collisions and thereby write to or read from victims data.  The first part to understanding the attack is understanding that all the nfts of a victim are going to be in continous storage locations of the contract. Lets assume that a victims mapped to array starts at 0x1337 and the own 2 nft with the Ids: 23 and 38. The memory layout could look like this:  ``` addr  | val | description ------|-----|---- 0x1337| 2   | length of the array 0x1338| 23   | Id of the first owned nft 0x1339| 38   | Id of the second owned nft ```  Please note if the victim were to deposit more nfts those nftIds would be placed in the storage address 0x133a, 0x133b and so on.  ### Less complex attack scenario The easier attack scenario would involve the attacker generating addresses that result in a continous storage region below address 0x1337. Suppose the attacker were to generate an address whose arrays storage of nftIdsStaked lands at 0x1330. The memory layout would look like this.  ``` addr  | val | description ------|-----|---- 0x1330| 0   | length of the array 0x1337| 2   | length of the array 0x1338| 23   | Id of the first owned nft 0x1339| 38   | Id of the second owned nft ```  It is easy to see, that they could grow their array and thereby corrupting the array of the victim.  They could essentially write nftIds of worthless nftId into the storage of the victim, thereby overwriting their nftId and preventing them (or anybody else) from withdrawing them.  ### More complex attack scenario  The more complex attack scenario involves finding two addresses that will have somewhat adjacent storage regions.  Where the lower storage region encroaches on the length field of the array. The length field is attacker controlled, thereby allowing the attacker to call `withdraw` on arbitrary nftId.  ``` addr  | val | description ------|-----|---- 0x1337| 4   | length of lower array 0x1338| 37   | Id of the first owned (worthless) nft 0x1339| 39   | Id of the second owned (worthless) nft 0x133a| 40   | Id of the third owned (worthless) nft 0x133b| N    | length of higher array (attacker controlled) AND 4th nftId of lower array 0x133a| 42   | Id of the first owned (worthless) nft ```   Please note that this "feels" like a traditional bruteforce attack on keccak (because it is) but it is orders of magnitude more likely to be succesful.  Attackers can essentially trade bruteforcing addresses with calling `deposit` a bunch of times.  As this attack scenario is somewhat less known and more similar to traditional memory corruption attacks allow me to leave a link describing the issue in more detail: `https://xlab.tencent.com/en/2018/11/09/pay-attention-to-the-ethereum-hash-collision-problem-from-the-stealing-coins-incident/`   ## Tools Used Manual audit  ## Recommended Mitigation Steps Track nftIdsStaked like so:  ``` // user address =>        nth nft =>  nft id mapping(address => mapping(uint256 => uint256)) public nftIdsStaked; ```  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L180-L186   # Vulnerability details  ## Impact The `getTokenPriceInLPShares` function calculates the token price in LP shares, but it checks a wrong condition - if supposed to return `BASE_DIVISOR` if the total reserve is zero, not if the total shares minted is zero. This might leads to a case where the price is calculated incorrectly, or a division by zero is happening.   ## Proof of Concept This is the wrong function implementation: ```sol function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {     uint256 supply = totalSharesMinted[_baseToken];     if (supply > 0) {         return totalSharesMinted[_baseToken] / totalReserve[_baseToken];     }     return BASE_DIVISOR; } ``` This function is used in this contract only in the removeLiquidity and claimFee function, so it's called only if funds were already deposited and totalReserve is not zero, but it can be problematic when other contracts will use this function (it's a public view function so it might get called from outside of the contract).  ## Recommended Mitigation Steps The correct code should be: ```sol function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {     uint256 reserve = totalReserve[_baseToken];     if (reserve > 0) {         return totalSharesMinted[_baseToken] / totalReserve[_baseToken];     }     return BASE_DIVISOR; } ```  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityPool.sol#L149-L173 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityPool.sol#L263-L277   # Vulnerability details  ## Impact `depositErc20` allows an attacker to specify the destination chain to be the same as the source chain and the receiver account to be the same as the caller account. This enables an attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state.    ## Proof of Concept This requires the attacker to have some collateral, to begin with. The profit also depends on how much the attacker has. Assume the attacker has enough assets.  In each chain, when the pool is very deficit (e.g. `currentLiquidity` is much less than `providedLiquidity`), which often mean there's a good amount in the Incentive pool after some high valued transfers, then do the following.    - step 1 :  borrow the liquidityDifference amount such that one can get the whole incentivePool. ```             uint256 liquidityDifference = providedLiquidity - currentLiquidity;             if (amount >= liquidityDifference) {                 rewardAmount = incentivePool[tokenAddress]; ``` - step 2 : call `depositErc20()` with `toChainId` being the same chain and `receiver` being `msg.sender`.  The executor will call `sendFundsToUser` to msg.sender. Then a rewardAmount, equivalent to the entire incentive pool (up to 10% of the total pool value), will be added to `msg.sender` minus equilibrium fee (~0.01%) and gas fee.    In the end, the pool is back to the deficit state as before, the incentive pool is drained and the exploiter pockets the difference of rewardAmount minus fees.   This attack can be repeated on each deployed chain multiple times whenever the incentive pool is profitable (particularly right after a big transfer).    ## Tools Used  ## Recommended Mitigation Steps - Disallow `toChainId` to be the source chain by validating it in `depositErc20` or in `sendFundsToUser` validate that `fromChainId` is not the same as current chain.  - require `receiver` is not `msg.sender` in `depositErc20`.      
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/WhitelistPeriodManager.sol#L178-L184 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/WhitelistPeriodManager.sol#L115-L125   # Vulnerability details  ## Impact  The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is removed from the `isExcludedAddress` mapping. While this affects the enforcement of the cap limits and the `getMaxCommunityLpPositon()` function, the worst impact this has is that the address cannot have liquidity removed / transferred due to subtraction overflow.  In particular, users can be prevented from withdrawing their staked LP tokens from the liquidity farming contract should it become non-excluded.  ## Proof of Concept  - Assume liquidity farming address `0xA` is excluded - Bob stakes his LP token - Liquidity farming contract is no longer to be excluded: `setIsExcludedAddressStatus([0xA, false])` - Bob attempts to withdraw liquidity â†’ reverts because `totalLiquidityByLp[USDC][0xA] = 0`, resulting in subtraction overflow.  ```jsx // insert test case in Withdraw test block of LiquidityFarming.tests.ts it.only('will brick withdrawals by no longer excluding farming contract', async () => {   await farmingContract.deposit(1, bob.address);   await wlpm.setIsExcludedAddressStatus([farmingContract.address], [false]);   await farmingContract.connect(bob).withdraw(1, bob.address); });  // results in // Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block) ```  ## Recommended Mitigation Steps  The simplest way is to prevent exclusion removals.  ```jsx function setIsExcludedAddresses(address[] memory _addresses) external onlyOwner {   for (uint256 i = 0; i < _addresses.length; ++i) {     isExcludedAddress[_addresses[i]] = true;     // emit event     emit AddressExcluded(_addresses[i]);   } } ```  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L151   # Vulnerability details  ## Impact The `depositErc20` function allows setting `tokenAddress = NATIVE` and does not throw an error. No matter the `amount` chosen, the `SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);` call will not revert because it performs a low-level call to `NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`, which is an EOA, and the low-level calls to EOAs always succeed. Because the `safe*` version is used, the EOA not returning any data does not revert either.  This allows an attacker to deposit infinite native tokens by not paying anything. The contract will emit the same `Deposit` event as a real `depositNative` call and the attacker receives the native funds on the other chain.  ## Recommended Mitigation Steps Check `tokenAddress != NATIVE` in `depositErc20`.   
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L319-L322   # Vulnerability details  ## Impact The `getAmountToTransfer` function of `LiquidityPool` updates `incentivePool[tokenAddress]` by adding some fee to it but the formula is wrong and the value of `incentivePool[tokenAddress]` will be divided by `BASE_DIVISOR` (10000000000) each time. After just a few time, the value of `incentivePool[tokenAddress]` will become zero and that amount of `tokenAddress` token will be locked in contract. ## Proof of concept Line 319-322 ``` incentivePool[tokenAddress] = (incentivePool[tokenAddress] + (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) / BASE_DIVISOR; ``` Let `x = incentivePool[tokenAddress]`, `y = amount`, `z = transferFeePerc` and `t = tokenManager.getTokensInfo(tokenAddress).equilibriumFee`. Then that be written as ``` x = (x + (y * (z - t))) / BASE_DIVISOR; x = x / BASE_DIVISOR + (y * (z - t)) / BASE_DIVISOR; ``` ## Recommended Mitigation Steps Fix the bug by change line 319-322 to: ``` incentivePool[tokenAddress] += (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee)) / BASE_DIVISOR; ```   
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L220 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L233   # Vulnerability details  In `deposit` function it is possible to push to `nftIdsStaked` of anyone, an attacker can deposit too many nfts to another user, and when the user will try to withdraw an nft at the end of the list, they will iterate on the list and revert because of gas limit.   
Title: Unnecessary Reentrancy Guards Severity: GAS  Where there is onlyOwner or Initializer modifer, the reentrancy gaurd isn't  necessary (unless you don't trust the owner or the deployer, which will lead to full security breakdown of the project and we believe this is not the case) This is a list we found of such occurrences:           LiquidityFarming.sol no need both nonReentrant and onlyOwner modifiers in reclaimTokens    Title: Change transferFrom to transfer Severity: GAS  'transferFrom(address(this), *, **)' could be replaced by the following more gas efficient 'transfer(*, **)'                This replacement is more gas efficient and improves the code quality.          LiquidityFarming.sol, 250 : lpToken.safeTransferFrom(address(this), msgSender, _nftId);   Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           ExecutorManager.sol, getAllExecutors         LPToken.sol, initialize         LPToken.sol, exists         WhitelistPeriodManager.sol, initialize   Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          LiquidityFarming.sol (L#275) - accumulator += rewardRateLog[_baseToken][i].rewardsPerSecond * (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));    Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           liquidityProviders in LiquidityFarming.sol         tokenManager in LiquidityPool.sol         lpToken in LiquidityFarming.sol    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               LiquidityPool.depositErc20 (tag)         LPToken.initialize (_symbol)         LiquidityPool.sendFundsToUser (depositHash)         LiquidityPool.permitEIP2612AndDepositErc20 (tag)         LiquidityPool.permitAndDepositErc20 (tag)         LiquidityPool.depositNative (tag)         LPToken.updateTokenMetadata (_lpTokenMetadata)         LiquidityPool.checkHashStatus (depositHash)         LPToken.initialize (_name)    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           ExecutorManager.sol, executorArray, 31         TokenManager.sol, tokenConfig, 78         ExecutorManager.sol, executorArray, 47         WhitelistPeriodManager.sol, _tokens, 228         LPToken.sol, nftIds, 77         WhitelistPeriodManager.sol, _addresses, 180    Title: Storage double reading. Could save SLOAD Severity: GAS  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           LiquidityProviders.sol: BASE_DIVISOR is read twice in _increaseLiquidity    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          WhitelistPeriodManager.sol, 180         WhitelistPeriodManager.sol, 228         LPToken.sol, 77         ExecutorManager.sol, 31         ExecutorManager.sol, 47         TokenManager.sol, 78     Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               TokenManager.sol, _msgData, { return ERC2771Context._msgData(); }         TokenManager.sol, _msgSender, { return ERC2771Context._msgSender(); }         WhitelistPeriodManager.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityPool.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityFarming.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityProviders.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LPToken.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityPool.sol, _msgSender, { return ERC2771ContextUpgradeable._msgSender(); }    Title: Use bytes32 instead of string to save gas whenever possible Severity: GAS       Use bytes32 instead of string to save gas whenever possible.     String is a dynamic data structure and therefore is more gas consuming then bytes32.               LPToken.sol (L140), string memory json = Base64.encode( bytes( string( abi.encodePacked( '{"name": "', name(), '", "description": "', description, '", "image": "data:image/svg+xml;base64,', Base64.encode(bytes(svgData)), '", "attributes": ', attributes, "}" ) ) ) );     Title: Unused state variables Severity: GAS  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           LPToken.sol, NATIVE    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           just change to unchecked: ExecutorManager.sol, i, 47         just change to unchecked: LiquidityFarming.sol, index, 233         just change to unchecked: LPToken.sol, i, 77         just change to unchecked: WhitelistPeriodManager.sol, i, 228         just change to unchecked: WhitelistPeriodManager.sol, i, 248         just change to unchecked: TokenManager.sol, index, 78         just change to unchecked: WhitelistPeriodManager.sol, i, 180         just change to unchecked: ExecutorManager.sol, i, 31    Title: Unused inheritance Severity: GAS       Some of your contract inherent contracts but aren't use them at all.     We recommend not to inherent those contracts.              TokenManager.sol; the inherited contracts Pausable not used   Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          WhitelistPeriodManager.sol, _msgData         LiquidityProviders.sol, _addLiquidity         WhitelistPeriodManager.sol, _isSupportedToken   Title: Unused inheritance Severity: GAS       Some of your contract inherent contracts but aren't use them at all.     We recommend not to inherent those contracts.              TokenManager.sol; the inherited contracts Pausable not used   Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          LiquidityPool.sol, line 5, import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";         WhitelistPeriodManager.sol, line 6, import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";         WhitelistPeriodManager.sol, line 5, import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";     Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           LiquidityProviders.sol, 283: change '_amount > 0' to '_amount != 0'         LiquidityPool.sol, 401: change 'balance > 0' to 'balance != 0'         LiquidityPool.sol, 292: change 'balance > 0' to 'balance != 0'
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L51 https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L52   # Vulnerability details  ## Impact  The **equilibriumFee** and **maxFee** does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions or the LP user will lost all funds when paying the fee.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L52  2. Owner can identify fee amount. That directly affect to LP management. (https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L352)  3. Here you can see there is no upper bound has been defined.   ```     function changeFee(         address tokenAddress,         uint256 _equilibriumFee,         uint256 _maxFee     ) external override onlyOwner whenNotPaused {         require(_equilibriumFee != 0, "Equilibrium Fee cannot be 0");         require(_maxFee != 0, "Max Fee cannot be 0");         tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;         tokensInfo[tokenAddress].maxFee = _maxFee;         emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);     }  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider defining upper and lower bounds on the **equilibriumFee** and **maxFee**.  
https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L30 Consider adding require(!executorStatus[executorArray[i]], "Executor already registered"); in the for loop before calling addExecutor. This will make the transaction faster and will save some gas fees.   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L55 Check if the executor is present and executorStatus is not already set to false. I can call the function in an infinity loop and it can block other transactions to executed while(i == 1){  executorManager.removeExecutor(address) }   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L99 Add zero check for rewardPerSecond. EVen though onlyOwner, it can create zero records and can exhust gas fees   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L170 Check if the baseToken is already added to rewardRateLog. Unless the business logic is to allow override, the emit will exhuast gas fees.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L182 Add zero check for amount. No point in transfering 0 amount. This will cost extra gas fees.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L113 Add zero check before setting baseGas.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L201 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L225 Add zero check. Although zero check if done in functions called further, having zero check at the begainning will definitly help save some gas 
https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L10 The executorstatus map is not really helpful in any business logic. If the executor is present in executors array then the status is true or else false.  Once the executor is added, it cannot be added again even though the status is set to FALSE.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L53 The function removeExecutor is just setting the status to false.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L55 Check if the executor is present and executorStatus is not already set to false.   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/token/svg-helpers/SvgHelperBase.sol#L126 Both inpurt parameters are not used in the function. Remove these.   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L169 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L330 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L333 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L107 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L113 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L123 If function is not called from inside the contract, better to make it external  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L211 NFTInfo storage nft = nftInfo[_nftId]; require(!nft.isStaked, "ERR__NFT_ALREADY_STAKED"); Move above code immidiately after the require(lpToken.isApprovedForAll...). If NFT is not approved, then no need to get token metadata 
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L265-L291   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L265-L291  ```solidity function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {     uint256 accumulator = 0;     uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;     uint256 counter = block.timestamp;     uint256 i = rewardRateLog[_baseToken].length - 1;     while (true) {         if (lastUpdatedTime >= counter) {             break;         }         unchecked {             accumulator +=                 rewardRateLog[_baseToken][i].rewardsPerSecond *                 (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));         }         counter = rewardRateLog[_baseToken][i].timestamp;         if (i == 0) {             break;         }         --i;     }      // We know that during all the periods that were included in the current iterations,     // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the     // updates to the pool that happened after the lastUpdatedTime.     accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];     return accumulator + poolInfo[_baseToken].accTokenPerShare; } ```  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L286-L292  ```solidity uint256 mintedSharesAmount; // Adding liquidity in the pool for the first time if (totalReserve[token] == 0) {     mintedSharesAmount = BASE_DIVISOR * _amount; } else {     mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token]; } ```  In `HyphenLiquidityFarming`, the `accTokenPerShare` is calculated based on the total staked shares.  However, as the `mintedSharesAmount` can easily become very large on `LiquidityProviders.sol`, all the users can lose their rewards due to precision loss.  ### PoC  Given:  - rewardsPerSecond is `10e18`; - lastRewardTime is 24 hrs ago;  Then:  1. Alice `addTokenLiquidity()` with `1e8 * 1e18` XYZ on B-Chain, totalSharesMinted == `1e44`; 2. Alice `deposit()` to HyphenLiquidityFarming, totalSharesStaked == `1e44`; 3. 24 hrs later, Alice tries to claim the rewards.   `accumulator = rewardsPerSecond * 24 hours` == 864000e18 == 8.64e23  Expected Results: As the sole staker, Alice should get all the `864000e18` rewards.  Actual Results: Alice received 0 rewards.  That's becasue when `totalSharesStaked > 1e36`, `accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];` will be round down to `0`.  When the `totalSharesStaked` is large enough, all users will lose their rewards due to precision loss.  ### Recommendation  1. Consider lowering the `BASE_DIVISOR` so that the initial share price can be higher; 2. Consider making `ACC_TOKEN_PRECISION` larger to prevent precision loss;  See also the Recommendation on [WP-H14].  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L345-L362   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L345-L362  ```solidity function removeLiquidity(uint256 _nftId, uint256 _amount)     external     nonReentrant     onlyValidLpToken(_nftId, _msgSender())     whenNotPaused {     (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);     require(_isSupportedToken(_tokenAddress), "ERR__TOKEN_NOT_SUPPORTED");      require(_amount != 0, "ERR__INVALID_AMOUNT");     require(nftSuppliedLiquidity >= _amount, "ERR__INSUFFICIENT_LIQUIDITY");     whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);     // Claculate how much shares represent input amount     uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);      // Calculate rewards accumulated     uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress); ```  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityProviders.sol#L192-L194  ```solidity=192 function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {     return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress]; } ```  The share price of the liquidity can be manipulated to an extremely low value (1 underlying token worth a huge amount of shares), making it possible for `sharesToTokenAmount(totalNFTShares, _tokenAddress)` to overflow in `removeLiquidity()` and therefore freeze users' funds.   ### PoC  1. Alice `addTokenLiquidity()` with `1e8 * 1e18` XYZ on B-Chain, totalSharesMinted == `1e44`; 2. Alice `sendFundsToUser()` and bridge `1e8 * 1e18` XYZ from B-Chain to A-Chain; 3. Alice `depositErc20()` and bridge `1e8 * 1e18` XYZ from A-Chain to B-Chain; 4. Alice `removeLiquidity()` and withdraw `1e8 * 1e18 - 1` XYZ, then: `totalReserve` == `1 wei` XYZ, and `totalSharesMinted` == `1e26`; 5. Bob `addTokenLiquidity()` with `3.4e7 * 1e18` XYZ; 6. Bob tries to `removeLiquidity()`.  Expected Results: Bob to get back the deposits;  Actual Results: The tx reverted due to overflow at `sharesToTokenAmount()`.  ### Recommendation  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L280-L292  ```solidity=280 function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {     (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);      require(_amount > 0, "ERR__AMOUNT_IS_0");     whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);      uint256 mintedSharesAmount;     // Adding liquidity in the pool for the first time     if (totalReserve[token] == 0) {         mintedSharesAmount = BASE_DIVISOR * _amount;     } else {         mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];     }     ... ```  Consider locking part of the first mint's liquidity to maintain a minimum amount of `totalReserve[token]`, so that the share price can not be easily manipulated.  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/security/Pausable.sol#L65-L68   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/security/Pausable.sol#L65-L68  ```solidity     function renouncePauser() external virtual onlyPauser {         emit PauserChanged(_pauser, address(0));         _pauser = address(0);     } ```  A malicious or compromised `pauser` can call `pause()` and `renouncePauser()` to brick the contract and all the funds can be frozen.  ### PoC  Given:  * Alice (EOA) is the `pauser` of the contract.  1. Alice calls `pause()` ; 2. Alice calls `renouncePauser()`;   As a result, most of the contract's methods are now unavailable, and this cannot be reversed even by the `owner`.  ### Recommendation  Consider removing `renouncePauser()`, or requiring the contract not in `paused` mode when `renouncePauser()`.  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L229-L253   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L229-L253  ```solidity function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {     address msgSender = _msgSender();     uint256 nftsStakedLength = nftIdsStaked[msgSender].length;     uint256 index;     for (index = 0; index < nftsStakedLength; ++index) {         if (nftIdsStaked[msgSender][index] == _nftId) {             break;         }     }      require(index != nftsStakedLength, "ERR__NFT_NOT_STAKED");     nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];     nftIdsStaked[msgSender].pop();      _sendRewardsForNft(_nftId, _to);     delete nftInfo[_nftId];      (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);     amount /= liquidityProviders.BASE_DIVISOR();     totalSharesStaked[baseToken] -= amount;      lpToken.safeTransferFrom(address(this), msgSender, _nftId);      emit LogWithdraw(msgSender, baseToken, _nftId, _to); } ```   https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L122-L165  ```solidity function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {     NFTInfo storage nft = nftInfo[_nftId];     require(nft.isStaked, "ERR__NFT_NOT_STAKED");      (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);     amount /= liquidityProviders.BASE_DIVISOR();      PoolInfo memory pool = updatePool(baseToken);     uint256 pending;     uint256 amountSent;     if (amount > 0) {         pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;         if (rewardTokens[baseToken] == NATIVE) {             uint256 balance = address(this).balance;             if (pending > balance) {                 unchecked {                     nft.unpaidRewards = pending - balance;                 }                 (bool success, ) = _to.call{value: balance}("");                 require(success, "ERR__NATIVE_TRANSFER_FAILED");                 amountSent = balance;             } else {                 nft.unpaidRewards = 0;                 (bool success, ) = _to.call{value: pending}("");                 require(success, "ERR__NATIVE_TRANSFER_FAILED");                 amountSent = pending;             }         } else {             IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);             uint256 balance = rewardToken.balanceOf(address(this));             if (pending > balance) {                 unchecked {                     nft.unpaidRewards = pending - balance;                 }                 amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);             } else {                 nft.unpaidRewards = 0;                 amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);             }         }     }     nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;     emit LogOnReward(_msgSender(), baseToken, amountSent, _to); } ```  When `withdraw()` is called, `_sendRewardsForNft(_nftId, _to)` will be called to send the rewards.  In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` will be recorded and the user can get it back at the next time.  However, at L244, the whole `nftInfo` is being deleted, so that `nft.unpaidRewards` will also get erased.  There is no way for the user to get back this `unpaidRewards` anymore.  ### Recommendation  Consider adding a new parameter named `force` for `withdraw()`, `require(force || unpaidRewards == 0)` before deleting nftInfo.  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L59 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L196:L224 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L229:L253   # Vulnerability details  ## Impact The `nftIdsStaked` variable introduces a hash collision vulnerability into the `LiquidityFarming.sol` contract as it is employing a mapping from address to a variable length of data field. Source: `https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L59`  The easiest attack scenario allows loss of funds for victims as the attackers can stop victims from unstaking their NFT in the `withdraw` function. Two more complicated attack scenarios allow loss of funds as attackers can outright withdraw nfts of victims.   ## Proof of Concept This attack depends very on the address of the victim an attacker would want to attack. Therefore let me just illustrate the problem.  When using an address mapping to some fixed length data field one can rely on keccak to prevent collisions.  When using an address mapping with an attacker controlled length data field an attacker has a somewhat easy path to create collisions and thereby write to or read from victims data.  The first part to understanding the attack is understanding that all the nfts of a victim are going to be in continous storage locations of the contract. Lets assume that a victims mapped to array starts at 0x1337 and the own 2 nft with the Ids: 23 and 38. The memory layout could look like this:  ``` addr  | val | description ------|-----|---- 0x1337| 2   | length of the array 0x1338| 23   | Id of the first owned nft 0x1339| 38   | Id of the second owned nft ```  Please note if the victim were to deposit more nfts those nftIds would be placed in the storage address 0x133a, 0x133b and so on.  ### Less complex attack scenario The easier attack scenario would involve the attacker generating addresses that result in a continous storage region below address 0x1337. Suppose the attacker were to generate an address whose arrays storage of nftIdsStaked lands at 0x1330. The memory layout would look like this.  ``` addr  | val | description ------|-----|---- 0x1330| 0   | length of the array 0x1337| 2   | length of the array 0x1338| 23   | Id of the first owned nft 0x1339| 38   | Id of the second owned nft ```  It is easy to see, that they could grow their array and thereby corrupting the array of the victim.  They could essentially write nftIds of worthless nftId into the storage of the victim, thereby overwriting their nftId and preventing them (or anybody else) from withdrawing them.  ### More complex attack scenario  The more complex attack scenario involves finding two addresses that will have somewhat adjacent storage regions.  Where the lower storage region encroaches on the length field of the array. The length field is attacker controlled, thereby allowing the attacker to call `withdraw` on arbitrary nftId.  ``` addr  | val | description ------|-----|---- 0x1337| 4   | length of lower array 0x1338| 37   | Id of the first owned (worthless) nft 0x1339| 39   | Id of the second owned (worthless) nft 0x133a| 40   | Id of the third owned (worthless) nft 0x133b| N    | length of higher array (attacker controlled) AND 4th nftId of lower array 0x133a| 42   | Id of the first owned (worthless) nft ```   Please note that this "feels" like a traditional bruteforce attack on keccak (because it is) but it is orders of magnitude more likely to be succesful.  Attackers can essentially trade bruteforcing addresses with calling `deposit` a bunch of times.  As this attack scenario is somewhat less known and more similar to traditional memory corruption attacks allow me to leave a link describing the issue in more detail: `https://xlab.tencent.com/en/2018/11/09/pay-attention-to-the-ethereum-hash-collision-problem-from-the-stealing-coins-incident/`   ## Tools Used Manual audit  ## Recommended Mitigation Steps Track nftIdsStaked like so:  ``` // user address =>        nth nft =>  nft id mapping(address => mapping(uint256 => uint256)) public nftIdsStaked; ```  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L180-L186   # Vulnerability details  ## Impact The `getTokenPriceInLPShares` function calculates the token price in LP shares, but it checks a wrong condition - if supposed to return `BASE_DIVISOR` if the total reserve is zero, not if the total shares minted is zero. This might leads to a case where the price is calculated incorrectly, or a division by zero is happening.   ## Proof of Concept This is the wrong function implementation: ```sol function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {     uint256 supply = totalSharesMinted[_baseToken];     if (supply > 0) {         return totalSharesMinted[_baseToken] / totalReserve[_baseToken];     }     return BASE_DIVISOR; } ``` This function is used in this contract only in the removeLiquidity and claimFee function, so it's called only if funds were already deposited and totalReserve is not zero, but it can be problematic when other contracts will use this function (it's a public view function so it might get called from outside of the contract).  ## Recommended Mitigation Steps The correct code should be: ```sol function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {     uint256 reserve = totalReserve[_baseToken];     if (reserve > 0) {         return totalSharesMinted[_baseToken] / totalReserve[_baseToken];     }     return BASE_DIVISOR; } ```  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityPool.sol#L149-L173 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityPool.sol#L263-L277   # Vulnerability details  ## Impact `depositErc20` allows an attacker to specify the destination chain to be the same as the source chain and the receiver account to be the same as the caller account. This enables an attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state.    ## Proof of Concept This requires the attacker to have some collateral, to begin with. The profit also depends on how much the attacker has. Assume the attacker has enough assets.  In each chain, when the pool is very deficit (e.g. `currentLiquidity` is much less than `providedLiquidity`), which often mean there's a good amount in the Incentive pool after some high valued transfers, then do the following.    - step 1 :  borrow the liquidityDifference amount such that one can get the whole incentivePool. ```             uint256 liquidityDifference = providedLiquidity - currentLiquidity;             if (amount >= liquidityDifference) {                 rewardAmount = incentivePool[tokenAddress]; ``` - step 2 : call `depositErc20()` with `toChainId` being the same chain and `receiver` being `msg.sender`.  The executor will call `sendFundsToUser` to msg.sender. Then a rewardAmount, equivalent to the entire incentive pool (up to 10% of the total pool value), will be added to `msg.sender` minus equilibrium fee (~0.01%) and gas fee.    In the end, the pool is back to the deficit state as before, the incentive pool is drained and the exploiter pockets the difference of rewardAmount minus fees.   This attack can be repeated on each deployed chain multiple times whenever the incentive pool is profitable (particularly right after a big transfer).    ## Tools Used  ## Recommended Mitigation Steps - Disallow `toChainId` to be the source chain by validating it in `depositErc20` or in `sendFundsToUser` validate that `fromChainId` is not the same as current chain.  - require `receiver` is not `msg.sender` in `depositErc20`.      
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/WhitelistPeriodManager.sol#L178-L184 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/WhitelistPeriodManager.sol#L115-L125   # Vulnerability details  ## Impact  The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is removed from the `isExcludedAddress` mapping. While this affects the enforcement of the cap limits and the `getMaxCommunityLpPositon()` function, the worst impact this has is that the address cannot have liquidity removed / transferred due to subtraction overflow.  In particular, users can be prevented from withdrawing their staked LP tokens from the liquidity farming contract should it become non-excluded.  ## Proof of Concept  - Assume liquidity farming address `0xA` is excluded - Bob stakes his LP token - Liquidity farming contract is no longer to be excluded: `setIsExcludedAddressStatus([0xA, false])` - Bob attempts to withdraw liquidity â†’ reverts because `totalLiquidityByLp[USDC][0xA] = 0`, resulting in subtraction overflow.  ```jsx // insert test case in Withdraw test block of LiquidityFarming.tests.ts it.only('will brick withdrawals by no longer excluding farming contract', async () => {   await farmingContract.deposit(1, bob.address);   await wlpm.setIsExcludedAddressStatus([farmingContract.address], [false]);   await farmingContract.connect(bob).withdraw(1, bob.address); });  // results in // Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block) ```  ## Recommended Mitigation Steps  The simplest way is to prevent exclusion removals.  ```jsx function setIsExcludedAddresses(address[] memory _addresses) external onlyOwner {   for (uint256 i = 0; i < _addresses.length; ++i) {     isExcludedAddress[_addresses[i]] = true;     // emit event     emit AddressExcluded(_addresses[i]);   } } ```  
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L151   # Vulnerability details  ## Impact The `depositErc20` function allows setting `tokenAddress = NATIVE` and does not throw an error. No matter the `amount` chosen, the `SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);` call will not revert because it performs a low-level call to `NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`, which is an EOA, and the low-level calls to EOAs always succeed. Because the `safe*` version is used, the EOA not returning any data does not revert either.  This allows an attacker to deposit infinite native tokens by not paying anything. The contract will emit the same `Deposit` event as a real `depositNative` call and the attacker receives the native funds on the other chain.  ## Recommended Mitigation Steps Check `tokenAddress != NATIVE` in `depositErc20`.   
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L319-L322   # Vulnerability details  ## Impact The `getAmountToTransfer` function of `LiquidityPool` updates `incentivePool[tokenAddress]` by adding some fee to it but the formula is wrong and the value of `incentivePool[tokenAddress]` will be divided by `BASE_DIVISOR` (10000000000) each time. After just a few time, the value of `incentivePool[tokenAddress]` will become zero and that amount of `tokenAddress` token will be locked in contract. ## Proof of concept Line 319-322 ``` incentivePool[tokenAddress] = (incentivePool[tokenAddress] + (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) / BASE_DIVISOR; ``` Let `x = incentivePool[tokenAddress]`, `y = amount`, `z = transferFeePerc` and `t = tokenManager.getTokensInfo(tokenAddress).equilibriumFee`. Then that be written as ``` x = (x + (y * (z - t))) / BASE_DIVISOR; x = x / BASE_DIVISOR + (y * (z - t)) / BASE_DIVISOR; ``` ## Recommended Mitigation Steps Fix the bug by change line 319-322 to: ``` incentivePool[tokenAddress] += (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee)) / BASE_DIVISOR; ```   
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L220 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L233   # Vulnerability details  In `deposit` function it is possible to push to `nftIdsStaked` of anyone, an attacker can deposit too many nfts to another user, and when the user will try to withdraw an nft at the end of the list, they will iterate on the list and revert because of gas limit.   
Title: Unnecessary Reentrancy Guards Severity: GAS  Where there is onlyOwner or Initializer modifer, the reentrancy gaurd isn't  necessary (unless you don't trust the owner or the deployer, which will lead to full security breakdown of the project and we believe this is not the case) This is a list we found of such occurrences:           LiquidityFarming.sol no need both nonReentrant and onlyOwner modifiers in reclaimTokens    Title: Change transferFrom to transfer Severity: GAS  'transferFrom(address(this), *, **)' could be replaced by the following more gas efficient 'transfer(*, **)'                This replacement is more gas efficient and improves the code quality.          LiquidityFarming.sol, 250 : lpToken.safeTransferFrom(address(this), msgSender, _nftId);   Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           ExecutorManager.sol, getAllExecutors         LPToken.sol, initialize         LPToken.sol, exists         WhitelistPeriodManager.sol, initialize   Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          LiquidityFarming.sol (L#275) - accumulator += rewardRateLog[_baseToken][i].rewardsPerSecond * (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));    Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           liquidityProviders in LiquidityFarming.sol         tokenManager in LiquidityPool.sol         lpToken in LiquidityFarming.sol    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               LiquidityPool.depositErc20 (tag)         LPToken.initialize (_symbol)         LiquidityPool.sendFundsToUser (depositHash)         LiquidityPool.permitEIP2612AndDepositErc20 (tag)         LiquidityPool.permitAndDepositErc20 (tag)         LiquidityPool.depositNative (tag)         LPToken.updateTokenMetadata (_lpTokenMetadata)         LiquidityPool.checkHashStatus (depositHash)         LPToken.initialize (_name)    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           ExecutorManager.sol, executorArray, 31         TokenManager.sol, tokenConfig, 78         ExecutorManager.sol, executorArray, 47         WhitelistPeriodManager.sol, _tokens, 228         LPToken.sol, nftIds, 77         WhitelistPeriodManager.sol, _addresses, 180    Title: Storage double reading. Could save SLOAD Severity: GAS  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           LiquidityProviders.sol: BASE_DIVISOR is read twice in _increaseLiquidity    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          WhitelistPeriodManager.sol, 180         WhitelistPeriodManager.sol, 228         LPToken.sol, 77         ExecutorManager.sol, 31         ExecutorManager.sol, 47         TokenManager.sol, 78     Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               TokenManager.sol, _msgData, { return ERC2771Context._msgData(); }         TokenManager.sol, _msgSender, { return ERC2771Context._msgSender(); }         WhitelistPeriodManager.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityPool.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityFarming.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityProviders.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LPToken.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityPool.sol, _msgSender, { return ERC2771ContextUpgradeable._msgSender(); }    Title: Use bytes32 instead of string to save gas whenever possible Severity: GAS       Use bytes32 instead of string to save gas whenever possible.     String is a dynamic data structure and therefore is more gas consuming then bytes32.               LPToken.sol (L140), string memory json = Base64.encode( bytes( string( abi.encodePacked( '{"name": "', name(), '", "description": "', description, '", "image": "data:image/svg+xml;base64,', Base64.encode(bytes(svgData)), '", "attributes": ', attributes, "}" ) ) ) );     Title: Unused state variables Severity: GAS  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           LPToken.sol, NATIVE    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           just change to unchecked: ExecutorManager.sol, i, 47         just change to unchecked: LiquidityFarming.sol, index, 233         just change to unchecked: LPToken.sol, i, 77         just change to unchecked: WhitelistPeriodManager.sol, i, 228         just change to unchecked: WhitelistPeriodManager.sol, i, 248         just change to unchecked: TokenManager.sol, index, 78         just change to unchecked: WhitelistPeriodManager.sol, i, 180         just change to unchecked: ExecutorManager.sol, i, 31    Title: Unused inheritance Severity: GAS       Some of your contract inherent contracts but aren't use them at all.     We recommend not to inherent those contracts.              TokenManager.sol; the inherited contracts Pausable not used   Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          WhitelistPeriodManager.sol, _msgData         LiquidityProviders.sol, _addLiquidity         WhitelistPeriodManager.sol, _isSupportedToken   Title: Unused inheritance Severity: GAS       Some of your contract inherent contracts but aren't use them at all.     We recommend not to inherent those contracts.              TokenManager.sol; the inherited contracts Pausable not used   Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          LiquidityPool.sol, line 5, import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";         WhitelistPeriodManager.sol, line 6, import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";         WhitelistPeriodManager.sol, line 5, import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";     Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           LiquidityProviders.sol, 283: change '_amount > 0' to '_amount != 0'         LiquidityPool.sol, 401: change 'balance > 0' to 'balance != 0'         LiquidityPool.sol, 292: change 'balance > 0' to 'balance != 0'
# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L51 https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L52   # Vulnerability details  ## Impact  The **equilibriumFee** and **maxFee** does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions or the LP user will lost all funds when paying the fee.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L52  2. Owner can identify fee amount. That directly affect to LP management. (https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L352)  3. Here you can see there is no upper bound has been defined.   ```     function changeFee(         address tokenAddress,         uint256 _equilibriumFee,         uint256 _maxFee     ) external override onlyOwner whenNotPaused {         require(_equilibriumFee != 0, "Equilibrium Fee cannot be 0");         require(_maxFee != 0, "Max Fee cannot be 0");         tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;         tokensInfo[tokenAddress].maxFee = _maxFee;         emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);     }  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider defining upper and lower bounds on the **equilibriumFee** and **maxFee**.  
https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L30 Consider adding require(!executorStatus[executorArray[i]], "Executor already registered"); in the for loop before calling addExecutor. This will make the transaction faster and will save some gas fees.   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L55 Check if the executor is present and executorStatus is not already set to false. I can call the function in an infinity loop and it can block other transactions to executed while(i == 1){  executorManager.removeExecutor(address) }   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L99 Add zero check for rewardPerSecond. EVen though onlyOwner, it can create zero records and can exhust gas fees   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L170 Check if the baseToken is already added to rewardRateLog. Unless the business logic is to allow override, the emit will exhuast gas fees.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L182 Add zero check for amount. No point in transfering 0 amount. This will cost extra gas fees.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L113 Add zero check before setting baseGas.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L201 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L225 Add zero check. Although zero check if done in functions called further, having zero check at the begainning will definitly help save some gas 
https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L10 The executorstatus map is not really helpful in any business logic. If the executor is present in executors array then the status is true or else false.  Once the executor is added, it cannot be added again even though the status is set to FALSE.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L53 The function removeExecutor is just setting the status to false.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L55 Check if the executor is present and executorStatus is not already set to false.   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/token/svg-helpers/SvgHelperBase.sol#L126 Both inpurt parameters are not used in the function. Remove these.   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L169 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L330 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L333 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L107 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L113 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L123 If function is not called from inside the contract, better to make it external  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L211 NFTInfo storage nft = nftInfo[_nftId]; require(!nft.isStaked, "ERR__NFT_ALREADY_STAKED"); Move above code immidiately after the require(lpToken.isApprovedForAll...). If NFT is not approved, then no need to get token metadata 
