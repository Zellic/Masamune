See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/hansfriese-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/hansfriese-Q.md).
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L178-L182 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L294-L298 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L188   # Vulnerability details  ## Impact `priceTarget` is inconsistent in `StabilizerNode.stabilize` so `stabilize` can do auction instead of selling malt and vice versa.  ## Proof of Concept  In `StabilizerNode.stabilize`, there is an early check using `_shouldAdjustSupply` function.   ```     if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {       lastStabilize = block.timestamp;       impliedCollateralService.syncGlobalCollateral();       return;     } ```  In `_shouldAdjustSupply`, `priceTarget` is calculated by `stabilizeToPeg` and then check if `exchangeRate` is outside of some margin of `priceTarget`.  ```     if (stabilizeToPeg) {       priceTarget = maltDataLab.priceTarget();     } else {       priceTarget = maltDataLab.getActualPriceTarget();     } ```  But in `stabilize`, `priceTarget` is always actual price target of `maltDataLab` regardless of `stabilizeToPeg`. And it decides selling malt or doing auction by the `priceTarget`. So when `stabilizeToPeg` is true, `priceTarget` (= actual price target) can be different from `maltDataLab.priceTarget()` in most cases, and it can cause wrong decision of selling or starting auction after that.   ```     uint256 priceTarget = maltDataLab.getActualPriceTarget(); ``` So when `stabilizeToPeg` is true, `stabilize` can do auction instead of selling malt, or vice versa.   ## Tools Used Manual Review  ## Recommended Mitigation Steps Use same logic as `_shouldAdjustSupply` for `priceTarget`. `priceTarget` should be `maltDataLab.priceTarget()` in `stabilize` when `stabilizeToPeg` is true. 
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L188 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L201-L203   # Vulnerability details  ## Impact `StabilizerNode.stabilize` will revert when `latestSample < priceTarget`.  ## Proof of Concept In StabilizerNode.stabilize, when `exchangeRate > priceTarget` and `_msgSender` is not an admin and not whitelisted, it asserts `livePrice > minThreshold`. And `minThreshold` is calculated as follows: ```     uint256 priceTarget = maltDataLab.getActualPriceTarget(); ``` ```         uint256 latestSample = maltDataLab.maltPriceAverage(0);         uint256 minThreshold = latestSample -           (((latestSample - priceTarget) * sampleSlippageBps) / 10000); ``` This code snippet assumes that `latestSample >= priceTarget`. Although `exchangeRate > priceTarget`, `exchangeRate` is the malt average price during `priceAveragePeriod`. But `latestSample` is one of those malt prices. So `latestSample` can be less than `exchangeRate` and `priceTarget`, so `stabilize` will revert in this case.  ## Tools Used Manual Review  ## Recommended Mitigation Steps  Use `minThreshold = latestSample + (((priceTarget - latestSample) * sampleSlippageBps) / 10000)` when `priceTarget > latestSample`.
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L147-L151 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L185-L186 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L123-L136   # Vulnerability details  ## Impact `LinearDistributor.declareReward` will revert and it can cause permanent DOS.  ## Proof of Concept  In `LinearDistributor.declareReward`, if the balance is greater than the bufferRequirement, the rest will be forfeited.   ```     if (balance > bufferRequirement) {       // We have more than the buffer required. Forfeit the rest       uint256 net = balance - bufferRequirement;       _forfeit(net);     } ```  And in `_forfeit`, it requires forfeited (= balance - bufferRequirement) <= declaredBalance.  ```   function _forfeit(uint256 forfeited) internal {     require(forfeited <= declaredBalance, "Cannot forfeit more than declared"); ```  So when an attacker sends some collateral tokens to `LinearDistributor`, the balance will be increased and it can cause revert in `_forfeit` and `declareReward`.  Since `declareReward` sends vested amount before `_forfeit` and the vested amount will be increased by time, so this DOS will be temporary.   ```     uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;     uint256 balance = collateralToken.balanceOf(address(this));      if (distributed > balance) {       distributed = balance;     }       if (distributed > 0) {       // Send vested amount to liquidity mine       collateralToken.safeTransfer(address(rewardMine), distributed);       rewardMine.releaseReward(distributed);     }      balance = collateralToken.balanceOf(address(this)); ``` But if the attacker increases the balance enough to cover all reward amount in vesting, `declareReward` will always revert and it can cause permanent DOS.  `decrementRewards` updates `declaredBalance`, but it only decreases `declaredBalance`, so it can't mitigate the DOS.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Track collateral token balance and add sweep logic for unused collateral tokens in `LinearDistributor`.
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/SwingTraderManager.sol#L36   # Vulnerability details  ## Impact If `SwingTraderManager.swingTraders()` contains duplicate `traderContract`s, several functions like `buyMalt()` and `sellMalt()` wouldn't work as expected as they work according to traders' balances.  ## Proof of Concept During the swing trader addition, there is no validation that each trader should have a unique `traderContract`.  ```solidity   function addSwingTrader(     uint256 traderId,     address _swingTrader, //@audit should be unique     bool active,     string calldata name   ) external onlyRoleMalt(ADMIN_ROLE, "Must have admin privs") {     SwingTraderData storage trader = swingTraders[traderId];     require(traderId > 2 && trader.id == 0, "TraderId already used");     require(_swingTrader != address(0), "addr(0)");      swingTraders[traderId] = SwingTraderData({       id: traderId,       index: activeTraders.length,       traderContract: _swingTrader,       name: name,       active: active     });      activeTraders.push(traderId);      emit AddSwingTrader(traderId, name, active, _swingTrader);   } ```  So the same `traderContract` might have 2 or more `traderId`s.  When we check `buyMalt()` as an example, it distributes the ratio according to the trader balance and it wouldn't work properly if one trader contract is counted twice and receives more shares that it can't manage.  Similarly, other functions wouldn't work as expected and return the wrong result.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend adding a new mapping like `activeTraderContracts` to check if the contract is added already or not.  Then we can check the trader contract is added only once.
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L163   # Vulnerability details  ## Impact `StabilizerNode.stabilize()` should update `lastTracking` as well to avoid an unnecessary incentive.  Current logic pays unnecessary incentives to track the pool.  ## Proof of Concept `trackPool()` pays an incentive per `trackingBackoff` in order to ensure pool consistency.  ```solidity File: 2023-02-malt\contracts\StabilityPod\StabilizerNode.sol 248:   function trackPool() external onlyActive { 249:     require(block.timestamp >= lastTracking + trackingBackoff, "Too early"); //@audit lastTracking should be updated in stabilize() also 250:     bool success = maltDataLab.trackPool(); 251:     require(success, "Too early"); 252:     malt.mint(msg.sender, (trackingIncentive * (10**malt.decimals())) / 100); // div 100 because units are cents 253:     lastTracking = block.timestamp; 254:     emit Tracking(); 255:   } ```  And `stabilize()` tracks the pool as well and we don't need to pay an incentive unnecessarily in `trackPool()` if `stabilize()` was called recently.  For that, we can update `lastTracking` in `stabilize()`.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend updating `lastTracking` in `stabilize()`.  ```solidity   function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {     // Ensure data consistency     maltDataLab.trackPool();     lastTracking = block.timestamp; //++++++++++++++++      ... ```
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L660 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L139   # Vulnerability details  ## Impact Average `APR`s might be calculated wrongly after calling `populateFromPreviousThrottle()` and `targetAPR` might be changed unexpectedly.  ## Proof of Concept The epoch state struct contains `cumulativeCashflowApr` element and `cashflowAverageApr` is used to adjust `targetAPR` in `updateDesiredAPR()` function.  And `populateFromPreviousThrottle()` is an admin function to change `activeEpoch` and the relevant epoch state using the previous throttle.  And the `activeEpoch` is likely to be increased inside this function.  ```solidity   function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)     external     onlyRoleMalt(ADMIN_ROLE, "Only admin role")   {     RewardThrottle previous = RewardThrottle(previousThrottle);     uint256 _activeEpoch = activeEpoch; // gas      for (uint256 i = _activeEpoch; i < epoch; ++i) {       (         uint256 profit,         uint256 rewarded,         uint256 bondedValue,         uint256 desiredAPR,         uint256 epochsPerYear,         uint256 cumulativeCashflowApr,         uint256 cumulativeApr       ) = previous.epochData(i);        state[i].bondedValue = bondedValue;       state[i].profit = profit;       state[i].rewarded = rewarded;       state[i].epochsPerYear = epochsPerYear;       state[i].desiredAPR = desiredAPR;       state[i].cumulativeCashflowApr = cumulativeCashflowApr;       state[i].cumulativeApr = cumulativeApr;     }      activeEpoch = epoch;   } ```  The problem might occur when `epoch < _activeEpoch + smoothingPeriod` because `state[epoch].cumulativeCashflowApr`and `state[epoch - smoothingPeriod].cumulativeCashflowApr` will be used for `cashflowAverageApr` calculation.  So `cumulativeCashflowApr` of the original epoch and the newly added epoch will be used together and `cashflowAverageApr` might be calculated wrongly.  As a result, `targetAPR` might be changed unexpectedly.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend checking `epoch - _activeEpoch > smoothingPeriod` in `populateFromPreviousThrottle()`.
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L602 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L101   # Vulnerability details  ## Impact `RewardThrottle._sendToDistributor()` reverts if one distributor is inactive.  ## Proof of Concept `RewardThrottle._sendToDistributor()` distributes the rewards to several distributors according to their allocation ratios.  ```solidity File: 2023-02-malt\contracts\RewardSystem\RewardThrottle.sol 575:   function _sendToDistributor(uint256 amount, uint256 epoch) internal { 576:     if (amount == 0) { 577:       return; 578:     } 579:  580:     ( 581:       uint256[] memory poolIds, 582:       uint256[] memory allocations, 583:       address[] memory distributors 584:     ) = bonding.poolAllocations(); 585:  586:     uint256 length = poolIds.length;ratio 587:     uint256 balance = collateralToken.balanceOf(address(this)); 588:     uint256 rewarded; 589:  590:     for (uint256 i; i < length; ++i) { 591:       uint256 share = (amount * allocations[i]) / 1e18; 592:  593:       if (share == 0) { 594:         continue; 595:       } 596:  597:       if (share > balance) { 598:         share = balance; 599:       } 600:  601:       collateralToken.safeTransfer(distributors[i], share); 602:       IDistributor(distributors[i]).declareReward(share); //@audit will revert if one distributor is inactive ```  And `LinearDistributor.declareReward()` has an `onlyActive` modifier and it will revert in case of `inactive`.  ```solidity File: 2023-02-malt\contracts\RewardSystem\LinearDistributor.sol 098:   function declareReward(uint256 amount) 099:     external 100:     onlyRoleMalt(REWARDER_ROLE, "Only rewarder role") 101:     onlyActive 102:   { ```  As a result, `RewardThrottle._sendToDistributor()` will revert if one distributor is inactive rather than working with active distributors only.  ## Tools Used Manual Review  ## Recommended Mitigation Steps I think it's logical to continue to work with active distributors in `_sendToDistributor()`.
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L114 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L227   # Vulnerability details  ## Impact `LinearDistributor.declareReward()` might revert after changing `vestingDistributor` due to uint underflow.  ## Proof of Concept In `LinearDistributor.sol`, there is a [setVestingDistributor()](https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L222-L228) function to update `vestingDistributor`.  And in `declareReward()`, it calculates the `netVest` and `netTime` by subtracting the previous amount and time.  ```solidity File: 2023-02-malt\contracts\RewardSystem\LinearDistributor.sol 112:     uint256 currentlyVested = vestingDistributor.getCurrentlyVested(); 113:  114:     uint256 netVest = currentlyVested - previouslyVested; //@audit revert after change vestingDistributor 115:     uint256 netTime = block.timestamp - previouslyVestedTimestamp; 116:  ```  But there is no guarantee that the vested amount of the new `vestingDistributor` is greater than the previously saved amount after changing the distributor.  Furthermore, there is no option to change `previouslyVested` beside this declareReward() function and it will keep reverting unless the admin change back the distributor.  ## Tools Used Manual Review  ## Recommended Mitigation Steps I think it would resolve the above problem if we change the previous amounts as well while updating the distributor.  ```solidity   function setVestingDistributor(address _vestingDistributor, uint _previouslyVested, uint _previouslyVestedTimestamp)     external     onlyRoleMalt(ADMIN_ROLE, "Must have admin privs")   {     require(_vestingDistributor != address(0), "SetVestDist: No addr(0)");     vestingDistributor = IVestingDistributor(_vestingDistributor);      previouslyVested = _previouslyVested;     previouslyVestedTimestamp = _previouslyVestedTimestamp;   } ```
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/DataFeed/MaltDataLab.sol#L448-L460 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/DataFeed/MaltDataLab.sol#L602-L612   # Vulnerability details  ## Impact `MaltDataLab.getActualPriceTarget()` reverts when `breakpointBps = 10000`.  ## Proof of Concept In `setBreakpointBps()`, it's possible `breakpointBps = 10000`.  ```solidity File: 2023-02-malt\contracts\DataFeed\MaltDataLab.sol 602:   function setBreakpointBps(uint256 _breakpointBps) 603:     external 604:     onlyRoleMalt(ADMIN_ROLE, "Must have admin role") 605:   { 606:     require(_breakpointBps != 0, "Cannot have 0 breakpoint BPS"); 607:     require( 608:       _breakpointBps <= 10000, 609:       "Cannot have a breakpoint BPS greater than 10,000" 610:     ); 611:     breakpointBps = _breakpointBps; 612:   } ```  And in `getActualPriceTarget`, it calculates `m` like the below.  ```solidity File: 2023-02-malt\contracts\DataFeed\MaltDataLab.sol 449:     int128 breakpointInt = ABDKMath64x64.div( //@audit-info purchaseParityInt * breakpointBps / 10000 450:       ABDKMath64x64.mul( 451:         purchaseParityInt, 452:         ABDKMath64x64.fromUInt(breakpointBps) 453:       ), 454:       ABDKMath64x64.fromUInt(10000) 455:     ); 456:     int128 oneInt = ABDKMath64x64.fromUInt(1); 457:  458:     int128 m = (icTotalInt.sub(oneInt)).div( //@audit-info (icTotalInt - 1) / (purchaseParityInt - breakpointInt) 459:       purchaseParityInt.sub(breakpointInt) //@audit revert when breakpointBps = 10000 460:     ); ```  As we can see from the comments, `purchaseParityInt = breakpointInt` when `breakpointBps = 10000` and the `ABDKMath64x64` library reverts on zero division [here](https://github.com/code-423n4/2023-02-malt/blob/main/contracts/libraries/ABDKMath64x64.sol#L239).  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend setting `breakpointBps < 10000` always in `setBreakpointBps()` function.
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/Repository.sol#L236-L242   # Vulnerability details  ## Impact `Repository._updateContract()` is used to change the contract name.  But if this function is called using the `_name` that doesn't have a trader contract yet, the `_name` will have a valid contract without adding to `contracts` array.  ## Proof of Concept `Repository._updateContract()` changes the contract for `_name`.  ```solidity File: 2023-02-malt\contracts\Repository.sol 236:   function _updateContract(string memory _name, address _newContract) internal { //@audit should check if _name has a contract address already 237:     require(_newContract != address(0), "0x0"); 238:     bytes32 hashedName = keccak256(abi.encodePacked(_name)); 239:     Contract storage currentContract = globalContracts[hashedName]; 240:     currentContract.contractAddress = _newContract; 241:     emit UpdateContract(hashedName, _newContract); 242:   } ```  But it doesn't check if `_name` has a non-zero contract already and it will work unexpectedly if the function is called with a new `_name` param.  In this case, the `_name` will have a valid contract but the contract won't be added to `contracts` array.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should revert if `_name` doesn't have a valid contract.  ```solidity   function _updateContract(string memory _name, address _newContract) internal {     require(_newContract != address(0), "0x0");     bytes32 hashedName = keccak256(abi.encodePacked(_name));     Contract storage currentContract = globalContracts[hashedName];      require(currentContract.contractAddress != address(0), "Invalid name"); //++++++++++++++++++      currentContract.contractAddress = _newContract;     emit UpdateContract(hashedName, _newContract);   } ```
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/Repository.sol#L229   # Vulnerability details  ## Impact After removing the contract, the `contracts` array would contain the wrong contract names.  ## Proof of Concept `Repository._removeContract()` removes the contract name from `contracts` array.  ```solidity File: 2023-02-malt\contracts\Repository.sol 223:   function _removeContract(string memory _name) internal { 224:     bytes32 hashedName = keccak256(abi.encodePacked(_name)); 225:     Contract storage currentContract = globalContracts[hashedName]; 226:     currentContract.contractAddress = address(0); 227:     currentContract.index = 0; 228:  229:     uint256 index = currentContract.index; //@audit wrong index 230:     string memory lastContract = contracts[contracts.length - 1]; 231:     contracts[index] = lastContract; 232:     contracts.pop(); 233:     emit RemoveContract(hashedName); 234:   } ```  But it uses the already changed index(= 0) and replaces the last name with 0 index all the time.  As a result, the contracts array will still contain the removed name and remove the valid name at index 0.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should use the original index like below.  ```solidity   function _removeContract(string memory _name) internal {     bytes32 hashedName = keccak256(abi.encodePacked(_name));     Contract storage currentContract = globalContracts[hashedName];      uint256 index = currentContract.index; //++++++++++++++      currentContract.contractAddress = address(0);     currentContract.index = 0;      string memory lastContract = contracts[contracts.length - 1];     contracts[index] = lastContract;     contracts.pop();     emit RemoveContract(hashedName);   } ```
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/GlobalImpliedCollateralService.sol#L116   # Vulnerability details  ## Impact `GlobalImpliedCollateralService.setPoolUpdater()` removes the updater when `_updater == oldUpdater`.  ## Proof of Concept `GlobalImpliedCollateralService.setPoolUpdater()` is used to set or update the pool updaters.  ```solidity   function setPoolUpdater(address _pool, address _updater)     external     onlyRoleMalt(UPDATER_MANAGER_ROLE, "Must have updater manager role")   {     require(_updater != address(0), "GlobImpCol: No addr(0)");     poolUpdaters[_updater] = _pool;     address oldUpdater = poolUpdatersLookup[_pool];     emit SetPoolUpdater(_pool, _updater);     poolUpdaters[oldUpdater] = address(0); //@audit doesn't work when _update = oldUpdater     poolUpdatersLookup[_pool] = _updater;   } ```  But it removes the `oldUpdater` after setting the new updater so it will reset `poolUpdaters[_updater]` when `_updater == oldUpdater`.  As a result, the original updater won't have a relevant role.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend checking `_update != oldUpdater`.  ```solidity   function setPoolUpdater(address _pool, address _updater)     external     onlyRoleMalt(UPDATER_MANAGER_ROLE, "Must have updater manager role")   {     require(_updater != address(0), "GlobImpCol: No addr(0)");     poolUpdaters[_updater] = _pool;     address oldUpdater = poolUpdatersLookup[_pool];      require(_updater != oldUpdater, "Same updater"); //+++++++++++++++++++      emit SetPoolUpdater(_pool, _updater);     poolUpdaters[oldUpdater] = address(0);     poolUpdatersLookup[_pool] = _updater;   } ```
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L445-L455 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L576   # Vulnerability details  ## Impact `RewardThrottle.checkRewardUnderflow()` might calculate the cumulative `APR`s for epochs wrongly.  As a result, `cashflowAverageApr` will be calculated incorrectly in `updateDesiredAPR()`, and `targetAPR` would be changed unexpectedly.  ## Proof of Concept In `checkRewardUnderflow()`, it calls a `_sendToDistributor()` function to update cumulative `APR`s after requesting some capitals from the overflow pool.  ```solidity File: 2023-02-malt\contracts\RewardSystem\RewardThrottle.sol 445:     if (epoch > _activeEpoch) { 446:       for (uint256 i = _activeEpoch; i < epoch; ++i) { 447:         uint256 underflow = _getRewardUnderflow(i); 448:  449:         if (underflow > 0) { 450:           uint256 balance = overflowPool.requestCapital(underflow); 451:  452:           _sendToDistributor(balance, i);  //@audit cumulative apr will be tracked wrongly when epoch > _activeEpoch + 1 453:         } 454:       } 455:     } ```  The main reason for this issue is that `_sendToDistributor()` doesn't update the cumulative `APR`s when `amount == 0` and the below scenario would be possible.  1. Let's assume `activeEpoch = 100` and `epoch = 103`. It's possible if the active epoch wasn't updated for 2 epochs. 2. After that, the `checkRewardUnderflow()` function will call `_fillInEpochGaps()` and the cumulative `APR`s will be settled accordingly. 3. And it will try to request capitals from the `overflowPool` and increase the rewards for epochs. 4. At epoch 100, it requests some positive `balance` from `overflowPool` and increases the cumulative `APR`s for epoch 101 correctly in `_sendToDistributor()`.  ```solidity File: 2023-02-malt\contracts\RewardSystem\RewardThrottle.sol 611:     state[epoch].rewarded = state[epoch].rewarded + rewarded; 612:     state[epoch + 1].cumulativeCashflowApr =  613:       state[epoch].cumulativeCashflowApr + 614:       epochCashflowAPR(epoch); 615:     state[epoch + 1].cumulativeApr =  616:       state[epoch].cumulativeApr + 617:       epochAPR(epoch); 618:     state[epoch].bondedValue = bonding.averageBondedValue(epoch); ``` 5. After that, the `overflowPool` doesn't have any remaining funds and the `balance(At L450)` will be 0 for epochs 101, 102. 6. So `_sendToDistributor()` will be terminated right away and won't increase the cumulative `APR`s of epoch 102 according to epoch 101 and this value won't be changed anymore because the `activeEpoch` is 103 already.  ```solidity File: 2023-02-malt\contracts\RewardSystem\RewardThrottle.sol 575:   function _sendToDistributor(uint256 amount, uint256 epoch) internal {  576:     if (amount == 0) { 577:       return; 578:     } ```  As a result, the cumulative `APR`s will save smaller values from epoch 102 and `cashflowAverageApr` will be smaller also if the `smoothingPeriod` contains such epochs in `updateDesiredAPR()`.  ```solidity File: 2023-02-malt\contracts\RewardSystem\RewardThrottle.sol 139:     uint256 cashflowAverageApr = averageCashflowAPR(smoothingPeriod); ```  So the `updateDesiredAPR()` function will change the `targetAPR` using the smaller average value and the smoothing logic wouldn't work as expected.  ## Tools Used Manual Review  ## Recommended Mitigation Steps I think `_sendToDistributor()` should update the cumulative `APR`s as well when `amount == 0`.  ```solidity   function _sendToDistributor(uint256 amount, uint256 epoch) internal {     if (amount == 0) {         state[epoch + 1].cumulativeCashflowApr = state[epoch].cumulativeCashflowApr + epochCashflowAPR(epoch);         state[epoch + 1].cumulativeApr = state[epoch].cumulativeApr + epochAPR(epoch);         state[epoch].bondedValue = bonding.averageBondedValue(epoch);          return;     } ```
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L690-L696   # Vulnerability details  ## Impact RewardThrottle.setTimekeeper allows POOL_UPDATER_ROLE to update the timekeeper when RewardThrottle is active,  ```solidity   function setTimekeeper(address _timekeeper)     external     onlyRoleMalt(POOL_UPDATER_ROLE, "Must have pool updater privs")   {     require(_timekeeper != address(0), "Not address 0");     timekeeper = ITimekeeper(_timekeeper);   } ``` if newTimekeeper.epoch changes, it will cause the following 1. The newTimekeeper.epoch increases, and the user can immediately call checkRewardUnderflow to fill the gap epoch, thereby distributing a large amount of rewards. 2. The newTimekeeper.epoch decreases, and the contract will use the state of the previous epoch. Since the state.rewarded has reached the upper limit, this will cause the current epoch to be unable to receive rewards. ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L690-L696 ## Tools Used None ## Recommended Mitigation Steps Consider only allowing setTimekeeper to be called when RewardThrottle is not active
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L437-L462   # Vulnerability details  ## Impact In RewardThrottle, both checkRewardUnderflow and fillInEpochGaps call _fillInEpochGaps to fill the state of the previous epoch without profit, the difference being that checkRewardUnderflow will request the reward from the overflowPool and distribute the reward, whereas fillInEpochGaps does not. ```solidity   function checkRewardUnderflow() public onlyActive {     uint256 epoch = timekeeper.epoch();      uint256 _activeEpoch = activeEpoch; // gas      // Fill in gaps so we have a fresh foundation to calculate from     _fillInEpochGaps(epoch);      if (epoch > _activeEpoch) {       for (uint256 i = _activeEpoch; i < epoch; ++i) {         uint256 underflow = _getRewardUnderflow(i);          if (underflow > 0) {           uint256 balance = overflowPool.requestCapital(underflow);            _sendToDistributor(balance, i);         }       }     }   }    function fillInEpochGaps() external {     uint256 epoch = timekeeper.epoch();      _fillInEpochGaps(epoch);   } ``` This results in that when an epoch does not have any profit, then at the start of the next epoch that epoch will have a reward if checkRewardUnderflow is called, and no reward if fillInEpochGaps is called. According to the documentation, when an epoch is not profitable enough, the reward should be requested from the overflowPool, so checkRewardUnderflow should be called. And if fillInEpochGaps is called first, the epoch will lose its reward.  Note: populateFromPreviousThrottle will also cause epochs without any profit to lose their rewards ```solidity   function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)     external     onlyRoleMalt(ADMIN_ROLE, "Only admin role")   {     RewardThrottle previous = RewardThrottle(previousThrottle);     uint256 _activeEpoch = activeEpoch; // gas      for (uint256 i = _activeEpoch; i < epoch; ++i) {       (         uint256 profit,         uint256 rewarded,         uint256 bondedValue,         uint256 desiredAPR,         uint256 epochsPerYear,         uint256 cumulativeCashflowApr,         uint256 cumulativeApr       ) = previous.epochData(i);        state[i].bondedValue = bondedValue;       state[i].profit = profit;       state[i].rewarded = rewarded;       state[i].epochsPerYear = epochsPerYear;       state[i].desiredAPR = desiredAPR;       state[i].cumulativeCashflowApr = cumulativeCashflowApr;       state[i].cumulativeApr = cumulativeApr;     }      activeEpoch = epoch;   } ``` ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L437-L462 ## Tools Used None ## Recommended Mitigation Steps Consider removing the fillInEpochGaps function, or only allowing it to be called when the contract is not active
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/cccz-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/minhquanym-G.md).
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/minhquanym-Q.md).
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L252-L256   # Vulnerability details  ## Impact Contract `SwingTraderManager` has a `totalProfit` variable. It keeps track of total profit swing traders maded during `sellMalt()`. However, the logic for accounting it is wrong so it will not have the correct value. As the results, it can affect other contracts that integrating with `SwingTraderManager` and use this `totalProfit` variable.  ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L252-L258  ```solidity if (amountSold + dustThreshold >= maxAmount) {   return maxAmount; }  totalProfit += profit;  // @audit did not update because already return above  emit SellMalt(amountSold, profit); ```  Function `sellMalt()` has a dust check before returning result. `totalProfit` should be updated before this check as it return the value immediately without updating `totalProfit`.   ## Tools Used Manual Review  ## Recommended Mitigation Steps Updating `totalProfit` before the dust check in function `sellMalt()`. 
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161 https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/DataFeed/MaltDataLab.sol#L326   # Vulnerability details  ## Impact MaltDataLab fetched `priceCumulative` directly from Uniswap V2 pool to calculate price of Malt token. However, it is noticed that Uniswap V2 pool use Solidity 0.5.16, which does not revert when overflow happen. In addition, it is actually commented in Uniswap code that  > * never overflows, and + overflow is desired  https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L77-L81 ```solidity if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {     // * never overflows, and + overflow is desired     price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;     price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; } ```  However, MaltDataLab contracts use Solidity 0.8 and will revert when overflow. It will break the `stabilize()` function and always revert since `stabilize()` call to MaltDataLab contract to get state.  Please note that, with Solidity 0.5.16, when result of addition bigger than `max(uint256)`, it will overflow without any errors. For example, `max(uint256) + 2 = 1`.   So when `price0CumulativeLast` is overflow, the new value of `price0CumulativeLast` will smaller than old value. As the result, when MaltDataLab doing a subtraction to calculate current price, it might get revert.  ## Proof of Concept Function `stabilize()` will call to `MaltDataLab.trackPool()` first https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L163  ```solidity function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {     // Ensure data consistency     maltDataLab.trackPool();     ... } ```  Function `trackPool()` used a formula that will revert when `priceCumulative` overflow in Uniswap pool. https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/DataFeed/MaltDataLab.sol#L323-L329  ```solidity price = FixedPoint     .uq112x112(       uint224(           // @audit might overflow with solidity 0.8.0         (priceCumulative - maltPriceCumulativeLast) /            (blockTimestampLast - maltPriceTimestampLast)       )     ) ```  Scenario: 1. `maltPriceCumulativeLast = max(uint256 - 10)` and `price = 10, timeElapsed = 10`. So the new `priceCumulative = max(uint256 - 10) + 10 * 10 = 99 (overflow)`  2. When doing calculation in Malt protocol, `priceCumulative < maltPriceCumulativeLast`, so `priceCumulative - maltPriceCumulativeLast` will revert and fail  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider using `unchecked` block to match handle overflow calculation in Uniswap V2. 
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L397-L447   # Vulnerability details  ## Impact In SwingTraderManager.addSwingTrader, if active = false, the traderId is also pushed to activeTraders. ```solidity   function addSwingTrader(     uint256 traderId,     address _swingTrader,     bool active,     string calldata name   ) external onlyRoleMalt(ADMIN_ROLE, "Must have admin privs") {     SwingTraderData storage trader = swingTraders[traderId];     require(traderId > 2 && trader.id == 0, "TraderId already used");     require(_swingTrader != address(0), "addr(0)");      swingTraders[traderId] = SwingTraderData({       id: traderId,       index: activeTraders.length,       traderContract: _swingTrader,       name: name,       active: active     });      activeTraders.push(traderId);      emit AddSwingTrader(traderId, name, active, _swingTrader);   } ``` Afterwards, if toggleTraderActive is called on the traderId, the traderId will be pushed to activeTraders again. ```solidity   function toggleTraderActive(uint256 traderId)     external     onlyRoleMalt(ADMIN_ROLE, "Must have admin privs")   {     SwingTraderData storage trader = swingTraders[traderId];     require(trader.id == traderId, "Unknown trader");      bool active = !trader.active;     trader.active = active;      if (active) {       // setting it to active so add to activeTraders       trader.index = activeTraders.length;       activeTraders.push(traderId);     } else { ``` This means that in getTokenBalances()/calculateSwingTraderMaltRatio(), since there are two identical traderIds in activeTraders, the data in this trader will be calculated twice. Wrong getTokenBalances() will result in wrong data when syncGlobalCollateral().  ```solidity   function getTokenBalances()     external     view     returns (uint256 maltBalance, uint256 collateralBalance)   {     uint256[] memory traderIds = activeTraders;     uint256 length = traderIds.length;      for (uint256 i; i < length; ++i) {       SwingTraderData memory trader = swingTraders[activeTraders[i]];       maltBalance += malt.balanceOf(trader.traderContract);       collateralBalance += collateralToken.balanceOf(trader.traderContract);     }   } ``` Wrong calculateSwingTraderMaltRatio() will cause MaltDataLab.getRealBurnBudget()/getSwingTraderEntryPrice() to be wrong. ```solidity   function calculateSwingTraderMaltRatio()     public     view     returns (uint256 maltRatio)   {     uint256[] memory traderIds = activeTraders;     uint256 length = traderIds.length;     uint256 decimals = collateralToken.decimals();     uint256 maltDecimals = malt.decimals();     uint256 totalMaltBalance;     uint256 totalCollateralBalance;      for (uint256 i; i < length; ++i) {       SwingTraderData memory trader = swingTraders[activeTraders[i]];       totalMaltBalance += malt.balanceOf(trader.traderContract);       totalCollateralBalance += collateralToken.balanceOf(         trader.traderContract       );     }      totalMaltBalance = maltDataLab.maltToRewardDecimals(totalMaltBalance);      uint256 stMaltValue = ((totalMaltBalance * maltDataLab.priceTarget()) /       (10**decimals));      uint256 netBalance = totalCollateralBalance + stMaltValue;      if (netBalance > 0) {       maltRatio = ((stMaltValue * (10**decimals)) / netBalance);     } else {       maltRatio = 0;     }   } ``` What's more serious is that even if toggleTraderActive is called again, only one traderId will pop up from activeTraders, and the other traderId cannot be popped up. ```solidity     } else {       // Becoming inactive so remove from activePools       uint256 index = trader.index;       uint256 lastTrader = activeTraders[activeTraders.length - 1];        activeTraders[index] = lastTrader;       activeTraders.pop();        swingTraders[lastTrader].index = index;       trader.index = 0;     } ``` This causes the trade to participate in the calculation of getTokenBalances()/calculateSwingTraderMaltRatio() even if the trade is deactive. Considering that the active parameter is likely to be false when addSwingTrader is called and cannot be recovered, this vulnerability should be high risk ## Proof of Concept ```solidity   function testAddSwingTrader(address newSwingTrader) public {     _setupContract();     vm.assume(newSwingTrader != address(0));     vm.prank(admin);     swingTraderManager.addSwingTrader(3, newSwingTrader, false, "Test");      (       uint256 id,       uint256 index,       address traderContract,       string memory name,       bool active     ) = swingTraderManager.swingTraders(3);      assertEq(id, 3);     assertEq(index, 2);     assertEq(traderContract, newSwingTrader);     assertEq(name, "Test");     assertEq(active, false);     vm.prank(admin);     swingTraderManager.toggleTraderActive(3);     assertEq(swingTraderManager.activeTraders(2),3);     assertEq(swingTraderManager.activeTraders(3),3); // @audit:activeTraders[2] = activeTraders[3] = 3     vm.prank(admin);     swingTraderManager.toggleTraderActive(3);     assertEq(swingTraderManager.activeTraders(2),3);   } ``` https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L397-L447 ## Tools Used None ## Recommended Mitigation Steps Change to ```diff   function addSwingTrader(     uint256 traderId,     address _swingTrader,     bool active,     string calldata name   ) external onlyRoleMalt(ADMIN_ROLE, "Must have admin privs") {     SwingTraderData storage trader = swingTraders[traderId];     require(traderId > 2 && trader.id == 0, "TraderId already used");     require(_swingTrader != address(0), "addr(0)");      swingTraders[traderId] = SwingTraderData({       id: traderId, -     index: activeTraders.length, +     index: active ? activeTraders.lengthÂ : 0,       traderContract: _swingTrader,       name: name,       active: active     }); +  if(active) activeTraders.push(traderId);  -   activeTraders.push(traderId);      emit AddSwingTrader(traderId, name, active, _swingTrader);   } ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/cccz-Q.md).
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161-L237   # Vulnerability details  ## Impact In StabilizerNode.stabilize, impliedCollateralService.syncGlobalCollateral() is called only at the end of the function to synchronize the GlobalImpliedCollateralService data. ```solidity     if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {       lastStabilize = block.timestamp;       impliedCollateralService.syncGlobalCollateral();       return;     } ...     if (trackAfterStabilize) {       maltDataLab.trackPool();     }     impliedCollateralService.syncGlobalCollateral();     lastStabilize = block.timestamp;   } ``` syncGlobalCollateral will use the data in getCollateralizedMalt(), which includes the collateralToken balance in overflowPool/swingTraderManager/liquidityExtension and the malt balance in swingTraderManager. ```solidity   function syncGlobalCollateral() public onlyActive {     globalIC.sync(getCollateralizedMalt());   } ...   function getCollateralizedMalt() public view returns (PoolCollateral memory) {     uint256 target = maltDataLab.priceTarget();      uint256 unity = 10**collateralToken.decimals();      // Convert all balances to be denominated in units of Malt target price     uint256 overflowBalance = maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(       address(overflowPool)     ) * unity) / target);     uint256 liquidityExtensionBalance = (collateralToken.balanceOf(       address(liquidityExtension)     ) * unity) / target;     (       uint256 swingTraderMaltBalance,       uint256 swingTraderBalance     ) = swingTraderManager.getTokenBalances();     swingTraderBalance = (swingTraderBalance * unity) / target; ``` Since StabilizerNode.stabilize will use the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice to stabilize, and maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will use `GlobalImpliedCollateralService.collateralRatio` , to ensure correct stabilization, the data in GlobalServiceImpliedCollateralService should be the latest. ```solidity   function getActualPriceTarget() external view returns (uint256) {     uint256 unity = 10**collateralToken.decimals();     uint256 icTotal = maltToRewardDecimals(globalIC.collateralRatio()); ...   function getSwingTraderEntryPrice()     external     view     returns (uint256 stEntryPrice)   {     uint256 unity = 10**collateralToken.decimals();     uint256 icTotal = maltToRewardDecimals(globalIC.collateralRatio()); ``` But since impliedCollateralService.syncGlobalCollateral() is not called before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice, this will cause StabilizerNode.stabilize to use stale GlobalImpliedCollateralService data, which will make stabilize incorrect.  A simple example would be: 1. impliedCollateralService.syncGlobalCollateral() is called to synchronize the latest data 2. SwingTraderManager.delegateCapital is called, and the collateralToken is taken out from SwingTrader, which will make the `GlobalImpliedCollateralService.collateralRatio` larger than the actual collateralRatio. ```solidity   function delegateCapital(uint256 amount, address destination)     external     onlyRoleMalt(CAPITAL_DELEGATE_ROLE, "Must have capital delegation privs")     onlyActive   {     collateralToken.safeTransfer(destination, amount);     emit Delegation(amount, destination, msg.sender);   } ...   function collateralRatio() public view returns (uint256) {     uint256 decimals = malt.decimals();     uint256 totalSupply = malt.totalSupply();     if (totalSupply == 0) {       return 0;     }     return (collateral.total * (10**decimals)) / totalSupply; // @audit: collateral.total is larger than the actual   } ``` 3. When StabilizerNode.stabilize is called, it will use the stale collateralRatio for calculation. If the collateralRatio is too large, the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will be incorrect, thus making stabilize incorrect.  Since stabilize is a core function of the protocol, stabilizing with the wrong data is likely to cause malt to be depegged, so the vulnerability should be high-risk.  ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161-L237 https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/ImpliedCollateralService.sol#L89-L131 ## Tools Used None ## Recommended Mitigation Steps Call impliedCollateralService.syncGlobalCollateral() before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget.  ```diff   function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {     // Ensure data consistency     maltDataLab.trackPool();      // Finalize auction if possible before potentially starting a new one     auction.checkAuctionFinalization();  +  impliedCollateralService.syncGlobalCollateral();      require(       block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),       "Can't call stabilize"     );     stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;      // used in 3 location.     uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);     bool stabilizeToPeg = onlyStabilizeToPeg; // gas      if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {       lastStabilize = block.timestamp;       impliedCollateralService.syncGlobalCollateral();       return;     }      emit Stabilize(block.timestamp, exchangeRate);      (uint256 livePrice, ) = dexHandler.maltMarketPrice();      uint256 priceTarget = maltDataLab.getActualPriceTarget(); ```
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L660-L688   # Vulnerability details  ## Impact RewardThrottle.populateFromPreviousThrottle allows ADMIN_ROLE to use epochData from previousThrottle to populate state from activeEpoch to epoch in current RewardThrottle. ```solidity   function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)     external     onlyRoleMalt(ADMIN_ROLE, "Only admin role")   {     RewardThrottle previous = RewardThrottle(previousThrottle);     uint256 _activeEpoch = activeEpoch; // gas      for (uint256 i = _activeEpoch; i < epoch; ++i) {       (         uint256 profit,         uint256 rewarded,         uint256 bondedValue,         uint256 desiredAPR,         uint256 epochsPerYear,         uint256 cumulativeCashflowApr,         uint256 cumulativeApr       ) = previous.epochData(i);        state[i].bondedValue = bondedValue;       state[i].profit = profit;       state[i].rewarded = rewarded;       state[i].epochsPerYear = epochsPerYear;       state[i].desiredAPR = desiredAPR;       state[i].cumulativeCashflowApr = cumulativeCashflowApr;       state[i].cumulativeApr = cumulativeApr;     }      activeEpoch = epoch;   } ``` But since populateFromPreviousThrottle and _fillInEpochGaps have basically the same function, a malicious user can call fillInEpochGaps to front-run populateFromPreviousThrottle. ```solidity   function _fillInEpochGaps(uint256 epoch) internal {     uint256 epochsPerYear = timekeeper.epochsPerYear();     uint256 _activeEpoch = activeEpoch; // gas      state[_activeEpoch].bondedValue = bonding.averageBondedValue(_activeEpoch);     state[_activeEpoch].epochsPerYear = epochsPerYear;     state[_activeEpoch].desiredAPR = targetAPR;      if (_activeEpoch > 0) {       state[_activeEpoch].cumulativeCashflowApr =         state[_activeEpoch - 1].cumulativeCashflowApr +         epochCashflowAPR(_activeEpoch - 1);       state[_activeEpoch].cumulativeApr =         state[_activeEpoch - 1].cumulativeApr +         epochAPR(_activeEpoch - 1);     }      // Avoid issues if gap between rewards is greater than one epoch     for (uint256 i = _activeEpoch + 1; i <= epoch; ++i) {       if (!state[i].active) {         state[i].bondedValue = bonding.averageBondedValue(i);         state[i].profit = 0;         state[i].rewarded = 0;         state[i].epochsPerYear = epochsPerYear;         state[i].desiredAPR = targetAPR;         state[i].cumulativeCashflowApr =           state[i - 1].cumulativeCashflowApr +           epochCashflowAPR(i - 1);         state[i].cumulativeApr = state[i - 1].cumulativeApr + epochAPR(i - 1);         state[i].active = true;       }     }      activeEpoch = epoch;   } ``` The only difference is that it seems that populateFromPreviousThrottle can make epoch and activeEpoch greater than timekeeper.epoch(), thereby updating the state for future epochs, but _fillInEpochGaps makes activeEpoch = timekeeper.epoch(), thereby invalidating populateFromPreviousThrottle for future updates. (This usage should be very unlikely) ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L660-L688 ## Tools Used None ## Recommended Mitigation Steps If populateFromPreviousThrottle is used to initialize the state in the current RewardThrottle, it should be called on contract setup
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/LinearDistributor.sol#L111-L153   # Vulnerability details  ## Impact In LinearDistributor.declareReward , distributed represents the reward to distribute and is calculated using netVest(currentlyVested - previouslyVested). At the same time, distributed cannot exceed balance, which means that if balance < linearBondedValue * netVest / vestingBondedValue, part of the rewards in netVest will be lost. ```solidity     uint256 netVest = currentlyVested - previouslyVested;     uint256 netTime = block.timestamp - previouslyVestedTimestamp;      if (netVest == 0 || vestingBondedValue == 0) {       return;     }      uint256 linearBondedValue = rewardMine.valueOfBonded();      uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;     uint256 balance = collateralToken.balanceOf(address(this));      if (distributed > balance) {       distributed = balance;     }  ``` At the end of the function, previouslyVested is directly assigned to currentlyVested instead of using the Vested adjusted according to distributed, which means that the previously lost rewards will also be skipped in the next distribution. ```solidity     previouslyVested = currentlyVested;     previouslyVestedTimestamp = block.timestamp; ``` Also, in the next distribution, bufferRequirement will be small because distributed is small, so it may increase the number of forfeits. ```     if (netTime < buf) {       bufferRequirement = (distributed * buf * 10000) / netTime / 10000;     } else {       bufferRequirement = distributed;     }      if (balance > bufferRequirement) {       // We have more than the buffer required. Forfeit the rest       uint256 net = balance - bufferRequirement;       _forfeit(net);     } ``` ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/LinearDistributor.sol#L111-L153 ## Tools Used None ## Recommended Mitigation Steps Consider adapting previouslyVested based on distributed ```diff     uint256 linearBondedValue = rewardMine.valueOfBonded();      uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;     uint256 balance = collateralToken.balanceOf(address(this));      if (distributed > balance) {       distributed = balance; +    currentlyVested = distributed * vestingBondedValue / linearBondedValue + previouslyVested;     } ```
# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L64-L74   # Vulnerability details  ## Impact MaltRepository inherits from AccessControl and adds validation of validRoles to the hasRole function, which means that even if super.hasRole(role, account) == true, if validRoles[role] == false hasRole will return false, which will cause _revokeRole to not work correctly. ```solidity   function hasRole(bytes32 role, address account)     public     view     override     returns (bool)   {     // Timelock has all possible permissions     return       (super.hasRole(role, account) && validRoles[role]) ||       super.hasRole(TIMELOCK_ROLE, account);   } ``` Consider the case where alice is granted ADMIN_ROLE, then ADMIN_ROLE is removed in the removeRole function, validRoles[ADMIN_ROLE] == false.  ```solidity   function removeRole(bytes32 role) external onlyRole(getRoleAdmin(role)) {     validRoles[role] = false;     emit RemoveRole(role);   } ``` Now if the revokeRole function is called on alice, in the _revokeRole, since hasRole returns false, alice's ADMIN_ROLE will not be revoked.   Since removeRole ends silently, this may actually cause the caller to incorrectly assume that alice's ADMIN_ROLE has been revoked  ```solidity     function _revokeRole(bytes32 role, address account) internal virtual {         if (hasRole(role, account)) {             _roles[role].members[account] = false;             emit RoleRevoked(role, account, _msgSender());         }     } ``` In addition, the renounceRole and _transferRole functions will also be affected. In particular, the _transferRole function, if you want to transfer alice's role to bob, both alice and bob will have the role if validRoles[role]==false. ```solidity   function _transferRole(     address newAccount,     address oldAccount,     bytes32 role   ) internal {     _revokeRole(role, oldAccount);     _grantRole(role, newAccount);   } ...     function renounceRole(bytes32 role, address account) public virtual override {         require(account == _msgSender(), "AccessControl: can only renounce roles for self");          _revokeRole(role, account);     } ``` ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L64-L74 https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L99-L102 ## Tools Used None ## Recommended Mitigation Steps Override renounceRole and removeRole in the MaltRepository and modify them as follows ```diff     function renounceRole(bytes32 role, address account) public virtual override { +     require(validRoles[role], "Unknown role");         require(account == _msgSender(), "AccessControl: can only renounce roles for self");          _revokeRole(role, account);     } ...     function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) { +     require(validRoles[role], "Unknown role");         _revokeRole(role, account);     } ...   function _transferRole(     address newAccount,     address oldAccount,     bytes32 role   ) internal { +  require(validRoles[role], "Unknown role");     _revokeRole(role, oldAccount);     _grantRole(role, newAccount);   } ```
See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/KingNFT-Q.md).
