## Risk rating Medium Risk  ## Links to affected code https://github.com/OpenCoreCH/cid-c4-squad/blob/4558d25aa8ea92644f3e778457fd6708104e0f24/src/CidNFT.sol#L192-L199  ## Impact Subprotocol NFTs may be trapped in contract CidNFT forever.  ## Proof of Concept When [adding NFT to CidNFT with AssociationType ORDERED or PRIMARY](https://github.com/OpenCoreCH/cid-c4-squad/blob/4558d25aa8ea92644f3e778457fd6708104e0f24/src/CidNFT.sol#L192-L199), the cidData is written directly, without checking and handling the case that a previously added nft may not have been removed:    ```   if (_type == AssociationType.ORDERED) {       if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);       cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;       emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);   } else if (_type == AssociationType.PRIMARY) {       if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);       cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;       emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);   ...   ```  For `AssociationType.ORDERED`: If `(key1, subNft1)` and `(key1, subNft2)` were added consecutively, `subNft1` would be trapped in the contract forever, because `subNft1` stored in `cidData` was overwritten by `subNft2`, and only `subNft2` can be retrieved through `CidNFT.remove()`.  For `AssociationType.PRIMARY`: If `subNft1` and `subNft2` were added consecutively, `subNft1` would be trapped in the contract forever, because `subNft1` stored in `cidData` was overwritten by `subNft2`, and only `subNft2` can be retrieved through `CidNFT.remove()`.  Test code for PoC: ``` diff --git a/src/test/CidNFT.t.sol b/src/test/CidNFT.t.sol index 8a6a87a..45d91bd 100644 --- a/src/test/CidNFT.t.sol +++ b/src/test/CidNFT.t.sol @@ -67,6 +67,81 @@ contract CidNFTTest is DSTest, ERC721TokenReceiver {          vm.stopPrank();      }   +    function testTrappedByAddingOrdered() public { +        address user = user2; +        vm.startPrank(user); + +        // mint two nft for user +        (uint256 nft1, uint256 nft2) = (101, 102); +        sub1.mint(user, nft1); +        sub1.mint(user, nft2); +        sub1.setApprovalForAll(address(cidNFT), true); +        // mint CidNFT +        uint256 cid = cidNFT.numMinted() + 1; +        cidNFT.mint(new bytes[](0)); +        uint256 key = 111; + +        // add nft1 to CidNFT a key +        cidNFT.add(cid, "sub1", key, nft1, CidNFT.AssociationType.ORDERED); +        // add nft2 to CidNFT with the same key +        cidNFT.add(cid, "sub1", key, nft2, CidNFT.AssociationType.ORDERED); + +        // confirm: both nft1 and nft2 have been transferred to CidNFT +        assertEq(sub1.ownerOf(nft1), address(cidNFT)); +        assertEq(sub1.ownerOf(nft2), address(cidNFT)); + +        // the first remove will success +        cidNFT.remove(cid, "sub1", key, nft1, CidNFT.AssociationType.ORDERED); +        // nft2 has been transferred back to the user +        assertEq(sub1.ownerOf(nft2), user); + +        // the second remove will fail for OrderedValueNotSet +        vm.expectRevert(abi.encodeWithSelector(CidNFT.OrderedValueNotSet.selector, cid, "sub1", key)); +        cidNFT.remove(cid, "sub1", key, nft1, CidNFT.AssociationType.ORDERED); +        // nft1 is trapped in CidNFT forever +        assertEq(sub1.ownerOf(nft1), address(cidNFT)); + +        vm.stopPrank(); +    } + +    function testTrappedByAddingPrimary() public { +        address user = user2; +        vm.startPrank(user); + +        // mint two nft for user +        (uint256 nft1, uint256 nft2) = (101, 102); +        sub1.mint(user, nft1); +        sub1.mint(user, nft2); +        sub1.setApprovalForAll(address(cidNFT), true); +        // mint CidNFT +        uint256 cid = cidNFT.numMinted() + 1; +        cidNFT.mint(new bytes[](0)); +        // key is useless when adding PRIMARY type +        uint256 key = 111; + +        // add nft1 to CidNFT +        cidNFT.add(cid, "sub1", key, nft1, CidNFT.AssociationType.PRIMARY); +        // add nft2 to CidNFT +        cidNFT.add(cid, "sub1", key, nft2, CidNFT.AssociationType.PRIMARY); + +        // confirm: both nft1 and nft2 have been transferred to CidNFT +        assertEq(sub1.ownerOf(nft1), address(cidNFT)); +        assertEq(sub1.ownerOf(nft2), address(cidNFT)); + +        // the first remove will success +        cidNFT.remove(cid, "sub1", key, nft1, CidNFT.AssociationType.PRIMARY); +        // nft2 has been transferred back to the user +        assertEq(sub1.ownerOf(nft2), user); + +        // the second remove will fail for PrimaryValueNotSet +        vm.expectRevert(abi.encodeWithSelector(CidNFT.PrimaryValueNotSet.selector, cid, "sub1")); +        cidNFT.remove(cid, "sub1", key, nft1, CidNFT.AssociationType.PRIMARY); +        // nft1 is trapped in CidNFT forever +        assertEq(sub1.ownerOf(nft1), address(cidNFT)); + +        vm.stopPrank(); +    } +      function testAddID0() public {          // Should revert if trying to add NFT ID 0          vm.expectRevert(abi.encodeWithSelector(CidNFT.NotAuthorizedForCIDNFT.selector, address(this), 0, address(0))); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Should revert the tx if an overwriting is found in [CidNFT.add()](https://github.com/OpenCoreCH/cid-c4-squad/blob/4558d25aa8ea92644f3e778457fd6708104e0f24/src/CidNFT.sol#L192-L199): ``` diff --git a/src/CidNFT.sol b/src/CidNFT.sol index b6c88de..c389971 100644 --- a/src/CidNFT.sol +++ b/src/CidNFT.sol @@ -101,6 +101,8 @@ contract CidNFT is ERC721, ERC721TokenReceiver {      error AssociationTypeNotSupportedForSubprotocol(AssociationType associationType, string subprotocolName);      error NotAuthorizedForCIDNFT(address caller, uint256 cidNFTID, address cidNFTOwner);      error NotAuthorizedForSubprotocolNFT(address caller, uint256 subprotocolNFTID); +    error OrderedKeyIsSetAlready(uint256 cidNFTID, string subprotocolName, uint256 key, uint256 nftIDToAdd); +    error PrimaryIsSetAlready(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);      error ActiveArrayAlreadyContainsID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);      error OrderedValueNotSet(uint256 cidNFTID, string subprotocolName, uint256 key);      error PrimaryValueNotSet(uint256 cidNFTID, string subprotocolName); @@ -191,10 +193,16 @@ contract CidNFT is ERC721, ERC721TokenReceiver {          }          if (_type == AssociationType.ORDERED) {              if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName); +            if (cidData[_cidNFTID][_subprotocolName].ordered[_key] != 0) { +                revert OrderedKeyIsSetAlready(_cidNFTID, _subprotocolName, _key, _nftIDToAdd); +            }              cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;              emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);          } else if (_type == AssociationType.PRIMARY) {              if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName); +            if (cidData[_cidNFTID][_subprotocolName].primary != 0) { +                revert PrimaryIsSetAlready(_cidNFTID, _subprotocolName, _nftIDToAdd); +            }              cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;              emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);          } else if (_type == AssociationType.ACTIVE) { ```
# Lines of code  https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/AddressRegistry.sol#L47   # Vulnerability details  Users can register their on-chain identity (ie their CID NFT) by calling `AddressRegistry.register()`  ```solidity File: src/AddressRegistry.sol 42:     function register(uint256 _cidNFTID) external { 43:         if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender) 44:             // We only guarantee that a CID NFT is owned by the user at the time of registration 45:             // ownerOf reverts if non-existing ID is provided 46:             revert NFTNotOwnedByUser(_cidNFTID, msg.sender); 47:         cidNFTs[msg.sender] = _cidNFTID; 48:         emit CIDNFTAdded(msg.sender, _cidNFTID); 49:     } ```  This overwrites `cidNFTs[msg.sender]` with the `cidNFTID` provided by the caller.  The issue is that there is nothing preventing several (2 or more) accounts to point to the same `cidNFTID`, ie have `cidNFTs[userA] == cidNFTs[userB]`  Note: the README mentioned that  ``` Transferring CID NFTs that are still referenced in the address registry: CID NFTs are transferrable on purpose and a user can transfer his CID NFT while it is still registered to his address if he wants to do so. ```  The issue described in this report is not that the CID NFT is transferrable, but that several accounts can point to the same CIDNFT id, which lead to several problems outlined below.   ## Impact   Quoting the README: ``` Canto Identity NFTs (CID NFTs) represent individual on-chain identities ```   Here, several accounts can point to the same on-chain identity, breaking the requirement that the said identity should be **individual**  To illustrate the consequences of this, let us look at `CidNFT.add()`, which adds a new entry for the given subprotocol to the provided CID NFT: - data is added by transferring a subprotocol NFT to the contract, which will write the NFT id in `cidData[_cidNFTID][_subprotocolName]` - This NFT id represents traits that will be associated with the identity.  Because of the issue outlined above, the identity system can be abused:   - Alice registers her CIDNft by calling `addressRegistry.register(N)` - she transfers it to Bob, who then proceeds to call `addressRegistry.register(N)` to register it. - at this point, `cidNFT` of id `N` points to both Alice and Bob: `addressRegistry.getCID(Alice) == addressRegistry.getCID(Bob)` - Bob calls `CidNFT.add()` to add a subProtocol NFT X to his identity `N` . Because Alice is also associated to the `CIDNFT` `N`, she essentially added this trait for free (assuming subprotocols will monetize their tokens, Bob had to pay the cost of the subProtocol NFT X, but Alice did not). - This can also have further consequences depending on what can be done with these traits (e.g: a protocol giving rewards for users with a trait of the subProtocol NFT X, Bob could be front run by Alice and not receive a reward he was entitled to)  Overall, because this issue impacts a key aspect of the protocol (identities are not individual) and can lead to a form of `theft` in certain conditions (in the scenario above, Alice got a trait added to her identity for "free"), the Medium severity seems appropriate.   ## Proof Of Concept This test shows how two users can point to the same `CID`. Add it to `AddressRegistry.t.sol`  ```solidity function testTwoUsersSameCID() public {     uint256 nftIdOne = 1;     address Alice = users[0];     address Bob = users[1];      // 1 - Alice mints NFT     vm.startPrank(Alice);     bytes[] memory addList;     cidNFT.mint(addList);     assertEq(cidNFT.ownerOf(nftIdOne), Alice);      // 2 - Alice registers the NFT     addressRegistry.register(nftIdOne);      // 3 - Alice transfers the CID NFT to Bob     cidNFT.transferFrom(Alice, Bob, nftIdOne);     vm.stopPrank();      // 4 - Bob registers the nft     vm.startPrank(Bob);     addressRegistry.register(nftIdOne);      // 5 - Alice and Bob have the same identity     uint256 cidAlice = addressRegistry.getCID(Alice);     uint256 cidBob = addressRegistry.getCID(Bob);     assertEq(cidAlice, cidBob); } ```   ## Tools Used  Manual Analysis, Foundry  ## Mitigation  `AddressRegistry` should have an additional mapping to track the account associated with a given `cifNTFID`.  ```diff File: src/AddressRegistry.sol 20:     /// @notice Stores the mappings of users to their CID NFT 21:     mapping(address => uint256) private cidNFTs; +       mapping(uint256 => address) private accounts; ```  When registering, the code would check if the `cidNFTID` has an account associated with it. If that is the case, `cidNFTs` for this user would be set to 0, preventing several users from having the same identity.  ```diff File: src/AddressRegistry.sol 42: function register(uint256 _cidNFTID) external { 43:         if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender) 44:             // We only guarantee that a CID NFT is owned by the user at the time of registration 45:             // ownerOf reverts if non-existing ID is provided 46:             revert NFTNotOwnedByUser(_cidNFTID, msg.sender); +           if (accounts[_cidNFTID] != address(0)) { +                 delete cidNFTs[accounts[_cidNFTID]]; +                 emit CIDNFTRemoved(accounts[_cidNFTID], _cidNFTID); +} 47:         cidNFTs[msg.sender] = _cidNFTID; +           accounts[_cidNFTID] = msg.sender; 48:         emit CIDNFTAdded(msg.sender, _cidNFTID); 49:     } ```
# Lines of code  https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L147-L157 https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L177-L182   # Vulnerability details  ## Impact `CidNFT.mint()` has an optional parameter `_addList` that enables users to register subprotocol NFTs to the CID NFT right after the mint.  However, there is no guarantee that the `_cidNFTID`  encoded in `_addList` is the same ID as the newly minted NFT. If there is a pending mint transaction and another user frontrun the mint transaction with higher fee, the previous transaction will revert as the `_cidNFTID` is no longer the expected ID.  [CidNFT.sol#L177-L182](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L177-L182) ```solidity address cidNFTOwner = ownerOf[_cidNFTID]; if (     cidNFTOwner != msg.sender &&     getApproved[_cidNFTID] != msg.sender &&     !isApprovedForAll[cidNFTOwner][msg.sender] ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner); ``` A malicious actor can grief this by frontrunning users that try to mint with non-zero `_addList`, causing their mint transaction to fail.   In absence of malicious actor, it is also possible for this issue to happen randomly during busy period where a lot of users are trying to mint at the same time.  ## Proof of Concept - The next CidNFT mint ID is `1000`. - Alice wants to mint and prepares `_addList` with the expected `_cidNFTID` of `1000`. - Bob saw Alice's transaction and frontran her, incrementing the next minting ID to `1001`. - Alice's transaction tries to add subprotocol NFTs to ID `1000` which is owned by Bob. This causes the transaction to revert.  ## Recommended Mitigation Steps Modify `mint` so that the minted ID is the one used during the `add` loop, ensuring that `mint` will always succeed.
# Lines of code  https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L140   # Vulnerability details  [`CidNFT#tokenURI`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L133-L142) does not convert the `uint256 _id` argument to a string before interpolating it in the token URI:  ```solidity     /// @notice Get the token URI for the provided ID     /// @param _id ID to retrieve the URI for     /// @return tokenURI The URI of the queried token (path to a JSON file)     function tokenURI(uint256 _id) public view override returns (string memory) {         if (ownerOf[_id] == address(0))             // According to ERC721, this revert for non-existing tokens is required             revert TokenNotMinted(_id);         return string(abi.encodePacked(baseURI, _id, ".json"));     }  ```  This means the raw bytes of the 32-byte ABI encoded integer `_id` will be interpolated into the token URI, e.g. `0x0000000000000000000000000000000000000000000000000000000000000001` for ID #1.   Most of the resulting UTF-8 strings will be malformed, incorrect, or invalid URIs. For example, token ID #1 will show up as the invisible "start of heading" control character, and ID #42 will show as the asterisk symbol `*`. URI-unsafe characters will break the token URIs altogether.  **Impact** - `CidNFT` tokens will have invalid `tokenURI`s. Offchain tools that read the `tokenURI` view may break or display malformed data.  **Suggestion**  Convert the `_id` to a string before calling `abi.encodePacked`. Latest Solmate includes a `LibString` helper library for this purpose:  ```solidity     import "solmate/utils/LibString.sol";      /// @notice Get the token URI for the provided ID     /// @param _id ID to retrieve the URI for     /// @return tokenURI The URI of the queried token (path to a JSON file)     function tokenURI(uint256 _id) public view override returns (string memory) {         if (ownerOf[_id] == address(0))             // According to ERC721, this revert for non-existing tokens is required             revert TokenNotMinted(_id);         return string(abi.encodePacked(baseURI, LibString.toString(_id), ".json"));     }  ```  **Test case**  ```solidity     function test_InvalidTokenURI() public {         uint256 id1 = cidNFT.numMinted() + 1;         uint256 id2 = cidNFT.numMinted() + 2;         // mint id1         cidNFT.mint(new bytes[](0));         // mint id2         cidNFT.mint(new bytes[](0));          // These pass â€” the raw bytes '0000000000000000000000000000000000000000000000000000000000000001' are interpolated as _id.         assertEq(string(bytes(hex"7462643a2f2f626173655f7572692f00000000000000000000000000000000000000000000000000000000000000012e6a736f6e")), cidNFT.tokenURI(id1));         assertEq(string(bytes(hex"7462643a2f2f626173655f7572692f00000000000000000000000000000000000000000000000000000000000000022e6a736f6e")), cidNFT.tokenURI(id2));          // These fail - the generated string on the right is not the expected string on the left.          assertEq("tbd://base_uri/1.json", cidNFT.tokenURI(id1));         assertEq("tbd://base_uri/2.json", cidNFT.tokenURI(id2));     } ```
# Lines of code  https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L147 https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L165 https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L237   # Vulnerability details  ## Impact High - an attacker can steal deposited NFTs from victims using the `mint()` + `add()` functionality in `CidNFT.sol`  ## Proof of Concept  One of the core features of CID Protocol is the ability for users to attach Subprotocol NFTs to their `CidNFT`. The `CidNFT` contract custodies these attached NFTs, and they are regarded as "traits" of the user.   The protocol currently includes functionality for a user to mint a `CidNFT` as their identity and then optionally add a subprotocol NFT to that `CidNFT` in the same transaction. This occurs in the `mint()` function of `CidNFT.sol`, which takes a byte array of `add()` parameters and includes a loop where `add()` can be repeatedly called with these parameters to attach subprotocol NFTs to the `CidNFT`.  ```  function mint(bytes[] calldata _addList) external {     _mint(msg.sender, ++numMinted);      bytes4 addSelector = this.add.selector;     for (uint256 i = 0; i < _addList.length; ++i) {         (bool success /*bytes memory result*/, ) = address(this)             .delegatecall(abi.encodePacked(addSelector, _addList[i]));         if (!success) revert AddCallAfterMintingFailed(i);     } } ``` One of the arguments for `add()` is the `_cidNFTID` to which the user would like to attach their outside NFT. However, `_cidNFTID` is specified in calldata to `mint()`, and there is no guarantee that the user is actually `add()`ing to the `CidNFT` that they just minted. There is only a check in `add()` that the user is either the owner or approved for that `CidNFT`.    ``` function add(         uint256 _cidNFTID, // No guarantee that this is the CidNFT id that was just minted by the user         string calldata _subprotocolName,         uint256 _key,         uint256 _nftIDToAdd,         AssociationType _type     ) external {     ...............     if (         cidNFTOwner != msg.sender &&         getApproved[_cidNFTID] != msg.sender &&         !isApprovedForAll[cidNFTOwner][msg.sender]     ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);     ............... } ```  This opens up the following attack:  1. Victim sends a transaction expecting to mint `CidNFT #100`, and includes calldata to `add()` their SubprotocolNFT to the token in the same tx 2. Attacker frontruns this transaction with a `mint()` with no `add()` parameters, receives `CidNFT #100`, and sets the victim as approved for that token 3. The victim's transaction begins execution, and they instead receive token #101, though their `add()` calldata still specifies token #100 4. The victim's `add()` call continues, and their SubprotocolNFT is registered to `CidNFT #100` and transferred to the `CidNFT` contract 5. The attacker can then either revoke approval to the victim for `CidNFT #100` or immediately call `remove()` to transfer the victim's SubprotocolNFT to themselves  Below is a forge test executing this attack. This should run if dropped into `CidNFT.t.sol`. ``` function testMaliciousMint() public {     uint256 cidTokenId = cidNFT.numMinted() + 1;     (uint256 subTokenId1, uint256 subTokenId2) = (1, 2);     (uint256 key1, uint256 key2) = (1, 2);      // user1 == attacker     // user2 == victim     // Frontrun the victim's mint by minting the cidNFT token they expect before them     vm.startPrank(user1);     cidNFT.mint(new bytes[](0));      // Set the victim (user2) as approved for the token user1 just minted     cidNFT.setApprovalForAll(user2, true);     vm.stopPrank();      // Mint user2 the subtokens that user1 wants to steal, approve the CidNFT contract     // for the subtokens, and prepare the addlist with the incorrect cidNFT token id     vm.startPrank(user2);     sub1.mint(user2, subTokenId1);     sub1.mint(user2, subTokenId2);     sub1.setApprovalForAll(address(cidNFT), true);      bytes[] memory addList = new bytes[](2);     addList[0] = abi.encode(         cidTokenId,         "sub1",         key1,         subTokenId1,         CidNFT.AssociationType.ORDERED     );     addList[1] = abi.encode(         cidTokenId,         "sub1",         key2,         subTokenId2,         CidNFT.AssociationType.ORDERED     );      // Mint user2 a new CidNFT and attach the subtokens to user1's CidNFT     cidNFT.mint(addList);     vm.stopPrank();      // Confirm that user1's CidNFT has the subtokens and can transfer them out     vm.startPrank(user1);     cidNFT.remove(         cidTokenId,         "sub1",         key1,         subTokenId1,         CidNFT.AssociationType.ORDERED     );     cidNFT.remove(         cidTokenId,         "sub1",         key2,         subTokenId2,         CidNFT.AssociationType.ORDERED     );     vm.stopPrank();      // Confirm that user1 now holds the subtokens     assertEq(cidNFT.ownerOf(cidTokenId), user1);     assertEq(cidNFT.ownerOf(cidTokenId + 1), user2);     assertEq(sub1.ownerOf(subTokenId1), user1);     assertEq(sub1.ownerOf(subTokenId2), user1); } ## Tools Used Manual review  ## Recommended Mitigation Steps - Enforce that the user can only `add()` to the CidNFT that they just minted rather than allowing for arbitrary IDs
