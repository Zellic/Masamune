1. Discrepancy in BaseStrategy versioning Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The git blame of BaseFeeOracle.sol from the yearn-vaults repo shows that the entire file is a new addition for yearn-vaults release v0.4.5. The file diff for PR #546 confirms the introduction of baseFee values in the v0.4.5 release. 
2. estimatedTotalAssets() does not include value of reward tokens Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The function name estimatedTotalAssets() implies all value held by the strategy is accounted for. The rewards from the staking pool are not, however, included in this calculation. This means after _claimRewards() is called in prepareReturn(), the value of _profit doesn't include the rewards just claimed. The _profit only includes these rewards after ySwap or Cowswap swaps the reward to want, which causes a delay in perceived profits. It may be intentional to only include the value of want and LP tokens in this calculation. Because this is a public function, other users or protocols may assume the function does account for all forms of value held by the strategy, which is an incorrect assumption. Instead, after rewards are claimed by the strategy and are converted into want tokens, the total assets of this strategy will suddenly increase. The amount of this sudden increase could vary depending on how often the rewards are redeemed from the staking pool and how often they are swapped for want. Beyond the inclusion of rewards in the profit and asset values, without guarantees around when the ySwap process will happen, it is possible that the strategy may hold the reward tokens in the form of STG or eTokens for some time. This would delay the start of compound interest on those rewards. Clearer guarantees or incentives to minimize the time between harvest() and the ySwap would resolve this. 
3. Loss calculation discrepancies Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The loss calculation in prepareReturn() is calculated with several assumptions. We will examine each step of the calculations and the relevant assumptions. The first loss calculation is in withdrawSome(). The loss will be zero if _potentialLoss < balanceOfLPTokens. This calculation assumes the LP tokens have the value that the Stargate pool advertises, which is a multiple of the underlying want asset (with bridge fees slowly adding to this value). But relying on the Pool to provide the value of an LP token assumes that the Pool is working normally and all LP tokens can be withdrawn. If the LP tokens cannot be withdraw, they will have zero value and cannot be assumed to compensate for any potential loss. The delta credit calculation is a complex algorithm, so it should be evaluated whether this complexity may introduce risk. The loss calculation may be problematic for liquidatePosition(), where the BaseStrategy describes the return values with the comment This function should return the amount of want tokens made available by the liquidation. If there is a difference between them, _loss indicates whether the difference is due to a realized loss, or if there is some other sitution at play (e.g. locked funds) where the amount made available is less than what is needed. Because withdrawSome() returns a loss of 0 even when there are locked funds, it may not meet with the described goal of the loss return value in liquidatePosition() if locked funds are considered losses (either because of temporary delta credit limits or because of a hack). The second loss calculation is in prepareReturn(). The calculation depends on whether _vaultDebt > _totalAssets is true. The problem with this is that a separate finding explains how estimatedTotalAssets() does not include the value of reward tokens, and _totalAssets = estimatedTotalAssets() in this calculation. If there is substantial value stored in reward tokens, the value of _totalAssets would be lower than the value of assets held by the strategy, meaning the loss value may be calculated as a larger loss than in reality once the reward tokens are factored in. The third loss calculation is at the end of prepareReturn(). This calculation compares loss to profit, but like the previous step of loss calculations, profit is dependent on estimatedTotalAssets(), so the profit may be less than in actuality. If _loss > _profit, then the reduction in loss may partially cancel out the inflation of the loss from the previous step, but if _loss <= _profit, then loss would not receive this adjustment. 
4. Variables set to Ethereum addresses Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The strategy is planned to use on other chains, like Optimism. These variables should be defined per chain. 
5. Emergency unstake forgoes extra rewards even when they can be claimed Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: _emergencyUnstakeLP is an internal function executed during migration, or during admin-initiated emergency exits. In the former case, migration can be required even if the staker contract is still functional and is receiving rewards. In the latter case, admin can call emergency unstake by mistake when the rewards are still claimable. In both cases, pending rewards will be discarded and irrecoverably stuck in the Stargate LP staker contract. 
6. Duplicate line of code Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: In prepareReturn(), the forceHarvestTriggerOnce variable gets set to false. However, the BaseStrategy does the exact same thing right after the call to prepareReturn() is completed, even with the same comment. This line of code (and the comment) is redundant. 
7. Use BaseStrategy logic for gas savings Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The BaseStrategy saves an if statement in harvestTrigger() by returning the final boolean directly. The current strategy implementation is not as direct. 
8. Use Solidity errors in 0.8.4+ Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Require statements are used in the strategy and error messages are not used anywhere. Using this new solidity feature can provide gas savings on revert conditions. 
9. Use simple comparison Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The prepareReturn() function contains this code: if (_liquidWant <= _profit) { _profit = _liquidWant; _debtPayment = 0; // enough to pay for all profit and _debtOutstanding (partial or full) } else { _debtPayment = Math.min(_liquidWant - _profit, _debtOutstanding); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (_liquidWant > _profit) { _debtPayment = Math.min(_liquidWant - _profit, _debtOutstanding); } else { _profit = _liquidWant; _debtPayment = 0; // enough to pay for all profit and _debtOutstanding (partial or full) } 
10. Use unchecked if no underflow risk Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The first location where unchecked can be applied - _profit = _totalAssets > _vaultDebt ? _totalAssets - _vaultDebt : 0; + unchecked { _profit = _totalAssets > _vaultDebt ? _totalAssets - _vaultDebt : 0; } The second location where unchecked can be applied - (_amountFreed, _loss) = withdrawSome( - _toLiquidate - _wantBalance - ); + unchecked { (_amountFreed, _loss) = withdrawSome( + _toLiquidate - _wantBalance + ); } Similar savings can be found throughout the contract because many logic checks remain from a recent commit where the strategy was migrated from an older version of solidity that did not have built-in SafeMath to a newer version that does have SafeMath. Other examples are found here, here, here, here, here, here, here, here, here, and here. 
11. Remove unneeded variables Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: _amountFreed is set in prepareReturn() but is never used after that point. The variable and the lines setting it can be deleted to save gas. In withdrawSome(), _liquidatedAmount is used only to return the proper value, and in on branch of the if statement _liquidatedAmount is set to _liquidAssets. Instead of creating a new temporary variable _liquidAssets, use _liquidatedAmount instead and change the if statement logic to - uint256 _liquidAssets = balanceOfWant() - _preWithdrawWant; + _liquidatedAmount = balanceOfWant() - _preWithdrawWant; - if (_amountNeeded > _liquidAssets) { + if (_amountNeeded > _liquidatedAmount) { - _liquidatedAmount = _liquidAssets; uint256 balanceOfLPTokens = _lpToLd(balanceOfAllLPToken()); - uint256 _potentialLoss = _amountNeeded - _liquidAssets; + uint256 _potentialLoss = _amountNeeded - _liquidatedAmount; _loss = _potentialLoss > balanceOfLPTokens ? _potentialLoss - balanceOfLPTokens:0; } else { _liquidatedAmount = _amountNeeded; } At L218 there is no need define _liquidWant and call balanceOfWant(). Recalculate _ wantBalance after L213. Remove variable _liquidWant and use _wantBalance instead. 
12. Remove unneeded if statement Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: withdrawSome() contains an if statement of if (_amountNeeded > 0). The two instances where this internal function is called is on line 210 and line 298. In both instances, the _amountNeeded function argument is greater than zero, so the if statement can be removed because the code in the if statement will always be used. 
13. Unnecessary internal function call Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: _lpToLd() calls liquidityPool.amountLPtoLD(). _lpToLd() is only used once, in withdrawSome(). liquidityPool.amountLPtoLD() is already called directly in valueOfLPTokens(), so _lpToLd() may as well be removed and the single instance of it replaced with a direct call to the external function. The same approach could be taken with _stakeLP() which calls the external lpStaker.deposit() function. 
14. balanceOfReward() can be external Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: If a function is only called externally and does not need to be called internally, it can be declared external for gas savings. Apply this to balanceOfReward(). 
15. Faster return from function Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: If the input param _amountNeeded is 0 there is no need to do any calculations. 
16. Minor fix not applied to mainnet strats Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Changes in recent commits, such as 36ddf75 and a1aaf31, contain changes that do not appear in the mainnet strategy contract code. The code on mainnet is using an older version of the contract code. Although the differences do not appear to impact the logic of the strategy, it is normally a good idea to update code on mainnet when improvements are made. 
17. Incorrect comment(s) Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There is a comment Amount of tokens that all strategies have borrowed in the strategy on the line of code for vault.strategies(address(this)).totalDebt. This comment was copied from the Vault contract's comment about the Vault's totalDebt state variable, and does not properly describe the code on this line because this line uses the totalDebt value in the StrategyParams struct for a specific strategy. 
18. Interfaces are not cleanly defined Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Several unexpected situations are found in the interface files: The standard IERC20 interface file does not have a token() function, but the IERC20Metadata.sol file has a token() function. This is probably a mistake that should be fixed because token() should only be called on pool addresses and is defined in IPool. Instead, consider adding name() to this interface like the OpenZeppelin IERC20Metadata.sol file. The ILPStaking interface contains pendingStargate() and pendingEmissionToken() functions. These functions are not found in the same Stargate contract. The interface combines functions from LPStaking and LPStakingTime to avoid creating a new interface file. decimals() can be removed from IWETH.sol because it is not used in the strategy. 
19. tradeFactory.disable() never called Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: setTradeFactory() is designed to migrate to a new ySwaps trade factories. _removeTradeFactoryPermissions() removes the approval of the old tradeFactory before a new one is approved. _removeTradeFactoryPermissions() does not call tradeFactory.disable(), but it might be preferable to do so and follow the design of how the TradeFactory contract was written. 
20. Could use Stargate RouterETH for WETH/SGETH conversion Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The list of Stargate contracts deployed on mainnet shows two router contracts, one named Router and one named RouterETH. Strangely, the RouterEth contract does not exist in the main branch of Stargate's github repository. The code is verified on Etherscan and shows that RouterEth.sol integrates with the SGETH contract to support ETH deposits. The addLiquidityETH() function in RouterEth could serve the same purpose as the custom _convertWETHtoSGETH() found in the strategy. Whether it is better to use existing code outside of the strategy or create an implementation in the strategy is up to the developers to determine, and the choice may come down to gas cost. 
21. Documentation improvements possible Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The only difference between harvestTrigger() in BaseStrategy and Strategy is that the Strategy implementation adds a check for the minReportDelay value and uses > maxReportDelay instead of >= maxReportDelay. Most of the logic in the custom implementation could be replaced by a super.harvestTrigger() as suggested in the BaseStrategy NatSpec. 
22. No USDT pool on Optimism Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: A comparison was done of the Stargate contracts on the different chains where Yearn Finance operates (mainnet, Arbitrum, and Optimism). The deployed contracts are listed in the Stargate docs. The findings from this comparison were: Mainnet and Arbitrum contracts of Stargate are identical Optimism has no USDT pool There are two differences between Arbitrum and Optimism a) The USDC Pool.sol on Optimism uses a flattened import structure for some odd reason, but otherwise the logic is the same in the pool contract and all imported files b) The LPStaking contract on Arbitrum and mainnet is renamed to LPStakingTime on Optimism and these contract have many differences: i) The LPStakingTime contract on Optimism uses an "eToken" with emissions for rewards (not STG). The eToken is OP, the Optimism token. It is a standard OpenZeppelin ERC20 token rather than the custom StarGate token that is not a simple OpenZeppelin ERC20. ii) The LPStakingTime contract on Optimism uses block.timestamp instead of block.number because this is one of the known differences in Optimism. iii) Some functions in LPStakingTime are external while the same function in LPStaking is public. 
23. == true unnecessary for boolean evaluation Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Booleans evaluated with true in the form require(wantIsWETH == true) can be simplified to require(wantIsWETH). The longer form may be easier to understand depending on the reader. 
24. aeWETH on Arbitrum is not an exact WETH9 clone Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: aeWETH on Arbitrum inherits WETH9 but is not an exact clone of the Ethereum mainnet WETH9 contract like WETH on Optimism. Extra attention may be needed here when deploying the strategy on Arbitrum for WETH. 
25. Rename variable Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The name _liquidAssets is a bit misleading because it represents only a part of liquid assets, i.e. liquidated assets. 
26. Use vault decimals Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Decimals data is stored in the vault. No need to add additional imports. 
27. Use explicit uint type Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Style change. 
28. Unused interface IPriceFeed Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Interface is defined but not used in the code. 
29. Missing protected token Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Sweeping LP token, strategy will report a loss. Only unstaken LP tokens can be sweeped. PoC: def test_sweep_lp(gov, vault, strategy, token, user, amount, token_lp, chain, RELATIVE_APPROX): # 1- Deposit to the vault token.approve(vault.address, amount, {"from": user}) vault.deposit(amount, {"from": user}) assert token.balanceOf(vault.address) == amount strategy.setDoHealthCheck(False, {"from": gov}) # 2- Harvest chain.sleep(1) strategy.harvest({"from": gov}) assert pytest.approx(strategy.estimatedTotalAssets(), rel=RELATIVE_APPROX) == amount # 3- Unstake LP tokens strategy.unstakeLP(amount, {"from": gov}) # 4- Sweep LP tokens unprotected_tokens = [token_lp] for token in unprotected_tokens: strategy.sweep(token, {"from": gov}) # Strategy lost all of it's money assert pytest.approx(strategy.estimatedTotalAssets(), rel=RELATIVE_APPROX) == 0 # Strategy still has debt assert vault.strategies(strategy).dict()["totalDebt"] == amount # 5- Report loss chain.sleep(1) tx = strategy.harvest({"from": gov}) assert tx.events["StrategyReported"]["loss"] == amount assert vault.strategies(strategy).dict()["totalLoss"] == amount 
30. Change function emergencyUnstakeLP() visibility Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Current visibility is set to public but can be changed to external because strategy uses internal function implementation _emergencyUnstakeLP(). 
31. Reward token can be swept by governance Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: BaseStrategy contract has a virtual function to define which tokens cannot be swept by the governance. The Strategy contract does not honor this by not setting the reward token as protected. 
32. Reverts are missing reason string Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There are five instances of this issue (1, 2, 3, 4, 5). 
33. Returned address from create is not explicitly checked to be non-zero Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: In assembly, create does not revert when a deployment fails. It instead returns zero address. This is currently not an issue because there is an implicit check due to the call made to the newStrategy. However, not having an explicit check might cause this to be overlooked in future refactorings of the code. 
34. Missing Zero-Address Check Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The lpStaker assignment in initializeThis() is missing a zero address check. Granted, there is an implicit revert when a function is called on zero address; however, debugging an unnamed revert could end up consuming valuable time. As such, a zero address check would expedite Strategy deployment and operation by quickly reverting during the construction of the contract if the LPStaker address passed is a zero address. 
35. Cache storage variables Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Accessing a state variable for the first time in a function takes 2100 gas (Gcoldsload), and then 100 gas (Gwarmaccess) for each additional time. So, it is best to cache (store in a stack/ memory) the storage variable if there are multiple reads for it within the same function. 
36. Use calldata for unchanging external function args Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: We can use calldata instead of memory for array, struct or mapping type arguments in external functions, which are not mutated in the function. This will save gas since the argument would not need to be saved into memory first. 
37. Use uint256 for bool values Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: On the EVM, changing a state variable from 0 to non-zero uses Gsset and incurs 20,000 gas. In case of bools, every time a bool is changed from false ( value of 0), to true, Gsset cost of 20,000 is incurred. 
38. Unnecessary declaration for Abi Coder pragma Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Abi Coder v2 is enabled by default since Solidity 0.8.0, hence it is not necessary to explicitly enable it. 
39. Constant is not named in capital letters Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The official Solidity style guide recommends using all capital letters for contants. However, the constant max does not adhere to this guideline. 
40. Anyone can send ETH to the contract via the receive() function Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The receive() function allows the Strategy contract to receive ETH from the WETH contract when the want token is WETH. However, anyone can send ETH to the contract via the receive() function as the address that sends the ETH isn't checked. 
41. Possible precision loss via the _ldToLp function Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: In the _ldToLp function the value returned is calculated by first dividing and then multiplying. This could lead to precision loss when liquidityPool.convertRate() != 1. If the convertRate() changes, the _ldToLp function will return lower value than expected. 
