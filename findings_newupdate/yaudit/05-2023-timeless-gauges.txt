1. VeBeacon contract vulnerable to denial of service Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The following code reverts when ETH is left on the contract. if (address(this).balance != 0) revert VeBeacon__LeftoverEth(); This ensures users don't overpay for the Arbitrum bridge, but it has two issues: An attacker will be able to DOS the contract by sending some ETH dust that will remain, causing the check to revert. A user might get his transaction reverted because the Arbitrum fee might change between the time the transaction is broadcasted and the time it gets executed. VeBeacon.sol#L66 
2. Potential denial of service vulnerability in bridger contracts Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: When a user tries to bridge tokens like USDT that doesn't return a boolean value on transferFrom() and approve() function calls, the operation will fail since the Bridger contracts use the assert statement to validate the function call's success. In Vyper, the assert function throws an exception if the condition is unmet and reverts all changes. 
3. Child gauge vulnerability: uncontrolled reward addition by managers Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: Refer to ChildGauge.vy#L579 for the relevant code snippet. 
4. unkillGauge should checkpoint funds distribution to prevent distributing for the time it was killed Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The function unkillGauge() merely changes the gauge state flag to active. User reward claims will trigger a checkpoint that will distribute rewards for the period up until the last checkpoint, which was set when the gauge was 'killed'. Consequently, this distributes rewards corresponding to the duration in which the pool was inactive. 
5. Potential user exploitation of boost adjustment mechanism Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The function at ChildGauge.vy#L699 sets a new boost value. While a 'kick' function exists, it cannot be utilized to update a user's effective balance. The kick() method can only be used when the user has updated a lock. 
6. Rewards can be locked in Gauges Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: childGuage.vy function deposit_reward_token allows anyone to create, and rewards distribution is done using the reward rate. Still, if the reward distributor deposits _amount (in WEI) less than 1 WEEK (or 604800 Wei), the transferred rewards will be locked into the contract. self.reward_data[_reward_token].rate = _amount / WEEK If _amount 
7. Add missing input validation on constructor/initializer/setters Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Certain functions are missing necessary input validation. In childGaugeFactory.vy: set_implementation, set_voting_escrow, deploy_gauge, and __init__. In childGuage.vy: __init__, add_reward, set_manager, initialize. 
8. Potential user manipulation of Uniswap deposit to claim rewards within range Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: For more information, refer to ChildGauge.vy#L744. 
9. votingEscrow.epoch() can't be zero if a user created a lock Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The following code snippet is not necessary: if (epoch == 0) revert VeBeacon__EpochIsZero(); This check is redundant as a validation already exists in line 117. If a user has created a lock, the global epoch cannot be zero, as confirmed in the ve contract. VeBeacon.sol#L122 
10. Consolidating Gauge State Setters for Gas Optimization Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Multiple setters are currently used to modify the gauge_state value. To optimize gas usage, it is recommended to consolidate these setters into a single function. 
11. Potential transaction order discrepancy and impact on total supply calculation in sidechain Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There is no warranty on transaction ordering from L1 to L2. A transaction can be mined on L1, fail on L2, and then be retried later, resulting in a different order. Here is an example: User A creates a lock that will last for 4 years. User A broadcasts their lock to L2. User B creates a lock that will last two weeks. User B broadcasts their lock to L2. If the broadcast from User B is processed by L2 before the one from User A, then the slope changes corresponding to the end of the lock from User B will be removed from the corresponding variable when User A's transaction is processed on L2. 
12. Optimizing bytecode size by removing unused constant variable Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There is an unused constant variable in the contract childGaugeFactory.vy that should be removed. 
13. Missing events for critical operations Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Ideally, the following critical operations should trigger events. In VeRecipient constructor() should emit SetBeacon In childGuage, following function lacks event emission. killGauge() unkillGauge() makeGaugePermissionless() set_manager() deposit_reward_token() kick() set_reward_distributor() add_reward() claim_rewards() set_rewards_receiver() In rootGuage, following functions lacks event emission. set_killed() 
14. Leveraging new syntax in Vyper 0.3.4 for default return value Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The existing codebase uses low-level raw_calls for safe calls. This can be simplified using the new syntax. 
