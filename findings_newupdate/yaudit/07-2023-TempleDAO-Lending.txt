1. Debtor debt can be cleared if rate is set to zero Severity: High Difficulty: n/a Type: n/a Target: n/a Description: Debtor interests are calculated using the function _compoundedDebtorInterest(). The implementation of this function will return zero if the rate is set to zero: function _compoundedDebtorInterest(Debtor storage debtor) internal view returns (uint256) { uint256 _rate = debtor.rate; if (_rate == 0) return 0; .... If the interest rate is first set to a positive number and then later set to zero, then the accrued debt of the debtor will be nullified as it will be reset to zero. As we can see in the following snippet of code, the return value of _compoundedDebtorInterest() will be stored in debtor.checkpoint, which represents the current accrued debt. function _checkpointDebtor(Debtor storage debtor) internal returns (uint256) { uint256 interest = _compoundedDebtorInterest(debtor); unchecked { estimatedTotalRiskPremiumInterest += (interest - debtor.checkpoint); } debtor.checkpoint = uint160(interest); debtor.checkpointTime = uint32(block.timestamp); return interest; } Note also that balanceOf() and currentDebtOf() will be affected as these use _compoundedDebtorInterest() internally. 
2. TPI can still be updated while there is a pending change Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The TreasuryPriceIndexOracle.sol uses a cooldown mechanism for price updates. Whenever the price is updated using setTreasuryPriceIndex(), the contract will store the overwritten value and will continue to return this price as long as the cooldown duration is in effect. However, there's nothing preventing this function from being called again during the cooldown period. Doing so will nullify the cooldown for the current change: the currentTpi value (which should be active after the cooldown) will become the previousTpi and treasuryPriceIndex() will return this value before the original cooldown expires. After discussions with the devs, it was determined that the cooldown is intended to allow for the TPI to be changed again during the cooldown period if the first TPI value was set incorrectly. The logic flow in this case where setTreasuryPriceIndex() is called a 2nd time during the cooldown period to fix an error causes an even larger problem. The problem is that during the cooldown period, the previous TPI value is considered the correct TPI value. If an incorrect TPI value is set, it will be stored in the currentTpi variable, but when it gets replaces with a second setTreasuryPriceIndex() call, the value previously stored in currentTpi will be stored as previousTpi. This means the incorrect TPI value will immediately become the real TPI value used by the protocol during the process of attempting to replace and fix the original mistake. The result is that the cooldown and the surrounding logic potentially make the situation worse than if the contract didn't implement the cooldown, because in the current flow, an attempt to fix a mistake by updating the TPI causes the mistaken TPI value to immediately be used in production. Note also that it is possible to adjust the cooldown duration while there is a current pending change too. This is another way that the TPI can be changed faster than the existing cooldown. 
3. Updating the debt ceiling for the line of credit strategy should trigger an update to the interest rate Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The calculation of the interest rate in the line of credit contract depends on the interest rate model and the utilization ratio, which is the debt over the available amount of tokens, defined as the debt ceiling of the strategy. If any of these values changes, the interest rate should be updated. While the rate is updated when the strategy changes, there is nothing ensuring that the interest rate is recalculated if the debt ceiling for the line of credit strategy gets updated in the TreasuryReservesVault.sol contract. 
4. Possibility of TLC bad debt from TPI increase Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The TPI is a value that is set by TempleDAO governance. This value is updated in a single block. For example, the latest TPI increase can be seen with: cast call 0xC3133cB9e685ccc82C73FbE580eCeDC667B41917 "templePriceFloorNumerator()(uint256)" --block 17737310 Return Value: 10250 cast call 0xC3133cB9e685ccc82C73FbE580eCeDC667B41917 "templePriceFloorNumerator()(uint256)" --block 17737311 Return Value: 10600 The TPI value is assumed to be equal to the price of TEMPLE when the value of TEMPLE collateral is calculated in TempleLineOfCredit.sol. This is in contrast to lending protocols such as Compound Finance, which use the current price of a token from Chainlink to determine the value of user collateral. It is possible, in fact likely, that the TPI value is greater than the value of TEMPLE based on the spot price of the Balancer pool. The graph illustrating the variation of the two prices is found on TempleDAO's homepage. If the difference between the spot price in the Balancer pool and the TLC is too great, an arbitrageur can leave the protocol with bad debt. Consider a scenario where TPI was at $1, the spot price of TEMPLE is $0.90, and the TPI was just raised by governance to $1.15: User takes DAI flashloan from Balancer with a 0% cost. User swaps DAI for TEMPLE in TEMPLE-DAI balancer pool. The volume of the swap can raise the TEMPLE price in the pool to $0.95 User deposits the newly acquired TEMPLE into the TLC and maxes out their LTC with a 85% LTV loan. The user will get liquidated almost immediately because the interest accumulated in the next block will cause them to exceed the max LTC threshold of 85%. But the user doesn't care, because $1 worth of DAI got them 1/0.95 = 1.053 TEMPLE. This TEMPLE is valued at 1.053*1.15 = $1.211 and can have 85% of its value borrowed, which is 1.211*0.85 = 1.029 In this example scenario, the arbitrageur walks away with a 2.9% profit. The bad debt will lower the holdings of the TempleDAO treasury and reduce the TPI, impacting TEMPLE token price. Another version of this bad debt scenario can happen in reverse if the TPI is decreased significantly while the TEMPLE spot price is significantly below TPI: User takes TEMPLE flashloan from Balancer with a 0% cost. User deposits TEMPLE into TLC, takes out DAI loan with max LTV when TPI is high relative to current TEMPLE token price. User swaps DAI to TEMPLE in Balancer pool when TEMPLE price is below TPI. User repays flashloan, retaining any profit. The profit comes at the expense of the TempleDAO treasury. There are already some protective measures preventing this scenario, but because these protective measures are controlled by governance, it's possible that future protocol changes may limit the effectiveness of these protective measures. The protective measures include: RAMOS should rebalance the price of TEMPLE in the Balancer pool if the price of TEMPLE drops below 1% of the TPI (note: the script linked to was not in the commit hash that the audit focused on). The maxTreasuryPriceIndexDelta value limits how large of a change the TPI can experience thanks to a check in setTreasuryPriceIndex(). The current choice of setting maxTreasuryPriceIndexDelta to 0.05 combined with the current choice of setting the max LTV to 0.85 should protect the protocol. However, be aware these values can be changed by governance, and there is no cooldown on setTreasuryPriceIndex(), meaning there is no real limit to how much governance can increase TPI in a single block. The first protective measure mentioned, the RAMOS rebalancing, is run by a bot controlled by governance. This bot is running off-chain and has the potential for more downtime that the Ethereum blockchain. Therefore, when consider extreme edge cases, the most extreme case is a scenario where the RAMOS bot is offline and is temporarily unable to stabilize the price of TEMPLE in the Balancer pool. 
5. checkNSignatures() logic causes revert Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: SafeForked.checkNSignatures() has an extra line require(keccak256(data) == dataHash, "GS027"); that is not found in v1.3.0. This line is found in the latest v1.4.1 release of the Gnosis Safe code. But the values of dataHash and data in the gnosis code are set differently than in the TempleDAO code. When checkNSignatures() is called from ThresholdSafeGuard.checkTransaction() with the line SafeForked.checkNSignatures(safeTxExecutor, safe, keccak256(txHashData), data, signatures, threshold);, the expectation is that data == txHashData to pass the later require statement. But data != txHashData because txHashData consists of encoded values that includes data. If this require() check fails, all calls to ThresholdSafeGuard.checkTransaction() that include at least one contract signature (when v == 0) will fail, reverting the transactions passing through the Gnosis guard. After discussions with the development team, the bug exists in the if/else branch where v == 0. This logical branch is not expected to be reached because the new governance multisig that will be using the Gnosis Safe Guard will only have EOA signers and no smart contract signers. This means the problematic line of code should not be reached by TempleDAO logic. 
6. Can repay debt for wrong borrow token Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: repay() and repayAll() accept a token and strategy function argument. There are two valid token values, the DAI address or the TEMPLE address. This is confirmed by the existing strategies and the deployment scripts for dUSD and dTEMPLE as the only debt tokens. There is no verification that the token and strategy arguments match, meaning that the token address can be a borrow token that does not match with the borrow token used by the strategy. The only strategy that handles more than one token (DAI and TEMPLE) is the Ramos strategy, so the other strategies should be limited to accumulating only debt in the token that they handle. It is unclear how the debt token and credit balances are queried off-chain to handle accounting of the overall system (this accounting is not performed on-chain with an equivalent of yearn vault's report()), but this scenario may cause accounting issues if the debt and credit balances are handled improperly. The caller of repay() does donate tokens to the protocol, so there is a cost to this call flow. A foundry test demonstrating this issue, based on the existing test_repay_withDTokenDebts_noCreditLeft test: function test_repay_withDTokenDebts_wrongToken() public { // Setup the config { vm.startPrank(executor); trv.setBorrowToken(dai, address(0), 0, 0, address(dUSD)); trv.setBorrowToken(temple, address(0), 0, 0, address(dTEMPLE)); deal(address(dai), address(trv), 120e18, true); deal(address(temple), address(trv), 120e18, true); ITempleStrategy.AssetBalance[] memory debtCeiling = new ITempleStrategy.AssetBalance[](1); debtCeiling[0] = ITempleStrategy.AssetBalance(address(dai), 50e18); trv.addStrategy(address(strategy), -123, debtCeiling); } // Borrow some so there's a debt { changePrank(address(strategy)); trv.borrow(dai, 5e18, address(strategy)); } // Fund alice so she can repay on behalf of the strategy { deal(address(temple), alice, 50e18, true); changePrank(address(alice)); temple.approve(address(trv), 50e18); } { trv.repay(temple, 7e18, address(strategy)); } // TEMPLE transferred to TRV, dToken DAI credit given to strategy as it started with no debt assertEq(dai.balanceOf(address(strategy)), 5e18); assertEq(dai.balanceOf(address(trv)), 120e18 - 5e18); assertEq(temple.balanceOf(address(alice)), 50e18-7e18); assertEq(trv.strategyTokenCredits(address(strategy), dai), 0); assertEq(trv.strategyTokenCredits(address(strategy), temple), 7e18); assertEq(dUSD.balanceOf(address(strategy)), 5e18); assertEq(dTEMPLE.balanceOf(address(strategy)), 0); } 
7. Potential clashing between function calls and ETH payments in ThresholdSafeGuard.sol Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Threshold configurations for functions are stored in a mapping whose keys are the contract address and the function selector. The check then queries this mapping to fetch the associated threshold setting. ETH transfer transactions are represented by a function selector of zero, as indicated by this comment: @dev functionSignature=bytes(0) is ok as this represents an ETH transfer which may also have an explicit threshold. As zero function selectors are valid (see issue Function selectors with a zero value are valid), this unveils a potential clashing between a function whose selector is zero and an ETH transfer. The checkTransaction() function casts the calldata parameter to bytes4 without checking the size: ... threshold = getThreshold(to, bytes4(data)); ... If the data argument is empty, then bytes4(data) will be zero, creating a conflict with a potential call to a function with a zero selector. 
8. currentUtilisation() can return stale data Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The logic of _currentUtilisation() is to loop through the buckets and sums the amounts. But this naive approach omits the possibility that the buckets contain old data that will be cleared on the next preCheck() and therefore the values stored in some buckets may not be relevant to checking the proximity to the current cap. These stale buckets should be ignored, the same way those stale buckets are cleared in preCheck(). This is only an issue when _currentUtilisation() is called from currentUtilisation(), because when called from preCheck() the buckets are updated before the call to _currentUtilisation(). 
9. setConfig() resets buckets and gives minor circuit breaker bypass Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: setConfig() lets governance choose new values for period duration, buckets, and cap. In this process, it resets the amount value of every bucket. While the bucket values are all reset to zero (or 1, though this dust is subtracted out later), this gives a window of opportunity to maximize the value passing through the circuit breaker. The worst case scenario with one setConfig() call is twice the circuit breaker cap value, and this can be generalized to n+1 times the circuit breaker cap for n number of setConfig() calls in a short timespan. So if a user frontruns a single setConfig() call to reach the cap before the config is changed, then setConfig() will reset all the buckets and the user can reach the cap again (second time) in a very short timespan, potentially in a single block. 
10. Weak liquidation incentives can result in unliquidated bad debt Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The liquidation of an undercollateralized position in TLC is performed by batchLiquidate(). The function checks if an address has an undercollateralized loan, and if so, the TEMPLE collateral is burned. No DAI is moved because the lender did not return the loaned funds, so only the collateral is in the protocol's possession. The burning of user-owned TEMPLE means that there is more treasury value per user-owned TEMPLE, increasing the protocol TPI. An increase in TPI indicates an increase in TEMPLE token price. This means that even though there is no liquidation incentive like there is in a protocol such as Compound Finance, TEMPLE holders should be incentivized to perform liquidations because it increases the value of the token they hold. The problem with this assumption is that it may fail in conditions with high gas prices or where all token holders hold only small amounts of the token, leading to a bad debt situation that sits unresolved and grows worse due to accumulating interest. Assume turbulent market conditions exist and cause mainnet gas prices to increase to $100 for a liquidation transaction. Further, assume that some loans might be eligible for liquidation due to interest accumulation, possibly from the same market turbulence. If a user owns 1% of all circulating TEMPLE, then to make the $100 transaction profitable to execute, the liquidation would have to result in a $10,000 profit to the protocol. If the $10,000 profit represents the 15% overcollateralization of the loan, then the total loan size is $66,666, which is a very large loan. Given this example, it may be no surprise that the protocol is designed in a way that the bot maintained by governance is expected to be the main liquidator for the protocol. This is because there is no incentive given to the liquidator except an increase in TPI (as long as the liquidation is profitable), and because the protocol multisig is the largest token holder at the current time, governance has the most incentive to liquidate positions and increase TPI. But in the case that governance is the primary liquidator, there is the risk that if governance liquidates positions when gas costs exceed liquidation profits, this impacts token value for all TEMPLE holders by lowering TPI because gas costs are paid by the same treasury that represents the value held by the TEMPLE token. There is the addition risk that if the bot goes offline, no one will have incentive to liquidate positions, but given the borrowing interest rate curve and active role of governance in this protocol, that is a much lesser risk. This example shows that there is limited incentive for most TEMPLE token holders to liquidate undercollateralized positions. If the undercollateralized loan sits unresolved, the TEMPLE that serves as collateral to that loan is effectively weighing down the TPI. Even though it is not profitable for any user to liquidate the undercollateralized position, especially smaller loans, there will be no increase in TPI until gas prices drop enough to make the liquidation profitable (a quicker solution) or the loan accumulates enough interests to counteract the high gas prices (a slower solution). The current design of TempleDAO is to use a governance-run bot to perform the liquidations, but this bot can encounter the same situation of unprofitable liquidations. If there are small value loans that are undercollateralized, the bot should not liquidate the loans when there are very high gas costs, because the protocol will lose value. It is also possible that the governance-run bot goes offline due to an outage in Google Cloud, AWS, or whichever server provider(s) are used, so the on-chain bot cannot be relied on to have 100% uptime on par with a stable blockchain. 
11. Function selectors with a zero value are valid Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Function selectors are represented by the first four bytes of the hash of the function signature. As these are the result of a hash function, it is possible and valid to have a function selector with the zero value (i.e. the first four bytes are zero). There are two occurrences in the codebase in which function selectors taken as input arguments are validated to be different from zero: setExplicitAccess() in TempleElevatedAccess.sol setFunctionThresholdBatch() in ThresholdSafeGuard.sol 
12. Aura rewards may be locked in AuraStaking Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The getReward() function is intended to collect the reward tokens received from staking in Aura and send those tokens to rewardsRecipient. But the rewardTokens array is only set in the constructor and cannot be modified after. The Aura contract has a addExtraReward() function that can add to the existing list of reward tokens, but AuraStaking.sol is not designed for such flexibility. If AuraStaking.sol does not contain the full list of reward tokens, then the missing tokens will be sent from Aura to AuraStaking.sol and stay trapped in the TempleDAO contract. 
13. Borrowers may be instantly liquidated after rescue mode is disabled Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: After rescue mode is enabled, all major functions of the contract are paused (notInRescueMode modifier). This means that repayments cannot be done by borrowers (since repay() and repayAll() are blocked), but their debt is still accrued. If a position becomes unhealthy while the rescue mode is enabled, a borrower can be liquidated as soon as the pause is disabled, and before they can even attempt to normalize their situation. 
14. Token allowance isn't revoked when updating TRV in Gnosis strategy Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: When repayments to the treasury vault are made from the Gnosis strategy, both repay() and repayAll() will execute an infinite (i.e. type(uint256).max) token approval so that the vault can pull the tokens from the strategy contract. The treasury vault contract can be updated in strategies, however, the implementation of _updateTrvApprovals() is empty for the GnosisStrategy.sol contract. This means that previously configured vaults will still have unrestricted access to tokens held by the strategy contract. 
15. Validate rate parameters in LinearWithKinkInterestRateModel.sol Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: When the utilization ratio is above the kink, the slope of the linear model is defined as (maxInterestRate - kinkInterestRate) / kinkUtilizationRatio. This means that maxInterestRate >= kinkInterestRate. Similarly, in the other case, the slope is defined as (kinkInterestRate - baseInterestRate) / kinkUtilizationRatio, which implies that kinkInterestRate >= baseInterestRate. 
16. Account validation in TempleElevatedAccess.sol Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The constructor of TempleElevatedAccess.sol initializes initialRescuer and initialExecutor without checking for zero/empty addresses. Additionally, as the rescuer account is intended to be a support role of the executor account, it is important to validate that both accounts are not the same address. The design intent is for rescuer and executor to be multisigs and not EOA, so an extra check can be added to verify these addresses are contracts. 
17. Zero token transfers while claiming rewards in AuraStaking.sol Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Some ERC20 implementations revert on zero value transfers. The implementation of the getReward() function in the AuraStaking.sol contract executes a token transfer of the contract's token balance without actually checking if the balance is not zero. Since all reward tokens are pulled and transferred simultaneously, a failure in any of the token transfers would result in a transaction revert, causing a denial of service in the reward claiming process. 
18. Insufficient gas for max buckets in TempleCircuitBreakerAllUsersPerPeriod.sol Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: TempleCircuitBreakerAllUsersPerPeriod.sol comments and the declaration of buckets indicate that the design is intended to allow up to 65535 buckets. But it is not easy to create anywhere near this number of buckets directly, because setConfig() reverts due to lack of gas if less than 10% that many buckets are supplied in the constructor. This is because _setConfig() clear the bucket values by looping through all buckets to set their initial value to 1. Now because of how solidity memory works, it may be possible for governance to clear 4000 buckets of array space at a time without running out of gas. But then in order to reach 65k buckets, setConfig() would need to be called over 10 times, incrementally increasing the value of nBuckets each time. Overall, the current design means that realistically the maximum number of buckets is too large, and the buckets array is oversized for an ETH mainnet deployment with a 30 million gas limit. 
19. addStrategy() allows setting debt ceiling for tokens without borrowing enabled Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: setStrategyDebtCeiling() checks if a token is a borrowable token before setting the debt ceiling of that token with the line if (!_borrowTokenSet.contains(address(token))) revert BorrowTokenNotEnabled();. When the debt ceiling is set in addStrategy(), there is no such check to confirm that the token is a borrowable token. This means the two functions have different checks even though they have the same onlyElevatedAccess modifier controlling who can call these functions. 
20. shutdown() doesn't delete strategyTokenCredits values Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The goal of shutdown() in TreasuryReservesVault.sol is to remove all data related to a strategy from variables and mappings. Although the credit value stored in the strategyTokenCredits mapping is used in the StrategyShutdownCreditAndDebt event, the value is never deleted. 
21. Casting overflow risk in strategy borrowing Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: _availableForStrategyToBorrow() calculates how many more tokens a strategy is allowed to borrow. To prevent a revert due to underflow, the function casts uint256 values to int256 values. Casting has no overflow protection, and because the debtCeiling value can be set to any arbitrary integer, it is possible that a very high ceiling value would result in an overflow. An overflow of the sum _ceiling + _credit would not give a strategy more borrowing than it should, but an overflow of dTokenBalance could cause int256(dTokenBalance) to resolve to a negative value, increasing the strategies borrowing greater than it should be. dTokens are minted 1:1 for the amount of tokens borrowed, so it is unlikely to reach a value that is large enough to overflow the int256 data type, but a modified implementation for this function could remove the problem entirely. 
22. Ramos inconsistencies between constructor and setter functions Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: setPostRebalanceSlippage() reverts when trying to set postRebalanceSlippage as zero. Because postRebalanceSlippage is zero by default, and it is not set in the constructor, it will remain zero until setPostRebalanceSlippage() is called. The same issue of a default zero value until otherwise set applies to setMaxRebalanceAmounts(), setRebalancePercentageBounds(), setTpiOracle(), setTokenVault(), and setRebalanceFees(). feeCollector() does not have this issue because feeCollector is set in the constructor. The constructor does not check if any state variables are set to valid values, but the setter functions do introduce this check. This means that the value set in the constructor may not align with the assumptions made elsewhere in the contract. For example, feeCollector cannot be set to the zero address value in setFeeCollector(), but can be set to the zero address value in the constructor. The maxRebalanceFee value implicitly should be less than BPS_PRECISION due to the accounting logic in the contract, but there is no logic in the constructor to confirm that maxRebalanceFee < BPS_PRECISION. 
23. Hardcoded Maker DSR base rate doesn't match on-chain value Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: There are two issues related to how TempleDAO handles the MarkerDAO DSR rate: The first issue is easy to fix. The deployment script uses the old MakerDAO DSR value of 3.49%, but the new value is 3.19%. This is confirmed by makerburn.com and by querying the on-chain value: cast call 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7 "dsr()(uint256)" --block 17722371 Return value: 1000000001087798189708544327 (equates to 3.49%) cast call 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7 "dsr()(uint256)" --block 17722372 Return value: 1000000000995743377573746041 (equates to 3.19%) The second and third issues suggest that a redesign may be a better approach to properly handle integration with MakerDAO's DSR. Instead of storing a baseRate value and calculating the accumulated interest, these operations should be outsourced to MakerDAO's contracts to avoid conflicting accounting calculations. If mismatched accounting is allowed to operate over long timespans, the delta between the actual value accrued from MakerDAO's DSR and the estimated interest accumulated calculated by TempleDAO can grow. If the value is overestimated, this can lead to bad debt and users can be misinformed about the interest rate they expect they are getting with the MakerDAO DSR integration. Although the ideal case would be for the base rate to match the Maker DSR rate, the developer intent is to allow the base rate to change in the future to be based on a different protocol. The contract therefore cannot be designed only around MakerDAO. Additionally, governance has options to adjust the accumulated interest (by minting/burning debt tokens or temporarily overcorrecting the base rate for a short period) if precision of the internal credit and debt becomes important later. For now, the internal credit and debt is only useful for governance to compare the performance of strategies against one another, and because the comparison is relative, precise values matching the MakerDAO DSR rate will not impact the comparison process. 
24. Simplify logic in removeLiquidity() function Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: In the implementation of removeLiquidity(), tokens are repaid to the strategy by iterating the array of assets and checking if each asset corresponds to the quote or protocol token. This is not really needed and can be simplified by removing the loop and just repaying both tokens. 
25. Avoid burn logic if amount is zero Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The amount of tokens to burn is limited by the actual debt amount of the debtor. This means that, even if the original argument (_burnAmount) is greater than zero, it can be overridden to zero if the debtor doesn't have any debt. If this is the case, the implementation will still call the internal function _burn(), wasting gas in operations that won't alter the state. This is particularly relevant, in the context of the vault, for strategies that execute repayments without having any actual debt. Repayment logic calls the burn() function of the debt token to know how much excess should be accounted for as credit. 
26. Duplicate and unneeded logic in repayAll() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Shared logic present in the _repayToken() contains code which is not really needed for the case of repayAll(). Account debt is recalculated (calls to _currentAccountDebt()). The check to validate that the amount does not exceed the debt is not needed (since _repayAmount equals _newDebt). debtCheckpoint can be set directly to zero, as it is paying the full debt. 
27. Move debt token cache out of the loop in computeLiquidity() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: In computeLiquidity(), the debt token cache struct is data independent in the for loop and can be moved outside to improve gas costs. 
28. Debt token cache is re-initialized in borrow() function Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The borrow() function first initializes the cache in line 204 and then calls the _checkLiquidity() internal function which also initializes the same cache. 
29. Change visibility of public constants Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Several contracts define a VERSION constant that is marked as public, while at the same time expose the same constant value in an explicit getter function. Examples: TempleDebtToken.sol TreasuryReservesVault.sol DsrBaseStrategy.sol 
30. Cache storage variable locally to prevent multiple reads from storage Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: rewardsRecipient in AuraStaking::getReward() rewardTokens[i] in AuraStaking::getReward() poolHelper in Ramos::rebalanceUpExit() poolHelper in Ramos::rebalanceDownExit() poolHelper in Ramos::rebalanceUpJoin() poolHelper in Ramos::rebalanceDownJoin() tokenVault in Ramos::addLiquidity() tokenVault in Ramos::removeLiquidity() totalPrincipal in TempleDebtToken::currentTotalDebt() maxTreasuryPriceIndexDelta in TreasuryPriceIndexOracle::setTreasuryPriceIndex() rescuer in TempleElevatedAccess::proposeNewRescuer() cap in TempleCircuitBreakerAllUsersPerPeriod::preCheck() treasuryReservesVault in DsrBaseStrategy::trvWithdraw() treasuryReservesVault in GnosisStrategy::borrowMax() treasuryReservesVault in GnosisStrategy::repay() treasuryReservesVault in GnosisStrategy::repayAll() treasuryReservesVault in TempleTokenBaseStrategy::trvWithdraw() _accountData.collateral in TempleLineOfCredit::removeCollateral() 
31. Unneeded unsafe downcasting in debt token cache Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The DebtTokenCache struct is used in TempleLineOfCredit.sol as a cache to initialize several values from storage to be used in different functions of the contract. In this cache struct, the interestAccumulator field is defined as uint128 while its matching field in the struct used in storage is defined as uint256, leading to an unsafe downcast while initializing the struct in _initDebtTokenCache() 
32. Set proper types to remove SafeCast operations Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Multiple setter functions in TreasuryPriceIndexOracle.sol cast function arguments to smaller integer types (1, 2, 3). This casting is unnecessary if the function argument is the proper type. 
33. Use unchecked if no underflow risk Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The subtractions in _mintDToken() can be unchecked because they are inside if/else branches with logic that prevents an underflow from happening (L569, L577). The calculation of _remaining in _burnDToken() can be made unchecked because _burnedAmount is the same as the value of toBurnAmount or less, based on the logic found in dToken burn(). The calculation of _delta in setTreasuryPriceIndex() can be unchecked. The calculation of _newDebt in _repayTotalDebt() can be unchecked. In _burn(), the updates to the _burnAmount variable can be unchecked, as the repaid amount should be less than the amount to burn (L275, L284, L293, L297). 
34. enoughCooldown modifier can be simplified Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: enoughCooldown performs two checks: lastRebalanceTimeSecs != 0 lastRebalanceTimeSecs + cooldownSecs > block.timestamp In the case that lastRebalanceTimeSecs is zero, the 2nd condition will return false assuming cooldownSecs is set to a value less than block.timestamp. This means the first condition can be removed from the if statement to save gas. 
35. Upgrade outdated dependencies Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: package.json lists @gnosis.pm/safe-contracts version 1.3.0 as a dependency. This version is the latest version available in the npm package but v1.4.1 is the latest available from the main gnosis repository. While the dependency is not used extensively though and is only imported into ThresholdSafeGuard.sol, SafeForked.sol, and IThresholdSafeGuard.sol, dependencies should remain updated to include the latest bug fixes. The prb/math dependency might be an easier to change because the npm package is update. Only the version number needs upgrading from 3.3.1 to the latest 4.0.1. 
36. Incorrect variable type in BalancerPoolHelper Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The two return value structs are defined in IBalancerVault.sol. Observe that assets is of type IERC20 in JoinPoolRequest but of type address in ExitPoolRequest. struct JoinPoolRequest { IERC20[] assets; uint256[] maxAmountsIn; bytes userData; bool fromInternalBalance; } struct ExitPoolRequest { address[] assets; uint256[] minAmountsOut; bytes userData; bool toInternalBalance; } In comparison, these structs should have the same types according to the Balancer docs. The on-chain Balancer implementations of JoinPoolRequest and ExitPoolRequest also shows consistency in variable types between the structs, although type IAsset is used instead of type address. 
37. High centralization risk throughout protocol Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Every DeFi protocol must decide how immutable or centralized the protocol will be. TempleDAO's design falls on the very centralized end of the spectrum. This by design and does not add risks if governance actions are only performed by trusted parties. But because this assumption is not governed by immutable code, some users may not be convinced that this assumption holds at all time. If this assumption does not hold, governance can: Withdraw tokens directly from the protocol contracts including AuraStaking.recoverToken(), AuraStaking.withdrawAllAndUnwrap(), AuraStaking.withdrawAndUnwrap(), Ramos.recoverToken(), TempleLineOfCredit.recoverToken(), TreasuryReservesVault.recoverToken(), etc. The majority of public or external functions in TempleDAO v2, especially in RAMOS and the strategies, has access control modifiers that allow only a governance multisig to call these functions. Many functions control key state variables that influence fees, Off-chain bots controlled by governance play a key role in performing swaps to stabilize the TEMPLE token price and handle liquidations. It was not clear during this audit what the off-chain bot implementation looks like and what the security around its operation looks like. In summary, the centralized nature of TempleDAO adds some risk because of the power that governance has. This finding has a risk of Informational only because the assumption was made that the protocol has trustworthy governance. If this assumption does not hold, the risk severity would likely jump to Critical. Even if all governance operates as a trusted party, centralization brings with it the risk of private key theft that has impacted several DAOs in the last couple of years. 
38. Add events to RamosStrategy.sol Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The borrow and repay functions in RamosStrategy.sol do not emit events. This is unlike the other events such as DsrBaseStrategy.sol and TempleTokenBaseStrategy.sol. 
39. TLC lending curve configuration choices may result in low utilization ratio Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The values set in the deployment script for LinearWithKinkInterestRateModel.sol result in a significantly different borrowing curve compared to Compound v2 and Aave DAI markets. Consider the goals and risk implications of the current choices to determine how closely TempleDAO aims to align with these other protocols to remain competitive and maintain a utilization ratio in line with the DAO's goals. If the lowest borrowing rate at zero utilization is 5%, this may be too high of a borrowing rate with current market conditions to remain competitive. Compound and Aave regularly modify the values that determine their borrowing curves based on feedback from Gauntlet that accounts for current market conditions. The suggestion to lower the interest rate at zero utilization is only valid with the current Maker DSR rate of 3.19%. If Maker increases the DSR rate, such as with the recent eDSR proposal that passed, then a different y-intercept value would make sense nearer to whatever base rate DAI in the TempleDAO base strategy is earning. 
40. Potential denial of service in TempleLineOfCredit.sol contract Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The TempleLineOfCredit.sol contract contains a circuit breaker safety measure in the removeCollateral() and borrow() functions. The current implementation of the circuit breaker (TempleCircuitBreakerAllUsersPerPeriod.sol) enforces a global volume limit over a sliding window period of time. As these limits apply globally to all users, any account can artificially generate volume to hit the caps defined by the circuit breaker, causing a temporary denial of service in the contract. For example, a malicious user can repeatedly call the addCollateral() and removeCollateral() functions to exhaust the limits of the circuit breaker and make the preCheck() call revert for all other users. 
41. Unused fields in AccountData struct Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The following fields from the AccountData struct are not used throughout the codebase: removeCollateralRequestAmount borrowRequestAmount removeCollateralRequestAt borrowRequestAt 
42. Replace magic numbers with constants Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The value 65535 appears in an if statement in TempleCircuitBreakerAllUsersPerPeriod.sol, but the value represents the length of the buckets array. The length of the array should be used instead of this magic number to give more context and accuracy to the if statement. 
43. Complexity reduction possible Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Multiple lines of code can be combined to reduce overall complexity. 
44. Hypothetical overflow Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There is no logic that prevents this summation from overflowing in _withdrawFromBaseStrategy(). However, it is very unlikely for token balances to reach such a high value, so this would be safe in most normal cases. 
45. _withdrawFromBaseStrategy() does not check if transfer may revert Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: A comment in _withdrawFromBaseStrategy() indicates that the amount that is intended to be withdrawn from the base strategy may not be the amount that the base strategy returns. Specifically, the DsrBaseStrategy may return fewer tokens than requested if it does not have the amount requested. 
46. totalAvailable() can be declared external Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: totalAvailable() is a public function that does not need to be public. 
47. Typos Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: In AuraStaking.sol: "_recipeint" -> "_recipient" In TreasuryReservesVault.sol, recoverToken() was copied from TempleDebtToken.sol but the comment was not modified: "Recover any token from the debt token" -> "Recover any token from the TRV" In TreasuryReservesVault.sol: "mroe" -> "more" In TreasuryReservesVault.sol:: "dToken's" -> "dTokens" In AbstractStrategy.sol and the 5 other strategy contracts: "stratgy" -> "strategy" In AbstractStrategy.sol and the 5 other strategy contracts: "onthe" -> "on the" In TempleDebtToken.sol: "stoarge" -> "storage" The link in this comment is broken 
48. Usage of onlyElevatedAccess modifier in public functions Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The implementation of the onlyElevatedAccess() modifier relies on msg.sig to authorize access to a particular function. This variable refers to the first 4 bytes of the calldata, which contains the intended function selector to be executed on the called contract. The TempleElevatedAccess.sol contract holds a mapping that defines which callers have access to which functions (represented by their function selectors). It may be possible to ignore the restrictions if this modifier is used in public functions. Consider the following example contract: contract SomeContract is TempleElevatedAccess { function foo() external onlyElevatedAccess { ... bar(); ... } function bar() public onlyElevatedAccess { ... } } If bar() is called externally then onlyElevatedAccess will correctly check the authorization using the function selector for bar(). But if bar() is called internally, like in the case of foo(), then the check will be done using the function selector of the original call to the contract (foo()), as msg.sig will still refer to the first four bytes of the calldata. 
49. TLC design may increase liquidation risk Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Unlike protocols like Compound Finance, there is no difference between the max LTV that a user can borrow and the liquidation threshold. When combined with the interest that accumulates on the loan each block, this means that a loan with 85% LTV can be liquidated in the next block. Another scenario that can cause user liquidation is reducing the Treasury Price Index (TPI). Because the value of TEMPLE collateral is price using the TPI, when the TPI drops, this causes an immediate drop in the value of collateral in TLC and cause positions to be eligible for liquidation. In normal market conditions, a reduction in TPI is unlikely, and a liquidation is unlikely to induce bad debt, but in the worst case scenario, governance's choice to reduce TPI can trigger liquidations that lead to bad debt for the protocol. 
