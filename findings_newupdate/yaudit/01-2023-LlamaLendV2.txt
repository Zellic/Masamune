1. createPool() always reverts Severity: High Difficulty: n/a Type: n/a Target: n/a Description: LLamalendFactory.createPool() sends ether to the LendingPool contract: payable(address(pool)).sendValue(msg.value); Since the LendingPool contract doesn't have a receive() function, this transfer reverts, in turn reverting createPool(). 
2. Frontrunning borrow changes borrower's interest rate Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The LlamaLend protocol calculates the interest rate of a loan in calculateInterest(). The rate curve is a linear 1-piece curve (unlike protocols like Aave that use a 2-part curve, with a steeper slope after a certain amount of borrowing). The interest rate for a loan is fixed, not variable like many other lending protocols where the rate depends on the total amount borrowed. To determine the fixed rate, LlamaLend uses the midpoint between the current borrowed amount of the new borrowed amount after the borrow action is complete. This calculation is in line 98. This introduces dependency on the amount borrowed at the time of the loan, or totalBorrowed. Frontrunning a borrow with another borrow can change the value of totalBorrowed. 
3. No support for cryptopunks Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: Cryptopunks are at the core of the NFT ecosystem. As one of the first NFTs, it embodies the culture of NFT marketplaces. But cryptopunks does not adhere to the ERC721 standard, that limits the contract ability to accept cryptopunks as collateral. 
4. baseURI can be made a modifiable state variable Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: LendingPool.tokenURI() uses this baseURI: string private constant baseURI = "https://nft.llamalend.com/nft2/"; This is a constant variable and if access to https://nft.llamalend.com/nft2/ is lost, tokenURI() will start returning an inaccessible URI. 
5. Consider removing LlamaLendFactory.receive() Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: There is no need to send ether to LlamaLendFactory contract explicitly, so receive() can be removed, but even if someone sends ETH by mistake to the contract address, any one can extract them by passing empty data to repay. 
6. calculateInterest() does not account for pending interest payments Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: When a pool has an outstanding borrowed amount, there is a corresponding amount of interest that is expected to be paid in the future. When the interest is calculated for new loans, the total value of the pool is calculated as the current pool balance plus the amount of value borrowed, which is the denominator in the calculation of variableRate. This total value does not consider the pending interest payments that are due. The result is that the total pool balance is slightly underestimated. While the existing approach of ignoring future interest payments until they are paid may have some benefit, it creates a discontinuity where the total assets held by the pool before and after a user calls repay() results in an immediate increase in pool assets. 
7. Risk of bad debt Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The README in the LlamaLend repository has this line in the "Risks for LPs" section You are selling put options on NFTs, if NFT price drops >66% before some loan expires, user will likely not repay and you'll get the NFT at a loss. Lending protocols like Aave and Compound have liquidation policies that limit the amount of bad debt that can accumulate in the protocol. This is no such protection in LlamaLend, so liquidation is only possible after loan.deadline regardless of how much bad debt accumulates. The LlamaLend README suggest a maxLoanLength value of 2 weeks will be used, but this is not hardcoded into the contracts, meaning that a longer deadline could increase the risk of bad debt and loss of value for the lender. 
8. Oracle data replay attack Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: There is no requirement in checkOracle() that only the latest oracle data can be used. Instead, there is a deadline and any oracle data in the timeframe allowed by deadline is accepted. A user can look at the data from the last 20 minutes and choose the oracle data with a price that is most beneficial to them. This lets users "turn back to clock" if they don't like the latest data that the oracle is returning. This means that the oracle must be sure not to return a zero value or underestimated value for the NFT floor price in any edge case scenario, such as before the NFT floor price data is available. For comparison, when Chainlink oracle data is used, it is normally recommended to use only the latest round of oracle data, which removes the ability for a user to choose which datapoint among recent data to use. 
9. NFT can get locked in contract if from is a smart contract Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: User will receive the collateral NFT when repay() is called. However, if from is a contract address that does not support ERC721, the collateral NFT can be frozen in the contract. As per EIP-721: "A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers." function _repay(Loan calldata loan, address from) internal returns (uint256) { ... IERC721(loan.nftContract).transferFrom(address(this), from, loan.nft); ... } 
10. Use custom errors Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Custom errors are more gas efficient than error strings. 
11. Variables are auto-initialized to 0 Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: LendingPool.sol#L277-L279 creates an else clause to assign 0 to a return value which is already 0: } else { lateFees = 0; } 
12. Extra event is emitted by _burnWithoutBalanceChanges() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: In a normal _burn() function, only a Transfer event is emitted. _burnWithoutBalanceChanges() emits 2 events: Transfer and Approval. The reason being it calls _approve() to clear approval, but _burn() function just deletes _tokenApprovals mapping. 
13. Use unchecked if no underflow risk Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Because lastUpdateDailyBorrows is only modified by setting the variable equal to block.timestamp, block.timestamp - lastUpdateDailyBorrows can never underflow. This line and this line can be unchecked. The same logic applies to loan.startTime so this line can be unchecked. 
14. factory can be marked as immutable Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Since there is no function in the contract that updates the factory variable address, it can be marked as immutable. 
15. Foundry and hardhat tests not working Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Hardhat and Foundry tests are not working as they refer to non-existent contracts and variables, or call functions with different number of arguments. 
16. _burnWithoutBalanceChanges() shadows owner Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The second argument in _burnWithoutBalanceChanges(tokenId, owner) shadows the global variable owner. 
17. Consider allowing anyone to repay any loan Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: LendingPool.sol#L203, LendingPool.sol#L169 
18. Update OpenZeppelin dependencies Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The package.json file shows a dependency of openzeppelin/contracts v4.2.0 and openzeppelin/contracts-upgradeable v4.8.0-rc1. All dependencies should be updated to the latest version available. 
19. Flashloans are free Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The interest due on a loan is calculated in _repay() and infoToRepayLoan(). The interest due for a flashloan is zero, meaning there is no fee for this borrowing operation. Whether this is intentional is unclear. 
20. Interest rate "renegotiation" after a repayment Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The interest due on a loan is calculated in _repay() and infoToRepayLoan(). The interest due for a flashloan is zero, meaning there is no fee for this borrowing operation. Whether this is intentional is unclear. 
21. Inaccurate comment Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The word overflow in this comment that reads "overflow checks implictly check that amount is enough" should be changed underflow. 
22. Align _burnWithoutBalanceChanges() with _burn() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Although it does not change the end result, the following change in _burnWithoutBalanceChanges() can be made to use the same approach as _burn() - _approve(address(0), tokenId); + delete _tokenApprovals[tokenId]; 
23. Missing events for critical operations Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Ideally, the following critical operations should trigger events: withdraw() setMaxDailyBorrows() setOracle() emergencyShutdown() doEffectiveAltruism() 
24. Revert operation performed without proper error message Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: For ex: In function borrow() it checks that current interest rate should be less than maximumInterestRate, but it does not revert with error message, which can be confusing to use, as error message helps to understand the reason why transaction failed. function borrow() { ... require(interest <= maxInterest); ... } 
