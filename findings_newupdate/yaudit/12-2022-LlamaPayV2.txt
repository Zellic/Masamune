1. Infinite withdrawals using function withdrawAllWithRedirect(uint256 _id) Severity: Critical Difficulty: n/a Type: n/a Target: n/a Description: In the following example, Bob can withdraw all tokens in the contract. The first call only withdraws the funds allocated to him, but because it's not recorded, Bob can call withdraw again. Here's an extended test. function testWithdrawAllWithRedirect() external { vm.prank(alice); llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 10000000 ); vm.prank(bob); llamaPayV2Payer.addRedirectStream(0, steve); vm.warp(15000); vm.prank(bob); llamaPayV2Payer.withdrawAllWithRedirect(0); (uint256 balance, , , uint48 lastUpdate) = llamaPayV2Payer.tokens( address(llamaToken) ); assertEq(llamaToken.balanceOf(address(llamaPayV2Payer)), 5000 * 1e18); assertEq(llamaToken.balanceOf(steve), 5000 * 1e18); assertEq(balance, 5000 * 1e20); assertEq(lastUpdate, 15000); // redeemables should be 0 but it's not assertGt(llamaPayV2Payer.redeemables(0), 0); // Withdraw all again vm.prank(bob); llamaPayV2Payer.withdrawAllWithRedirect(0); assertEq(llamaToken.balanceOf(address(llamaPayV2Payer)), 0); assertEq(llamaToken.balanceOf(steve), 2 * 5000 * 1e18); assertEq(lastUpdate, 15000); // redeemables should be 0 but it's not assertGt(llamaPayV2Payer.redeemables(0), 0); } 
2. Inaccurate internal token balance for weird ERC20 tokens Severity: High Difficulty: n/a Type: n/a Target: n/a Description: When a token is deposited into LlamaPayV2Payer, the internal balance is updated and the transfer of tokens into the contract happens. The key lines are: tokens[_token].balance += _amount * tokens[_token].divisor; token.safeTransferFrom(msg.sender, address(this), _amount); The problem is that if a fee-on-transfer exists, the tokens[_token].balance will be greater than the balanceOf token amount in the contract, because the tokens[_token].balance did not subtract the fee-on-transfer amount. A receiver could withdraw more tokens than they should have access to with these steps: The payer deposits X number of fee-on-transfer tokens into the LlamaPayV2Payer contract The internal balance thinks the contract holds X tokens, but actually the contract holds X - tokenFee tokens The contract accounting does not consider the fee involved for fee-on-transfer tokens. If the receiver is eligible to withdraw the X amount of tokens, they can only withdraw X - tokenFee tokens because this is the amount held by the contract. If fee-on-transfer tokens are permitted, the accounting should only permit a withdrawal of X - tokenFee. The payer deposits Y number of fee-on-transfer tokens into the LlamaPayV2Payer contract. If X - tokenFee + Y - tokenFee > X, then the receiver can now withdraw the X amount of tokens because the contract holds enough tokens to allow this withdrawal. If fee-on-transfer tokens are permitted, the accounting should only permit a withdrawal of X - tokenFee, but with the current code, the receiver with withdraw X tokens. Likewise, if a rebasing token is used and the balanceOf token amount in the contract is a function of time, the tokens[_token].balance value is not increased or decreased outside of deposit or withdraw events and therefore the internal accounting may underestimate the tokens held by the contract. This latter case could lock funds in the contract, for example: The payer deposits X number of rebasing tokens into the LlamaPayV2Payer contract Over time, the X rebasing tokens grow to 1.25 * X tokens Once the stream ends and the receiver can withdraw the full token balance, the internal account balance still assumes the contract holds only X tokens, so only X tokens and not 1.25 * X tokens can be withdrawn. 
3. burnStream() shouldn't burn a stream if it has some debt Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: Alice creates a stream for Bob which ended but has some debt accrued. Some time after the stream ends, Alice decides to burn that stream. Later Bob checks that Alice has to pay some debt for stream and calls repayAllDebt() to pay the debt for that stream. But now as the stream has been burnt by Alice, Bob cannot redeem the debt from stream, and those amount of funds are locked into that stream. 
4. Payee funds get locked if stream is resumed after being burned Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: Alice (payer) creates a stream for Bob (payee), and later Alice decided to burn the stream as the payout time was over. Now later Alice decides to resume the stream to Bob, which in turns makes the stream active again. But Bob can not accesss the redeemable funds as due to the burn the ownerOf(_id) is address(0), and has not been reallocated in resumeStream(). function testBurnAndResumeStream() external { vm.startPrank(alice); // Alice creates a stream for Bob llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 50000 ); vm.warp(12000); // Alice stops the stream llamaPayV2Payer.stopStream(0, false); // Alice pays Bob llamaPayV2Payer.withdrawAll(0); // checking that bob is the owner of stream address nftOnwer = llamaPayV2Payer.ownerOf(0); assertEq(nftOnwer, bob); // Alice burns the stream llamaPayV2Payer.burnStream(0); // Alice resumes the stream, now Bob can again withdraw after some time llamaPayV2Payer.resumeStream(0); vm.warp(20000); vm.stopPrank(); // now Bob tries to withdraw from stream, which fails as the owner of nft is address(0) vm.startPrank(bob); llamaPayV2Payer.withdrawAll(0); vm.stopPrank(); } 
5. Llama Pay V2 is incompatible with high decimal tokens Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The key line is: if (tokens[_token].divisor == 0) { tokens[_token].divisor = uint208(10**(20 - token.decimals())); } If token.decimals() is greater than 20, then the subtraction 20 - token.decimals() will underflow and the transaction will revert. This prevents depositing tokens like YAM-V2 into Llama Pay V2. 
6. permitToken fails in case of tokens that doesn't follow IERC20Permit standard Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: permitToken() fails in case of DAI. IERC20Permit: function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external; DaiPermit: function permit( address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s ) external; 
7. Handle funds transferred via transfer method Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Introduce a new variable X that tracks the net amount that exist in the contract for each token. Updating LlamaPayV2Payer.sol#L183 with ERC20(token_).balanceOf(address(this)) solves this by making those extra funds withdraw-able. - uint256 toSend = token.balance / token.divisor; + uint256 toSend = (token.balance / token.divisor) + (ERC20(_token).balanceOf(address(this)) - X); Rebalance token balance in _updateToken function. function _updateToken(address _token) private { Token storage token = tokens[_token]; token.balance += (ERC20(_token).balanceOf(address(this)) - X); ... } 
8. Missing Input Validation Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: None of the external createStream functions or the internal one createStream perform input validation for the _to address. This address is supplied by the user and is the recipient of the stream token. It is not uncommon for users or front-ends/ clients to set 0 as values for input forms. This can lead to a user creating a stream but accidentally burning it in the process as well. 
9. _updateToken updates token.lastUpdate even if the token doesn't exists Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: function _updateToken(address _token) private { Token storage token = tokens[_token]; // @audit add this check require(token.divisor > 0, "NOT_ADDED"); // rest same } 
10. BoringBatchable.batch() is payable Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: BoringBatchable.sol#L46 
11. modifyStream() should revert for inactive stream Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: For example, take a stream s with id id with this configuration: s.lastPaid  s.ends s.amountPerSec == _oldAmountPerSec Now, modifyStream(id, _newAmountPerSec, _newEnd) is called for this stream with _newEnd in future. After _updateStream(), lastPaid becomes 0, and now even though the stream's end is in future, it is not streamed any funds as the stream remains inactive. 
12. withdrawable() can revert Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Cases where withdrawable() can revert: When no token is deposited in LlamaPayV2Payer, and a stream is created. reverts due to division by 0 as token.divisor is 0. When execution reaches in this else block, and stream.starts > lastUpdate. reverts due to arithmetic underflow. This implicitly assumes that lastUpdate lies between starts and ends. 
13. Inaccuracies in withdrawable() Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: LlamaPayV2Payer.sol#L650 LlamaPayV2Payer.sol#L603 
14. streams can be resumed even after burn Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: function testBurnAndResumeStream() external { vm.startPrank(alice); llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 50000 ); vm.warp(12000); llamaPayV2Payer.stopStream(0, false); llamaPayV2Payer.withdrawAll(0); // burning the stream llamaPayV2Payer.burnStream(0); // resuming the stream llamaPayV2Payer.resumeStream(0); vm.stopPrank(); } function burnStream(uint256 _id) external { if ( msg.sender != owner && payerWhitelists[msg.sender] != 1 && msg.sender != ownerOf(_id) ) revert NOT_OWNER_OR_WHITELISTED(); /// Prevents somebody from burning an active stream or a stream with balance in it if (redeemables[_id] > 0 || streams[_id].lastPaid > 0) revert STREAM_ACTIVE_OR_REDEEMABLE(); _burn(_id); emit BurnStream(_id); } As above code shows that data related to that particular burnt _id still stays in contract, it can be again resumed. 
15. modifyStream can create a new stream if it doesn't exist Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Since modifyStream doesn't check whether the stream is present or not, it creates a new stream if not present. function testModifyStream() external { vm.prank(alice); llamaPayV2Payer.modifyStream(0, 2e20, 20000); (uint208 amountPerSec, , , , uint256 ends) = llamaPayV2Payer.streams( 0 ); assertEq(amountPerSec, 2e20); assertEq(ends, 20000); } 
16. payerWhitelists addresses should have access to all withdraw operations Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: withdraw(), withdrawAll(), withdrawWithRedirect(), and withdrawAllWithRedirect() do not permit an address in payerWhitelists to call them. Most likely this was an oversight, because the addresses in payerWhitelists should have similar permissions as the contract owner. The payer whitelist addresses could take funds directly from the contract already, so they should be able to assist with transfering the funds to the intended recipient. 
17. Rogue payerWhitelists address can steal value Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Any function protected by the onlyOwnerAndWhitelisted modifier treats the owner and whitelisted payer addresses as the same privilege level. This includes the internal _createStream() function that can redirect value to a recipient. If an owner deposits value into the Llamapay contract, an address in the payerWhitelists mapping can: Backrun the deposit to create a stream where the recipient is an address that is controlled by the whitelisted address. The stream end date can be in the past so that it is possible to instantly withdraw. After the stream is created, the recipient can withdraw the funds. The end result is the same as calling withdrawPayer() directly, but this is a less expected approach. 
18. Use cheaper comparison Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: At L251 and L280 logic can be switched to save some gas. 
19. Incorrect function visibility Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: tokenURI() and withdrawable() should be external functions in LlamaPayV2Payer. In LlamaPayV2Factory, calculateLlamaPayAddress() should be an external function. 
20. owner should be a immutable variable Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: owner is never updated; it should be defined as an immutable to save gas. 
21. Return stream value after updating Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: If the _updateStream(uint256 _id) is changed to return the update stream, small gas optimization is possible. At L201, L222, L243, L272, L400, L425, L446, L222 a stream value could be returned instead of loading again stream in the next line. 
22. Use unchecked if no underflow risk Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Unchecked can be applied to this line and other similar locations. The subtraction will not overflow because lastUpdate is zero. block.timestamp - lastUpdate has a max value of type(uint48).max and token.totalPaidPerSec has a max value of type(uint208).max, the maximum product is type(uint256).max which doesn't overflow. - uint256 streamed = (block.timestamp - lastUpdate) * token.totalPaidPerSec; + unchecked { uint256 streamed = (block.timestamp - lastUpdate) * token.totalPaidPerSec; } 
23. Do not load whole struct if not required Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Following function loads Stream struct, but loading Stream.token works. withdrawAllWithRedirect withdrawWithRedirect withdrawAll withdraw - Stream storage stream = streams[_id]; + address token = streams[_id].token; 
24. Pass struct as a params to _createStream() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Update _createStream and createStream this way: function createStream( address _token, address _to, uint208 _amountPerSec, uint48 _starts, uint48 _ends ) external { uint256 id = _createStream( Stream({ amountPerSec: _amountPerSec, token: _token, lastPaid: 0, starts: _starts, ends: _ends }), _to ); emit CreateStream(id, _token, _to, _amountPerSec, _starts, _ends); } function _createStream(Stream memory stream, address _to) private onlyOwnerAndWhitelisted returns (uint256 id) { if (stream.starts >= stream.ends) revert INVALID_TIME(); _updateToken(stream.token); Token storage token = tokens[stream.token]; if (block.timestamp > token.lastUpdate) revert PAYER_IN_DEBT(); _safeMint(_to, id = nextTokenId); /// calculate owed if stream already ended on creation uint256 owed; if (block.timestamp > stream.ends) { owed = (stream.ends - stream.starts) * stream.amountPerSec; } else if (block.timestamp > stream.starts) { /// calculated owed if start is before block.timestamp owed = (block.timestamp - stream.starts) * stream.amountPerSec; tokens[stream.token].totalPaidPerSec += stream.amountPerSec; stream.lastPaid = uint48(block.timestamp); } else if (stream.starts >= block.timestamp) { /// If started at timestamp or starts in the future tokens[stream.token].totalPaidPerSec += stream.amountPerSec; stream.lastPaid = uint48(block.timestamp); } unchecked { /// If can pay owed then directly send it to payee if (token.balance >= owed) { tokens[stream.token].balance -= owed; redeemables[id] = owed; } else { /// If cannot pay debt, then add to debt and send entire balance to payee uint256 balance = token.balance; tokens[stream.token].balance = 0; debts[id] = owed - balance; redeemables[id] = balance; } nextTokenId++; streams[id] = stream; } } 
25. if condition can be optimized in withdrawable() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: LlamaPayV2Payer.sol#L662 
26. Use calldata instead of memory if function param remains unchanged Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Following function uses memory to pass string param, calldata can be used as the string remains unchanged during function execution. createStreamWithReason createStreamWithheldWithReason - string memory _reason + string calldata _reason 
27. Consider and compare UX when streams are ERC1155 tokens Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: ERC1155 doesn't have the same interface as ERC721, so if doing this replacement, a code refactor may be needed. Another thing to consider would be to use ERC1155D (see this repo and announcement) which provides compatibility with ERC721 interface, however, it's not audited. So if you consider ERC1155D, you can either self-review it, take inspiration or get it audited. 
28. Missing Indexed Event Parameters Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: All the events are missing any indexed parameters. 
29. External createStream functions should return the streamId Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Right now, the createStream functions namely createStream, createStreamWithReason, createStreamWithheld and createStreamWithheldWithReason, do not return the id of the newly created stream. Returning the id of the stream upon creation could result in better integration with other protocols and a better UX, where the user immediately knows the id of his stream once it is created. 
30. Update BoringBatchable to latest version Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The difference between BoringBatchable in Llama Pay V2 and the main Boring Solidity repo is this PR https://github.com/boringcrypto/BoringSolidity/pull/16/files. 
31. Add tests for weird ERC20 tokens Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The weird-erc20 repo has many sample contracts that mimic unusual ERC20 token behavior. Consider writing tests to check the compatibility of LlamaPay V2 with all of these contracts. 
32. Sanitisation to avoid false event emission Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: function addPayerWhitelist(address _toAdd) external onlyOwner { require(payerWhitelists[_toAdd] == 0, "ALREADY_WHITELISTED"); payerWhitelists[_toAdd] = 1; emit AddPayerWhitelist(_toAdd); } function removePayerWhitelist(address _toRemove) external onlyOwner { require(payerWhitelists[_toAdd] == 1, "NOT_WHITELISTED"); payerWhitelists[_toRemove] = 0; emit RemovePayerWhitelist(_toRemove); } 
33. tokenURI() should revert for non-existent tokens Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: LlamaPayV2Payer.sol#L135 
34. Missing events for critical operations Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Ideally, the following critical operations should trigger events: cancelDebt repayAllDebt repayDebt updateStream 
35. Lack of zero check on functions Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: For e.x., function addPayerWhitelist(address _toAdd) external onlyOwner { payerWhitelists[_toAdd] = 1; emit AddPayerWhitelist(_toAdd); } Similarly following function doesn't check for valid input address. addPayerWhitelist removePayerWhitelist addRedirectStream addStreamWhitelist removeStreamWhitelist 
36. onlyOwnerAndWhitelisted should be renamed onlyOwnerOrWhitelisted Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: LlamaPayV2Payer.sol#L129 
37. unchecked has no effect Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: LlamaPayV2Payer.sol#L454 
38. Use consistent decimals format in functions Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: - /// @param _amount amount to repay (20 decimals) + /// @param _amount amount to repay (native token decimals) function repayDebt(uint256 _id, uint256 _amount) external { if ( msg.sender != owner && payerWhitelists[msg.sender] != 1 && msg.sender != ownerOf(_id) ) revert NOT_OWNER_OR_WHITELISTED(); address token = streams[_id].token; + /// convert _amount into 20 decimals format + _amount = _amount * tokens[token].divisor; /// Update token to update balances _updateToken(token); /// Reverts if debt cannot be paid tokens[token].balance -= _amount; /// Reverts if paying too much debt debts[_id] -= _amount; /// Add to redeemable to payee redeemables[_id] += _amount; } 
39. Use function to reduce duplicacy of code Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: if ( msg.sender != nftOwner && msg.sender != owner && streamWhitelists[_id][msg.sender] != 1 ) revert NOT_OWNER_OR_WHITELISTED(); Following code snippet can be converted into a function. function ownerOrNftOwnerOrWhitelisted(uint _id, address _nftOwner) internal { if ( msg.sender != nftOwner && msg.sender != owner && streamWhitelists[_id][msg.sender] != 1 ) revert NOT_OWNER_OR_WHITELISTED(); } Applicable to following functions: withdraw withdrawAll withdrawWithRedirect withdrawAllWithRedirect 
40. Redirect recipient cannot receive funds directly Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: addRedirectStream() and removeRedirectStream() allow the receiver of the stream's tokens to sent to a different address with withdrawWithRedirect() or withdrawAllWithRedirect(). withdrawWithRedirect() and withdrawAllWithRedirect() have the same access controls as other withdraw functions, meaning only the NFT owner, the contract owner, or a stream whitelist address can trigger the transfer of funds to the redirect address. This means the redirect address does not have control over these funds but is instead relying on someone else to deliver the funds. This is a less than ideal experience for the redirect receiver, unless the intent of this feature is that the redirect address and NFT address should have the same person (or entity) owning the two addresses. If that is a hidden intent when using the redirect address, it should be clearly documented. 
41. Typos Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: strean -> stream redeeemable -> redeemable 
42. Stream owner should be able to call updateStream() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: LlamaPayV2Payer.sol#L478 
