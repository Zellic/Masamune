1. The swap and stake mechanisms in OpenMevZapper leave funds in the contract Severity: High Difficulty: n/a Type: n/a Target: n/a Description: Both swapAndStakeLiquidity and swapETHAndStakeLiquidity take the input tokens or ETH sent by a user, divide it by 2, swap it into the B token, and stake these tokens as a pair. However, this approach leaves some of the B token in the contract due to the reserve asset ratio change before and after the swap. 
2. Using normal functions for fee-on-transfer tokens causes value loss Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The NatSpec comment for removeLiquidityETHSupportingFeeOnTransferTokens() includes Identical to removeLiquidityETH, but succeeds for tokens that take a fee on transfer The only difference in these functions, and what is implied to cause the revert condition in removeLiquidityETH(), is the amount used in safeTransfer(). removeLiquidityETH() has an amount of amountToken, while removeLiquidityETHSupportingFeeOnTransferTokens() uses ERC20(token).balanceOf(address(this)) - balanceBefore. This does cause a revert in Uniswap's code because of the Uniswap assumption that the router holds no token balance, but OpenMevRouter can hold a token balance. The process of value loss is: Fee-on-transfer token is held by the router. This can happen either with an initial deposit by the Manifold team or from backrun arbitrage profits. The devs suggested the tokens that will be sent to the router will likely be tokens that Aave does not support flashloans for, which could include lesser known tokens with fee-on-transfer support. User wants to remove liquidity from WETH-ERC20 pair where the ERC20 has a non-zero fee-on-transfer. Instead of using removeLiquidityETHSupportingFeeOnTransferTokens(), the user calls removeLiquidityETH(). The code of removeLiquidityETHSupportingFeeOnTransferTokens() and removeLiquidityETH() is identical except for the amount in ERC20(token).safeTransfer(). The amountToken value used in removeLiquidityETH() is greater than the amount of fee-on-transfer tokens received from the removeLiquidity() call, so the amount transferred to the user will include some of the token balance that was held by the router before the user's remove liquidity interaction. Result: The router lost value in the form of the transfer-on-fee token 
3. Backrun arb not designed for fee-on-transfer tokens Severity: High Difficulty: n/a Type: n/a Target: n/a Description: While Aave and Kashi do not currently allow flashloans on any fee-on-transfer tokens, this call of _arb() using internal router contract funds is problematic. The first and second swaps are performed with _asmSwap(), which have a safeTransfer() performed first to send the token to the pair address. It is assumed that the amountOut value calculated by OpenMevLibrary.getAmountOut() accurately stores the amount of tokens that the router contract receives from the swap process. Instead, to support fee-on-transfer tokens, a calculation of ERC20(token).balanceOf(address(this)) - balanceBefore as found in the router function removeLiquidityETHSupportingFeeOnTransferTokens() should be used. The _arb() function can even cause problems when neither the first nor last token is a fee-on-transfer token, but one of the intermediate swaps uses a fee-on-transfer token. Because the _backrunSwaps() function loops through the array of swaps, any of the backrun swaps that involve a fee-on-transfer token could be problematic. 
4. Failed flashloan arbitrage reverts the original swap Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: These lines include the revert for each flashloan [1, 2]. 
5. Edge case suboptimal arb profit Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The logic branch checks if contractAssetBalance >= optimalAmount, otherwise a flashloan is used. 
6. One failed arb can revert otherwise profitable arb Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The _backrunSwaps() function loops through the array of swaps. Imagine a scenario where _backrunSwaps() is called with a swaps array of length 4. Assume the 1st, 2nd, and 4th backrun swaps are profitable, but the 3rd backrun swap is not. Performing this series of four backrun swaps can still be net profitable even if one of the individual backrun swaps is not. The reason the 3rd backrun swap is not profitable may be because the flashloan fee costs more than the profit of this arb, which reverts here or here, or a similar revert can happen if the router contract funds are used for the arb and the amount received is less than expected. The result is the transaction reverts and OpenMevRouter will miss out on the arb profits if the swaps had been completed even if one individual backrun swap wasn't profitable. 
7. Max approval granted to spender Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: ERC20(token).safeApprove(spender, type(uint256).max); in _approveTokenIfNeeded approves the spend to spent the entire balance. 
8. No check For Aave flashloan balance Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: L915 of OpenMevRouter 
9. Use _isNonZero() for gas savings Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
10. Use _inc() instead of ++ and _dec() instead of -- Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: There is one instance of an increment improvement. There are two instances of a double decrement that could be replaced with _dec(_decr()) or with unchecked { length - 2; }: First instance Second instance 
11. Bitshifting is cheaper than multiplication or division Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: There are four instance of divide by 2 operations that can use bitshifting for gas efficiency: First instance Second instance Third instance Fourth instance 
12. Unnecessary zero initialization Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: 
13. Payable functions can save gas Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The following functions have the onlyOwner modifier and can be marked as payable First function Second function Third function 
14. Avoid && logic in require statements Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: One instance of require with && logic was found. 
15. Declare constant internal when possible Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The bento constant should be internal if possible. 
16. Replace require with errors in OpenMevRouter Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: One instance in _addLiquidity (require(amountAOptimal <= amountADesired);) and another instance in addLiquidityETH (require(IWETH(weth).transfer(pair, amountETH));, which can be replaced with safeTransfer as is done in swapExactETHForTokens). 
17. Remove unused code Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: First instance Second instance Third instance 
18. Use simple comparison Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The _addLiquidity() function in OpenMenRouter.sol contains this code: if (amountBOptimal <= amountBDesired) { // require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT'); if (amountBOptimal < amountBMin) revert InsufficientBAmount(); // revert InsufficientBAmount({ available: amountBOptimal, required: amountBMin }); (amountA, amountB) = (amountADesired, amountBOptimal); } else { uint256 amountAOptimal = OpenMevLibrary.quote(amountBDesired, reserveB, reserveA); require(amountAOptimal <= amountADesired); // require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT'); if (amountAOptimal < amountAMin) revert InsufficientAAmount(); // revert InsufficientAAmount({ available: amountAOptimal, required: amountAMin }); (amountA, amountB) = (amountAOptimal, amountBDesired); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (amountBOptimal > amountBDesired) { uint256 amountAOptimal = OpenMevLibrary.quote(amountBDesired, reserveB, reserveA); require(amountAOptimal <= amountADesired); // require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT'); if (amountAOptimal < amountAMin) revert InsufficientAAmount(); // revert InsufficientAAmount({ available: amountAOptimal, required: amountAMin }); (amountA, amountB) = (amountAOptimal, amountBDesired); } else { // require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT'); if (amountBOptimal < amountBMin) revert InsufficientBAmount(); // revert InsufficientBAmount({ available: amountBOptimal, required: amountBMin }); (amountA, amountB) = (amountADesired, amountBOptimal); } Another instance of this improvement is found with the comparison >= 1. Two other instances of this are in OpenMevLibrary.sol (lines 270 and 331), but to show the example from _swapSupportingFeeOnTransferTokens(): swaps[i].isBackrunable = ((1000 * amountInput) / reserveInput) >= 1; Because >= 1 equates to > 0, and G1 shows how != 0 or _isNonZero() is better than > 0, the comparison can be simplified to swaps[i].isBackrunable = _isNonZero(((1000 * amountInput) / reserveInput)); 
19. Combine reserve value checks Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Most places where OpenMevLibrary.getAmountOut() in OpenMevZapper results in duplicated reserve checks. 
20. Use msg global vars directly Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: msg.value is unnecessarily cached in: addLiquidityETH() swapETHForExactTokens() swapETHAndStakeLiquidity() msg.value can replace swaps[0].amountIn swapExactETHForTokens() here and here 
21. Remove duplicate internal function call Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: One example: First call Second call 
22. deadline special case not aligned with permit Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: EIP-2612 text ensure() function 
23. Replace pair.swap() with _asmSwap() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Line 699 of OpenMEVRouter.sol 
24. Remove a sortTokens call Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The first sortTokens() call The second sortTokens() call happens in pairFor() 
25. Missing curly brace Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: This if statement is missing curly braces. 
26. Reduce number of swaps Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Consider the constant product diagram Point 1 shows the liquidity pool amounts before OpenMevRouter interaction, point 2 shows the amounts after the OpenMevRouter user swap, and point 3 shows the amounts after the first backrun of the arb process. These two steps can be combined to arrive from point 1 to point 3, skipping to need to swap to arrive at point 2. The math in OpenMevRouter.sol would need changing, but gas savings from removing one swap may be enough to reduce overall gas consumption. 
27. Revert if zero flashloan profit Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The revert logic for the kashi flashloan callback is currently: if (amountOver < amountOwing) revert InsufficientOutputAmount(); Instead, the revert should also happen on the equality case: if (amountOver <= amountOwing) revert InsufficientOutputAmount(); The same improvement can be made in the Aave flashloan callback. 
28. OpenMevRouter should inherit from IFlashBorrower and IOpenMevRouter Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
29. The ETHERSCAN_API key is present in plaintext Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
30. SafeTransferLib does not match Solmate's main branch Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
31. Incorrect comment Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The comment on line 1001 doesn't match the code in line 1002. 
32. Replace magic numbers with constants Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There are many instances of the value 1000. Consider replacing this magic number with a constant internal variable named MINIMUM_LIQUIDITY like Uniswap does: First instance Second instance Third instance Fourth instance Fifth instance Other instances of magic numbers are found in calcCoeffs(). 
33. Typos Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: First typo Second typo 
34. Hard coded Aave token list Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The hard coded list of tokens in OpenMevLibrary.sol. 
35. Inconsistency in WETH transfers Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The one instance of a WETH transfer with require(IWETH(weth).transfer(pair, amount));. All other instances use IWETH(weth).deposit{ value: amount }(); First instance Second instance Third instance 
36. safeApprove vulnerable to double withdraw Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: One relevant safeApprove() call was found. Permit is used in several functions in OpenMevRouter.sol: First function Second function Third function 
37. Same frontrunning weaknesses as Uniswap/SushiSwap Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Project documentation explaining these attack vectors still remain. 
38. Kashi flashloanable tokens assumed same as aave Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The logic to backrun a swap happens if either there is sufficient token balance in the router that no flashloan is needed, or the token can be flashloaned from Aave. There is no separate list of Kashi-supported flashloanable tokens. Only a list of Aave flashloanable tokens exists. 
39.  (engn33r) Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Incorrect comment for add512x512() 
