1. Underflow in int256 -> uint256 conversion Severity: High Difficulty: n/a Type: n/a Target: n/a Description: In GTranche.sol, pnlDistribution() and _pnlDistribution() calculate the new _trancheBalances in int256 values before casting them to uint256 when storing in the return variables. This final casting will cause an underflow if the int256 value _trancheBalances is negative. For example: Assume a scenario where the Junior Tranche is permitted 50x leverage, so the Senior Tranche has 5000 wei and the Junior Tranche has 100 wei (root causes include: no minimum deposit in the tranche, no limit on the leverage allowed, no limit on the fixed yield paid to the Senior Tranche) If the PnL distribution is not done in a long time, it is possible that the seniorProfit owed to the Senior Tranche will be greater than 100 wei. This needs to be paid to the Senior Tranche even if the profit of the tranche is zero (if lastTotal <= totalValue then distributeProfit() will be triggered). distributeLoss() prevents loss[0] from holding a value that is greater than _trancheBalances[0], which would cause a negative _trancheBalances[0] after this subtraction and would later underflow. In contrast, distributeProfit() has no similar check and there is even a comment stating that the profit to the Junior Tranche can be negative, which would make it similar to a loss scenario for this tranche. If the value of -1 * (_amount - seniorProfit) is greater than _trancheBalances[0], then the addition operation will actually become a subtraction and result in _trancheBalances[0] holding a negative value, which would underflow in a later casting. The same underflow issue may theoretically occur with distributeLoss() if _amount - _trancheBalances[0] > _trancheBalances[1]. This might be possible in a tranche setup where nearly all the deposits are in the Junior Tranche so the utilization ratio is nearly zero, but an accounting error causes the losses to be greater than the total tranche assets. This scenario seems unlikely but still may be worth protecting against. 
2. sellAllRewards() reverts with non-zero numberOfRewards Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The swapExactTokensForTokens() function in Uniswap V2 Router has a safeTransferFrom() call. The address calling the Uniswap V2 router must approve the tokens for the Router before calling this function, otherwise the function will revert. The ConvexStrategy fails to approve additional reward tokens before calling Uniswap V2. 
3. wethAmount in rewards calculations should be balanceOf Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: When _sellRewards() calculates the rewards that can be reinvested into 3CRV, it starts calculating with a wethAmount of zero. However, the minimum amount for converting CRV rewards or CVX rewards to ETH is 1E18 of CRV or CVX, while the minimum amount for converting ETH to 3CRV is 1E16 ETH. Assuming the current prices of $1200 WETH, $0.5 CRV, and $3.50 CVX, it is possible for a scenario where $11 worth of CRV and CVX is converted into WETH, but because the 1E16 threshold for converting WETH to 3CRV is $12, the WETH will not be converted into 3CRV. If this case happens many times, substantial WETH could accumulate in the strategy without getting reinvested to earn more yield. 
4. Tranche deposit/withdrawal denial of service Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The current code is written in a way that assumes the utilisation ratio remains below the utilisationThreshold unless a deposit or withdrawal will move it above the threshold. In fact, the utilisation ratio can achieve a value greater than utilisationThreshold in a couple of ways: The owner can set utilisationThreshold to any value with setUtilizationThreshold(). If the threshold is set to a value less than the current utilisation ratio, it can break assumptions about how the protocol should work and prevent tranche deposits or withdrawals. Losses for the Junior Tranche may result in a scenario where the utilisation ratio exceeds the utilisationThreshold. Note that the Junior tranche can experience a loss even when distributeProfit() is called because the yield paid to the Senior Tranche depositors may exceed the profit earned. If the utilisation ratio exceeds the utilisationThreshold, a GTranche deposit() or withdraw() that attempts to move the utilisation ratio in the correct direction may revert if it does not bring the ratio below utilisationThreshold. This behaviour breaks an assumption in the protocol documentation that such actions should always be allowed. 
5. Unreliable Senior Tranche yield Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: PnLFixedRate.sol does not account for seniorProfit in two cases: In distributeLoss() when the loss is greater than or equal to the value of the Junior Tranche and could cause losses for the Senior Tranche In distributeProfit() when the utilisation ratio is greater than utilisationThreshold 
6. Timing mismatch between time-gated actions Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: _calculateLockedProfit() is designed to slowly release profits to the GVault depositors. If the releaseTime is surpassed, which is 24 hours, it returns zero, which means no profit is locked. The lockedProfit value is updated when report() in GVault is called by a strategy's runHarvest(). ConvexStrategy's canHarvest(), which indicates when a keeper can call runHarvest(), has a constant MIN_REPORT_DELAY value of 48 hours. This means that if MIN_REPORT_DELAY is the determining factor for when a harvest happens, _calculateLockedProfit() will return zero for roughly half of that minimum time period. During the time that _calculateLockedProfit() returns zero, the profit calculation in PnLFixedRate of totalValue - lastTotal will return zero. This will causes the Senior Tranche to take value from the Junior Tranche to pay the fixed yield of the Senior Tranche. An example of how this could be leveraged to cause a loss for Junior Tranche holders: Depositor deposits 3CRV into the GVault The GVault does not move 3CRV to the strategy until report() is called by a strategy, so the assets may not maximize their yield for some time Depositor deposits their GVault ERC4626 tokens into the Senior Tranche and soon withdraws. The deposit and withdrawal may both be done in a short period (say, 24 hours) while _calculateLockedProfit() is returning zero. This means before report() will not have been called to deposit the loose 3CRV in the GVault to maximize yield, yet the depositor claims their fixed yield from the Senior Tranche at the cost of Junior Tranche depositors, who don't reap the full benefits of the 3CRV deposit into the GVault. If the above actions are performed frequently with large amounts of capital, say twice a week, the Junior Tranche may be less appealing for depositors. This is because the Junior Tranche is willing to pay the Senior Tranche the borrowing cost for leverage, but this cost makes more sense if the Junior Tranche is able to use the 3CRV in the strategy and not when it is sitting idle in the GVault. This scenario would get worse if the tranche had a large utilization ratio, say 10x, because the fee paid to the Senior Tranche would be larger. The flip side of this is that Junior Tranche depositors would be incentivized to withdraw their deposits during the time when _calculateLockedProfit() returns zero for the same reason. 
7. Whale invest() and divest() denial of service Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: A whale may deposit an extremely large amount of 3CRV into GVault. When the GVault provides this 3CRV to ConvexStrategy to invest, the invest() function makes sure that the liquidity added to the metapool is within proper slippage tolerance. If the Curve pool is imbalanced sufficiently by the added liquidity, it may not return sufficient value and cause invest() to revert due to the slippage exceeding the slippage tolerance. This denial of service would not cost the whale much to sustain the DoS because they could deposit the GVault tokens into the Senior Tranche (at least until the utilization ratio is met) and receive their fixed yield, even though the Junior Tranche is not receiving its yield because the strategy's harvesting mechanism is locked up. In theory this could lead to bankrupting the Junior Tranche if carried out for long enough because the whale's deposit can't be deposited into the metapool to maximize rewards, like the "leach attack" described in a separate finding. divest() has a similar slippage check that may also revert under some conditions. Since users cannot control when divest happens, the whale would need to imbalance the pool outside of Gro. This DoS is likely far more costly than the invest() DoS vector because imbalancing the Curve pool would most likely create and arbitrage opportunity. 
8. Strategy migration should remove old approvals Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: setPool() in ConvexStrategy.sol gives a new metaPool infinite approval. But when this happens, the old metapool (if one was previously set) does not have its infinite approval revoked. If the old metapool had a security issue, the inability to revoke the prior approval could be problematic and would require emergency mode activation which would not be required if the approval could be revoked. The same process should take place to remove the BOOSTER approval of the old LP token. 
9. Inconsistent ERC20 imports Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: One example showing the mixup between the OpenZeppelin and solmate ERC20 libraries is in IGVault and GVault. IGVault imports IERC20 from OpenZeppelin while GVault imports ERC20 from solmate. The solmate ERC20 library has EIP-2612 support while OpenZeppelin does not include such logic in the default ERC20 file and instead packages it in the file draft-ERC20Permit.sol. The way the code is currently written may be confusing for protocols integrating with Gro Protocol because The GVault ERC4626 token will support EIP-2612 but the GToken (and therefore the JuniorTranche and SeniorTranche) will not. Because the tranche is intended to be a wrapper for the GVault ERC4626, which does support permit(), this is not ideal because the tranche wrapper does not support permit() like the GVault ERC4626. The below slither commands can be used to demonstrate the difference in EIP2612 support. slither-check-erc --erc ERC2612 --solc-remaps "@openzeppelin/=lib/openzeppelin-contracts/ @chainlink/=lib/chainlink-brownie-contracts/ ds-test/=lib/forge-std/lib/ds-test/src/" ./src/tokens/GToken.sol GToken slither-check-erc --erc ERC2612 --solc-remaps "@openzeppelin/=lib/openzeppelin-contracts/ @chainlink/=lib/chainlink-brownie-contracts/ ds-test/=lib/forge-std/lib/ds-test/src/" ./src/GVault.sol GVault 
10. Similar functions have different logic Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: executeStopLoss() includes the line if (strategy == address(0)) continue; which is not in canExecuteStopLossPrimer(). Likewise, canExecuteStopLossPrimer() includes the line if (strategyCheck[strategy].primerTimestamp == 0) continue; which is not in executeStopLoss(). The two functions should share logic. Currently, the lack of a zero check for strategyCheck[strategy].primerTimestamp in executeStopLoss() means a rogue keeper could execute a stop loss before primerTimestamp has been set to a non-zero value. 
11. ConvexStrategy owner can sweep tokens Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Many DeFi protocols attempt to remain immutable to enable the user to maintain control over their assets at all times. While the underlying asset token is prevented from owner sweeping, the rewards returned by the Curve metapool are impacted as are the metapool LP tokens. This could lead to loss of user funds if the owner count is compromised or acts maliciously. In order to increase trust in the protocol, the owner should be a sufficiently distributed multisig to allow users to trust it. 
12. Inconsistent minimum reward amount Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: _claimableRewards() should compare the WETH value of rewards to MIN_WETH_SELL_AMOUNT and not to , otherwise _claimableRewards() will not return a value if the amount of rewards has a value of less than 1 ETH, which is quite a large requirement for rewards values to be included in the calculations in rewards(). The existing strategy code will underestimate the rewards returned by _estimatedTotalAssets() when the value of _claimableRewards() is between 1E16 WETH and 1E18 WETH which impacts the PnL calculations. 
13. Inconsistent metapool fee inclusion Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The Curve docs describe calc_token_amount(), which is used in divest(), with the following: This calculation accounts for slippage, but not fees. It should be used as a basis for determining expected amounts when calling add_liquidity or remove_liquidity_imbalance, but should not be considered to be precise! This means that in invest(), the slippage calculation compares _credit, the initial 3CRV token amount, with amount * ratio, which is the 3CRV value after slippage and fees. In contrast, divest() compares _debt, the initial 3CRV token amount, with meta_amount * ratio, which is the 3CRV value after slippage but without fees. 
14. Potentially incorrect branching logic Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: This line of realisePnl() is unreachable because if loss > _excessDebt evaluates to true, to flow would have entered this if statement instead. The duplicate line of logic should be removed or changed. The comment of here for safety, but should really never be the case before the line of code that is duplicated and never reached indicates some of the nuance of the branching may not be fully understood. 
15. setStrategies() doesn't set strategyCheck values Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: setStrategies() does not allow setting values in strategyCheck, which is in contrast to addStrategy(). This could impact the use case where setStrategies() is useful. For example, if strategyCheck values are not set, the strategy will never return true in functions like canEndStopLoss(). 
16. Weak oracle result staleness check in staleCheck() Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: staleCheck() only checks that the Chainlink price data is under 24 hours old. The staleness check does not consider whether the roundId data may be outdated. It is recommended to do both, as shown in other security report findings here and here. Specifically, the DAI/USD oracle updates more regularly than every 24 hours. Considering that the Gro protocol has protections in place for stablecoins losing their peg, improving the Chainlink price staleness check is a crucial consideration. 
17. No minDeposit in GTranche Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: GVault sets a minDeposit value to prevent very small 1 wei deposits. GTranche has no comparable minimum value. When combined with the implementation of utilization() adding 1 wei to the denominator, the lack of a minDeposit is problematic in the following scenario: The utilisationThreshold is set to 3E4, implying there can be 3 tokens deposit into the Senior Tranche for every token deposited into the Junior Tranche 1 wei is deposited into the Junior Tranche 3 wei is deposited into the Senior Tranche, which should be the maximum amount permitted to maintain the 3-to-1 ratio With the current tranche holdings, utilization() returns a value of (3 * 1E4) / (1+1) = 15000, which is half of the utilisationThreshold limit of 3E4 An additional 3 wei can be deposited into the Senior Tranche. Now utilization() returns (6 * 1E4) / (1+1) = 30000, but the ratio of Senior Tranche deposits to Junior Tranche deposits is 6-to-1, not the originally intended 3-to-1 Beyond the risk of underinsured Senior Tranche deposits, another side effect of the lack of minDeposit is the possibility of an inflation attack. 
18. Volatile token price causes higher vault fees Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: _calcFees() is called only once in GVault, from report(). _calcFees() is a bit of a misnomer because the function also takes those fees and sends them to the feeCollector address specified by the owner using setFeeCollector() while returning the gains amount minus fees. The gains are defined as the difference between all the strategy's assets (loose assets, LP tokens, and rewards) and the strategy's debt, which is a value stored in strategies[strategyAddress].totalDebt in the GVault. A key part of this is that when a strategy reports a loss, the totalDebt of the strategy is reduced to account for the loss, so it is as though the strategy received fewer assets to begin with. The combination of how fees are taken from gains and the goal post for how gains are calculated getting moved on every loss creates a problematic combination. Consider the following series of events: Value of Strategy is $1000 Strategy loses $20 and report() is triggered Strategy gains $20 and report() is triggered (pays vault fee on $20 gains) Strategy loses $20 and report() is triggered Strategy gains $20 and report() is triggered (pays vault fee on $20 gains) The strategy has paid the vault fee twice even though the value in the strategy hasn't changed. It is only the volatility in the strategy's assets that caused the fees to be applied. This penalizes depositors for market volatility instead of penalizing them for withdrawing, which is how the Gro protocol is documented to work today. Note that this specific strategy is built on 3CRV and the Frax Curve metapool, so the value of the LP tokens should only increase and not be subject to such volatility. By deducting fees at the time of profit, there is less value in the vault to compound and grow, which slightly reduces the appeal of the strategy. 
19. High default slippage tolerance Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The default value of PERCENTAGE_DECIMAL_FACTOR if 1E4 while baseSlippage is 50. This means the default tolerance is (10000 - 50) / 10000 = 9950 / 10000 = 99.5%, allowing for 0.5% slippage, in invest() and divest(). When the Frax metapool was examined at the time of this review, the Curve Finance frontend estimated a 0.03% slippage if withdrawing 1E8 LP tokens, which was over 20% of the total supply of the metapool. Similarly, when estimating the slippage for a deposit of 1E8 CRV tokens, which would increase the existing balance of CRV in the metapool by over 50%, the frontend estimated a 0.06% slippage. Given the size of the slippage with such large deposits or withdrawals, and considering that the default slippage tolerance on the Curve frontend for this Frax metapool is 0.1%, the existing combination of PERCENTAGE_DECIMAL_FACTOR and baseSlippage provides too large of a slippage tolerance. 
20. Use prefix in loops Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: There are instances of this throughout the contracts, with examples of this optimization opportunity found in GStrategyGuard.sol, GTranche.sol, and GRouter.sol. 
21. Unnecessary zero initializations Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: There are instances of this throughout the contracts, with examples of this optimization opportunity found in GTranche.sol, GRouter.sol, StrategyQueue.sol, and ConvexStrategy. 
22. Use simple comparison Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The withdraw() function in ConvexStrategy provides one example of this, but there are other instances in the contracts: if (withdrawnAssets <= _amount) { loss += _amount - withdrawnAssets; } else { if (loss > withdrawnAssets - _amount) { loss -= withdrawnAssets - _amount; } else { loss = 0; } } By switching around the if/else clauses, we can replace the compound operator with a simple one if (withdrawnAssets > _amount) { if (loss > withdrawnAssets - _amount) { loss -= withdrawnAssets - _amount; } else { loss = 0; } } else { loss += _amount - withdrawnAssets; } 
23. Remove redundant check Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: mint() in GVault checks if assets is zero and then checks if assets is less than minDeposit. The first check is redundant because if assets is zero, then assets < minDeposit is true and it will revert in the next check. This suggestion assumes that minDeposit should be 10 ** _asset.decimals() instead of _asset.decimals(), since 10 ** X where X is a uint cannot result in a value of zero. Separately, the returns in mint(), deposit(), and withdraw() are unnecessary and can be removed because the return value is the same as the named return variable. 
24. Use Solidity errors in 0.8.4+ Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Require statements are found in the JuniorTranche, SeniorTranche, GToken, and GVault contracts (examples include 1, 2, 3, 4). Using this new solidity feature can provide gas savings on revert conditions. 
25. Declare variables immutable when possible Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The IsGTrancheSet boolean is set only once in GMigration.sol and can be immutable. 
26. Use unchecked if no underflow risk Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: One example where unchecked can be applied: - loss = lastTotal - totalValue; + unchecked { loss = lastTotal - totalValue; } Similar savings can be found throughout the contracts including here, here, and here. 
27. Unusual minDeposit choice Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: This line of GVault.sol may have a typo if the intent is to have a minimum deposit of at least one dollar (because the vault is designed for stablecoins). 
28. Fees may be sent to address(0) Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The GVault default is to have vaultFee and feeCollector remain unset, which keeps them at the default values of 0 and address(0) respectively. It is possible for vaultFee to be set to a non-zero value while feeCollector remains at zero, resulting in fees getting sent to address(0). 
29. Missing _minAmount check in redeem Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: deposit() and mint() verify the deposit amount is greater than minDeposit while withdraw() checks that the asset amount is greater than the user-specified _minAmount before transferring tokens. redeem() does have a comparable minimum value check before assets are transferred. 
30. _owner argument shadows Ownable state variable Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: withdraw() in GVault.sol has a _owner argument that shadows a state variable with the same name in OpenZeppelin's Ownable library. 
31. Junior tranche lacks immediate withdrawal guarantees Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: In order to deposit in the Senior Tranche, there must be sufficient value in the Junior Tranche to protect Senior Tranche deposits. This means that if the Junior Tranche protects the Senior Tranche 1-to-1 and there is 100% utilization, no Junior Tranche funds can be withdraw. In the event that all depositors to the Junior Tranche wish to withdraw, there could be a "bank run" where the first users to withdrawer receive their funds, but when the utilization ratio hits 100%, no Junior Tranche funds can be withdrawn because they are needed to protect the funds in the Senior Tranche. This behaviour is the norm for tranche structures, but users who have not interacted with such a pool design may not clearly understand the limitations of the system. This could be problematic for users if they have a loan in a protocol like Aave that is about to be liquidated and they cannot withdraw their funds from the Junior Tranche to increase their loan collateralization ratio. A real scenario where this would be incentivized to take place is a "leach attack", when the fixed yield on the Senior Tranche exceeds what the underlying vault is capable of producing and the Senior Tranche depositors leach off the Junior Tranche value. If the Senior Tranche promised an absurdly high fixed yield, or if the underlying vault yield drops to a near-zero value, the Senior Tranche depositors would be more incentivized to keep their token in the Senior Tranche to receive the "impossibly good" yield, even though the yield the Senior Tranche is receiving is being taken from the token value of the Junior Tranche depositors (because the yield from the vault cannot cover the fixed yield amount). It is true that the tranche owner can set the fixed rate with setRate(), but there may be a delay before this happens (possibly a DAO vote), during which time value could be leached from Junior Tranche depositors and the Junior Tranche depositors would be unable to withdraw because 1. the utilization ratio does not permit it 2. the leaching causes a loss of value in the Junior Tranche which makes the utilization ratio even worse. 
32. Change call sequence for reentrancy mitigation Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: In _withdraw(), funds are transferred out of the GVault before the vaultAssets state variable is updated. According to checks-effects-interactions, the external interactions should happen last, meaning the vaultAssets variable should be updated before funds are transferred. This is what the solmate ERC4626 implementation does by calling the internal _burn() first to update the totalSupply value before transferring funds, which is the opposite of when the transfer happens relative to _mint() in mint(). The same change can be applied to redeem() and report() (1, 2). 
33. Undocumented assumption of private Gelato mempool Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: MEV protection mitigates the risk of a frontrun, backrun, or sandwich that can extract value from a transaction. This most often happens during swap operations. The design of Gro Protocol assumes that when a Gelato keeper executes a transaction, there will be MEV protection. The Gelato documentation does not clarify that this is a guarantee that keepers offer and whether there is still risk of an uncle bandit attack. The MEV mitigation is expected to exist based on discussions with the Gro devs, but the lack of official documentation around the mempool guarantees provided by Gelato jobs, the possibility of changes over time, and the risk of a rogue Gelato keeper are all possible concerns with this approach. 
34. Inconsistent interface files Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: metapool is cast as ICurve3Pool here because get_virtual_price() is found in the external Curve3Pool contract and is inherited by the metapool contract. However, the same could be said about remove_liquidity_one_coin(), but metapool is cast as ICurveMeta when removing liquidity (1, 2, 3) because the Curve3Pool usage in ConvexStrategy didn't use that function. 
35. Inconsistent Uniswap array indices Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Uniswap references the amountOut value with amounts[amounts.length - 1] with comparing that value to amountOutMin, and this approach is found once in ConvexStrategy. Another approach of hard coding an index of 1 is found elsewhere. 
36. _additionalRewardTokens() works in unexpected way Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: In rewards(), _additionalRewardTokens() is summed with _claimableRewards(). The latter returns the value of claimable rewards that can be received if getReward() is called as it is in sellAllRewards(). In contrast, _additionalRewardTokens() does not do this. Instead, _additionalRewardTokens() sums the current balance of award tokens in the strategy. This can result in a different value than the return value of sellAllRewards(), which is likely unexpected behaviour. 
37. Non-ideal _sellAdditionalRewards() min reward limit Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Consider a value different from the current MIN_REWARD_SELL_AMOUNT used in _sellAdditionalRewards() because different tokens have different decimals values and different values. A more flexible choice of value would be preferable to enable flexibility with future reward tokens. 
38. Strategy migration logic can revert Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: divestAll() is written to avoid a revert condition at all costs because it is intended to be used for the emergency scenario where reverting is not an option. divestAll() is called immediately before migratePool(). After the migration, realisePnl() is called which has has divest() calls (1, 2) which offer an opportunity for a revert to happen. This could prevent the migration from happening in some circumstances. 
39. Theoretical casting overflow Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: This line of StopLossLogic casts a uint256 dy_diff to an int256 value. It is possible a very large unsigned value would be converted to a negative number. 
40. Differing approach to keeper role Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The keeper variable in GStrategyGuard stores a single address while a similar keepers variable in ConvexStrategy allows for multiple addresses to serve as keepers. Allowing more keepers provides more flexibility if Gelato changes their operations to have multiple addresses executing transactions, or to allow the owner address to serve as a keeper. 
41. Duplicate strategies possible with setStrategies() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: _addStrategy() does not permit a strategy to be added to the strategies array if it is already in the array. But the owner could use setStrategies() to do the same. 
42. Unnecessary ERC4626 casting Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: getYieldToken() in FixedTokensCurve returns an ERC4626 value. But GTranche needlessly casts this return value to an ERC4626 in several places (1, 2, 3, 4). 
43. getSwappingPrice() doesn't make sense with single strategy and vault Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The Gro protocol as examined only has one token that is deposited into it, as the return value of getYieldToken() shows. The current implementation of getSwappingPrice() allows any uint256 input values for function arguments i and j and always returns the input _amount which implies a 1-to-1 exchange rate between token i and token j. This return value doesn't make sense. It would make more sense to follow an implementation like getYieldToken() shows and only allow an i and j value of zero, reverting in other cases. 
44. No upper limit to Junior Tranche leverage or fixed yield Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Setting an upper bound on the leverage available to a Junior Tranche, and therefore a lower bound on the protection available to Senior Tranche depositors, may be prudent to avoid blatant misuse of the Gro tranche design. Additionally consider a limit on the fixed yield amount, which could be adjusted by the protocol owner depending on market conditions. Be aware that the yield in the tranche design is dollar denominated, so if the underlying asset drops in value, there could be issues in paying the fixed yield to the Senior Tranche. We can take one example of the Junior Tranche taking 20x leverage by borrowing from the Senior Tranche, with a fixed Senior Tranche yield of 2%: 100% utilizationRatio * (20x leverage - 1x from Junior Tranche) * 2% Senior Tranche Fixed Yield = 38% borrowing cost owed to Senior Tranche Due to the amount of leverage in the Junior Tranche and the yield promised to the Senior Tranche depositors, the Junior Tranche could easily see losses if it cannot continue to deliver the 38% yield. 
45. Multiple migration functions increase trancheBalances Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: migrateFromOldTranche() increases the tranche balances here. migrate() does so here. The two migration functions appear to serve different purposes, but a boolean protecting the two functions from both getting called does not exist. Instead, hasMigratedFromOldTranche is only found in migrateFromOldTranche(). 
46. Unclear redistribution of vault fees Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Existing Gro protocol documentation mentions the withdrawal fees are redistributed back to the protocol. While this may not be true with the upgraded Gro protocol, if the fees are to be redistributed to the protocol, it should be done in a way that is not gameable. 
47. Tranche tokens not compliant with ERC4626 Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: To clarify, the tranche tokens do not currently implement ERC4626 but the documentation uses the word "ERC4626 wrapper" when describing the tranche, which could be misleading. GVault and tranche tokens import the same ERC4626 to implement basic ERC4626 support. GVault overrides many virtual functions from this import to implement them correctly according to ERC4626 specifications, but GTranche does not. The functions that should be implemented in GTranche to comply with ERC4626 include: mint() deposit() withdraw() redeem() convertToShares() convertToAssets() maxRedeem() previewRedeem() maxWithdraw() previewWithdraw() maxMint() previewMint() maxDeposit() previewDeposit() 
48. Silent returns Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: move() in StrategyQueue silently returns in three cases. This may give the owner calling moveStrategy() a false sense of confidence that the strategy was moved, when it in fact was not. 
49. Minor nitpicks Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Consider naming withdrawalQueue(uint256 i) to withdrawalQueueAt(uint256 i) and withdrawalQueue() to fullWithdrawalQueue(). Consider clarifying the strategy return value is an address, not a Strategy struct. getStrategyDebt() and getStrategyAssets() return the totalDebt of a strategy and might be improved with more similar names to avoid confusion over debt vs. assets. NatSpec is incomplete for some functions, such as missing return value descriptions for beforeWithdraw()/excessDebt/_excessDebt and no NatSpec for _removeStrategy() in GVault depositIntoTrancheForCaller() is missing a comment that _token_index of 3 or greater is 3CRV Typo: adapetr -> adapter Typo: Apporve -> Approve Typo: CHIANLINK_FACTOR -> CHAINLINK_FACTOR Typo: add_liquididty -> add_liquidity Typo: strategies -> strategy's and same here Typo: enstimated -> estimated Typo: excluding and profits -> excluding profits Typo: srategy -> strategy Typo: do generate -> to generate Typo: unledrying -> underlying Typo: beneth -> beneath and here Typo: baring -> bearing Typo: extensoin -> extension Typo: their -> there Typo: underlyng -> underlying Typo: prive -> price Typo: it -> its Typo: utiliszation -> utilisation Typo: _tranchTokens -> _trancheTokens Typo: between to underlying -> between the underlying Typo: amount of price -> amount of yield token Typo: and ontermiadry -> an intermediary Typo: amount of transform (unclear what this means) Typo: setUtilizationThreshold() (note utilization with a 'z') sets the variable utilisationThreshold (note utilisation with 's') and there is a function utilization() (note utilization with a 'z') Typo: experiene -> experience Improve precision by changing ((_lockedProfit / _releaseTime) * _timeSinceLastReport) to ((_lockedProfit * _timeSinceLastReport) / _releaseTime) to match Vault.vy approach Fix this comment that references a non-existent emergencyExit() function The emergency boolean function argument is missing a NatSpec comment as is _calcFactor() in GTranche and _loss in PnL The debt variable is not used for any purpose. It may be better to simply compare debtPayment to the value of _excessDebt(msg.sender) to replace the safeMath in this line. Inaccurate NatSpec for withdraw()'s _amount (better would be "asset quantity needed by Vault if not holding enough asset balance") and missing NatSpec for return values Replace PnL magic numbers with constants. For example, replace 10000 with utilisationThreshold. Junior Tranche is branded as GVT token, so this comment should replace PWRD with GVT Consider a better name than "controller" or "ctrl" in GToken for the GTranche address, because the word "controller" does not appear anywhere in GTranche Assets in Convex are not locked and therefore are not used to vote in reward distribution. There are potential downsides to this approach and this choice should be documented somewhere in Gro's documentation. The strategy that ConvexStrategy was inspired by does lock some tokens for voting. _claimableRewards() in ConvexStrategy does not return a value if MIN_REWARD_SELL_AMOUNT is not met and this if statement is not entered Consider replacing slippage in divestAll() with the baseSlippage value used elsewhere because baseSlippage can be modified by the owner unlike slippage estimatedTotalAssets() should replace _estimatedTotalAssets(true) with _estimatedTotalAssets(false) because the rewards return value is not needed Incomplete NatSpec for factor in _calcTrancheValue() and factor elsewhere in GTranche This return is redundant, the named return values would be returned properly without this line The SafeMath OpenZeppelin import in GToken is redundant because solidity 0.8.10 is used. The contract should be updated accordingly. The Ownable import in GToken is redundant because the import of Whitelist.sol includes Ownable already _calcTokenAmount() can remove the _deposit boolean function argument because it is never used for anything useful in the function The NatSpec in CurveOracle uses the term "yield token" to mostly refer to 3CRV while FixedTokensCurve NatSpec uses "yield token" to mostly refer to GVault shares. Consider terms that more clearly differentiate the tokens. Remove unused _tranche bool function argument from _calcTrancheValue() Remove if (_factor == 0) logic from _calcTrancheValue() because this can never happen based on current contract logic lastDistribution could be uint32 instead of uint64 Consider renaming _calcFees() to _gainSubFees() 
