1. Anyone can call uniswapV3MintCallback() stealing the protocol fees Severity: Critical Difficulty: n/a Type: n/a Target: n/a Description: LiquidityManagement::uniswapV3MintCallback() only checks that msg.sender == address(decodedData.pool), which any attacker can trivially fulfill by setting decodedData.pool to an address they own. The function then transfers decodedData.pool.token0() and decodedData.pool.token1() to msg.sender, the amount of which is specified by the caller. 
2. Anyone can call the PeripheryPayments sweepToken() stealing the protocol fees Severity: Critical Difficulty: n/a Type: n/a Target: n/a Description: PeripheryPayments is a dependency of the LiquidityManagement contract, which is a dependency of the BunniHub contract. PeripheryPayments has a sweepToken() with no access control which allows a caller to transfer any token from the BunniHub contract to any recipient. 
3. Anyone can call the PeripheryPayments unwrapWETH9() stealing the weth stored in BunniHub Severity: Critical Difficulty: n/a Type: n/a Target: n/a Description: PeripheryPayments is a dependency of the LiquidityManagement contract, which is a dependency of the BunniHub contract. PeripheryPayments has a unwrapWETH9() with no access control which allows a caller to the contract's weth balance from the BunniHub contract to any recipient. 
4. General complexity around ETH management including certain circumstances where ETH could be lost Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The BunniHub contract currently only has one payable function that can receive ETH which is the receive() found in PeripheryPayments. That function requires that the sender is WETH9. In general BunniHub will not be interacting with ETH but there is functionality embedded with the Uniswap imports related to the management of ETH which adds complexity and some risk. abstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState { receive() external payable { require(msg.sender == WETH9, 'Not WETH9'); } If for some reason someone unwrapped WETH and set the recipient to the BunniHub, then the contract would no hold the ETH. This ETH could be taken by anyone via refundEth() or it could also be included used the next time anyone deposited into a WETH pool since pay() includes some logic that is designed to work with with unwrapping WETH: function pay( address token, address payer, address recipient, uint256 value ) internal { if (token == WETH9 && address(this).balance >= value) { // pay with WETH9 IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay IWETH9(WETH9).transfer(recipient, value); } else if (payer == address(this)) { ... 
5. Calling withdraw() forfeits uncollected LP fees Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Fees are collected and reinvested via compound(), but when withdraw() is called, fees are not collected. 
6. Optimize the sweepTokens() loop Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: @@ -436,12 +453,16 @@ contract BunniHub is - for (uint256 i = 0; i < tokenList.length; i++) { + uint256 tokenListLength = tokenList.length; + for (uint256 i = 0; i < tokenListLength;) { SafeTransferLib.safeTransfer( tokenList[i], recipient, tokenList[i].balanceOf(address(this)) ); + unchecked { + ++i; + } } Incrementing i can be done in an unchecked block because the number of tokens will not overflow saving 108 gas per per iteration. The length of an array can be stored outside of the for loop for additional gas savings 3 gas per iteration.of as is suggested here. Incrementing with ++i instead of i++ saves ~5 gas per iteration from reduced stack operations. 
7. Upgrade to at least solidity 0.8.4 Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Currently there is no underflow or overflow protection at the compiler level in Bunni, which means SafeMath style libraries are necessary, which are gas inefficient compared to the compiler and potentially less safe. Also see hrkrshnn's related comment. 
8. Use latest versions of unmodified libraries Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The contracts are using Solidity 0.7.6 some library contracts (CREATE3, ERC20, and SafeTransferLib) were copied into the directory rather than being imported. However, due to these being copied into the project and also because of some modifications, they do not match the latest versions of these projects. 
9. Consider Foundry scripting for the deployment scripts Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Currently bash scripts are used for the deployment scripts. While they are currently relatively simple, as the project progresses this may no longer be the case. 
10. Typo in README Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There is a typo in the README "perfer". 
11. Consider adding npm related steps to the README Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: npm is used to manage dependencies but this information is not present in the README. 
12. Consider removing the WETH unwrapping logic Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: One of the critical findings is related to WETH management. If it's not necessary it is a source of unecessary additional complexity that may lead to other future vulnerabilities. 
