1. Sonne market parameters have a high risk profile Severity: High Difficulty: n/a Type: n/a Target: n/a Description: In summary, the collateral limits set by Sonne are unusually high in certain markets. Additionally, the overall amount of borrowed assets in Sonne compared to the total assets deposited is also very high. The combination of these factors indicates that Sonne is at risk of collecting bad debt and may not be in a position to pay off this bad debt, which could permanently impact the protocol's reputation. For a first data point, Sonne collateral parameters can be compared to Compound Finance v2, Aave v2 Ethereum, and Aave v3 Optimism market parameters. The table below shows the collateral and reserve parameters for the different underlying assets. | TOKEN | Sonne Collateral Factor | Compound Collateral Factor | Aave v2 Collateral Factor | Aave v3 Optimism Collateral Factor | Sonne Reserve Factor | Compound Reserve Factor | Aave v2 Reserve Factor | Aave v3 Optimism Reserve Factor | | ------ | ----------------------- | -------------------------- | ------------------------- | ---------------------------------- | -------------------- | ----------------------- | ---------------------- | ------------------------------- | | OP | 65% | | | 30.00% | 20% | | | | | USDC | 90% | 85.50% | 80.00% | 80.00% | 10% | 7.50% | 10.00% | 10.00% | | USDT | 90% | 0.00% | 0.00% | 75.00% | 10% | 7.50% | 10.00% | 10.00% | | DAI | 90% | 83.50% | 75.00% | 78.00% | 10% | 15.00% | 10.00% | 10.00% | | sUSD | 60% | | 0.00% | 60.00% | 20% | | 20.00% | | | wETH | 75% | 82.50% | 82.50% | 80.00% | 15% | 20.00% | 15.00% | 15.00% | | SNX | 45% | | 46.00% | | 27% | | 35.00% | | | wBTC | 70% | 70.00% | 72.00% | 73.00% | 20% | 20.00% | 20.00% | 20.00% | | LUSD | 60% | | 0.00% | 0.00% | 20% | | 10.00% | 10.00% | | wstETH | 60% | | 72.00% | 70.00% | 18% | | | 15.00% | Some of the most obvious cases where the Sonne choices differ from other protocols include: 90% USDT collateral factor (compared to 0%) 60% sUSD and LUSD collateral factors (compared to 0%) 75% WETH collateral factor (compared to 80%-82.5%) Aave and Compound have undergone extensive risk analysis as evidenced by their dashboards on Gauntlet's website (1, 2), Gauntlet risk assessment reports (1, 2), and regular governance proposals that modify the risk parameters according to market conditions (1, 2). Aave even disabled borrowing on many tokens in AIP-125 in Nov 2022 after an attack on the protocol caused an accumulation of bad debt. Some of the tokens that had borrowing disabled, including SNX (which exists on Sonne), have not yet reenabled borrowing. While Euler Finance decided to allow borrowing against USDT collateral, it is unclear if Euler Finance has undergone the same level of extensive risk modelling that Compound and Aave have. Comptroller has a hardcoded 90% collateralization factor limit, and because the liquidationIncentiveMantissa is 108%, this means that there is less than a 3% margin in price movement (100% - (108% * 90%) = 2.8%) for some markets before a partial liquidation of a position will push the entire position towards liquidation, as outlined by the "Counterproductive Incentives" high finding in this OpenZeppelin report. A second data point can be found by comparing the amount of assets lent and borrowed between different lending protocols. A specific focus was placed on comparing Sonne with other Compound forks (Venus, Tectonic, Benqi, Flux) for a more equal comparison. Note that Venus also has a Gauntlet dashboard. The results below show that Sonne is allowing a much higher amount of borrowing than other lending protocols, which means Sonne is at higher risk of accumulating bad debt than other lending protocols. The reason behind such high borrowing might be the added SONNE token incentives, but the specific borrowing interest rate curves may be another reason behind such high borrowing. | Protocol | Total assets ($M) | Borrowed ($M) | Borrowed percentage | | ---------------- | ----------------- | ------------- | ------------------- | | Sonne | 85 | 56 | 65.90% | | Compound v2 | 1770 | 539 | 30.50% | | Aave v2 Ethereum | 5130 | 1670 | 32.60% | | Aave v3 Optimism | 94 | 35 | 37.20% | | Venus | 1219 | 430 | 35.20% | | Tectonic | 194 | 69 | 35.60% | | Benqi | 151 | 36 | 23.80% | | Flux | 60 | 23 | 38.00% | A final data point that would be helpful to understand the risk for the Sonne protocol is a dashboard that shows liquidations or bad debt in Sonne. Sonne is not listed in the Risk DAO bad debt dashboard, but working with this team to add Sonne would be a good step forward. Creating a Dune dashboard for liquidations and accounts at risk of liquidation would also help. The very high borrowing on Sonne relative to underlying collateral indicates that users are taking higher risk positions in the protocol than other lending protocols. Monitoring should be in place to understand if bad debt is accumulating, as it did in Aave in November 2022, so that governance action can be taken to adjust the protocol parameters as needed. The combination of the above factors and the lack of any borrow cap means that the risk of a bank run on Sonne is higher than protocols with less risky parameters. There are at least two different ways that a bank run could happen. One is the case where a market is at a high utilization rate, say near 90% utilization like the soOP market currently is. This means that if a whale who has deposited into the soOP pool plans to withdraw 10% of the total supplied assets, the soOP market will reach 100% utilization ratio. When a market is at 100% utilization ratio, there are no more assets that can be withdrawn from the market, because the market physically does not hold any of these assets. This means that some users will not be able to withdraw their assets in this case. The second scenario where a bank run could happen is if bad debt accumulates in the market. The early users to withdraw will be able to withdraw their funds without any problem, but the late depositors will not. The result is that the late or last users to withdraw their assets will receive 100% of the impact of bad debt accumulation. 
2. EOA admins control staking rewards Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The address 0xFb59Ce8986943163F14C590755b29dB2998F2322 is the owner of uSONNE and sSONNE contracts and it is an EOA. This can be confirmed by opening etherscan or querying the contracts directly: cast call 0x41279e29586eb20f9a4f65e031af09fced171166 "owner()(address)" --rpc-url https://mainnet.optimism.io cast call 0xdc05d85069dc4aba65954008ff99f2d73ff12618 "owner()(address)" --rpc-url https://mainnet.optimism.io This same EOA that is the owner of uSONNE and sSONNE is the admin address for Sonne LiquidityGenerator, which was out of scope of this review. Another role of this EOA is to deploy contracts, including the proxy and logic contract for the Unitroller in the Sonne lending protocol. Another EOA address, 0x201ECB1C439F92aFd5df5d399e195F73b01bB0F3, plays a key role in manually transferring rewards from Velodrome to the uSONNE and sSONNE contracts by calling addReward(). The same EOA is stored as reservesManager in Sonne LiquidityGenerator, which was a contract outside the scope of this review. cast call 0x17063Ad4e83B0aBA4ca0F3fC3a9794E807A00ED7 "reservesManager()(address)" --rpc-url https://mainnet.optimism.io EOAs should not play key roles in value transfer operations in a DeFi protocol. There is no way to trust that the EOA is going to act as expected, and without context there is no way to determine that this EOA will not end up rugging depositors of their rewards. Fortunately, in the case of uSONNE and sSONNE, the 0x201ECB1C439F92aFd5df5d399e195F73b01bB0F3 EOA does not have access to the underlying SONNE tokens deposited into the staking contracts, and only has control over future rewards that SONNE generates. But using an EOA for key operations increases the risk of loss of funds due to private key exposure. A multisig would mitigate the risk of this single point of failure. 
3. EOA swapped staked token rewards to ETH for gas Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The EOA 0x201ECB1C439F92aFd5df5d399e195F73b01bB0F3 plays a key role in manually transferring rewards from Velodrome to the uSONNE and sSONNE contracts by calling addReward(). This same EOA converted some rewards to ETH to pay for the gas consumed in the EOA transactions. This process of taking some staking rewards for ETH is not documented anywhere. In fact, this process contradicts the staking documentation which states that users will get 100% of staking rewards: Stakers will get 80% of the protocol revenue and 80% of VELO rewards for the first 3 months. After team tokens start to get unlocked, stakers will start to get 100% of the protocol revenue. Because the EOA is taking some of these rewards for gas, users are not getting 100% of staking rewards. In fact, there is no explanation for how many reward tokens are spent on gas, so users cannot know what percentage of staking rewards they receive. At the time of this review, 27% of total SONNE is staked in uSONNE or sSONNE contracts, which means over 25% of all SONNE tokens are indirectly impacted by this finding. 
4. Unclear protection against Hundred Finance attack vector Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The Hundred Finance hack was largely caused by an empty WBTC market. The other requirements for this attack vector are that the market has a non-zero collateral factor (to allow borrowing against this token as collateral) and a totalSupply of the cToken of zero. The result of this is a scenario similar to ERC4626 share price manipulation for the first deposit, with a large donation to skew share price. There is no evidence that Sonne has a clear and consistent mitigation to this attack vector. One of the more recently created Sonne markets, sowstETH, had a 1 day period between the creation of the market on February 19 and the first deposit on February 20. The same pattern is seen in the soLUSD and soWBTC markets, with the soLUSD market created on February 2 and the first deposit on February 3 and the soWBTC market created on December 3 and the first deposit on December 4. The markets were initialized with a non-zero collateral factor, but the collateral factor was raised above 0 before the first deposit in all three of these cases, meaning there was a point in time when the protocol was likely vulnerable to the same attack as Hundred Finance. For example: soWBTC market is deployed at 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D. soWBTC market was deployed in block 45086893. Collateral factor in this block and soon after is zero, which is good, because assets deposited immediately cannot be borrowed against. cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 "markets(address)(bool,uint256,bool)" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --block 45086893 --rpc-url https://mainnet.optimism.io First deposit into soWBTC happened in block 45448745. But in the block before it, we can see the collateralization factor was already non-zero and was set to 70%: cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 "markets(address)(bool,uint256,bool)" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --block 45448744 --rpc-url https://mainnet.optimism.io For further confirmation that this is the correct block to examine, the blockchain data confirms that the totalSupply of soWBTC in the block before the first deposit was zero, and then was non-zero in the following block. Before: cast call 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D "totalSupply()" --block 45448744 --rpc-url https://mainnet.optimism.io After: cast call 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D "totalSupply()" --block 45448745 --rpc-url https://mainnet.optimism.io In fact, after doing a search to find when the collateralization factor changed, it is revealed that the collateralization factor was changed in block 45448654. The before and after can be compared with: Before: cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 "markets(address)(bool,uint256,bool)" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --rpc-url https://mainnet.optimism.io --block 45448653 After: cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 "markets(address)(bool,uint256,bool)" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --rpc-url https://mainnet.optimism.io --block 45448654 There is no script in the deploy directory for deploying a new market, which is another data point that there is no consistent documented process to deploying new markets in a way that mitigates this attack vector. 
5. No sequencer uptime check before querying Chainlink data on L2 Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: If a transaction is created on an L2 rollup while the sequencer is down, the transaction would be added to a queue. Because the transaction timestamp is the time when the transaction was queued, by the time the sequencer comes back online to process the queue, the price data could be outdated. 
6. Poor choice of interest rate models in Sonne Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: Every cToken has a separate interest rate model contract. This is true even when the cTokens have the exact same interest rate borrowing and lending curves. Some examples are shown below. | cToken | Interest Rate Model Contract | | ------ | ------------------------------------------ | | cUSDC | 0xD8EC56013EA119E7181d231E5048f90fBbe753c0 | | cDAI | 0xFB564da37B41b2F6B6EDcc3e56FbF523bD9F2012 | | cETH | 0xF9583618169920c544Ec89795a346F487cB5a227 | In contrast, Sonne is using the same interest rate model contract for many different tokens. The results for all soTokens are shown below. The interest rate model curve for WETH and OP is the same as the interest rate model for the stablecoins that aim to maintain a peg to USD. | soToken | Interest Rate Model Contract | | -------- | ------------------------------------------ | | soWETH | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soDAI | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soUSDC | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soUSDT | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soOP | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soSUSD | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soLUSD | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soWBTC | 0x3F6fB832279AC7db0B4F92b79cBB8Df03702631e | | sowstETH | 0x3F6fB832279AC7db0B4F92b79cBB8Df03702631e | | soSNX | 0x7320bD5fA56F8a7Ea959a425F0C0b8cAc56F741E | One of the side effects of the Sonne interest rate model choices is that the rate curve is less steep for tokens with more volatile prices. In order to minimize the risk of bad debt, there should be incentives to avoid excessive borrowing of risky assets. Specifically, WETH and OP are using the same interest rate model curve as stablecoins that should remain pegged to USD. Using a curve with less slope for volatile assets means that borrowing that asset is less expensive, and making it cheaper to borrow volatile assets increases the risk of bad debt accumulating. The table below compares Compound cToken parameters to Sonne soTokens. | Token | multiplierPerSecond | jumpMultiplierPerSecond | baseRatePerSecond | | ------ | ------------------- | ----------------------- | ----------------- | | cUSDC | 1585489599 | 34563673262 | 0 | | soUSDC | 1981861998 | 43283866057 | 0 | | cETH | 7134703196 | 1553779807204 | 634195839 | | soWETH | 1981861998 | 43283866057 | 0 | | cwBTC | 7134703196 | 31709791983 | 634195839 | | sowBTC | 8918378995 | 39637239979 | 634195839 | Not surprisingly, the largest discrepancy is in WETH, because as mentioned above, soWETH is using the same slope parameters as stablecoins. The soWETH multiplierPerSecond slope is 27.7% of the slope value that Compound uses, and the jumpMultiplierPerSecond slope is only 2.8% of the value chosen by Compound. Or for a different comparison, the cWETH slope after the kink is 218 times the slope before the kink. For soWETH, the slope only increases 22 times after the kink. This means that the Compound Finance market is providing a strong disincentive to borrow beyond the kink for the WETH market than Sonne, most likely to reduce the risk of bad debt. If Compound v2 had a market for OP tokens, the same result would almost certainly exist because soOP is using the same interest rate model as stablecoins, just like soWETH. Finally, while it is true that _setInterestRateModel() in the cToken contract can be used to set a new interest rate model contract, the admin that is able to trigger this change is the Timelock Controller at 0x37ff10390f22fabdc2137e428a6e6965960d60b6, which means that a minimum 48 hour delay must take place before the change can be implemented. 
7. Sonne interest rate model math error Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The only non-stablecoin asset in Sonne that is found in Compound Finance with an interest rate model that is almost the same is WBTC. However, Sonne does not properly imitate the WBTC curve from Compound Finance. Consider these example values for a utilization value of 80%. cash: 20000000000000 borrows: 80000000000000 reserves: 0 reserveMantissa: 200000000000000000 Entering these values into getBorrowRate and getSupplyRate in etherscan for intrest rate contract defined in cWBTC, the resulting values are 95129375951 and 60882800608 respectively. After multiplying this rate-per-block by the blocks-per-year value of 2628000, we find the borrow rate is 25% and the supply rate is 16%. Meanwhile, entering these values into etherscan for soWBTC returns 7768899035 for getBorrowRate and 4972095382 for getSupplyRate. After multiplying this rate-per-second by the seconds-per-year value of 31536000, we find the borrow rate is 24.5% and the supply rate is 15.7%. This error may be partially caused by the baseRatePerBlock value chosen for soWBTC. The Compound value for baseRatePerBlock is 9512937595 and the soWBTC value is 9512937595 / 15 = 634195839. However, a soWBTC value assuming 12 second blocks instead of 15 second blocks may improve alignment to Compound Finance's cWBTC curve. Be aware that the Compound UI is inaccurate for the cWBTC curve as detailed in this open issue for the Compound Finance frontend. When hovering over the 80% utilization in the Compound Finance UI, the UI suggests a borrow rate of 24.5% and a supply rate of 18.13%. Therefore, the UI curves do not match the on-chain cWBTC deployment. Additionally, Sonne uses the same value for constant borrowRateMaxMantissa as Compound but in the comment it is stated that borrow rate value is applied per block. This means that the value should be 12 times lower on Optimism. Another Compound fork on Optimism, Hundred Finance, uses the correct value 0.00004e16. 
8. No Borrow Caps set Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: In November 2022, a widely publicized CRV short selling event aimed at liquidating certain Aave borrowers. Compound Finance took action after this event and made significant changes to their borrow cap approach (1, 2). The result is that Compound Finance has a borrow cap set on every market except for USDC, DAI, and USDT. The borrow caps that are set on markets are set to values that are less than the assets supplied. This means that even though the interest rate curve for borrowing could work up to 100% supplied assets, the borrow cap keeps the maximum amount that can be borrowed significantly lower. Aave also has non-zero borrow caps, although Aave v3 on mainnet Ethereum has higher borrow caps for many assets relative to the amount deposited. Although the explanation in the proposal for reducing the borrow caps was "insolvency risk from liquidation cascades" and "risk of high utilization", setting proper borrow cap values may also provide some protection in cases like the Venus protocol LUNA fallout (Venus is a Compound fork), because a borrow cap below the value of assets deposited to the protocol would prevent all the assets from the protocol from being borrowed if a Chainlink oracle failed. 
9. Reserves stored in Sonne adds currency risk Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: When comparing Sonne and Compound Finance on-chain data, it is obvious that there is a large difference in the amount of reserves stored in each protocol. In Compound's cUSDC market, the value of totalReserves is over $13 million. These tokens are owned and stored by the cUSDC contract. In comparison, the Sonne soUSDC market has a totalReserves value of under $1000. The reason that soUSDC has such a low totalReserves value is because the reserves are periodically withdrawn by the admin in transactions such as 0xed3ee0eb900779a6c82d474fc12697bb6cc55372960c775a22c42e4931a7d922. The value flow of the reserves in Sonne is as follows: Reserve tokens accumulate in soToken market contract Reserve tokens are withdrawn by EOA admin EOA admin swaps reserve tokens for USDC using Velodrome pool (potentially has 2% slippage) EOA admin swaps USDC for SONNE tokens (potentially 2% slippage, plus the market price is moved because the USDC/Sonne pool has low liquidity) EOA deposits SONNE tokens into sSONNE, where it sits in the sSONNE contract and collect Velodrome rewards At a minimum, storing the value of the reserves tokens in SONNE introduces currency risk. If bad debt accumulates in a token that is not correlated or pegged to SONNE token value, there is a risk that the value of the reserves could drop in USD terms while the bad debt amount increases in USD terms, making it impossible for the Sonne multisig or admins to pay off the debt. For a specific example, if Sonne collects $1000 in bad debt denominated in USDC and has $5000 of reserves value that was converted to SONNE, then if the SONNE token drops in price more than 80% compared to when the USDC was converted to SONNE, the protocol will not have enough reserves to pay off the bad debt. It is generally a good practice for DAOs or protocols to diversify their treasury holdings. If Sonne holds the original underlying assets instead of converting these assets to Sonne, it demonstrates that Sonne holds real value uncorrelated to the SONNE token. The current approach converts these underlying into SONNE with the goal of propping up the SONNE token price by funding the Velodrome USDC/SONNE market, but it reduces the actual value owned by SONNE in non-SONNE tokens. A secondary risk that is introduced with the swapping of reserve funds is the total losses due to the swaps. Sonne may be losing 5% of total reserve value by swapping the underlying reserve tokens into SONNE because the default slippage on Velodrome is 2%. Two swaps in Velodrome means around 4% of value can be lost, and as highlighted in a separate low findings, the SONNE/USDC market has low liquidity and large swaps can move the market price. If SONNE tokens need to converted back to other tokens to pay off debt, then the overall losses due to slippage could be 7% or higher. This means that the reserves collected by the protocol over time does not match the actual value that could pay off bad debt. 
10. No Chainlink staleness check in _getLatestPrice() Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The Chainlink latestRoundData() function returns price data along with the roundId and timestamp of the data. If the data is stale, it should be discarded. Otherwise the protocol will trust outdated data that could lead to a loss of value from using an inaccurate exchange rate. Chainlink docs recommend to check the roundId and timestamp values that the oracle returns, as shown in other security report findings here and here. 
11. User can accidentally postpone staking release time Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: If burn() is called with amount zero, no state variable changes should be made. Moving all state variable changes inside the if statement will make sure that less gas is spent on the zero amount case, and will also prevent a user from accidentally postponing their release time. function burn(uint256 amount) public { if (amount > 0) { _burn(msg.sender, amount); Withdrawal storage withdrawal_ = withdrawal[msg.sender]; withdrawal_.amount = withdrawal_.amount + amount; withdrawal_.releaseTime = block.timestamp + withdrawalPendingTime; } } 
12. Small SONNE/USDC liquidity leaves potential for large price shifts Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Let us examine a specific example of the price change before and after this tx involving the EOA that performs swaps of the Sonne staking rewards. Approximately $14500 of USDC was swapped for SONNE. Check the price of SONNE in the pool before the swap (block 94817489) cast call 0xc899c4d73ed8df2ead1543ab915888b0bf7d57a2 "getAmountOut(uint256,address)(uint256)" "10000000000000000000" "0x1DB2466d9F5e10D7090E7152B68d62703a2245F0" --block 94817489 --rpc-url OPTIMISM_RPC 1 SONNE = 1516372 USDC Check the price of SONNE in the pool after the swap (block 94817490) cast call 0xc899c4d73ed8df2ead1543ab915888b0bf7d57a2 "getAmountOut(uint256,address)(uint256)" "10000000000000000000" "0x1DB2466d9F5e10D7090E7152B68d62703a2245F0" --block 94817490 --rpc-url OPTIMISM_RPC 1 SONNE = 1561887 USD Calculate the price change from this swap (1561887 - 1516372) / 1561887 ~ 3% This price impact is even displayed in the Velodrome UI when it exceeds a certain threshold. 
13. Incorrect totalSupply in Comp for on-chain voting Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Excluding the 18 decimals of the SONNE token, 100 million SONNE are minted when the token is deployed. Contrast this to only 10 million COMP total supply value. The values can be queried with etherscan: COMP totalSupply: https://etherscan.io/token/0xc00e94cb662c3520282e6f5717214004a7f26888#readContract#F14 SONNE totalSupply: https://optimistic.etherscan.io/address/0x1DB2466d9F5e10D7090E7152B68d62703a2245F0#readContract#F6 The 10 million total supply value is hardcoded in Comp.sol and was not updated to the 100 million value that should be used in Sonne. This means that on-chain voting could be problematic if Sonne uses Comp.sol for this reason. The Sonne.sol contract clearly shows a total supply of 100 million Sonne. 
14. SUSD and LUSD Chainlink price feeds are not standardized verified feeds Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The lowest risk and highest quality tier for Chainlink oracles are verified feeds. Monitored Chainlink feeds are the second highest quality tier of oracles, but they carry additional risk and are still under review. Because a common weakness for Compound forks is oracle manipulation leading to the draining of many markets, the Sonne protocol is only as robust as its weakest oracle. Using Chainlink oracles that introduce extra risk is problematic. Screenshots of the Chainlink documentation at the time of the review is below. Chainlink documentation about data feed quality The LUSD data feed is a monitored feed The SUSD data feed is a monitored feed 
15. Functions calls to uninitialized address Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Because the address is not initialized, the attacker could deploy a harmful contract with the same function calls but with harmful logic. Also, function calls should be done using a contract interface. 
16. High default slippage may lose value Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The velodrome frontend has an unusually high 2% slippage setting. The slippage in AMMs like Uniswap is automatically set in a dynamic way. Based on conversations with the development team, the default slippage has been used in the past. While Optimism is not at risk of MEV right now, a high slippage tolerance can still lose value if the token weights in the Velodrome pool do not favor the direction of the swap. 
17. Remove SafeMath import Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Solidity 0.8.0 introduced a breaking change to implement overflow and underflow protection. The original code from Tarot Finance was using solidity 0.6.6 which did not have this feature. This means the SafeMath imports can be removed to save gas on deployment for Distributor.sol. 
18. Cache variable Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Obtaining the length of an array consumes gas, so storing this value in a temporary memory variable when the value is needed more than once saves gas, like in claimAll(). 
19. Replace totalShares and shares[] Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Etherscan shows that the totalShares and totalSupply values for uSONNE and sSONNE are the same. Reasoning about the totalShares math in _editRecipientInternal() reaches the conclusion that these values should remain the same. _editRecipientInternal() increases totalShares when uSONNE or sSONNE is minted, decreases totalShares when uSONNE or sSONNE is burned, and doesn't modify totalShares when uSONNE or sSONNE is transferred between non-zero addresses. The same applies to shares[]. In fact, because _editRecipientInternal() is always called with shares_ set to balanceOf(account), the shares[] mapping is duplicating exactly what _balances[] already stores. The only reason that Tarot Finance has a totalShares state variable and stores the shares count in recipient.shares (the equivalent of shares[]) in its Distributor contract (the inspiration for Sonne's Distributor) is because the Tarot Finance contract is not an ERC20 and does not have a totalSupply variable or _balances mapping. 
20. Remove duplicate line of code Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: This line of claimInternal() can be removed because updateCredit() performs the same check and updateCredit() is called in the 2nd line of claimInternal(). 
21. Consistently apply unchecked for gas savings Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: This line of sub() and this line of div() can be unchecked. This would follow the approach applied in trySub() and tryDiv() in the OZ SafeMath library for solidity 0.8.X and the approach in add() and mul() of the Sonne SafeMath library. 
22. Use Solidity errors in 0.8.4+ Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Require statements are found throughout the protocol, but especially in Comptroller.sol, CToken.sol, and ExternalRewardDistributor.sol. Replacing require with solidity errors can provide gas savings. 
23. Borrow gas optimizations from Compound Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: notifyBorrowIndexInternal() and notifyBorrowIndexInternal() can benefit from gas optimizations by: caching state variable storage values retrieved more than once removing duplicate > or < checks The specific differences compared to Compound are: notifyBorrowIndexInternal() checks if blockNumber > marketState.borrowBlock and then performs the math blockNumber - marketState.borrowBlock with SafeMath. The subtraction can be unchecked to save gas, or the logic from Compound where the subtraction is performed before the if statement can be used. Two state variable values are queried twice, marketState.supplyBlock and marketState.supplySpeed. These values can be cached to save gas in the case where they are queried twice. Compound only caches supplySpeed because the supply block is queried only once because of the previous optimization (subtracting the values before the if statement). 
24. Initialize variable only if needed Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Variable marketBorrowIndex is initialized before the if statement but it’s only used inside the second if block. 
25. Undocumented market creation process Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: One of the top causes of Compound fork hacks is reentrancy bugs, because Compound does not follow the checks-effects-interaction pattern. This means that if a Sonne market is created with a token that allows reentrancy, such as an ERC777 token, this can put the protocol funds at risk. Compound has a clear process for adding new markets that includes creating a public governance proposal. Compound is aware of this risk but has chosen not to fix it in their code. 
26. Replace magic numbers with constants Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Distribution.sol uses magic number 2**160 in several places. Consider replacing these magic numbers with a constant internal variable. This will not change gas consumption. 
27. Remove unused code Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Distribution.sol has commented code that is not used, L105 and L116. Removing it will improve readability. 
28. Add events to Distributor.sol Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Add events for changing the list of rewards tokens tokens. One for each of the functions addToken() and removeToken() in the file Distribution.sol. 
29. Add event to setWithdrawalPendingTime() and burn() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: It can be helpful to add events for any action that modifies state variables to make it easier to trace when the value change happened and to add monitoring of such changes more easily. 
30. Remove unused files Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Removing unused files will improve readability. 
31. Outsourcing staking yield generation increases risk Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Sonne heavily relies on Velodrome for the Sonne staking protocol. Unlike some other staking protocols, Sonne does not directly provide rewards to stakers but instead outsources the reward generation to Velodrome. Relying on a protocol that does not have an active bug bounty program, has not gotten an audit from a high quality firm, is forked from Solidly which had several known bugs, and has a top 30 TVL introduces risk to the funds that Sonne users stake. Because Velodrome is likely one of the highest TVL protocols without an active bug bounty program, they likely are a target for bad actors while they do not have much incentive for white hat hackers to look at their code. 
32. Use consistent naming for internal functions Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: _editRecipientInternal() and claimInternal() are defined in Distributor.sol. Consider renaming claimInternal() to _claimInternal() for consistency to avoid confusion about the context of certain functions. 
33. Remove redundant import Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Distributor.sol imports SafeToken.sol and StakedDistributor.sol also imports SafeToken.sol. The SafeToken.sol import in StakedDistributor.sol can be removed because StakedDistributor.sol already imports Distributor.sol. 
34. Missing NatSpec Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: NatSpec is a good way to explain your code to other developers modifying or forking a project, to users who want to understand what the contracts are doing, and to auditors who are trying to determine whether the contract logic is implemented properly. The contracts of staking-protocol have a severe lack of detailed NatSpec comments which makes it harder to understand the developer's intentions. 
35. Simplify claimInternal() arguments Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: claimInternal() takes two function arguments of type address. But this function is an internal function, and the only two places where it is called (1, 2) set the account argument to msg.sender. This means claimInternal() does not require this argument because account can be replaced with msg.sender. 
36. Document the end of rewards accumulation when burn() is called Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Every SONNE depositor into uSONNE or sSONNE must leave their tokens in the contract for one week without reward accumulation. This is not documented in the Sonne staking docs, but should be. Otherwise if the documentation does not properly describe this behavior, users may not expect the code to be implemented in the way that it is. 
37. Distributor function removeToken() can lose funds Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Removing reward token from the list of reward tokens will result in locked reward tokens which cannot be collected by users or contract owner. 
38. Unnecessary code from Compound Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Compound proposal 65 is related to fixing a past issue that Compound had related to distributing rewards early. Sonne does not need to fix such an issue and therefore this function is unnecessary outside of Compound. liquidateBorrowVerify() is also unnecessary. Remove the functions without purpose or implement if needed: sizeVerify(), transferVerify(), mintVerify(), borrowVerify(), repayBorrowVerify(), liquidateBorrowVerify(). Also, remove errors that are not used: TransferTooMuch and LiquidateRepayBorrowFreshFailed. 
39. Make public functions external Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Declare these public functions as external because they do not need to be called internally: getSupplyRate() in JumpRateModelV4.sol isOwner() in Ownable.sol 
40. Use standard implementation approach in SafeMath.sol Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There are two functions for each SafeMath operation. One of the functions supports an arbitrary error message by providing a function argument for this message. The other function has a hardcoded error message. The way that sub() and div() are implemented is by having the hardcoded error message implementation calling the arbitrary error message implementation with a hardcoded error string. But add() and mul() are not implemented in this way. Instead, add() and mul() reimplement the function with the arbitrary error message but replace the function argument with a hardcoded string. Consider using the same approach from sub() and div() in add() and mul() to avoid reimplementing the same logic. 
41. Incorrect price oracle address in Sonne docs Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Sonne docs show the price oracle address is 0xEFc0495DA3E48c5A55F73706b249FD49d711A502. But the Comptroller oracle state variable has the value of 0x8d0db2bd9111e35554b8152e172451c80dff22b7. The older Sonne price oracle does not contain data for tokens soWBTC, soLUSD, and sowstETH. 
42. No comparison against minAnswer or maxAnswer Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The Chainlink data is verified to be greater than zero, but a stricter check would use the aggregator minAnswer and maxAnswer values. Chainlink documents this approach in their docs. Many tokens, like USDC or USDT, have a minAnswer value equivalent of $0.01. 
43. _getLatestPrice() timeStamp return value never used Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: _getLatestPrice() is an internal function with two return values, uPrice and timeStamp. timeStamp is not used when this internal function is called so it can be removed. 
44. Protocol will stop working after year 2106 Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: getBlockNumber() is safecast to uint32 in Comptroller.sol (1, 2) and will revert in the year 2016 when block.timestamp is too large for this type. 
45. Typos Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: compAccued() in BasicLens should be compAccrued(). Also consider modifying the function and variable names that include the word block because the Sonne implementation of all of these functions and variables uses seconds, not blocks. getBlockNumber() -> getBlockTimestamp() blocksPerYear -> secondsPerYear multiplierPerBlock -> multiplierPerSecond jumpMultiplierPerBlock -> jumpMultiplierPerSecond baseRatePerBlock -> baseRatePerSecond 
46. Use interface instead of call function Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Calling the contract using an interface is more secure than using call function. File ExternalRewardDistributor.sol contains the interface for ExternalRewardDistributor contract. Change call function defined at L1458, L1590, L1639, L1700 and L1792. 
47. SNX token risk Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: SNX had a double entrypoint issue that was found in Balancer. The issue was originally reported for mainnet but the same bug was applicable on Optimism. Even after this fix, the mainnet SNX code and the Optimism SNX code are different. The SNX token on mainnet and Optimism is using a form of proxy, and the implementation on Optimism has assembly code that differs from the OpenZeppelin implementation. The code of this token is out of scope of the Sonne audit, but risks to Sonne can be introduced by supporting markets for tokens that have added risks. 
48. Solidity version 0.8.20 Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: New opcode PUSH0 is introduced in Solidity version 0.8.20 which may not be supported on a chain other than mainnet like L2 chains. 
