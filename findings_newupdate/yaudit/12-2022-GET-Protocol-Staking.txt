1. Double voting using cross-chain voting Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The process a staker would take to double vote with their assets is: Vote on the first chain (can be Ethereum mainnet or Polygon) Take the 15% instant withdrawal fee Bridge assets Restake GET to receive xGET Vote again on the second chain The end result is 85% more votes than should be possible from the original asset value There is even more complexity involved in cross-chain voting. Some other cases to consider are: The argument could be made that no user would want to lose 15% of their assets to get extra votes. This would depend on the bribe market and other factors, but there is also a way for the user to recapture some of their "lost" 15%. If a user has X amount of assets staked in the vault, 10% of the total amount could be used for this cross-chain double voting while the other 90% of the assets reclaim some of the "lost" 15% because the 15% fee is distributed among the stakers in the vault. To take this to the next level, a user who knows they will be performing an instant withdrawal can borrow GET at a certain interest rate, stake it, take the 15% instant withdrawal fee hit, and later withdraw the borrowed GET potentially at a profit before returning it to the borrower. Some modeling or linear programming is necessary to determine exactly when recapturing the 15% fee is profitable, especially in the scenario involving borrowed GET, which will not be examined further here. If a snapshot of user assets at a specific block is used to determine votes held by each address, the question is how to synchronize this point in time across chains. It is unlikely such a process would be exact, given that mining a block is not an instant process. If there is a different in snapshot times between Ethereum mainnet and Polygon, it may enable time for assets to be bridged across chains to enable this double voting. The exact plans around how this would work were not outlined in the smart contract and are not in scope of this review, but should be considered. 
2. Withdraw and cancel requests can be frontrun for profit Severity: High Difficulty: n/a Type: n/a Target: n/a Description: In the following test example, Alice deposits funds, profits are scheduled, and Alice makes a withdrawal request while funds are being streamed. Right before the executeWithdrawalRequest() is triggered by Alice, Bob deposits funds, and he will be able to get the profits immediately. Because Alice executeWithdrawalRequest() is triggered right after the deposit, the leftover profits from the duration of the lockTime are distributed to everyone, including Bob, immediately through the burn of shares. In the test, we compare the shares with Eve's shares. Eve deposited right after Alice's withdrawal. They are very different from the amount of Bob shares's. The share amount is very different because the price per share has dramatically increased. function testFrontRunWithdraw() public { address eve = address(0x0E5E); // first Alice deposit _setUpDepositor(alice, 1 ether); // We add some profit asset.mint(address(vault), 1 ether); vault.updateVestingSchedule(); vm.warp(block.timestamp + 2 days); // Alice starts a withdrawal request vault.createWithdrawalRequest(1 ether); // we increase time to reach the end of the lock vm.warp(block.timestamp + 26 weeks); // Bob deposit _setUpDepositor(bob, 1 ether); vm.stopPrank(); // Alice execute the withdraw vm.startPrank(alice); vault.executeWithdrawalRequest(0); // Eve deposit vm.stopPrank(); _setUpDepositor(eve, 1 ether); vm.stopPrank(); assertApproxEqRel(vault.balanceOf(eve), vault.balanceOf(bob), 10e6); } function convertToAssets(uint256 shares_) public view virtual override returns (uint256 assets_) { uint256 supply = totalSupply; // Cache to stack. assets_ = supply == 0 ? shares_ : (shares_ * totalAssets()) / supply; } 
3. Vault may be susceptible to donation attack Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The first user to call deposit() on the GovernanceLockedRevenueDistributionToken.sol contract is issued the same quantity of shares as the underlying assets they provide. A user can abuse this to deposit a single quantity of assets in return for one share, setting the supply to 1. This same user could then send a large donation of underlying assets to the vault through a direct transfer and call the updateVestingSchedule() function to begin increasing the totalAssets() value. The ability to call updateVestingSchedule() after a donation is a requisite for this attack due to the totalAssets() value relying on the issuanceRate. The required capital for a successful donation attack will diminish over the course of a 14 day period. The below POC can be added to Compound.t.sol to show the donation amount needed to round another depositor's share issuance to 0 after 1 day has passed between deposits: function testDonationAttack() public { // after set up, allow alice to withdraw all but a dust amount from the vault // we warp ahead in time to avoid withdrawal penalties to ensure the vault is left with only dust vm.startPrank(alice); uint256 allButDust = 1 ether - 1; vault.createWithdrawalRequest((allButDust)); uint256 afterWithdrawalPenalties = start + 26 weeks; vm.warp(afterWithdrawalPenalties); // execute the withdrawal request vault.executeWithdrawalRequest(0); vm.stopPrank(); // print out the shares that would be minted from 1 ether console.log("1 ether deposit before donation attack yields _%s_ shares.", vault.previewDeposit(1 ether)); // provide bob with starting capital asset.mint(bob, 14 ether + 1); // bob performs the donation. With a 1 day wait, it will require 14 times the capital of the other user to issue 0 shares // this is because the vesting schedule follows a linear issuance mechanism over the course of 14 days vm.startPrank(bob); asset.transfer(address(vault), 14 ether + 1); // call the update vesting schedule and wait 1 day for issuance rate to increase vault.updateVestingSchedule(); vm.warp(afterWithdrawalPenalties + (1 days)); // demonstrate that a user who wishes to deposit 1 ether will now be minted 0 shares console.log("1 ether deposit after donation attack yields _%s_ shares.", vault.previewDeposit(1 ether)); } 
4. Redistribute event emits incorrect value and could underflow Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: Within the executeWithdrawalRequest() function, a user's withdrawal request is processed, shares are transferred from the vault to the user, and the equivalent number of the user's shares are burned. When this internal _burn() function is called, the issuanceRate, totalAssets(), and supply values change. The Redistribute event is then emitted and the value it calculates in its convertToAssets() call is significantly impacted by these changes. Adding the following POC to InstantWithdrawal.t.sol demonstrates that the skewed value can even prevent the last share(s) from being withdrawn from the vault due to an arithmetic underflow: function testExecuteWithdrawalRedistributeUnderflow() public { // Alice deposits 1 ether of underlying asset to the vault // Bob deposits 2 ether of underlying asset to the vault _setUpDepositor(alice, 1 ether); _setUpDepositor(bob, 2 ether); // Allow bob to redeem early as seen in the instantWithdrawalFeeSharing test // This leaves positive yield in the vault for alice vault.redeem(vault.balanceOf(bob), bob, bob); uint256 bobFee_ = _instantWithdrawalFee(2 ether); // == 0.3 ether assertEq(asset.balanceOf(bob), 2 ether - bobFee_); vm.stopPrank(); // Attempt to withdraw our balance as alice // This will throw an arithmetic underflow due to the incorrect calculation in // The Redistribute event vm.startPrank(alice); vault.createWithdrawalRequest(vault.balanceOf(alice)); vault.executeWithdrawalRequest(0); vm.stopPrank(); } 
5. Incorrect _burn function in cancelWithdrawalRequest() Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The standard ERC20 _burn() function with two function arguments exists in the contracts inherited from the ERC20 contract, but RevenueDistributionToken has a _burn() function with five function arguments. The latter is what is normally called in LockedRevenueDistributionToken (1, 2, 3) except for in cancelWithdrawalRequest(). The purpose of line 137 is to burn any excess shares beyond what is returned to the staker cancelling their withdrawal request, because in this case the staker will receive the same value of shares (priced in underlying assets) as when they deposited, but this may be a lesser number of shares than they submitted a withdrawal request for. Phrased another way, the accrued value that the shares gained while the contract held the shares is returned to the vault to be shared among shareholders. When the value in the vault has changed, the value of each share should change by updating freeAssets and issuanceRate. But freeAssets and issuanceRate are not updated when _burn() with two function arguments is called. So after cancelWithdrawalRequest() is called, freeAssets and issuanceRate may not be accurate. Specifically, freeAssets could be overinflated by convertToAssets(burnShares_). And if the _burn happens after vestingPeriodFinish, the issuanceRate will not be updated to zero, meaning the return value of totalAssets() would not be accurate. 
6. updateVestingSchedule() may not be called on time Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: There are two closely related issues here: updateVestingSchedule() can be called any time within 24 hours of vestingPeriodFinish. The optimal strategy for calling updateVestingSchedule() from the perspective of a staker who will withdraw from the vault if the yield is any lower is to 1. call updateVestingSchedule() as soon as possible if issuanceRate will increase from its current value (the rate of rewards distribution increases) or 2. delay calling updateVestingSchedule() until vestingPeriodFinish if issuanceRate will decrease. The issue here is that by delaying the updateVestingSchedule() call, the function may not be called until after vestingPeriodFinish. It may be even further delayed if gas is very high and the staker(s) running bots to automatically call the function determine that the "lost yield" from the time where issuanceRate is zero is less than the gas cost of calling vestingPeriodFinish. This is possible because the staker(s) running bots may not have a large number of vault shares. issuanceRate can only be changed in updateVestingSchedule() except when block.timestamp > vestingPeriodFinish. When block.timestamp > vestingPeriodFinish, issuanceRate can be set to zero when the _burn() or _mint() RevenueDistributionToken functions are called. This could be done accidentally, with a normal user wishing to stake into the vault who unknowingly sets issuanceRate to zero while staking their GET. Even if issuanceRate is non-zero, rewards will not be distributed after vestingPeriodFinish due to the math in totalAssets(). Any time that vestingPeriodFinish is less than the current block.timestamp is a zero yield scenario for stakers. In short, an issuanceRate of zero is not good for stakers, but there is a question of who will call updateVestingSchedule() and when they will call it. Competing incentives and a lack of integration with a keeper system like Gelato may result in non-ideal scenarios for all stakers. 
7. External call made to non-existent permit function Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The mintWithPermit() and depositWithPermit() functions are intended to allow users to transfer assets to the vault in a single transaction. To achieve this, these functions call permit on the underlying asset with a user's signature that was gathered off-chain. However, the vault's underlying asset is intended to be GET which does not contain a permit function on Ethereum or Polygon. 
8. Vault lacks slippage protection Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: When an EOA user wants to participate in staking with the vault, they can check what the current exchange rate of their GET and/or xGET will be using functions such as previewDeposit(). Since they are an EOA, they must then wait for this transaction to be mined for it to return results before they can post a new transaction acting on this information. There is no guarantee that the previously returned exchange rate will be the same and in fact it could be drastically different. There are numerous reasons a price change may occur, such as from exploitative front-run attempts, reward distributions, or even the ratio completely resetting if all of the shares have been removed from the vault. ERC-4626 alludes to this issue in its security considerations, and many other protocols in the ecosystem that offer swaps and exchanges have slippage protection mechanisms for their users. 
9. Unsafe casting Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: OpenZeppelin uses SafeCast in functions like numCheckpoints(), getCurrentVotes(), and getPriorVotes() to prevent overflows due to casting. GovernanceLockedRevenueDistributionToken.sol has similar implementations of numCheckpoints(), getCurrentVotes(), and getPriorVotes() but without SafeCast. The SafeCast library protects against overflows when casting from a large int value to a small int value, and GovernanceLockedRevenueDistributionToken.sol doesn't have any casting overflow protection in the existing contract. A comparison of the numCheckpoints() implementation is compared below. function numCheckpoints(address account_) public view virtual override returns (uint32 numCheckpoints_) { - numCheckpoints_ = uint32(userCheckpoints[account_].length); // this is the GovernanceLockedRevenueDistributionToken.sol implementation + numCheckpoints_ = SafeCast.toUint32(_checkpoints[account].length); // this is how OpenZeppelin implements the casting } 
10. previewWithdrawalRequest() may return incorrect user's request Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Regardless of what value for owner_ is passed to the previewWithdrawalRequest(), the withdrawal request is gathered based on the msg.sender. The owner_ value is then used to determine if this request should be fee exempt or not. This incorrectly associates the withdrawal request and any corresponding fee exemptions. Adding the following POC to InstantWithdrawal.t.sol demonstrates the issue: function testIncorrectPreviewWithdrawal() public { // Exempt bob from fees vault.setWithdrawalFeeExemption(bob, true); // Create a deposit and withdrawal request for 2 ether for Bob // This should be fee exempt _setUpDepositor(bob, 2 ether); vault.createWithdrawalRequest(vault.balanceOf(bob)); // Create a deposit and withdrawal request for 1 ether for Alice // This should not be fee exempt // Note that the current prank is now using alice's context _setUpDepositor(alice, 1 ether); vault.createWithdrawalRequest(vault.balanceOf(alice)); // Bob should have no withdrawal fees and a balance of 2 ether // so we would expect this to return 2 ether. Instead it returns 1 ether // which is a combination of Alice's withdrawal request and bob's fee exemption (, uint256 bobWithdrawAmount, uint256 bobFee) = vault.previewWithdrawalRequest(0, bob); console.log("Amount to withdraw: %s", bobWithdrawAmount); } 
11. Withdrawal requests incentivized if issuanceRate is zero Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: When a withdrawal request is created, the contract takes and holds the staker's shares until the withdrawal is executed or canceled. The staker receives no interest or yield while the contract holds the shares. But if the interest or yield is zero, stakers are incentivized to submit a withdrawal request because there are no rewards to miss out on when the contract holds the shares, which happens when issuanceRate is zero. 
12. Lack of issuance rate synchronization across chains may lead to uneven voting rewards Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Voting power is denominated in the underlying assets (GET) as opposed to the vault's shares (xGET) to better facilitate voting across chains. This way, stakers on a vault with a lower share to underlying asset exchange rate are not necessarily penalized (as far as voting is concerned). This does not necessarily hold true for reward distribution. Rewards are granted through a vesting schedule whereby an issuanceRate is calculated to issue rewards linearly throughout the vesting period. Since rewards are issued in GET, higher issuanceRate vaults may reward their stakers with more voting power. 
13. Incorrect value getVotes(address account) Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The function is changed from standard one to include additional votes that will be available after the next action from the user. Only after the user write action a new checkpoint is stored for him, with a new vote value. 
14. Lack of input sanitization in the constructor function Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The variables instantWithdrawalFee and lockTime are not checked to be valid in the constructor. constructor( string memory name_, string memory symbol_, address owner_, address asset_, uint256 precision_, uint256 instantWithdrawalFee_, uint256 lockTime_ ) RevenueDistributionToken(name_, symbol_, owner_, asset_, precision_) { instantWithdrawalFee = instantWithdrawalFee_; lockTime = lockTime_; } LockedRevenueDistributionToken.sol#L55-L56 
15. Add require statement in updateVestingSchedule Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The function updateVestingSchedule allows anyone to update the vesting schedule even if the issuanceRate_ is zero. 
16. Avoid && logic in require statements Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: One instance of require with && logic was found. 
17. Use Solidity errors in 0.8.4+ Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Require statements are used in the strategy and error messages are not used anywhere. Using this new solidity feature can provide gas savings on revert conditions. 
18. Use unchecked if no underflow risk Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: There is at least one location where unchecked can be applied + unchecked { return high_ == 0 ? 0 : (isVotes_ ? _unsafeAccess(ckpts, high_ - 1).votes : _unsafeAccess(ckpts, high_ - 1).shares); + } There is another example of a subtraction operation that can use unchecked for gas savings in LockedRevenueDistributionToken. if (withdrawalFeeExemptions[owner_] || request_.unlockedAt 
19. Make DELEGATE_TYPEHASH private Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: DELEGATE_TYPEHASH is a private constant in the OpenZeppelin contract that the GET contract is based on. This variable is public in the GET GovernanceLockedRevenueDistributionToken.sol contract. Note this has been applied to PERMIT_TYPEHASH already, which is public in OpenZeppelin but private in GET. 
20. Duplicate zero check Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: _mint() is always called with the argument shares_ = previewDeposit(assets_) or with assets_ = previewMint(shares_). previewDeposit() rounds down while previewMint() rounds up. This means if assets_ is zero, shares_ will be zero, but it is possible for shares_ to be zero when assets_ is non-zero. Therefore the weaker check of assets_ can be removed. The same change can be made to _burn(). 
21. Duplicate balance check Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: createWithdrawalRequest() checks if msg.sender has sufficient shares balance, but the ERC20 transfer a few lines later effectively does the same check, because this subtraction would revert if msg.sender has insufficient shares balance. 
22. Make variables immutable Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The asset state variable in the constructor of RevenueDistributionToken can be declared immutable. In addition, ERC20.sol symbol and name aren't changed after the contract is initialized so they can be immutable. 
23. Make functions external Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: getPastTotalSupply() is never called in GovernanceLockedRevenueDistributionToken and can be external instead of public. The change could be applied to delegate() too. 
24. Make variables uint32 Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: instantWithdrawalFee and lockTime have hard coded maximum values of 100 and MAXIMUM_LOCK_TIME (or 62899200) respectively. These variables are of uint256 type but can be defined as uint32. The same approach can be taken with the constant values MAXIMUM_LOCK_TIME, VESTING_PERIOD, and WITHDRAWAL_WINDOW in the same contract. 
25. Transfer isn't necessary before calling _burn() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Burn can be performed without the transfer: - _transfer(address(this), msg.sender, request_.shares); - _burn(request_.shares, assets_, msg.sender, msg.sender, msg.sender); + _burn(request_.shares, assets_, msg.sender, address(this), address(this)); LockedRevenueDistributionToken.sol#L159 
26. Unnecessary nonReentrant protection Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The following functions have an unnecessary non-reentrant check: RevenueDistributionToken.sol#L99 RevenueDistributionToken.sol#111 RevenueDistributionToken.sol#L117 RevenueDistributionToken.sol#L130 RevenueDistributionToken.sol#L138 RevenueDistributionToken.sol#L142 LockedRevenueDistributionToken.sol#L110 LockedRevenueDistributionToken.sol#L127 LockedRevenueDistributionToken.sol#L152 LockedRevenueDistributionToken.sol#L205 
27. Replace != with > Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: In updateVestingSchedule, instead of using != in L181 > can be used for minor gas savings. - require(totalSupply != 0, "LRDT:UVS:ZERO_SUPPLY"); + require(totalSupply > 0, "LRDT:UVS:ZERO_SUPPLY"); 
28. Emit memory variables in events instead of storage Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: In following functions, memory variables can be emitted in events instead of global. setInstantWithdrawalFee - emit InstantWithdrawalFeeChanged(instantWithdrawalFee); + emit InstantWithdrawalFeeChanged(percentage_); setLockTime - emit LockTimeChanged(lockTime); + emit LockTimeChanged(lockTime_); 
29. Usage of booleans for storage incurs overhead Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: In the LockedRevenueDistributionToken.sol file, the withdrawalFeeExemptions mapping maps user address with a boolean flag to indicate fee exemption, which could cost some additional gas. In solidity, booleans (bool) are a bit expensive to use in comparison to other data types because each bool value is stored in a single byte. This means that each bool value requires at least one gas unit to be read or written. In comparison, other data types like uint (unsigned integer) can be stored in much less space, allowing for more efficient use of gas. It's generally more efficient to use other data types, like uint, whenever possible. Read more here: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 
30. Redundant imports can be removed Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: GovernanceLockedRevenueDistributionToken.sol imports ERC20.sol. But the ERC20.sol import already exists in LockedRevenueDistributionToken.sol and in RevenueDistributionToken.sol. The ERC20.sol import can be removed from GovernanceLockedRevenueDistributionToken.sol and from LockedRevenueDistributionToken.sol because it will be included from RevenueDistributionToken.sol. 
31. Clarify order of operations Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The Math library is based on OpenZeppelin's Math library. The OpenZeppelin library has parenthesis on these lines but the GET Math library doesn't have these. No issue is expected here, but clarifying the order of operations can make the code easier for readers to understand and make upgrades to future version of solidity less problematic in case the compiler has changes made to the order of operations. 
32. Operational order during minting could be improved Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: When a user makes a deposit call in the RevenueDistributionToken.sol contract, the underlying _mint() function with 4 parameters is called. Inside of this function, the user is given their shares before they officially transfer in the underlying asset to the vault. If reentrancy were to occur in a before token transfer hook during this transferFrom call, the vault would have issued shares without receiving assets in return at that point in time. Reordering these operations may make it possible to remove the nonReentrant modifiers on functions that call _mint(). 
33. Abandoned withdrawal shares are irretrievable Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: After createWithdrawalRequest() is called, the contract takes possession of the user's shares. But the contract has no way of redeeming these shares that it holds, and there is no time limit for shares to be considered "abandoned" or "forfeited" if left in the contract. This may be similar to a user transferring their shares to an inaccessible random address, except: The contract holding the shares is the ERC4626 vault contract itself The ERC4626 vault cannot do anything with these shares The user can retrieve these shares if the want, unlike sending them to an irretrievable address 
34. Shares escrowed for withdrawal can't vote Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The GET Locked Revenue Distribution token contracts hold shares that are waiting to be withdrawn, but these shares are not able to be used for voting because the contract never delegates these shares. Because there is no quorum, this is unlikely to result in altering the outcome of a vote directly, but it would make it easier to potentially swing a vote because the shares held in escrow during the withdrawal process will not vote. 
35. Improve function and variable names Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: createWithdrawalRequest() takes a function argument of shares and returns a value in units of assets, but the standard ERC4626 withdraw() does the opposite by taking assets as a function argument and returning a value in units of shares. Instead, the function might be better named createRedeemRequest() if it is going to take a function argument of shares to match the ERC4626 redeem() function. totalAssets_ found in previewRedeem() and previewWithdraw() doesn't related to the return value of totalAssets(). It might be better named preFeeAssets_ or assetsPlusFee_. The Checkpoint array function argument is named ckpts, but this is the same name as the state variable ckpts. Consider removing this function argument if the same state variable will always be accessed when _unsafeAccess() is called. 
36. Use actual GET token contract for tests Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Since the GET token is the ERC20 token that the tests care about, consider using the GET contract code directly. The tests can use a fork of mainnet to use the on-chain contract, or the relevant contract code could be imported. If testing on a fork, consider testing on mainnet and Polygon, the two places where these contracts are planned to be deployed. 
37. Documentation nitpicks Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The Governance section makes no mention of this crucial nuance in the governance logic - that the staker must "delegate to themselves in order to activate checkpoints and have their voting power tracked". The list of state variables that can be controlled by governance votes is either incomplete or omits variables that can be changed by the owner outside of governance votes. Specifically, setPendingOwner() and updateVestingSchedule() are not in the list. 
38. Conversion calculations not protected from shadow overflow Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: In an expression such as uint256 D = A * B / C, Solidity will attempt to store the intermediary result of A * B before it performs the division by C. If this overflows, then the transaction will revert. The muldiv technique was created to prevent the possibility of an intermediary overflow on calculations that perform both multiplication and division. 
39. Inaccurate comment Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: updateVestingSchedule() has a misleading comment description and a typo that misspelled "Identical" as "Intentical". 
40. Mainnet deposit delay incentivized due to bridging delay Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The GET token contract on Ethereum is where GET can be minted, but there is a GET contract on Polygon that is properly mapped and registered with Polygon. The GET token is bridged using the Polygon PoS Bridge, which Polygon docs describe as having a delay of 20 minutes to 3 hours. When GET is bridged across by the bridging contract, stakers will be able to see that rewards are going to arrive soon to the xGET contract on mainnet. The prospective stakers may delay the start of their staking for the amount of time it takes for the assets to bridge and earn yield elsewhere during that time. 
41. Influence of blockchain data on xGET rewards Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Because GET tickets are NFTs, the sales of those tickets are visible in real-time. The sales of the tickets may provide insight into the future yield that could be earned by stakers. This is not a security concern per se, but may influence the decision making of stakers to stake sooner or later based on this information and depending on how rewards are transmitted to the contract. 
42. Partial comments Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The function is defined in GovernanceLockedRevenueDistributionToken: https://github.com/GETProtocolDAO/locked-revenue-distribution-token/blob/ab272ced94d6bc8cc1ded2664408a3fa7ce67128/src/GovernanceLockedRevenueDistributionToken.sol#L300. 
43. issuanceRate_ is scaled up Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: issuanceRate_ is scaled up using precision. 
44. Use named constants instead of magic numbers Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 100 in the following instances should use a constant variable instead: LockedRevenueDistributionToken.sol#L68 LockedRevenueDistributionToken.sol#L265 LockedRevenueDistributionToken.sol#L292 LockedRevenueDistributionToken.sol#L135 
45. Silence compiler warning for unused variables Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: If any function param is not used, do not declare that param with a name in functions maxDeposit, maxMint. For e.g., - function maxDeposit(address receiver_) + function maxDeposit(address) 
46. Use the latest Solidity version with a stable pragma Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Using a stable pragma ensures that the contract will continue to function as intended even if there are breaking changes in future versions of Solidity. By using a stable pragma, the contract will be locked to a specific version of Solidity, which can help to prevent unexpected behavior or errors if the contract is compiled with a newer version of the compiler. Also consider using the latest version of Solidity since it will include the most up-to-date features, enhancements, and bug fixes, which can help to make the contract more efficient and secure. 
47. Delete doesn't reduce the size of the array Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: delete userWithdrawalRequests[msg.sender][pos_]; LockedRevenueDistributionToken.sol#L131 (LockedRevenueDistributionToken.sol#L157)[https://github.com/GETProtocolDAO/locked-revenue-distribution-token/blob/ab272ced94d6bc8cc1ded2664408a3fa7ce67128/src/LockedRevenueDistributionToken.sol#L157] 
