1. Incorrect order of operations in LibCompound.sol Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The problematic computations are for the variables interestAccumulated and the return value. interestAccumulated calculation from transmissions11/libcompound repo: uint256 interestAccumulated = (borrowRateMantissa * (block.number - accrualBlockNumberPrior)).mulWadDown( borrowsPrior ); interestAccumulated calculation from local LibCompound.sol contract: uint256 interestAccumulated = borrowRateMantissa * block.number - accrualBlockNumberPrior.mulWadDown(borrowsPrior); Made up example values: borrowRateMantissa = 1000000000 block.number = 15460000 accrualBlockNumberPrior = 15459990 borrowsPrior = 500000000000000000000000 interestAccumulated result from transmissions11/libcompound: 5000000000000000 interestAccumulated result from local LibCompound.sol: 15452270005000000 Return value calculation from transmissions11/libcompound repo: (totalCash + totalBorrows - totalReserves).divWadDown(totalSupply); Return value calculation from local LibCompound.sol contract: totalCash + totalBorrows - totalReserves.divWadDown(totalSupply); Example values loosely taken from cDAI: totalCash = 400000000000000000000000000 totalBorrows = 300000000000000000000000000 totalReserves = 20000000000000000000000000 totalSupply = 3100000000000000000 Return value result from transmissions11/libcompound: 219354838709677419354838709 Return value result from local LibCompound.sol: 693548387096774193548387097 
2. User can set arbitrary approveMaxIfNeeded() target Severity: High Difficulty: n/a Type: n/a Target: n/a Description: This finding is not a complete attack chain, but the missing link of the chain depends on a hypothetical weakness in an external contract, which is out of scope of this review. In order for value to be stolen from Swapper.sol, a malicious actor would: Create a malicious contract that is approved by Swapper.sol for ERC20 tokens that pass through Swapper.sol, which enables it to transferFrom() those tokens Use an external call from Swapper.sol to call the malicious contract while Swapper.sol holds value to take that value before it can be sent to the user calling the contract The first step is possible because the input argument to approveMaxIfNeeded() in Swapper.sol code is a user-specified argument. Not only that, but in a function such as _swapXpytToUnderlying(), the args.gate parameter approved for args.xPYT here is only used for one function call, exitToUnderlying(). This function could be implemented in a malicious contract as an empty function and the rest of the _swapXpytToUnderlying() function would still succeed, allowing the args.gate user-specific argument to be set to an address under the malicious user's control. Even worse, this exitToUnderlying() could be where the transferFrom() call happens, so if an innocent user specifies this value for the args.gate value (either due to a mistake, a Timeless frontend hack, or any other means), the value would be transferred to the malicious gate contract and the innocent user would lose the value that was going to be sent to them. It is not even necessary for the user to provide a malicious value for args.gate for this to become a problem. Multiple external calls exist within the functions of Swapper.sol, and if any of these are insecure or have an external call to an insecure contract, loss of value can occur even if the user's transaction has the proper function argument values set. 
3. Lack of slippage protection in Curve swaps Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The exchange() call in _swap() in CurveV2xPYT.sol sets a minimum output token quantity of zero. This means the swap will happen regardless of how imbalanced the pool is. The only check that is applied to the quantity of tokens received is validating the amount is greater than minXpytAmountOut. The value of minXpytAmountOut does not help with slippage and is not user customizable, it only helps avoid a case where a very small (near zero) amount of of xPYT is returned. This is in contrast to where pool.exchange() is used in _swapFromUnderlying() in the swapper repository. There is a check of tokenAmountOut < args.minAmountOut in Swapper.sol to check the return value of pool.exchange(). Whether the args.minAmountOut value will be calculated properly in the user interface is outside the scope of this review, but at least users have the option to specify a slippage tolerance. Similarly, the output of the swapAmountOut return value from _swapFromYieldToken() is compared against args.minAmountOut in Swapper.sol. 
4. Accrued rewards may not be returned to depositors Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The claimRewards() function is an external function without access controls, so anyone can call it. When it is called, the liquidity mining incentive rewards accrued to the aTokens held by the ERC4626 vault are sent to the address rewardRecipient. The rewardRecipient address may be a previously audited contract that is out of scope of this review, but because it is not in the scope of this review, it is not clear whether users will receive rewards claimed from this function. 
5. Bypass to add cEtherAddress to underlyingToCToken array Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The CompoundERC4626Factory.sol constructor has an if statement that prevents cEtherAddress from getting added to the underlyingToCToken array. The updateUnderlyingToCToken() function has a for loop very similar to the constructor, but the if statement check is missing. Because updateUnderlyingToCToken() has no access controls, anyone can use updateUnderlyingToCToken() to add the cEtherAddress to the array. This will cause problems because the CompoundERC4626.sol code assumes ERC20 tokens when using imported SafeTransferLib functions and does not use safeTransferETH() for the case where ETH is the underlying asset. 
6. Improper wrapEthInput() call can cause value loss Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: If a user calls wrapEthInput() as a separate transaction, ether will be converted to WETH and deposited to the Swapper.sol address. Even if the user intends to call swapUnderlyingToXpyt() or swapUnderlyingToNyt() in their next transaction, the user can be frontrun. Whoever calls swapUnderlyingToXpyt() or swapUnderlyingToNyt() while Swapper.sol holds value can extract that value because those functions use args.underlying.balanceOf(address(this)) for the value of tokenAmountIn (here and here). 
7. ERC20 tokens sitting in contracts can be extracted Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The Swapper.sol contract uses the code args.TOKEN.balanceOf(address(this)) in several places. The value of args.xPYT, args.pyt, or args.nyt can be any address, which means any token balance stored by the contract can be queried, and soon after extracted, with this code. The contract is not designed to store value, but if it does store value (say if a user accidentally sends tokens directly to the contract), the value could be extracted in a backrun transaction. A similar scenario exists with Uniswap's V2 router, which is not designed to store any token balances but it does have non-zero token balances as seen on etherscan. Separately, sweep() in xPYT.sol is described with Uses the extra asset balance of the xPYT contract to mint shares. This can remove any extra assets of token asset that sits in the xPYT.sol contract. While less generalize than the Sweeper.sol contract, a more specific case of the same issue exists. 
8. Difficult to use withdraw() with full deposit Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Aave allows users to submit the value type(uint256).max to withdraw the user's full balance. No similar feature is present in the Yield Daddy ERC4626 vault. This makes it hard to use withdraw() while specifying the correct value of assets to remove all aTokens from the vault because the aTokens are rebasing and increasing over time. In contrast, the redeem() function allows a user a specify the number of shares they want to withdraw. Shares are not always rebasing and are easier for a user to specify an accurate number for a complete withdrawal. 
9. Inaccurate function return values Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The maxDeposit() and maxMint() functions only return the value type(uint256).max when the underlying pool can accept a deposit or mint. The value type(uint256).max does not accurately represent the maximum value that can be deposited into the vault when some ERC4626 tokens have already been minted. This is because the vault normally can mint a maximum of type(uint256).max, otherwise the totalSupply state variable will overflow and cause a revert, so the existing token supply should be subtracted. The same is true for aTokens, which should have the existing supply excluded. EIP4626 defines this requirement for maxMint(): MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). The output of maxDeposit() cannot be passed into withdraw() without a revert, which does not satisfy this ERC4626 requirement. A more accurate return value for maxDeposit() in Aave V2 and Aave V3 is: return type(uint256).max - aToken.totalSupply(); The totalSupply value limitation of the ERC4626 vault can be ignored because the totalSupply of the vault will always be less than or equal to aToken.totalSupply(), so the aToken totalSupply is the limiting factor. The same issue is relevant for maxMint(), but the return value of maxMint() should be in units of shares instead of assets because the ERC4626 mint() function takes a shares value as input. The more accurate return value for maxMint() in Aave V2 and Aave V3 is therefore: return convertToShares(type(uint256).max - aToken.totalSupply()); This issue is present in the Compound ERC4626 wrapper as well. A similar solution should be applied. 
10. No fee-on-transfer token support Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Fee-on-transfer tokens have the property where the value that is sent is not the same as the value that is received. This difference in logic compared to standard ERC20 tokens requires special handling in solidity to avoid a revert or loss of value. No fee-on-transfer ERC20 appears to exist on the supported lending platforms at the time of the review, but if one is added in the future or if the fee is enabled on an existing token that supports fee-on-transfer, the ERC4626 wrappers for protocols that require two separate transfers for depositing and withdrawing (Euler, Compound, Aave only for depositing) would not function with fee-on-transfer tokens because the deposit or withdraw process would revert because the fee is not accounted for in between the two transfers. The swapper repo also lacks fee-on-transfer support. This is because the tokenAmountIn value used in the safeTransferFrom() call is assumed to equal the value held by the Swapper.sol contract after the transfer takes place. This will revert when args.gate.enterWithUnderlying() is called because the underlying.safeTransferFrom() call in Gate.sol's enterWithUnderlying() will not have sufficient balance to transfer. 
11. Curve's price_oracle() may provide less effective sandwiching protection post-merge Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: In the upcoming Merge of the Ethereum mainnet, block proposers and validators are assigned randomly 2 epochs in advance. This enables an attacker with a sufficient amount of capital to fully manipulate the contents of two or more blocks in a row, undermining previous the security assumption that arbitrageurs could disrupt a multi-block oracle manipulation attack. This risk is compounded by price oracles that put more weight on recent observations, such as Curve's EMA oracle. 
12. Insufficient SwapArgs input validation Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: There is no validation in _swapUnderlyingToNyt() that confirms that the addresses of args.underlying, args.nyt, args.pyt, args.xPYT, and args.vault are all related to the same underlying asset. Similarly, the value args.gate may not hold the address of the actual Gate.sol contract in the timeless protocol, but instead may be the address of an attacker's contract. An external call is made to args.gate in _swapUnderlyingToNyt() and _swapUnderlyingToXpyt(), and although the external functions swapUnderlyingToNyt() and swapUnderlyingToXpyt() have the nonReentrant modifier, there is no global reentrancy lock across the Timeless protocol(s), so the risk of a hack involving reentrancy is not zero. 
13. Curve Swap design may generate unexpected NYT/PYT dust Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: According to the documentation, CurveV2Swapper's swapNytToUnderlying() and swapXpytToUnderlying() functions are intended to be used in conjunction with CurveV2Juggler.juggleXpytInput() and CurveV2Juggler.juggleNytInput() respectively. These two juggle function are intended to operate as off-chain oracles which are used to calculate the correct quantities of NYT/PYT tokens to be swapped. The goal of the swap is for the user to end up with a nominally equivalent number of NYT+PYT tokens for a vault, which are then redeemed in equal amounts for xPYT tokens, which is then redeemed for the underlying vault's token. The decoupling of the off-chain price oracle with the on-chain swap introduces a chance that the swap is executed at a different price that the price oracle expected. If a swap is executed at a different price than the oracle predicted, then the user will have differing quantities of NYT and PYT, and will have some amount of dust remaining after they redeem their NYT+PYT for xPYT. 
14. xPYT deployment lacks trust mechanism Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Often the CREATE2 opcode is used to deploy contracts that depend on underlying parameters, because the address of the contract can be derived from those underlying parameters. This is the approach used in deployYieldTokenPair() of Factory.sol to deploy new NYT/PYT pairs and by Uniswap V2 to deploy new pairs. But because multiple xPYT tokens can exist for a single underlying vault, perhaps CREATE2 cannot be used in this case. There is no state variable in CurveV2xPYTFactory.sol that stores the address of deployed xPYT contracts, which means that functions that accept a xPYT address as a function argument, including several functions in Swapper.sol that have a SwapArgs.xPYT function argument, cannot determine whether the xPYT address is a legitimate xPYT token or a malicious contract. This is unlikely to impact most users who use a web interface in their browser, but it may open up an attack vector of a malicious contract posing as a legitimate xPYT token. 
15. Missing PYT/NYT lookup mechanism Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The PerpetualYieldToken.sol and NegativeYieldToken.sol contracts contain many external calls to the gate contract, notably the gate.beforePerpetualYieldTokenTransfer() call in PYT's transfer() and transferFrom() functions and the gate-protected gateMint() and gateBurn() in BaseERC20.sol. If the gate is malicious, it could leverage these callbacks for a variety of attack vectors. 
16. Replace require blocks with errors Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Instances of require that can be replace with custom errors are found in: AaveV2 AaveV3 xPYT 
17. Declare variables internal, immutable, or constant when possible Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Many public immutable variables exist in the Euler, Aave V2, Aave V3, and Compound wrappers. If possible, make these internal instead of public for gas savings. There is one variable in xPYT.sol, assetBalance, that can be made private because it already has a public getter function in the form of totalAssets(). A variable in CurveV2xPYT.sol, curvePool, can be made immutable because it is only changed once, in the initializer. 
18. Remove beforeWithdraw() calls Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: withdraw() and redeem() call beforeWithdraw(), but beforeWithdraw() is never implemented with code. beforeWithdraw() is declared in ERC4626.sol as an empty virtual function. The calls to beforeWithdraw() can be removed because it doesn't run any code. 
19. Replace duplicate code with internal function Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The code below is found in two places in AaveV2ERC4626.sol (here and here): // check if pool is paused if (lendingPool.paused()) { return 0; } // check if asset is paused uint256 configData = lendingPool.getReserveData(address(asset)).configuration.data; if (!_getActive(configData)) { return 0; } This code could be moved into an internal view function to reduce contract deployment costs. The same could be done with the similar duplicate code block (here and here). The Aave V3 wrapper has duplicate code in the same functions of maxDeposit(), maxMint(), maxWithdraw(), and maxRedeem(). 
20. Declare functions external for gas savings Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: There is a public function updateUnderlyingToCToken() in CompoundERC4626Factory.sol that can be made external. 
21. Use claimComp() with borrowers = false Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: claimComp() is called in claimRewards(). It can be replaced with a call to the other claimComp() function with borrowers set to false. 
22. Use unchecked if no underflow risk Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: There are two subtraction operations (here and here) that should not underflow because the supplyCap should be greater than the value of totalSupply(). The Aave V3 code should be checked to confirm that there is a valid comparison to supplyCap when the supply increases. Another subtraction operation can be made unchecked in CurveV2Juggler.sol (and the out of scope UniswapV3Juggler.sol contract), found here and here. This operation can be unchecked because tokenAmountIn >= (tokenAmountIn >> 1), and because swapAmountIn = (tokenAmountIn >> 1), then tokenAmountIn >= swapAmountIn and tokenAmountIn - swapAmountIn >= 0. Swapper.sol has two operations repeated four times that can be unchecked to save gas. A similar operation that already is unchecked is found in xPYT.sol. Division here, here, here, and here can be unchecked because (protocolFeeInfo_.fee / 10000) < 1 so it cannot overflow. uint256 feeAmount = (tokenAmountIn * protocolFeeInfo_.fee) / 10000; Subtraction here, here, here, and here can be unchecked because feeAmount < tokenAmountIn so it cannot underflow. tokenAmountIn -= feeAmount; 
23. Function arg should be calldata not memory Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The Compound factory contract has a memory argument that can be changed to calldata for gas savings. The same change can be made for _deployCurvePool() in CurveV2xPYTFactory.sol. 
24. Move revert earlier in function Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: This revert check in the xPYT constructor can take place earlier in the constructor because it only relies on a function argument and does not rely on any other calculations. Move this if statement to immediately follow the other if statement revert check. 
25. Internal function is cheaper than modifier Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: This onlyOwner modifier could be replaced with a require check in this function or an internal function. For example, add this line to ownerSetProtocolFee() to replace the modifier on the function. require(msg.sender == owner, "UNAUTHORIZED"); 
26. Zero check could save gas Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: getClaimableYieldAmount() is called once in xPYT.sol, but this function is missing a zero check for yieldAmount. The first function that calculates the claimable yield, claimYieldAndEnter(), confirms that yieldAmount != 0. The other locations where the claimable yield is calculated, getClaimableYieldAmount, does not confirm that yieldAmount != 0. This zero check could provide a gas savings in the case that yieldAmount is zero. 
27. Remove unnecessary approve Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: This approve() call is designed to initialize the storage slot to a non-zero value in order to save gas on future changes of this slot. The problem is that the approve() call that happens before each swap overwrites the initial allowance value, which is subsequently consumed by the Curve swap and re-set to zero. 
28. Unnecessary logic in approveMaxIfNeeded() function Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The contracts that call approveMaxIfNeeded() include Swapper.sol and CurveV2Swapper.sol. No other approve() or safeApprove() calls happen in these contracts, so the only allowance being set is an allowance of type(uint256).max. If the allowance is set to type(int256).max, USDT will not decrease the allowance when a transfer happens. So the process of checking the allowance and setting it to zero if the value is not type(int256).max is unnecessary and can be replaced with a simple token.safeApprove(spender, type(uint256).max); call. There might be an edge case other than USDT that the approveMaxIfNeeded() was designed for, but the function should not be necessary for USDT or standard ERC20 tokens. 
29. Direct transfer of aTokens impacts share value Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: function totalAssets() public view virtual override returns (uint256) { // aTokens use rebasing to accrue interest, so the total assets is just the aToken balance return aToken.balanceOf(address(this)); } The totalAssets() function in AaveV2ERC4626.sol and AaveV3ERC4626.sol is an important function. It is called in the calculations of convertToShares(), convertToAssets(), previewMint(), and previewWithdraw(). It is possible for anyone to transfer Aave aTokens directly to the vault, which would change the value returned by totalAssets(). Although such an increase in value happens normally as deposits take place or yield is earned, an instantaneous change may impact how other protocols interface with Yield Daddy ERC4626 tokens depending on how the other protocols are implemented. This comment is absent from the Compound ERC4626 wrapper, but the same edge case of a user sending tokens directly to the vault can apply. 
30. aAMPL edge cases Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: AMPL is a rebasing token, but unlike Aave aTokens, AMPL can increase or decrease the balance that user's hold. This website shows some recent rebasing activity in both the positive and negative directions. The ability to rebalance in either direction means that a user depositing into the Yield Daddy aAMPL vault may receive less tokens when withdrawing than when they deposited. If there are very few depositors in the aAMPL vault, a user with a large fraction of vault ownership may be able to take advantage of the timing of the AMPL rebasing (which happens once per day) at the cost of the other vault shareholders. 
31. Invert constant mask variables Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Modify the constant masks in the Aave V3 wrapper to the following: - uint256 internal constant DECIMALS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; + uint256 internal constant DECIMALS_MASK = 0xFF << 48; - uint256 internal constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; + uint256 internal constant ACTIVE_MASK = 1 << 56; - uint256 internal constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; + uint256 internal constant FROZEN_MASK = 1 << 57; - uint256 internal constant PAUSED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; + uint256 internal constant PAUSED_MASK = 1 << 60; - uint256 internal constant SUPPLY_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; + uint256 internal constant PAUSED_MASK = 0xFFFFFFFFF << 116; Remember to remove the negation where the variables are used, so ~DECIMALS_MASK will become DECIMALS_MASK. 
32. Simplify logic in maxDeposit() and maxMint() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: maxDeposit() and maxMint() have logic which can be simplified: - if (!(_getActive(configData) && !_getFrozen(configData) && !_getPaused(configData))) { + if (!_getActive(configData) || _getFrozen(configData) || _getPaused(configData)) { 
33. Add parentheses to avoid order of operations ambiguity Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: These three functions have boolean logic that relies on order of operations. If this changes in a future solidity version, an incorrect value may be calculated. Applying parentheses would remove any ambiguity and make it easier to upgrade to future solidity releases with reduced concerns. function _getActive(uint256 configData) internal pure returns (bool) { - return configData & ~ACTIVE_MASK != 0; + return (configData & ~ACTIVE_MASK) != 0; } function _getFrozen(uint256 configData) internal pure returns (bool) { - return configData & ~FROZEN_MASK != 0; + return (configData & ~FROZEN_MASK) != 0; } function _getPaused(uint256 configData) internal pure returns (bool) { - return configData & ~PAUSED_MASK != 0; + return (configData & ~PAUSED_MASK) != 0; } 
34. Inconsistent ERC4626 callback usage Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The default withdraw() and redeem() function implementations are overridden in AaveV2ERC4626.sol, possibly to save gas from one ERC20 token transfer. The same approach could be used for deposit() and mint() by having the user send their reserve asset directly to Aave with an onBehalfOf value in the deposit() call of the Yield Daddy vault. This may require the user to approval the Aave pool, but it would improve consistency in the Yield Daddy code. 
35. Some hard coded variables might be better adjustable Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The rewardRecipient is an address that receives accrued rewards from the ERC4626 vault. This address cannot be changed in the existing AaveV2ERC4626.sol contract. Scenarios may arise where this value needs to be changed, but the contract does not currently allow this to happen. 
36. Unclear upgrade mechanism Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The Yield Daddy contracts have no clear upgrade mechanism even though some hard coded values might need changing in the future. Some examples of upgrade use cases include: If extra features are planned for a future Yield Daddy vault version, there is no clear path for migrating the aTokens from the existing vault. The Yield Daddy vaults do not have a mechanism to borrow from Aave using the aTokens the vault holds. Borrowing with some amount of this collateral could allow Yield Daddy to increase the yield generated and improve the value proposition to users. Introducing such a mechanism in the future would require the vault to approve the aTokens to another address or borrowing directly from Aave, and neither option is available with the contract logic. Aave had a referral program in the past which is now inactive, and a governance proposal could theoretically bring the program back. Even though this scenario is unlikely, if it were to happen the Aave deposit() call in Yield Daddy has a hard coded value of 0 for the referral code, so no referral rewards could be collected if the reward program is resumed by Aave. 
37. General lack of documentation and comments Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: To give one example of some unclear code that should have comments, the maxRedeem() function checks how much of the reserve asset is held by the aToken address. It may not be obvious to all readers that the reason that an external protocol is queried before returning a result for Yield Daddy users is to cover the edge case where the Aave pool is undercollateralized (which is common due to Aave's lending feature) and the Yield Daddy withdrawal would be larger than the entire Aave aToken reserve balance. A comment in the code or developer docs explaining this reasoning could expedite understanding for developers interfacing with this protocol or future code reviewers. Another place where NetSpec comments would help is clarifying that the return value of maxWithdraw() is in units of shares while the return value of maxRedeem() is in units of the underlying asset. 
38. Typos Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The Aave V2 factory contract has a comment accidentally copied from Aave V3. This should be modified to reference Aave V2. This comment about burn the xPYT should be removed or changed. It was erroneously copied from a similar function that does burn xPYT. The same applieds to this other comment in the same function. 
39. Aave LendingPool getConfiguration() can replace getReserveData() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: getReserveData() returns many pieces of data in Aave V2 and Aave V3. The only data needed in the wrapper contracts can be received from getConfiguration(), which returns less data in Aave V2 and Aave V3. This efficiency boost won't save gas because it is used in a view function. 
40. Redundant dependency imports Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The ERC4626 factory contracts have the same redundant import of two solmate files. For example, Aave V3 imports ERC4626Factory.sol and two solmate files. But the imported base factory contract has the solmate files imported, making the import of these files redundant. StETHERC4626.sol has a similar instance of this where StETHERC4626.sol imports "solmate/tokens/ERC20.sol" and "./external/IStETH.sol", but "solmate/tokens/ERC20.sol" is already imported by IStETH.sol making the separate import unnecessary. CurveV2Swapper.sol has a similar instance of this where CurveV2Swapper.sol imports "../Swapper.sol" and "../lib/ApproveMaxIfNeeded.sol", but "../lib/ApproveMaxIfNeeded.sol" is already imported by Swapper.sol. The same applies to the solmate and timeless imports in CurveV2Swapper.sol. 
41. Interface doesn't match mainnet contract Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: This is the Compound code defining the mintGuardianPaused mapping as mapping(address => bool) public mintGuardianPaused. The interface for this mapping is defined as function mintGuardianPaused(ICERC20 cToken) external view returns (bool). This is problematic because the address type is not equal to the ICERC20 type. A foundry test was created to test if this type mismatch caused a revert, but the test passed without a revert. However, the custom maxMint() and maxDeposit() functions are not tested with existing tests for Compound or Aave V3. 
42. Consider upgrade to latest solidity release Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The release notes of solidity releases since 0.8.13 describe code generation bugfixes and gas optimizations that have been introduced in the more recent releases. It would be best to use the latest release unless there is a good reason to continue using 0.8.13. 
43. Theoretical overflow of convertToShares() and convertToAssets() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Below is the custom convertToShares() function from StETHERC4626.sol: function convertToShares(uint256 assets) public view virtual override returns (uint256) { uint256 supply = stETH().totalSupply(); return supply == 0 ? assets : assets.mulDivDown(stETH().getTotalShares(), supply); } If the value of the assets input parameter or the value of stETH().getTotalShares() is very close to type(uint256).max at the same time that supply is a very small value, this function could revert during the mulDivDown library call. The same is true of the convertToShares() function in the standard solmate implementation. The convertToAssets() function suffers from the same side effect in this extreme case. 
44. No zero address checks in constructor Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The xPYT.sol constructor sets three state variables to specific external contract addresses. No zero address check is performed, making it possible that one of these state variables could be set to the zero address. 
45. Modify Gate.sol claimYieldAndEnter() function argument Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Most locations where xPYT is used, it is cast to an address with address(xPYT). Only once is it used as IxPYT type. Instead, take in a function argument of type address and cast to IxPYT the one time that this type is needed. 
46. CurveV2xPYT utilizes a non-TWAP price oracle Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Curve's price_oracle() implementation uses an exponential moving average for its oracle. EMA oracles have different properties from TWAP oracles, most notable of which is they are more sensitive to high price volatility near the time of query. 
47. Replace magic numbers with constants Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There are many instances of the value 10000. Consider replacing this magic number with a constant internal variable named FEE_BASE. Instances are found here, here, here, and here. 
48. No timelock or other protection around changing fee or fee recipient Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: ownerSetProtocolFee() allows the owner to set the fee percentage and fee recipient. While this function has access control to only allow the owner to call this function, there is no further controls to reduce centralization risk. Whether this is necessary depends on the parties who are intended to receive the fees. If users are intended to receive a fraction of the fees from Swapper.sol, they may want additional guarantees that the fees will not be redirected somewhere else without notice. 
49. safeApprove is deprecated Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: This function is deprecated because it can be used to manipulate a user's allowances using specific transaction ordering. 
50. Swapper repo foundry coverage failing Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: While increasing code coverage does not necessarily reduce the risk of security issues, it is generally a good idea to improve code coverage for projects. Running foundry coverage in the swapper repo returns a CompilerError: Stack too deep when compiling inline assembly: Variable value0 is 1 slot(s) too deep inside the stack. error. This implies that code coverage is not being monitored or improved for the swapper issue. 
51. StETHERC4626.t.sol test failing Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: This issue is caused by the mintUnderlying call on line 188, which mints 1e18+2 of the underlying token for alice. 1e18 of these tokens are deposited to the vault on line 201, leaving behind 2 underlying tokens in alice's account when the following assertion is made on line 205. 
