1. Vault should mint exactly the specified number of shares Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: Shares are minted by first converting the shares argument to assets using the _convert_to_assets() function with the option to round up the calculation. The assets variable is then forwarded to the internal function _deposit(), which takes this amount and recalculates the number of shares in the _issue_shares_for_amount() function. This breaks the compliance with EIP-4626, as the mint() function is expected to mint the receiver the exact number of shares: Mints exactly shares Vault shares to receiver by depositing assets of underlying tokens. 
2. Non-compliance with ERC4626 Withdrawal Standard Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: See: EIP-4626 The methods used in both the v3 vault and the v3 strategy are to convert assets into shares and to burn this number of shares. If any losses occur, the number of assets to be sent back is currently reduced. However, this approach does not align with the ERC4626 protocol. Instead, more shares should be burned to match the requested number of assets. https://github.com/yearn/yearn-vaults-v3/blob/3e51c08d88d2764b39348c98f20e18c51b475722/contracts/VaultV3.vy#L1523 https://github.com/yearn/tokenized-strategy/blob/72a71b16088f1a7821f299aa013d824b3dbb8d4e/src/TokenizedStrategy.sol#L464 
3. set_open_role() might only be used for a single role while putting at risk all the others Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: VaultV3.vy#L1255-L1275 
4. lastReport() function does not return timestamp of last report for all cases Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The implementation of lastReport() returns the value of the last_profit_update storage variable. This timestamp is handled during the call to process_report() but is only updated if shares are burned (line 425) or if there are locked shares after logic is executed (line 1139). 
5. Use a two step process to update the management account Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The implementation of the setManagement() function performs the role transfer in a single step, by directly transferring this key role to the specified account. 
6. Strategy deposit limits should be checked on the receiver account Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The implementation of the deposit() and mint() functions check for deposit limits on the caller (msg.sender) account. The EIP-4626 standard specifies that these limits should be queried for the receiver account. Taking the maxDeposit function as an example, the specification states: Maximum amount of the underlying asset that can be deposited into the Vault for the receiver, through a deposit call. 
7. Strategy may allow to redeem more assets than the available limit Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: In order to calculate the maximum number of shares that can be minted, the implementation of maxRedeem() takes the amount of assets specified by availableWithdrawLimit() and calculates the associated number of shares by using previewWithdraw(), which uses up rounding. The resulting number of shares can then be used in redeem() to withdraw assets according to the calculation of previewRedeem(). This double rounding may, under certain circumstances, result in more assets than the original limit specified by availableWithdrawLimit(). 
8. Inconsistent rounding of losses_user_share Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: losses_user_share: uint256 = assets_needed - assets_needed * strategy_assets / strategy_current_debt The calculation is done with a loss of precision, it should be rounded up instead of down. yearn 
9. Potential fund loss due to missing zero address check Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The lack of a zero address check on the receiver could lead to unintentional loss of funds. If the receiver address were mistakenly set to the zero address, the transferred funds would be irretrievably lost. Given that this function appears to handle fund withdrawal, this could potentially lead to a significant loss. https://github.com/yearn/yearn-vaults-v3/blob/3e51c08d88d2764b39348c98f20e18c51b475722/contracts/VaultV3.vy#L802 
10. Update debt does not check that strategy is active Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The update_debt() function does not check that the given strategy is currently active (i.e. self.strategies[strategy].activation != 0). 
11. Cache storage variable locally to prevent multiple reads from storage Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: VaultV3.vy#L328 VaultV3.vy#L334 VaultV3.vy#L838 VaultV3.vy#L1329 
12. Don't initialize variables with default value Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: VaultV3.vy#L294 
13. Function can be marked external Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: on the TokenizedStrategy.sol contract, several functions can be marked external. TokenizedStrategy.sol#L587 TokenizedStrategy.sol#L599 TokenizedStrategy.sol#L615 TokenizedStrategy.sol#L1355 TokenizedStrategy.sol#L1404 TokenizedStrategy.sol#L1450 TokenizedStrategy.sol#L1482 TokenizedStrategy.sol#L1509 TokenizedStrategy.sol#L1536 
14. Use != 0 instead of > 0 for comparison Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: TokenizedStrategy.sol#L878 TokenizedStrategy.sol#L885 TokenizedStrategy.sol#L897 TokenizedStrategy.sol#L911 TokenizedStrategy.sol#L915 TokenizedStrategy.sol#L925 TokenizedStrategy.sol#L934 TokenizedStrategy.sol#L942 TokenizedStrategy.sol#L1340 
15. Use unchecked for subtractions where the operands cannot underflow Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: TokenizedStrategy.sol#L1065 TokenizedStrategy.sol#L1073 VaultV3.vy#L304 VaultV3.vy#L309 VaultV3.vy#L310 VaultV3.vy#L378 VaultV3.vy#L533 VaultV3.vy#L581 VaultV3.vy#L695 VaultV3.vy#L889 VaultV3.vy#L897 VaultV3.vy#L950 VaultV3.vy#L1025 VaultV3.vy#L1028 VaultV3.vy#L1329 
16. Vyper 0.3.8 introduces transient storage for non-reentrancy checks, leading to notable gas savings Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: yearn vault 
17. Unnecessary return variable declaration Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: BaseTokenizedStrategy.sol 
18. Use constants for literal or magic values Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: TokenizedStrategy.sol#L1302 TokenizedStrategy.sol#L1302 
19. Prefer abi.encodeCall() over abi.encodeWithSignature() or abi.encodeWithSelector() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: BaseTokenizedStrategy.sol#L433 
20. Optional ERC-20 functions Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: VaultV3.vy#L280 TokenizedStrategy.sol#L383 TokenizedStrategy.sol#L1366 
21. Typos in tokenized-strategy repo Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
22. Vyper raw_call() can be replaced with the new vyper default_return syntax Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The existing codebase uses low-level raw_call to handle non-standard ERC20 calls. This can be simplified using the new syntax. 
23. Selector clashing attack in strategies Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The current design of strategies is composed of two contracts, an abstract BaseTokenizedStrategy.sol contract inherited by strategist and a TokenizedStrategy.sol contract that implements the vault's core logic. Communication between the two is done using delegatecall. Similar to the proxy pattern, the main strategy contract uses a fallback() function to delegatecall any non-matching function to the TokenizedStrategy.sol contract. Since function selectors are 4 bytes long, it is feasible to mine a function signature that matches one of the functions in the TokenizedStrategy.sol contract. A bad actor can then hide such a function in the strategy implementation that will be unintentionally called while trying to access the "real" function. Due to the current contract design, this function will be caught by the strategy implementation instead of being delegated to the TokenizedStrategy.sol contract, as function dispatch will happen first in the main strategy contract. 
24. Lack of event logging in tend() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: TokenizedStrategy.sol#L1051 
25. Lack of event logging in emergencyWithdraw() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: TokenizedStrategy.sol#L1122 
