1. Dependency on a single DEX for CRV price Severity: High Difficulty: n/a Type: n/a Target: n/a Description: StrategyConvexFactoryClonable.sol#L430 estimates value of CRV tokens in terms of USDT by routing it through WETH swaps. 
2. Possible revert on creating a vault Severity: High Difficulty: n/a Type: n/a Target: n/a Description: BalancerGlobal.sol#L368-L375: bytes memory data = abi.encodeWithSignature("latestVault(address)", lptoken); (bool success, ) = address(registry).staticcall(data); if (success) { return registry.latestVault(lptoken); } else { return registry.latestVault(lptoken, VaultType.AUTOMATED); } If no vault is registered for DEFAULT, success is false, and since there is no AUTOMATED type vault, the else clause revert. So in this case, it becomes impossible to create a vault for lptoken. 
3. Strategy migrations fail to claim reward/extraReward tokens Severity: High Difficulty: n/a Type: n/a Target: n/a Description: There does not appear to be any mechanism to harvest or re-enable a strategy that has been migrated. This means that any unharvested rewards are effectively lost on migration. The magnitude of this finding depends on the amount of time that has passed since the strategy was last harvested. If the strategy has not been harvested in a week & is migrated, then a week's worth of extra rewards are lost. Given the following assumptions/observations, this finding may have a high impact: Some Curve vaults go unharvested for many weeks at a time. CRV/CVX/Extra rewards tend to make up a large fraction of yield revenue. There is no mechanism to prevent a strategy migration when a strategy has not been harvested in a long period of time. If the magnitude/accuracy of the above assumptions are incorrect, then this finding may have medium or lower severity. 
4. _loss on liquidatePosition() is never accounted in strategy & vault, which can result in funds lost/stuck Severity: High Difficulty: n/a Type: n/a Target: n/a Description: In BaseStrategy.sol, in harvest() we have this code debtOutstanding = vault.report(profit, loss, debtPayment); which reports the loss to the vault, so if it reports a 0 loss when there is one then the whole accounting logic for the strategy will be incorrect which can lead to loss funds or stuck funds in strategy. Also the correctness of the healthcheck in the strategy will not be certain because of the following code in BaseStrategy.sol that uses loss: require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), "!healthcheck"); 
5. Dependence on Curve/Balancer governance Severity: High Difficulty: n/a Type: n/a Target: n/a Description: Things move quick in this space and "Curve wars" bribing adds additional volatility to the situation. With this new automated process for adding pools/strategies, the risk from dependence on external governance processes is amplified. In the event of another governance attack or if a vulnerable token were to enter the system, then malicious actions could be completed more quickly now due to this new permissionless system dependent on approved gauges. 
6. Wrong parameter to cloneStrategyConvex function Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The 3rd parameter in cloneStrategyConvex() is a _rewards address as defined in BalancerGlobal.sol#L83 interface IStrategy { function cloneStrategyConvex( address _vault, address _strategist, address _rewards, address _keeper, uint256 _pid, address _tradeFactory, uint256 _harvestProfitMax, address _booster, address _convexToken ) external returns (address newStrategy); However, the same management address was passed in for both 2nd and 3rd parameters: BalancerGlobal.sol#L479 
7. Strategy migrations will cause inaccurate accounting on first harvest of new strategy Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The impact of this finding is dependent on Yearn's strategy management practices & downstream tooling, so consider this impact analysis "best effort". If the old strategy has not been harvested in a long time, there may be a relatively large amount of unreported gains/losses that have yet to be realized by the old strategy. This may cause data accuracy problems when analyzing the APR performance for the new strategy. Consider the case where: Old strategy was last harvested a week ago. Old strategy is migrated to new strategy. 10 minutes later, the new strategy is harvested. In the above scenario, a week's worth of gains/losses will be realized by the new strategy, and since the new strategy was deployed 10 minutes prior, off-chain tooling/instrumentation might draw inaccurate conclusions about the performance of the new strategy. 
8. Convex's extraRewards array is unbounded Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: StrategyConvexFactoryClonable#_updateRewards has the following for loop: for (uint256 i; i 
9. _loss incorrectly assumed even if rewards can be sold to cover loss Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: In BaseStrategy.sol, in withdraw() the _loss will be returned to the vault. The vault will then report this loss, suggesting the price per share is lower, despite the fact that the strategy could have even been in a profit if rewards were sold. 
10. Setting deposit limit twice Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: BalancerGlobal.sol#L463-L472 v.setDepositLimit(depositLimit) and Vault(vault).setDepositLimit(depositLimit) both set the deposit limit to the same value. The second call is not changing the deposit limit. 
11. External call on each loop iteration Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: StrategyConvexFactoryClonable.sol#L484 for (uint256 i; i 
12. Use of SafeMath for safe arithmetic Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: StrategyConvexFactoryClonable.sol#L343: _profit = assets.sub(debt); StrategyConvexFactoryClonable.sol#L361: _loss = debt.sub(assets); StrategyConvexFactoryClonable.sol#L565: Math.min(_stakedBal, _amountNeeded.sub(_wantBal)), In all these case, SafeMath can be avoided. 
13. Remove unused state variable Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: state variable numVaults in BalancerGlobal contract has been set once in createNewVaultsAndStrategies and have never been used any other function. There is an additional SSTORE operation each time we want to create a new vault. 
14. Use >0 for unsigned integers Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: != 0 is a cheaper operation compared to >0, when dealing with uint. >0 can be replaced with != 0 for gas optimization. The >0 has been used in many places in BalancerGlobal and StrategyConvexFactoryClonable contract such as here and here. 
15. Storage variable numVaults in BalancerGlobal is not needed Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The variable is set only once in numVaults = deployedVaults.length;. There is no need to use a separate storage slot for this value, you can just add a getter method for deployedVaults.length instead Recommendation Add a getter method for deployedVaults.length and remove numVaults storage variable. Developer Response Great. Fix has been taken. 7. Gas - recalculation not needed (datapunk) Proof of concept As marked in the the snippet below, there is no need to recalculate _profit.add(_debtPayment) and _profit In L#345 uint256 toFree = _profit.add(_debtPayment); //freed is math.min(wantBalance, toFree) (uint256 freed, ) = liquidatePosition(toFree); if (_profit.add(_debtPayment) > freed) { // *** if (_debtPayment > freed) { _debtPayment = freed; _profit = 0; } else { _profit = freed - _debtPayment; // *** remove } } Recommendation use toFree in place of _profit.add(_debtPayment) and remove else { ... } 8. Gas - remove tradesEnabled (datapunk) Proof of concept tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations. 
16. recalculation not needed Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: As marked in the the snippet below, there is no need to recalculate _profit.add(_debtPayment) and _profit In L#345 uint256 toFree = _profit.add(_debtPayment); //freed is math.min(wantBalance, toFree) (uint256 freed, ) = liquidatePosition(toFree); if (_profit.add(_debtPayment) > freed) { // *** if (_debtPayment > freed) { _debtPayment = freed; _profit = 0; } else { _profit = freed - _debtPayment; // *** remove } } Recommendation use toFree in place of _profit.add(_debtPayment) and remove else { ... } 8. Gas - remove tradesEnabled (datapunk) Proof of concept tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations. 
17. remove tradesEnabled Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations. 
18. Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations. 
19. Redundant external call when using staticcall Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations. 
20. Upgrade Pragma Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
21. Missing events in BalancerGlobal & StrategyConvexFactoryClonable Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: StrategyConvexFactoryClonable has several occurrences of the safeApprove method calls. This method has been deprecated by OpenZeppelin and its usage is discouraged. 
22. ERC20.safeApprove is deprecated Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: StrategyConvexFactoryClonable has several occurrences of the safeApprove method calls. This method has been deprecated by OpenZeppelin and its usage is discouraged. 
23. incorrect comment Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: L505 comment on turnOffRewards() says it will set the allowance on the router to 0. This doesnt happen in turnOffRewards 
24. hardcoded addresses Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Hard coded addresses in multiple places: StrategyConvexFactoryClonable.sol and BalancerGlobal.sol. 
25. VaultRegistry.latestVault() functions can consume all gas Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: Vault registry is a proxy and 0xc3efbfdb50cf06e8e5bb623af28678d72caeafea is its current implementation. It has 2 latestVault() functions: function latestVault(address _token) external view returns (address) { address[] memory tokenVaults = vaults[_token][VaultType.DEFAULT]; // dev: no vault for token return tokenVaults[tokenVaults.length - 1]; // dev: no vault for token } function latestVault(address _token, VaultType _type) external view returns (address) { address[] memory tokenVaults = vaults[_token][_type]; return tokenVaults[tokenVaults.length - 1]; // dev: no vault for token } Both the functions copy the storage array in memory. 
