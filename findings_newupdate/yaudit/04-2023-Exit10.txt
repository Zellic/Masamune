1. _getPercentFromTarget() called with incorrect argument Severity: High Difficulty: n/a Type: n/a Target: n/a Description: _getPercentFromTarget() calculates a return value that represents a percent value. The calculation can be summarized as (x / bootstrapTargetLiquidity) * 100%. This ratio and the context of this line of coe indicates that x should be the current bootstrap liquidity held by the protocol. The current code does not use the current bootstrap liquidity value and therefore needs modification. 
2. Incorrect value in _safeTokenClaim() Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The ratio of rewards that a user can claim to the total rewards supply should be the same as the ratio of tokens that the user holds to the total token supply. This is how the _safeTokenClaim() logic works in the first step. The second step involves a correction to the rewards that a user can claim if the total claimed rewards exceed the total supply of rewards. This is how the logic should work, but this line of code actually checks if the total claimed rewards exceed the total supply of EXIT, BOOT, or other tokens. The total supply of tokens should not be involved in this calculation, the total supply of rewards should be used. 
3. bootstrapBucket fees are double counted in claimAndDistributeFees() Severity: High Difficulty: n/a Type: n/a Target: n/a Description: To summarize the fee collection logic that is currently implemented in claimAndDistributeFees(), assume: amountCollected0 = 100 bootstrapFees0 = 10 (this implies bootstrap liquidity is 10% of the total Exit10 liquidity) amountCollected0 passed to FeeSplitter.collectFees() = 90 (100 - 10 = 90) The amount of fees passed to FeeSplitter.collectFees() is 90 (this is the amountCollected0 value from the previous calculation). This value is then distributed by the ratio of pending bucket's liquidity over the total liquidity (the sum of liquidity of all buckets), which is 70%. If pendingBucket is 70% of liquidity while remainingBuckets are 30% of liquidity, then assuming the original 100 of fees, pendingBucket should get 70% of fees, in this example, 70 worth of fees. But because only 90 worth of fees is passed in collectFees(), pendingBucket instead gets 70% of 90, 63. The result is that pendingBucket is penalized while the bootstrap bucket gets counted twice and effectively gets double fees. 
4. Reinvested bootstrap fees are counted as fee-earning liquidity immediately Severity: High Difficulty: n/a Type: n/a Target: n/a Description: Exit10.claimAndDistributeFees() collects and distributes the Uniswap LP fees between the different buckets in the Exit10 protocol. This distribution of rewards is calculated using the liquidity share owned by each bucket. The more liquidity that a bucket owns, the more fees that the bucket deserves. But the total Uniswap v3 LP liquidity is increased in this function and the newly added liquidity did not contribute to generating the fees that were just collected. Therefore the value of Exit10._exitBucket() is greater than the Exit bucket liquidity that is responsible for generating the collected fees. This means that the Exit bucket will receive a larger share of fees than it should and other buckets will be penalized. 
5. _depositAndSwap() should set non-zero amountOutMinimum values Severity: High Difficulty: n/a Type: n/a Target: n/a Description: Uniswap v3 docs have this to say about amountOutMinimum: amountOutMinimum: we are setting to zero, but this is a significant risk in production. For a real deployment, this value should be calculated using our SDK or an onchain price oracle - this helps protect against getting an unusually bad price for a trade due to a front running sandwich or another type of price manipulation Exit10 sets a amountOutMinimum value of zero in several places, including in _depositAndSwap() and claimAndDistributeFees(). There is a risk of value loss due to MEV bots when the minimum value is set to zero. 
6. Unconsumed allowance will break fee updates Severity: High Difficulty: n/a Type: n/a Target: n/a Description: When the FeeSplitter is updating the rewards for the masterchef contracts, it first swaps USDC for WETH. This in turn calls swap() in Swapper.sol. This function uses safeApprove to give the Uniswap V3 Router permission to spend all of the USDC the FeeSplitter has given the Swapper. Importantly, the Swapper also creates a price limit and adds this as parameter in its call to the Uniswap V3 Router. The problem in this case combines two related truths: safeApprove requires that the previous allowance be completely spent or that it is called with a 0 value. Under any other circumstance it will revert. There is a non-zero chance that the call to the Uniswap V3 Router will not consume the entire allowance set by the call to safeApprove. Uniswap V3 Router's exactInputSingle function, which is what was called by the Swapper, calls exactInputInternal which itself calls swap directly on the pool with the provided parameters. As mentioned earlier, a price limit was included among these parameters. The swap function in Uniswap V3 then swaps in steps until it either has used the entire amountIn or it hits the price limit specified. If it hits the price limit specified before it hits the amountIn, there will be an unconsumed allowance and all subsequent calls to the Swapper's swap function will fail. 
7. Exit10.sol ignores token order when sending fees to FeeSplitter.sol Severity: High Difficulty: n/a Type: n/a Target: n/a Description: The call to collect() in the Uniswap pool will return collected fees as amount0 and amount1 which corresponds to the token0 and token1 of the pool. These amounts are eventually forwarded to the call to collectFees() in the FeeSplitter.sol contract. The third and fourth arguments are amountTokenOut and amountTokenIn, amountTokenOut should correspond to the "token out" (USDC) while amountTokenIn should correspond to the "token in" (ETH). The order here is important because FeeSplitter.sol use amountTokenOut as transfer amount for USDC. However, claimAndDistributeFees() ignores this order and simply sends amountCollected0 as amountTokenOut and amountCollected1 as amountTokenIn. This will work on Ethereum mainnet as the address of USDC is lower than the address of WETH, meaning token0 is "token out", but will fail on Optimism where the address of USDC is greater than the address of WETH. The following test simulates an scenario where token0 is WETH and token1 is USDC by forking Optimism. The call to claimAndDistributeFees() will revert as FeeSplitter.sol will try to pull more funds than available from the Exit10.sol contract. Full test suite is available here. function test_Exit10_claimAndDistributeFees_IncorrectTokenOrder() public { // We are on optimism where the token0/1 order in inverse to mainnet setUpOptimism(); // Skip bootstrap phase _skipBootstrap(); // Create a bond to provide some liquidity weth.approve(address(exit10), type(uint256).max); usdc.approve(address(exit10), type(uint256).max); deal(address(weth), address(this), 10 ether); deal(address(usdc), address(this), 10_000e6); _createBond(10 ether, 10_000e6); // Do some swaps to generate fees weth.approve(UNISWAP_V3_ROUTER, type(uint256).max); usdc.approve(UNISWAP_V3_ROUTER, type(uint256).max); _generateFees(usdc, weth, 1e12); // This function will claim fees from the pool and call collectFees() in FeeSplitter. // FeeSplitter will try to pull the tokens from Exit10 but will fail since the token order is wrong, // the call to collectFees() sends the USDC amount as the WETH amount and the WETH amount as the // USDC amount. As these amounts represent different magnitudes, the transaction will be reverted // since the Exit10 contract won't have those balances. For example, if fees are 500 USDC it will // try to pull 500 WETH from the Exit10 contract. vm.expectRevert("ERC20: transfer amount exceeds balance"); exit10.claimAndDistributeFees(); } 
8. Potential loss of collected fees during the call to claimAndDistributeFees() Severity: High Difficulty: n/a Type: n/a Target: n/a Description: When claimAndDistributeFees() is called, the function will collect fees from the Uniswap pool, which will send the funds to the caller contract. The implementation will then try to compound the proportion corresponding to the bootstrap bucket using increaseLiquidity(): https://github.com/open-bakery/exit10-protocol/blob/0b3c2782c5a93d2218234bc70fee31ec32f9e337/src/Exit10.sol#L439-L457 439: try 440: INPM(NPM).increaseLiquidity( 441: INPM.IncreaseLiquidityParams({ 442: tokenId: positionId, 443: amount0Desired: bootstrapFees0, 444: amount1Desired: bootstrapFees1, 445: amount0Min: 0, 446: amount1Min: 0, 447: deadline: DEADLINE 448: }) 449: ) 450: returns (uint128, uint256 amountAdded0, uint256 amountAdded1) { 451: unchecked { 452: amountCollected0 -= amountAdded0; 453: amountCollected1 -= amountAdded1; 454: } 455: } catch { 456: return; 457: } The external call is wrapped in a try/catch statement. The main issue is that if the call to increaseLiquidity() fails then the catch block will simply return from the function, which means the call to claimAndDistributeFees() will succeed. However, funds from fees have been already claimed but won't be sent to the FeeSplitter.sol contract. Additionally, this issue can be exploited by a bad actor using EIP-150 and the "rule of 1/64th". A bad actor can carefully choose the gas limit to make the call to increaseLiquidity() fail due out of gas, while still saving some gas in the main context to continue execution. The call to increaseLiquidity() will revert due to gas limits, and the catch block will be executed thanks to the saved gas. The following test reproduces the issue. We set up the liquidity and fees, and mock the call to increaseLiquidity() to make it revert. The fees will never reach the FeeSplitter.sol and will be stuck in Exit10.sol. Note: the following test requires a newer version of the Forge Standard Library in order to use vm.mockCallRevert(). It can be installed by executing forge install foundry-rs/forge-std --no-commit. function test_Exit10_claimAndDistributeFees_LossOfFeesIfIncreaseLiquidityReverts() public { // Generate liquidity and fees _bootstrapLock(10_000e6, 1 ether); _skipBootstrap(); _createBond(100_000e6, 10 ether); _generateFees(address(token0), address(token1), 1000e6); // Assume call to nonfungiblePositionManager.increaseLiquidity reverts vm.mockCallRevert( nonfungiblePositionManager, abi.encodeWithSelector(INPM.increaseLiquidity.selector), "" ); // Call function exit10.claimAndDistributeFees(); // FeeSplitter is empty uint256 feesClaimed0 = token0.balanceOf(feeSplitter); uint256 feesClaimed1 = token1.balanceOf(feeSplitter); assertEq(feesClaimed0, 0); assertEq(feesClaimed1, 0); // Fees are stuck in exit10 contract assertGt(token0.balanceOf(address(exit10)), 0); assertGt(token1.balanceOf(address(exit10)), 0); } In this other test we demonstrate the griefing scenario. Even if the call to increaseLiquidity() would succeed, a bad actor can arbitrarily exercise the issue by choosing a gas limit such that the call reverts due out of gas. The entire call to claimAndDistributeFees takes about ~360k units of gas, before calling increaseLiquidity() the gas cost is a bit more than 150k and the call to increaseLiquidity() itself takes a bit more than 50k gas. By choosing 200k units of gas we can get to point of calling increaseLiquidity(), but make this call fail due to out of gas since the forwarded gas will be less than 50k. function test_Exit10_claimAndDistributeFees_IntentionalRevert() public { // Generate liquidity and fees _bootstrapLock(10_000e6, 1 ether); _skipBootstrap(); _createBond(100_000e6, 10 ether); _generateFees(address(token0), address(token1), 1000e6); // Call function and supply a gas limit such that the call to "increaseLiquidity()" reverts due to OOG. // The function still continues execution since EIP150 will save 1/64 of available gas, enough to // execute the return in the catch clause. exit10.claimAndDistributeFees{gas: 200_000}(); // FeeSplitter is empty uint256 feesClaimed0 = token0.balanceOf(feeSplitter); uint256 feesClaimed1 = token1.balanceOf(feeSplitter); assertEq(feesClaimed0, 0); assertEq(feesClaimed1, 0); // Fees are stuck in exit10 contract assertGt(token0.balanceOf(address(exit10)), 0); assertGt(token1.balanceOf(address(exit10)), 0); } 
9. Using tick as price proxy is slightly inaccurate Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: _requireOutOfTickRange() is the key function that determines whether the price of ETH has reached a price above $10k and whether the Exit10 protocol's mission is complete. This function works by checking the WETH/USDC tick value and determining whether it is in the tick range or not. The tick values set in the environment variables are LOWER_TICK=184210 and UPPER_TICK=214170. We can do some math to check what ETH prices this corresponds to. // Step 1. calculate 1.0001^tickValue // Step 2. multiply by 10^-12 because of the USDC/WETH decimals conversion // Step 3. invert the value because of the order of WETH and USDC addresses 1 / ((1.0001**184210) * (10 ** -12)) = 10006.019136330182 1 / ((1.0001**214170) * (10 ** -12)) = 500.24195658614434 The chosen tick value that is used for the lower tick corresponds to a price of roughly $10006, which means that if the price of ETH only reaches $10005 before dropping below $10k, the exit10() function cannot be called. A tick value of 184216 or relying on slot0.sqrtPriceX96 instead of slot0.tick would be more precise, but using one of these values would then break the stated goal of holding only USDC when ETH arrives ta $10k because liquidity can only be removed at ticket intervals of 10 ticks. In summary, the protocol has 2 conflicting goals that are slightly mismatched: triggering exit10() when the price of ETH rises above $10k and holding only USDC at the same time that exit10() is called. One possible improvement for price data that would also protect against the situation of a USDC depeg event causing the price of ETH to appear to rise above $10k is to use Chainlink or another decentralized oracle solution for price data. Even if Chainlink is not the primary source of price data, it would be a useful secondary data source to validate that the Uniswap TWAP price is correct and that the price of ETH has indeed reached above 10k to allow exit10() to be called. 
10. Incorrect EXIT_DISCOUNT values Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The docs page describing the EXIT token describes a 5% discount on the EXIT token. But this value is not used consistently in the code. The value set in the .env file combined with the constant PERCENT_BASE value results in a much lower discount, only 0.05%. 
11. Problematic MasterchefExit rewards distribution to first EXIT staker Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: There are three problems with MasterchefExit.deposit(): Only the first staker to call deposit() receives rewards, which can lead to frontrunning of this function. A zero amount is permitted in deposit(), meaning the caller does not need to have any tokens. Because a zero amount is permitted in deposit(), pool.totalStaked will not increase after deposit() is called the first time with a zero amount, so deposit() can keep getting called with a zero amount by anyone until there is a non-zero value staked. 
12. Griefer can force bootstrap depositors to lose all funds if exit10() is triggered during the bootstrap phase Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: Within the bootstrapLock(..) function in the Exit10 contract, there is no check which prevents a user from calling it even after the exit10() function has been called and inExitMode has been set to true. The call to exit10() will set bootstrapBucketFinal to the current bootstrap funds - however an attacker is still able to call bootstrapLock(..), thus increasing the actual size of the bootstrap bucket to be greater than bootstrapBucketFinal. If the attacker deposits an amount equal to bootstrapBucketFinal, they will be able to trap all existing bootstrapper's deposits in the contract. To do so, they first call bootstrapLock(..) with this amount, and then call bootstrapClaim(). This function will call _safeTokenClaim() which has the following check which only allows an amount up to bootstrapBucketFinal to be claimed: _claim = (_claimed + _claim <= _supply) ? _claim : _supply - _claimed;. Thus, the attacker will be able to withdraw their own funds, leaving normal bootstrap depositors locked out of claiming. 
13. Updating fees with zero amount can be used to dilute rewards Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The updateFees() function present in FeeSplitter.sol is used to swap fees to ETH and feed those as rewards in Masterchef.sol. Doing so recalculates the reward rate to include the new amounts and extends the reward period by the configured rewards duration. This function can be abused by a malicious actor to dilute the reward process by calling it with a zero amount. This action won't increase the amount of rewards, but will extend the reward period, effectively lowering the reward rate. Current stakers will need to wait an additional period to claim their rewards. In this test, the issue is triggered each day using a reward duration of 10 days, and produces the following log: Logs: Logs: MC0 RewardRate: 599161603689814814814814814 MC0 PeriodFinish: 1684365053 MC1 RewardRate: 1048532902071511243386243386 MC1 PeriodFinish: 1684365053 ============================================= MC0 RewardRate: 556364346283399470899470898 MC0 PeriodFinish: 1684451453 MC1 RewardRate: 973637694780689011715797429 MC1 PeriodFinish: 1684451453 ============================================= MC0 RewardRate: 516624035834585222978080119 MC0 PeriodFinish: 1684537853 MC1 RewardRate: 904092145153496939450383326 MC1 PeriodFinish: 1684537853 ============================================= MC0 RewardRate: 479722318989257707051074396 MC0 PeriodFinish: 1684624253 MC1 RewardRate: 839514134785390015203927374 MC1 PeriodFinish: 1684624253 ============================================= MC0 RewardRate: 445456439061453585118854796 MC0 PeriodFinish: 1684710653 MC1 RewardRate: 779548839443576442689361133 MC1 PeriodFinish: 1684710653 ============================================= MC0 RewardRate: 413638121985635471896079453 MC0 PeriodFinish: 1684797053 MC1 RewardRate: 723866779483320982497263909 MC1 PeriodFinish: 1684797053 ============================================= MC0 RewardRate: 384092541843804366760645206 MC0 PeriodFinish: 1684883453 MC1 RewardRate: 672162009520226626604602201 MC1 PeriodFinish: 1684883453 ============================================= MC0 RewardRate: 356657360283532626277741977 MC0 PeriodFinish: 1684969853 MC1 RewardRate: 624150437411639010418559186 MC1 PeriodFinish: 1684969853 ============================================= MC0 RewardRate: 331181834548994581543617550 MC0 PeriodFinish: 1685056253 MC1 RewardRate: 579568263310807652531519244 MC1 PeriodFinish: 1685056253 ============================================= MC0 RewardRate: 307525989224066397147644867 MC0 PeriodFinish: 1685142653 MC1 RewardRate: 538170530217178534493553583 MC1 PeriodFinish: 1685142653 ============================================= MC0 RewardRate: 285559847136633083065670233 MC0 PeriodFinish: 1685229053 MC1 RewardRate: 499729778058808639172585469 MC1 PeriodFinish: 1685229053 ============================================= 
14. Pool spot price manipulation allows to call exit10() before ETH reaches 10K Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: In Exit10.exit10() it is checked inside _requireOutOfTickRange() whether the price of ETH has surpassed 10k by comparing the current tick to the upper or lower tick of the position range. function _requireOutOfTickRange() internal view { if (TOKEN_IN > TOKEN_OUT) { require(_currentTick() <= TICK_LOWER, 'EXIT10: Current Tick not below TICK_LOWER'); } else { require(_currentTick() >= TICK_UPPER, 'EXIT10: Current Tick not above TICK_UPPER'); } } _currentTick() is taken from slotO() function _currentTick() internal view returns (int24 _tick) { (, _tick, , , , , ) = POOL.slot0(); } The tick value returned by slotO() is the current tick and moves as the liquidity inside the pool is used up during swaps. If the USDC cumulated liquidity from the current price up to 10k is less than what can be obtained with a flash loan, then it is possible to take a flashloan and make a swap which will push the price beyond 10k. At this moment on Optimism there is: 3.24M of USDC liquidity on UniV3 WETH/USDC 500 pool 8M USDC available to borrow on AaveV3 The following PoC shows how a 4M USDC to ETH swap will manipulate the current tick to more than -184210 (corresponds to 10k on Optimism). function testManipulate() public { console2.log("block number:", block.number); (uint160 sqrtPriceX96Init, int24 tickInit, , , , , ) = pool.slot0(); // Take USDC from a large holder instead of flashloan for simplicity address atck = address(0xEbe80f029b1c02862B9E8a70a7e5317C06F62Cae); uint value = 4_000_000 * 1e6; vm.startPrank(atck); IERC20(pool.token1()).approve(address(router), value); ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams( pool.token1(), // USDC pool.token0(), // WETH 500, atck, block.timestamp, value, 0, 0 ); router.exactInputSingle(params); vm.stopPrank(); (uint160 sqrtPriceX96Fin, int24 tickFin, , , , , ) = pool.slot0(); console2.log("tickInit:", tickInit); console2.log("tickFin:", tickFin); } which outputs: Logs: block number: 95682224 tickInit: -201109 tickFin: -102138 Full PoC file here: https://gist.github.com/bahurum/9daac43a30cd67fe02453a58a52645b5 At any time, an attacker can take a flashloan, swap USDC to ETH, trigger exit10() and swap ETH back to USDC on the pool. Note that this may not yield any profit for the attacker (who would have to pay at least for flash loan fees), but the result is that the protocol ends sooner than expected. 
15. Use _collect() return values Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: _decreaseLiquidity() is called before each _collect() call (except one) to return the amount of each token that is passed to _collect(). However, after _collect() is called, it is assumed that the values passed as arguments to _collect() are equivalent to the values that are returned by _collect(). Looking at the Uniswap v3 NatSpec for the underlying NonfungiblePositionManager.collect(), the arguments are described as indicating the maximum amount of tokens to collect, and the return values from collect() indicate the actual value that is returned by the function. One example of this assumption is in bootstrapLock(). amountRemoved0 and amountRemoved1 are passed to _collect() as arguments and then are subtracted from amountAdded0 and amountAdded1. But because the arguments passed to _collect() are the maximum values that could be collected, the return values from _collect() should be what is subtracted from amountAdded0 and amountAdded1. 
16. No emergency function(s) to handle edge cases Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The Exit10 protocol is designed to be immutable, with renounceOwnership() calls in NFT.sol and FeeSplitter.sol. This immutability and the lack of emergency functions could result in locked funds due to uncontrollable external events. The funds that are locked until Exit10.exit10() is called include bootstrap funds, STO, and EXIT, which can only be withdrawn with bootstrapClaim(), stoClaim(), exitClaim(). Uniswap fees are currently passed on to liquidity providers. The Uniswap DAO has long discussed the idea of turning on the fee switch in order to direct some of these fees to Uniswap token holders. This change could substantially impact the fees earned by liquidity providers and may therefore change the assumptions in the Exit10 protocol. A similar result could happen if other events, such as a Uniswap hack or a better AMM, causes the ETH-USDC pool to generate substantially lower fees than estimated. Regardless of what actually happens, the assumption that the underlying Uniswap LP positions will generate fees when held in Exit10 depends on external factors not under control of the protocol. If these assumptions change, it may be useful to allow for emergency withdrawal of funds even before ETH reaches 10k. Another edge case that may occur is if ETH never reaches 10k. While this is a very pessimistic case, external factors like new laws banning certain cryptocurrencies, hacks, hard forks, or other factors could impact the price of ETH and when it might reach 10k. If the price of ETH does not reach 10k before the hardcoded deadline timestamp, which is in the year 2286, the funds will be locked. Another edge case is if a USDC depeg event happens. This could cause the price of ETH in the Uniswap pool to appear to rise above 10k, but in actuality the price of ETH may only be at a lower value such as $8000. A final edge case is that one of the Uniswap contracts behind a proxy, such as the Uniswap v3 Router, may undergo a change that is not backwards compatible. While this is unlikely to happen, a security vulnerability or unexpected DAO vote could cause this to happen. 
17. Inelegant rounding solution Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The purpose of _safeTokenClaim() is to burn all tokens held by a user and to return the quantity of rewards the user can claim. The calculation of claimable rewards due to the user is a 2-step process. In the first step, the user's claimable rewards is calculated as the fraction of final totalSupply that msg.sender owns. This calculation is similar to how ERC4626 asset <-> share conversion happens in functions such as convertToShares() and convertToAssets(). The second step is to modify the value of the user's claimable rewards if the total claimed rewards (including the amount that is claimed in the active transaction) exceeds the total supply of rewards that exist. The fact that this second step exists implies that the protocol could encounter a situation where the outstanding rewards exceed the rewards that the protocol can afford to payout, which means that at least one user owed rewards will not receive their full amount of rewards. The way the logic works could lead to a bank run scenario, where user(s) who are late to redeem their rewards don't receive the full value of their rewards. While it is not clear under what circumstance this line of logic would be needed, a better design is one like ERC4626 that manages the rounding up or down appropriately and never reaches a bank run type scenario where some users do not receive the expected amount of value due to rounding error accumulation. 
18. Incentive tokens EXIT, BOOT exposed to frontrunning Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: There is a limited supply of EXIT tokens. If a user converts a bond with convertBond() and _mintExitCapped() is called when mintAmount evaluates to zero or when the amount of EXIT to be minted updates to MAX_EXIT_SUPPLY - EXIT.totalSupply() instead of the original amount input argument, then the user may end up receiving less EXIT tokens than they expected (with a worst case of receiving zero EXIT). The process of increasing EXIT.totalSupply() to the MAX_EXIT_SUPPLY is at risk of being frontrun if a user is converting a bond in the same block as another user. The same frontrun risk exists with BOOT tokens in bootstrapLock(). Once bootstrapBucket increases to the value of BOOTSTRAP_CAP or near this value, a user calling bootstrapLock() may receive less BOOT tokens than expected (with a worst case of receiving zero BOOT). This means that user calls to bootstrapLock() (and also calls to swapAndBootstrapLock()) could be frontrun with the user receiving less BOOT than expected. The risk of frontrunning bootstrapLock() to claim BOOT is greater than the risk of frontrunning convertBond() to claim EXIT, because only users with existing bonds can call convertBond(). 
19. Incorrect PROTOCOL_GUILD address for multichain deployment Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: PROTOCOL_GUILD is hardcoded to 0xF29Ff96aaEa6C9A1fBa851f74737f3c069d4f1a9 in this line. But checking the Optimism blockchain scanner and Arbitrum blockchain scanner shows there is no contract deployed to these addresses. Any funds sent to this address on chains other than mainnet will not be useful to the Protocol Guild. The Protocol Guild only takes donations on Ethereum mainnet. 
20. High hardcoded slippage Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The slippage can be changed to a lower value. It won't cause the protocol to become stuck because FeeSplitter.sol uses function updateFees(uint256 swapAmountOut) to swap which has an input parameter. If the liquidity gets too low, and defined slippage is too high, input swapAmountOut can be decreased to complete the swaps. 
21. Bootstrap rewards are shared Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: When a user locks in an amount for bootstrapping, they transfer in USDC and WETH in order to add liquidity to the pool. BOOT tokens are then minted to the user 1:1 for the amount of liquidity they were able to add to the pool. Regardless of when a user locks into bootstrapping, they are minted the same ratio of BOOT as the original entrants. After the protocol has performed an Exit10 and a user goes to claim their BOOT, they are given USDC based on the ratio of the BOOT they own to the size of the bootstrap bucket. This means that fees generated during the bootstrap period are distributed to all bootstrappers, penalizing the early bootstrappers. 
22. Possible loss of funds with price limited swaps through DepositHelper Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: In DepositHelper._depositAndSwap() a user can provide TOKEN_IN and TOKEN_OUT at a certain ratio and make the contract perform a swap with _swapParams in order to provide liquidity at a different ratio. Let's say that _swapParams.tokenIn == TOKEN_0. The issue is that the contract assumes that _swapParams.amountIn is fully used for the swap and computes the amount to provide as liquidity as _initialAmount0 - _swapParams.amountIn (DepositHelper.sol#L85-L91). if (_swapParams.tokenIn == TOKEN_0) { _initialAmount0 -= _swapParams.amountIn; _initialAmount1 += amountOut; } else { _initialAmount1 -= _swapParams.amountIn; _initialAmount0 += amountOut; } Here is a PoC that demonstrates the issue: function testPriceLimitSwaps() public { _skipBootstrap(); uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower); uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper); (uint160 sqrtRatioX96, int24 tick, , , , , ) = IUniswapV3Pool(vm.envAddress('POOL')).slot0(); console.log("initial USDC balance of DepositHelper:", ERC20(usdc).balanceOf(address(depositHelper))); console.log("sqrtRatioX96:", sqrtRatioX96); (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, 1e15); // amounts to obtain 1e15 liquidity uint256 swapAmount0 = convert1ToToken0(sqrtRatioX96, amount1, 6); // usdc amount to swap ERC20(usdc).transfer(alice, amount0 + swapAmount0); // give usdc to alice IUniswapV3Router.ExactInputSingleParams memory swapParams = _getSwapParams( usdc, weth, swapAmount0); swapParams.sqrtPriceLimitX96 = TickMath.getSqrtRatioAtTick(tick - 1); console.log("alice sends", amount0 + swapAmount0, "USDC"); console.log("and swaps", swapAmount0, "USDC for ETH"); console.log("swapParams.sqrtPriceLimitX96 set to:", swapParams.sqrtPriceLimitX96); vm.startPrank(alice); ERC20(usdc).approve(address(depositHelper), amount0 + swapAmount0); depositHelper.swapAndCreateBond(amount0 + swapAmount0, 0, swapParams); vm.stopPrank(); uint256 usdcLeft = ERC20(usdc).balanceOf(address(depositHelper)); console.log("Only", swapAmount0 - usdcLeft, "USDC has been swapped and used to mint bonds"); console.log("USDC Left into DepositHelper:", usdcLeft); } which outputs: Logs: initial USDC balance of DepositHelper: 0 sqrtRatioX96: 1980704062856608439838598758400000 alice sends 41638723701 USDC and swaps 24004813136 USDC for ETH swapParams.sqrtPriceLimitX96: 1980530912134207514651007739210316 Only 5701654427 USDC has been swapped and used to mint bonds USDC Left into DepositHelper: 18303158709 Full PoC file here: https://gist.github.com/bahurum/96a5a6c2082b81712392924cd2e673fd. 
23. Relying on hardcoded values can save gas Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The variables TOKEN_IN and POOL are immutable in Exit10.sol. In UniswapV3Pool.sol the variables token1 and token0 are immutable. Because these values are not changing, branching logic like this if statement can be removed and simplified because the same logic path will always be followed because immutable variables cannot change after deployment. The same applies to places where POOL.token0() is used, it can be replaced with TOKEN_IN or TOKEN_OUT to remove an external call. 
24. Unnecessary 1e18 decimals multiplication Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: _getAccruedLiquidity() multiplies 1e18 by the value of block.timestamp - _params.startTime so that the resulting bondDuration variable has decimals of 1e18. But this is unnecessary because in the next line of code, the presence of bondDuration in the numerator and denominator means these decimals will cancel each other out. The code can be simplified and one multiplication operation removed by keeping the original decimals that block.timestamp has. 
25. Pass _liquidityAmount() to collectFees() for 2nd argument Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The only place where the remainingBuckets argument is used in on lines of code like pendingBucket + remainingBuckets. This summation should return the same value as Exit10._liquidityAmount(), so pass _liquidityAmount() instead of bootstrapBucket + reserveBucket + _exitBucket() as the 2nd parameter to FeeSplitter.collectFees() to save gas. Even better, cache _liquidityAmount() instead of calling the internal function multiple times. 
26. Remove function used only once Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Functions _getDiscountedExitAmount() and _getLiquidityForBootsrapTarget() are used only once. They can be removed and their code can be inlined to the only place where they are used. This will save gas without sacrificing readability if the variable naming is in line. The same is true of _transferAmountIn() in AMasterchefBase, it is only used in deposit(). 
27. Remove unused variables Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: State variable FACTORY is defined and used only in constructor() and can be removed. State variable bootstrapDeposit is not used at all and can be removed. 
28. Remove unneeded variable Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: There is no need to store deployment timestamp because this information can be retrieved from deployed block. This value is not used in any function and can be removed. Small change is required in Exit10.sol. - DEPLOYMENT_TIMESTAMP = block.timestamp; - BOOTSTRAP_PERIOD = params_.bootstrapPeriod; + BOOTSTRAP_PERIOD = params_.bootstrapPeriod + block.timestamp; Additional gas saving will be in dropping add operation at L554: - return (block.timestamp < DEPLOYMENT_TIMESTAMP + BOOTSTRAP_PERIOD); + return (block.timestamp < BOOTSTRAP_PERIOD); 
29. Struct packing Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The allocPoint and lastUpdateTime elements are currently uint256, however, allocPoint appears unlikely to exceed 100 and lastUpdateTime is only required to be as large as necessary to hold updated block.timestamp values. Given this, it may be reasonable to combine these two with the token address in order to have all three occupy only a single slot in storage. 
30. Skip double fetching of the same value Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: All functions that call _updatePool() already fetch the value from the storage, except _massUpdatePools() which can be easily changed to fetch the value from the storage. This will save gas on every call of _updatePool(). 
31. Use Shift Left instead of Multiplication if possible Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: In the file FeeSplitter.sol:125: -uint256 mc0TokenIn = (pendingBucketTokenIn * 4) / 10; // 40% +uint256 mc0TokenIn = (pendingBucketTokenIn << 2) / 10; // 40% In the file Exit10.sol:608: -_stoRewards = tenPercent * 2; +_stoRewards = tenPercent << 1; 
32. Cache state variables Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: In exitClaim() and stoClaim() the state variables EXIT and STO (respectively) are loaded three times, rather than being cached in a local variable. 
33. Redundant check in cancelBond() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: When a user cancels their bond, the amount of liquidity that they provided initially is removed from Uniswap, in order to pay them back. The _decreaseLiquidity() function requires a parameter of type RemoveLiquidity. In order to save gas, it is possible to remove the check _requireEqualValues and instead update the memory param parameter with bond.bondAmount. 
34. >= costs less gas than >. Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The compiler uses opcodes GT and ISZERO for solidity code that uses >, but only requires LT for >=, which saves 3 gas. File: Exit10-code/exit10-protocol/src/AMasterchefBase.sol 215: if (_poolLastUpdateTime > periodFinish) return 0; File: Exit10-code/exit10-protocol/src/Exit10.sol 177: if (bootstrapBucket > BOOTSTRAP_CAP) { 482: uint256 liquidityPerExit = actualLiquidityPerExit > projectedLiquidityPerExit 529: uint256 mintAmount = newSupply > MAX_EXIT_SUPPLY ? MAX_EXIT_SUPPLY - EXIT.totalSupply() : amount; 566: if (TOKEN_IN > TOKEN_OUT) { 
35. Standardize ProcessEth implementation Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Compare the implementations of _processEth(): DepositHelper implementation, without an event UniswapBase implementation, without an event 
36. Consider else if instead of else for stricter checks Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Some else branches might be best changed to else if branches to ensure that no unexpected edge cases trigger the else case. For example: This else branch could be replaced with else if (POOL.token0() == TOKEN_IN) This else branch could be replaced with else if (_swapParams.tokenIn == TOKEN_1) 
37. Possibly unnecessary event emit Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The MintExit event is emitted in _mintExitCapped(). This is the only event emitted in an internal function of Exit10.sol. It is emitted even when no EXIT token is minted. Instead, consider expanding the if statement to determine if EXIT is minted to include this emit. Another side effect of this emit is that it is duplicating the emit in ERC20._mint(), so each minting event will have 2 emits. Consider whether this is the intended result for minting EXIT tokens. 
38. Revert on zero case Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Consider the implementation of _safeTransferToken(): function _safeTransferToken(address _token, address _recipient, uint256 _amount) internal { if (_amount != 0) IERC20(_token).safeTransfer(_recipient, _amount); } If _amount is zero, _safeTransferToken() will not revert, but means any functions calling _safeTransferToken() will continue executing. This is similar behavior to phantom functions, an area of research that dedaub previously found a novel security issue with. Because there should be no changes when an amount of zero is involved, reverting will save the user gas and also prevent later logic from executing unexpectedly. 
39. Replace modifiers Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: NFT.sol and FeeSplitter.sol implement an onlyAuthorized modifier. This modifier can be replaced with internal functions in the same way that _requireExitMode(), _isBootstrapOngoing(), and similar internal functions are implemented in Exit10.sol. 
40. Missing NatSpec Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: NatSpec is a good way to explain your code to other developers modifying or forking a project, to users who want to understand what the contracts are doing, and to auditors who are trying to determine whether the contract logic is implemented properly. The contracts of Exit10 have a severe lack of detailed NatSpec comments which makes it harder to understand the developer's intentions. 
41. Use abstract contract Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Defining contract that is not deployed as abstract is a good practice to avoid confusion. 
42. Solidity version Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Solidity version 0.8.0 introduced a lot breaking changes. It would be good to define the same Solidity version for all contracts. Version above 0.8.0 don't need imported SafeMath library and abicoder v2 is enabled by default. 
43. Non-descriptive variable and function names Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Some variable names could be improved: exitBucketFinal set in exit10() is a very confusing name for a variable that contains the liquidity of the exit bucket and the bootstrap bucket. Consider changing the variable name to exitBucketBootstrapBucketFinal. exitBucketRewards is the amount of withdrawn USDC from the exitBucketFinal liquidity amount. This liquidity amount includes the exit bucket and bootstrap bucket liquidity so it would be better named exitBucketBootstrapBucketRewards. _getActualLiquidityPerExit is the estimated liquidity per EXIT token assuming MAX_EXIT_SUPPLY of EXIT is minted and redeemed. This is not always a valid assumption, because MasterchefExit.stopRewards() will burn the undistributedRewards if periodFinish is not reached. This function would be better named _getActualLiquidityPerExitAfterPeriodFinish. BOOTSTRAP_TARGET and BOOTSTRAP_CAP would be better described by the names BOOTSTRAP_LIQUIDITY_TARGET and BOOTSTRAP_LIQUIDITY_CAP. percentFromTaget would be better described with percentFromBootstrapTarget. _getPercentFromTarget() can return values that represent over 100%, so the word "percent" should be removed from the name of this function because a value representing 100% is meaningless. Consider instead getDollarPerExit() or getValuePerExit(). 
44. Outdated documentation Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The documentation describing the Exit10 buckets could be improved by adding a section for the bootstrap bucket. 
45. Replace magic numbers with constants Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The value 5000 appears on this line of Exit10.sol but there is no explanation for what this value represents. It looks like it represents the value 50% with a PERCENT_BASE of 10_000, but it turns out the 5000 value has nothing to do with a percentage. Instead, it helps set the price floor of the EXIT token, and a percentage over 100% only signifies a higher price. A constant variable with a clear name would make it easier to understand what is happening in this function. Arguably the 
46. Typos Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The _getLiquidityForBootsrapTarget function name was missing a t in Bootstrap and so was this comment. In addition, variable percentFromTaget on Exit10.sol lines 479 and 480 has a typo, it should be percentFromTarget instead. 
47. Unclaimed rewards can be added to user's reward debt Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The _safeClaimRewards function calculates the amount of underlying reward tokens a user may claim for their staked position. This function is called during deposit or withdraw operations. It sets the claimable amount to the lesser of the remaining rewards in the contract or the user's eligible rewards. It then transfers this amount to the user. In both the deposit and withdraw functions, the rewardDebt is then set to be eligible for 0 rewards regardless of the results of the claimed rewards. 
48. Remove unnecessary address casting Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: In the file AMasterchefBase.sol there are multiple unnecessary address casting at L51 and L121. 
49. Remove unnecessary virtual marker Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The function _updateUndistributedRewards() can drop the virtual marker because it is not overridden in child contract. 
50. Potentially unnecessary line of code Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: It is likely that this line of logic in MasterchefExit is never reached. In fact, if it is reached it means that the Masterchef contract has accumulated debt by paying out more rewards than it should have. If this scenario ever occurs, it means there is a problem with another part of the protocol. 
51. (Out of scope file) Ensure that Bond NFT contract is initialized with non-zero TRANSFER_LOCKOUT_PERIOD_SECONDS Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Bond NFTs are tradeable ERC721s that represent the holder's share of the liquidity in the protocol's pendingBucket. When a user converts or cancels the bond, the NFT still exists but has its status in Exit10's idToBondData mapping changed to converted/canceled, rendering it unusable for protocol functions. To avoid situations where a user converts/cancels their bond and immediately sells it to an unsuspecting buyer, the following check in NFT.sol#beforeTokenTransfer() exists: require( status == uint8(Exit10.BondStatus.active) || block.timestamp >= endTime + TRANSFER_LOCKOUT_PERIOD_SECONDS, 'NFT: Cannot transfer during lockout period' ); In the current tests, the value of TRANSFER_LOCKOUT_PERIOD_SECONDS is initialized to zero. This would allow a malicious user to bypass the lockout period and sell their bond immediately. 
52. Potential lock funds if USDC implements taking fee mechanism in the future Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: USDC contract is now using proxy pattern, which indeed could change business logic in the future. In case USDC takes fee on transfers before ETH 10k, Exit10 users can not claim total amount of USDC from system, i.e. at least the latest user can not claim his full amount because contract balance deducted by fee from earlier claim 
53. Bonds may convert less EXIT tokens than users expect Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The summation of convertible liquidity can exceed the cap EXIT token cap: $$\sum_{i=1}^n (\frac{l_{it}}{r_{it}}) \geq E_S$$ Where: $l_{it}$ is the convertible liquidity of bond $i$ at time $t$; $r_{it}$ is the rate of liquidity per EXIT token that bond $i$ will receive at time $t$; $E_s$ is the EXIT token supply cap. The rate of liquidity per token for a bond at time ${t}$ to receive $r_{it}$ is the larger of two values: the projected liquidity per token $r_p$ and actual liquidity per token $r_a$. The formula for $r_p$ is: $$r_p=p_t*L_{USDC}$$ Where: ${p_t}$ is the percentage of collected bootstrap liquidity to its target, floored to 50%. In other words, if less than 50% of the target was reached, $p_t=0.5$. $L_{USDC}$ is a constant: the projected amount of liquidity per USDC; For $r_a$ the formula is: $$r_a=\frac{e_l}{E_s}$$ Where: $e_l$ is the available liquidity to be claimed by EXIT holders from the exit bucket (i.e. 70% of the exit bucket); $E_s$ is the exit token supply cap. To break the invariant and fall in the case where the token cap exceeds we assume: Less than or 50% of the bootstrap target was reached (i.e. $p_t=0.5$); Not enough liquidity accumulated in the exit bucket and $r_a<=r_p$. So we have: $$r_p=r_a=\frac{L_{USDC}}{2} = \frac{e_l}{E_s}=r_{it}$$ The amount of EXIT tokens a bond $i$ is entitled to at time $t$ (before the discount is added) $e_i$ is: $$e_i=\frac{l_{it}}{r_{it}}$$ The convertible liquidity cap (i.e. the point from which the entire EXIT supply is minted and all other bonds receive 0 EXIT tokens per liquidity) can be defined by setting the amount of tokens received to the supply $e_i=E_s$. Solving for $r_p$ and $r_a$: $$e_i=\frac{2*l_{it}}{L_{USDC}} =\frac{l_{it}}{e_l}*E_s=E_s$$ From here, we can make two observations: If the ratio between the bond's convertible liquidity $l_{it}$ to the liquidity in the exit bucket $e_l\geq 1$ or; If the bond's convertible liquidity $l_{it} \geq \frac{E_s*L_{USDC}}{2}$ , i.e. $l_{it} \geq 6437989144.5 * 10^7$ assuming 10mi EXIT. The bond would mint the entire EXIT supply and all bonds will receive 0 EXIT on conversion. Note: To simplify modeling we are using one massive bond, but this behavior is equivalent if the liquidity is split in multiple bonds. In other words, the two observations above still apply if we replace $l_{it}$ with $\sum_{k=1}^n(l_{it})$ as what matters is that the aggregate convertible liquidity. Note that as the code is, people can still create new bonds even after the supply cap is reached. 
54. Masterchef is vulnerable to reentrancy attacks Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: In both functions, rewards are sent to the caller before state is updated to reflect the claim. If the implementation of the reward token contains callbacks or hooks that would grant control to the caller, such as an ERC777, then it is possible to execute a reentrancy attack to steal the reward tokens from the contract. Using the withdraw() as an example, we can see that tokens are transferred in line 101 and state is updated in lines 103-105. 094: function withdraw(uint256 pid, uint256 amount) public { 095: PoolInfo storage pool = poolInfo[pid]; 096: UserInfo storage user = userInfo[pid][msg.sender]; 097: _updatePool(pid); 098: 099: amount = Math.min(user.amount, amount); 100: 101: _safeClaimRewards(pid, _getUserPendingReward(user.amount, user.rewardDebt, pool.accRewardPerShare)); 102: 103: user.amount -= amount; 104: user.rewardDebt = (user.amount * pool.accRewardPerShare) / PRECISION; 105: pool.totalStaked -= amount; 106: _transferAmountOut(pool.token, amount); 107: 108: emit Withdraw(msg.sender, pid, amount); 109: } If the caller receives control during the call to _safeClaimRewards() (which transfers the reward token), an attacker can reenter the function and execute the claim again, since the state hasn't been updated yet, in particular line 104 which tracks how many rewards have been already sent to the user. A test with a proof of concept for this issue is available here. 
55. Event not emitted when adding a token. Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: 
56. Centralization risk during protocol bootstrap Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: During bootstrap, different contracts need to be created separately by the deployer of the protocol before they are put together in their final configuration. During this period of time, the deployer is the owner of these contracts that are later transferred to the Exi10.sol contract. BLP, STO, BOOT and EXIT tokens used in the protocol are created during the initialization. As these contracts grant the owner the ability to arbitrarily mint tokens, a malicious deployer can mint any number of tokens they want before transferring control to the main contract. Another example attack would be to backdoor the Masterchef.sol or MasterchefExit.sol contracts by configuring another pool with a fake token, which can then be used to steal rewards. 
