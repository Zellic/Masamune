1. Incorrect ratios used for delta neutral rebalancing Severity: High Difficulty: n/a Type: n/a Target: n/a Description: Rage Trade relies on providing liquidity to the GMX protocol for long exposure to WETH and WBTC. The GMX Vault is where all GMX protocol underlying assets are stored. The GMX vault has a target weight for each underlying asset, but the target weight is not the same as the current weight of the asset in the vault during a specific block. The actual weights of the tokens The Rage Trade rebalancing approach uses the ideal target weight, not the actual current weight of the asset. This means the Rage trade strategy is not actually delta neutral because it assumes an ideal mix of underlying assets when holding GLP and doesn't consider the current underlying assets. To demonstrate the issue, data was taken from the Arbitrum blockchain to plot the exposure that Rage Trade has had to the underlying assets WETH and WBTC since around the time that the delta neutral strategy began receiving funds. The short exposure takes the form of WETH or WBTC borrowed from Aave. To calculate this percentage, the amount of WETH or WBTC borrowed was multiplied by the price of the asset and then divided by the total value of GLP held by the Rage trade strategy. The short exposure does a good job of targeting the 35% and 15% marks for WETH and WBTC respectively. The 35% and 15% marks are the target allocations for the GMX vault to hold of WETH and WBTC. The long exposure takes the form of GLP, which holds roughly 50% stablecoins and 50% WETH and WBTC. The data for the exposure to WETH and WBTC was taken from at stats.gmx.io during the same period as the short position exposure chart. The comparison of the short and long exposure to WETH and WBTC is shown below. As the charts demonstrate, since the deployment of Rage Trade in December 2022, the GMX vault, and therefore GLP, has consistently held more WBTC and less WETH than the GMX vault target weights. But the Rage Trade short positions do not reflect this, and instead use the target weights to determine the ideal short exposure to these assets. In its current form, Rage Trade has held a position of long WBTC and short WETH since it was deployed. Examining the asset exposure in the GMX Vault over the entire duration of GMX's history, it is more apparent how far the asset allocations can stray from the target. The second figure below focuses on the less volatile period of GMX asset allocation in 2022 to provide a closer look at how different the asset allocation is from the 35% WETH and 15% WBTC targets. Since June 2022, the GMX vault has mostly been overweight in WBTC and underweight in WETH, but sometimes it is overweight in both assets. Focusing on more "extreme" changes in the asset allocations of the vault, the vault held a total of 39.4% in WETH and WBTC combined on May 26 2022, but that rose to 54% on July 24 2022, less than 2 months later. If this strategy was active at this time, it would have had too large of a short position and too small of a long position. It is true that during this time the value of WETH and WBTC dropped by around 22%, so in actuality these months would have been profitable for this strategy, but a reverse scenario where the assets increased by 22% in value would have left the strategy at a loss. Even if the above scenario where the strategy is weighted in the wrong direction of market movements does not occur, another risk is if the correlation between WETH and WBTC prices change significantly. It's possible there is an implied assumption that WETH and WBTC prices are correlated, so as long as the sum of allocations WETH and WBTC in the GMX vault is roughly 50% of the GMX vault, then the long position should neutralize the short position. But if the WETH/WBTC price correlation changes while they GMX vault allocations are not near the targets, this could be problematic. The chart from CoinGecko shows this ratio over the last two years and demonstrates that it can easily change by 10% or more in a short timespan. In summary, the risk this issue highlights includes: strategy losses from when WETH and WBTC positions are overweighted towards a long position and the prices of these assets drops. The reverse can also happen, where WETH and WBTC positions are underweighted towards a long position and the prices of these assets rises. strategy losses from when WETH and WBTC weights in the GMX vault are not at the target weights and the WETH/WBTC price ratio changes in the wrong direction from how the GMX vault (and therefore the Rage Trade strategy) is weighted. 
2. Junior vault getPriceX128() has wrong decimals Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The term X128 as used in Uniswap documentation indicates a Q128 value. This means that the value should be divided by 1 << 128 to get the actual value that it represents. Examining getPriceX128() in the junior vault finds a problem. The return value is aum.mulDiv(1 << 128, totalSupply * 1e24). This is similar to the previous junior vault example. aum is 1E12, but the denominator is totalSupply of 1E18 multiplied by 1E24. This leaves the numerator with 1E12 but the denominator with 1E42, the resulting values is not correct. When the value of getPriceX128() in the existing on-chain deployment is divided by 1 << 128, the resulting value is 8.34E-13. In contrast, the price of GLP is $0.834 and the return value of getPrice(bool) in the junior vault with 18 decimals like GLP is 0.834E18. We can apply the same approach to getPriceX128() in the senior vault and find that it is implemented correctly. We can double check the decimals of the return value price.mulDiv(1 << 128, 1e8). price is 1E8 and it is divided by 1E8, so the price value is properly multiplied by 1 << 128. We can also confirm the decimals in getPrice(bool) in the junior vault are correct. The price value is documented in GMX docs: The sell price would be getAum(false) / glpSupply getPrice(bool) returns aum.mulDivDown(PRICE_PRECISION, totalSupply * 1e24). aum is 1E12, PRICE_PRECISION is 1E30, totalSupply is 1E18 and it is multiplied by 1E24. This results in 1E12 * 1E30 / (1E18 * 1E24) = 1E42 / 1E42 = 1. And because GLP has a decimals value of 18, the value is returned with 18 decimals. The return value can be confirmed against the GLP price in the GMX frontend. 
3. maxWithdraw() and maxRedeem() are inaccurate if Aave pool doesn't permit withdrawals Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: EIP4626 states the following requirements for maxRedeem(): Maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a redeem call. MUST return the maximum amount of shares that could be transferred from owner through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0. If an Aave pool is paused or inactive, maxWithdraw() and maxRedeem() in the senior vault should return zero. The functions currently do not. Currently the senior vault is not compliant with the ERC4626 spec if the Aave pool is inactive or paused. maxMint() and maxDeposit() should also have a similar change. 
4. maxMint() and maxDeposit() are inaccurate if Aave pool is frozen Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: EIP4626 states the following requirements for maxMint(): MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset. MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0. If an Aave pool is frozen, Aave documentation states it will not accept deposits. Therefore maxMint() and maxDeposit() should return zero in this case. The functions currently do not. Currently the senior vault is not compliant with the ERC4626 spec if the Aave pool is frozen. 
5. setGmxParams() doesn't update dependent variable Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The value state.glpManager can be updated in setGmxParams() by the owner. The value state.gmxVault is set in initialize() by calling vault() in state.glpManager. When state.glpManager is updated, the value state.gmxVault is not updated, which may leave the gmx vault variable outdated. 
6. Biased delta neutral position Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The junior vault attempts to hold equal long and short positions to maintain a delta neutral position in the market. The reason this is done is to avoid impermanent loss, which is a common problem for liquidity providers. The junior vault holds a short position by borrowing WETH and WBTC from Aave (after depositing USDC to maintain a reasonable health factor). The junior vault holds an equal long position by holding GLP (technically fsGLP, the staked version of GLP) which consists of a basket of underlying assets mostly consistently of WETH, WBTC and stablecoins. There are two small ways in which the Rage Trade delta neutral strategy has bias in its holdings that could create unwanted exposure to certain assets. A consistent bias over the long run can impact yield returns to depositors because impermanent loss may cause losses in the long run. The GLP vault does not hold exactly 50% WETH & WBTC with the remaining 50% in stablecoins. It targets a holding of 1% LINK and 1% UNI, so in reality the targeted exposure is 35% WETH, 15% WBTC, 1% UNI, 1% LINK, and 50% stablecoins. The delta neutral strategy has no short position to cover the long exposure held in UNI or LINK. Although the percentage of UNI and LINK holdings is small, this exposure can result in non-zero impermanent loss over the long run. If there is an assumption that UNI and LINK prices are correlated to WETH and WBTC, then the value of the short positions should be increased to roughly 52% of the GLP value, rather than the currently targeted 50%. LINK is an asset that can be borrowed and shorted on Aave like WETH and WBTC currently are, an approach which would maintain a more precise neutral position. The second bias is that the process that rebalances the junior vault holdings consistently has more long exposure than short. This can be seen on the long timescale where the ratio is targeting 2 (the reason the target ratio is 2 and not 1 is because only 50% of the holdings in the GMX vault are WETH and WBTC) but the actual value is consistently above 2. Zooming in on the shorter timescale, observe the point in time when a rebalance happens in the middle of this plot. While the rebalance brings the ratio closer to 2, it could do better, and this inaccuracy may be due to an inaccuracy in the implementation's math. 
7. Make functions external Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Make getVaultMarketValue() in the senior vault and the junior vault external, not public. The same can be done for getPriceX128() in the senior vault and the junior vault. getPriceX128() in the senior vault includes a comment that it is only used in the frontend. 
8. Immutable variables are cheaper Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: pool can be immutable for gas savings. 
9. Remove unused function Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: getMaxVariableBorrowRate() is not used in any contracts in the Rage Trade repo and can be removed. 
10. Remove duplicate length check Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The array length check in _executeFlashloan() is unnecessary because it is duplicated a few lines later when the Balancer vault flashloan() call happens. 
11. Unnecessary addition operation Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: usdcBorrowed is zero at the start of totalUsdcBorrowed(), so the line can be changed to: - if (address(leveragePool) != address(0)) usdcBorrowed += leveragePool.getUsdcBorrowed(); + if (address(leveragePool) != address(0)) usdcBorrowed = leveragePool.getUsdcBorrowed(); 
12. No way to remove approvals Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: grantAllowances() in the junior vault and senior vault exists solely to set the allowances for the vault, even though these are set in the initializer(). It may also be useful to have a way to remove these allowances. For example, if the Aave pool address is updated or there is a security concern with an approved contract, it may be useful to remove the approval. But there is currently no ability to do this with the vaults. This ability may be useful to introduce because a paused vault will not prevent tokens from being withdrawn by an approved address when an infinite allowance is set. 
13. Move Aave pool and oracle update to new function Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The second half of setHedgeParams() is unrelated to the first half and may not be necessary to use each time the other state variables are updated. Consider moving the second half of setHedgeParams() to a separate function. 
14. Unused dependencies imported Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The WadRayMath import from Aave V3 is never used by DnGmxJuniorVault. The same applies to IRewardTracker. 
15. Hypothetical revert condition breaks EIP4626 requirements Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: EIP4626 states totalAssets() has the requirement that it MUST NOT revert. But in the senior vault, the call flow totalAssets() -> totalUsdcBorrowed() -> dnGmxJuniorVault.getUsdcBorrowed() -> .toInt256() calls a SafeCast function that could revert if the uint256 value in getUsdcBorrowed() is greater than or equal to 2**255. It is unlikely that Rage Trade will hold this much value, which would equate to 2**249 dollars of value, but totalAssets() would revert in such a case. 
16. Replace magic numbers with constants Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There are many instances of magic numbers with powers of ten. Consider replacing these magic numbers with a constant internal variable, which is already done in some cases like PRICE_PRECISION. Some examples are these magic numbers 1e12, 1e14, 1e16, and 1e30. 
17. Unnecessary reimplementation of GMX functions Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The junior vault's getPrice() and the junior vault manager's _getGlpPrice() functions are identical other than the different of the state function argument. Furthermore, these functions reimplement a function named getPrice() in GlpManager that returns the GLP price. In fact, the return value and decimals of the junior vault's getPrice() and getPrice() in GlpManager is identical, so arguably the function isn't needed at all and the GlpManager contract can be called directly when needed. The same applies to the first half of _getGlpPriceInUsdc() in the junior vault manager. 
18. Library functions with unusual visibility Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: A library is slightly different than a contract in that the functions in a library are only accessible to the contract that imports the library. This means the junior vault manager library can remove any external functions that are declared external in the library but are not called by the junior vault (which is the only contract that imports the library). Such functions include getTokenReservesInGlp(), rebalanceBorrow(), getTokenPrice(), getGlpPrice(), getGlpPriceInUsdc(), getTokenPriceInUsdc(), getLiquidationThreshold(), flashloanAmounts(), getOptimalCappedBorrows(), getTokenReservesInGlp(), and isWithinAllowedDelta(). Another change that could be made with the library is combining external and internal functions if the external function only calls the internal function. 
19. Functions altering state variables missing events Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Some functions that modify state variables do not emit events: updateFeeStrategyParams() unstakeAndVestEsGmx() stopVestAndStakeEsGmx() claimVestedGmx() 
20. Dead link in ERC4626Upgradeable.sol comment Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: This link points to a repo that no longer exists. 
21. Move excessUtilizationRate calculation in calculateFeeSplit() into if statement Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: This line can be moved inside the if statement. 
