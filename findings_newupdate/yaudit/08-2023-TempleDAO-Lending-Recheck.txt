1. Rounded down principal could be carried over in debtor cache struct Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The _initDebtorCache() function is in charge of building the cache structure associated with a debtor. While calculating the baseInterest value, the function may eventually overwrite the principal: // Because the shares => debt conversion is rounded down in some scenarios, // there is a chance the `_debtor.principal` outstanding may be // less than this rounded down number. So use the minimum of the two. _debtorCache.principal = _debtorPrincipalAndBaseInterest < _debtorCache.principal ? _debtorPrincipalAndBaseInterest : _debtorCache.principal; // The baseInterest outstanding for this debtor is now the difference. unchecked { _debtorCache.baseInterest = _debtorPrincipalAndBaseInterest - _debtorCache.principal; } As hinted in the comment from the snippet, _debtorPrincipalAndBaseInterest may be lower than the actual principal due to rounding issues. The solution present in the implementation is to take the minimum of these values so that the subtraction to calculate _debtorCache.baseInterest doesn't overflow. While this sounds reasonable (the base interest value would end up being zero in such case), it is important to note that the principal value present in the cache struct is overwritten with a value that is actually lower than the original principal, which may impact other calculations that use the value from the struct. For example, mint() initializes the debtor cache and then uses the principal stored in the cache struct to update the principal value in storage. 
2. Enabled borrow tokens configuration is not cleared when shutting down a strategy Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The implementation of the shutdown() function, which is in charge of removing a strategy from the vault, fails to clear the configuration associated with the enabled borrow tokens of a strategy. 
3. G7 treasuryReservesVault optimization not implemented in DsrBaseStrategy Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: The suggestion to cache treasuryReservesVault in DsrBaseStrategy::trvWithdraw() was not applied but is still applicable. 
4. Change visibility of public constants Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: This was originally reported as G-06 in the first audit report. Most of the occurrences have been resolved, except the one in AbstractStrategy.sol. The VERSION constant in ThresholdSafeGuard.sol is also marked as public, although this contract doesn't have a separate getter that publishes the constant, as the others do. 
5. Avoid copying calldata to memory in addStrategy() Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Line 184 defines a variable in memory that is used to assign each element of the debtCeiling array, which will end up copying the AssetBalance structure from calldata to memory. 
6. Imprecise comment Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: _debtTokenCache(), _getDebtorCache(), and _getBaseCache() are similar functions in different contracts. The NatSpec describing _debtTokenCache() is Update storage if and only if the state has changed. while the NatSpec for _getBaseCache() and _getDebtorCache() is Update storage if and only if the timestamp has changed since last time. In reality, the functions rely on a timestamp if statement check, not specifically a state change check. The timestamp comment is more accurate and can be applied to both functions. Additional alignment between related caching functions is possible. _initDebtTokenCache() checks if blockTs != interestAccumulatorUpdatedAt while _initBaseCache() and _initDebtorCache() checks if _timeElapsed > 0. Aligning the logic in related functions can reduce overall protocol complexity. 
7. Potential overflow in _initDebtorCache() Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: In _initDebtorCache() the debtor's principal and current risk premium are added together to calculate the updated risk premium interest. Since the data type of the resulting expression (_debtorTotalDue) is of type uint128 (same as the operands), the calculation may silently overflow due to the usage of unchecked math. 
8. Unchecked statement could overflow Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: A summation in _mintDToken() newly moved to an unchecked block could hypothetically overflow. The comment before this line hints that the overflow is checked within the dToken.mint(), but this is incorrect. dToken.mint() does not check for an overflow of _newDebt + dTokenBalance, where dTokenBalance is the sum of principal, baseInterest, and riskPremiumInterest. The closest that dToken.mint() achieves is confirming no overflow in the summation _debtorCache.principal + _mintAmountUInt128, but this summation omits the baseInterest and riskPremiumInterest values that are included in dTokenBalance. 
9. Code without math operations doesn't need unchecked Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Consider moving the line if (_delta > maxTreasuryPriceIndexDelta) revert BreachedMaxTpiDelta(_oldTpi, _newTpi, maxTreasuryPriceIndexDelta) outside of this unchecked block. The same suggestion applies to debtTokenData.totalDebt = _cache.totalDebt = _newDebt; in _repayTotalDebt(). 
10. currentTotalDebt() can be declared external Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: currentTotalDebt() is a public function that does not need to be public. 
11. _withdrawFromBaseStrategy() should also revert explicitly if withdrawn amount from base strategy is not enough Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The check and the revert was added in line 624 which only covers the else branch of the conditional present in line 591. If there is a base strategy associated with the debt token, it is possible that this strategy may not have the required funds and could potentially return an amount less than what was requested. In such a scenario, the condition may fail to be correctly checked. 
12. Emit RewardTokensSet event in AuraStaking.sol constructor Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Given the inclusion of the setRewardTokens() function, which now emits the RewardTokensSet event when the reward tokens array is updated, the constructor of the contract should also emit the same event since it performs an assignment of the same array. 
13. Strategy details could output debt ceiling only for enabled tokens Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Both strategyDetails() and strategyBalanceSheet() return information based on all tokens present in the configured set of borrow tokens (i.e. _borrowTokenSet). With the introduction of the enabled borrow tokens feature for each particular strategy, these results could be bound to only the enabled tokens instead of the whole set. 
14. Debt ceiling hook is not triggered when a strategy is added to the vault Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The setStrategyDebtCeiling() function fires the debtCeilingUpdated() callback to signal the strategy that its associated debt ceiling has been updated. The same hook is not triggered in the addStrategy() function, which initializes the debt ceiling value for each of the configured tokens for the strategy. Considering the strategy contract is created before being added to the vault, the strategy might not be aware about the eventual configuration and could potentially require this value during its setup. 
