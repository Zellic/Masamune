1. Inaccurate rounding from maximize Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: There are two locations where mulDivDown() uses _getGlpPriceInUsdc(state, maximize) in the denominator and one place where _getGlpPriceInUsdc(state, !maximize) is in the denominator. This inconsistency indicates a bug. If a fraction is intended to be maximized (with maximize set to true), then the denominator should be reduced (with maximize set to false). If the fraction is intended to be minimized (with maximize set to false), then the denominator should be increased (with maximize set to true). This indicates that the correct value of maximize when it is used in the denominator is inverted from the value it holds in the current function. The two cases where this is not done, line 1140 and line 1146, should be fixed to align to line 1172. 
2. Loss of precision can lead to loss of value Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The calculation of minTokenOut in _convertToToken() is done in a way where the value is reduced to 6 decimals of precision, then increased to the number of decimals needed for that specific token. This process means that all digits beyond the first 6 decimals of precision will be zeros. This effectively rounds down the value, which increases the amount of possible slippage from the value targeted by the slippageThreshold value. This could result in minor loss of value. 
3. Possible underflow could cause revert Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: A comment in _executeVaultUserBatchStake() attempts to explain why _roundUsdcBalance will be always >= _usdcToConvert, but the logic does not hold up. Take the following example scenario. Starting values: usdcAmountToConvert = 1 _roundUsdcBalance = 2 minUsdcConversionAmount = 4 Logical steps After line 388: _usdcToConvert = 1 After line 397: _usdcToConvert = 4 _roundUsdcBalance - _usdcToConvert will underflow on line 399 because _roundUsdcBalance = 2 while _usdcToConvert = 4 The same logic is found in DnGmxBatchingManagerGlp.sol. 
4. Cannot undo infinite approval Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: grantAllowances() in the batching managers gives an infinite approval of sGLP to dnGmxJuniorVault, but there is no way to undo this approval. It may be useful to add a function argument to grantAllowances() to allow a custom approval value to be set, including an approval of zero. While the batching managers are implemented behind proxies, in the event that the approval needs to be removed, response time will likely be important so it is preferable to have failsafes in place before they are needed. Because dnGmxJuniorVault is implemented behind a proxy, the code at that address today may differ from the code at that address in the future, making safety measures more important. 
5. abs() reverts for type(int256).min Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The abs() implementation in SignedFixedPointMathLib is not from OpenZeppelin's SignedMath. OpenZeppelin's code has a comment indicating unchecked must be used to support the argument value of type(int256).min. The current abs() implementation reverts on this value. Because mulDivDown() relies on this abs() implementation, it too would revert in the case of x == type(int256).min. 
6. Missing assert risks casting overflow Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: _calculateSwapLoss() contains two casting operations where a value is negated. In the second case, it is clear that the negation will make tokenAmount positive because tokenAmount is less than zero in that code branch. But in the first case, it is not clear that the negation will make otherTokenAmount positive rather than negative. _calculateSwapLoss() is called with values returned from QuoterLib.quoteCombinedSwap(). quoteCombinedSwap() contains an assert that validates ethAmountInEthSwap and usdcAmountInEthSwap have opposite signs. But there is no similar check to confirm btcAmountInBtcSwap and usdcAmountInBtcSwap have opposite signs. This means the _calculateSwapLoss() call with BTC values may have a chance of a casting overflow because there is no assertion to guarantee avoidance of this case. 
7. Combine zero checks Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: In batching manager, when executeBatch() is called it checks if the function argument is zero and then later checks if a value derived from the argument is zero. The first check can be removed, because if the function argument is zero it will be caught in the second check. The same logic is in DnGmxBatchingManagerGlp.sol. 
8. Use unchecked if no underflow risk Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: There is at least one example where unchecked can be applied, because the line before the subtraction prevents an underflow: - userDeposit.unclaimedShares = userUnclaimedShares - amount.toUint128(); + unchecked { userDeposit.unclaimedShares = userUnclaimedShares - amount.toUint128(); } The same modification could be made to DnGmxBatchingManagerGlp.sol. 
9. Use cached value Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: userDeposit.usdcBalance is cached in userUsdcBalance in depositUsdc(). This cached value can be used instead of userDeposit.usdcBalance on line 225. This optimization is already used later in the same contract. The same edit can be made in DnGmxBatchingManagerGlp. 
10. Remove unused functions Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: simulateSwap() with 4 function arguments is not used anywhere and can safely be removed from Simulate.sol to save some gas on deployment. The onlyDnGmxJuniorVault modifier is declared in DnGmxBatchingManager and DnGmxBatchingManagerGlp but is never used in Rage Trade. These modifier declarations can be removed. 
11. Consider refactoring Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: _getMaxTokenHedgeAmount() is nearly identical to _getTokenHedgeAmount(). The only difference is in the last line of these functions. _getTokenHedgeAmount() could be replaced with _getMaxTokenHedgeAmount() * _traderOIHedgeBps / MAX_BPS. 
12. Update and improve comments Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Several improvements can be made in comments: DnGmxBatchingManagerGlp.sol now handles USDC instead of GLP. Many comments still reference GLP but should now mention USDC. For example, this comment and this comment in depositUsdc() should say USDC not sGLP. There are other comments that also need updating to reflect the switch to using USDC. slippageThresholdGmxBps in DnGmxBatchingManager is used for USDC slippage but also WETH slippage in rescueFees(). This comment only mentions USDC but should mention WETH. _getMaxTokenHedgeAmount() is nearly identical to _getTokenHedgeAmount() but the comments of the two functions are identical. The difference is that _getTokenHedgeAmount() returns a value multiplied by _traderOIHedgeBps. This difference in not reflect in the comments of the function. 
13. Efficiency improvement Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The tokenTraderOIMax function argument for the function _checkTokenHedgeAmount() is returned from _getMaxTokenHedgeAmount(). This returned value should always be positive. This means tokenTraderOIMax.sign() == 1, so _checkTokenHedgeAmount() can be simplified with the following: function _checkTokenHedgeAmount(int256 tokenTraderOIHedge, int256 tokenTraderOIMax) internal pure returns (bool) { - if (tokenTraderOIHedge.sign() * tokenTraderOIMax.sign() < 0) return false; + if (tokenTraderOIHedge.sign() < 0) return false; - if (tokenTraderOIHedge.abs() > tokenTraderOIMax.abs()) return false; + if (tokenTraderOIHedge > tokenTraderOIMax) return false; return true; } 
14. Migration requires managing slot reuse Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: In DnGmxBatchingManager.sol, the glpDepositPendingThreshold variable in the old contract version is renamed to minUsdcConversionAmount in the new contract version. This storage slot used to store an amount of GLP but now stores an amount of USDC. If the logic contract behind the proxy is upgraded before this storage slot value is changed, a well-timed attack may be able to take advantage of the incorrect value. Similarly, the deprecated variables should be set to zero before the upgrade. While roundGlpDepositPending is already set to zero, the private bypass variable is not, so setBypass() should be called before the upgrade, otherwise the variable will remain set. batchingManager in 
15. Use updated solmate import Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Consider replacing the outdated reference in package.json and multiple solidity files to use the current location of the solmate library. This will help to ensure the latest bug fixes and improvements are used. 
16. Possible mulDivDown confusion Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Consider renaming the custom mulDivDown() implementation to indicate the first argument is a int256, not a uint256 like the solmate implementation of mulDivDown(). One place where this ambiguity may cause confusion is this line. Solidity will prevent an underflow from happening, so the solmate implementation will be used if no revert happens, but should an underflow be allowed here with unchecked to allow the custom implementation to be used? 
17. Unnecessary operations Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: This line unnecessarily casts netSlippage to uint256 when it is already of that type. This line emits an event with the constant value of address(0). Because this event is used in only this one location, there is no point in this event taking a constant value. 
18. Change variable name Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The variables name unhedgedGlp is used in two places in DnGmxJuniorVaultManager. Only the second case of this variable actually refers to the exact value of unhedged GLP maintained by Rage Trade, while the first case actually refers to the target amount of unhedged GLP that the protocol should rebalance to. 
19. Missing NatSpec comments Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Several variables and functions could benefit from improved NatSpec: depositCap: add the comment "Maximum USDC that can be deposited in one round" depositCap: add the comment "Maximum sGLP that can be deposited in one round" depositUsdc(), executeBatch(), claimAndRedeem(), rescueFees(), and all internal functions are missing NatSpec in DnGmxBatchingManager.sol. batchingManager variable in State struct should be marked as deprecated because batching manager integration was removed. _getBorrowValue() should have a comment to specify the return value is in USDC not USD 
20. Typos in comments Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: These typos were found in comments: cooldowm -> cooldown depoists -> deposits roudn -> round accumuated -> accumulated mangager -> manager cooldowm -> cooldown depoists -> deposits roudn -> round accumuated -> accumulated flase -> false (found here, here, here, and here) glp price in usd -> glp price in usdc (found here and here) againts -> against assests -> assets retunrs -> returns 
