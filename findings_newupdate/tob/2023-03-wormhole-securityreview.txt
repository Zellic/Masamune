1. Lack of doc comments Severity: Informational Diﬃculty: High Type: Patching Finding ID: TOB-WORMGUWA-1 Target: node/pkg/governor/governor.go, various source ﬁles in node/pkg/watchers Description Publicly accessible functions within the governor and watcher code generally lack doc comments. Inadequately documented code can be misunderstood, which increases the likelihood of an improper bug ﬁx or a mis-implemented feature. There are ten publicly accessible functions within governor.go. However, only one such function has a comment preceding it (see ﬁgure 1.1). // Returns true if the message can be published, false if it has been added to the pending list. func (gov *ChainGovernor) ProcessMsg(msg *common.MessagePublication) bool { Figure 1.1: node/pkg/governor/governor.go#L281–L282 Similarly, there are at least 28 publicly accessible functions among the non-evm watchers. However, only seven of them are preceded by doc comments, and only one of the seven is not in the Near watcher code (see ﬁgure 1.2). // GetLatestFinalizedBlockNumber() returns the latest published block. func (s *SolanaWatcher) GetLatestFinalizedBlockNumber() uint64 { Figure 1.2: node/pkg/watchers/solana/client.go#L846–L847 Go’s oﬃcial documentation on doc comments states the following: A func’s doc comment should explain what the function returns or, for functions called for side eﬀects, what it does. Exploit Scenario Alice, a Wormhole developer, implements a new node feature involving the governor. Alice misunderstands how the functions called by her new feature work. Alice introduces a vulnerability into the node as a result. Recommendations Short term, add doc comments to each function that are accessible from outside of the package in which the function is deﬁned. This will facilitate code review and reduce the likelihood that a developer introduces a bug into the code because of a misunderstanding. Long term, regularly review code comments to ensure they are accurate. Documentation must be kept up to date to be beneﬁcial. References ● Go Doc Comments 
2. Fields protected by mutex are not documented Severity: Informational Diﬃculty: High Type: Patching Finding ID: TOB-WORMGUWA-2 Target: node/pkg/governor/governor.go Description The ﬁelds protected by the governor’s mutex are not documented. A developer adding functionality to the governor is unlikely to know whether the mutex must be locked for their application. The ChainGovernor struct appears in ﬁgure 2.1. The Wormhole Foundation communicated to us privately that the mutex protects the ﬁelds highlighted in yellow. Note that, because there are 13 ﬁelds in ChainGovernor (not counting the mutex itself), the likelihood of a developer guessing exactly the set of highlighted ﬁelds is small. type ChainGovernor struct { db logger mutex tokens tokensByCoinGeckoId chains msgsSeen db.GovernorDB *zap.Logger sync.Mutex map[tokenKey]*tokenEntry map[string][]*tokenEntry map[vaa.ChainID]*chainEntry map[string]bool // Key is hash, payload is consts transferComplete and transferEnqueued. []*common.MessagePublication int string int msgsToPublish dayLengthInMinutes coinGeckoQuery env nextStatusPublishTime time.Time nextConfigPublishTime time.Time statusPublishCounter int64 configPublishCounter int64 } Figure 2.1: node/pkg/governor/governor.go#L119–L135 Exploit Scenario Alice, a Wormhole developer, adds a new function to the governor. ● Case 1: Alice does not lock the mutex, believing that her function operates only on ﬁelds that are not protected by the mutex. However, by not locking the mutex, Alice introduces a race condition into the governor. ● Case 2: Alice locks the mutex “just to be safe.” However, the ﬁelds on which Alice’s function operates are not protected by the mutex. Alice introduces a deadlock into the code as a result. Recommendations Short term, document the ﬁelds within ChainGovernor that are protected by the mutex. This will reduce the likelihood that a developer incorrectly locks, or does not lock, the mutex. Long term, regularly review code comments to ensure they are accurate. Documentation must be kept up to date to be beneﬁcial. 
3. Potential nil pointer dereference in reloadPendingTransfer Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-WORMGUWA-3 Target: node/pkg/governor/governor_db.go Description A potential nil pointer dereference exists in reloadPendingTransfer. The bug could be triggered if invalid data were stored within a node’s database, and could make it impossible to restart the node. The relevant code appears in ﬁgures 3.1 and 3.2 When DecodeTransferPayloadHdr returns an error, the payload that is also returned is used to construct the error message (ﬁgure 3.1). However, as shown in ﬁgure 3.2, the returned payload can be nil. payload, err := vaa.DecodeTransferPayloadHdr(msg.Payload) if err != nil { gov.logger.Error("cgov: failed to parse payload for reloaded pending transfer, dropping it", zap.String("MsgID", msg.MessageIDString()), zap.Stringer("TxHash", msg.TxHash), zap.Stringer("Timestamp", msg.Timestamp), zap.Uint32("Nonce", msg.Nonce), zap.Uint64("Sequence", msg.Sequence), zap.Uint8("ConsistencyLevel", msg.ConsistencyLevel), zap.Stringer("EmitterChain", msg.EmitterChain), zap.Stringer("EmitterAddress", msg.EmitterAddress), zap.Stringer("tokenChain", payload.OriginChain), zap.Stringer("tokenAddress", payload.OriginAddress), zap.Error(err), ) return } Figure 3.1: node/pkg/governor/governor_db.go#L90–L106 func DecodeTransferPayloadHdr(payload []byte) (*TransferPayloadHdr, error) { if !IsTransfer(payload) { return nil, fmt.Errorf("unsupported payload type") } Figure 3.2: sdk/vaa/structs.go#L962–L965 Exploit Scenario Eve ﬁnds a code path that allows her to store erroneous payloads within the database of Alice’s node. Alice is unable to restart her node, as it tries to dereference a nil pointer on each attempt. Recommendations Short term, either eliminate the use of payload when constructing the error message, or verify that the payload is not nil before attempting to dereference it. This will eliminate a potential nil pointer dereference. Long term, add tests to exercise additional error paths within governor_db.go. This could help to expose bugs like this one. 
4. Unchecked type assertion in queryCoinGecko Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-WORMGUWA-4 Target: node/pkg/governor/governor_prices.go Description The code that processes CoinGecko responses contains an unchecked type assertion. The bug is triggered when CoinGecko returns invalid data, and could be exploited for denial of service (DoS). The relevant code appears in ﬁgure 4.1. The data object that is returned as part of CoinGecko’s response to a query is cast to a map m of type map[string]interface{} (yellow). However, the cast’s success is not veriﬁed. As a result, a nil pointer dereference can occur when m is accessed (red). m := data.(map[string]interface{}) if len(m) != 0 { var ok bool price, ok = m["usd"].(float64) if !ok { to configured price for this token", zap.String("coinGeckoId", coinGeckoId)) gov.logger.Error("cgov: failed to parse coin gecko response, reverting // By continuing, we leave this one in the local map so the price will get reverted below. continue } } Figure 4.1: node/pkg/governor/governor_prices.go#L144–L153 Note that if the access to m is successful, the resulting value is cast to a float64. In this case, the cast’s success is veriﬁed. A similar check should be performed for the earlier cast. Exploit Scenario Eve, a malicious insider at CoinGecko, sends invalid data to Wormhole nodes, causing them to crash. Recommendations Short term, in the code in ﬁgure 4.1, verify that the cast in yellow is successful by adding a check similar to the one highlighted in green. This will eliminate the possibility of a node crashing because CoinGecko returns invalid data. Long term, consider enabling the forcetypeassert lint in CI. This bug was initially ﬂagged by that lint, and then conﬁrmed by our queryCoinGecko response fuzzer. Enabling the lint could help to expose additional bugs like this one. 
5. Governor relies on a single external source of truth for asset prices Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-WORMGUWA-5 Target: node/pkg/governor/governor_prices.go Description The governor relies on a single external source (CoinGecko) for asset prices, which could enable an attacker to transfer more than they would otherwise be allowed. The governor fetches an asset’s price from CoinGecko, compares the price to a hard-coded default, and uses whichever is larger (ﬁgure 5.1). However, if an asset’s price were to grow much larger than the hard-coded default, the hard-coded default would essentially be meaningless, and CoinGecko would become the sole source of truth for the price of that asset. Such a situation could be problematic, for example, if the asset’s price were volatile and CoinGecko had trouble keeping up with the price changes. // We should use the max(coinGeckoPrice, configuredPrice) as our price for computing notional value. func (te tokenEntry) updatePrice() { if (te.coinGeckoPrice == nil) || (te.coinGeckoPrice.Cmp(te.cfgPrice) < 0) { te.price.Set(te.cfgPrice) } else { te.price.Set(te.coinGeckoPrice) } } Figure 5.1: node/pkg/governor/governor_prices.go#L205–L212 Exploit Scenario Eve obtains a large quantity of AliceCoin from a hack. AliceCoin’s price is both highly volatile and much larger than what was hard-coded in the last Wormhole release. CoinGecko has trouble keeping up with the current price of AliceCoin. Eve identiﬁes a point in time when the price that CoinGecko reports is low (but still higher than the hard-coded default). Eve uses the opportunity to move more of her maliciously obtained AliceCoin than Wormhole would allow if CoinGecko had reported the correct price. Recommendations Short term, monitor the price of assets supported by Wormhole. If the price of an asset increases substantially, consider issuing a release that takes into account the new price. This will help to avoid situations where CoinGecko becomes the sole source of truth of the price of an asset. Long term, incorporate additional price oracles besides CoinGecko. This will provide more robust protection than requiring a human to monitor prices and issue point releases. 
6. Potential resource leak Severity: Informational Diﬃculty: High Type: Denial of Service Finding ID: TOB-WORMGUWA-6 Target: node/pkg/watchers/evm/watcher.go Description Calls to some Contexts’ cancel functions are missing along certain code paths involving panics. If an attacker were able to exercise these code paths in rapid succession, they could exhaust system resources and cause a DoS. Within watcher.go, WithTimeout is essentially used in one of two ways, using the pattern shown in either ﬁgure 6.1 or 6.2. The pattern of ﬁgure 6.1 is problematic because cancel will not be called if a panic occurs in MessageEventsForTransaction. By comparison, cancel will be called if a panic occurs after the defer statement in ﬁgure 6.2. Note that if a panic occurred in either ﬁgure 6.1 or 6.2, RunWithScissors (ﬁgure 6.3) would prevent the program from terminating. timeout, cancel := context.WithTimeout(ctx, 5*time.Second) blockNumber, msgs, err := MessageEventsForTransaction(timeout, w.ethConn, w.contract, w.chainID, tx) cancel() Figure 6.1: node/pkg/watchers/evm/watcher.go#L395–L397 timeout, cancel := context.WithTimeout(ctx, 15*time.Second) defer cancel() Figure 6.2: node/pkg/watchers/evm/watcher.go#L186–L187 // Start a go routine with recovering from any panic by sending an error to a error channel func RunWithScissors(ctx context.Context, errC chan error, name string, runnable supervisor.Runnable) { ScissorsErrors.WithLabelValues("scissors", name).Add(0) go func() { defer func() { if r := recover(); r != nil { switch x := r.(type) { case error: errC <- fmt.Errorf("%s: %w", name, x) default: errC <- fmt.Errorf("%s: %v", name, x) } ScissorsErrors.WithLabelValues("scissors", name).Inc() } }() err := runnable(ctx) if err != nil { errC <- err } }() } Figure 6.3: node/pkg/common/scissors.go#L20–L41 Golang’s oﬃcial Context documentation states: The WithCancel, WithDeadline, and WithTimeout functions take a Context (the parent) and return a derived Context (the child) and a CancelFunc. … Failing to call the CancelFunc leaks the child and its children until the parent is canceled or the timer ﬁres. … In light of the above guidance, it seems prudent to call the cancel function, even along panicking paths. Note that the problem described applies to three locations in watch.go: one involving a call to MessageEventsForTransaction (ﬁgure 6.1), one involving a call to TimeOfBlockByHash, and one involving a call to TransactionReceipt. Exploit Scenario Eve discovers a code path she can call in rapid succession, which induces a panic in the call to MessageEventsForTransaction (ﬁgure 6.1). Eve exploits this code path to crash Wormhole nodes. Recommendations Short term, use the defer cancel() pattern (ﬁgure 6.2) wherever WithTimeout is used. This will help to prevent DoS conditions. Long term, regard all code involving Contexts with heightened scrutiny. Contexts are frequently a source of resource leaks in Go programs, and deserve elevated attention. References ● Golang Context WithTimeout Example 
7. PolygonConnector does not properly use channels Severity: Undetermined Diﬃculty: Undetermined Type: Timing Finding ID: TOB-WORMGUWA-7 Target: node/pkg/watchers/evm/connectors/polygon.go Description The Polygon connector does not read from the PollSubscription.quit channel, nor does it write to the PollSubscription.unsubDone channel. A caller who calls Unsubscribe on the PollSubscription could hang. A PollSubscription struct contains three channels: err, quit, and unsubDone (ﬁgure 7.1). Based on our understanding of the code, the entity that fulﬁlls the subscription writes to the err and unsubDone channels, and reads from the quit channel. Conversely, the entity that consumes the subscription reads from the err and unsubDone channels, and writes to the quit channel.1 type PollSubscription struct { errOnce err quit unsubDone chan struct{} sync.Once chan error chan error } Figure 7.1: node/pkg/watchers/evm/connectors/common.go#L38–L43 More speciﬁcally, the consumer can call PollSubscription.Unsubscribe, which writes ErrUnsubscribed to the quit channel and waits for a message on the unsubDone channel (ﬁgure 7.2). func (sub *PollSubscription) Unsubscribe() { sub.errOnce.Do(func() { select { case sub.quit <- ErrUnsubscribed: <-sub.unsubDone case <-sub.unsubDone: } close(sub.err) }) } Figure 7.2: node/pkg/watchers/evm/connectors/common.go#L59–L68 1 If our understanding is correct, we recommend documenting these facts. However, the Polygon connector does not read from the quit channel, nor does it write to the unsubDone channel (ﬁgure 7.3). This is unlike BlockPollConnector (ﬁgure 7.4), for example. Thus, if a caller tries to call Unsubscribe on the Polygon connector PollSubscription, the caller may hang. select { case <-ctx.Done(): return nil case err := <-messageSub.Err(): sub.err <- err case checkpoint := <-messageC: if err := c.processCheckpoint(ctx, sink, checkpoint); err != nil { sub.err <- fmt.Errorf("failed to process checkpoint: %w", err) } } Figure 7.3: node/pkg/watchers/evm/connectors/polygon.go#L120–L129 select { case <-ctx.Done(): blockSub.Unsubscribe() innerErrSub.Unsubscribe() return nil case <-sub.quit: blockSub.Unsubscribe() innerErrSub.Unsubscribe() sub.unsubDone <- struct{}{} return nil case v := <-innerErrSink: sub.err <- fmt.Errorf(v) } Figure 7.4: node/pkg/watchers/evm/connectors/poller.go#L180–L192 Exploit Scenario Alice, a Wormhole developer, adds a code path that involves calling Unsubscribe on a Polygon connector’s PollSubscription. By doing so, Alice introduces a deadlock into the code. Recommendations Short term, adjust the code in ﬁgure 7.3 so that it reads from the quit channel and writes to the unsubDone channel, similar to how the code in ﬁgure 7.4 does. This will eliminate a class of code paths along which hangs or deadlocks could occur. Long term, consider refactoring the code so that the select statements in ﬁgures 7.3 and 7.4, as well as a similar statement in LogPollConnector, are consolidated under a single function. The three statements appear similar in their behavior; combining them would make the code more robust against future changes and could help to prevent bugs like this one. 
8. Receiver closes channel, contradicting Golang guidance Severity: Undetermined Diﬃculty: Undetermined Type: Timing Finding ID: TOB-WORMGUWA-8 Target: node/pkg/watchers/evm/connectors/common.go Description According to Golang’s oﬃcial guidance, “Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.” However, along some code paths within the watcher code, the receiver of a channel closes the channel. When PollSubscription.Unscbscribe is called, it closes the err channel (ﬁgure 8.1). However, in logpoller.go (ﬁgure 8.2), the caller of Unsubscribe (red) is clearly an err channel receiver (green). func (sub *PollSubscription) Err() <-chan error { return sub.err } func (sub *PollSubscription) Unsubscribe() { sub.errOnce.Do(func() { select { case sub.quit <- ErrUnsubscribed: <-sub.unsubDone case <-sub.unsubDone: } close(sub.err) }) } Figure 8.1: node/pkg/watchers/evm/connectors/common.go#L55–L68 sub, err := l.SubscribeForBlocks(ctx, errC, blockChan) if err != nil { return err } defer sub.Unsubscribe() supervisor.Signal(ctx, supervisor.SignalHealthy) for { select { case <-ctx.Done(): return ctx.Err() case err := <-sub.Err(): return err case err := <-errC: return err case block := <-blockChan: if err := l.processBlock(ctx, logger, block); err != nil { l.errFeed.Send(err.Error()) } } } Figure 8.2: node/pkg/watchers/evm/connectors/logpoller.go#L49–L69 Exploit Scenario Eve discovers a code path along which a sender tries to send to an already closed err channel and panics. RunWithScissors (see TOB-WORMGUWA-6) prevents the node from terminating, but the node is left in an undetermined state. Recommendations Short term, eliminate the call to close in ﬁgure 8.1. This will eliminate a class of code paths along which the err channel’s sender(s) could panic. Long term, for each channel, document who the expected senders and receivers are. This will help catch bugs like this one. References ● A Tour of Go: Range and Close 
9. Watcher conﬁguration is overly complex Severity: Informational Diﬃculty: Medium Type: Data Validation Finding ID: TOB-WORMGUWA-9 Target: node/pkg/watchers/evm/watcher.go Description The Run function of the Watcher conﬁgures each chain’s connection based on its ﬁelds, unsafeDevMode and chainID. This is done in a series of nested if-statements that span over 100 lines, amounting to a cyclomatic complexity over 90 which far exceeds what is considered complex. In order to make the code easier to understand, test, and maintain, it should be refactored. Rather than handling all of the business logic in a monolithic function, the logic for each chain should be isolated within a dedicated helper function. This would make the code easier to follow and reduce the likelihood that an update to one chain’s conﬁguration inadvertently introduces a bug for other chains. if w.chainID == vaa.ChainIDCelo && !w.unsafeDevMode { // When we are running in mainnet or testnet, we need to use the Celo ethereum library rather than go-ethereum. // However, in devnet, we currently run the standard ETH node for Celo, so we need to use the standard go-ethereum. w.ethConn, err = connectors.NewCeloConnector(timeout, w.networkName, w.url, w.contract, logger) if err != nil { ethConnectionErrors.WithLabelValues(w.networkName, "dial_error").Inc() p2p.DefaultRegistry.AddErrorCount(w.chainID, 1) return fmt.Errorf("dialing eth client failed: %w", err) } } else if useFinalizedBlocks { if w.chainID == vaa.ChainIDEthereum && !w.unsafeDevMode { safeBlocksSupported = true logger.Info("using finalized blocks, will publish safe blocks") } else { logger.Info("using finalized blocks") } [...] /* many more nested branches */ Figure 9.1: node/pkg/watchers/evm/watcher.go#L192–L326 Exploit Scenario Alice, a wormhole developer, introduces a bug that causes guardians to run in unsafe mode in production while adding support for a new evm chain due to the diﬃculty of modifying and testing the nested code. Recommendations Short term, isolate each chain’s conﬁguration into a helper function and document how the conﬁgurations were determined. Long term, run linters in CI to identify code with high cyclomatic complexity and consider whether complex code can be simpliﬁed during code reviews. 
10. evm.Watcher.Run’s default behavior could hide bugs Severity: Informational Diﬃculty: High Type: Patching Finding ID: TOB-WORMGUWA-10 Target: node/{cmd/guardiand/node.go, pkg/watchers/evm/watcher.go} Description evm.Watcher.Run tries to create an evm watcher, even if called with a ChainID that does not correspond to an evm chain. Additional checks should be added to evm.Watcher.Run to reject such ChainIDs. Approximately 60 watchers are started in node/cmd/guardiand/node.go (ﬁgure 10.1). Fifteen of those starts result in calls to evm.Watcher.Run. Given the substantial number of ChainIDs, one can imagine a bug where a developer tries to create an evm watcher with a ChainID that is not for an evm chain. Such a ChainID would be handled by the blanket else in ﬁgure 10.2, which tries to create an evm watcher. Such behavior could allow the bug to go unnoticed. To avoid this possibility, evm.Watcher.Run’s default behavior should be to fail rather than to create a watcher. if shouldStart(ethRPC) { ... ethWatcher = evm.NewEthWatcher(*ethRPC, ethContractAddr, "eth", common.ReadinessEthSyncing, vaa.ChainIDEthereum, chainMsgC[vaa.ChainIDEthereum], setWriteC, chainObsvReqC[vaa.ChainIDEthereum], *unsafeDevMode) ... } if shouldStart(bscRPC) { ... bscWatcher := evm.NewEthWatcher(*bscRPC, bscContractAddr, "bsc", common.ReadinessBSCSyncing, vaa.ChainIDBSC, chainMsgC[vaa.ChainIDBSC], nil, chainObsvReqC[vaa.ChainIDBSC], *unsafeDevMode) ... } if shouldStart(polygonRPC) { ... polygonWatcher := evm.NewEthWatcher(*polygonRPC, polygonContractAddr, "polygon", common.ReadinessPolygonSyncing, vaa.ChainIDPolygon, chainMsgC[vaa.ChainIDPolygon], nil, chainObsvReqC[vaa.ChainIDPolygon], *unsafeDevMode) } ... Figure 10.1: node/cmd/guardiand/node.go#L1065–L1104 ... } else if w.chainID == vaa.ChainIDOptimism && !w.unsafeDevMode { ... } else if w.chainID == vaa.ChainIDPolygon && w.usePolygonCheckpointing() { ... } else { w.ethConn, err = connectors.NewEthereumConnector(timeout, w.networkName, w.url, w.contract, logger) if err != nil { ethConnectionErrors.WithLabelValues(w.networkName, "dial_error").Inc() p2p.DefaultRegistry.AddErrorCount(w.chainID, 1) return fmt.Errorf("dialing eth client failed: %w", err) } } Figure 10.2: node/pkg/watchers/evm/watcher.go#L192–L326 Exploit Scenario Alice, a Wormhole developer, introduces a call to NewEvmWatcher with a ChainID that is not for an evm chain. evm.Watcher.Run accepts the invalid ChainID, and the error goes unnoticed. Recommendations Short term, rewrite evm.Watcher.Run so that a new watcher is created only when a ChainID for an evm chain is passed. When a ChainID for some other chain is passed, evm.Watcher.Run should return an error. Adopting such a strategy will help protect against bugs in node/cmd/guardiand/node.go. Long term: ● Add tests to the guardiand package to verify that the right watcher is created for each ChainID. This will help ensure the package’s correctness. ● Consider whether TOB-WORMGUWA-9’s recommendations should also apply to node/cmd/guardiand/node.go. That is, consider whether the watcher conﬁguration should be handled in node/cmd/guardiand/node.go, as opposed to evm.Watcher.Run. The ﬁle node/cmd/guardiand/node.go appears to suﬀer from similar complexity issues. It is possible that a single strategy could address the shortcomings of both pieces of code. 
11. Race condition in TestBlockPoller Severity: Informational Diﬃculty: Medium Type: Timing Finding ID: TOB-WORMGUWA-11 Target: node/pkg/watchers/evm/connectors/poller_test.go Description A race condition causes TestBlockPoller to fail sporadically with the error message in ﬁgure 11.1. For a test to be of value, it must be reliable. poller_test.go:300: Error Trace: Error: .../node/pkg/watchers/evm/connectors/poller_test.go:300 Received unexpected error: polling encountered an error: failed to look up latest block: RPC failed Test: TestBlockPoller Figure 11.1: Error produced when TestBlockPoller fails A potential code interleaving causing the above error appears in ﬁgure 11.2. The interleaving can be explained as follows: ● The main thread sets the baseConnector’s error and yields (left column). ● The go routine declared at poller_test.go:189 retrieves the error, sets the err variable, loops, retrieves the error a second time, and yields (right column). ● The main thread locks the mutex, veriﬁes that err is set, clears err, and unlocks the mutex (left). ● The go routine sets the err variable a second time (right). ● The main thread locks the mutex and panics because err is set (left). baseConnector.setError(fmt.Errorf("RPC failed")) case thisErr := <-headerSubscription.Err(): mutex.Lock() err = thisErr mutex.Unlock() ... case thisErr := <-headerSubscription.Err(): time.Sleep(10 * time.Millisecond) mutex.Lock() require.Equal(t, 1, pollerStatus) assert.Error(t, err) assert.Nil(t, block) baseConnector.setError(nil) err = nil mutex.Unlock() // Post the next block and verify we get it (so we survived the RPC error). baseConnector.setBlockNumber(0x309a10) time.Sleep(10 * time.Millisecond) mutex.Lock() require.Equal(t, 1, pollerStatus) require.NoError(t, err) mutex.Lock() err = thisErr mutex.Unlock() Figure 11.2: Interleaving of node/pkg/watchers/evm/connectors/poller_test.go#L283–L300 (left) and node/pkg/watchers/evm/connectors/poller_test.go#L198–L201 (right) that causes an error Exploit Scenario Alice, a Wormhole developer, ignores TestBlockPoller failures because she believes the test to be ﬂaky. In reality, the test is ﬂagging a bug in Alice’s code, which she commits to the Wormhole repository. Recommendations Short term: ● Use diﬀerent synchronization mechanisms in order to eliminate the race condition described above. This will increase TestBlockPoller’s reliability. ● Have the main thread sleep for random rather than ﬁxed intervals. This will help to expose bugs like this one. Long term, investigate automated tools for ﬁnding concurrency bugs in Go programs. This bug is not ﬂagged by Go’s race detector. As a result, diﬀerent analyses are needed. 
12. Unconventional test structure Severity: Informational Diﬃculty: High Type: Testing Finding ID: TOB-WORMGUWA-12 Target: Various source ﬁles in node/pkg/watchers Description Tilt is the primary means of testing Wormhole watchers. Relying on such a coarse testing mechanism makes it diﬃcult to know that all necessary conditions and edge cases are tested. The following are some conditions that should be checked by native Go unit tests: ● The right watcher is created for each ChainID (TOB-WORMGUWA-10). ● The evm watchers’ connectors behave correctly (similar to how the evm ﬁnalizers’ correct behavior is now tested).2 ● The evm watchers’ logpoller behaves correctly (similar to how the poller’s correct behavior is now tested by poller_test.go). ● There are no oﬀ-by-one errors in any inequality involving a block or round number. Examples of such inequalities include the following: ○ node/pkg/watchers/algorand/watcher.go#L225 ○ node/pkg/watchers/algorand/watcher.go#L243 ○ node/pkg/watchers/solana/client.go#L363 ○ node/pkg/watchers/solana/client.go#L841 To be clear, we are not suggesting that the Tilt tests be discarded. However, the Tilt tests should not be the sole means of testing the watchers for any given chain. Exploit Scenario Alice, a Wormhole developer, introduces a bug into the codebase. The bug is not exposed by the Tilt tests. Recommendations Short term, develop unit tests for the watcher code. Get as close to 100% code coverage as possible. Develop speciﬁc unit tests for conditions that seem especially problematic. These steps will help ensure the correctness of the watcher code. 2 Note that the evm watchers’ ﬁnalizers have nearly 100% code coverage by unit tests. Long term, regularly review test coverage to help identify gaps in the tests as the code evolves. 
13. Vulnerable Go packages Severity: Undetermined Diﬃculty: Undetermined Type: Patching Finding ID: TOB-WORMGUWA-13 Target: node/go.mod Description govulncheck reports that the packages used by Wormhole in table 13.1 have known vulnerabilities, which are described in the following table. Package Vulnerability Description excerpt path/filepath GO-2023-1568 A path traversal vulnerability exists in ﬁlepath.Clean on Windows. … mime/multipart GO-2023-1569 A denial of service is possible from excessive resource consumption in net/http and mime/multipart. … crypto/tls GO-2023-1570 Large handshake records may cause panics in crypto/tls. … golang.org/x/net GO-2023-1571 A maliciously crafted HTTP/2 stream could cause excessive CPU consumption in the HPACK decoder, suﬃcient to cause a denial of service from a small number of small requests. Table 13.1: Vulnerabilities in dependencies reported by govulncheck Exploit Scenario Eve discovers an exploitable code path involving one of the vulnerabilities in table 13.1 and uses it to crash Wormhole nodes. Recommendations Short term, update Wormhole to Go version 1.20.1. This will mitigate all of the vulnerabilities in table 13.1, according to the vulnerability descriptions. Long term, run govulncheck as part of Wormhole’s CI process. This will help to identify vulnerable dependencies as they arise. References ● Vulnerability Management for Go 
14. Wormhole node does not build with latest Go version Severity: Informational Diﬃculty: High Type: Patching Finding ID: TOB-WORMGUWA-14 Target: Various source ﬁles Description Attempting to build a Wormhole node with the latest Go version (1.20.1) produces the error in ﬁgure 14.1. Go’s release policy states, “Each major Go release is supported until there are two newer major releases.” By not building with the latest Go version, Wormhole’s ability to receive updates will expire. cannot use "The version of quic-go you're using can't be built on Go 1.20 yet. For more details, please see https://github.com/lucas-clemente/quic-go/wiki/quic-go-and-Go-versions." (untyped string constant "The version of quic-go you're using can't be built on Go 1.20 yet. F...) as int value in variable declaration Figure 14.1: Error produced when one tries to build the Wormhole with the latest Go version (1.20) It is unclear when Go 1.21 will be released. Go 1.20 was released on February 1, 2023 (a few days prior to the start of the audit), and new versions appear to be released about every six months. We found a thread discussing Go 1.21, but it does not mention dates. Exploit Scenario Alice attempts to build a Wormhole node with Go version 1.20. When her attempt fails, Alice switches to Go version 1.19. Go 1.21 is released, and Go 1.19 ceases to receive updates. A vulnerability is found in a Go 1.19 package, and Alice is left vulnerable. Recommendations Short term, adapt the code so that it builds with Go version 1.20. This will allow Wormhole to receive updates for a greater period of time than if it builds only with Go version 1.19. Long term, test with the latest Go version in CI. This will help identify incompatibilities like this one sooner. References ● Go Release History (see Release Policy) ● Planning Go 1. 
15. Missing or wrong context Severity: Low Type: Timing Diﬃculty: High Finding ID: TOB-WORMGUWA-15 Target: node/pkg/watchers/{algorand, cosmwasm, sui, wormchain}/ watcher.go Description In several places where a Context is required, the Wormhole node creates a new background Context rather than using the passed-in Context. If the passed-in Context is canceled or times out, a go routine using the background Context will not detect this, and resources will be leaked. The aforementioned problem is ﬂagged by the contextcheck lint. For each of the locations named in ﬁgure 15.1, a Context is passed in to the enclosing function, but the passed-in Context is not used. Rather, a new background Context is created. algorand/watcher.go:172:51: Non-inherited new context, use function like `context.WithXXX` instead (contextcheck) status, err := algodClient.StatusAfterBlock(0).Do(context.Background()) ^ algorand/watcher.go:196:139: Non-inherited new context, use function like `context.WithXXX` instead (contextcheck) result, err := indexerClient.SearchForTransactions().TXID(base32.StdEncoding.WithPadding(base32.NoP adding).EncodeToString(r.TxHash)).Do(context.Background()) ^ algorand/watcher.go:205:42: Non-inherited new context, use function like `context.WithXXX` instead (contextcheck) block, err := algodClient.Block(r).Do(context.Background()) ^ Figure 15.1: Warnings produced by contextcheck A closely related problem is ﬂagged by the noctx lint. In each of the locations named in ﬁgure 15.2, http.Get or http.Post is used. These functions do not take a Context argument. As such, if the Context passed in to the enclosing function is canceled, the Get or Post will not similarly be canceled. cosmwasm/watcher.go:198:28: (*net/http.Client).Get must not be called (noctx) resp, err := client.Get(fmt.Sprintf("%s/%s", e.urlLCD, e.latestBlockURL)) ^ cosmwasm/watcher.go:246:28: (*net/http.Client).Get must not be called (noctx) resp, err := client.Get(fmt.Sprintf("%s/cosmos/tx/v1beta1/txs/%s", e.urlLCD, tx)) ^ sui/watcher.go:315:26: net/http.Post must not be called (noctx) resp, err := http.Post(e.suiRPC, "application/json", strings.NewReader(buf)) ^ sui/watcher.go:378:26: net/http.Post must not be called (noctx) strings.NewReader(`{"jsonrpc":"2.0", "id": 1, "method": "sui_getCommitteeInfo", "params": []}`)) resp, err := http.Post(e.suiRPC, "application/json", ^ wormchain/watcher.go:136:27: (*net/http.Client).Get must not be called (noctx) resp, err := client.Get(fmt.Sprintf("%s/blocks/latest", e.urlLCD)) Figure 15.2: Warnings produced by noctx ^ Exploit Scenario A bug causes Alice’s Algorand, Cosmwasm, Sui, or Wormchain node to hang. The bug triggers repeatedly. The connections from Alice’s Wormhole node to the respective blockchain nodes hang, causing unnecessary resource consumption. Recommendations Short term, take the following steps: ● For each location named in ﬁgure 15.1, use the passed-in Context rather than creating a new background Context. ● For each location named in ﬁgure 15.2, rewrite the code to use http.Client.Do. Taking these steps will help to prevent unnecessary resource consumption and potential denial of service. Long term, enable the contextcheck and notctx lints in CI. The problems highlighted in this ﬁnding were uncovered by those lints. Running them regularly could help to identify similar problems. References ● checkcontext ● noctx 
16. Use of defer in a loop Severity: Low Diﬃculty: High Type: Denial of Service Finding ID: TOB-WORMGUWA-16 Target: node/pkg/watchers/solana/client.go Description The Solana watcher uses defer within an inﬁnite loop (ﬁgure 16.1). Deferred calls are executed when their enclosing function returns. Since the enclosing loop is not exited under normal circumstances, the deferred calls are never executed and constitute a waste of resources. for { select { case <-ctx.Done(): return nil default: rCtx, cancel := context.WithTimeout(ctx, time.Second*300) // 5 minute defer cancel() ... } } Figure 16.1: node/pkg/watchers/solana/client.go#L244–L271 Sample code demonstrating the problem appears in appendix E. Exploit Scenario Alice runs her Wormhole node in an environment with constrained resources. Alice ﬁnds that her node is not able to achieve the same uptime as other Wormhole nodes. The underlying cause is resource exhaustion caused by the Solana watcher. Recommendations Short term, rewrite the code in ﬁgure 16.1 to eliminate the use of defer in the for loop. The easiest and most straightforward way would likely be to move the code in the default case into its own named function. Eliminating this use of defer in a loop will eliminate a potential source of resource exhaustion. Long term, regularly review uses of defer to ensure they do not appear in a loop. To the best of our knowledge, there are not publicly available detectors for problems like this. However, regular manual review should be suﬃcient to spot them. 
17. Finalizer is allowed to be nil Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-WORMGUWA-17 Target: node/pkg/watchers/evm/connectors/poller.go Description The conﬁguration of a chain’s watcher can allow a ﬁnalizer to be nil, which may allow newly introduced bugs to go unnoticed. Whenever a chain’s RPC does not have a notion of “safe” or “ﬁnalized” blocks, the watcher polls the chain for the latest block using BlockPollConnector. After fetching a block, the watcher checks whether it is “ﬁnal” in accordance with the respective chain’s PollFinalizer implementation. // BlockPollConnector polls for new blocks instead of subscribing when using SubscribeForBlocks. It allows to specify a // finalizer which will be used to only return finalized blocks on subscriptions. type BlockPollConnector struct { Connector time.Duration Delay useFinalized bool publishSafeBlocks bool finalizer blockFeed errFeed PollFinalizer ethEvent.Feed ethEvent.Feed } Figure 17.1: node/pkg/watchers/evm/connectors/poller.go#L24–L34 However, the method pollBlocks allows BlockPollConnector to have a nil PollFinalizer (see ﬁgure 17.2). This is unnecessary and may permit edge cases that could otherwise be avoided by requiring all BlockPollConnectors to use the DefaultFinalizer explicitly if a ﬁnalizer is not required (the default ﬁnalizer accepts all blocks as ﬁnal). This will ensure that the watcher does not incidentally process a block received from blockFeed that is not in the canonical chain . if b.finalizer != nil { finalized, err := b.finalizer.IsBlockFinalized(timeout, block) if err != nil { logger.Error("failed to check block finalization", zap.Uint64("block", block.Number.Uint64()), zap.Error(err)) finalization (%d): %w", block.Number.Uint64(), err) return lastPublishedBlock, fmt.Errorf("failed to check block } if !finalized { break } } b.blockFeed.Send(block) lastPublishedBlock = block Figure 17.2: node/pkg/watchers/evm/connectors/poller.go#L149–L164 Exploit Scenario A developer adds a new chain to the watcher using BlockPollConnector and forgets to add a PollFinalizer. Because a ﬁnalizer is not required to receive the latest blocks, transactions that were not included in the blockchain are considered valid, and funds are incorrectly transferred without corresponding deposits. Recommendations Short term, rewrite the block poller to require a ﬁnalizer. This makes the conﬁguration of the block poller explicit and clariﬁes that a DefaultFinalizer is being used, indicating that no extra validations are being performed. Long term, document the conﬁguration and assumptions of each chain. Then, see if any changes could be made to the code to clarify the developers’ intentions. 
