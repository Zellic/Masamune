1. Initialization functions can be front-run Severity: High Diﬃculty: High Type: Conﬁguration Finding ID: TOB-CMP-1 Target: Throughout the contracts Description The CrosslayerPortal contracts have initializer functions that can be front-run, allowing an attacker to incorrectly initialize the contracts. Due to the use of the delegatecall proxy pattern, these contracts cannot be initialized with their own constructors, and they have initializer functions: function initialize() public initializer { __Ownable_init(); __Pausable_init(); __ReentrancyGuard_init(); } Figure 1.1: The initialize function in MsgSender:126-130 An attacker could front-run these functions and initialize the contracts with malicious values. This issue aﬀects the following system contracts: ● contracts/core/BridgeAggregator ● contracts/core/InvestmentStrategyBase ● contracts/core/MosaicHolding ● contracts/core/MosaicVault ● contracts/core/MosaicVaultConfig ● contracts/core/functionCalls/MsgReceiverFactory ● contracts/core/functionCalls/MsgSender ● contracts/nfts/Summoner ● contracts/protocols/aave/AaveInvestmentStrategy ● contracts/protocols/balancer/BalancerV1Wrapper ● contracts/protocols/balancer/BalancerVaultV2Wrapper ● contracts/protocols/bancor/BancorWrapper ● contracts/protocols/compound/CompoundInvestmentStrategy ● contracts/protocols/curve/CurveWrapper ● contracts/protocols/gmx/GmxWrapper ● contracts/protocols/sushiswap/SushiswapLiquidityProvider ● contracts/protocols/synapse/ISynapseSwap ● contracts/protocols/synapse/SynapseWrapper ● contracts/protocols/uniswap/IUniswapV2Pair ● contracts/protocols/uniswap/UniswapV2Wrapper ● contracts/protocols/uniswap/UniswapWrapper Exploit Scenario Bob deploys the MsgSender contract. Eve front-runs the contract’s initialization and sets her own address as the owner address. As a result, she can use the initialize function to update the contract’s variables, modifying the system parameters. Recommendations Short term, to prevent front-running of the initializer functions, use hardhat-deploy to initialize the contracts or replace the functions with constructors. Alternatively, create a deployment script that will emit suﬃcient errors when an initialize call fails. Long term, carefully review the Solidity documentation, especially the “Warnings” section, as well as the pitfalls of using the delegatecall proxy pattern. 
2. Trades are vulnerable to sandwich attacks Severity: High Type: Timing Diﬃculty: Medium Finding ID: TOB-CMP-2 Target: CrossLayerPortal/core/nativeSwappers/MosaicNativeSwapperETH.sol , MosaicNativeSwapperAVAX.sol Description The swapToNative function does not allow users to specify the minAmountOut parameter of swapExactTokensForETH , which indicates the minimum amount of ETH that a user will receive from a trade. Instead, the value is hard-coded to zero, meaning that there is no guarantee that users will receive any ETH in exchange for their tokens. By using a bot to sandwich a user’s trade, an attacker could increase the slippage incurred by the user and proﬁt oﬀ of the spread at the user’s expense. The minAmountOut parameter is meant to prevent the execution of trades through illiquid pools and to provide protection against sandwich attacks. The current implementation lacks protections against high slippage and may cause users to lose funds. This applies to the AVAX version, too. Composable Finance indicated that only the relayer will call this function, but the function lacks access controls to prevent users from calling it directly. Importantly, it is highly likely that if a relayer does not implement proper protections, all of its trades will suﬀer from high slippage, as they will represent pure-proﬁt opportunities for sandwich bots. uint256 [] memory amounts = swapRouter.swapExactTokensForETH( _amount, 0 , path, _to, deadline ); Figure 2.1: Part of the SwapToNative function in MosaicNativeSwapperETH.sol: 44–50 Exploit Scenario Bob, a relayer, makes a trade on behalf of a user. The minAmountOut value is set to zero, which means that the trade can be executed at any price. As a result, when Eve sandwiches the trade with a buy and sell order, Bob sells the tokens without purchasing any, eﬀectively giving away tokens for free. Recommendations Short term, allow users (relayers) to input a slippage tolerance, and add access controls to the swapToNative function. Long term, consider the risks of integrating with other protocols such as Uniswap and implement mitigations for those risks. 
3. forwardCall creates a denial-of-service attack vector Severity: High Diﬃculty: Medium Type: Denial of Service Finding ID: TOB-CMP-3 Target: CrossLayerPortal/contracts/functionCalls/MsgReceiver.sol Description Low-level external calls can exhaust all available gas by returning an excessive amount of data, thereby causing the relayer to incur memory expansion costs. This can be used to cause an out-of-gas exception and is a denial-of-service (DoS) attack vector. Since arbitrary contracts can be called, Composable Finance should implement additional safeguards. If an out-of-gas exception occurs, the message will never be marked as forwarded ( forwarded[id] = true ). If the relayer repeatedly retries the transaction, assuming it will eventually be marked as forwarded, the queue of pending transactions will grow without bounds, with each unsuccessful message-forwarding attempt carrying a gas cost. The approveERC20TokenAndForwardCall function is also vulnerable to this DoS attack. (success, returnData) = _contract. call {value: msg.value }(_data); require (success, "Failed to forward function call" ); uint256 balance = IERC20(_feeToken).balanceOf( address ( this )); require ( balance >= _feeAmount, "Not enough tokens for the fee" ); forwarded[_id] = true ; Figure 3.1: Part of the forwardCall function in MsgReceiver:79-85 Exploit Scenario Eve deploys a contract that returns 10 million bytes of data. A call to that contract causes an out-of-gas exception. Since the transaction is not marked as forwarded, the relayer continues to propagate the transaction without success. This results in excessive resource consumption and a degraded quality of service. Recommendations Short term, require that the size of return data be ﬁxed to 32 bytes. Long term, review the documentation on low-level Solidity calls and EVM edge cases. References ● Excessively Safe Call 
8. Lack of two-step process for contract ownership changes Severity: High Diﬃculty: Low Type: Data Validation Finding ID: TOB-CMP-8 Target: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol Description The owner of a contract in the Composable Finance ecosystem can be changed through a call to the transferOwnership function. This function internally calls the setOwner function, which immediately sets the contract’s new owner. Making such a critical change in a single step is error-prone and can lead to irrevocable mistakes. /** * @dev Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner. */ function renounceOwnership () public virtual onlyOwner { _setOwner( address ( 0 )); } /** * @dev Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner. */ function transferOwnership ( address newOwner ) public virtual onlyOwner { require (newOwner != address ( 0 ), "Ownable: new owner is the zero address" ); _setOwner(newOwner); } function _setOwner ( address newOwner ) private { address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner); } Figure 8.1: OpenZeppelin’s OwnableUpgradeable contract Exploit Scenario Bob, a Composable Finance developer, invokes transferOwnership() to change the address of an existing contract’s owner but accidentally enters the wrong address. As a result, he permanently loses access to the contract. Recommendations Short term, perform ownership transfers through a two-step process in which the owner proposes a new address and the transfer is completed once the new address has executed a call to accept the role. Long term, identify and document all possible actions that can be taken by privileged accounts and their associated risks. This will facilitate reviews of the codebase and prevent future mistakes. 
9. sendFunds is vulnerable to reentrancy by owners Severity: High Type: Timing Diﬃculty: Low Finding ID: TOB-CMP-9 Target: CrosslayerPortal/contracts/PolygonReward/FundKeeper.sol Description The sendFunds function is vulnerable to reentrancy and can be used by the owner of a token contract to drain the contract of its funds. Speciﬁcally, because fundsTransfered[user] is written to after a call to an external contract, the contract’s owner could input his or her own address and reenter the sendFunds function to drain the contract’s funds. An owner could send funds to him- or herself without using the reentrancy, but there is no reason to leave this vulnerability in the code. Additionally, the FundKeeper contract can send funds to any user by calling setAmountToSend and then sendFunds . It is unclear why amountToSend is not changed (set to zero) after a successful transfer. It would make more sense to call setAmountToSend after each transfer and to store users’ balances in a mapping. function setAmountToSend ( uint256 amount ) external onlyOwner { amountToSend = amount; emit NewAmountToSend(amount); } function sendFunds ( address user ) external onlyOwner { require (!fundsTransfered[user], "reward already sent" ); require ( address ( this ).balance >= amountToSend, "Contract balance low" ); // solhint-disable-next-line avoid-low-level-calls ( bool sent , ) = user.call{value: amountToSend}( "" ); require (sent, "Failed to send Polygon" ); fundsTransfered[user] = true ; emit FundSent(amountToSend, user); } Figure 9.1: Part of the sendFunds function in FundKeeper.sol:23-38 Exploit Scenario Eve’s smart contract is the owner of the FundKeeper contract. Eve’s contract executes a transfer for which Eve should receive only 1 ETH. Instead, because the user address is a contract with a fallback function, Eve can reenter the sendFunds function and drain all ETH from the contract. Recommendations Short term, set fundsTransfered[user] to true prior to making external calls. Long term, store each user’s balance in a mapping to ensure that users cannot make withdrawals that exceed their balances. Additionally, follow the checks-eﬀects-interactions pattern. 
20. MosaicVault and MosaicHolding owner has excessive privileges Severity: High Diﬃculty: High Type: Access Controls Finding ID: TOB-CMP-20 Target: CrosslayerPortal Description The owner of the MosaicVault and MosaicHolding contracts has too many privileges across the system. Compromise of the owner’s private key would put the integrity of the underlying system at risk. The owner of the MosaicVault and MosaicHolding contracts can perform the following privileged operations in the context of the contracts: ● ● ● ● ● ● Rescuing funds if the system is compromised Managing withdrawals, transfers, and fee payments Pausing and unpausing the contracts Rebalancing liquidity across chains Investing in one or more investment strategies Claiming rewards from one or more investment strategies The ability to drain funds, manage liquidity, and claim rewards creates a single point of failure. It increases the likelihood that the contracts’ owner will be targeted by an attacker and increases the incentives for the owner to act maliciously. Exploit Scenario Alice, the owner of MosaicVault and MosaicHolding , deploys the contracts. MosaicHolding eventually holds assets worth USD 20 million. Eve gains access to Alice’s machine, upgrades the implementations, pauses MosaicHolding , and drains all funds from the contract. Recommendations Short term, clearly document the functions and implementations that the owner of the MosaicVault and MosaicHolding contracts can change. Additionally, split the privileges provided to the owner across multiple roles (e.g., a fund manager, fund rescuer, owner, etc.) to ensure that no one address has excessive control over the system. Long term, develop user documentation on all risks associated with the system, including those associated with privileged users and the existence of a single point of failure. 
24. SushiswapLiquidityProvider deposits cannot be used to cover withdrawal requests Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-CMP-24 Target: CrosslayerPortal/contracts/core/MosaicHolding.sol, CrosslayerPortal/contracts/protocols/sushiswap/SushiswapLiquidityPro vider.sol Description Withdrawal requests that require the removal of liquidity from a Sushiswap liquidity pool will revert and cause a system failure. When a user requests a withdrawal of liquidity from the Mosaic system, MosaicVault (via the coverWithdrawRequest() function) queries MosaicHolding to see whether liquidity must be removed from an investment strategy to cover the withdrawal amount (ﬁgure 24.1). function _withdraw ( address _accountTo , uint256 _amount , address _tokenIn , address _tokenOut , uint256 _amountOutMin , WithdrawData calldata _withdrawData, bytes calldata _data ) { internal onlyWhitelistedToken(_tokenIn) validAddress(_tokenOut) nonReentrant onlyOwnerOrRelayer whenNotPaused returns ( uint256 withdrawAmount ) IMosaicHolding mosaicHolding = IMosaicHolding(vaultConfig.getMosaicHolding()); require (hasBeenWithdrawn[_withdrawData.id] == false , "ERR: ALREADY WITHDRAWN" ); if (_tokenOut == _tokenIn) { require ( mosaicHolding.getTokenLiquidity(_tokenIn, _withdrawData.investmentStrategies) >= _amount, "ERR: VAULT BAL" ); } [...] mosaicHolding.coverWithdrawRequest( _withdrawData.investmentStrategies, _tokenIn, withdrawAmount ); [...] } Figure 24.1: The _ withdraw function in MosaicVault :40 4-474 If MosaicHolding ’s balance of the token being withdrawn ( _tokenIn ) is not suﬃcient to cover the withdrawal, MosaicHolding will iterate through each investment strategy in the _investmentStrategy array and remove enough _tokenIn to cover it. To remove liquidity from an investment strategy, it calls withdrawInvestment() on that strategy (ﬁgure 24.2). function coverWithdrawRequest ( address [] calldata _investmentStrategies, address _token , uint256 _amount ) external override { require (hasRole(MOSAIC_VAULT, msg.sender ), "ERR: PERMISSIONS A-V" ); uint256 balance = IERC20(_token).balanceOf( address ( this )); if (balance >= _amount) return ; uint256 requiredAmount = _amount - balance; uint8 index ; while (requiredAmount > 0 ) { address strategy = _investmentStrategies[index]; IInvestmentStrategy investment = IInvestmentStrategy(strategy); uint256 investmentAmount = investment.investmentAmount(_token); uint256 amountToWithdraw = 0 ; if (investmentAmount >= requiredAmount) { amountToWithdraw = requiredAmount; requiredAmount = 0 ; } else { amountToWithdraw = investmentAmount; requiredAmount = requiredAmount - investmentAmount; } IInvestmentStrategy.Investment[] memory investments = new IInvestmentStrategy.Investment[]( 1 ); investments[ 0 ] = IInvestmentStrategy.Investment(_token, amountToWithdraw); IInvestmentStrategy(investment).withdrawInvestment(investments, "" ); emit InvestmentWithdrawn(strategy, msg.sender ); index++; } require (IERC20(_token).balanceOf( address ( this )) >= _amount, "ERR: VAULT BAL" ); } Figure 24.2: The coverWithdrawRequest function in MosaicHolding:217-251 This process works for an investment strategy in which the investments array function argument has a length of 1. However, in the case of SushiswapLiquidityProvider , the withdrawInvestment() function expects the investments array to have a length of 2 (ﬁgure 24.3). function withdrawInvestment (Investment[] calldata _investments, bytes calldata _data) external override onlyInvestor nonReentrant { Investment memory investmentA = _investments[ 0 ]; Investment memory investmentB = _investments[ 1 ]; ( uint256 deadline , uint256 liquidity ) = abi.decode(_data, ( uint256 , uint256 )); IERC20Upgradeable pair = IERC20Upgradeable(getPair(investmentA.token, investmentB.token)); pair.safeIncreaseAllowance( address (sushiSwapRouter), liquidity); ( uint256 amountA , uint256 amountB ) = sushiSwapRouter.removeLiquidity( investmentA.token, investmentB.token, liquidity, investmentA.amount, investmentB.amount, address ( this ), deadline ); IERC20Upgradeable(investmentA.token).safeTransfer(mosaicHolding, amountA); IERC20Upgradeable(investmentB.token).safeTransfer(mosaicHolding, amountB); } Figure 24.3: The withdrawInvestment function in SushiswapLiquidityProvider :90-113 Thus, any withdrawal request that requires the removal of liquidity from SushiswapLiquidityProvider will revert. Exploit Scenario Alice wishes to withdraw liquidity ( tokenA ) that she deposited into the Mosaic system. The MosaicHolding contract does not hold enough tokenA to cover the withdrawal and thus tries to withdraw tokenA from the SushiswapLiquidityProvider investment strategy. The request reverts, and Alice’s withdrawal request fails, leaving her unable to access her funds. Recommendations Short term, avoid depositing user liquidity into the SushiswapLiquidityProvider investment strategy. Long term, take the following steps: ● ● Identify and implement one or more data structures that will reduce the technical debt resulting from the use of the InvestmentStrategy interface. Develop a more eﬀective solution for covering withdrawals that does not consistently require withdrawing funds from other investment strategies. 
26. MosaicVault and MosaicHolding owner is controlled by a single private key Severity: High Diﬃculty: High Type: Access Controls Finding ID: TOB-CMP-26 Target: CrosslayerPortal Description The MosaicVault and MosaicHolding contracts manage many critical functionalities, such as those for rescuing funds, managing liquidity, and claiming rewards. The owner of these contracts is a single externally owned account (EOA). As mentioned in TOB-CMP-20 , this creates a single point of failure. Moreover, it makes the owner a high-value target for attackers and increases the incentives for the owner to act maliciously. If the private key is compromised, the system will be compromised too. Exploit Scenario Alice, the owner of the MosaicVault and MosaicHolding contracts, deploys the contracts. MosaicHolding eventually holds assets worth USD 20 million. Eve gains access to Alice’s machine, upgrades the implementations, pauses MosaicHolding , and drains all funds from the contract. Recommendations Short term, change the owner of the contracts from a single EOA to a multi-signature account. Long term, take the following steps: ● ● Develop user documentation on all risks associated with the system, including those associated with privileged users and the existence of a single point of failure. Assess the system’s key management infrastructure and document the associated risks as well as an incident response plan. 
27. The relayer is a single point of failure Severity: High Diﬃculty: High Type: Access Controls Finding ID: TOB-CMP-27 Target: CrosslayerPortal Description Because the relayer is a centralized service that is responsible for critical functionalities, it constitutes a single point of failure within the Mosaic ecosystem. The relayer is responsible for the following tasks: ● ● ● ● ● ● Managing withdrawals across chains Managing transfers across chains Managing the accrued interest on all users’ investments Executing cross-chain message call requests Collecting fees for all withdrawals, transfers, and cross-chain message calls Refunding fees in case of failed transfers or withdrawals The centralized design and importance of the relayer increase the likelihood that the relayer will be targeted by an attacker. Exploit Scenario Eve, an attacker, is able to gain root access on the server that runs the relayer. Eve can then shut down the Mosaic system by stopping the relayer service. Eve can also change the source code to trigger behavior that can lead to the drainage of funds. Recommendations Short term, document an incident response plan and monitor exposed ports and services that may be vulnerable to exploitation. Long term, arrange an external security audit of the core and peripheral relayer source code. Additionally, consider implementing a decentralized relayer architecture more resistant to system takeovers. 
4. Project dependencies contain vulnerabilities Severity: Medium Diﬃculty: Low Type: Patching Finding ID: TOB-CMP-4 Target: CrosslayerPortal Description Although dependency scans did not yield a direct threat to the project under review, npm and yarn audit identiﬁed dependencies with known vulnerabilities. Due to the sensitivity of the deployment code and its environment, it is important to ensure dependencies are not malicious. Problems with dependencies in the JavaScript community could have a signiﬁcant eﬀect on the repositories under review. The output below details these issues. CVE ID Description Dependency CVE-2021-23337 Command Injection in lodash lodash CVE-2022-0235 node-fetch is vulnerable to Exposure of Sensitive Information to an Unauthorized Actor node-fetch CVE-2021-23358 Arbitrary Code Execution in underscore underscore Figure 4.1: Advisories aﬀecting CrosslayerPortal dependencies Exploit Scenario Alice installs the dependencies of an in-scope repository on a clean machine. Unbeknownst to Alice, a dependency of the project has become malicious or exploitable. Alice subsequently uses the dependency, disclosing sensitive information to an unknown actor. Recommendations Short term, ensure dependencies are up to date. Several node modules have been documented as malicious because they execute malicious code when installing dependencies to projects. Keep modules current and verify their integrity after installation. Long term, consider integrating automated dependency auditing into the development workﬂow. If a dependency cannot be updated when a vulnerability is disclosed, ensure the code does not use and is not aﬀected by the vulnerable functionality of the dependency. 
10. DoS risk created by cross-chain message call requests on certain networks Severity: Medium Diﬃculty: Medium Type: Denial of Service Finding ID: TOB-CMP-10 Target: CrosslayerPortal/contracts/functionCalls/* Description Cross-chain message calls that are requested on a low-fee, low-latency network could facilitate a DoS, preventing other users from interacting with the system. If a user, through the MsgSender contract, sent numerous cross-chain message call requests, the relayer would have to act upon the emitted events regardless of whether they were legitimate or part of a DoS attack. Exploit Scenario Eve creates a theoretically inﬁnite series of transactions on Arbitrum, a low-fee, low-latency network. The internal queue of the relayer is then ﬁlled with numerous malicious transactions. Alice requests a cross-chain message call; however, because the relayer must handle many of Eve’s transactions ﬁrst, Alice has to wait an undeﬁned amount of time for her transaction to be executed. Recommendations Short term, create multiple queues that work across the various chains to mitigate this DoS risk. Long term, analyze the implications of the ability to create numerous message calls on low-fee networks and its impact on relayer performance. 
11. Missing validation in takeFees function Diﬃculty: Medium Diﬃculty: Medium Type: Data Validation Finding ID: TOB-CMP-11 Target: CrossLayerPortal/contracts/core/MosaicVault.sol Description The takeFees function takes calldata from relayers and contract owners but does not validate the baseFee value passed to it. This lack of validation allows relayers and owners to set arbitrarily large baseFee values. To withdraw funds from the MosaicVault contract, a relayer or owner invokes the withdrawTo function on the contract, passing in _withdrawData calldata . /// @notice method called by the relayer to release transfer funds /// @param _accountTo eth address to send the withdrawal tokens /// @param _amount amount of token in /// @param _tokenIn address of the token in /// @param _tokenOut address of the token out /// @param _amountOutMin minimum amount out user wants /// @param _withdrawData set of data for withdraw /// @param _data additional data required for each AMM implementation function withdrawTo ( address _accountTo , uint256 _amount , address _tokenIn , address _tokenOut , uint256 _amountOutMin , WithdrawData calldata _withdrawData, bytes calldata _data ) external override { uint256 withdrawAmount = _withdraw ( _accountTo, _amount, _tokenIn, _tokenOut, _amountOutMin, _withdrawData, _data ); emit WithdrawalCompleted( _accountTo, _amount, withdrawAmount, _tokenOut, _withdrawData.id, _withdrawData.amountToSwapToNative > 0 ); } Figure 11.1: The withdrawTo function in MosaicVault:359-394 The internal _withdraw function veriﬁes that the caller is either a relayer or owner and invokes the takeFees function. /// @dev internal function called by `withdrawLiquidity` and `withdrawTo` /// @param _accountTo eth address to send the withdrawal tokens /// @param _amount amount of token in /// @param _tokenIn address of the token in /// @param _tokenOut address of the token out /// @param _amountOutMin minimum amount out user wants /// @param _withdrawData set of data for withdraw /// @param _data additional data required for each AMM implementation function _withdraw ( address _accountTo , uint256 _amount , address _tokenIn , address _tokenOut , uint256 _amountOutMin , WithdrawData calldata _withdrawData , bytes calldata _data internal onlyWhitelistedToken(_tokenIn) validAddress(_tokenOut) nonReentrant onlyOwnerOrRelayer whenNotPaused returns ( uint256 withdrawAmount ) ) { IMosaicHolding mosaicHolding = IMosaicHolding(vaultConfig.getMosaicHolding()); require (hasBeenWithdrawn[_withdrawData.id] == false , "ERR: ALREADY WITHDRAWN" ); if (_tokenOut == _tokenIn) { require ( mosaicHolding.getTokenLiquidity(_tokenIn, _withdrawData.investmentStrategies) >= _amount, "ERR: VAULT BAL" ); } uint256 amountToNative = _withdrawData.amountToSwapToNative; if (amountToNative > 0 ) { require (vaultConfig.ableToPerformSmallBalanceSwap(), "ERR: UNABLE TO SWAP TO NATIVE" ); } require (amountToNative <= _amount, "ERR: AMOUNT TO NATIVE TOO HIGH" ); hasBeenWithdrawn[_withdrawData.id] = true ; lastWithdrawID = _withdrawData.id; withdrawAmount = _takeFees ( _tokenIn, _amount, _accountTo, _withdrawData.id, _withdrawData.baseFee, _withdrawData.feePercentage ); Figure 11.2: The _withdraw function in MosaicVault:396-445 The contract checks that the feePercentage value is between the MosaicVault -conﬁgured minimum and maximum. However, there is no validation of the baseFee value. This lack of validation allows the caller to specify an arbitrarily large baseFee amount. /// @dev internal function called to calculate the on-chain fees /// @param _token address of the token in /// @param _amount amount of token in /// @param _accountTo address who will receive the withdrawn liquidity /// @param _withdrawRequestId id of the withdraw request /// @param _baseFee base fee of the withdraw /// @param _feePercentage fee percentage of the withdraw function _takeFees ( address _token , uint256 _amount , address _accountTo , bytes32 _withdrawRequestId , uint256 _baseFee , uint256 _feePercentage ) private returns ( uint256 ) { if (_baseFee > 0 ) { IMosaicHolding(vaultConfig.getMosaicHolding()).transfer(_token, relayer, _baseFee); } uint256 fee = 0 ; if (_feePercentage > 0 ) { require ( _feePercentage >= vaultConfig.minFee() && _feePercentage <= vaultConfig.maxFee(), "ERR: FEE PERCENTAGE OUT OF RANGE" ); fee = FeeOperations.getFeeAbsolute(_amount, _feePercentage); IMosaicHolding(vaultConfig.getMosaicHolding()).transfer( _token, vaultConfig.getMosaicHolding(), fee ); } uint256 totalFee = _baseFee + fee; require (totalFee < _amount, "ERR: FEE EXCEEDS AMOUNT" ); if (totalFee > 0 ) { emit FeeTaken( msg.sender , _accountTo, _token, _amount, fee, _baseFee, fee + _baseFee, _withdrawRequestId ); } return _amount - totalFee; } Figure 11.3: The takeFees function in MosaicVault:548-597 Exploit Scenario Alice, a user, submits a withdrawal request, assuming a baseFee of 5 DAI. When executing the withdrawal, the relayer sets the baseFee to 100 DAI, signiﬁcantly decreasing the amount of funds Alice receives through her withdrawal. Recommendations Short term, add suﬃcient data validation of the baseFee value to ensure that relayers cannot set it to arbitrarily large values. Long term, use Echidna to test the system invariants and ensure that they hold. 
12. Unimplemented getAmountsOut function in Balancer V2 Severity: Medium Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-CMP-12 Target: CrosslayerPortal/contracts/protocols/balancer/BalancerVaultV2Wrapper .sol#L43-L50 Description The getAmountsOut function in the BalancerV2Wrapper contract is unimplemented. The purpose of the getAmountsOut() function, shown in ﬁgure 12.1, is to allow users to know the amount of funds they will receive when executing a swap. Because the function does not invoke any functions on the Balancer Vault, a user must actually perform a swap to determine the amount of funds he or she will receive: function getAmountsOut ( address , address , uint256 , bytes calldata ) external pure override returns ( uint256 ) { return 0 ; } Figure 12.1: The getAmountsOut function in BalancerVaultV2Wrapper:43-50 Exploit Scenario Alice, a user of the Composable Finance vaults, wants to swap 100 USDC for DAI on Balancer. Because the getAmountsOut function is not implemented, she is unable to determine how much DAI she will receive before executing the swap. Recommendations Short term, implement the getAmountsOut function and have it call the queryBatchSwap function on the Balancer Vault. Long term, add unit tests for all functions to test all ﬂows. Unit tests will detect incorrect function behavior. 
28. Lack of events for critical operations Severity: Medium Diﬃculty: Low Type: Auditing and Logging Finding ID: TOB-CMP-28 Target: CrosslayerPortal/contracts/core/MosaicVault.sol,CrosslayerPortal/con tracts/core/BridgeAggregator.sol,CrosslayerPortal/contracts/nfts/Mos aicNFT.sol Description Several critical operations do not trigger events. As a result, it will be diﬃcult to review the correct behavior of the contracts once they have been deployed. For example, the setRelayer function, which is called in the MosaicVault contract to set the relayer address, does not emit an event providing conﬁrmation of that operation to the contract’s caller (ﬁgure 28.1). function setRelayer ( address _relayer ) external override onlyOwner { relayer = _relayer; } Figure 28.1: The setRelayer() function in MosaicVault:80-82 Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Exploit Scenario Eve, an attacker, is able to take ownership of the MosaicVault contract. She then sets a new relayer address. Alice, a Composable Finance team member, is unaware of the change and does not raise a security incident. Recommendations Short term, add events for all critical operations that result in state changes. Events aid in contract monitoring and the detection of suspicious behavior. Long term, consider using a blockchain-monitoring system to track any suspicious behavior in the contracts. The system relies on several contracts to behave as expected. A monitoring mechanism for critical events would quickly detect any compromised system components. 30. Insu cient protection of sensitive information Severity: Medium Diﬃculty: High Type: Conﬁguration Finding ID: TOB-CMP-30 Target: CrosslayerPortal/env , bribe-protocol/hardhat.config.ts Description Sensitive information such as a mnemonic seed phrase and API keys is stored in process environments and environment ﬁles. This method of storage could make it easier for an attacker to compromise the information; compromise of the seed phrase, for example, could enable an attacker to gain owner privileges and steal funds from the protocol. The following portion of the bribe-protocol/hardhat.config.ts ﬁle uses a mnemonic seed phrase from the process environment: mainnet: { accounts: { mnemonic: process.env.MNEMONIC || "" , }, url: "https://eth-mainnet.alchemyapi.io/v2/ XXXXXXXXXXXXXXXXXXXXXXXXXXXX " , }, } Figure 30.1: Use of a mnemonic seed phrase from the process environment in the bribe-protocol/hardhat.config.ts ﬁle The following portion of the CrosslayerPortal/env/mainnet.env ﬁle exposes Etherscan and Alchemy API keys: NETWORK_NAME=mainnet CHAIN_ID = 1 ## API BLOCK_EXPLORER_API_KEY = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX ALCHEMY_API=https://eth-mainnet.alchemyapi.io/v2/ XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Figure 30.2: Exposed API keys in the CrosslayerPortal/env/mainnet.env ﬁle If this repository is ever made public, the Git commit history will retain these API keys in plaintext. Access to the Alchemy API key, for example, would allow an attacker to launch a DoS attack on the application’s front end. Exploit Scenario Alice has the owner’s mnemonic seed phrase stored in her process environment. Eve, an attacker, gains access to Alice’s device and extracts the seed phrase from it. Eve uses the owner key to steal all funds. Recommendations Short term, use a hardware security module to ensure that none of the keys can be extracted. Additionally, avoid using hard-coded secrets and committing environment ﬁles to version control systems. Long term, take the following steps: ● ● Move key material from environment variables to a dedicated secret management system with trusted computing abilities. The best options for such a system are the Google Cloud Key Management System and Hashicorp Vault (with hardware security module backing). Determine the business risk that would result from a lost or stolen key and develop disaster recovery and business continuity policies to be implemented in such a case. 5. Accrued interest is not attributable to the underlying investor on-chain Severity: Low Diﬃculty: Undetermined Type: Data Validation Finding ID: TOB-CMP-5 Target: CrosslayerPortal/contracts/core/MosaicHolding.sol Description When an investor earns interest-bearing tokens by lending funds through Mosaic’s investment strategies, the tokens are not directly attributed to the investor by on-chain data. The claim() function, which can be called only by the owner of the MosaicHolding contract, is deﬁned in the contract and used to redeem interest-bearing tokens from protocols such as Aave and Compound (ﬁgure 5.1). The underlying tokens of these protocols’ lending pools are provided by users who are interacting with the Mosaic system and wish to earn rewards on their idle funds. function claim ( address _investmentStrategy , bytes calldata _data) external override onlyAdmin validAddress(_investmentStrategy) { require (investmentStrategies[_investmentStrategy], "ERR: STRATEGY NOT SET" ); address rewardTokenAddress = IInvestmentStrategy(_investmentStrategy).claimTokens(_data); emit TokenClaimed(_investmentStrategy, rewardTokenAddress); } Figure 5.1: The claim function in MosaicHolding:270-279 During the execution of claim() , the internal claimTokens() function calls into the AaveInvestmentStrategy , CompoundInvestmentStrategy , or SushiswapLiquidityProvider contract, which eﬀectively transfers its balance of the interest-bearing token directly to the MosaicHolding contract. Figure 5.2 shows the claimTokens() function call in AaveInvestmentStrategy . function claimTokens ( bytes calldata data) external override onlyInvestor returns ( address ) { address token = abi.decode(data, ( address )); ILendingPool lendingPool = ILendingPool(lendingPoolAddressesProvider.getLendingPool()); DataTypes.ReserveData memory reserve = lendingPool.getReserveData(token); IERC20Upgradeable(reserve.aTokenAddress).safeTransfer( mosaicHolding, IERC20Upgradeable(reserve.aTokenAddress).balanceOf( address ( this )) ); return reserve.aTokenAddress; } Figure 5.2: The c laimTokens function in AaveInvestmentStrategy:58-68 However, there is no identiﬁable mapping or data structure attributing a percentage of those rewards to a given user. The oﬀ-chain relayer service is responsible for holding such mappings and rewarding users with the interest they have accrued upon withdrawal (see the r elayer bot assumptions in the Project Coverage section). Exploit Scenario Investors Alice and Bob, who wish to earn interest on their idle USDC, decide to use the Mosaic system to provide loans. Mosaic invests their money in Aave’s lending pool for USDC. However, there is no way for the parties to discern their ownership stakes in the lending pool through the smart contract logic. The owner of the contract decides to call the claim() function and redeem all aUSDC associated with Alice’s and Bob’s positions. When Bob goes to withdraw his funds, he has to trust that the relayer will send him his claim on the aUSDC without any on-chain veriﬁcation. Recommendations Short term, consider implementing a way to identify the amount of each investor’s stake in a given investment strategy. Currently, the relayer is responsible for tracking all rewards. Long term, review the privileges and responsibilities of the relayer and architect a more robust solution for managing investments. 6. User funds can become trapped in nonstandard token contracts Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-CMP-6 Target: CrosslayerPortal/contracts/functionCalls/MsgReceiver.sol Description If a user’s funds are transferred to a token contract that violates the ERC20 standard, the funds may become permanently trapped in that token contract. In the MsgReceiver contract, there are six calls to the transfer() function. See ﬁgure 6.1 for an example. function approveERC20TokenAndForwardCall( uint256 _feeAmount, address _feeToken, address _feeReceiver, address _token, uint256 _amount, bytes32 _id, address _contract, bytes calldata _data ) external payable onlyOwnerOrRelayer returns ( bool success, bytes memory returnData) { require ( IMsgReceiverFactory(msgReceiverFactory).whitelistedFeeTokens(_feeToken), "Fee token is not whitelisted" ); require (!forwarded[_id], "call already forwared" ); //approve tokens to _contract IERC20(_token).safeIncreaseAllowance(_contract, _amount); // solhint-disable-next-line avoid-low-level-calls (success, returnData) = _contract.call{value: msg.value }(_data); require (success, "Failed to forward function call" ); uint256 balance = IERC20(_feeToken).balanceOf( address ( this )); require (balance >= _feeAmount, "Not enough tokens for the fee" ); forwarded[_id] = true ; IERC20(_feeToken).transfer(_feeReceiver, _feeAmount); } Figure 6.1: The approveERC20TokenAndForwardCall function in MsgReceiver:98- When implemented in accordance with the ERC20 standard, the transfer() function returns a boolean indicating whether a transfer operation was successful. However, tokens that implement the ERC20 interface incorrectly may not return true upon a successful transfer, in which case the transaction will revert and the user’s funds will be locked in the token contract. Exploit Scenario Alice, the owner of the MsgReceiverFactory contract, adds a fee token that is controlled by Eve. Eve’s token contract incorrectly implements the ERC20 interface. Bob interacts with MsgReceiver and calls a function that executes a transfer to _feeReceiver , which is controlled by Eve. Because Eve’s fee token contract does not provide a return value, Bob’s transfer reverts. Recommendations Short term, use safeTransfer() for token transfers and use the SafeERC20 library for interactions with ERC20 token contracts. Long term, develop a process for onboarding new fee tokens. Review our Token Integration Checklist for guidance on the onboarding process. References ● Missing Return Value Bug 13. Use of MsgReceiver to check _feeToken status leads to unnecessary gas consumption Severity: Low Diﬃculty: Medium Type: Data Validation Finding ID: TOB-CMP-13 Target: CrosslayerPortal/contracts/functionCalls/MsgReceiver.sol Description Checking the whitelist status of a token only on the receiving end of a message call can lead to excessive gas consumption. As part of a cross-chain message call, all functions in the MsgReceiver contract check whether the token used for the payment to _feeReceiver ( _feeToken ) is a whitelisted token (ﬁgure 13.1). Tokens are whitelisted by the owner of the MsgReceiverFactory contract. function approveERC20TokenAndForwardCall( uint256 _feeAmount, address _feeToken, address _feeReceiver, address _token, uint256 _amount, bytes32 _id, address _contract, bytes calldata _data ) external payable onlyOwnerOrRelayer returns ( bool success, bytes memory returnData) { require ( IMsgReceiverFactory(msgReceiverFactory).whitelistedFeeTokens(_feeToken), "Fee token is not whitelisted" ); require (!forwarded[_id], "call already forwared" ); //approve tokens to _contract IERC20(_token).safeIncreaseAllowance(_contract, _amount); // solhint-disable-next-line avoid-low-level-calls (success, returnData) = _contract.call{value: msg.value }(_data); require (success, "Failed to forward function call" ); uint256 balance = IERC20(_feeToken).balanceOf( address ( this )); require (balance >= _feeAmount, "Not enough tokens for the fee" ); forwarded[_id] = true ; IERC20(_feeToken).transfer(_feeReceiver, _feeAmount); } Figure 13.1: The approveERC20TokenAndForwardCall function in M sgReceiver:98-123 This validation should be performed before the MsgSender contract emits the related event (ﬁgure 13.2). This is because the relayer will act upon the emitted event on the receiving chain regardless of whether _feeToken is set to a whitelisted token. function registerCrossFunctionCallWithTokenApproval( uint256 _chainId, address _destinationContract, address _feeToken, address _token, uint256 _amount, bytes calldata _methodData ) { external override nonReentrant onlyWhitelistedNetworks(_chainId) onlyUnpausedNetworks(_chainId) whenNotPaused bytes32 id = _generateId(); //shouldn't happen require (hasBeenForwarded[id] == false , "Call already forwarded" ); require (lastForwardedCall != id, "Forwarded last time" ); lastForwardedCall = id; hasBeenForwarded[id] = true ; emit ForwardCallWithTokenApproval( msg.sender , id, _chainId, _destinationContract, _feeToken , _token, _amount, _methodData ); } Figure 13.2: The registerCrossFunctionCallWithTokenApproval function in M sgSender:169-203 Exploit Scenario On Arbitrum, a low-fee network, Eve creates a theoretically inﬁnite series of transactions to be sent to MsgSender , with _feeToken set to a token that she knows is not whitelisted. The relayer relays the series of message calls to a MsgReceiver contract on Ethereum, a high-fee network, and all of the transactions revert. However, the relayer has to pay the intrinsic gas cost for each transaction, with no repayment, while allowing its internal queue to be ﬁlled up with malicious transactions. Recommendations Short term, move the logic for token whitelisting and validation to the MsgSender contract. Long term, analyze the implications of the ability to create numerous message calls on low-fee networks and its impact on relayer performance. 14. Active liquidity providers can set arbitrary _tokenOut values when withdrawing liquidity Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-CMP-14 Target: CrosslayerPortal/contracts/core/MosaicVault.sol Description An active liquidity provider (LP) can move his or her liquidity into any token, even one that the LP controls. When a relayer acts upon a WithdrawRequest event triggered by an active LP, the MosaicVault contract checks only that the address of _tokenOut (the token being requested) is not the zero address (ﬁgure 14.1). Outside of that constraint, _tokenOut can eﬀectively be set to any token, even one that might have vulnerabilities. function _withdraw( address _accountTo, uint256 _amount, address _tokenIn, address _tokenOut, uint256 _amountOutMin, WithdrawData calldata _withdrawData, bytes calldata _data ) internal onlyWhitelistedToken(_tokenIn) validAddress(_tokenOut) nonReentrant onlyOwnerOrRelayer whenNotPaused returns ( uint256 withdrawAmount) Figure 14.1: The signature of the _withdraw function in M osaicVault:404-419 This places the burden of ensuring the swap’s success on the decentralized exchange, and, as the application grows, can lead to unintended code behavior. Exploit Scenario Eve, a malicious active LP, is able to trigger undeﬁned behavior in the system by setting _tokenOut to a token that is vulnerable to exploitation. Recommendations Short term, analyze the implications of allowing _tokenOut to be set to an arbitrary token. Long term, validate the assumptions surrounding the lack of limits on _tokenOut as the codebase grows, and review our Token Integration Checklist to identify any related pitfalls. References ● imBTC Uniswap Hack 15. Withdrawal assumptions may lead to transfers of an incorrect token Severity: Low Diﬃculty: Low Type: Data Validation Finding ID: TOB-CMP-15 Target: apyhunter-tricrypto/contracts/tricrypto/CurveTricryptoStrategy.sol Description The CurveTricryptoStrategy contract manages liquidity in Curve pools and facilitates transfers of tokens between chains. While it is designed to work with one curve vault, the vault can be set to an arbitrary pool. Thus, the contract should not make assumptions regarding the pool without validation. Each pool contains an array of tokens specifying the tokens to withdraw from that pool. However, when the vault address is set in the constructor of CurveTricryptoConfig , the pool’s address is not checked against the TriCrypto pool’s address. The token at index 2 in the coins array is assumed to be wrapped ether (WETH), as indicated by the code comment shown in ﬁgure 15.1. If the conﬁguration is incorrect, a diﬀerent token may be unintentionally transferred. if (unwrap) { //unwrap LP into weth transferredToken = tricryptoConfig.tricryptoLPVault().coins( 2 ); [...] Figure 15.1: Part of the transferLPs function in CurveTricryptoStrategy .sol:377-379 Exploit Scenario The Curve pool array, coins , stores an address other than that of WETH in index 2. As a result, a user mistakenly sends the wrong token in a transfer. Recommendations Short term, have the constructor of CurveTricryptoConfig or the transferLPs function validate that the address of transferredToken is equal to the address of WETH. Long term, validate data from external contracts, especially data involved in the transfer of funds. 16. Improper validation of Chainlink data Severity: Low Diﬃculty: Medium Type: Data Validation Finding ID: TOB-CMP-16 Target: v2-sdk-contracts/contracts/libraries/oracles/ChainlinkLib.sol Description The latestRoundData function returns a signed integer that is coerced to an unsigned integer without checking that the value is positive. An overﬂow (e.g., uint(-1) ) would result in drastic misrepresentation of the price and unexpected behavior. In addition, ChainlinkLib does not ensure the completeness or recency of round data, so pricing data may not reﬂect recent changes. It is best practice to deﬁne a window in which data is considered suﬃciently recent (e.g., within a minute of the last update) by comparing the block timestamp to updatedAt . (, int256 price , , , ) = _aggregator.latestRoundData(); return uint256 (price); Figure 16.1: Part of the getCurrentTokenPrice function in ChainlinkLib.sol:113-114 Recommendations Short term, have latestRoundData and similar functions verify that values are non-negative before converting them to unsigned integers, and add an invariant— require(updatedAt != 0 && answeredInRound == roundID) —to ensure that the round has ﬁnished and that the pricing data is from the current round. Long term, deﬁne a minimum update threshold and add the following check: require((block.timestamp - updatedAt <= minThreshold) && (answeredInRound == roundID)) . 25. Incorrect safeIncreaseAllowance() amount can cause invest() calls to revert Severity: Low Diﬃculty: Medium Type: Data Validation Finding ID: TOB-CMP-25 Target: CrosslayerPortal/contracts/protocols/sushiswap/SushiswapLiquidityPro vider.sol Description Calls to make investments through Sushiswap can revert because the sushiSwapRouter may not have the token allowances needed to fulﬁll the requests. The owner of the MosaicHolding contract is responsible for investing user-deposited funds in investment strategies. The contract owner does this by calling the contract’s invest() function, which then calls makeInvestment() on the investment strategy meant to receive the funds (ﬁgure 25.1). function invest ( IInvestmentStrategy.Investment[] calldata _investments, address _investmentStrategy , bytes calldata _data ) external override onlyAdmin validAddress(_investmentStrategy) { require (investmentStrategies[_investmentStrategy], "ERR: STRATEGY NOT SET" ); uint256 investmentsLength = _investments.length; address contractAddress = address ( this ); for ( uint256 i ; i < investmentsLength; i++) { IInvestmentStrategy.Investment memory investment = _investments[i]; require (investment.amount != 0 && investment.token != address ( 0 ), "ERR: TOKEN AMOUNT" ); IERC20Upgradeable token = IERC20Upgradeable(investment.token); require (token.balanceOf(contractAddress) >= investment.amount, "ERR: BALANCE" ); token.safeApprove(_investmentStrategy, investment.amount); } uint256 mintedTokens = IInvestmentStrategy(_investmentStrategy).makeInvestment( _investments, _data ); emit FoundsInvested(_investmentStrategy, msg.sender , mintedTokens); } Figure 25.1: The invest function in MosaicHolding:190- To deposit funds into the SushiswapLiquidityProvider investment strategy, the contract must increase the sushiSwapRouter ’s approval limits to account for the tokenA and tokenB amounts to be transferred. However, tokenB ’s approval limit is increased only to the amount of the tokenA investment (ﬁgure 25.2). function makeInvestment (Investment[] calldata _investments, bytes calldata _data) external override onlyInvestor nonReentrant returns ( uint256 ) { Investment memory investmentA = _investments[ 0 ]; Investment memory investmentB = _investments[ 1 ]; IERC20Upgradeable tokenA = IERC20Upgradeable(investmentA.token); IERC20Upgradeable tokenB = IERC20Upgradeable(investmentB.token); tokenA.safeTransferFrom( msg.sender , address ( this ), investmentA.amount); tokenB.safeTransferFrom( msg.sender , address ( this ), investmentB.amount); tokenA.safeIncreaseAllowance( address (sushiSwapRouter), investmentA.amount); tokenB.safeIncreaseAllowance( address (sushiSwapRouter), investmentA.amount); ( uint256 deadline , uint256 minA , uint256 minB ) = abi.decode( _data, ( uint256 , uint256 , uint256 ) ); (, , uint256 liquidity ) = sushiSwapRouter.addLiquidity( investmentA.token, investmentB.token, investmentA.amount, investmentB.amount, minA, minB, address ( this ), deadline ); return liquidity; } Figure 25.2: The makeInvestment function in SushiswapLiquidityProvider : 52-85 If the amount of tokenB to be deposited is greater than that of tokenA , sushiSwapRouter will fail to transfer the tokens, and the transaction will revert. Exploit Scenario Alice, the owner of the MosaicHolding contract, wishes to invest liquidity in a Sushiswap liquidity pool. The amount of the tokenB investment is greater than that of tokenA . The sushiSwapRouter does not have the right token allowances for the transaction, and the investment request fails. Recommendations Short term, change the amount value used in the safeIncreaseAllowance() call from investmentA.amount to investmentB.amount . Long term, review the codebase to identify similar issues. Additionally, create a more extensive test suite capable of testing edge cases that may invalidate system assumptions. 17. Incorrect check of token status in the providePassiveLiquidity function Severity: Informational Diﬃculty: Low Type: Data Validation Finding ID: TOB-CMP-17 Target: CrosslayerPortal/contracts/core/MosaicVault.sol Description A passive LP can provide liquidity in the form of a token that is not whitelisted. The providePassiveLiquidity() function in MosaicVault is called by users who wish to participate in the Mosaic system as passive LPs. As part of the function’s execution, it checks whether there is a ReceiptToken associated with the _tokenAddress input parameter (ﬁgure 17.1). This is equivalent to checking whether the token is whitelisted by the system. function providePassiveLiquidity( uint256 _amount, address _tokenAddress) external payable override nonReentrant whenNotPaused { require (_amount > 0 || msg.value > 0 , "ERR: AMOUNT" ); if ( msg.value > 0 ) { require ( vaultConfig.getUnderlyingIOUAddress(vaultConfig.wethAddress()) != address ( 0 ), "ERR: WETH NOT WHITELISTED" ); _provideLiquidity( msg.value , vaultConfig.wethAddress(), 0 ); } else { require (_tokenAddress != address ( 0 ), "ERR: INVALID TOKEN" ); require ( vaultConfig.getUnderlyingIOUAddress(_tokenAddress) != address ( 0 ), "ERR: TOKEN NOT WHITELISTED" ); _provideLiquidity(_amount, _tokenAddress, 0 ); } } Figure 17.1: The providePassiveLiquidity function in MosaicVault:127-149 However, providePassiveLiquidity() uses an incorrect function call to check the whitelist status. Instead of calling getUnderlyingReceiptAddress() , it calls getUnderlyingIOUAddress() . The same issue occurs in checks of WETH deposits. Exploit Scenario Eve decides to deposit liquidity in the form of a token that is whitelisted only for active LPs. The token provides a higher yield than the tokens whitelisted for passive LPs. This may enable Eve to receive a higher annual percentage yield on her deposit than other passive LPs in the system receive on theirs. Recommendations Short term, change the function called to validate tokenAddress and wethAddress from getUnderlyingIOUAddress() to getUnderlyingReceiptAddress() . Long term, take the following steps: ● ● ● Review the codebase to identify similar errors. Consider whether the assumption that the same tokens will be whitelisted for both passive and active LPs will hold in the future. Create a more extensive test suite capable of testing edge cases that may invalidate system assumptions. 18. Solidity compiler optimizations can be problematic Severity: Informational Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-CMP-18 Target: CrosslayerPortal , apy-hunter Description The Composable Finance contracts have enabled optional compiler optimizations in Solidity. There have been several optimization bugs with security implications. Moreover, optimizations are actively being developed . Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them. Therefore, it is unclear how well they are being tested and exercised. High-severity security issues due to optimization bugs have occurred in the past . A high-severity bug in the emscripten -generated solc-js compiler used by Truﬄe and Remix persisted until late 2018. The ﬁx for this bug was not reported in the Solidity CHANGELOG. Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6 . More recently, another bug due to the incorrect caching of keccak256 was reported. A compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe . It is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations. Exploit Scenario A latent or future bug in Solidity compiler optimizations—or in the Emscripten transpilation to solc-js —causes a security vulnerability in the Composable Finance contracts. Recommendations Short term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug. Long term, monitor the development and adoption of Solidity compiler optimizations to assess their maturity. 19. Lack of contract documentation Severity: Informational Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-CMP-19 Target: Throughout the code Description The codebases lack code documentation, high-level descriptions, and examples, making the contracts diﬃcult to review and increasing the likelihood of user mistakes. The CrosslayerPortal codebase would beneﬁt from additional documentation, including on the following: ● ● ● ● ● ● The logic responsible for setting the roles in the core and the reason for the manipulation of indexes The incoming function arguments and the values used on source chains and destination chains The arithmetic involved in reward calculations and the relayer’s distribution of tokens The checks performed by the oﬀ-chain components, such as the relayer and the rebalancing bot The third-party integrations The rebalancing arithmetic and calculations There should also be clear NatSpec documentation on every function, identifying the unit of each variable, the function’s intended use, and the function’s safe values. The documentation should include all expected properties and assumptions relevant to the aforementioned aspects of the codebase. Recommendations Short term, review and properly document the aforementioned aspects of the codebase. Long term, consider writing a formal speciﬁcation of the protocol. 21. Unnecessary complexity due to interactions with native and smart contract tokens Severity: Informational Diﬃculty: Low Type: Data Validation Finding ID: TOB-CMP-21 Target: apyhunter-tricrypto/contracts/sushiswap/SushiSlpStrategy.sol Description The Composable Finance code is needlessly complex and has excessive branching. Its complexity largely results from the integration of both ERC20s and native tokens (i.e., ether). Creating separate functions that convert native tokens to ERC20s and then interact with functions that must receive ERC20 tokens (i.e., implementing separation of concerns) would drastically simplify and optimize the code. This complexity is the source of many bugs and increases the gas costs for all users whether or not they need to distinguish between ERC20s and ether. It is best practice to make components as small as possible and to separate helpful but noncritical components into periphery contracts. This reduces the attack surface and improves readability. Figure 21.1 shows an example of complex code. if (tempData.isSlp) { IERC20(sushiConfig.slpToken()).safeTransfer( msg.sender , tempData.slpAmount ); [...] } else { //unwrap and send the right asset [...] if (tempData.isEth) { [...] } else { IERC20(sushiConfig.wethToken()).safeTransfer( Figure 21.1: Part of the withdraw function in SushiSlpStrategy.sol:L180-L216 Recommendations Short term, remove the native ether interactions and use WETH instead. Long term, minimize the function complexity by breaking functions into smaller units. Additionally, refactor the code with minimalism in mind and extend the core functionality into periphery contracts. 29. Use of legacy openssl version in CrosslayerPortal tests Severity: Informational Diﬃculty: N/A Type: Patching Finding ID: TOB-CMP-29 Target: CrosslayerPortal Description The CrosslayerPortal project uses a legacy version of openssl to run tests. While this version is not exposed in production, the use of outdated security protocols may be risky (ﬁgure 29.1). An unexpected error occurred: Error: error:0308010C:digital envelope routines::unsupported at new Hash (node:internal/crypto/hash:67:19) at Object.createHash (node:crypto:130:10) at hash160 (~/CrosslayerPortal/node_modules/ethereum-cryptography/vendor/hdkey-without-crypto.js:249:21 ) at HDKey.set (~/CrosslayerPortal/node_modules/ethereum-cryptography/vendor/hdkey-without-crypto.js:50:24) at Function.HDKey.fromMasterSeed (~/CrosslayerPortal/node_modules/ethereum-cryptography/vendor/hdkey-without-crypto.js:194:20 ) at deriveKeyFromMnemonicAndPath (~/CrosslayerPortal/node_modules/hardhat/src/internal/util/keys-derivation.ts:21:27) at derivePrivateKeys (~/CrosslayerPortal/node_modules/hardhat/src/internal/core/providers/util.ts:29:52) at normalizeHardhatNetworkAccountsConfig (~/CrosslayerPortal/node_modules/hardhat/src/internal/core/providers/util.ts:56:10) at createProvider (~/CrosslayerPortal/node_modules/hardhat/src/internal/core/providers/construction.ts:78:59) at ~/CrosslayerPortal/node_modules/hardhat/src/internal/core/runtime-environment.ts:80:28 { opensslErrorStack: [ 'error:03000086:digital envelope routines::initialization error' ], library: 'digital envelope routines', reason: 'unsupported', code: 'ERR_OSSL_EVP_UNSUPPORTED' } Figure 29.1: Errors ﬂagged in npx hardhat testing Recommendations Short term, refactor the code to use a new version of openssl to prevent the exploitation of openssl vulnerabilities. Long term, avoid using outdated or legacy versions of dependencies. 22. Commented-out and unimplemented conditional statements Severity: Undetermined Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-CMP-22 Target: apyhunter-tricrypto/contracts/sushiswap/SushiSlpStrategy.sol Description The Composable Finance system does not deﬁne or document the expected behavior of certain conditional statements. It is diﬃcult to assess the correctness or security of the code without an understanding of its expected behavior. For example, it is unclear why one if statement is commented out. // if (!_isSenderKeeperOrOwner(msg.sender)) { totalAmountOfLPs = totalAmountOfLPs - tempData.slpAmount; // } Figure 22.1: Part of the withdraw function in SushiSlpStrategy.sol:L404 Another if statement does not deﬁne what should happen when the condition evaluates to true . if (_isSenderKeeperOrOwner( msg.sender ) && _isReceiveBackLP) {} Figure 22.2: Part of the _deposit function in SushiSlpStrategy.sol:L177-L179 This pattern is error-prone and bad practice. Recommendations Short term, fully implement the necessary logic and remove commented-out code. Long term, remove the ambiguity surrounding the code and conditional branches by clearly documenting and testing the system’s functions. 23. Error-prone NFT management in the Summoner contract Severity: Undetermined Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-CMP-23 Target: CrosslayerPortal Description The Summoner contract’s ability to hold NFTs in a number of states may create confusion regarding the contracts’ states and the diﬀerences between the contracts. For instance, the Summoner contract can hold the following kinds of NFTs: ● ● NFTs that have been pre-minted by Composable Finance and do not have metadata attached to them Original NFTs that have been locked by the Summoner for minting on the destination chain ● MosaicNFT wrapper tokens, which are copies of NFTs that have been locked and are intended to be minted on the destination chain As the system is scaled, the number of NFTs held by the Summoner , especially the number of pre-minted NFTs, will increase signiﬁcantly. Recommendations Simplify the NFT architecture; see the related recommendations in Appendix E .
5. Accrued interest is not attributable to the underlying investor on-chain Severity: Low Diﬃculty: Undetermined Type: Data Validation Finding ID: TOB-CMP-5 Target: CrosslayerPortal/contracts/core/MosaicHolding.sol Description When an investor earns interest-bearing tokens by lending funds through Mosaic’s investment strategies, the tokens are not directly attributed to the investor by on-chain data. The claim() function, which can be called only by the owner of the MosaicHolding contract, is deﬁned in the contract and used to redeem interest-bearing tokens from protocols such as Aave and Compound (ﬁgure 5.1). The underlying tokens of these protocols’ lending pools are provided by users who are interacting with the Mosaic system and wish to earn rewards on their idle funds. function claim ( address _investmentStrategy , bytes calldata _data) external override onlyAdmin validAddress(_investmentStrategy) { require (investmentStrategies[_investmentStrategy], "ERR: STRATEGY NOT SET" ); address rewardTokenAddress = IInvestmentStrategy(_investmentStrategy).claimTokens(_data); emit TokenClaimed(_investmentStrategy, rewardTokenAddress); } Figure 5.1: The claim function in MosaicHolding:270-279 During the execution of claim() , the internal claimTokens() function calls into the AaveInvestmentStrategy , CompoundInvestmentStrategy , or SushiswapLiquidityProvider contract, which eﬀectively transfers its balance of the interest-bearing token directly to the MosaicHolding contract. Figure 5.2 shows the claimTokens() function call in AaveInvestmentStrategy . function claimTokens ( bytes calldata data) external override onlyInvestor returns ( address ) { address token = abi.decode(data, ( address )); ILendingPool lendingPool = ILendingPool(lendingPoolAddressesProvider.getLendingPool()); DataTypes.ReserveData memory reserve = lendingPool.getReserveData(token); IERC20Upgradeable(reserve.aTokenAddress).safeTransfer( mosaicHolding, IERC20Upgradeable(reserve.aTokenAddress).balanceOf( address ( this )) ); return reserve.aTokenAddress; } Figure 5.2: The c laimTokens function in AaveInvestmentStrategy:58-68 However, there is no identiﬁable mapping or data structure attributing a percentage of those rewards to a given user. The oﬀ-chain relayer service is responsible for holding such mappings and rewarding users with the interest they have accrued upon withdrawal (see the r elayer bot assumptions in the Project Coverage section). Exploit Scenario Investors Alice and Bob, who wish to earn interest on their idle USDC, decide to use the Mosaic system to provide loans. Mosaic invests their money in Aave’s lending pool for USDC. However, there is no way for the parties to discern their ownership stakes in the lending pool through the smart contract logic. The owner of the contract decides to call the claim() function and redeem all aUSDC associated with Alice’s and Bob’s positions. When Bob goes to withdraw his funds, he has to trust that the relayer will send him his claim on the aUSDC without any on-chain veriﬁcation. Recommendations Short term, consider implementing a way to identify the amount of each investor’s stake in a given investment strategy. Currently, the relayer is responsible for tracking all rewards. Long term, review the privileges and responsibilities of the relayer and architect a more robust solution for managing investments. 
6. User funds can become trapped in nonstandard token contracts Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-CMP-6 Target: CrosslayerPortal/contracts/functionCalls/MsgReceiver.sol Description If a user’s funds are transferred to a token contract that violates the ERC20 standard, the funds may become permanently trapped in that token contract. In the MsgReceiver contract, there are six calls to the transfer() function. See ﬁgure 6.1 for an example. function approveERC20TokenAndForwardCall( uint256 _feeAmount, address _feeToken, address _feeReceiver, address _token, uint256 _amount, bytes32 _id, address _contract, bytes calldata _data ) external payable onlyOwnerOrRelayer returns ( bool success, bytes memory returnData) { require ( IMsgReceiverFactory(msgReceiverFactory).whitelistedFeeTokens(_feeToken), "Fee token is not whitelisted" ); require (!forwarded[_id], "call already forwared" ); //approve tokens to _contract IERC20(_token).safeIncreaseAllowance(_contract, _amount); // solhint-disable-next-line avoid-low-level-calls (success, returnData) = _contract.call{value: msg.value }(_data); require (success, "Failed to forward function call" ); uint256 balance = IERC20(_feeToken).balanceOf( address ( this )); require (balance >= _feeAmount, "Not enough tokens for the fee" ); forwarded[_id] = true ; IERC20(_feeToken).transfer(_feeReceiver, _feeAmount); } Figure 6.1: The approveERC20TokenAndForwardCall function in MsgReceiver:98- When implemented in accordance with the ERC20 standard, the transfer() function returns a boolean indicating whether a transfer operation was successful. However, tokens that implement the ERC20 interface incorrectly may not return true upon a successful transfer, in which case the transaction will revert and the user’s funds will be locked in the token contract. Exploit Scenario Alice, the owner of the MsgReceiverFactory contract, adds a fee token that is controlled by Eve. Eve’s token contract incorrectly implements the ERC20 interface. Bob interacts with MsgReceiver and calls a function that executes a transfer to _feeReceiver , which is controlled by Eve. Because Eve’s fee token contract does not provide a return value, Bob’s transfer reverts. Recommendations Short term, use safeTransfer() for token transfers and use the SafeERC20 library for interactions with ERC20 token contracts. Long term, develop a process for onboarding new fee tokens. Review our Token Integration Checklist for guidance on the onboarding process. References ● Missing Return Value Bug 
13. Use of MsgReceiver to check _feeToken status leads to unnecessary gas consumption Severity: Low Diﬃculty: Medium Type: Data Validation Finding ID: TOB-CMP-13 Target: CrosslayerPortal/contracts/functionCalls/MsgReceiver.sol Description Checking the whitelist status of a token only on the receiving end of a message call can lead to excessive gas consumption. As part of a cross-chain message call, all functions in the MsgReceiver contract check whether the token used for the payment to _feeReceiver ( _feeToken ) is a whitelisted token (ﬁgure 13.1). Tokens are whitelisted by the owner of the MsgReceiverFactory contract. function approveERC20TokenAndForwardCall( uint256 _feeAmount, address _feeToken, address _feeReceiver, address _token, uint256 _amount, bytes32 _id, address _contract, bytes calldata _data ) external payable onlyOwnerOrRelayer returns ( bool success, bytes memory returnData) { require ( IMsgReceiverFactory(msgReceiverFactory).whitelistedFeeTokens(_feeToken), "Fee token is not whitelisted" ); require (!forwarded[_id], "call already forwared" ); //approve tokens to _contract IERC20(_token).safeIncreaseAllowance(_contract, _amount); // solhint-disable-next-line avoid-low-level-calls (success, returnData) = _contract.call{value: msg.value }(_data); require (success, "Failed to forward function call" ); uint256 balance = IERC20(_feeToken).balanceOf( address ( this )); require (balance >= _feeAmount, "Not enough tokens for the fee" ); forwarded[_id] = true ; IERC20(_feeToken).transfer(_feeReceiver, _feeAmount); } Figure 13.1: The approveERC20TokenAndForwardCall function in M sgReceiver:98-123 This validation should be performed before the MsgSender contract emits the related event (ﬁgure 13.2). This is because the relayer will act upon the emitted event on the receiving chain regardless of whether _feeToken is set to a whitelisted token. function registerCrossFunctionCallWithTokenApproval( uint256 _chainId, address _destinationContract, address _feeToken, address _token, uint256 _amount, bytes calldata _methodData ) { external override nonReentrant onlyWhitelistedNetworks(_chainId) onlyUnpausedNetworks(_chainId) whenNotPaused bytes32 id = _generateId(); //shouldn't happen require (hasBeenForwarded[id] == false , "Call already forwarded" ); require (lastForwardedCall != id, "Forwarded last time" ); lastForwardedCall = id; hasBeenForwarded[id] = true ; emit ForwardCallWithTokenApproval( msg.sender , id, _chainId, _destinationContract, _feeToken , _token, _amount, _methodData ); } Figure 13.2: The registerCrossFunctionCallWithTokenApproval function in M sgSender:169-203 Exploit Scenario On Arbitrum, a low-fee network, Eve creates a theoretically inﬁnite series of transactions to be sent to MsgSender , with _feeToken set to a token that she knows is not whitelisted. The relayer relays the series of message calls to a MsgReceiver contract on Ethereum, a high-fee network, and all of the transactions revert. However, the relayer has to pay the intrinsic gas cost for each transaction, with no repayment, while allowing its internal queue to be ﬁlled up with malicious transactions. Recommendations Short term, move the logic for token whitelisting and validation to the MsgSender contract. Long term, analyze the implications of the ability to create numerous message calls on low-fee networks and its impact on relayer performance. 
14. Active liquidity providers can set arbitrary _tokenOut values when withdrawing liquidity Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-CMP-14 Target: CrosslayerPortal/contracts/core/MosaicVault.sol Description An active liquidity provider (LP) can move his or her liquidity into any token, even one that the LP controls. When a relayer acts upon a WithdrawRequest event triggered by an active LP, the MosaicVault contract checks only that the address of _tokenOut (the token being requested) is not the zero address (ﬁgure 14.1). Outside of that constraint, _tokenOut can eﬀectively be set to any token, even one that might have vulnerabilities. function _withdraw( address _accountTo, uint256 _amount, address _tokenIn, address _tokenOut, uint256 _amountOutMin, WithdrawData calldata _withdrawData, bytes calldata _data ) internal onlyWhitelistedToken(_tokenIn) validAddress(_tokenOut) nonReentrant onlyOwnerOrRelayer whenNotPaused returns ( uint256 withdrawAmount) Figure 14.1: The signature of the _withdraw function in M osaicVault:404-419 This places the burden of ensuring the swap’s success on the decentralized exchange, and, as the application grows, can lead to unintended code behavior. Exploit Scenario Eve, a malicious active LP, is able to trigger undeﬁned behavior in the system by setting _tokenOut to a token that is vulnerable to exploitation. Recommendations Short term, analyze the implications of allowing _tokenOut to be set to an arbitrary token. Long term, validate the assumptions surrounding the lack of limits on _tokenOut as the codebase grows, and review our Token Integration Checklist to identify any related pitfalls. References ● imBTC Uniswap Hack 
15. Withdrawal assumptions may lead to transfers of an incorrect token Severity: Low Diﬃculty: Low Type: Data Validation Finding ID: TOB-CMP-15 Target: apyhunter-tricrypto/contracts/tricrypto/CurveTricryptoStrategy.sol Description The CurveTricryptoStrategy contract manages liquidity in Curve pools and facilitates transfers of tokens between chains. While it is designed to work with one curve vault, the vault can be set to an arbitrary pool. Thus, the contract should not make assumptions regarding the pool without validation. Each pool contains an array of tokens specifying the tokens to withdraw from that pool. However, when the vault address is set in the constructor of CurveTricryptoConfig , the pool’s address is not checked against the TriCrypto pool’s address. The token at index 2 in the coins array is assumed to be wrapped ether (WETH), as indicated by the code comment shown in ﬁgure 15.1. If the conﬁguration is incorrect, a diﬀerent token may be unintentionally transferred. if (unwrap) { //unwrap LP into weth transferredToken = tricryptoConfig.tricryptoLPVault().coins( 2 ); [...] Figure 15.1: Part of the transferLPs function in CurveTricryptoStrategy .sol:377-379 Exploit Scenario The Curve pool array, coins , stores an address other than that of WETH in index 2. As a result, a user mistakenly sends the wrong token in a transfer. Recommendations Short term, have the constructor of CurveTricryptoConfig or the transferLPs function validate that the address of transferredToken is equal to the address of WETH. Long term, validate data from external contracts, especially data involved in the transfer of funds. 
16. Improper validation of Chainlink data Severity: Low Diﬃculty: Medium Type: Data Validation Finding ID: TOB-CMP-16 Target: v2-sdk-contracts/contracts/libraries/oracles/ChainlinkLib.sol Description The latestRoundData function returns a signed integer that is coerced to an unsigned integer without checking that the value is positive. An overﬂow (e.g., uint(-1) ) would result in drastic misrepresentation of the price and unexpected behavior. In addition, ChainlinkLib does not ensure the completeness or recency of round data, so pricing data may not reﬂect recent changes. It is best practice to deﬁne a window in which data is considered suﬃciently recent (e.g., within a minute of the last update) by comparing the block timestamp to updatedAt . (, int256 price , , , ) = _aggregator.latestRoundData(); return uint256 (price); Figure 16.1: Part of the getCurrentTokenPrice function in ChainlinkLib.sol:113-114 Recommendations Short term, have latestRoundData and similar functions verify that values are non-negative before converting them to unsigned integers, and add an invariant— require(updatedAt != 0 && answeredInRound == roundID) —to ensure that the round has ﬁnished and that the pricing data is from the current round. Long term, deﬁne a minimum update threshold and add the following check: require((block.timestamp - updatedAt <= minThreshold) && (answeredInRound == roundID)) . 
25. Incorrect safeIncreaseAllowance() amount can cause invest() calls to revert Severity: Low Diﬃculty: Medium Type: Data Validation Finding ID: TOB-CMP-25 Target: CrosslayerPortal/contracts/protocols/sushiswap/SushiswapLiquidityPro vider.sol Description Calls to make investments through Sushiswap can revert because the sushiSwapRouter may not have the token allowances needed to fulﬁll the requests. The owner of the MosaicHolding contract is responsible for investing user-deposited funds in investment strategies. The contract owner does this by calling the contract’s invest() function, which then calls makeInvestment() on the investment strategy meant to receive the funds (ﬁgure 25.1). function invest ( IInvestmentStrategy.Investment[] calldata _investments, address _investmentStrategy , bytes calldata _data ) external override onlyAdmin validAddress(_investmentStrategy) { require (investmentStrategies[_investmentStrategy], "ERR: STRATEGY NOT SET" ); uint256 investmentsLength = _investments.length; address contractAddress = address ( this ); for ( uint256 i ; i < investmentsLength; i++) { IInvestmentStrategy.Investment memory investment = _investments[i]; require (investment.amount != 0 && investment.token != address ( 0 ), "ERR: TOKEN AMOUNT" ); IERC20Upgradeable token = IERC20Upgradeable(investment.token); require (token.balanceOf(contractAddress) >= investment.amount, "ERR: BALANCE" ); token.safeApprove(_investmentStrategy, investment.amount); } uint256 mintedTokens = IInvestmentStrategy(_investmentStrategy).makeInvestment( _investments, _data ); emit FoundsInvested(_investmentStrategy, msg.sender , mintedTokens); } Figure 25.1: The invest function in MosaicHolding:190- To deposit funds into the SushiswapLiquidityProvider investment strategy, the contract must increase the sushiSwapRouter ’s approval limits to account for the tokenA and tokenB amounts to be transferred. However, tokenB ’s approval limit is increased only to the amount of the tokenA investment (ﬁgure 25.2). function makeInvestment (Investment[] calldata _investments, bytes calldata _data) external override onlyInvestor nonReentrant returns ( uint256 ) { Investment memory investmentA = _investments[ 0 ]; Investment memory investmentB = _investments[ 1 ]; IERC20Upgradeable tokenA = IERC20Upgradeable(investmentA.token); IERC20Upgradeable tokenB = IERC20Upgradeable(investmentB.token); tokenA.safeTransferFrom( msg.sender , address ( this ), investmentA.amount); tokenB.safeTransferFrom( msg.sender , address ( this ), investmentB.amount); tokenA.safeIncreaseAllowance( address (sushiSwapRouter), investmentA.amount); tokenB.safeIncreaseAllowance( address (sushiSwapRouter), investmentA.amount); ( uint256 deadline , uint256 minA , uint256 minB ) = abi.decode( _data, ( uint256 , uint256 , uint256 ) ); (, , uint256 liquidity ) = sushiSwapRouter.addLiquidity( investmentA.token, investmentB.token, investmentA.amount, investmentB.amount, minA, minB, address ( this ), deadline ); return liquidity; } Figure 25.2: The makeInvestment function in SushiswapLiquidityProvider : 52-85 If the amount of tokenB to be deposited is greater than that of tokenA , sushiSwapRouter will fail to transfer the tokens, and the transaction will revert. Exploit Scenario Alice, the owner of the MosaicHolding contract, wishes to invest liquidity in a Sushiswap liquidity pool. The amount of the tokenB investment is greater than that of tokenA . The sushiSwapRouter does not have the right token allowances for the transaction, and the investment request fails. Recommendations Short term, change the amount value used in the safeIncreaseAllowance() call from investmentA.amount to investmentB.amount . Long term, review the codebase to identify similar issues. Additionally, create a more extensive test suite capable of testing edge cases that may invalidate system assumptions. 
17. Incorrect check of token status in the providePassiveLiquidity function Severity: Informational Diﬃculty: Low Type: Data Validation Finding ID: TOB-CMP-17 Target: CrosslayerPortal/contracts/core/MosaicVault.sol Description A passive LP can provide liquidity in the form of a token that is not whitelisted. The providePassiveLiquidity() function in MosaicVault is called by users who wish to participate in the Mosaic system as passive LPs. As part of the function’s execution, it checks whether there is a ReceiptToken associated with the _tokenAddress input parameter (ﬁgure 17.1). This is equivalent to checking whether the token is whitelisted by the system. function providePassiveLiquidity( uint256 _amount, address _tokenAddress) external payable override nonReentrant whenNotPaused { require (_amount > 0 || msg.value > 0 , "ERR: AMOUNT" ); if ( msg.value > 0 ) { require ( vaultConfig.getUnderlyingIOUAddress(vaultConfig.wethAddress()) != address ( 0 ), "ERR: WETH NOT WHITELISTED" ); _provideLiquidity( msg.value , vaultConfig.wethAddress(), 0 ); } else { require (_tokenAddress != address ( 0 ), "ERR: INVALID TOKEN" ); require ( vaultConfig.getUnderlyingIOUAddress(_tokenAddress) != address ( 0 ), "ERR: TOKEN NOT WHITELISTED" ); _provideLiquidity(_amount, _tokenAddress, 0 ); } } Figure 17.1: The providePassiveLiquidity function in MosaicVault:127-149 However, providePassiveLiquidity() uses an incorrect function call to check the whitelist status. Instead of calling getUnderlyingReceiptAddress() , it calls getUnderlyingIOUAddress() . The same issue occurs in checks of WETH deposits. Exploit Scenario Eve decides to deposit liquidity in the form of a token that is whitelisted only for active LPs. The token provides a higher yield than the tokens whitelisted for passive LPs. This may enable Eve to receive a higher annual percentage yield on her deposit than other passive LPs in the system receive on theirs. Recommendations Short term, change the function called to validate tokenAddress and wethAddress from getUnderlyingIOUAddress() to getUnderlyingReceiptAddress() . Long term, take the following steps: ● ● ● Review the codebase to identify similar errors. Consider whether the assumption that the same tokens will be whitelisted for both passive and active LPs will hold in the future. Create a more extensive test suite capable of testing edge cases that may invalidate system assumptions. 
18. Solidity compiler optimizations can be problematic Severity: Informational Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-CMP-18 Target: CrosslayerPortal , apy-hunter Description The Composable Finance contracts have enabled optional compiler optimizations in Solidity. There have been several optimization bugs with security implications. Moreover, optimizations are actively being developed . Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them. Therefore, it is unclear how well they are being tested and exercised. High-severity security issues due to optimization bugs have occurred in the past . A high-severity bug in the emscripten -generated solc-js compiler used by Truﬄe and Remix persisted until late 2018. The ﬁx for this bug was not reported in the Solidity CHANGELOG. Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6 . More recently, another bug due to the incorrect caching of keccak256 was reported. A compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe . It is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations. Exploit Scenario A latent or future bug in Solidity compiler optimizations—or in the Emscripten transpilation to solc-js —causes a security vulnerability in the Composable Finance contracts. Recommendations Short term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug. Long term, monitor the development and adoption of Solidity compiler optimizations to assess their maturity. 
19. Lack of contract documentation Severity: Informational Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-CMP-19 Target: Throughout the code Description The codebases lack code documentation, high-level descriptions, and examples, making the contracts diﬃcult to review and increasing the likelihood of user mistakes. The CrosslayerPortal codebase would beneﬁt from additional documentation, including on the following: ● ● ● ● ● ● The logic responsible for setting the roles in the core and the reason for the manipulation of indexes The incoming function arguments and the values used on source chains and destination chains The arithmetic involved in reward calculations and the relayer’s distribution of tokens The checks performed by the oﬀ-chain components, such as the relayer and the rebalancing bot The third-party integrations The rebalancing arithmetic and calculations There should also be clear NatSpec documentation on every function, identifying the unit of each variable, the function’s intended use, and the function’s safe values. The documentation should include all expected properties and assumptions relevant to the aforementioned aspects of the codebase. Recommendations Short term, review and properly document the aforementioned aspects of the codebase. Long term, consider writing a formal speciﬁcation of the protocol. 
21. Unnecessary complexity due to interactions with native and smart contract tokens Severity: Informational Diﬃculty: Low Type: Data Validation Finding ID: TOB-CMP-21 Target: apyhunter-tricrypto/contracts/sushiswap/SushiSlpStrategy.sol Description The Composable Finance code is needlessly complex and has excessive branching. Its complexity largely results from the integration of both ERC20s and native tokens (i.e., ether). Creating separate functions that convert native tokens to ERC20s and then interact with functions that must receive ERC20 tokens (i.e., implementing separation of concerns) would drastically simplify and optimize the code. This complexity is the source of many bugs and increases the gas costs for all users whether or not they need to distinguish between ERC20s and ether. It is best practice to make components as small as possible and to separate helpful but noncritical components into periphery contracts. This reduces the attack surface and improves readability. Figure 21.1 shows an example of complex code. if (tempData.isSlp) { IERC20(sushiConfig.slpToken()).safeTransfer( msg.sender , tempData.slpAmount ); [...] } else { //unwrap and send the right asset [...] if (tempData.isEth) { [...] } else { IERC20(sushiConfig.wethToken()).safeTransfer( Figure 21.1: Part of the withdraw function in SushiSlpStrategy.sol:L180-L216 Recommendations Short term, remove the native ether interactions and use WETH instead. Long term, minimize the function complexity by breaking functions into smaller units. Additionally, refactor the code with minimalism in mind and extend the core functionality into periphery contracts. 
29. Use of legacy openssl version in CrosslayerPortal tests Severity: Informational Diﬃculty: N/A Type: Patching Finding ID: TOB-CMP-29 Target: CrosslayerPortal Description The CrosslayerPortal project uses a legacy version of openssl to run tests. While this version is not exposed in production, the use of outdated security protocols may be risky (ﬁgure 29.1). An unexpected error occurred: Error: error:0308010C:digital envelope routines::unsupported at new Hash (node:internal/crypto/hash:67:19) at Object.createHash (node:crypto:130:10) at hash160 (~/CrosslayerPortal/node_modules/ethereum-cryptography/vendor/hdkey-without-crypto.js:249:21 ) at HDKey.set (~/CrosslayerPortal/node_modules/ethereum-cryptography/vendor/hdkey-without-crypto.js:50:24) at Function.HDKey.fromMasterSeed (~/CrosslayerPortal/node_modules/ethereum-cryptography/vendor/hdkey-without-crypto.js:194:20 ) at deriveKeyFromMnemonicAndPath (~/CrosslayerPortal/node_modules/hardhat/src/internal/util/keys-derivation.ts:21:27) at derivePrivateKeys (~/CrosslayerPortal/node_modules/hardhat/src/internal/core/providers/util.ts:29:52) at normalizeHardhatNetworkAccountsConfig (~/CrosslayerPortal/node_modules/hardhat/src/internal/core/providers/util.ts:56:10) at createProvider (~/CrosslayerPortal/node_modules/hardhat/src/internal/core/providers/construction.ts:78:59) at ~/CrosslayerPortal/node_modules/hardhat/src/internal/core/runtime-environment.ts:80:28 { opensslErrorStack: [ 'error:03000086:digital envelope routines::initialization error' ], library: 'digital envelope routines', reason: 'unsupported', code: 'ERR_OSSL_EVP_UNSUPPORTED' } Figure 29.1: Errors ﬂagged in npx hardhat testing Recommendations Short term, refactor the code to use a new version of openssl to prevent the exploitation of openssl vulnerabilities. Long term, avoid using outdated or legacy versions of dependencies. 22. Commented-out and unimplemented conditional statements Severity: Undetermined Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-CMP-22 Target: apyhunter-tricrypto/contracts/sushiswap/SushiSlpStrategy.sol Description The Composable Finance system does not deﬁne or document the expected behavior of certain conditional statements. It is diﬃcult to assess the correctness or security of the code without an understanding of its expected behavior. For example, it is unclear why one if statement is commented out. // if (!_isSenderKeeperOrOwner(msg.sender)) { totalAmountOfLPs = totalAmountOfLPs - tempData.slpAmount; // } Figure 22.1: Part of the withdraw function in SushiSlpStrategy.sol:L404 Another if statement does not deﬁne what should happen when the condition evaluates to true . if (_isSenderKeeperOrOwner( msg.sender ) && _isReceiveBackLP) {} Figure 22.2: Part of the _deposit function in SushiSlpStrategy.sol:L177-L179 This pattern is error-prone and bad practice. Recommendations Short term, fully implement the necessary logic and remove commented-out code. Long term, remove the ambiguity surrounding the code and conditional branches by clearly documenting and testing the system’s functions. 23. Error-prone NFT management in the Summoner contract Severity: Undetermined Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-CMP-23 Target: CrosslayerPortal Description The Summoner contract’s ability to hold NFTs in a number of states may create confusion regarding the contracts’ states and the diﬀerences between the contracts. For instance, the Summoner contract can hold the following kinds of NFTs: ● ● NFTs that have been pre-minted by Composable Finance and do not have metadata attached to them Original NFTs that have been locked by the Summoner for minting on the destination chain ● MosaicNFT wrapper tokens, which are copies of NFTs that have been locked and are intended to be minted on the destination chain As the system is scaled, the number of NFTs held by the Summoner , especially the number of pre-minted NFTs, will increase signiﬁcantly. Recommendations Simplify the NFT architecture; see the related recommendations in Appendix E .
23. Error-prone NFT management in the Summoner contract Severity: Undetermined Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-CMP-23 Target: CrosslayerPortal Description The Summoner contract’s ability to hold NFTs in a number of states may create confusion regarding the contracts’ states and the diﬀerences between the contracts. For instance, the Summoner contract can hold the following kinds of NFTs: ● ● NFTs that have been pre-minted by Composable Finance and do not have metadata attached to them Original NFTs that have been locked by the Summoner for minting on the destination chain ● MosaicNFT wrapper tokens, which are copies of NFTs that have been locked and are intended to be minted on the destination chain As the system is scaled, the number of NFTs held by the Summoner , especially the number of pre-minted NFTs, will increase signiﬁcantly. Recommendations Simplify the NFT architecture; see the related recommendations in Appendix E . 
