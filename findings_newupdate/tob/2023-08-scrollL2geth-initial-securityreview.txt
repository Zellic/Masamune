2. Multiple instances of unchecked errors Severity: Low Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-L2GETH-2 Targets: trie/zkproof/writer.go, trie/sync.go, trie/proof.go, trie/committer.go, trie/database.go Description There are multiple instances of unchecked errors in the l2geth codebase, which could lead to undeﬁned behavior when errors are raised. One such unhandled error is shown in ﬁgure 2.1. A comprehensive list of unchecked errors is provided in appendix C. if len(requests) == 0 && req.deps == 0 { s.commit(req) } else { Figure 2.1: The Sync.commit() function returns an error that is unhandled, which could lead to invalid commitments or a frozen chain. (go-ethereum/trie/sync.go#296–298) Unchecked errors also make the system vulnerable to denial-of-service attacks; they could allow attackers to trigger nil dereference panics in the sequencer node. Exploit Scenario An attacker identiﬁes a way to cause a zkTrie commitment to fail, allowing invalid data to be silently committed by the sequencer. Recommendations Short term, add error checks to all functions that can emit Go errors. Long term, add the tools errcheck and ineffassign to l2geth’s build pipeline. These tools can be used to detect errors and prevent builds containing unchecked errors from being deployed. 
3. Risk of double-spend attacks due to use of single-node Clique consensus without ﬁnality API Severity: Medium Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-L2GETH-3 Target: N/A Description l2geth uses the proof-of-authority Clique consensus protocol, deﬁned by EIP-255. This consensus type is not designed for single-node networks, and an attacker-controlled sequencer node may produce multiple conﬂicting forks of the chain to facilitate double-spend attacks. The severity of this ﬁnding is compounded by the fact that there is no API for an end user to determine whether their transaction has been ﬁnalized by L1, forcing L2 users to use ineﬀective block/time delays to determine ﬁnality. Clique consensus was originally designed as a replacement for proof-of-work consensus for Ethereum testnets. It uses the same fork choice rule as Ethereum’s proof-of-work consensus; the fork with the highest “diﬃculty” should be considered the canonical fork. Clique consensus does not use proof-of-work and cannot update block diﬃculty using the traditional calculation; instead, block diﬃculty may be one of two values: ● “1” if the block was mined by the designated signer for the block height ● “2” if the block was mined by a non-designated signer for the block height This means that in a network with only one authorized signer, all of the blocks and forks produced by the sequencer will have the same diﬃculty value, making it impossible for syncing nodes to determine which fork is canonical at the given block height. In a normal proof-of-work network, one of the proposed blocks will have a higher diﬃculty value, causing syncing nodes to re-organize and drop the block with the lower diﬃculty value. In a single-validator proof-of-authority network, neither block will be preferred, so each syncing node will simply prefer the ﬁrst block they received. This ﬁnding is not unique to l2geth; it will be endemic to all L2 systems that have only one authorized sequencer. Exploit Scenario An attacker acquires control over l2geth’s centralized sequencer node. The attacker modiﬁes the node to prove two forks: one fork containing a deposit transaction to a centralized exchange, and one fork with no such deposit transaction. The attacker publishes the ﬁrst fork, and the centralized exchange picks up and processes the deposit transaction. The attacker continues to produce blocks on the second private fork. Once the exchange processes the deposit, the attacker stops generating blocks on the public fork, generates an extra block to make the private fork longer than the public fork, then publishes the private fork to cause a re-organization across syncing nodes. This attack must be completed before the sequencer is required to publish a proof to L1. Recommendations Short term, add API methods and documentation to ensure that bridges and centralized exchanges query only for transactions that have been proved and ﬁnalized on the L1 network. Long term, decentralize the sequencer in such a way that a majority of sequencers must collude in order to successfully execute a double-spend attack. This design should be accompanied by a slashing mechanism to penalize sequencers that sign conﬂicting blocks. 
4. Improper use of panic Severity: Low Diﬃculty: Medium Type: Denial of Service Finding ID: TOB-L2GETH-4 Target: Various areas of the codebase Description l2geth overuses Go’s panic mechanism in lieu of Go’s built-in error propagation system, introducing opportunities for denial of service. Go has two primary methods through which errors can be reported or propagated up the call stack: the panic method and Go errors. The use of panic is not recommended, as it is unrecoverable: when an operation panics, the Go program is terminated and must be restarted. The use of panic creates a denial-of-service vector that is especially applicable to a centralized sequencer, as a restart of the sequencer would eﬀectively halt the L2 network until the sequencer recovers. Some example uses of panic are presented in ﬁgures 4.1 to 4.3. These do not represent an exhaustive list of panic statements in the codebase, and the Scroll team should investigate each use of panic in its modiﬁed code to verify whether it truly represents an unrecoverable error. func sanityCheckByte32Key(b []byte) { if len(b) != 32 && len(b) != 20 { panic(fmt.Errorf("do not support length except for 120bit and 256bit now. data: %v len: %v", b, len(b))) } } Figure 4.1: The sanityCheckByte32Key function panics when a trie key does not match the expected size. This function may be called during the execution of certain RPC requests. (go-ethereum/trie/zk_trie.go#44–48) func (s *StateAccount) MarshalFields() ([]zkt.Byte32, uint32) { fields := make([]zkt.Byte32, 5) if s.Balance == nil { panic("StateAccount balance nil") } if !utils.CheckBigIntInField(s.Balance) { panic("StateAccount balance overflow") } if !utils.CheckBigIntInField(s.Root.Big()) { panic("StateAccount root overflow") } if !utils.CheckBigIntInField(new(big.Int).SetBytes(s.PoseidonCodeHash)) { panic("StateAccount poseidonCodeHash overflow") } Figure 4.2: The MarshalFields function panics when attempting to marshal an object that does not match certain requirements. This function may be called during the execution of certain RPC requests. (go-ethereum/core/types/state_account_marshalling.go#47–64) func (t *ProofTracer) MarkDeletion(key []byte) { if path, existed := t.emptyTermPaths[string(key)]; existed { // copy empty node terminated path for final scanning t.rawPaths[string(key)] = path } else if path, existed = t.rawPaths[string(key)]; existed { // sanity check leafNode := path[len(path)-1] if leafNode.Type != zktrie.NodeTypeLeaf { panic("all path recorded in proofTrace should be ended with leafNode") } Figure 4.3: The MarkDeletion function panics when the proof tracer contains a path that does not terminate in a leaf node. This function may be called when a syncing node attempts to process an invalid, malicious proof that an attacker has gossiped on the network. (go-ethereum/trie/zktrie_deletionproof.go#120–130) Exploit Scenario An attacker identiﬁes an error path that terminates with a panic that can be triggered by a malformed RPC request or proof payload. The attacker leverages this issue to either disrupt the sequencer’s operation or prevent follower/syncing nodes from operating properly. Recommendations Short term, review all uses of panic that have been introduced by Scroll’s changes to go-ethereum. Ensure that these uses of panic truly represent unrecoverable errors, and if not, add error handling logic to recover from the errors. Long term, annotate all valid uses of panic with explanations for why the errors are unrecoverable and, if applicable, how to prevent the unrecoverable conditions from being triggered. l2geth’s code review process must also be updated to verify that this documentation exists for new uses of panic that are introduced later. 
5. Risk of panic from nil dereference due to ﬂawed error reporting in addressToKey Severity: Informational Diﬃculty: N/A Type: Error Reporting Finding ID: TOB-L2GETH-5 Target: trie/zkproof/writer.go Description The addressToKey function, shown in ﬁgure 5.1, returns a nil pointer instead of a Go error when an error is returned by the preImage.Hash() function, which will cause a nil dereference panic in the NewZkTrieProofWriter function, as shown in ﬁgure 5.2. If the error generated by preImage.Hash() is unrecoverable, the addressToKey function should panic instead of silently returning a nil pointer. func addressToKey(addr common.Address) *zkt.Hash { var preImage zkt.Byte32 copy(preImage[:], addr.Bytes()) h, err := preImage.Hash() if err != nil { log.Error("hash failure", "preImage", hexutil.Encode(preImage[:])) return nil } return zkt.NewHashFromBigInt(h) } Figure 5.1: The addressToKey function returns a nil pointer to zkt.Hash when an error is returned by preImage.Hash(). (go-ethereum/trie/zkproof/writer.go#31–41) func NewZkTrieProofWriter(storage *types.StorageTrace) (*zktrieProofWriter, error) { underlayerDb := memorydb.New() zkDb := trie.NewZktrieDatabase(underlayerDb) accounts := make(map[common.Address]*types.StateAccount) // resuming proof bytes to underlayerDb for addrs, proof := range storage.Proofs { if n := resumeProofs(proof, underlayerDb); n != nil { addr := common.HexToAddress(addrs) if n.Type == zktrie.NodeTypeEmpty { accounts[addr] = nil } else if acc, err := types.UnmarshalStateAccount(n.Data()); err == nil { if bytes.Equal(n.NodeKey[:], addressToKey(addr)[:]) { accounts[addr] = acc Figure 5.2: The addressToKey function is consumed by NewZkTrieProofWriter, which will attempt to dereference the nil pointer and generate a system panic. (go-ethereum/trie/zkproof/writer.go#152–167) Recommendations Short term, modify addressToKey so that it either returns an error that its calling functions can propagate or, if the error is unrecoverable, panics instead of returning a nil pointer. Long term, update Scroll’s code review and style guidelines to reﬂect that errors must be propagated by Go’s error system or must halt the program by using panic. 
6. Risk of transaction pool admission denial of service Severity: Low Diﬃculty: Low Type: Denial of Service Finding ID: TOB-L2GETH-6 Target: core/tx_pool.go Description l2geth’s changes to the transaction pool include an ECDSA recovery operation at the beginning of the pool’s transaction validation logic, introducing a denial-of-service vector: an attacker could generate invalid transactions to exhaust the sequencer’s resources. l2geth adds an L1 fee that all L2 transactions must pay. To verify that an L2 transaction can aﬀord the L1 fee, the transaction pool calls fees.VerifyFee(), as shown in ﬁgure 6.1. VerifyFee() performs an ECDSA recovery operation to determine the account that will pay the L1 fee, as shown in ﬁgure 6.2. ECDSA key recovery is an expensive operation that should be executed as late in the transaction validation process as possible in order to reduce the impact of denial-of-service attacks. func (pool *TxPool) add(tx *types.Transaction, local bool) (replaced bool, err error) { // If the transaction is already known, discard it hash := tx.Hash() if pool.all.Get(hash) != nil { log.Trace("Discarding already known transaction", "hash", hash) knownTxMeter.Mark(1) return false, ErrAlreadyKnown } // Make the local flag. If it's from local source or it's from the network but // the sender is marked as local previously, treat it as the local transaction. isLocal := local || pool.locals.containsTx(tx) if pool.chainconfig.Scroll.FeeVaultEnabled() { if err := fees.VerifyFee(pool.signer, tx, pool.currentState); err != nil { Figure 6.1: TxPool.add() calls fees.VerifyFee() before any other transaction validators are called. (go-ethereum/core/tx_pool.go#684–697) func VerifyFee(signer types.Signer, tx *types.Transaction, state StateDB) error { from, err := types.Sender(signer, tx) if err != nil { return errors.New("invalid transaction: invalid sender") } Figure 6.2: VerifyFee() initiates an ECDSA recovery operation via types.Sender(). (go-ethereum/rollup/fees/rollup_fee.go#198–202) Exploit Scenario An attacker generates a denial-of-service attack against the sequencer by submitting extraordinarily large transactions. Because ECDSA recovery is a CPU-intensive operation and is executed before the transaction size is checked, the attacker is able to exhaust the memory resources of the sequencer. Recommendations Short term, modify the code to check for L1 fees in the TxPool.validateTx() function immediately after that function calls types.Sender(). This will ensure that other, less expensive-to-check validations are performed before the ECDSA signature is recovered. Long term, exercise caution when making changes to code paths that validate information received from public sources or gossip. For changes to the transaction pool, a good general rule of thumb is to validate transaction criteria in the following order: 1. Simple, in-memory criteria that do not require disk reads or data manipulation 2. Criteria that require simple, in-memory manipulations of the data such as checks of the transaction size 3. Criteria that require an in-memory state trie to be checked 4. ECDSA recovery operations 5. Criteria that require an on-disk state trie to be checked However, note that sometimes these criteria must be checked out of order; for example, the ECDSA recovery operation to identify the origin account may need to be performed before the state trie is checked to determine whether the account can aﬀord the transaction. 
1. Transaction pool fails to drop transactions that cannot a ord L1 fees Severity: Informational Diﬃculty: Low Type: Data Validation Finding ID: TOB-L2GETH-1 Target: core/types/transaction.go Description l2geth deﬁnes two fees that must be paid for L2 transactions: an L2 fee and an L1 fee. However, the code fails to account for L1 fees; as a result, transactions that cannot aﬀord the combined L1 and L2 fees may be included in a block rather than demoted, as intended. The transaction.go ﬁle deﬁnes a Cost() function that returns the amount of ether that a transaction consumes, as shown in ﬁgure 1.1. The current implementation of Cost() does not account for L1 fees, causing other parts of the codebase to misjudge the balance requirements to execute a transaction. The correct implementation of Cost() should match the implementation of VerifyFee(), which correctly checks for L1 fees. // Cost returns gas * gasPrice + value. func (tx *Transaction) Cost() *big.Int { total := new(big.Int).Mul(tx.GasPrice(), new(big.Int).SetUint64(tx.Gas())) total.Add(total, tx.Value()) return total } Figure 1.1: The Cost() function does not include L1 fees in its calculation. (go-ethereum/core/types/transaction.go#318–323) Most notably, Cost() is consumed by the tx_list.Filter() function, which is used to prune un-executable transactions (transactions that cannot aﬀord the fees), as shown in ﬁgure 1.2. The failure to account for L1 fees in Cost() could cause tx_list.Filter() to fail to demote such transactions, causing them to be incorrectly included in the block. func (l *txList) Filter(costLimit *big.Int, gasLimit uint64) (types.Transactions, types.Transactions) { // If all transactions are below the threshold, short circuit if l.costcap.Cmp(costLimit) <= 0 && l.gascap <= gasLimit { return nil, nil } l.costcap = new(big.Int).Set(costLimit) // Lower the caps to the thresholds l.gascap = gasLimit // Filter out all the transactions above the account's funds removed := l.txs.Filter(func(tx *types.Transaction) bool { return tx.Gas() > gasLimit || tx.Cost().Cmp(costLimit) > 0 }) Figure 1.2: Filter() uses Cost() to determine which transactions to demote. (go-ethereum/core/tx_list.go#332–343) Exploit Scenario A user creates an L2 transaction that can just barely aﬀord the L1 and L2 fees in the next upcoming block. Their transaction is delayed due to full blocks and is included in a future block in which the L1 fees have risen. Their transaction reverts due to the increased L1 fees instead of being ejected from the transaction pool. Recommendations Short term, refactor the Cost() function to account for L1 fees, as is done in the VerifyFee() function; alternatively, have the transaction list structure use VerifyFee() or a similar function instead of Cost(). Long term, add additional tests to verify complex state transitions such as a transaction becoming un-executable due to changes in L1 fees. 
2. Multiple instances of unchecked errors Severity: Low Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-L2GETH-2 Targets: trie/zkproof/writer.go, trie/sync.go, trie/proof.go, trie/committer.go, trie/database.go Description There are multiple instances of unchecked errors in the l2geth codebase, which could lead to undeﬁned behavior when errors are raised. One such unhandled error is shown in ﬁgure 2.1. A comprehensive list of unchecked errors is provided in appendix C. if len(requests) == 0 && req.deps == 0 { s.commit(req) } else { Figure 2.1: The Sync.commit() function returns an error that is unhandled, which could lead to invalid commitments or a frozen chain. (go-ethereum/trie/sync.go#296–298) Unchecked errors also make the system vulnerable to denial-of-service attacks; they could allow attackers to trigger nil dereference panics in the sequencer node. Exploit Scenario An attacker identiﬁes a way to cause a zkTrie commitment to fail, allowing invalid data to be silently committed by the sequencer. Recommendations Short term, add error checks to all functions that can emit Go errors. Long term, add the tools errcheck and ineffassign to l2geth’s build pipeline. These tools can be used to detect errors and prevent builds containing unchecked errors from being deployed. 
3. Risk of double-spend attacks due to use of single-node Clique consensus without ﬁnality API Severity: Medium Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-L2GETH-3 Target: N/A Description l2geth uses the proof-of-authority Clique consensus protocol, deﬁned by EIP-255. This consensus type is not designed for single-node networks, and an attacker-controlled sequencer node may produce multiple conﬂicting forks of the chain to facilitate double-spend attacks. The severity of this ﬁnding is compounded by the fact that there is no API for an end user to determine whether their transaction has been ﬁnalized by L1, forcing L2 users to use ineﬀective block/time delays to determine ﬁnality. Clique consensus was originally designed as a replacement for proof-of-work consensus for Ethereum testnets. It uses the same fork choice rule as Ethereum’s proof-of-work consensus; the fork with the highest “diﬃculty” should be considered the canonical fork. Clique consensus does not use proof-of-work and cannot update block diﬃculty using the traditional calculation; instead, block diﬃculty may be one of two values: ● “1” if the block was mined by the designated signer for the block height ● “2” if the block was mined by a non-designated signer for the block height This means that in a network with only one authorized signer, all of the blocks and forks produced by the sequencer will have the same diﬃculty value, making it impossible for syncing nodes to determine which fork is canonical at the given block height. In a normal proof-of-work network, one of the proposed blocks will have a higher diﬃculty value, causing syncing nodes to re-organize and drop the block with the lower diﬃculty value. In a single-validator proof-of-authority network, neither block will be preferred, so each syncing node will simply prefer the ﬁrst block they received. This ﬁnding is not unique to l2geth; it will be endemic to all L2 systems that have only one authorized sequencer. Exploit Scenario An attacker acquires control over l2geth’s centralized sequencer node. The attacker modiﬁes the node to prove two forks: one fork containing a deposit transaction to a centralized exchange, and one fork with no such deposit transaction. The attacker publishes the ﬁrst fork, and the centralized exchange picks up and processes the deposit transaction. The attacker continues to produce blocks on the second private fork. Once the exchange processes the deposit, the attacker stops generating blocks on the public fork, generates an extra block to make the private fork longer than the public fork, then publishes the private fork to cause a re-organization across syncing nodes. This attack must be completed before the sequencer is required to publish a proof to L1. Recommendations Short term, add API methods and documentation to ensure that bridges and centralized exchanges query only for transactions that have been proved and ﬁnalized on the L1 network. Long term, decentralize the sequencer in such a way that a majority of sequencers must collude in order to successfully execute a double-spend attack. This design should be accompanied by a slashing mechanism to penalize sequencers that sign conﬂicting blocks. 
4. Improper use of panic Severity: Low Diﬃculty: Medium Type: Denial of Service Finding ID: TOB-L2GETH-4 Target: Various areas of the codebase Description l2geth overuses Go’s panic mechanism in lieu of Go’s built-in error propagation system, introducing opportunities for denial of service. Go has two primary methods through which errors can be reported or propagated up the call stack: the panic method and Go errors. The use of panic is not recommended, as it is unrecoverable: when an operation panics, the Go program is terminated and must be restarted. The use of panic creates a denial-of-service vector that is especially applicable to a centralized sequencer, as a restart of the sequencer would eﬀectively halt the L2 network until the sequencer recovers. Some example uses of panic are presented in ﬁgures 4.1 to 4.3. These do not represent an exhaustive list of panic statements in the codebase, and the Scroll team should investigate each use of panic in its modiﬁed code to verify whether it truly represents an unrecoverable error. func sanityCheckByte32Key(b []byte) { if len(b) != 32 && len(b) != 20 { panic(fmt.Errorf("do not support length except for 120bit and 256bit now. data: %v len: %v", b, len(b))) } } Figure 4.1: The sanityCheckByte32Key function panics when a trie key does not match the expected size. This function may be called during the execution of certain RPC requests. (go-ethereum/trie/zk_trie.go#44–48) func (s *StateAccount) MarshalFields() ([]zkt.Byte32, uint32) { fields := make([]zkt.Byte32, 5) if s.Balance == nil { panic("StateAccount balance nil") } if !utils.CheckBigIntInField(s.Balance) { panic("StateAccount balance overflow") } if !utils.CheckBigIntInField(s.Root.Big()) { panic("StateAccount root overflow") } if !utils.CheckBigIntInField(new(big.Int).SetBytes(s.PoseidonCodeHash)) { panic("StateAccount poseidonCodeHash overflow") } Figure 4.2: The MarshalFields function panics when attempting to marshal an object that does not match certain requirements. This function may be called during the execution of certain RPC requests. (go-ethereum/core/types/state_account_marshalling.go#47–64) func (t *ProofTracer) MarkDeletion(key []byte) { if path, existed := t.emptyTermPaths[string(key)]; existed { // copy empty node terminated path for final scanning t.rawPaths[string(key)] = path } else if path, existed = t.rawPaths[string(key)]; existed { // sanity check leafNode := path[len(path)-1] if leafNode.Type != zktrie.NodeTypeLeaf { panic("all path recorded in proofTrace should be ended with leafNode") } Figure 4.3: The MarkDeletion function panics when the proof tracer contains a path that does not terminate in a leaf node. This function may be called when a syncing node attempts to process an invalid, malicious proof that an attacker has gossiped on the network. (go-ethereum/trie/zktrie_deletionproof.go#120–130) Exploit Scenario An attacker identiﬁes an error path that terminates with a panic that can be triggered by a malformed RPC request or proof payload. The attacker leverages this issue to either disrupt the sequencer’s operation or prevent follower/syncing nodes from operating properly. Recommendations Short term, review all uses of panic that have been introduced by Scroll’s changes to go-ethereum. Ensure that these uses of panic truly represent unrecoverable errors, and if not, add error handling logic to recover from the errors. Long term, annotate all valid uses of panic with explanations for why the errors are unrecoverable and, if applicable, how to prevent the unrecoverable conditions from being triggered. l2geth’s code review process must also be updated to verify that this documentation exists for new uses of panic that are introduced later. 
5. Risk of panic from nil dereference due to ﬂawed error reporting in addressToKey Severity: Informational Diﬃculty: N/A Type: Error Reporting Finding ID: TOB-L2GETH-5 Target: trie/zkproof/writer.go Description The addressToKey function, shown in ﬁgure 5.1, returns a nil pointer instead of a Go error when an error is returned by the preImage.Hash() function, which will cause a nil dereference panic in the NewZkTrieProofWriter function, as shown in ﬁgure 5.2. If the error generated by preImage.Hash() is unrecoverable, the addressToKey function should panic instead of silently returning a nil pointer. func addressToKey(addr common.Address) *zkt.Hash { var preImage zkt.Byte32 copy(preImage[:], addr.Bytes()) h, err := preImage.Hash() if err != nil { log.Error("hash failure", "preImage", hexutil.Encode(preImage[:])) return nil } return zkt.NewHashFromBigInt(h) } Figure 5.1: The addressToKey function returns a nil pointer to zkt.Hash when an error is returned by preImage.Hash(). (go-ethereum/trie/zkproof/writer.go#31–41) func NewZkTrieProofWriter(storage *types.StorageTrace) (*zktrieProofWriter, error) { underlayerDb := memorydb.New() zkDb := trie.NewZktrieDatabase(underlayerDb) accounts := make(map[common.Address]*types.StateAccount) // resuming proof bytes to underlayerDb for addrs, proof := range storage.Proofs { if n := resumeProofs(proof, underlayerDb); n != nil { addr := common.HexToAddress(addrs) if n.Type == zktrie.NodeTypeEmpty { accounts[addr] = nil } else if acc, err := types.UnmarshalStateAccount(n.Data()); err == nil { if bytes.Equal(n.NodeKey[:], addressToKey(addr)[:]) { accounts[addr] = acc Figure 5.2: The addressToKey function is consumed by NewZkTrieProofWriter, which will attempt to dereference the nil pointer and generate a system panic. (go-ethereum/trie/zkproof/writer.go#152–167) Recommendations Short term, modify addressToKey so that it either returns an error that its calling functions can propagate or, if the error is unrecoverable, panics instead of returning a nil pointer. Long term, update Scroll’s code review and style guidelines to reﬂect that errors must be propagated by Go’s error system or must halt the program by using panic. 
6. Risk of transaction pool admission denial of service Severity: Low Diﬃculty: Low Type: Denial of Service Finding ID: TOB-L2GETH-6 Target: core/tx_pool.go Description l2geth’s changes to the transaction pool include an ECDSA recovery operation at the beginning of the pool’s transaction validation logic, introducing a denial-of-service vector: an attacker could generate invalid transactions to exhaust the sequencer’s resources. l2geth adds an L1 fee that all L2 transactions must pay. To verify that an L2 transaction can aﬀord the L1 fee, the transaction pool calls fees.VerifyFee(), as shown in ﬁgure 6.1. VerifyFee() performs an ECDSA recovery operation to determine the account that will pay the L1 fee, as shown in ﬁgure 6.2. ECDSA key recovery is an expensive operation that should be executed as late in the transaction validation process as possible in order to reduce the impact of denial-of-service attacks. func (pool *TxPool) add(tx *types.Transaction, local bool) (replaced bool, err error) { // If the transaction is already known, discard it hash := tx.Hash() if pool.all.Get(hash) != nil { log.Trace("Discarding already known transaction", "hash", hash) knownTxMeter.Mark(1) return false, ErrAlreadyKnown } // Make the local flag. If it's from local source or it's from the network but // the sender is marked as local previously, treat it as the local transaction. isLocal := local || pool.locals.containsTx(tx) if pool.chainconfig.Scroll.FeeVaultEnabled() { if err := fees.VerifyFee(pool.signer, tx, pool.currentState); err != nil { Figure 6.1: TxPool.add() calls fees.VerifyFee() before any other transaction validators are called. (go-ethereum/core/tx_pool.go#684–697) func VerifyFee(signer types.Signer, tx *types.Transaction, state StateDB) error { from, err := types.Sender(signer, tx) if err != nil { return errors.New("invalid transaction: invalid sender") } Figure 6.2: VerifyFee() initiates an ECDSA recovery operation via types.Sender(). (go-ethereum/rollup/fees/rollup_fee.go#198–202) Exploit Scenario An attacker generates a denial-of-service attack against the sequencer by submitting extraordinarily large transactions. Because ECDSA recovery is a CPU-intensive operation and is executed before the transaction size is checked, the attacker is able to exhaust the memory resources of the sequencer. Recommendations Short term, modify the code to check for L1 fees in the TxPool.validateTx() function immediately after that function calls types.Sender(). This will ensure that other, less expensive-to-check validations are performed before the ECDSA signature is recovered. Long term, exercise caution when making changes to code paths that validate information received from public sources or gossip. For changes to the transaction pool, a good general rule of thumb is to validate transaction criteria in the following order: 
1. Simple, in-memory criteria that do not require disk reads or data manipulation 
2. Criteria that require simple, in-memory manipulations of the data such as checks of the transaction size 
3. Criteria that require an in-memory state trie to be checked 
4. ECDSA recovery operations 
5. Criteria that require an on-disk state trie to be checked However, note that sometimes these criteria must be checked out of order; for example, the ECDSA recovery operation to identify the origin account may need to be performed before the state trie is checked to determine whether the account can aﬀord the transaction. 
7. Syncing nodes fail to check consensus rule for L1 message count Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-L2GETH-7 Target: core/block_validator.go Description l2geth adds a consensus rule requiring that there be no more than L1Config.NumL1MessagesPerBlock number of L1 messages per L2 block. This rule is checked by the sequencer when building new blocks but is not checked by syncing nodes through the ValidateL1Messages function, as shown in ﬁgure 7.1. // TODO: consider adding a rule to enforce L1Config.NumL1MessagesPerBlock. // If there are L1 messages available, sequencer nodes should include them. // However, this is hard to enforce as different nodes might have different views of L1. Figure 7.1: The ValidateL1Messages function does not check the NumL1MessagesPerBlock restriction. (go-ethereum/core/block_validator.go#145–147) The TODO comment shown in the ﬁgure expresses a concern that syncing nodes cannot enforce NumL1MessagesPerBlock due to the diﬀerent view of L1 that the nodes may have; however, this issue does not prevent syncing nodes from simply checking the number of L1 messages included in the block. Exploit Scenario A malicious sequencer ignores the NumL1MessagesPerBlock restriction while constructing a block, thus bypassing the consensus rules. Follower nodes consider the block to be valid even though the consensus rule is violated. Recommendations Short term, add a check to ValidateL1Messages to check the maximum number of L1 messages per block restriction. Long term, document and check all changes to the system’s consensus rules to ensure that both nodes that construct blocks and nodes that sync blocks check the consensus rules. This includes having syncing nodes check whether an L1 transaction actually exists on the L1, a concern expressed in comments further up in the ValidateL1Messages function. A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diﬃculty levels used in this document. Vulnerability Categories Category Description Access Controls Insuﬃcient authorization or assessment of rights Auditing and Logging Insuﬃcient auditing of actions or logging of problems Authentication Improper identiﬁcation of users Conﬁguration Misconﬁgured servers, devices, or software components Cryptography A breach of system conﬁdentiality or integrity Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service A system failure with an availability impact Error Reporting Insecure or insuﬃcient reporting of error conditions Patching Use of an outdated software package or library Session Management Improper identiﬁcation of authenticated users Testing Timing Insuﬃcient test methodology or test coverage Race conditions or other order-of-operations ﬂaws Undeﬁned Behavior Undeﬁned behavior triggered within the system Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices. Undetermined The extent of the risk was not determined during this engagement. Low The risk is small or is not one the client has indicated is important. Medium High User information is at risk; exploitation could pose reputational, legal, or moderate ﬁnancial risks. The ﬂaw could aﬀect numerous users and have serious reputational, legal, or ﬁnancial implications. Diﬃculty Levels Diﬃculty Description Undetermined The diﬃculty of exploitation was not determined during this engagement. Low Medium High The ﬂaw is well known; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of the system. An attacker must have privileged access to the system, may need to know complex technical details, or must discover other weaknesses to exploit this issue. B. Code Maturity Categories The following tables describe the code maturity categories and rating criteria used in this document. Code Maturity Categories Category Description Arithmetic The proper use of mathematical operations and semantics Auditing The use of event auditing and logging to support monitoring Authentication / Access Controls The use of robust access controls to handle identiﬁcation and authorization and to ensure safe interactions with the system Complexity Management The presence of clear structures designed to manage system complexity, including the separation of system logic into clearly deﬁned functions Cryptography and Key Management The safe use of cryptographic primitives and functions, along with the presence of robust mechanisms for key generation and distribution Decentralization The presence of a decentralized governance structure for mitigating insider threats and managing risks posed by contract upgrades Documentation The presence of comprehensive and readable codebase documentation Transaction Ordering Risks Memory Safety and Error Handling Low-Level Manipulation Testing and Veriﬁcation Rating Criteria Rating Strong The system’s resistance to transaction re-ordering attacks The presence of memory safety and robust error-handling mechanisms The justiﬁed use of inline assembly and low-level calls The presence of robust testing procedures (e.g., unit tests, integration tests, and veriﬁcation methods) and suﬃcient test coverage Description No issues were found, and the system exceeds industry standards. Satisfactory Minor issues were found, but the system is compliant with best practices. Moderate Some issues that may aﬀect system safety were found. Weak Many issues that aﬀect system safety were found. Missing A required component is missing, signiﬁcantly aﬀecting system safety. Not Applicable The category is not applicable to this review. Not Considered The category was not considered in this review. Further Investigation Required Further investigation is required to reach a meaningful conclusion. C. Unchecked Errors List The following table lists the various unhandled Go errors, as reported in ﬁnding TOB-L2GETH-2. Location Functions with Unchecked Errors trie/zkproof/writer.go, line 226 underlayerDb.Put() trie/zkproof/writer.go, line 57 db.Put() trie/sync.go, line 297 trie/sync.go, line 279 trie/proof.go, line 567 trie/proof.go, line 497 trie/proof.go, line 86 trie/committer.go, line 229 trie/committer.go, line 235 s.commit() s.commit() tr.TryUpdate() tr.TryUpdate() proofDb.Put() c.onleaf() c.onleaf() trie/committer.go, line 245 c.sha.Write() trie/committer.go, line 256 c.sha.Read() trie/database.go, line 581 db.preimages.commit() trie/database.go, line 659 batch.Put() trie/database.go, line 676 db.preimages.commit() trie/database.go, line 695 batch.Replay() trie/database.go, line 743 batch.Replay() trie/database.go, line 850 db.saveCache() D. Code Quality Findings This appendix contains ﬁndings that do not have immediate or obvious security implications. However, they may facilitate exploit chains targeting other vulnerabilities or become easily exploitable in future releases. ● Avoid the use of magic values. The use of hard-coded magic values within code introduces ambiguity because they lack clear context, making it challenging for developers/auditors to understand their purpose and signiﬁcance. By using variables or constants, meaningful names can be provided to these values, oﬀering self-documentation and improving code comprehension. func toWordSize(size uint64) uint64 { if size > math.MaxUint64-31 { return math.MaxUint64/32 + 1 } return (size + 31) / 32 } Figure D.1: go-ethereum/core/state_transition.go#173–179 func IterateL1MessagesFrom(db ethdb.Iteratee, fromQueueIndex uint64) L1MessageIterator { start := encodeQueueIndex(fromQueueIndex) it := db.NewIterator(l1MessagePrefix, start) keyLength := len(l1MessagePrefix) + 8 Figure D.2: go-ethereum/core/rawdb/accessors_l1_message.go#108–112 ● Remove redundant code. Clean up the redundant code related to handling uncle blocks and forks, as the codebase does not recognize or produce uncle blocks. Removing this unnecessary functionality will simplify the code, making it easier to understand and maintain. ● Address TODO statements or create tickets for them. TODO statements should remain in a codebase only while the codebase is in a pre-release state. Address TODO statements that can be addressed immediately; for those that cannot be addressed before production deployment, create tickets to ensure that they are prioritized. ● Use feature ﬂags to control network behavior instead of using reﬂection or magic hashes. Some features in l2geth use reﬂection or the presence of a speciﬁc hash in a database to determine whether certain features are enabled, as in the VerifyProof function, shown in ﬁgure D.3. Feature ﬂags provide a better, more uniﬁed interface to enable or disable speciﬁc features or functionality. If a function needs to operate in multiple, simultaneous modes, an encapsulating function should be used to make it clear that the behavior is not speciﬁc to a network feature. func VerifyProof(rootHash common.Hash, key []byte, proofDb ethdb.KeyValueReader) (value []byte, err error) { // test the type of proof (for trie or SMT) if buf, _ := proofDb.Get(magicHash); buf != nil { return VerifyProofSMT(rootHash, key, proofDb) } key = keybytesToHex(key) wantHash := rootHash for i := 0; ; i++ { Figure D.3: The VerifyProof function uses the presence of a magic hash to determine what kind of proof to verify. (go-ethereum/trie/proof.go#106–115) 
