1. Out-of-bounds crash in extract_claims Severity: Low Diﬃculty: Low Type: Data Validation Finding ID: TOB-WACL-1 Target: wascap/src/wasm.rs Description The strip_custom_section function does not suﬃciently validate data and crashes when the range is not within the buﬀer (ﬁgure 1.1). The function is used in the extract_claims function and is given an untrusted input. In the wasmCloud-otp , even though extract_claims is called as an Erlang NIF (Native Implemented Function) and potentially could bring down the VM upon crashing, the panic is handled gracefully by the Rustler library, resulting in an isolated crash of the Elixir process. if let Some ((id, range )) = payload.as_section() { wasm_encoder::RawSection { id, data: & buf [range] , } .append_to(& mut output); } Figure 1.1: wascap/src/wasm.rs#L161-L167 We found this issue by fuzzing the extract_claims function with cargo-fuzz (ﬁgure 2.1). #![no_main] use libfuzzer_sys::fuzz_target; use getrandom::register_custom_getrandom; // TODO: the program won’t compile without this, why? fn custom_getrandom (buf: & mut [ u8 ]) -> Result <(), getrandom::Error> { return Ok (()); } register_custom_getrandom!(custom_getrandom); fuzz_target!(|data: & [ u8 ]| { let _ = wascap::wasm::extract_claims(data); }); Figure 1.2: A simple extract_claims fuzzing harness that passes the fuzzer-provided bytes straight to the function After ﬁxing the issue (ﬁgure 1.3), we fuzzed the function for an extended period of time; however, we found no additional issues. if let Some ((id, range)) = payload.as_section() { if range.end <= buf.len() { wasm_encoder::RawSection { id, data: & buf [range], } .append_to(& mut output); } else { return Err (errors::new(ErrorKind::InvalidCapability)); } } Figure 1.3: The ﬁx we applied to continue fuzzing extract_claims . The code requires a new error value because we reused one of the existing ones that likely does not match the semantics. Exploit Scenario An attacker deploys a new module with invalid claims. While decoding the claims, the extract_claims function panics and crashes the Elixir process. Recommendations Short term, ﬁx the strip_custom_section function by adding the range check, as shown in the ﬁgure 1.3. Add the extract_claims fuzzing harness to the wascap repository and run it for an extended period of time before each release of the library. Long term, add a fuzzing harness for each Rust function that processes user-provided data. References ● Erlang - NIFs 
2. Stack overﬂow while enumerating containers in blobstore-fs Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-WACL-2 Target: capability-providers/blobstore-fs/src/fs_utils.rs Description The all_dirs function is vulnerable to a stack overﬂow caused by unbounded recursion, triggered by either the presence of circular symlinks inside the root of the blobstore (as conﬁgured during startup), or the presence of excessively nested directory inside the same. Because this function is used by FsProvider::list_containers , this issue would result in a denial of service for all actors that use the method exposed by aﬀected blobstores. let mut subdirs: Vec <PathBuf> = Vec ::new(); for dir in &dirs { let mut local_subdirs = all_dirs(prefix.join(dir.as_path()).as_path(), prefix); subdirs.append( &mut local_subdirs); } dirs.append( &mut subdirs); dirs Figure 2.1: capability-providers/blobstore-fs/src/fs_utils.rs#L24-L30 Exploit Scenario An attacker creates a circular symlink inside the storage directory. Alternatively, an attacker can—under the right circumstances—create successively nested directories with a suﬃcient depth to cause a stack overﬂow. blobstore.create_container(ctx, &"a".to_string()). await ?; blobstore.create_container(ctx, &"a/a".to_string()). await ?; blobstore.create_container(ctx, &"a/a/a".to_string()). await ?; ... blobstore.create_container(ctx, &"a/a/a/.../a/a/a".to_string()). await ?; blobstore.list_containers(). await ?; Figure 2.2: Possible attack to a vulnerable blobstore In practice, this attack requires the underlying ﬁle system to allow exceptionally long ﬁlenames, and we have not been able to produce a working attack payload. However, this does not prove that no such ﬁle systems exist or will exist in the future. Recommendations Short term, limit the amount of allowable recursion depth to ensure that no stack overﬂow attack is possible given realistic stack sizes, as shown in ﬁgure 2.3. pub fn all_dirs(root: &Path, prefix: &Path, depth: i32 ) -> Vec <PathBuf> { if depth > 1000 { return vec![]; } ... // Now recursively go in all directories and collect all sub-directories let mut subdirs: Vec <PathBuf> = Vec ::new(); for dir in &dirs { let mut local_subdirs = all_dirs( prefix.join(dir.as_path()).as_path(), prefix, depth + 1 ); subdirs.append( &mut local_subdirs); } dirs.append( &mut subdirs); dirs } Figure 2.3: Limiting the amount of allowable recursion depth Long term, consider limiting the reliance on the underlying ﬁle system to a minimum by disallowing nesting containers. For example, Base64-encode all container and object names before passing them down to the ﬁle system routines. References ● OWASP Denial of Service Cheat Sheet ("Input validation" section) 
3. Denial of service in blobstore-s3 using malicious actor Severity: Undetermined Diﬃculty: High Type: Data Validation Finding ID: TOB-WACL-3 Target: capability-providers/blobstore-s3/src/lib.rs Description The stream_bytes function continues looping until it detects that all of the available bytes have been sent. It does this based on the output of the send_chunk function, which reports the amount of bytes that have been sent by the call. An attacker could send specially crafted responses that cause stream_bytes to continue looping, causing send_chunk to report that no errors were detected while also reporting that no bytes were sent. while bytes_sent < bytes_to_send { let chunk_offset = offset + bytes_sent; let chunk_len = (self.max_chunk_size() as u64).min(bytes_to_send - bytes_sent); bytes_sent += self .send_chunk ( ctx, Chunk { is_last: offset + chunk_len > end_range, bytes: bytes[bytes_sent as usize..(bytes_sent + chunk_len) as usize] .to_vec(), offset: chunk_offset as u64, container_id: bucket_id.to_string(), object_id: cobj.object_id.clone(), }, ) .await?; } Figure 3.1: capability-providers/blobstore-s3/src/lib.rs#L188-L204 Exploit Scenario An attacker can send a maliciously crafted request to get an object from a blobstore-s3 provider, then send successful responses without making actual progress in the transfer by reporting that empty-sized chunks were received. Recommendations Make send_chunk report a failure if a zero-sized response is received. 
4. Unexpected panic in validate_token Severity: Informational Diﬃculty: High Type: Error Reporting Finding ID: TOB-WACL-4 Target: wascap/src/jwt.rs Description The validate_token function from the wascap library panics with an out-of-bounds error when input is given in an unexpected format. The function expects the input to be a valid JWT token with three segments separated by a dot (ﬁgure 4.1). This implicit assumption is satisﬁed in the code; however, the function is public and does not mention the assumption in its documentation. /// Validates a signed JWT. This will check the signature, expiration time, and not-valid-before time pub fn validate_token <T>(input: &str ) -> Result <TokenValidation> where T: Serialize + DeserializeOwned + WascapEntity, { } let segments: Vec <& str > = input.split( '.' ).collect(); let header_and_claims = format! ( "{}.{}" , segments[ 0 ] , segments[ 1 ] ); let sig = base64::decode_config( segments[ 2 ] , base64::URL_SAFE_NO_PAD)?; ... Figure 4.1: wascap/src/jwt.rs#L612-L641 Exploit Scenario A developer uses the validate_token function expecting it to fully validate the token string. The function receives an untrusted malicious input that forces the program to panic. Recommendations Short term, add input format validation before accessing the segments and a test case with malformed input. Long term, always validate all inputs to functions or document the input assumptions if validation is not in place for a speciﬁc reason. 
1. Out-of-bounds crash in extract_claims Severity: Low Diﬃculty: Low Type: Data Validation Finding ID: TOB-WACL-1 Target: wascap/src/wasm.rs Description The strip_custom_section function does not suﬃciently validate data and crashes when the range is not within the buﬀer (ﬁgure 1.1). The function is used in the extract_claims function and is given an untrusted input. In the wasmCloud-otp , even though extract_claims is called as an Erlang NIF (Native Implemented Function) and potentially could bring down the VM upon crashing, the panic is handled gracefully by the Rustler library, resulting in an isolated crash of the Elixir process. if let Some ((id, range )) = payload.as_section() { wasm_encoder::RawSection { id, data: & buf [range] , } .append_to(& mut output); } Figure 1.1: wascap/src/wasm.rs#L161-L167 We found this issue by fuzzing the extract_claims function with cargo-fuzz (ﬁgure 2.1). #![no_main] use libfuzzer_sys::fuzz_target; use getrandom::register_custom_getrandom; // TODO: the program won’t compile without this, why? fn custom_getrandom (buf: & mut [ u8 ]) -> Result <(), getrandom::Error> { return Ok (()); } register_custom_getrandom!(custom_getrandom); fuzz_target!(|data: & [ u8 ]| { let _ = wascap::wasm::extract_claims(data); }); Figure 1.2: A simple extract_claims fuzzing harness that passes the fuzzer-provided bytes straight to the function After ﬁxing the issue (ﬁgure 1.3), we fuzzed the function for an extended period of time; however, we found no additional issues. if let Some ((id, range)) = payload.as_section() { if range.end <= buf.len() { wasm_encoder::RawSection { id, data: & buf [range], } .append_to(& mut output); } else { return Err (errors::new(ErrorKind::InvalidCapability)); } } Figure 1.3: The ﬁx we applied to continue fuzzing extract_claims . The code requires a new error value because we reused one of the existing ones that likely does not match the semantics. Exploit Scenario An attacker deploys a new module with invalid claims. While decoding the claims, the extract_claims function panics and crashes the Elixir process. Recommendations Short term, ﬁx the strip_custom_section function by adding the range check, as shown in the ﬁgure 1.3. Add the extract_claims fuzzing harness to the wascap repository and run it for an extended period of time before each release of the library. Long term, add a fuzzing harness for each Rust function that processes user-provided data. References ● Erlang - NIFs 
2. Stack overﬂow while enumerating containers in blobstore-fs Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-WACL-2 Target: capability-providers/blobstore-fs/src/fs_utils.rs Description The all_dirs function is vulnerable to a stack overﬂow caused by unbounded recursion, triggered by either the presence of circular symlinks inside the root of the blobstore (as conﬁgured during startup), or the presence of excessively nested directory inside the same. Because this function is used by FsProvider::list_containers , this issue would result in a denial of service for all actors that use the method exposed by aﬀected blobstores. let mut subdirs: Vec <PathBuf> = Vec ::new(); for dir in &dirs { let mut local_subdirs = all_dirs(prefix.join(dir.as_path()).as_path(), prefix); subdirs.append( &mut local_subdirs); } dirs.append( &mut subdirs); dirs Figure 2.1: capability-providers/blobstore-fs/src/fs_utils.rs#L24-L30 Exploit Scenario An attacker creates a circular symlink inside the storage directory. Alternatively, an attacker can—under the right circumstances—create successively nested directories with a suﬃcient depth to cause a stack overﬂow. blobstore.create_container(ctx, &"a".to_string()). await ?; blobstore.create_container(ctx, &"a/a".to_string()). await ?; blobstore.create_container(ctx, &"a/a/a".to_string()). await ?; ... blobstore.create_container(ctx, &"a/a/a/.../a/a/a".to_string()). await ?; blobstore.list_containers(). await ?; Figure 2.2: Possible attack to a vulnerable blobstore In practice, this attack requires the underlying ﬁle system to allow exceptionally long ﬁlenames, and we have not been able to produce a working attack payload. However, this does not prove that no such ﬁle systems exist or will exist in the future. Recommendations Short term, limit the amount of allowable recursion depth to ensure that no stack overﬂow attack is possible given realistic stack sizes, as shown in ﬁgure 2.3. pub fn all_dirs(root: &Path, prefix: &Path, depth: i32 ) -> Vec <PathBuf> { if depth > 1000 { return vec![]; } ... // Now recursively go in all directories and collect all sub-directories let mut subdirs: Vec <PathBuf> = Vec ::new(); for dir in &dirs { let mut local_subdirs = all_dirs( prefix.join(dir.as_path()).as_path(), prefix, depth + 1 ); subdirs.append( &mut local_subdirs); } dirs.append( &mut subdirs); dirs } Figure 2.3: Limiting the amount of allowable recursion depth Long term, consider limiting the reliance on the underlying ﬁle system to a minimum by disallowing nesting containers. For example, Base64-encode all container and object names before passing them down to the ﬁle system routines. References ● OWASP Denial of Service Cheat Sheet ("Input validation" section) 
3. Denial of service in blobstore-s3 using malicious actor Severity: Undetermined Diﬃculty: High Type: Data Validation Finding ID: TOB-WACL-3 Target: capability-providers/blobstore-s3/src/lib.rs Description The stream_bytes function continues looping until it detects that all of the available bytes have been sent. It does this based on the output of the send_chunk function, which reports the amount of bytes that have been sent by the call. An attacker could send specially crafted responses that cause stream_bytes to continue looping, causing send_chunk to report that no errors were detected while also reporting that no bytes were sent. while bytes_sent < bytes_to_send { let chunk_offset = offset + bytes_sent; let chunk_len = (self.max_chunk_size() as u64).min(bytes_to_send - bytes_sent); bytes_sent += self .send_chunk ( ctx, Chunk { is_last: offset + chunk_len > end_range, bytes: bytes[bytes_sent as usize..(bytes_sent + chunk_len) as usize] .to_vec(), offset: chunk_offset as u64, container_id: bucket_id.to_string(), object_id: cobj.object_id.clone(), }, ) .await?; } Figure 3.1: capability-providers/blobstore-s3/src/lib.rs#L188-L204 Exploit Scenario An attacker can send a maliciously crafted request to get an object from a blobstore-s3 provider, then send successful responses without making actual progress in the transfer by reporting that empty-sized chunks were received. Recommendations Make send_chunk report a failure if a zero-sized response is received. 
4. Unexpected panic in validate_token Severity: Informational Diﬃculty: High Type: Error Reporting Finding ID: TOB-WACL-4 Target: wascap/src/jwt.rs Description The validate_token function from the wascap library panics with an out-of-bounds error when input is given in an unexpected format. The function expects the input to be a valid JWT token with three segments separated by a dot (ﬁgure 4.1). This implicit assumption is satisﬁed in the code; however, the function is public and does not mention the assumption in its documentation. /// Validates a signed JWT. This will check the signature, expiration time, and not-valid-before time pub fn validate_token <T>(input: &str ) -> Result <TokenValidation> where T: Serialize + DeserializeOwned + WascapEntity, { } let segments: Vec <& str > = input.split( '.' ).collect(); let header_and_claims = format! ( "{}.{}" , segments[ 0 ] , segments[ 1 ] ); let sig = base64::decode_config( segments[ 2 ] , base64::URL_SAFE_NO_PAD)?; ... Figure 4.1: wascap/src/jwt.rs#L612-L641 Exploit Scenario A developer uses the validate_token function expecting it to fully validate the token string. The function receives an untrusted malicious input that forces the program to panic. Recommendations Short term, add input format validation before accessing the segments and a test case with malformed input. Long term, always validate all inputs to functions or document the input assumptions if validation is not in place for a speciﬁc reason. 
5. Incorrect error message when starting actor from ﬁle Severity: Informational Diﬃculty: Low Type: Error Reporting Finding ID: TOB-WACL-5 Target: host_core/lib/host_core/actors/actor_supervisor.ex Description The error message when starting an actor from a ﬁle contains a string interpolation bug that causes the message to not include the fileref content (ﬁgure 5.1). This causes the error message to contain the literal string ${fileref} instead. It is worth noting that the ﬁleref content will be included anyway as an attribute. Logger .error( "Failed to read actor file from ${fileref} : #{ inspect(err) } " , fileref : fileref ) Figure 5.1: host_core/lib/host_core/actors/actor_supervisor.ex#L301 Recommendations Short term, change the error message to correctly interpolate the fileref string. A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diﬃculty levels used in this document. Vulnerability Categories Category Description Access Controls Insuﬃcient authorization or assessment of rights Auditing and Logging Insuﬃcient auditing of actions or logging of problems Authentication Improper identiﬁcation of users Conﬁguration Misconﬁgured servers, devices, or software components Cryptography A breach of system conﬁdentiality or integrity Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service A system failure with an availability impact Error Reporting Insecure or insuﬃcient reporting of error conditions Patching Use of an outdated software package or library Session Management Improper identiﬁcation of authenticated users Testing Timing Insuﬃcient test methodology or test coverage Race conditions or other order-of-operations ﬂaws Undeﬁned Behavior Undeﬁned behavior triggered within the system Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices. Undetermined The extent of the risk was not determined during this engagement. Low The risk is small or is not one the client has indicated is important. Medium High User information is at risk; exploitation could pose reputational, legal, or moderate ﬁnancial risks. The ﬂaw could aﬀect numerous users and have serious reputational, legal, or ﬁnancial implications. Diﬃculty Levels Diﬃculty Description Undetermined The diﬃculty of exploitation was not determined during this engagement. Low Medium High The ﬂaw is well known; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of the system. An attacker must have privileged access to the system, may need to know complex technical details, or must discover other weaknesses to exploit this issue. B. Code Maturity Categories The following tables describe the code maturity categories and rating criteria used in this document. Code Maturity Categories Category Description Arithmetic The proper use of mathematical operations and semantics Auditing The use of event auditing and logging to support monitoring Authentication / Access Controls The use of robust access controls to handle identiﬁcation and authorization and to ensure safe interactions with the system Complexity Management The presence of clear structures designed to manage system complexity, including the separation of system logic into clearly deﬁned functions Conﬁguration The conﬁguration of system components in accordance with best practices Cryptography and Key Management The safe use of cryptographic primitives and functions, along with the presence of robust mechanisms for key generation and distribution Data Handling The safe handling of user inputs and data processed by the system Documentation The presence of comprehensive and readable codebase documentation Memory Safety and Error Handling The presence of memory safety and robust error-handling mechanisms Testing and Veriﬁcation The presence of robust testing procedures (e.g., unit tests, integration tests, and veriﬁcation methods) and suﬃcient test coverage Rating Criteria Rating Strong Description No issues were found, and the system exceeds industry standards. Satisfactory Minor issues were found, but the system is compliant with best practices. Moderate Some issues that may aﬀect system safety were found. Weak Many issues that aﬀect system safety were found. Missing A required component is missing, signiﬁcantly aﬀecting system safety. Not Applicable The category is not applicable to this review. Not Considered The category was not considered in this review. Further Investigation Required Further investigation is required to reach a meaningful conclusion. C. Fix Review Results When undertaking a ﬁx review, reviews the ﬁxes implemented for issues identiﬁed in the original report. This work involves a review of speciﬁc areas of the source code and system conﬁguration, not comprehensive analysis of the system. On October 4, 2023, reviewed the ﬁxes and mitigations implemented by the wasmCloud team for the issues identiﬁed in this report. We reviewed each ﬁx to determine its eﬀectiveness in resolving the associated issue. In summary, wasmCloud has resolved all identiﬁed issues. For additional information, please see the Detailed Fix Review Results below. ID Title 1 Out of bounds crash in extract_claims Status Resolved 2 Stack overﬂow while enumerating containers in blobstore-fs Resolved 3 Denial of Service in blobstore-s3 using malicious actor Resolved Detailed Fix Review Results TOB-WACL-1: Out of bounds crash in extract_claims Resolved in commit 664d9b9 . The missing range validation was added. TOB-WACL-2: Stack overﬂow while enumerating containers in blobstore-fs Resolved in PR capability-providers/271 . The ﬁx limits the recursion to a maximum of 1,000 calls. TOB-WACL-3: Denial of Service in blobstore-s3 using malicious actor Resolved in PR capability-providers/271 . The missing response emptiness check was added. TOB-WACL-4: Unexpected panic in validate_token Resolved in PR wascap/52 . The missing segments quantity validation was added. TOB-WACL-5: Incorrect error message when starting actor from ﬁle Resolved in PR wasmcloud-otp/648 . The mistake in message log string interpolation was ﬁxed. D. Fix Review Status Categories The following table describes the statuses used to indicate whether an issue has been suﬃciently addressed. Fix Status Status Description Undetermined The status of the issue was not determined during this engagement. Unresolved The issue persists and has not been resolved. Partially Resolved The issue persists but has been partially resolved. Resolved The issue has been suﬃciently resolved. 
