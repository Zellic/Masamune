1. receiveFlashLoan does not account for fees Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-SANDCLOCK-1 Target: src/steth/scWETHv2.sol , src/steth/scUSDCv2.sol Description The receiveFlashLoan functions of the scWETHv2 and scUSDCv2 vaults ignore the Balancer ﬂash loan fees and repay exactly the amount that was loaned. This is not currently an issue because the Balancer vault does not charge any fees for ﬂash loans. However, if Balancer implements fees for ﬂash loans in the future, the Sandclock vaults would be prevented from withdrawing investments back into the vault. function flashLoan ( IFlashLoanRecipient recipient, IERC20[] memory tokens, uint256 [] memory amounts, bytes memory userData ) external override nonReentrant whenNotPaused { uint256 [] memory feeAmounts = new uint256 [](tokens.length); uint256 [] memory preLoanBalances = new uint256 [](tokens.length); for ( uint256 i = 0 ; i < tokens.length; ++i) { IERC20 token = tokens[i]; uint256 amount = amounts[i]; preLoanBalances[i] = token.balanceOf( address ( this )); feeAmounts[i] = _calculateFlashLoanFeeAmount(amount); token.safeTransfer( address (recipient), amount); } recipient.receiveFlashLoan(tokens, amounts, feeAmounts , userData); for ( uint256 i = 0 ; i < tokens.length; ++i) { IERC20 token = tokens[i]; uint256 preLoanBalance = preLoanBalances[i]; uint256 postLoanBalance = token.balanceOf( address ( this )); uint256 receivedFeeAmount = postLoanBalance - preLoanBalance; _require(receivedFeeAmount >= feeAmounts[i]); _payFeeAmount(token, receivedFeeAmount); } } Figure 1.1: Abbreviated code showing the receivedFeeAmount check in the Balancer flashLoan method in 0xBA12222222228d8Ba445958a75a0704d566BF2C8#code#F5#L78 In the Balancer flashLoan function , shown in ﬁgure 1.1, the contract calls the recipient’s receiveFlashLoan function with four arguments: the addresses of the tokens loaned, the amounts for each token, the fees to be paid for the loan for each token, and the calldata provided by the caller. The Sandclock vaults ignore the fee amount and repay only the principal, which would lead to reverts if the fees are ever changed to nonzero values. Although this problem is present in multiple vaults, the receiveFlashLoan implementation of the scWETHv2 contract is shown in ﬁgure 1.2 as an illustrative example: function receiveFlashLoan ( address [] memory , uint256 [] memory amounts, uint256 [] memory , bytes memory userData) external { _isFlashLoanInitiated(); // the amount flashloaned uint256 flashLoanAmount = amounts[ 0 ]; // decode user data bytes [] memory callData = abi.decode(userData, ( bytes [])); _multiCall(callData); // payback flashloan asset.safeTransfer( address (balancerVault), flashLoanAmount ); _enforceFloat(); } Figure 1.2: The feeAmounts parameter is ignored by the receiveFlashLoan method. ( sandclock-contracts/src/steth/scWETHv2.sol#L232–L249 ) Exploit Scenario After Sandclock’s scUSDv2 and scWETHv2 vaults are deployed and users start depositing assets, the Balancer governance system decides to start charging fees for ﬂash loans. Users of the Sandclock protocol now discover that, apart from the ﬂoat margin, most of their funds are locked because it is impossible to use the ﬂash loan functions to withdraw vault assets from the underlying investment pools. Recommendations Short term, use the feeAmounts parameter in the calculation for repayment to account for future Balancer ﬂash loan fees. This will prevent unexpected reverts in the ﬂash loan handler function. Long term, document and justify all ignored arguments provided by external callers. This will facilitate a review of the system’s third-party interactions and help prevent similar issues from being introduced in the future. 
2. Reward token distribution rate can diverge from reward token balance Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-SANDCLOCK-2 Target: src/staking/RewardTracker.sol Description The privileged distributor role is responsible for transferring reward tokens to the RewardTracker contract and then passing the number of tokens sent as the _reward parameter to the notifyRewardAmount method. However, the _reward parameter provided to this method can be larger than the number of reward tokens transferred. Given the accounting for leftover rewards, such a situation would be diﬃcult to recover from. /// @notice Lets a reward distributor start a new reward period. The reward tokens must have already /// been transferred to this contract before calling this function. If it is called /// when a reward period is still active, a new reward period will begin from the time /// of calling this function, using the leftover rewards from the old reward period plus /// the newly sent rewards as the reward. /// @dev If the reward amount will cause an overflow when computing rewardPerToken, then /// this function will revert. /// @param _reward The amount of reward tokens to use in the new reward period. function notifyRewardAmount ( uint256 _reward ) external onlyDistributor { _notifyRewardAmount(_reward); } Figure 2.1: The comment on the notifyRewardAmount method hints at an unenforced assumption that the number of reward tokens transferred must be equal to the _reward parameter provided. ( sandclock-contracts/src/staking/RewardTracker.sol#L185–L195 ) If a _reward value smaller than the actual number of transferred tokens is provided, the situation can be ﬁxed by calling notifyRewardAmount again with a _reward parameter that accounts for the diﬀerence between the RewardTracker contract’s actual token balance and the rewards already scheduled for distribution. This solution is possible because the _notifyRewardAmount helper function accounts for leftover rewards if it is called during an ongoing reward period. function _notifyRewardAmount ( uint256 _reward ) internal { ... uint64 rewardRate_ = rewardRate; uint64 periodFinish_ = periodFinish; uint64 duration_ = duration; ... if ( block.timestamp >= periodFinish_) { newRewardRate = _reward / duration_; } else { uint256 remaining = periodFinish_ - block.timestamp ; uint256 leftover = remaining * rewardRate_; newRewardRate = (_reward + leftover ) / duration_; } Figure 2.2: The accounting for leftover rewards in the _notifyRewardAmount helper method ( sandclock-contracts/src/staking/RewardTracker.sol#L226–L262 ) This accounting for leftover rewards, however, makes the situation diﬃcult to recover from if a _reward parameter that is too large is provided to the notifyRewardAmount method. As shown by the arithmetic in ﬁgure 2.2, if the reward period has not ﬁnished, the code for creating the newRewardRate value can only add to the reward distribution, not subtract from it. The only way to bring a too-large reward distribution back in line with the RewardTracker contract’s reward token balance is to transfer additional reward tokens to the contract. Exploit Scenario The RewardTracker distributor transfers 10 reward tokens to the RewardTracker contract and then mistakenly calls the notifyRewardAmount method with a _reward parameter of 100. Some users call the claimRewards method early and receive inﬂated rewards until the contract’s balance is depleted, leaving later users unable to claim any rewards. To recover, the distributor either needs to provide another 90 reward tokens to the RewardTracker contract or accept the reputational loss of allowing this misconﬁgured reward period to ﬁnish before resetting the reward payouts correctly during the next period. Recommendations Short term, modify the _notifyRewardAmount helper function to reset the rewardRate so that it is in line with the current rewardToken balance and the time remaining in the reward period. This change could also allow the fetchRewards method to maintain its current behavior but with only a single rewardToken.balanceOf external call. Long term, review the internal accounting state variables and document the ways in which they are inﬂuenced by the actual ﬂow of funds. Pay attention to any internal accounting values that can be inﬂuenced by external sources, including privileged accounts, and reexamine the system’s assumptions surrounding the ﬂow of funds. 
3. Miscalculation in beforeWithdraw can leave the vault with less than minimum ﬂoat Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-SANDCLOCK-3 Target: src/steth/scWETHv2.sol Description When a user wants to redeem or withdraw, the beforeWithdraw function is called with the number of assets to be withdrawn as the assets parameter. This function makes sure that if the value of the float parameter (that is, the available assets in the vault) is not enough to pay for the withdrawal, the strategy gets some assets back from the pools to be able to pay. function beforeWithdraw ( uint256 assets , uint256 ) internal override { uint256 float = asset.balanceOf( address ( this )); if (assets <= float) return ; uint256 minimumFloat = minimumFloatAmount; uint256 floatRequired = float < minimumFloat ? minimumFloat - float : 0 ; uint256 missing = assets + floatRequired - float; _withdrawToVault(missing); } Figure 3.1: The aﬀected code in sandclock-contracts/src/steth/scWETHv2.sol#L386–L396 When the float value is enough, the function returns and the withdrawal is paid with the existing ﬂoat. If the float value is not enough, the missing amount is recovered from the pools via the adapters. The issue lies in the calculation of the missing parameter: it does not guarantee that the float value remaining after the withdrawal is at least the value of the minimumFloatAmount parameter. The consequence is that the calculation always leaves a ﬂoat equal to floatRequired in the vault. If this value is small enough, it can cause users to waste gas when withdrawing small amounts because they will need to pay for the gas-intensive _withdrawToVault action. This eclipses the usefulness of having the ﬂoat in the vault. The correct calculation should be uint256 missing = assets + minimumFloat - float; . Using this correct calculation would make the calculation of the floatRequired parameter unnecessary as it would no longer be required or used in the rest of the code. Exploit Scenario The value for minimumFloatAmount is set to 1 ether in the scWETHv2 contract. For this scenario, suppose that the current ﬂoat is exactly equal to minimumFloatAmount . Alice wants to withdraw 0.15 WETH from her invested amount. Because this amount is less than the current ﬂoat, her withdrawal is paid from the vault assets, leaving the ﬂoat equal to 0.85 WETH after the operation. Then, Bill wants to withdraw 0.9 WETH, but the vault has no available assets to pay for it. In this case, when beforeWithdraw is called, Bill has to pay gas for the call to _withdrawToVault , which is an expensive action because it includes gas-intensive operations such as loops and a ﬂash loan. After Bill’s withdrawal, the ﬂoat in the vault is 0.15 WETH. This is a relatively small amount compared with minimumFloatValue , and it will likely make the next withdrawing/redeeming user also have to pay for the call to _withdrawToVault . Recommendations Short term, replace the calculation of the missing amount to be withdrawn on line 393 of the scWETHv2 contract with assets + minimumFloat - float . This calculation will ensure that the minimum ﬂoat restriction is enforced after withdrawals. It will take the required ﬂoat into consideration, so the separate calculation of floatRequired on line 392 of scWETHv2 would no longer be required. Long term, add unit or fuzz tests to make sure that the vault has an amount of assets equal to or greater than the minimum expected amount at all times. 
4. Last user in scWETHv2 vault will not be able to withdraw their funds Severity: Low Diﬃculty: Medium Type: Data Validation Finding ID: TOB-SANDCLOCK-4 Target: src/steth/scWETHv2.sol Description When a user wants to withdraw, the withdrawal amount is checked against the current vault ﬂoat (the uninvested assets readily available in the vault). If the withdrawal amount is less than the ﬂoat, the amount is paid from the available balance; otherwise, the protocol has to disinvest from the strategies to get the required assets to pay for the withdrawal. The issue with this approach is that in order to maintain a ﬂoat equal to the minimumFloatValue parameter in the vault, the value to be disinvested from the strategies is calculated in the beforeWithdraw function, and its correct value is equal to the sum of the amount to be withdrawn and the minimum ﬂoat minus the current ﬂoat. If there is only one user remaining in the vault and they want to withdraw, this enforcement will not allow them to do so, because there will not be enough invested in the strategies to leave a minimum ﬂoat in the vault after the withdrawal. They would only be able to withdraw their assets minus the minimum ﬂoat at most. The code for the _withdrawToVault function is shown in ﬁgure 4.1. The line highlighted in the ﬁgure would cause the revert in this situation, as there would not be enough invested to supply the requested amount. function _withdrawToVault ( uint256 _amount ) internal { uint256 n = protocolAdapters.length(); uint256 flashLoanAmount ; uint256 totalInvested_ = _totalCollateralInWeth() - totalDebt(); bytes [] memory callData = new bytes [](n + 1 ); uint256 flashLoanAmount_ ; uint256 amount_ ; uint256 adapterId ; address adapter ; for ( uint256 i ; i < n; i++) { (adapterId, adapter) = protocolAdapters.at(i); (flashLoanAmount_, amount_) = _calcFlashLoanAmountWithdrawing(adapter, _amount, totalInvested_); flashLoanAmount += flashLoanAmount_; callData[i] = abi.encodeWithSelector( this .repayAndWithdraw.selector, adapterId, flashLoanAmount_, priceConverter.ethToWstEth(flashLoanAmount_ + amount_) ); } // needed otherwise counted as loss during harvest totalInvested -= _amount; callData[n] = abi.encodeWithSelector(scWETHv2.swapWstEthToWeth.selector, type( uint256 ).max, slippageTolerance); uint256 float = asset.balanceOf( address ( this )); _flashLoan(flashLoanAmount, callData); emit WithdrawnToVault(asset.balanceOf( address ( this )) - float); } Figure 4.1: The aﬀected code in sandclock-contracts/src/steth/scWETHv2.sol#L342–L376 Additionally, when this revert occurs, an integer overﬂow is given as the reason, which obscures the real reason and can make the user’s experience more confusing. Exploit Scenario Bob is the only remaining user in a scWETHv2 vault, and he has 2 ether invested. He wants to withdraw his assets, but all of his calls to the withdrawal function keep reverting due to an integer overﬂow. He keeps trying, wasting gas in the process, until he discovers that the maximum amount he is allowed to withdraw is around 1 ether. The rest of his funds are locked in the vault until the keeper makes a manual call to withdrawToVault or until the admin lowers the minimum ﬂoat value. Recommendations Short term, ﬁx the calculation of the amount to be withdrawn and make sure that it never exceeds the total invested amount. Long term, add end-to-end unit or fuzz tests that are representative of the way multiple users can interact with the protocol. Test for edge cases involving various numbers of users, investment amounts, and critical interactions, and make sure that the protocol’s invariants hold and that users do not lose access to funds in the event of such edge cases. 
5. Lido stake rate limit could lead to unexpected reverts Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-SANDCLOCK-5 Target: src/steth/Swapper.sol Description To mitigate the eﬀects of a surge in demand for stETH on the deposit queue, Lido has implemented a rate limit for stake submissions. This rate limit is ignored by the lidoSwapWethToWstEth method of the Swapper library, potentially leading to unexpected reversions. The Lido stETH integration guide states the following: To avoid [reverts due to the rate limit being hit], you should check if getCurrentStakeLimit() >= amountToStake , and if it's not you can go with an alternative route. function lidoSwapWethToWstEth ( uint256 _wethAmount ) external { // weth to eth weth.withdraw(_wethAmount); // stake to lido / eth => stETH stEth.submit{value: _wethAmount}( address ( 0x00 )); // stETH to wstEth uint256 stEthBalance = stEth.balanceOf( address ( this )); ERC20( address (stEth)).safeApprove( address (wstETH), stEthBalance); wstETH.wrap(stEthBalance); } Figure 5.1: The submit method is subject to a rate limit that is not taken into account. ( sandclock-contracts/src/steth/Swapper.sol#L130–L142 ) Exploit Scenario A surge in demand for Ethereum validators leads many people using Lido to stake ETH, causing the Lido rate limit to be hit, and the submit method of the stEth contract begins to revert. As a result, the Sandclock keeper is unable to deposit despite the presence of alternate routes to obtain stETH, such as through Curve or Balancer. Recommendations Short term, have the lidoSwapWethToWstEth method of the Swapper library check whether the amount being deposited is less than the value returned by the getCurrentStakeLimit method of the stEth contract. If it is not, have the code use ZeroEx to swap or revert with a message that clearly communicates the reason for the failure. Long term, review the documentation for all third-party interactions and note any situations in which the integration could revert unexpectedly. If such reversions are acceptable, clearly document how they could occur and include a justiﬁcation for this acceptance in the inline comments. 
1. receiveFlashLoan does not account for fees Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-SANDCLOCK-1 Target: src/steth/scWETHv2.sol , src/steth/scUSDCv2.sol Description The receiveFlashLoan functions of the scWETHv2 and scUSDCv2 vaults ignore the Balancer ﬂash loan fees and repay exactly the amount that was loaned. This is not currently an issue because the Balancer vault does not charge any fees for ﬂash loans. However, if Balancer implements fees for ﬂash loans in the future, the Sandclock vaults would be prevented from withdrawing investments back into the vault. function flashLoan ( IFlashLoanRecipient recipient, IERC20[] memory tokens, uint256 [] memory amounts, bytes memory userData ) external override nonReentrant whenNotPaused { uint256 [] memory feeAmounts = new uint256 [](tokens.length); uint256 [] memory preLoanBalances = new uint256 [](tokens.length); for ( uint256 i = 0 ; i < tokens.length; ++i) { IERC20 token = tokens[i]; uint256 amount = amounts[i]; preLoanBalances[i] = token.balanceOf( address ( this )); feeAmounts[i] = _calculateFlashLoanFeeAmount(amount); token.safeTransfer( address (recipient), amount); } recipient.receiveFlashLoan(tokens, amounts, feeAmounts , userData); for ( uint256 i = 0 ; i < tokens.length; ++i) { IERC20 token = tokens[i]; uint256 preLoanBalance = preLoanBalances[i]; uint256 postLoanBalance = token.balanceOf( address ( this )); uint256 receivedFeeAmount = postLoanBalance - preLoanBalance; _require(receivedFeeAmount >= feeAmounts[i]); _payFeeAmount(token, receivedFeeAmount); } } Figure 1.1: Abbreviated code showing the receivedFeeAmount check in the Balancer flashLoan method in 0xBA12222222228d8Ba445958a75a0704d566BF2C8#code#F5#L78 In the Balancer flashLoan function , shown in ﬁgure 1.1, the contract calls the recipient’s receiveFlashLoan function with four arguments: the addresses of the tokens loaned, the amounts for each token, the fees to be paid for the loan for each token, and the calldata provided by the caller. The Sandclock vaults ignore the fee amount and repay only the principal, which would lead to reverts if the fees are ever changed to nonzero values. Although this problem is present in multiple vaults, the receiveFlashLoan implementation of the scWETHv2 contract is shown in ﬁgure 1.2 as an illustrative example: function receiveFlashLoan ( address [] memory , uint256 [] memory amounts, uint256 [] memory , bytes memory userData) external { _isFlashLoanInitiated(); // the amount flashloaned uint256 flashLoanAmount = amounts[ 0 ]; // decode user data bytes [] memory callData = abi.decode(userData, ( bytes [])); _multiCall(callData); // payback flashloan asset.safeTransfer( address (balancerVault), flashLoanAmount ); _enforceFloat(); } Figure 1.2: The feeAmounts parameter is ignored by the receiveFlashLoan method. ( sandclock-contracts/src/steth/scWETHv2.sol#L232–L249 ) Exploit Scenario After Sandclock’s scUSDv2 and scWETHv2 vaults are deployed and users start depositing assets, the Balancer governance system decides to start charging fees for ﬂash loans. Users of the Sandclock protocol now discover that, apart from the ﬂoat margin, most of their funds are locked because it is impossible to use the ﬂash loan functions to withdraw vault assets from the underlying investment pools. Recommendations Short term, use the feeAmounts parameter in the calculation for repayment to account for future Balancer ﬂash loan fees. This will prevent unexpected reverts in the ﬂash loan handler function. Long term, document and justify all ignored arguments provided by external callers. This will facilitate a review of the system’s third-party interactions and help prevent similar issues from being introduced in the future. 
2. Reward token distribution rate can diverge from reward token balance Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-SANDCLOCK-2 Target: src/staking/RewardTracker.sol Description The privileged distributor role is responsible for transferring reward tokens to the RewardTracker contract and then passing the number of tokens sent as the _reward parameter to the notifyRewardAmount method. However, the _reward parameter provided to this method can be larger than the number of reward tokens transferred. Given the accounting for leftover rewards, such a situation would be diﬃcult to recover from. /// @notice Lets a reward distributor start a new reward period. The reward tokens must have already /// been transferred to this contract before calling this function. If it is called /// when a reward period is still active, a new reward period will begin from the time /// of calling this function, using the leftover rewards from the old reward period plus /// the newly sent rewards as the reward. /// @dev If the reward amount will cause an overflow when computing rewardPerToken, then /// this function will revert. /// @param _reward The amount of reward tokens to use in the new reward period. function notifyRewardAmount ( uint256 _reward ) external onlyDistributor { _notifyRewardAmount(_reward); } Figure 2.1: The comment on the notifyRewardAmount method hints at an unenforced assumption that the number of reward tokens transferred must be equal to the _reward parameter provided. ( sandclock-contracts/src/staking/RewardTracker.sol#L185–L195 ) If a _reward value smaller than the actual number of transferred tokens is provided, the situation can be ﬁxed by calling notifyRewardAmount again with a _reward parameter that accounts for the diﬀerence between the RewardTracker contract’s actual token balance and the rewards already scheduled for distribution. This solution is possible because the _notifyRewardAmount helper function accounts for leftover rewards if it is called during an ongoing reward period. function _notifyRewardAmount ( uint256 _reward ) internal { ... uint64 rewardRate_ = rewardRate; uint64 periodFinish_ = periodFinish; uint64 duration_ = duration; ... if ( block.timestamp >= periodFinish_) { newRewardRate = _reward / duration_; } else { uint256 remaining = periodFinish_ - block.timestamp ; uint256 leftover = remaining * rewardRate_; newRewardRate = (_reward + leftover ) / duration_; } Figure 2.2: The accounting for leftover rewards in the _notifyRewardAmount helper method ( sandclock-contracts/src/staking/RewardTracker.sol#L226–L262 ) This accounting for leftover rewards, however, makes the situation diﬃcult to recover from if a _reward parameter that is too large is provided to the notifyRewardAmount method. As shown by the arithmetic in ﬁgure 2.2, if the reward period has not ﬁnished, the code for creating the newRewardRate value can only add to the reward distribution, not subtract from it. The only way to bring a too-large reward distribution back in line with the RewardTracker contract’s reward token balance is to transfer additional reward tokens to the contract. Exploit Scenario The RewardTracker distributor transfers 10 reward tokens to the RewardTracker contract and then mistakenly calls the notifyRewardAmount method with a _reward parameter of 100. Some users call the claimRewards method early and receive inﬂated rewards until the contract’s balance is depleted, leaving later users unable to claim any rewards. To recover, the distributor either needs to provide another 90 reward tokens to the RewardTracker contract or accept the reputational loss of allowing this misconﬁgured reward period to ﬁnish before resetting the reward payouts correctly during the next period. Recommendations Short term, modify the _notifyRewardAmount helper function to reset the rewardRate so that it is in line with the current rewardToken balance and the time remaining in the reward period. This change could also allow the fetchRewards method to maintain its current behavior but with only a single rewardToken.balanceOf external call. Long term, review the internal accounting state variables and document the ways in which they are inﬂuenced by the actual ﬂow of funds. Pay attention to any internal accounting values that can be inﬂuenced by external sources, including privileged accounts, and reexamine the system’s assumptions surrounding the ﬂow of funds. 
3. Miscalculation in beforeWithdraw can leave the vault with less than minimum ﬂoat Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-SANDCLOCK-3 Target: src/steth/scWETHv2.sol Description When a user wants to redeem or withdraw, the beforeWithdraw function is called with the number of assets to be withdrawn as the assets parameter. This function makes sure that if the value of the float parameter (that is, the available assets in the vault) is not enough to pay for the withdrawal, the strategy gets some assets back from the pools to be able to pay. function beforeWithdraw ( uint256 assets , uint256 ) internal override { uint256 float = asset.balanceOf( address ( this )); if (assets <= float) return ; uint256 minimumFloat = minimumFloatAmount; uint256 floatRequired = float < minimumFloat ? minimumFloat - float : 0 ; uint256 missing = assets + floatRequired - float; _withdrawToVault(missing); } Figure 3.1: The aﬀected code in sandclock-contracts/src/steth/scWETHv2.sol#L386–L396 When the float value is enough, the function returns and the withdrawal is paid with the existing ﬂoat. If the float value is not enough, the missing amount is recovered from the pools via the adapters. The issue lies in the calculation of the missing parameter: it does not guarantee that the float value remaining after the withdrawal is at least the value of the minimumFloatAmount parameter. The consequence is that the calculation always leaves a ﬂoat equal to floatRequired in the vault. If this value is small enough, it can cause users to waste gas when withdrawing small amounts because they will need to pay for the gas-intensive _withdrawToVault action. This eclipses the usefulness of having the ﬂoat in the vault. The correct calculation should be uint256 missing = assets + minimumFloat - float; . Using this correct calculation would make the calculation of the floatRequired parameter unnecessary as it would no longer be required or used in the rest of the code. Exploit Scenario The value for minimumFloatAmount is set to 1 ether in the scWETHv2 contract. For this scenario, suppose that the current ﬂoat is exactly equal to minimumFloatAmount . Alice wants to withdraw 0.15 WETH from her invested amount. Because this amount is less than the current ﬂoat, her withdrawal is paid from the vault assets, leaving the ﬂoat equal to 0.85 WETH after the operation. Then, Bill wants to withdraw 0.9 WETH, but the vault has no available assets to pay for it. In this case, when beforeWithdraw is called, Bill has to pay gas for the call to _withdrawToVault , which is an expensive action because it includes gas-intensive operations such as loops and a ﬂash loan. After Bill’s withdrawal, the ﬂoat in the vault is 0.15 WETH. This is a relatively small amount compared with minimumFloatValue , and it will likely make the next withdrawing/redeeming user also have to pay for the call to _withdrawToVault . Recommendations Short term, replace the calculation of the missing amount to be withdrawn on line 393 of the scWETHv2 contract with assets + minimumFloat - float . This calculation will ensure that the minimum ﬂoat restriction is enforced after withdrawals. It will take the required ﬂoat into consideration, so the separate calculation of floatRequired on line 392 of scWETHv2 would no longer be required. Long term, add unit or fuzz tests to make sure that the vault has an amount of assets equal to or greater than the minimum expected amount at all times. 
4. Last user in scWETHv2 vault will not be able to withdraw their funds Severity: Low Diﬃculty: Medium Type: Data Validation Finding ID: TOB-SANDCLOCK-4 Target: src/steth/scWETHv2.sol Description When a user wants to withdraw, the withdrawal amount is checked against the current vault ﬂoat (the uninvested assets readily available in the vault). If the withdrawal amount is less than the ﬂoat, the amount is paid from the available balance; otherwise, the protocol has to disinvest from the strategies to get the required assets to pay for the withdrawal. The issue with this approach is that in order to maintain a ﬂoat equal to the minimumFloatValue parameter in the vault, the value to be disinvested from the strategies is calculated in the beforeWithdraw function, and its correct value is equal to the sum of the amount to be withdrawn and the minimum ﬂoat minus the current ﬂoat. If there is only one user remaining in the vault and they want to withdraw, this enforcement will not allow them to do so, because there will not be enough invested in the strategies to leave a minimum ﬂoat in the vault after the withdrawal. They would only be able to withdraw their assets minus the minimum ﬂoat at most. The code for the _withdrawToVault function is shown in ﬁgure 4.1. The line highlighted in the ﬁgure would cause the revert in this situation, as there would not be enough invested to supply the requested amount. function _withdrawToVault ( uint256 _amount ) internal { uint256 n = protocolAdapters.length(); uint256 flashLoanAmount ; uint256 totalInvested_ = _totalCollateralInWeth() - totalDebt(); bytes [] memory callData = new bytes [](n + 1 ); uint256 flashLoanAmount_ ; uint256 amount_ ; uint256 adapterId ; address adapter ; for ( uint256 i ; i < n; i++) { (adapterId, adapter) = protocolAdapters.at(i); (flashLoanAmount_, amount_) = _calcFlashLoanAmountWithdrawing(adapter, _amount, totalInvested_); flashLoanAmount += flashLoanAmount_; callData[i] = abi.encodeWithSelector( this .repayAndWithdraw.selector, adapterId, flashLoanAmount_, priceConverter.ethToWstEth(flashLoanAmount_ + amount_) ); } // needed otherwise counted as loss during harvest totalInvested -= _amount; callData[n] = abi.encodeWithSelector(scWETHv2.swapWstEthToWeth.selector, type( uint256 ).max, slippageTolerance); uint256 float = asset.balanceOf( address ( this )); _flashLoan(flashLoanAmount, callData); emit WithdrawnToVault(asset.balanceOf( address ( this )) - float); } Figure 4.1: The aﬀected code in sandclock-contracts/src/steth/scWETHv2.sol#L342–L376 Additionally, when this revert occurs, an integer overﬂow is given as the reason, which obscures the real reason and can make the user’s experience more confusing. Exploit Scenario Bob is the only remaining user in a scWETHv2 vault, and he has 2 ether invested. He wants to withdraw his assets, but all of his calls to the withdrawal function keep reverting due to an integer overﬂow. He keeps trying, wasting gas in the process, until he discovers that the maximum amount he is allowed to withdraw is around 1 ether. The rest of his funds are locked in the vault until the keeper makes a manual call to withdrawToVault or until the admin lowers the minimum ﬂoat value. Recommendations Short term, ﬁx the calculation of the amount to be withdrawn and make sure that it never exceeds the total invested amount. Long term, add end-to-end unit or fuzz tests that are representative of the way multiple users can interact with the protocol. Test for edge cases involving various numbers of users, investment amounts, and critical interactions, and make sure that the protocol’s invariants hold and that users do not lose access to funds in the event of such edge cases. 
5. Lido stake rate limit could lead to unexpected reverts Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-SANDCLOCK-5 Target: src/steth/Swapper.sol Description To mitigate the eﬀects of a surge in demand for stETH on the deposit queue, Lido has implemented a rate limit for stake submissions. This rate limit is ignored by the lidoSwapWethToWstEth method of the Swapper library, potentially leading to unexpected reversions. The Lido stETH integration guide states the following: To avoid [reverts due to the rate limit being hit], you should check if getCurrentStakeLimit() >= amountToStake , and if it's not you can go with an alternative route. function lidoSwapWethToWstEth ( uint256 _wethAmount ) external { // weth to eth weth.withdraw(_wethAmount); // stake to lido / eth => stETH stEth.submit{value: _wethAmount}( address ( 0x00 )); // stETH to wstEth uint256 stEthBalance = stEth.balanceOf( address ( this )); ERC20( address (stEth)).safeApprove( address (wstETH), stEthBalance); wstETH.wrap(stEthBalance); } Figure 5.1: The submit method is subject to a rate limit that is not taken into account. ( sandclock-contracts/src/steth/Swapper.sol#L130–L142 ) Exploit Scenario A surge in demand for Ethereum validators leads many people using Lido to stake ETH, causing the Lido rate limit to be hit, and the submit method of the stEth contract begins to revert. As a result, the Sandclock keeper is unable to deposit despite the presence of alternate routes to obtain stETH, such as through Curve or Balancer. Recommendations Short term, have the lidoSwapWethToWstEth method of the Swapper library check whether the amount being deposited is less than the value returned by the getCurrentStakeLimit method of the stEth contract. If it is not, have the code use ZeroEx to swap or revert with a message that clearly communicates the reason for the failure. Long term, review the documentation for all third-party interactions and note any situations in which the integration could revert unexpectedly. If such reversions are acceptable, clearly document how they could occur and include a justiﬁcation for this acceptance in the inline comments. 
6. Chainlink oracles could return stale price data Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-SANDCLOCK-6 Target: src/steth/PriceConverter.sol , src/liquity/scLiquity.sol Description The latestRoundData() function from Chainlink oracles returns ﬁve values: roundId , answer , startedAt , updatedAt , and answeredInRound . The PriceConverter contract reads only the answer value and discards the rest. This can cause outdated prices to be used for token conversions, such as the ETH-to-USDC conversion shown in ﬁgure 6.1. function ethToUsdc ( uint256 _ethAmount ) public view returns ( uint256 ) { ( , int256 usdcPriceInEth ,,, ) = usdcToEthPriceFeed.latestRoundData(); return _ethAmount.divWadDown( uint256 (usdcPriceInEth) * C.WETH_USDC_DECIMALS_DIFF); } Figure 6.1: All returned data other than the answer value is ignored during the call to a Chainlink feed’s latestRoundData method. ( sandclock-contracts/src/steth/PriceConverter.sol#L67–L71 ) According to the Chainlink documentation , if the latestRoundData() function is used, the updatedAt value should be checked to ensure that the returned value is recent enough for the application. Similarly, the LUSD/ETH price feed used by the scLiquity vault is an intermediate contract that calls the deprecated latestAnswer method on upstream Chainlink oracles. contract LSUDUsdToLUSDEth is IPriceFeed { IPriceFeed public constant LUSD_USD = IPriceFeed( 0x3D7aE7E594f2f2091Ad8798313450130d0Aba3a0 ); IPriceFeed public constant ETH_USD = IPriceFeed( 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 ); function latestAnswer () external view override returns ( int256 ) { return (LUSD_USD.latestAnswer() * 1 ether) / ETH_USD.latestAnswer(); } } Figure 6.2: The custom latestAnswer method in 0x60c0b047133f696334a2b7f68af0b49d2F3D4F72#code#L19 The Chainlink API reference ﬂags the latestAnswer method as “(Deprecated - Do not use this function.).” Note that the upstream IPriceFeed contracts called by the intermediate LSUDUsdToLUSDEth contract are upgradeable proxies. It is possible that the implementations will be updated to remove support for the deprecated latestAnswer method, breaking the scLiquity vault’s lusd2eth price feed. Because the oracle price feeds are used for calculating the slippage tolerance, a diﬀerence may exist between the oracle price and the DEX pool spot price, either due to price update delays or normal price ﬂuctuations or because the feed has become stale. This could lead to two possible adverse scenarios: ● ● If the oracle price is signiﬁcantly higher than the pool price, the slippage tolerance could be too loose, introducing the possibility of an MEV sandwich attack that can proﬁt on the excess. If the oracle price is signiﬁcantly lower than the pool price, the slippage tolerance could be too tight, and the transaction will always revert. Users will perceive this as a denial of service because they would not be able to interact with the protocol until the price diﬀerence is settled. Exploit Scenario Bob has assets invested in a scWETHv2 vault and wants to withdraw part of his assets. He interacts with the contracts, and every withdrawal transaction he submits reverts due to a large diﬀerence between the oracle and pool prices, leading to failed slippage checks. This results in a waste of gas and leaves Bob confused, as there is no clear indication of where the problem lies. Recommendations Short term, make sure that the oracles report up-to-date data, and replace the external LUSD/ETH oracle with one that supports veriﬁcation of the latest update timestamp. In the case of stale oracle data, pause price-dependent Sandclock functionality until the oracle comes back online or the admin replaces it with a live oracle. Long term, review the documentation for Chainlink and other oracle integrations to ensure that all of the security requirements are met to avoid potential issues, and add tests that take these possible situations into account. A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diﬃculty levels used in this document. Vulnerability Categories Category Description Access Controls Insuﬃcient authorization or assessment of rights Auditing and Logging Insuﬃcient auditing of actions or logging of problems Authentication Improper identiﬁcation of users Conﬁguration Misconﬁgured servers, devices, or software components Cryptography A breach of system conﬁdentiality or integrity Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service A system failure with an availability impact Error Reporting Insecure or insuﬃcient reporting of error conditions Patching Use of an outdated software package or library Session Management Improper identiﬁcation of authenticated users Testing Timing Insuﬃcient test methodology or test coverage Race conditions or other order-of-operations ﬂaws Undeﬁned Behavior Undeﬁned behavior triggered within the system Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices. Undetermined The extent of the risk was not determined during this engagement. Low The risk is small or is not one the client has indicated is important. Medium High User information is at risk; exploitation could pose reputational, legal, or moderate ﬁnancial risks. The ﬂaw could aﬀect numerous users and have serious reputational, legal, or ﬁnancial implications. Diﬃculty Levels Diﬃculty Description Undetermined The diﬃculty of exploitation was not determined during this engagement. Low Medium High The ﬂaw is well known; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of the system. An attacker must have privileged access to the system, may need to know complex technical details, or must discover other weaknesses to exploit this issue. B. Code Maturity Categories The following tables describe the code maturity categories and rating criteria used in this document. Code Maturity Categories Category Description Arithmetic The proper use of mathematical operations and semantics Auditing The use of event auditing and logging to support monitoring Authentication / Access Controls The use of robust access controls to handle identiﬁcation and authorization and to ensure safe interactions with the system Complexity Management The presence of clear structures designed to manage system complexity, including the separation of system logic into clearly deﬁned functions Cryptography and Key Management The safe use of cryptographic primitives and functions, along with the presence of robust mechanisms for key generation and distribution Decentralization The presence of a decentralized governance structure for mitigating insider threats and managing risks posed by contract upgrades Documentation The presence of comprehensive and readable codebase documentation Front-Running Resistance Low-Level Manipulation The system’s resistance to front-running attacks The justiﬁed use of inline assembly and low-level calls Testing and Veriﬁcation The presence of robust testing procedures (e.g., unit tests, integration tests, and veriﬁcation methods) and suﬃcient test coverage Rating Criteria Rating Strong Description No issues were found, and the system exceeds industry standards. Satisfactory Minor issues were found, but the system is compliant with best practices. Moderate Some issues that may aﬀect system safety were found. Weak Many issues that aﬀect system safety were found. Missing A required component is missing, signiﬁcantly aﬀecting system safety. Not Applicable The category is not applicable to this review. Not Considered The category was not considered in this review. Further Investigation Required Further investigation is required to reach a meaningful conclusion. C. Code Quality Recommendations The following recommendations are not associated with speciﬁc vulnerabilities. However, implementing them may enhance code readability and may prevent the introduction of vulnerabilities in the future. ● ● ● ● Disambiguate the system’s contract names. The EulerAdapter and AaveV3Adapter contract names refer to more than one distinct contract. Some frameworks and analysis tools will crash when a project contains two contracts with the same name. Additionally, this pattern increases the risk of miscommunication between developers, auditors, and/or users. Consider adding a preﬁx or suﬃx to such contract names or, if applicable, consolidating them into a single contract. Consider having helper functions load values directly from storage. Many methods load values from storage and then pass them to internal helper functions. Some of these methods, enumerated below, do not use the loaded values except to pass them to the helper functions. Consider replacing the following arguments with direct storage loads. ○ BonusTracker._earnedBonus ■ accountBalance => balanceOf[account] ■ accountBonus => bonus[account] ○ RewardTracker._earned ■ _accountBalance => balanceOf[account] + multiplierPointsOf[_account] ■ _accountRewards => rewards[account] ○ RewardTracker._calcRewardPerToken ■ _totalSupply => totalSupply + totalBonus Use helper functions consistently. An assignment to the lastTimeRewardApplicable_ variable on line 241 of the RewardTracker contract features a ternary expression identical to that of the lastTimeRewardApplicable method in the same contract. To reduce code duplication and improve readability, replace this lastTimeRewardApplicable_ assignment with a call to this helper method instead. Remove unnecessary variable assignments. The lastUpdateTime variable is updated on line 251 of the RewardTracker contract, but this new value is not used before the same variable is updated again on line 270. Removing the ﬁrst assignment on line 251 will yield identical behavior and improve the code’s readability. ● Use constants consistently. The addresses deﬁned on lines 23–28 of the scLiquity contract could be speciﬁed as constant to save gas during deployment. However, to improve the maintainability of the code, consider deﬁning these variables in the src/lib/Constants.sol ﬁle to keep all third-party contract addresses in one place. The following are the Sandclock contracts that deﬁne third-party addresses in place; consider importing them from Constants instead: ○ scLiquity ○ AaveV2Adapter (both) ○ EulerAdapter (only in scUSDCv2-adapters ) ○ MorphoAaveV3Adapter ○ Swapper ● ● ● Note that some of these, such as the xrouter address deﬁned by the scLiquity contract, are already present in the Constants library. Also note that some addresses in the Constants library are deﬁned twice, such as the ZEROX_ROUTER and ZERO_EX_ROUTER addresses. Document the omission of LQTY in the scLiquity contract’s totalAssets method. The LQTY rewards earned by depositing into the Liquity Stability Pool are expected to be small, but the gas costs for factoring LQTY rewards into the scLiquity vault are signiﬁcant. As a result, the Sandclock team has made the decision to omit LQTY rewards from the totalAssets value. This design decision should be clearly speciﬁed and justiﬁed in inline comments. Document the requirements for using the Swapper contract. The Swapper contract handles ether but does not implement a receive method because it is intended to be used via delegatecall from a contract that does implement the receive method. Add comments to the Swapper contract documenting these requirements so that future developers and auditors are aware of how it should be safely used. Use libraries in the scLiquity vault. The scLiquity vault uses error-prone low-level calls to the 0x router while harvesting proceeds for LUSD. The Swapper library implements similar swap logic with additional safety measures. Consider using the Swapper library to exchange assets instead of re-implementing this logic in place. For consistency, also consider moving the LUSD-to-ETH price-fetching logic into the PriceConverter library. D. Fix Review Results When undertaking a ﬁx review, reviews the ﬁxes implemented for issues identiﬁed in the original report. This work involves a review of speciﬁc areas of the source code and system conﬁguration, not comprehensive analysis of the system. On July 27, 2023 , reviewed the ﬁxes and mitigations implemented by the Lindy Labs team for the issues identiﬁed in this report. We reviewed each ﬁx to determine its eﬀectiveness in resolving the associated issue. In summary, of the six issues described in this report, Lindy Labs has resolved four, has partially resolved one, and has not resolved the remaining issue. For additional information, refer to the Detailed Fix Review Results below. ID Title Severity Status 1 receiveFlashLoan does not account for fees High Resolved 2 3 4 5 Reward token distribution rate can diverge from reward token balance Low Resolved Miscalculation in beforeWithdraw can leave the vault with less than minimum ﬂoat Informational Resolved Last user in scWETHv2 vault will not be able to withdraw their funds Low Resolved Lido stake rate limit could lead to unexpected reverts Informational Unresolved 6 Chainlink oracles could return stale price data Informational Partially Resolved Detailed Fix Review Results TOB-SANDCLOCK-1: receiveFlashLoan does not account for fees Resolved. The feeAmounts parameter provided by Balancer ﬂash loans is no longer ignored by the receiveFlashLoan method. The fees are now incorporated into the asset management strategy; other updates include a modiﬁed borrow amount from Aave and a modiﬁed swap amount from Uniswap. New unit tests have been added to ensure that the newly added logic properly accounts for nonzero fees that might be introduced by Balancer in the future. TOB-SANDCLOCK-2: Reward token distribution rate can diverge from reward token balance Resolved. The current token balance is now used by the _startRewardsDistribution method (renamed from _notifyRewardAmount ) of the RewardTracker contract. An additional state variable tracks the previously measured token balance to properly account for any balance increases. The distributor role no longer provides a parameter specifying how many reward tokens to allocate, eliminating any possibility of divergence. TOB-SANDCLOCK-3: Miscalculation in beforeWithdraw can leave the vault with less than minimum ﬂoat Resolved. The arithmetic calculating how much ﬂoat is missing has been ﬁxed. A new unit test has been added that reproduces the provided exploit scenario to ensure that this change ﬁxes the underlying issue and to prevent regression. TOB-SANDCLOCK-4: Last user in scWETHv2 vault will not be able to withdraw their funds Resolved. The _withdrawToVault method was refactored to limit the amount that the vault withdraws from investment strategies. This allows the last user to withdraw their remaining balance from the vault despite normal ﬂoat requirements. A new assertion was added to the unit tests to ensure that the last user is able to withdraw their funds. TOB-SANDCLOCK-5: Lido stake rate limit could lead to unexpected reverts Unresolved. The client provided the following context for this ﬁnding’s ﬁx status: We acknowledge the issue with a potential lido stake rate limit but we feel it will have a limited eﬀect and not lead to reverts on user deposits since user funds ﬁrst end up in the vault. Additional comments have been added specifying that the ZeroEx exchange will be the default method for swapping WETH for wstETH and that Lido will be used as a fallback, decreasing the likelihood of hitting the rate limit. For the beneﬁt of future auditors, we recommend adding an inline comment to the lidoSwapWethToWstEth method in the Swapper library to explain the acceptance of the risk and the use of Lido only as a fallback. TOB-SANDCLOCK-6: Chainlink oracles could return stale price data Partially resolved. The third-party LSUDUsdToLUSDEth oracle has been deprecated in favor of the more reliable USD-to-ETH oracle maintained by Liquity. This solution has the side eﬀect of assuming that the value of LUSD is exactly equal to that of USD. However, the amount of ETH held by the scLiquity vault at any given time is small relative to its exposure to the LUSD price, so the Lindy Labs team is willing to accept this trade-oﬀ. We recommend correcting an inline code comment that erroneously refers to the reported price as being in terms of LUSD rather than USD. For the beneﬁt of future auditors and developers, we also recommend adding inline comments explaining the implications of and justiﬁcations for this trade-oﬀ. The usdcToEthPriceFeed and stEThToEthPriceFeed oracles have not been updated and are still at risk of using stale data without raising any warning. 
