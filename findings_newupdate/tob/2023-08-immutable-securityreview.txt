1. Initialization functions vulnerable to front-running Severity: Informational Diﬃculty: High Type: Timing Finding ID: TOB-IMM-1 Target: Throughout Description Several implementation contracts have initialization functions that can be front-run, which would allow an attacker to incorrectly initialize the contracts. Due to the use of the delegatecall proxy pattern, the RootERC20Predicate and RootERC20PredicateFlowRate contracts (as well as other upgradeable contracts that are not in scope) cannot be initialized with a constructor, so they have initialize functions: function initialize ( address newStateSender , address newExitHelper , address newChildERC20Predicate , address newChildTokenTemplate , address nativeTokenRootAddress ) external virtual initializer { __RootERC20Predicate_init( newStateSender, newExitHelper, newChildERC20Predicate, newChildTokenTemplate, nativeTokenRootAddress ); } Figure 1.1: Front-runnable initialize function ( RootERC20Predicate.sol ) function initialize ( address superAdmin , address pauseAdmin , address unpauseAdmin , address rateAdmin , address newStateSender , address newExitHelper , address newChildERC20Predicate , address newChildTokenTemplate , address nativeTokenRootAddress ) external initializer { __RootERC20Predicate_init( newStateSender, newExitHelper, newChildERC20Predicate, newChildTokenTemplate, nativeTokenRootAddress ); __Pausable_init(); __FlowRateWithdrawalQueue_init(); _setupRole(DEFAULT_ADMIN_ROLE, superAdmin); _setupRole(PAUSER_ADMIN_ROLE, pauseAdmin); _setupRole(UNPAUSER_ADMIN_ROLE, unpauseAdmin); _setupRole(RATE_CONTROL_ROLE, rateAdmin); } Figure 1.2: Front-runnable initialize function ( RootERC20PredicateFlowRate.sol ) An attacker could front-run these functions and initialize the contracts with malicious values. The documentation provided by the Immutable team indicates that they are aware of this issue and how to mitigate it upon deployment of the proxy or when upgrading the implementation. However, there do not appear to be any deployment scripts to demonstrate that this will be correctly done in practice, and the codebase’s tests do not cover upgradeability. Exploit Scenario Bob deploys the RootERC20Predicate contract. Eve deploys an upgradeable version of the ExitHelper contract and front-runs the RootERC20Predicate initialization, passing her contract’s address as the exitHelper argument. Due to a lack of post-deployment checks, this issue goes unnoticed and the protocol functions as intended for some time, drawing in a large amount of deposits. Eve then upgrades the ExitHelper contract to allow her to arbitrarily call the onL2StateReceive function of the RootERC20Predicate contract, draining all assets from the bridge. Recommendations Short term, either use a factory pattern that will prevent front-running the initialization, or ensure that the deployment scripts have robust protections against front-running attacks. Long term, carefully review the Solidity documentation , especially the “Warnings” section, and the pitfalls of using the delegatecall proxy pattern. 
2. Lack of lower and upper bounds for system parameters Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-IMM-2 Target: contracts/root/flowrate/RootERC20PredicateFlowRate.sol Description The lack of lower and upper bound checks when setting important system parameters could lead to a temporary denial of service, allow users to complete their withdrawals prematurely, or otherwise hinder the expected performance of the system. The setWithdrawalDelay function of the RootERC20PredicateFlowRate contract can be used by the rate control role to set the amount of time that a user needs to wait before they can withdraw their assets from the root chain of the bridge. // RootERC20PredicateFlowRate.sol function setWithdrawalDelay ( uint256 delay ) external onlyRole(RATE_CONTROL_ROLE) { _setWithdrawalDelay(delay); } // FlowRateWithdrawalQueue.sol function _setWithdrawalDelay ( uint256 delay ) internal { withdrawalDelay = delay; emit WithdrawalDelayUpdated(delay); } Figure 2.1: The setter functions for the withdrawalDelay state variable ( RootERC20PredicateFlowRate.sol and FlowRateWithdrawalQueue.sol ) The withdrawalDelay variable value is applied to all currently pending withdrawals in the system, as shown in the highlighted lines of ﬁgure 2.2. function _processWithdrawal ( address receiver , uint256 index ) internal returns ( address withdrawer , address token , uint256 amount ) { // ... // Note: Add the withdrawal delay here, and not when enqueuing to allow changes // to withdrawal delay to have effect on in progress withdrawals. uint256 withdrawalTime = withdrawal.timestamp + withdrawalDelay; // slither-disable-next-line timestamp if ( block.timestamp < withdrawalTime) { // solhint-disable-next-line not-rely-on-time revert WithdrawalRequestTooEarly( block.timestamp , withdrawalTime); } // ... } Figure 2.2: The function completes a withdrawal from the withdrawal queue if the withdrawalTime has passed. ( FlowRateWithdrawalQueue.sol ) However, the setWithdrawalDelay function does not contain any validation on the delay input parameter. If the input parameter is set to zero, users can skip the withdrawal queue and immediately withdraw their assets. Conversely, if this variable is set to a very high value, it could prevent users from withdrawing their assets for as long as this variable is not updated. The setRateControlThreshold allows the rate control role to set important token parameters that are used to limit the amount of tokens that can be withdrawn at once, or in a certain time period, in order to mitigate the risk of a large amount of tokens being bridged after an exploit. // RootERC20PredicateFlowRate.sol function setRateControlThreshold ( address token , uint256 capacity , uint256 refillRate , uint256 largeTransferThreshold ) external onlyRole(RATE_CONTROL_ROLE) { _setFlowRateThreshold(token, capacity, refillRate); largeTransferThresholds[token] = largeTransferThreshold; } // FlowRateDetection.sol function _setFlowRateThreshold ( address token , uint256 capacity , uint256 refillRate ) internal { if (token == address ( 0 )) { revert InvalidToken(); } if (capacity == 0 ) { revert InvalidCapacity(); } if (refillRate == 0 ) { revert InvalidRefillRate(); } Bucket storage bucket = flowRateBuckets[token]; if (bucket.capacity == 0 ) { bucket.depth = capacity; } bucket.capacity = capacity; bucket.refillRate = refillRate; } Figure 2.3: The function sets the system parameters to limit withdrawals of a speciﬁc token. ( RootERC20PredicateFlowRate.sol and FlowRateDetection.sol ) However, because the _setFlowRateThreshold function of the FlowRateDetection contract is missing upper bounds on the input parameters, these values could be set to an incorrect or very high value. This could potentially allow users to withdraw large amounts of tokens at once, without triggering the withdrawal queue. Exploit Scenario Alice attempts to update the withdrawalDelay state variable from 24 to 48 hours. However, she mistakenly sets the variable to 0 . Eve uses this setting to skip the withdrawal queue and immediately withdraws her assets. Recommendations Short term, determine reasonable lower and upper bounds for the setWithdrawalDelay and setRateControlThreshold functions, and add the necessary validation to those functions. Long term, carefully document which system parameters are conﬁgurable and ensure they have adequate upper and lower bound checks. 
3. RootERC20Predicate is incompatible with nonstandard ERC-20 tokens Severity: Low Diﬃculty: Low Type: Data Validation Finding ID: TOB-IMM-3 Target: contracts/root/RootERC20Predicate.sol Description The deposit and depositTo functions of the RootERC20Predicate contract are incompatible with nonstandard ERC-20 tokens, such as tokens that take a fee on transfer. The RootERC20Predicate contract allows users to deposit arbitrary tokens into the root chain of the bridge and mint the corresponding token on the child chain of the bridge. Users can deposit their tokens by approving the bridge for the required amount and then calling the deposit or depositTo function of the contract. These functions will call the internal _depositERC20 function, which will perform a check to ensure the token balance of the contract is exactly equal to the balance of the contract before the deposit, plus the amount of tokens that are being deposited. function _depositERC20 (IERC20Metadata rootToken, address receiver , uint256 amount ) private { uint256 expectedBalance = rootToken.balanceOf( address ( this )) + amount; _deposit(rootToken, receiver, amount); // invariant check to ensure that the root token balance has increased by the amount deposited // slither-disable-next-line incorrect-equality require ((rootToken.balanceOf( address ( this )) == expectedBalance), "RootERC20Predicate: UNEXPECTED_BALANCE" ); } Figure 3.1: Internal function used to deposit ERC-20 tokens to the bridge ( RootERC20Predicate.sol ) However, some nonstandard ERC-20 tokens will take a percentage of the transferred amount as a fee. Due to this, the require statement highlighted in ﬁgure 3.1 will always fail, preventing users from depositing such tokens. Recommendations Short term, clearly document that nonstandard ERC-20 tokens are not supported by the protocol. If the team determines that they want to support nonstandard ERC-20 implementations, additional logic should be added into the _deposit function to determine the actual token amount received by the contract. In this case, reentrancy protection may be needed to mitigate the risks of ERC-777 and similar tokens that implement callbacks whenever tokens are sent or received. Long term, be aware of the idiosyncrasies of ERC-20 implementations. This standard has a history of misuses and issues. References ● ● Incident with non-standard ERC20 deﬂationary tokens d-xo/weird-erc20 
4. Lack of event generation Severity: Informational Diﬃculty: Low Type: Auditing and Logging Finding ID: TOB-IMM-4 Target: RootERC20PredicateFlowRate.sol , ImmutableSeaport.sol Description Multiple critical operations do not emit events. This creates uncertainty among users interacting with the system. The setRateControlThresholds function in the RootERC20PredicateFlowRate contract does not emit an event when it updates the largeTransferThresholds critical storage variable for a token (ﬁgure 4.1). However, having an event emitted to reﬂect such a change in the critical storage variable may allow other system and oﬀ-chain components to detect suspicious behavior in the system. Events generated during contract execution aid in monitoring, baselining behavior, and detecting suspicious activity. Without events, users and blockchain-monitoring systems cannot easily detect behavior that falls outside the baseline conditions, and malfunctioning contracts and attacks could go undetected. function setRateControlThreshold ( 1 address token , 2 uint256 capacity , 3 uint256 refillRate , 4 5 uint256 largeTransferThreshold 6 ) external onlyRole(RATE_CONTROL_ROLE) { 7 8 9 } _setFlowRateThreshold(token, capacity, refillRate); largeTransferThresholds[token] = largeTransferThreshold; Figure 4.1: The setRateControlThreshold function ( RootERC20PredicateFlowRate.sol #L214-L222 ) In addition to the above function, the following function should also emit events: ● The setAllowedZone function in seaport/contracts/ImmutableSeaport.sol Recommendations Short term, add events for all functions that change state to aid in better monitoring and alerting. Long term, ensure that all state-changing operations are always accompanied by events. In addition, use static analysis tools such as Slither to help prevent such issues in the future. 
1. Initialization functions vulnerable to front-running Severity: Informational Diﬃculty: High Type: Timing Finding ID: TOB-IMM-1 Target: Throughout Description Several implementation contracts have initialization functions that can be front-run, which would allow an attacker to incorrectly initialize the contracts. Due to the use of the delegatecall proxy pattern, the RootERC20Predicate and RootERC20PredicateFlowRate contracts (as well as other upgradeable contracts that are not in scope) cannot be initialized with a constructor, so they have initialize functions: function initialize ( address newStateSender , address newExitHelper , address newChildERC20Predicate , address newChildTokenTemplate , address nativeTokenRootAddress ) external virtual initializer { __RootERC20Predicate_init( newStateSender, newExitHelper, newChildERC20Predicate, newChildTokenTemplate, nativeTokenRootAddress ); } Figure 1.1: Front-runnable initialize function ( RootERC20Predicate.sol ) function initialize ( address superAdmin , address pauseAdmin , address unpauseAdmin , address rateAdmin , address newStateSender , address newExitHelper , address newChildERC20Predicate , address newChildTokenTemplate , address nativeTokenRootAddress ) external initializer { __RootERC20Predicate_init( newStateSender, newExitHelper, newChildERC20Predicate, newChildTokenTemplate, nativeTokenRootAddress ); __Pausable_init(); __FlowRateWithdrawalQueue_init(); _setupRole(DEFAULT_ADMIN_ROLE, superAdmin); _setupRole(PAUSER_ADMIN_ROLE, pauseAdmin); _setupRole(UNPAUSER_ADMIN_ROLE, unpauseAdmin); _setupRole(RATE_CONTROL_ROLE, rateAdmin); } Figure 1.2: Front-runnable initialize function ( RootERC20PredicateFlowRate.sol ) An attacker could front-run these functions and initialize the contracts with malicious values. The documentation provided by the Immutable team indicates that they are aware of this issue and how to mitigate it upon deployment of the proxy or when upgrading the implementation. However, there do not appear to be any deployment scripts to demonstrate that this will be correctly done in practice, and the codebase’s tests do not cover upgradeability. Exploit Scenario Bob deploys the RootERC20Predicate contract. Eve deploys an upgradeable version of the ExitHelper contract and front-runs the RootERC20Predicate initialization, passing her contract’s address as the exitHelper argument. Due to a lack of post-deployment checks, this issue goes unnoticed and the protocol functions as intended for some time, drawing in a large amount of deposits. Eve then upgrades the ExitHelper contract to allow her to arbitrarily call the onL2StateReceive function of the RootERC20Predicate contract, draining all assets from the bridge. Recommendations Short term, either use a factory pattern that will prevent front-running the initialization, or ensure that the deployment scripts have robust protections against front-running attacks. Long term, carefully review the Solidity documentation , especially the “Warnings” section, and the pitfalls of using the delegatecall proxy pattern. 
2. Lack of lower and upper bounds for system parameters Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-IMM-2 Target: contracts/root/flowrate/RootERC20PredicateFlowRate.sol Description The lack of lower and upper bound checks when setting important system parameters could lead to a temporary denial of service, allow users to complete their withdrawals prematurely, or otherwise hinder the expected performance of the system. The setWithdrawalDelay function of the RootERC20PredicateFlowRate contract can be used by the rate control role to set the amount of time that a user needs to wait before they can withdraw their assets from the root chain of the bridge. // RootERC20PredicateFlowRate.sol function setWithdrawalDelay ( uint256 delay ) external onlyRole(RATE_CONTROL_ROLE) { _setWithdrawalDelay(delay); } // FlowRateWithdrawalQueue.sol function _setWithdrawalDelay ( uint256 delay ) internal { withdrawalDelay = delay; emit WithdrawalDelayUpdated(delay); } Figure 2.1: The setter functions for the withdrawalDelay state variable ( RootERC20PredicateFlowRate.sol and FlowRateWithdrawalQueue.sol ) The withdrawalDelay variable value is applied to all currently pending withdrawals in the system, as shown in the highlighted lines of ﬁgure 2.2. function _processWithdrawal ( address receiver , uint256 index ) internal returns ( address withdrawer , address token , uint256 amount ) { // ... // Note: Add the withdrawal delay here, and not when enqueuing to allow changes // to withdrawal delay to have effect on in progress withdrawals. uint256 withdrawalTime = withdrawal.timestamp + withdrawalDelay; // slither-disable-next-line timestamp if ( block.timestamp < withdrawalTime) { // solhint-disable-next-line not-rely-on-time revert WithdrawalRequestTooEarly( block.timestamp , withdrawalTime); } // ... } Figure 2.2: The function completes a withdrawal from the withdrawal queue if the withdrawalTime has passed. ( FlowRateWithdrawalQueue.sol ) However, the setWithdrawalDelay function does not contain any validation on the delay input parameter. If the input parameter is set to zero, users can skip the withdrawal queue and immediately withdraw their assets. Conversely, if this variable is set to a very high value, it could prevent users from withdrawing their assets for as long as this variable is not updated. The setRateControlThreshold allows the rate control role to set important token parameters that are used to limit the amount of tokens that can be withdrawn at once, or in a certain time period, in order to mitigate the risk of a large amount of tokens being bridged after an exploit. // RootERC20PredicateFlowRate.sol function setRateControlThreshold ( address token , uint256 capacity , uint256 refillRate , uint256 largeTransferThreshold ) external onlyRole(RATE_CONTROL_ROLE) { _setFlowRateThreshold(token, capacity, refillRate); largeTransferThresholds[token] = largeTransferThreshold; } // FlowRateDetection.sol function _setFlowRateThreshold ( address token , uint256 capacity , uint256 refillRate ) internal { if (token == address ( 0 )) { revert InvalidToken(); } if (capacity == 0 ) { revert InvalidCapacity(); } if (refillRate == 0 ) { revert InvalidRefillRate(); } Bucket storage bucket = flowRateBuckets[token]; if (bucket.capacity == 0 ) { bucket.depth = capacity; } bucket.capacity = capacity; bucket.refillRate = refillRate; } Figure 2.3: The function sets the system parameters to limit withdrawals of a speciﬁc token. ( RootERC20PredicateFlowRate.sol and FlowRateDetection.sol ) However, because the _setFlowRateThreshold function of the FlowRateDetection contract is missing upper bounds on the input parameters, these values could be set to an incorrect or very high value. This could potentially allow users to withdraw large amounts of tokens at once, without triggering the withdrawal queue. Exploit Scenario Alice attempts to update the withdrawalDelay state variable from 24 to 48 hours. However, she mistakenly sets the variable to 0 . Eve uses this setting to skip the withdrawal queue and immediately withdraws her assets. Recommendations Short term, determine reasonable lower and upper bounds for the setWithdrawalDelay and setRateControlThreshold functions, and add the necessary validation to those functions. Long term, carefully document which system parameters are conﬁgurable and ensure they have adequate upper and lower bound checks. 
3. RootERC20Predicate is incompatible with nonstandard ERC-20 tokens Severity: Low Diﬃculty: Low Type: Data Validation Finding ID: TOB-IMM-3 Target: contracts/root/RootERC20Predicate.sol Description The deposit and depositTo functions of the RootERC20Predicate contract are incompatible with nonstandard ERC-20 tokens, such as tokens that take a fee on transfer. The RootERC20Predicate contract allows users to deposit arbitrary tokens into the root chain of the bridge and mint the corresponding token on the child chain of the bridge. Users can deposit their tokens by approving the bridge for the required amount and then calling the deposit or depositTo function of the contract. These functions will call the internal _depositERC20 function, which will perform a check to ensure the token balance of the contract is exactly equal to the balance of the contract before the deposit, plus the amount of tokens that are being deposited. function _depositERC20 (IERC20Metadata rootToken, address receiver , uint256 amount ) private { uint256 expectedBalance = rootToken.balanceOf( address ( this )) + amount; _deposit(rootToken, receiver, amount); // invariant check to ensure that the root token balance has increased by the amount deposited // slither-disable-next-line incorrect-equality require ((rootToken.balanceOf( address ( this )) == expectedBalance), "RootERC20Predicate: UNEXPECTED_BALANCE" ); } Figure 3.1: Internal function used to deposit ERC-20 tokens to the bridge ( RootERC20Predicate.sol ) However, some nonstandard ERC-20 tokens will take a percentage of the transferred amount as a fee. Due to this, the require statement highlighted in ﬁgure 3.1 will always fail, preventing users from depositing such tokens. Recommendations Short term, clearly document that nonstandard ERC-20 tokens are not supported by the protocol. If the team determines that they want to support nonstandard ERC-20 implementations, additional logic should be added into the _deposit function to determine the actual token amount received by the contract. In this case, reentrancy protection may be needed to mitigate the risks of ERC-777 and similar tokens that implement callbacks whenever tokens are sent or received. Long term, be aware of the idiosyncrasies of ERC-20 implementations. This standard has a history of misuses and issues. References ● ● Incident with non-standard ERC20 deﬂationary tokens d-xo/weird-erc20 
4. Lack of event generation Severity: Informational Diﬃculty: Low Type: Auditing and Logging Finding ID: TOB-IMM-4 Target: RootERC20PredicateFlowRate.sol , ImmutableSeaport.sol Description Multiple critical operations do not emit events. This creates uncertainty among users interacting with the system. The setRateControlThresholds function in the RootERC20PredicateFlowRate contract does not emit an event when it updates the largeTransferThresholds critical storage variable for a token (ﬁgure 4.1). However, having an event emitted to reﬂect such a change in the critical storage variable may allow other system and oﬀ-chain components to detect suspicious behavior in the system. Events generated during contract execution aid in monitoring, baselining behavior, and detecting suspicious activity. Without events, users and blockchain-monitoring systems cannot easily detect behavior that falls outside the baseline conditions, and malfunctioning contracts and attacks could go undetected. function setRateControlThreshold ( 1 address token , 2 uint256 capacity , 3 uint256 refillRate , 4 5 uint256 largeTransferThreshold 6 ) external onlyRole(RATE_CONTROL_ROLE) { 7 8 9 } _setFlowRateThreshold(token, capacity, refillRate); largeTransferThresholds[token] = largeTransferThreshold; Figure 4.1: The setRateControlThreshold function ( RootERC20PredicateFlowRate.sol #L214-L222 ) In addition to the above function, the following function should also emit events: ● The setAllowedZone function in seaport/contracts/ImmutableSeaport.sol Recommendations Short term, add events for all functions that change state to aid in better monitoring and alerting. Long term, ensure that all state-changing operations are always accompanied by events. In addition, use static analysis tools such as Slither to help prevent such issues in the future. 
5. Withdrawal queue can be forcibly activated to hinder bridge operation Severity: Medium Diﬃculty: Low Type: Denial of Service Finding ID: TOB-IMM-5 Target: RootERC20PredicateFlowRate.sol Description The withdrawal queue can be forcibly activated to impede the proper operation of the bridge. The RootERC20PredicateFlowRate contract implements a withdrawal queue to more easily detect and stop large withdrawals from passing through the bridge (e.g., bridging illegitimate funds from an exploit). A transaction can enter the withdrawal queue in four ways: 1. If a token’s ﬂow rate has not been conﬁgured by the rate control admin 2. If the withdrawal amount is larger than or equal to the large transfer threshold for that token 3. If, during a predeﬁned period, the total withdrawals of that token are larger than the deﬁned token capacity 4. If the rate controller manually activates the withdrawal queue by using the activateWithdrawalQueue function In cases 3 and 4 above, the withdrawal queue becomes active for all tokens, not just the individual transfers. Once the withdrawal queue is active, all withdrawals from the bridge must wait a speciﬁed time before the withdrawal can be ﬁnalized. As a result, a malicious actor could withdraw a large amount of tokens to forcibly activate the withdrawal queue and hinder the expected operation of the bridge. Exploit Scenario 1 Eve observes Alice initiating a transfer to bridge her tokens back to the mainnet. Eve also initiates a transfer, or a series of transfers to avoid exceeding the per-transaction limit, of suﬃcient tokens to exceed the expected ﬂow rate. With Alice unaware she is being targeted for grieﬁng, Eve can execute her withdrawal on the root chain ﬁrst, cause Alice’s withdrawal to be pushed into the withdrawal queue, and activate the queue for every other bridge user. Exploit Scenario 2 Mallory has identiﬁed an exploit on the child chain or in the bridge itself, but because of the withdrawal queue, it is not feasible to exﬁltrate the funds quickly enough without risking getting caught. Mallory identiﬁes tokens with small ﬂow rate limits relative to their price and repeatedly triggers the withdrawal queue for the bridge, degrading the user experience until Immutable disables the withdrawal queue. Mallory takes advantage of this window of time to carry out her exploit, bridge the funds, and move them into a mixer. Recommendations Short term, explore the feasibility of withdrawal queues on a per-token basis instead of having only a global queue. Be aware that if the ﬂow rates are set low enough, an attacker could feasibly use them to grief all bridge users. Long term, develop processes for regularly reviewing the conﬁguration of the various token buckets. Fluctuating token values may unexpectedly make this type of grieﬁng more feasible. A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diﬃculty levels used in this document. Vulnerability Categories Category Description Access Controls Insuﬃcient authorization or assessment of rights Auditing and Logging Insuﬃcient auditing of actions or logging of problems Authentication Improper identiﬁcation of users Conﬁguration Misconﬁgured servers, devices, or software components Cryptography A breach of system conﬁdentiality or integrity Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service A system failure with an availability impact Error Reporting Insecure or insuﬃcient reporting of error conditions Patching Use of an outdated software package or library Session Management Improper identiﬁcation of authenticated users Testing Timing Insuﬃcient test methodology or test coverage Race conditions or other order-of-operations ﬂaws Undeﬁned Behavior Undeﬁned behavior triggered within the system Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices. Undetermined The extent of the risk was not determined during this engagement. Low The risk is small or is not one the client has indicated is important. Medium High User information is at risk; exploitation could pose reputational, legal, or moderate ﬁnancial risks. The ﬂaw could aﬀect numerous users and have serious reputational, legal, or ﬁnancial implications. Diﬃculty Levels Diﬃculty Description Undetermined The diﬃculty of exploitation was not determined during this engagement. Low Medium High The ﬂaw is well known; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of the system. An attacker must have privileged access to the system, may need to know complex technical details, or must discover other weaknesses to exploit this issue. B. Code Maturity Categories The following tables describe the code maturity categories and rating criteria used in this document. Code Maturity Categories Category Description Arithmetic The proper use of mathematical operations and semantics Auditing The use of event auditing and logging to support monitoring Authentication / Access Controls The use of robust access controls to handle identiﬁcation and authorization and to ensure safe interactions with the system Complexity Management The presence of clear structures designed to manage system complexity, including the separation of system logic into clearly deﬁned functions Cryptography and Key Management The safe use of cryptographic primitives and functions, along with the presence of robust mechanisms for key generation and distribution Decentralization The presence of a decentralized governance structure for mitigating insider threats and managing risks posed by contract upgrades Documentation The presence of comprehensive and readable codebase documentation Front-Running Resistance Low-Level Manipulation The system’s resistance to front-running attacks The justiﬁed use of inline assembly and low-level calls Testing and Veriﬁcation The presence of robust testing procedures (e.g., unit tests, integration tests, and veriﬁcation methods) and suﬃcient test coverage Rating Criteria Rating Strong Description No issues were found, and the system exceeds industry standards. Satisfactory Minor issues were found, but the system is compliant with best practices. Moderate Some issues that may aﬀect system safety were found. Weak Many issues that aﬀect system safety were found. Missing A required component is missing, signiﬁcantly aﬀecting system safety. Not Applicable The category is not applicable to this review. Not Considered The category was not considered in this review. Further Investigation Required Further investigation is required to reach a meaningful conclusion. C. Code Quality Recommendations The following recommendations are not associated with speciﬁc vulnerabilities. However, they enhance code readability and may prevent the introduction of vulnerabilities in the future. Bridge Contracts ● ● ● ● The _setupRole function was deprecated in OpenZeppelin Contracts v4.4.0 in favor of the _grantRole function. Replace the deprecated calls with similar calls to _grantRole . Using 0x1 as the root chain token address for native ether could have subtle unexpected side eﬀects because this address corresponds to the ecrecover precompile. Consider using a diﬀerent address outside of the existing precompile space (e.g., some protocols use an address consisting of all 0xe s). Prefer using larger time units when possible to improve readability. For example, the DEFAULT_WITHDRAWAL_DELAY constant in the FlowRateWithdrawalQueue contract could be deﬁned as 1 days instead of 60 * 60 * 24 . Assigning constant state variables to be the result of an expression that uses other constant variables can lead to an increase in gas costs, bytecode size, and unexpected results. This is because the compiler will replace all mentions of the constant with the expression itself, as opposed to replacing it with the result of the expression in case of literals. This can cause subtle issues if the expression results in a revert or panic (e.g., arithmetic underﬂow). D. Testing Improvement Recommendations This appendix aims to provide general recommendations on improving processes and creating a robust testing suite. General Recommendations Creating a robust testing suite is an iterative process that can involve deﬁning or adjusting internal development processes and using multiple testing strategies and approaches. We compiled a list of general guidelines for improving testing suite quality below: 1. 2. 3. 4. 5. 6. Deﬁne a clear test directory structure. A clear directory structure can be beneﬁcial for structuring the work of multiple developers, making it easier to identify which components and behaviors are being tested and giving insight into the overall test coverage. Write a design speciﬁcation of the system, its components, and its functions in plain language. Deﬁning a speciﬁcation can allow the team to more easily detect bugs and inconsistencies in the system, reduce the likelihood that future code changes will introduce bugs, improve the maintainability of the system, and create a robust and holistic testing strategy. Use the function speciﬁcations to guide the creation of unit tests. Creating a speciﬁcation of all preconditions, postconditions, failure cases, entry points, and execution paths for a function will make it easier to maintain high test coverage and identify edge cases. Use the interaction speciﬁcations to guide the creation of integration tests. An interaction speciﬁcation will make it easier to identify the interactions that need to be tested and the external failure cases that need to be validated or guarded against. It will also help identify issues related to access controls and external calls. Use fork testing for integration testing with third-party smart contracts and to ensure the deployed system works as expected. Fork testing can be used to test interactions between the protocol contracts and third-party smart contracts by providing an environment that is as close to production as possible. Additionally, fork testing can be used to identify whether the deployed system is behaving as expected. Implement fuzz testing by ﬁrst deﬁning a set of system- and function-level invariants and then testing them with Echidna and/or Foundry. Fuzz testing is a powerful technique for exposing security vulnerabilities and ﬁnding edge cases that are unlikely to be found through unit testing or manual review. Fuzz testing can be done on a single function by passing in randomized arguments and on an entire system by generating a sequence of random calls to various functions inside the system. Both testing approaches should be applied. 7. Use mutation testing to identify gaps in test coverage and more easily identify bugs in the code. Mutation testing can help identify coverage gaps in unit tests and help discover security vulnerabilities. Taking a two-pronged approach using Necessist to mutate tests and universalmutator to mutate source code can prove valuable in creating a robust testing suite. Directory Structure Creating a speciﬁc directory structure for the system’s tests will make it easier to develop and maintain the testing suite and to ﬁnd coverage gaps. This section contains brief guidelines on deﬁning a directory structure: ● ● ● Create individual directories for each test type (e.g., unit/ , integration/ , fork/ , fuzz/ ) and for the utility contracts. The individual directories can be further divided into directories based on components or behaviors being tested. Create a single base contract that inherits from the shared utility contracts and is inherited by individual test contracts. This will help reduce code duplication across the testing suite. Create a clear naming convention for test ﬁles and test functions to make it easier to ﬁlter tests and understand the properties or contracts that are being tested. Speciﬁcation Guidelines This section provides generally accepted best practices and guidance for how to write design speciﬁcations. A good design speciﬁcation serves three purposes: 1. 2. It helps development teams detect bugs and inconsistencies in a proposed system architecture before any code is written. Codebases written without adequate speciﬁcations are often littered with snippets of code that have lost their relevance as the system’s design has evolved. Without a speciﬁcation, it is exceedingly challenging to detect such code snippets and remove them without extensive validation testing. It reduces the likelihood that bugs will be introduced in implementations of the system . In systems without a speciﬁcation, engineers must divide their attention between designing the system and implementing it in code. In projects requiring multiple engineers, engineers may make assumptions about how another engineer’s component works, creating an opportunity for bugs to be introduced. 3. It improves the maintainability of system implementations and reduces the likelihood that future code changes will introduce bugs. Without an adequate speciﬁcation, new developers need to spend time “on-ramping,” where they explore the code and learn how it works. This process is highly error-prone and can lead to incorrect assumptions and the introduction of bugs. Low-level designs may also be used by test engineers to create property-based fuzz tests and by auditors to reduce the time needed to audit a speciﬁc protocol component. Speciﬁcation Construction A good speciﬁcation must describe system components in enough detail that an engineer unfamiliar with the project can use the speciﬁcation to implement those components. The level of detail required to achieve this can vary from project to project, but generally, a low-level speciﬁcation will include the following details, at a minimum: ● ● ● ● How each system component (e.g., a contract or plugin) interacts with and relies on other components The actors and agents that participate in the system, the way they interact with the system, and their permissions, roles, authorization mechanisms, and expected known-good ﬂows The expected failure conditions the system may encounter and the way those failures are mitigated, including failures that are automatically mitigated Speciﬁcation details for each function that the system will implement, which should include the following: ○ ○ ○ ○ ○ ○ ○ A description of the function’s purpose and intended use A description of the function’s inputs and the various validations that are performed against each input Any speciﬁc restrictions on the function’s inputs that are not validated or not obvious Any interactions between the function and other system components The function’s various failure modes, such as failure modes for queries to a Chainlink oracle for a price (e.g., stale price, oracle disabled) Any authentication or authorization required by the function Any function-level assumptions that depend on other components behaving in a speciﬁc way In addition, speciﬁcations should use standardized RFC-2119 language as much as possible. This language pushes speciﬁcation authors toward a writing style that is both detailed and easy to understand. One relevant example is the ERC-4626 speciﬁcation , which uses RFC-2119 language and provides enough constraints on implementers so that a vault client for a single implementation may be used interchangeably with other implementations. Interaction Speciﬁcation Example An interaction speciﬁcation is used to describe how the components of the system depend on each other. It includes a description of the other components that the system interacts with, the nature of those interactions, expected behavior or dependencies, and access relationships. A diagram can often be a helpful aid for modeling component interactions, but it should not be used to substitute a textual description of the component’s interactions. Part of the goal of a speciﬁcation is to help derive a list of properties that can be explicitly tested, and deriving properties from a diagram is much more challenging and error-prone than deriving properties from a textual speciﬁcation. Here is an example of an interaction speciﬁcation. RootERC20Predicate interacts with the following contracts: ● StateSender : RootERC20Predicate calls the syncState function of this contract whenever: 1. a root token is mapped to a child token address, or 2. an ERC-20 or native asset is deposited into the contract. This function will emit an event that will be picked up by the oﬀ-chain components and later included as part of a commit to the receiving chain. The following contracts interact with RootERC20Predicate : ● [Example contract] The following actors interact with RootERC20Predicate : ● [Example actor] Function Speciﬁcation Example Here is an example of a speciﬁcation for the mapToken(IERC20Metadata rootToken) function. The mapToken function can be called by any account to map the root token address to a child token on the other chain. If the rootToken input parameter is zero, mapToken () must revert. If the rootToken address has already been mapped to a child token, mapToken () must revert. If the provided address is not the zero address and the address has not been mapped to a child token before, mapToken () must set the rootTokenToChildToken[rootToken] mapping to the address return value of the Clones.predictDeterministicAddress function, call the syncState function of the StateSender contract, emit the TokenMapped event, and return the child token address. Another complementary technique for deﬁning a function speciﬁcation, which can be especially useful for deﬁning test cases, is the branching tree technique ( proposed by Paul Berg ), which is a tree-like structure based on all the execution paths, the contract state or function arguments that lead to each path, and the end result of each path. This type of speciﬁcation can be useful when developing unit tests because it makes it easy to identify the execution paths, conditions, and edge cases that need to be tested. Constraints Speciﬁcation Example Here is an example of a constraints speciﬁcation. A RootERC20Predicate contract must be initialized in the same transaction as the deployment by calling the initialize function. RootERC20Predicate has two constraints that limit the contract’s operation: the stateSender address and the exitHelper address. The stateSender address must be deﬁned during initialization and must implement the syncState function. If this address is not deﬁned or is misconﬁgured, all calls to deposit or map tokens will fail, preventing the bridge from operating. The exitHelper address must be deﬁned during initialization. If this address is not deﬁned or is misconﬁgured, users will not be able to withdraw their bridged assets. Integration and Fork Testing Integration tests build on unit tests by testing how individual components integrate with each other or with third-party contracts. It can often be useful to run integration testing on a fork of the network to make the testing environment as close to production as possible and to minimize the use of mock contracts whose implementation can diﬀer from the third-party contracts. We provide general recommendations on performing integration and fork testing below: ● Use the interaction speciﬁcation to develop integration tests. Ensure that the integration tests aid in verifying the interaction’s speciﬁcation. ● ● ● ● Identify valuable input data for the integration tests that can maximize code coverage and test potential edge cases. Use negative integration tests , similar to negative unit tests, to test common failure cases. Use fork testing to build on top of the integration testing suite. Fork testing will aid in testing third-party contract integrations and the proper conﬁguration of the system once it is deployed. Enrich the forked integration testing suite with fuzzed values and call sequences (refer to the recommendations below). This will aid in increasing code coverage, validating system-level invariants, and identifying edge cases. Fuzz Testing ● ● ● ● ● Deﬁne system- and function-level invariants. Invariants are properties that should always hold within a system, component, or function. Deﬁning invariants is a prerequisite for developing eﬀective fuzz tests that can detect unexpected behavior. Developing a robust system speciﬁcation will directly aid in the identiﬁcation of system- and function-level invariants. Improving fuzz testing coverage. When using Echidna, regularly review the coverage ﬁles generated at the end of a run to determine whether the property tests’ assertions are reached and what parts of the codebase are explored by the fuzzer. To improve the fuzzer’s exploration and increase the chances that it ﬁnds an unexpected edge case, avoid overconstraining the function arguments. Integrate fuzz testing into the CI/CD workﬂow. Continuous fuzz testing can help quickly identify any code changes that will result in a violation of a system property and can force developers to update the fuzz testing suite in parallel with the code. Running fuzz campaigns stochastically may cause a divergence between the operations in the code and the fuzz tests. Add comprehensive logging mechanisms to all fuzz tests to aid in debugging. Logging during smart contract fuzzing is crucial for understanding the state of the system when a system property is broken. Without logging, it is diﬃcult to identify the arithmetic or operation that caused the failure. Enrich each fuzz test with comments explaining the preconditions and postconditions of the test. Strong fuzz testing requires well-deﬁned preconditions (for guiding the fuzzer) and postconditions (for properly testing the invariants in question). Comments explaining the bounds on certain values and the importance of the system properties being tested will aid in testing suite maintenance and debugging eﬀorts. Mutation Testing At a high level, mutation tests make several changes to each line of a target ﬁle and rerun the testing suite for each change. Changes that result in test failures indicate adequate test coverage, while changes that do not result in test failures indicate gaps in the test coverage. Although mutation testing is a slow process, it allows auditors to focus their review on areas of the codebase that are most likely to contain latent bugs, and it allows developers to identify and add missing tests. We recommend using two mutation tools, both of which can help detect redundant code, insuﬃcient test coverage, incorrectly deﬁned tests or conditions, and bugs in the underlying source code under test: ● ● Necessist performs mutation of the testing suite by iteratively removing lines in the test cases. universalmutator performs mutation of the underlying source code. E. Fix Review Results When undertaking a ﬁx review, reviews the ﬁxes implemented for issues identiﬁed in the original report. This work involves a review of speciﬁc areas of the source code and system conﬁguration, not comprehensive analysis of the system. On October 2, 2023, reviewed the ﬁxes and mitigations implemented by the Immutable team for the issues identiﬁed in this report. We reviewed each ﬁx to determine its eﬀectiveness in resolving the associated issue. In summary, the Immutable team has resolved all ﬁve issues described in this report. For additional information, please see the Detailed Fix Review Results below. ID Title Status 1 Initialization functions vulnerable to front-running Resolved 2 Lack of lower and upper bounds for system parameters Resolved 3 RootERC20Predicate is incompatible with nonstandard ERC- Detailed Fix Review Results TOB-IMM-1: Initialization functions vulnerable to front-running Resolved in commit 9156c04 through inline documentation. The Immutable team incorporated explanatory inline comments in both initialize functions. These comments highlight the potential for front-running and propose preventive steps, such as calling initialize when TransparentUpgradeableProxy is deployed through its constructor or calling initialize post-deployment of TransparentUpgradeableProxy to check for possible front-running. TOB-IMM-2: Lack of lower and upper bounds for system parameters Resolved in commit 29251f9 through inline documentation. The Immutable team added descriptive inline comments for both the setWithdrawalDelay and setRateControlThreshold functions, outlining the potential risks associated with setting excessively high and low threshold values and outlining the strategies to mitigate these risks, such as monitoring and resetting the threshold values. TOB-IMM-3: RootERC20Predicate is incompatible with nonstandard ERC-20 tokens Resolved in commit 9b5a008 through inline documentation. The Immutable team added inline comments indicating that the deposit function is not compatible with nonstandard ERC-20 tokens that implement fees during transfers. TOB-IMM-4: Lack of event generation Resolved in commit 64f1a11 and commit b46f2cc . Both the setRateControlThreshold and setAllowedZone functions now incorporate the events emitted after the execution of the corresponding action. TOB-IMM-5: Withdrawal queue can be forcibly activated to hinder bridge operation Resolved in commit 7ff87f2 through inline documentation. The Immutable team incorporated inline comments in the RootERC20PredicateFlowRate contract to highlight the dangers of misconﬁgured ﬂow rates, which could potentially be exploited by an attacker, and to outline the measures to avoid such conﬁguration errors. F. Fix Review Status Categories The following table describes the statuses used to indicate whether an issue has been suﬃciently addressed. Fix Status Status Description Undetermined The status of the issue was not determined during this engagement. Unresolved The issue persists and has not been resolved. Partially Resolved The issue persists but has been partially resolved. Resolved The issue has been suﬃciently resolved. 
