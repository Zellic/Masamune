1. Related-nonce attacks across keys allow root key recovery Severity: Medium Diﬃculty: Undetermined Type: Cryptography Finding ID: TOB-CTSA-1 Target: Root key Description Given multiple addresses generated by the same sender, if any two signatures with the associated private keys use the same nonce, then the recipient’s private root key can be recovered. Nonce reuse attacks are a known risk for single ECDSA keys, but this attack extends the vulnerability to all keys generated by a given sender. Exploit Scenario Alice uses Bob’s public key to generate addresses 𝐵 1 = 𝐻𝑎𝑠ℎ ( 𝑠 ||1 ) * 𝐺 + 𝐵 𝑎𝑏 and 𝑟𝑜𝑜𝑡 = 𝐻𝑎𝑠ℎ ( 𝑠 ||2 ) * 𝐺 + 𝐵 and deposits funds in each. Bob’s corresponding private 𝐵 2 keys will be 𝑎𝑏 𝑏 1 does not know 𝑟𝑜𝑜𝑡 ||1 ) + 𝑏 = 𝐻𝑎𝑠ℎ ( 𝑠 𝑎𝑏 𝑏 2 𝑟𝑜𝑜𝑡 𝑏 , she does know the diﬀerence of the two: 2 = 𝐻𝑎𝑠ℎ ( 𝑠 ||2 ) + 𝑏 and 𝑟𝑜𝑜𝑡 𝑎𝑏 𝑏 1 or . Note that, while Alice 𝑏 𝑑𝑖𝑓𝑓 = 𝑏 2 − 𝑏 1 = 𝐻𝑎𝑠ℎ ( 𝑠 ||2 ) − 𝐻𝑎𝑠ℎ ( 𝑠 ||1 ) 𝑎𝑏 . As a result, she can write 𝑏 2 = 𝑏 1 + 𝑏 . 𝑑𝑖𝑓𝑓 𝑎𝑏 Suppose Bob signs messages with hashes (respectively), and he uses the same nonce 𝑚 2 and to transfer the funds out of 𝑚 𝐵 1 2 𝑘 in both signatures. He will output signatures − 1 − 1 and 𝐵 1 ) ( 𝑟 , 𝑠 1 and ) ( 𝑟 , 𝑠 2 , where 𝑟 = ( 𝑘 * 𝐺 ) , 𝑥 𝑠 1 = 𝑘 ( 𝑚 1 ) + 𝑟 𝑏 1 , and = 𝑘 𝑠 2 ( 𝑚 2 + 𝑟 𝑏 1 + 𝑟 𝑏 ) 𝑑𝑖𝑓𝑓 . 𝑠 Subtracting the -values gives us 𝑠 1 except 𝑘 are known, Alice can recover − 1 − 𝑠 2 𝑘 = 𝑘 ( 𝑚 1 𝑏 , and thus 1 − 𝑚 2 𝑏 , and 2 − 𝑟 𝑏 ) 𝑑𝑖𝑓𝑓 𝑏 𝑟𝑜𝑜𝑡 . Because all the terms = 𝑏 2 − 𝐻𝑎𝑠ℎ ( 𝑠 ||2 ) . 𝑎𝑏 Recommendations Consider using deterministic nonce generation in any stealth-enabled wallets. This is an approach used in multiple elliptic curve digital signature schemes, and can be adapted to ECDSA relatively easily; see RFC 6979 . Also consider root key blinding. Set 𝐵 𝑖 = 𝐻𝑎𝑠ℎ ( 𝑠 || 𝑖 ) * 𝐺 + 𝐻𝑎𝑠ℎ ( 𝑠 || 𝑖 ||" 𝑟𝑜𝑜𝑡 " ) * 𝐵 𝑎𝑏 𝑎𝑏 With blinding, private keys take the form 𝑏 𝑖 = 𝐻𝑎𝑠ℎ ( 𝑠 || 𝑖 ) + 𝑏 · 𝐻𝑎𝑠ℎ ( 𝑠 || 𝑖 ||" 𝑟𝑜𝑜𝑡 " ) 𝑎𝑏 𝑎𝑏 Since the 𝑏 𝑟𝑜𝑜𝑡 terms no longer cancel out, Alice cannot ﬁnd , and the attack falls apart. 𝑟𝑜𝑜𝑡 𝑏 𝑑𝑖𝑓𝑓 . 𝑟𝑜𝑜𝑡 . Finally, consider using homogeneous key derivation. Set private key for Bob is then 𝑏 𝑖 = 𝐻𝑎𝑠ℎ ( 𝑠 || 𝑖 ) · 𝑏 + 𝑏 𝑎𝑏 𝐷𝐻 𝑟𝑜𝑜𝑡 𝐵 𝑖 = 𝐻𝑎𝑠ℎ ( 𝑠 || 𝑖 ) * 𝐵 + 𝐵 𝑟𝑜𝑜𝑡 . Because Alice does not know 𝐷𝐻 𝑎𝑏 . The 𝑏 , 𝑑ℎ she cannot ﬁnd 𝑏 , and the attack falls apart. 𝑑𝑖𝑓𝑓 References ● ● ECDSA: Handle with Care RFC 6979: Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA) 
2. Limited forgeries for related keys Severity: Low Diﬃculty: Low Type: Cryptography Finding ID: TOB-CTSA-2 Target: Stealth addresses generated by the same sender Description If Bob signs a message for an address generated by Alice, Alice can convert it into a valid signature for another address. She cannot, however, control the hash of the message being signed, so this attack is of limited value. As with the related-nonce attack, this attack relies on Alice knowing the diﬀerence in discrete logarithms between two addresses. Exploit Scenario Alice generates addresses 𝐵 1 = 𝐻𝑎𝑠ℎ ( 𝑠 ||1 ) * 𝐺 + 𝐵 𝑎𝑏 and 𝐵 2 𝑟𝑜𝑜𝑡 = 𝐻𝑎𝑠ℎ ( 𝑠 ||2 ) * 𝐺 + 𝐵 𝑎𝑏 𝑟𝑜𝑜𝑡 and deposits funds in each account. As before, Alice knows discrete logs for 𝐵 1 and 𝐵 , and 2 𝐵 𝑑𝑖𝑓𝑓 = 𝐵 2 − 𝐵 . 1 𝑏 𝑑𝑖𝑓𝑓 , the diﬀerence of the Bob transfers money out of 𝐵 , generating signature 2 𝑘 * 𝐺 -coordinate of (where 𝑘 where 𝑟 is the 𝑥 ( 𝑟 , 𝑠 ) of a message 𝑚 𝑒 with hash , is the nonce). The signature is validated by computing 𝑃 = 𝑒 𝑠 − 1 * 𝐺 + 𝑟 𝑠 − 1 * 𝐵 2 and verifying that the 𝑥 -coordinate of 𝑃 𝑟 matches . Alice can convert this into a signature under for a message with hash 𝑒 ' = 𝑒 + 𝑟 𝑏 . 𝑑𝑖𝑓𝑓 Verifying this signature under 𝐵 , computing 1 𝐵 1 𝑃 becomes: 𝑃 = ( 𝑒 + 𝑟 𝑏 − 1 ) 𝑠 * 𝐺 + 𝑟 𝑠 − 1 * 𝐵 1 𝑑𝑖𝑓𝑓 − 1 = 𝑒 𝑠 * 𝐺 + 𝑟 𝑏 − 1 𝑠 − 1 𝑠 * 𝐺 + 𝑟 𝑏 1 * 𝐺 𝑑𝑖𝑓𝑓 − 1 = 𝑒 𝑠 * 𝐺 + 𝑟 𝑠 − 1 ( 𝑏 1 + 𝑏 𝑑𝑖𝑓𝑓 ) * 𝐺 − 1 = 𝑒 𝑠 * 𝐺 + 𝑟 𝑠 − 1 * 𝐵 2 This is the same relation that makes will be correct. ( 𝑟 , 𝑠 ) a valid signature on a message with hash , so 𝑒 𝑃 Note that Alice has no control over the value of 𝑒 ' would have to ﬁnd a preimage preimages is, to date, a hard problem for SHA-256 and related functions. under the given hash function. Computing , so to make an eﬀective exploit, she 𝑚 ' of 𝑒 ' Recommendations Consider root key blinding, as above. The attack relies on Alice knowing blinding prevents her from learning it. 𝑏 𝑑𝑖𝑓𝑓 , and root key Consider homogeneous key derivation, as above. Once again, depriving Alice of 𝑏 𝑑𝑖𝑓𝑓 obviates the attack completely. 
3. Mutual transactions can be completely deanonymized Severity: Medium Diﬃculty: Medium Type: Cryptography Finding ID: TOB-CTSA-3 Target: Anonymity of mutual transactions Description When Alice and Bob both make stealth payments to each other, they generate the same Shared Secret #i for transaction i, which is used to derive destination keys for Bob and Alice: Symbol Description Alice’s derivation Bob’s derivation s i B i A i Shared secret #i hash(a dh * B dh , i) hash(b dh * A dh , i) Bob’s destination key #i Alice’s destination key #i B r + s i * G A r + s i * G However, as a result, the destination keys of Bob and Alice for the same transaction number #i will always have the constant diﬀerence B i - A i = B r - A r . Exploit Scenario An attacker records all root public keys from the database, computes the pairwise diﬀerences B i - A i for every pair of users A and B they want to monitor, and stores the diﬀerences in a list. The attacker subsequently reviews all pairs of public keys associated with transactions on the blockchain, computes the diﬀerences between the public keys, and compares the x coordinates to the stored list of pairwise diﬀerences. If a match is found, the attacker knows that those transactions correspond to stealth transactions between A and B with some index i. The attacker can also determine which transaction went from A to B and vice versa by considering the y coordinates of the public keys and pairwise diﬀerences. Because the attack compromises the anonymity of pairs of users without giving access to funds, we consider this issue to have medium severity. As the attack requires both users in the pair to make transactions to each other, and as it requires a potentially signiﬁcant calculation eﬀort (proportional to the square of the number of transactions), we consider this issue to have medium diﬃculty. Recommendations There are several ways to mitigate this issue: ● ● Root key blinding, as described in the recommendations for TOB-CTSA-1 . Diversify the shared secret #i, e.g., by adding the DH key of the receiver to the hash 𝑠 𝑖 , 𝐵 ) , or to any other known 𝑑ℎ ) = 𝐻𝑎𝑠ℎ ( 𝑏 = 𝐻𝑎𝑠ℎ ( 𝑎 || 𝑖 || 𝐵 || 𝑖 || 𝐵 · 𝐵 · 𝐴 𝑑ℎ 𝑑ℎ 𝑑ℎ 𝑑ℎ 𝑑ℎ identiﬁer for the receiver (e.g., public root key B r , a unique predetermined string that is stored in the public key database). ● Homogenize the destination keys by including both the root key and the DH key of the receiver, i.e., * 𝐵 + 𝑠 = 𝐵 𝐵 𝑖 𝑟 𝑖 𝑑ℎ , with corresponding private key 𝑏 𝑖 = 𝑏 𝑟 · 𝑏 + 𝑠 𝑖 . 𝑑ℎ The advantages and disadvantages of each of these mitigation methods is discussed in detail in Appendix B . 
4. Allowing invalid public keys may enable DH private key recovery Severity: Medium Diﬃculty: High Type: Cryptography Finding ID: TOB-CTSA-4 Target: DH private key Description Consider the following three assumptions: 1. 2. 3. Alice can add points that are not on the elliptic curve to the public key database, Bob does not verify the public key points, and Bob's scalar multiplication implementation has some speciﬁc characteristics. Assumptions 1 and 2 are currently not speciﬁed in the speciﬁcation, which motivates this ﬁnding. If these assumptions hold, then Alice can recover Bob's DH key using a complicated attack, based on the CRYPTO 2000 paper by Biehl et al. and the DCC 2005 paper by Ciet et al . What follows is a rough sketch of the attack. For more details, see the reference publications, which also detail the speciﬁc characteristics for Assumption 3. Exploit Scenario Alice roughly follows the following steps: 1. Find a point 𝑃 ' which is not on the curve used for ECDH, and a. b. when used in Bob’s scalar multiplication, is eﬀectively on a diﬀerent curve 𝐸 ' 2. 3. 4. with (a subgroup of) small prime order Brute-force all possible values of addresses with shared secret 𝑥 · 𝑃 ' for 𝐻𝑎𝑠ℎ ( 𝑥 · 𝑃 ' || 0 ) the unique stealth address associated with 𝑏 𝑑ℎ · 𝑃 ' = ( 𝑏 𝑚𝑜𝑑 𝑝 ' ) · 𝑃 ' . 𝑑ℎ 𝑝 ' . 0 ≤ 𝑥 < 𝑝 ' , i.e., 𝐵 𝑥 𝑥 ' = 𝑏 𝑑ℎ , and sends funds to all + 𝐻𝑎𝑠ℎ ( 𝑥 · 𝑃 '|| 0 ) * 𝐺 = 𝐵 𝐵 . 𝑟 𝑥 𝑚𝑜𝑑 𝑝 ' . This happens because Monitor all resulting addresses associated with until Bob withdraws funds from Repeat steps 1–3 for new points ' 𝑃 𝑗 with diﬀerent small prime orders ' 𝑝 𝑗 to recover 𝑏 ' 𝑚𝑜𝑑 𝑝 . 𝑗 𝑑ℎ 5. Use the Chinese Remainder Theorem to recover 𝑏 𝑑ℎ from 𝑏 𝑑ℎ ' 𝑚𝑜𝑑 𝑝 . 𝑗 As a result, Alice can now track all stealth payments made to Bob (but cannot steal funds). To understand the complexity of this attack, it is suﬃcient for Alice to repeat steps 1–3 for the ﬁrst 44 primes (numbers between 2 and 193). This requires Alice to make 3,831 payments in total (corresponding to the sum of the ﬁrst 44 primes). There is a tradeoﬀ where Alice uses fewer primes, which means that fewer transactions are needed. However, it means that Alice does not recover the full b dh . To compensate for this, Alice can brute-force the discrete logarithm of B dh guided by the partial information on b dh . Because the attack compromises anonymity for a particular user without giving access to funds, we consider this issue to have medium severity. As this is a complicated attack with various assumptions that requires Bob to access the funds from all his stealth addresses, we consider this issue to have high diﬃculty. Recommendations The speciﬁcation should enforce that public keys are validated for correctness, both when they are added to the public database and when they are used by senders and receivers. These validations should include point-on-curve checks, small-order-subgroup checks (if applicable), and point-at-inﬁnity checks. References ● ● Diﬀerential Fault Attacks on Elliptic Curve Cryptosystems, Biehl et al., 2000 Elliptic Curve Cryptosystems in the Presence of Permanent and Transient Faults, Ciet et al., 
