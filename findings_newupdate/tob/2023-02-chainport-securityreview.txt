1. Several secrets checked into source control Severity: Medium Diﬃculty: High Type: Data Exposure Finding ID: TOB-CHPT-1 Target: The chainport-backend repository Description The chainport-backend repository contains several secrets that are checked into source control. Secrets that are stored in source control are accessible to anyone who has had access to the repository (e.g., former employees or attackers who have managed to gain access to the repository). We used TruﬄeHog to identify these secrets (by running the command trufflehog git file://. in the root directory of the repository). TruﬄeHog found several types of credentials, including the following, which were veriﬁed through TruﬄeHog’s credential veriﬁcation checks: ● GitHub personal access tokens ● Slack access tokens TruﬄeHog also found unveriﬁed GitLab authentication tokens and Polygon API credentials. Furthermore, we found hard-coded credentials, such as database credentials, in the source code, as shown in ﬁgure 1.1. [REDACTED] Figure 1.1: chainport-backend/env.prod.json#L3-L4 Exploit Scenario An attacker obtains a copy of the source code from a former DcentraLab employee. The attacker extracts the secrets from it and uses them to exploit DcentraLab’s database and insert events in the database that did not occur. Consequently, ChainPort’s AWS lambdas process the fake events and allow the attacker to steal funds. Recommendations Short term, remove credentials from source control and rotate them. Run TruﬄeHog by invoking the trufflehog git file://. command; if it identiﬁes any unveriﬁed credentials, check whether they need to be addressed. Long term, consider using a secret management solution such as Vault to store secrets. 2. Same credentials used for staging, test, and production environment databases Severity: Low Diﬃculty: High Type: Conﬁguration Finding ID: TOB-CHPT-2 Target: Database authentication Description The staging, test, and production environments' databases have the same username and password credentials. Exploit Scenario An attacker is able to obtain the password for the test environment’s database, which is less tightly secured than that of the production environment. He tries the same credentials on the production database and gains access to the database’s contents as well as the ability to write to it. He inserts fake events into the database. ChainPort’s AWS lambdas process the fake events and allow the attacker to steal funds. Recommendations Short term, rotate the current credentials and safely generate diﬀerent credentials for each environment. This will prevent attackers who have compromised credentials for one environment from accessing other environments. Long term, use a secret management solution such as Vault to store the database credentials instead of relying on conﬁguration ﬁles stored in the source code. 3. Use of error-prone pattern for logging functions Severity: Low Diﬃculty: High Type: Auditing and Logging Finding ID: TOB-CHPT-3 Target: The chainport-backend repository Description The pattern shown in ﬁgure 3.1 is used repeatedly throughout the codebase to log function names. [REDACTED] Figure 3.1: An example of the pattern used by ChainPort to log function names This pattern is prone to copy-and-paste errors. Developers may copy the code from one function to another but forget to change the function name, as exempliﬁed in ﬁgure 3.2. [REDACTED] Figure 3.2: An example of an incorrect use of the pattern used by ChainPort to log function names We wrote a Semgrep rule to detect these problems (appendix D). This rule detected 46 errors associated with this pattern in the back-end application. Figure 3.3 shows an example of one of these ﬁndings. [REDACTED] Figure 3.3: An example of one of the 46 errors resulting from the function-name logging pattern (chainport-backend/modules/web_3/helpers.py#L313-L315) Exploit Scenario A ChainPort developer is auditing the back-end application logs to determine the root cause of a bug. Because an incorrect function name was logged, the developer cannot correctly trace the application’s ﬂow and determine the root cause in a timely manner. Recommendations Short term, use the Python decorator in ﬁgure 3.4 to log function names. This will eliminate the risk of copy-and-paste errors. [REDACTED] Figure 3.4: A Python decorator that logs function names, eliminating the risk of copy-and-paste errors Long term, review the codebase for other error-prone patterns. If such patterns are found, rewrite the code in a way that eliminates or reduces the risk of errors, and write a Semgrep rule to ﬁnd the errors before the code hits production. 4. Use of hard-coded strings instead of constants Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-CHPT-4 Target: The chainport-backend repository Description The back-end code uses several hard-coded strings that could be deﬁned as constants to prevent any typos from introducing vulnerabilities. For example, the checks that determine the system’s environment compare the result of the get_env function with the strings “develop”, “staging”, “prod”, or “local”. Figure 4.1 shows an example of one of these checks. [REDACTED] Figure 4.1: chainport-backend/project/lambdas/mainchain/rebalance_monitor.py#L42-L43 We did not ﬁnd any typos in these literal strings, so we set the severity of this ﬁnding to informational. However, the use of hard-coded strings in place of constants is not best practice; we suggest ﬁxing this issue and following other best practices for writing safe code to prevent the introduction of bugs in the future. Exploit Scenario A ChainPort developer creates code that should run only in the development build and safeguards it with the check in ﬁgure 4.2. [REDACTED] Figure 4.2: An example of a check against a hard-coded string that could lead to a vulnerability This test always fails—the correct value to test should have been “develop”. Now, the poorly tested, experimental code that was meant to run only in development mode is deployed in production. Recommendations Short term, create a constant for each of the four possible environments. Then, to check the system’s environment, import the corresponding constant and use it in the comparison instead of the hard-coded string. Alternatively, use an enum instead of a string to perform these comparisons. Long term, review the code for other instances of hard-coded strings where constants could be used instead. Create Semgrep rules to ensure that developers never use hard-coded strings where constants are available. 5. Use of incorrect operator in SQLAlchemy ﬁlter Severity: Undetermined Diﬃculty: Undetermined Type: Undeﬁned Behavior Finding ID: TOB-CHPT-5 Target: chainport-backend/project/data/db/port.py#L173 Description The back-end code uses the is not operator in an SQLAlchemy query’s filter. SQLAlchemy relies on the __eq__ family of methods to apply the ﬁlter; however, the is and is not operators do not trigger these methods. Therefore, only the comparison operators (== or !=) should be used. [REDACTED] Figure 5.1: chainport-backend/project/data/db/port.py#L173 We did not review whether this ﬂaw could be used to bypass the system’s business logic, so we set the severity of this issue to undetermined. Exploit Scenario An attacker exploits this ﬂawed check to bypass the system’s business logic and steal user funds. Recommendations Short term, replace the is not operator with != in the filter indicated above. Long term, to continuously monitor the codebase for reintroductions of this issue, run the python.sqlalchemy.correctness.bad-operator-in-filter.bad-operator-in-f ilter Semgrep rule as part of the CI/CD ﬂow. References ● SQLAlchemy: Common Filter Operators ● Stack Overﬂow: Select NULL Values in SQLAlchemy 6. Several functions receive the wrong number of arguments Severity: Undetermined Diﬃculty: Undetermined Type: Undeﬁned Behavior Finding ID: TOB-CHPT-6 Target: The chainport-backend repository Description Several functions in the chainport-backend repository are called with an incorrect number of arguments: ● Several functions in the /project/deprecated_files folder ● A call to release_tokens_by_maintainer from the rebalance_bridge function (ﬁgures 6.1 and 6.2) ● A call to generate_redeem_signature from the regenerate_signature function (ﬁgures 6.3 and 6.4) ● A call to get_next_nonce_for_public_address from the prepare_erc20_transfer_transaction function (ﬁgures 6.5 and 6.6) ● A call to get_cg_token_address_list from the main function of the ﬁle (likely old debugging code) [REDACTED] Figure 6.1: The release_tokens_by_maintainer function is called with four arguments, but at least ﬁve are required. (chainport-backend/project/lambdas/mainchain/rebalance_monitor.py#L109-L1 14) [REDACTED] Figure 6.2: The deﬁnition of the release_tokens_by_maintainer function (chainport-backend/project/lambdas/release_tokens_by_maintainer.py#L27-L3 4) [REDACTED] Figure 6.3: A call to generate_redeem_signature that is missing the network_id argument (chainport-backend/project/scripts/keys_maintainers_signature/regenerate_ signature.py#L38-L43) [REDACTED] Figure 6.4: The deﬁnition of the generate_redeem_signature function (chainport-backend/project/lambdas/sidechain/events_handlers/handle_burn_ event.py#L46-L48) [REDACTED] Figure 6.5: A call to get_next_nonce_for_public_address that is missing the outer_session argument (chainport-backend/project/web3_cp/erc20/prepare_erc20_transfer_transacti on.py#L32-L34) [REDACTED] Figure 6.6: The deﬁnition of the get_next_nonce_for_public_address function (chainport-backend/project/web3_cp/nonce.py#L19-L21) [REDACTED] Figure 6.7: A call to get_cg_token_address_list that is missing all three arguments (chainport-backend/project/lambdas/token_endpoints/cg_list_get.py#L90-91) [REDACTED] Figure 6.8: The deﬁnition of the get_cg_token_address_list function (chainport-backend/project/lambdas/token_endpoints/cg_list_get.py#L37) We did not review whether this ﬂaw could be used to bypass the system’s business logic, so we set the severity of this issue to undetermined. Exploit Scenario The release_tokens_by_maintainer function is called from the rebalance_bridge function with the incorrect number of arguments. As a result, the rebalance_bridge function fails if the token balance is over the threshold limit, and the tokens are not moved to a safe address. An attacker ﬁnds another ﬂaw and is able to steal more tokens than he would have been able to if the tokens were safely stored in another account. Recommendations Short term, ﬁx the errors presented in the description of this ﬁnding by adding the missing arguments to the function calls. Long term, run pylint or a similar static analysis tool to detect these problems (and others) before the code is committed and deployed in production. This will ensure that if the list of a function’s arguments ever changes (which was likely the root cause of this problem), a call that does not match the new arguments will be ﬂagged before the code is deployed. 7. Lack of events for critical operations Severity: Informational Diﬃculty: High Type: Auditing and Logging Finding ID: TOB-CHPT-7 Target: ChainportMainBridge.sol, ChainportSideBridge.sol, Validator.sol, Description Several critical operations do not trigger events. As a result, it will be diﬃcult to review the correct behavior of the contracts once they have been deployed. For example, the setSignatoryAddress function, which is called in the Validator contract to set the signatory address, does not emit an event providing conﬁrmation of that operation to the contract’s caller (ﬁgure 7.1). [REDACTED] Figure 7.1: The setSignatoryAddress function in Validator:43-52 Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Exploit Scenario Eve, an attacker, is able to compromise a quorum of the ChainPort congress voters contract. She then sets a new signatory address. Alice, a ChainPort team member, is unaware of the change and does not raise a security incident. Recommendations Short term, add events for all critical operations that result in state changes. Events aid in contract monitoring and the detection of suspicious behavior. Long term, consider using a blockchain-monitoring system to track any suspicious behavior in the contracts. The system relies on several contracts to behave as expected. A monitoring mechanism for critical events would quickly detect any compromised system components. 8. Lack of zero address checks in setter functions Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-CHPT-8 Target: ChainportMainBridge.sol, ChainportMiddleware.sol, ChainportSideBridge.sol Description Certain setter functions fail to validate incoming arguments, so callers can accidentally set important state variables to the zero address. For example, in the initialize function of the ChainportMainBridge contract, developers can deﬁne the maintainer registry, the congress address for governance, and the signature validator and set their addresses to the zero address. [REDACTED] Figure 8.1: The initialize function of ChainportMainBridge.sol Failure to immediately reset an address that has been set to the zero address could result in unexpected behavior. Exploit Scenario Alice accidentally sets the ChainPort congress address to the zero address when initializing a new version of the ChainportMainBridge contract. The misconﬁguration causes the system to behave unexpectedly, and the system must be redeployed once the misconﬁguration is detected. Recommendations Short term, add zero-value checks to all constructor functions and for all setter arguments to ensure that users cannot accidentally set incorrect values, misconﬁguring the system. Document any arguments that are intended to be set to the zero address, highlighting the expected values of those arguments on each chain. Long term, use the Slither static analyzer to catch common issues such as this one. Consider integrating a Slither scan into the project’s CI pipeline, pre-commit hooks, or build scripts. 9. Python type annotations are missing from most functions Severity: Low Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-CHPT-9 Target: The chainport-backend repository Description The back-end code uses Python type annotations; however, their use is sporadic, and most functions are missing them. Exploit Scenario The cg_rest_call function receives the exception argument without specifying its type with a Python type annotation. The get_token_details_by_cg_id function calls cg_rest_call with an object of the incorrect type, an Exception instance instead of an Exception class, causing the program to crash (ﬁgure 9.1). [REDACTED] Figure 9.1: chainport-backend/modules/coingecko/api.py#L41-L42 Recommendations Short term, add type annotations to the arguments of every function. This will not prevent the code from crashing or causing undeﬁned behavior during runtime; however, it will allow developers to clearly see each argument’s expected type and static analyzers to better detect type mismatches. Long term, implement checks in the CI/CD pipeline to ensure that code without type annotations is not accepted. 10. Use of libraries with known vulnerabilities Severity: Low Diﬃculty: Low Type: Patching Finding ID: TOB-CHPT-10 Target: The chainport-backend repository Description The back-end repository uses outdated libraries with known vulnerabilities. We used pip-audit, a tool developed by with support from Google to audit Python environments and dependency trees for known vulnerabilities, and identiﬁed two known vulnerabilities in the project’s dependencies (as shown in ﬁgure 10.1). [REDACTED] Figure 10.1: A list of outdated libraries in the back-end repository Recommendations Short term, update the project’s dependencies to their latest versions wherever possible. Use pip-audit to conﬁrm that no vulnerable dependencies remain. Long term, add pip-audit to the project’s CI/CD pipeline. Do not allow builds to succeed with dependencies that have known vulnerabilities. 11. Use of JavaScript instead of TypeScript Severity: Low Diﬃculty: Low Type: Conﬁguration Finding ID: TOB-CHPT-11 Target: The chainport-app repository Description The ChainPort front end is developed with JavaScript instead of TypeScript. TypeScript is a strongly typed language that compiles to JavaScript. It allows developers to specify the types of variables and function arguments, and TypeScript code will fail to compile if there are type mismatches. Contrarily, JavaScript code will crash (or worse) during runtime if there are type mismatches. In summary, TypeScript is preferred over JavaScript for the following reasons: ● It improves code readability; developers can easily identify variable types and the types that functions receive. ● It improves security by providing static type checking that catches errors during compilation. ● It improves support for integrated development environments (IDEs) and other tools by allowing them to reason about the types of variables. Exploit Scenario A bug in the front-end application is missed, and the code is deployed in production. The bug causes the application to crash, preventing users from using it. This bug would have been caught if the front-end application were written in TypeScript. Recommendations Short term, rewrite newer parts of the application in TypeScript. TypeScript can be used side-by-side with JavaScript in the same application, allowing it to be introduced gradually. Long term, gradually rewrite the whole application in TypeScript. 12. Use of .format to create SQL queries Severity: Informational Diﬃculty: Medium Type: Data Validation Finding ID: TOB-CHPT-12 Target: [REDACTED] Description The back end builds SQL queries with the .format function. An attacker that controls one of the variables that the function is formatting will be able to inject SQL code to steal information or damage the database. [REDACTED] Figure 12.1: chainport-backend/project/data/db/postgres.py#L4-L24 [REDACTED] Figure 12.2: chainport-backend/project/lambdas/database_monitor/clear_lock.py#L29-L31 None of the ﬁelds described above are attacker-controlled, so we set the severity of this ﬁnding to informational. However, the use of .format to create SQL queries is an anti-pattern; parameterized queries should be used instead. Exploit Scenario A developer copies the vulnerable code to create a new SQL query. This query receives an attacker-controlled string. The attacker conducts a time-based SQL injection attack, leaking the whole database. Recommendations Short term, use parameterized queries instead of building strings with variables by hand. Long term, create or use a static analysis check that forbids this pattern. This will ensure that this pattern is never reintroduced by a less security-aware developer. 13. Many rules are disabled in the ESLint conﬁguration Severity: Informational Diﬃculty: High Type: Testing Finding ID: TOB-CHPT-13 Target: chainport-app/.eslintrc.js Description There are 34 rules disabled in the front-end eslint conﬁguration. Disabling some of these rules does not cause problems, but disabling others reduces the code’s security and reliability (e.g., react/no-unescaped-entities, consistent-return, no-shadow) and the code’s readability (e.g., react/jsx-boolean-value, react/jsx-one-expression-per-line). Furthermore, the code contains 46 inline eslint-disable comments to disable speciﬁc rules. While disabling some of these rules in this way may be valid, we recommend adding a comment to each instance explaining why the speciﬁc rule was disabled. Recommendations Short term, create a list of rules that can be safely disabled without reducing the code’s security or readability, document the justiﬁcation, and enable every other rule. Fix any ﬁndings that these rules may report. For rules that are disabled with inline eslint-disable comments, include explanatory comments justifying why they are disabled. 14. Congress can lose quorum after manually setting the quorum value Severity: Medium Diﬃculty: High Type: Conﬁguration Finding ID: TOB-CHPT-14 Target: contracts/governance/ChainportCongressMembersRegistry.sol Description Proposals to the ChainPort congress must be approved by a minimum quorum of members before they can be executed. By default, when a new member is added to the congress, the quorum is updated to be N − 1, where N is the number of congress members. [REDACTED] Figure 14.1: smart-contracts/contracts/governance/ChainportCongressMembersRegistry.so l#L98-L119 However, the congress has the ability to overwrite the quorum number to any nonzero number, including values larger than the current membership. [REDACTED] Figure 14.2: smart-contracts//contracts/governance/ChainportCongressMembersRegistry.s ol#L69-L77 If the congress manually lowers the quorum number and later adds a member, the quorum number will be reset to one less than the total membership. If for some reason certain members are temporarily or permanently unavailable (e.g., they are on vacation or their private keys were destroyed), the minimum quorum would not be reached. Exploit Scenario The ChainPort congress is composed of 10 members. Alice submits a proposal to reduce the minimum quorum to six members to ensure continuity while several members take vacations over a period of several months. During this period, a proposal to add Bob as a new member of the ChainPort congress is passed while Carol and Dave, two other congress members, are on vacation. This unexpectedly resets the minimum quorum to 10 members of the 11-person congress, preventing new proposals from being passed. Recommendations Short term, rewrite the code so that, when a new member is added to the congress, the minimum quorum number increases by one rather than being updated to the current number of congress members subtracted by one. Add a cap to the minimum quorum number to prevent it from being manually set to values larger than the current membership of the congress. Long term, uncouple operations for increasing and decreasing quorum values from operations for making congress membership changes. Instead, require that such operations be included as additional actions in proposals for membership changes. 15. Potential race condition could allow users to bypass PORTX fee payments Severity: Low Type: Timing Diﬃculty: Medium Finding ID: TOB-CHPT-15 Target: contracts/ChainportFeeManager.sol Description ChainPort fees are paid either as a 0.3% fee deducted from the amount transferred or as a 0.2% fee in PORTX tokens that the user has deposited into the ChainportFeeManager contract. To determine whether a fee should be paid in the base token or in PORTX, the back end checks whether the user has a suﬃcient PORTX balance in the ChainportFeeManager contract. [REDACTED] Figure 15.1: chainport-backend//project/lambdas/fees/fees.py#L219-249 However, the ChainportFeeManager contract does not enforce an unbonding period, a period of time before users can unstake their PORTX tokens. [REDACTED] Figure 15.2: smart-contracts/contracts/ChainportFeeManager.sol#L113-L125 Since pending fee payments are generated as part of deposit, transfer, and burn events but the actual processing is handled by a separate monitor, it could be possible for a user to withdraw her PORTX tokens on-chain after the deposit event has been processed and before the fee payment transaction is conﬁrmed, allowing her to avoid paying a fee for the transfer. Exploit Scenario Alice uses ChainPort to bridge one million USDC from the Ethereum mainnet to Polygon. She has enough PORTX deposited in the ChainportFeeManager contract to cover the $2,000 fee. She watches for the pending fee payment transaction and front-runs it to remove her PORTX from the ChainportFeeManager contract. Her transfer succeeds, but she is not required to pay the fee. Recommendations Short term, add an unbonding period preventing users from unstaking PORTX before the period has passed. Long term, ensure that deposit, transfer, and redemption operations are executed atomically with their corresponding fee payments. 16. Signature-related code lacks a proper speciﬁcation and documentation Severity: Medium Diﬃculty: High Type: Cryptography Finding ID: TOB-CHPT-16 Target: Signature-related code Description ChainPort uses signatures to ensure that messages to mint and release tokens were generated by the back end. These signatures are not well documented, and the properties they attempt to provide are often unclear. For example, answers to the following questions are not obvious; we provide example answers that could be provided in the documentation of ChainPort’s use of signatures: ● Why does the signed message contain a networkId ﬁeld, and why does it have to be unique? If not, an operation to mint tokens on one chain could be replayed on another chain. ● Why does the signed message contain an action ﬁeld? The action ﬁeld prevents replay attacks in networks that have both a main and side bridge. Without this ﬁeld, a signature for minting tokens could be used on a sidechain contract of the same network to release tokens. ● Why are both the signature and nonce checked for uniqueness in the contracts? The signatures could be represented in more than one format, which means that storing them is not enough to ensure uniqueness. Recommendations Short term, create a speciﬁcation describing what the signatures protect against, what properties they attempt to provide (e.g., integrity, non-repudiation), and how these properties are provided. 17. Cryptographic primitives lack sanity checks and clear function names Severity: Informational Diﬃculty: High Type: Cryptography Finding ID: TOB-CHPT-17 Target: chainport-backend/modules/cryptography_2key/signatures.py Description Several cryptographic primitives are missing sanity checks on their inputs. Without such checks, problems could occur if the primitives are used incorrectly. The remove_0x function (ﬁgure 17.1) does not check that the input starts with 0x. A similar function in the eth-utils library has a more robust implementation, as it includes a check on its input (ﬁgure 17.2). [REDACTED] Figure 17.1: chainport-backend/modules/cryptography_2key/signatures.py#L10-L16 [REDACTED] Figure 17.2: ethereum/eth-utils/eth_utils/hexadecimal.py#L43-L46 The add_leading_0 function's name does not indicate that the value is padded to a length of 64 (ﬁgure 17.3). [REDACTED] Figure 17.3: chainport-backend/modules/cryptography_2key/signatures.py#L19-L25 The _build_withdraw_message function does not ensure that the beneficiary_address and token_address inputs have the expected length of 66 bytes and that they start with 0x (ﬁgure 17.4). [REDACTED] Figure 17.4: chainport-backend/modules/cryptography_2key/signatures.py#L28-62 We did not identify problems in the way these primitives are currently used in the code, so we set the severity of this ﬁnding to informational. However, if the primitives are used improperly in the future, cryptographic bugs that can have severe consequences could be introduced, which is why we highly recommend ﬁxing the issues described in this ﬁnding. Exploit Scenario A developer fails to understand the purpose of a function or receives an input from outside the system that has an unexpected format. Because the functions lack sanity checks, the code fails to do what the developer expected. This leads to a cryptographic vulnerability and the loss of funds. Recommendations Short term, add the missing checks and ﬁx the naming issues described above. Where possible, use well-reviewed libraries rather than implementing cryptographic primitives in-house. Long term, review all the cryptographic primitives used in the codebase to ensure that the functions’ purposes are clear and that functions perform sanity checks, preventing them from being used improperly. Where necessary, add comments to describe the functions’ purposes. 18. Use of requests without the timeout argument Severity: Low Diﬃculty: High Type: Denial of Service Finding ID: TOB-CHPT-18 Target: The chainport-backend repository Description The Python requests library is used in the ChainPort back end without the timeout argument. By default, the requests library will wait until the connection is closed before fulﬁlling a request. Without the timeout argument, the program will hang indeﬁnitely. The following locations in the back-end code are missing the timeout argument: ● chainport-backend/modules/coingecko/api.py#L29 ● chainport-backend/modules/requests_2key/requests.py#L14 ● chainport-backend/project/stats/cg_prices.py#L74 ● chainport-backend/project/stats/cg_prices.py#L95 The code in these locations makes requests to the following websites: ● https://api.coingecko.com ● https://ethgasstation.info ● https://gasstation-mainnet.matic.network If any of these websites hang indeﬁnitely, so will the back-end code. Exploit Scenario One of the requested websites hangs indeﬁnitely. This causes the back end to hang, and token ports from other users cannot be processed. Recommendations Short term, add the timeout argument to each of the code locations indicated above. This will ensure that the code will not hang if the website being requested hangs. Long term, integrate Semgrep into the CI pipeline to ensure that uses of the requests library always have the timeout argument. 19. Lack of noopener attribute on external links Severity: Low Diﬃculty: High Type: Conﬁguration Finding ID: TOB-CHPT-19 Target: chainport-app/src/modules/exchange/components/PortOutModal.jsx Description In the ChainPort front-end application, there are links to external websites that have the target attribute set to _blank but lack the noopener attribute. Without this attribute, an attacker could perform a reverse tabnabbing attack. [REDACTED] Figure 19.1: chainport-app/src/modules/exchange/components/PortOutModal.jsx#L126 Exploit Scenario An attacker takes control of one of the external domains linked by the front end. The attacker prepares a malicious script on the domain that uses the window.opener variable to control the parent window’s location. A user clicks on the link in the ChainPort front end. The malicious website is opened in a new window, and the original ChainPort front end is seamlessly replaced by a phishing website. The victim then returns to a page that appears to be the original ChainPort front end but is actually a web page controlled by the attacker. The attacker tricks the user into transferring his funds to the attacker. Recommendations Short term, add the missing rel="noopener noreferrer" attribute to the anchor tags. References ● OWASP: Reverse tabnabbing attacks 20. Use of urllib could allow users to leak local ﬁles Severity: Undetermined Diﬃculty: High Type: Data Exposure Finding ID: TOB-CHPT-20 Target: chainport-backend/modules/infrastructure/aws/s3.py Description To upload images of new tokens to S3, the upload_media_from_url_to_s3 function uses the urllib library (ﬁgure 20.1), which supports the file:// scheme; therefore, if a malicious actor controls a dynamic value uploaded to S3, she could read arbitrary local ﬁles. [REDACTED] Figure 20.1: chainport-backend/modules/infrastructure/aws/s3.py#L25-29 The code in ﬁgure 20.2 replicates this issue. [REDACTED] Figure 20.2: Code to test urlopen’s support of the file:// scheme We set the severity of this ﬁnding to undetermined because it is unclear whether an attacker (e.g., a token owner) would have control over token images uploaded to S3 and whether the server holds ﬁles that an attacker would want to extract. Exploit Scenario A token owner makes the image of his token point to a local ﬁle (e.g., file:///etc/passwd). This local ﬁle is uploaded to the S3 bucket and is shown to an attacker attempting to port his own token into the ChainPort front end. The local ﬁle is leaked to the attacker. Recommendations Short term, use the requests library instead of urllib. The requests library does not support the file:// scheme. 21. The front end is vulnerable to iFraming Severity: Low Diﬃculty: High Type: Conﬁguration Finding ID: TOB-CHPT-21 Target: The chainport-app repository Description The ChainPort front end does not prevent other websites from iFraming it. Figure 21.1 shows an example of how another website could iFrame the ChainPort front end. [REDACTED] Figure 21.1: An example of how another website could iFrame the ChainPort front end Exploit Scenario An attacker creates a website that iFrames ChainPort’s front end. The attacker performs a clickjacking attack to trick users into submitting malicious transactions. Recommendations Short term, add the X-Frame-Options: DENY header on every server response. This will prevent other websites from iFraming the ChainPort front end. 22. Lack of CSP header in the ChainPort front end Severity: Low Diﬃculty: High Type: Conﬁguration Finding ID: TOB-CHPT-22 Target: The chainport-app repository Description The ChainPort front end lacks a Content Security Policy (CSP) header, leaving it vulnerable to cross-site scripting (XSS) attacks. A CSP header adds extra protection against XSS and data injection attacks by enabling developers to select the sources that the browser can execute or render code from. This safeguard requires the use of the CSP HTTP header and appropriate directives in every server response. Exploit Scenario An attacker ﬁnds an XSS vulnerability in the ChainPort front end and crafts a custom XSS payload. Because of the lack of a CSP header, the browser executes the attack, enabling the attacker to trick users into transferring their funds to him. Recommendations Short term, use a CSP header in the ChainPort front end and validate it with the CSP Evaluator. This will help mitigate the eﬀects of XSS attacks. Long term, track the development of the CSP header and similar web browser features that help mitigate security risks. Ensure that new protections are adopted as quickly as possible. References ● HTTP Content Security Policy (CSP) ● Google CSP Evaluator ● Google Web Security Fundamentals: Eval ● Google Web Security Fundamentals: Inline code is considered harmful
3. Use of error-prone pattern for logging functions Severity: Low Diﬃculty: High Type: Auditing and Logging Finding ID: TOB-CHPT-3 Target: The chainport-backend repository Description The pattern shown in ﬁgure 3.1 is used repeatedly throughout the codebase to log function names. [REDACTED] Figure 3.1: An example of the pattern used by ChainPort to log function names This pattern is prone to copy-and-paste errors. Developers may copy the code from one function to another but forget to change the function name, as exempliﬁed in ﬁgure 3.2. [REDACTED] Figure 3.2: An example of an incorrect use of the pattern used by ChainPort to log function names We wrote a Semgrep rule to detect these problems (appendix D). This rule detected 46 errors associated with this pattern in the back-end application. Figure 3.3 shows an example of one of these ﬁndings. [REDACTED] Figure 3.3: An example of one of the 46 errors resulting from the function-name logging pattern (chainport-backend/modules/web_3/helpers.py#L313-L315) Exploit Scenario A ChainPort developer is auditing the back-end application logs to determine the root cause of a bug. Because an incorrect function name was logged, the developer cannot correctly trace the application’s ﬂow and determine the root cause in a timely manner. Recommendations Short term, use the Python decorator in ﬁgure 3.4 to log function names. This will eliminate the risk of copy-and-paste errors. [REDACTED] Figure 3.4: A Python decorator that logs function names, eliminating the risk of copy-and-paste errors Long term, review the codebase for other error-prone patterns. If such patterns are found, rewrite the code in a way that eliminates or reduces the risk of errors, and write a Semgrep rule to ﬁnd the errors before the code hits production. 
4. Use of hard-coded strings instead of constants Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-CHPT-4 Target: The chainport-backend repository Description The back-end code uses several hard-coded strings that could be deﬁned as constants to prevent any typos from introducing vulnerabilities. For example, the checks that determine the system’s environment compare the result of the get_env function with the strings “develop”, “staging”, “prod”, or “local”. Figure 4.1 shows an example of one of these checks. [REDACTED] Figure 4.1: chainport-backend/project/lambdas/mainchain/rebalance_monitor.py#L42-L43 We did not ﬁnd any typos in these literal strings, so we set the severity of this ﬁnding to informational. However, the use of hard-coded strings in place of constants is not best practice; we suggest ﬁxing this issue and following other best practices for writing safe code to prevent the introduction of bugs in the future. Exploit Scenario A ChainPort developer creates code that should run only in the development build and safeguards it with the check in ﬁgure 4.2. [REDACTED] Figure 4.2: An example of a check against a hard-coded string that could lead to a vulnerability This test always fails—the correct value to test should have been “develop”. Now, the poorly tested, experimental code that was meant to run only in development mode is deployed in production. Recommendations Short term, create a constant for each of the four possible environments. Then, to check the system’s environment, import the corresponding constant and use it in the comparison instead of the hard-coded string. Alternatively, use an enum instead of a string to perform these comparisons. Long term, review the code for other instances of hard-coded strings where constants could be used instead. Create Semgrep rules to ensure that developers never use hard-coded strings where constants are available. 
5. Use of incorrect operator in SQLAlchemy ﬁlter Severity: Undetermined Diﬃculty: Undetermined Type: Undeﬁned Behavior Finding ID: TOB-CHPT-5 Target: chainport-backend/project/data/db/port.py#L173 Description The back-end code uses the is not operator in an SQLAlchemy query’s filter. SQLAlchemy relies on the __eq__ family of methods to apply the ﬁlter; however, the is and is not operators do not trigger these methods. Therefore, only the comparison operators (== or !=) should be used. [REDACTED] Figure 5.1: chainport-backend/project/data/db/port.py#L173 We did not review whether this ﬂaw could be used to bypass the system’s business logic, so we set the severity of this issue to undetermined. Exploit Scenario An attacker exploits this ﬂawed check to bypass the system’s business logic and steal user funds. Recommendations Short term, replace the is not operator with != in the filter indicated above. Long term, to continuously monitor the codebase for reintroductions of this issue, run the python.sqlalchemy.correctness.bad-operator-in-filter.bad-operator-in-f ilter Semgrep rule as part of the CI/CD ﬂow. References ● SQLAlchemy: Common Filter Operators ● Stack Overﬂow: Select NULL Values in SQLAlchemy 
6. Several functions receive the wrong number of arguments Severity: Undetermined Diﬃculty: Undetermined Type: Undeﬁned Behavior Finding ID: TOB-CHPT-6 Target: The chainport-backend repository Description Several functions in the chainport-backend repository are called with an incorrect number of arguments: ● Several functions in the /project/deprecated_files folder ● A call to release_tokens_by_maintainer from the rebalance_bridge function (ﬁgures 6.1 and 6.2) ● A call to generate_redeem_signature from the regenerate_signature function (ﬁgures 6.3 and 6.4) ● A call to get_next_nonce_for_public_address from the prepare_erc20_transfer_transaction function (ﬁgures 6.5 and 6.6) ● A call to get_cg_token_address_list from the main function of the ﬁle (likely old debugging code) [REDACTED] Figure 6.1: The release_tokens_by_maintainer function is called with four arguments, but at least ﬁve are required. (chainport-backend/project/lambdas/mainchain/rebalance_monitor.py#L109-L1 14) [REDACTED] Figure 6.2: The deﬁnition of the release_tokens_by_maintainer function (chainport-backend/project/lambdas/release_tokens_by_maintainer.py#L27-L3 4) [REDACTED] Figure 6.3: A call to generate_redeem_signature that is missing the network_id argument (chainport-backend/project/scripts/keys_maintainers_signature/regenerate_ signature.py#L38-L43) [REDACTED] Figure 6.4: The deﬁnition of the generate_redeem_signature function (chainport-backend/project/lambdas/sidechain/events_handlers/handle_burn_ event.py#L46-L48) [REDACTED] Figure 6.5: A call to get_next_nonce_for_public_address that is missing the outer_session argument (chainport-backend/project/web3_cp/erc20/prepare_erc20_transfer_transacti on.py#L32-L34) [REDACTED] Figure 6.6: The deﬁnition of the get_next_nonce_for_public_address function (chainport-backend/project/web3_cp/nonce.py#L19-L21) [REDACTED] Figure 6.7: A call to get_cg_token_address_list that is missing all three arguments (chainport-backend/project/lambdas/token_endpoints/cg_list_get.py#L90-91) [REDACTED] Figure 6.8: The deﬁnition of the get_cg_token_address_list function (chainport-backend/project/lambdas/token_endpoints/cg_list_get.py#L37) We did not review whether this ﬂaw could be used to bypass the system’s business logic, so we set the severity of this issue to undetermined. Exploit Scenario The release_tokens_by_maintainer function is called from the rebalance_bridge function with the incorrect number of arguments. As a result, the rebalance_bridge function fails if the token balance is over the threshold limit, and the tokens are not moved to a safe address. An attacker ﬁnds another ﬂaw and is able to steal more tokens than he would have been able to if the tokens were safely stored in another account. Recommendations Short term, ﬁx the errors presented in the description of this ﬁnding by adding the missing arguments to the function calls. Long term, run pylint or a similar static analysis tool to detect these problems (and others) before the code is committed and deployed in production. This will ensure that if the list of a function’s arguments ever changes (which was likely the root cause of this problem), a call that does not match the new arguments will be ﬂagged before the code is deployed. 
7. Lack of events for critical operations Severity: Informational Diﬃculty: High Type: Auditing and Logging Finding ID: TOB-CHPT-7 Target: ChainportMainBridge.sol, ChainportSideBridge.sol, Validator.sol, Description Several critical operations do not trigger events. As a result, it will be diﬃcult to review the correct behavior of the contracts once they have been deployed. For example, the setSignatoryAddress function, which is called in the Validator contract to set the signatory address, does not emit an event providing conﬁrmation of that operation to the contract’s caller (ﬁgure 7.1). [REDACTED] Figure 7.1: The setSignatoryAddress function in Validator:43-52 Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Exploit Scenario Eve, an attacker, is able to compromise a quorum of the ChainPort congress voters contract. She then sets a new signatory address. Alice, a ChainPort team member, is unaware of the change and does not raise a security incident. Recommendations Short term, add events for all critical operations that result in state changes. Events aid in contract monitoring and the detection of suspicious behavior. Long term, consider using a blockchain-monitoring system to track any suspicious behavior in the contracts. The system relies on several contracts to behave as expected. A monitoring mechanism for critical events would quickly detect any compromised system components. 
8. Lack of zero address checks in setter functions Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-CHPT-8 Target: ChainportMainBridge.sol, ChainportMiddleware.sol, ChainportSideBridge.sol Description Certain setter functions fail to validate incoming arguments, so callers can accidentally set important state variables to the zero address. For example, in the initialize function of the ChainportMainBridge contract, developers can deﬁne the maintainer registry, the congress address for governance, and the signature validator and set their addresses to the zero address. [REDACTED] Figure 8.1: The initialize function of ChainportMainBridge.sol Failure to immediately reset an address that has been set to the zero address could result in unexpected behavior. Exploit Scenario Alice accidentally sets the ChainPort congress address to the zero address when initializing a new version of the ChainportMainBridge contract. The misconﬁguration causes the system to behave unexpectedly, and the system must be redeployed once the misconﬁguration is detected. Recommendations Short term, add zero-value checks to all constructor functions and for all setter arguments to ensure that users cannot accidentally set incorrect values, misconﬁguring the system. Document any arguments that are intended to be set to the zero address, highlighting the expected values of those arguments on each chain. Long term, use the Slither static analyzer to catch common issues such as this one. Consider integrating a Slither scan into the project’s CI pipeline, pre-commit hooks, or build scripts. 
9. Python type annotations are missing from most functions Severity: Low Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-CHPT-9 Target: The chainport-backend repository Description The back-end code uses Python type annotations; however, their use is sporadic, and most functions are missing them. Exploit Scenario The cg_rest_call function receives the exception argument without specifying its type with a Python type annotation. The get_token_details_by_cg_id function calls cg_rest_call with an object of the incorrect type, an Exception instance instead of an Exception class, causing the program to crash (ﬁgure 9.1). [REDACTED] Figure 9.1: chainport-backend/modules/coingecko/api.py#L41-L42 Recommendations Short term, add type annotations to the arguments of every function. This will not prevent the code from crashing or causing undeﬁned behavior during runtime; however, it will allow developers to clearly see each argument’s expected type and static analyzers to better detect type mismatches. Long term, implement checks in the CI/CD pipeline to ensure that code without type annotations is not accepted. 
10. Use of libraries with known vulnerabilities Severity: Low Diﬃculty: Low Type: Patching Finding ID: TOB-CHPT-10 Target: The chainport-backend repository Description The back-end repository uses outdated libraries with known vulnerabilities. We used pip-audit, a tool developed by with support from Google to audit Python environments and dependency trees for known vulnerabilities, and identiﬁed two known vulnerabilities in the project’s dependencies (as shown in ﬁgure 10.1). [REDACTED] Figure 10.1: A list of outdated libraries in the back-end repository Recommendations Short term, update the project’s dependencies to their latest versions wherever possible. Use pip-audit to conﬁrm that no vulnerable dependencies remain. Long term, add pip-audit to the project’s CI/CD pipeline. Do not allow builds to succeed with dependencies that have known vulnerabilities. 
11. Use of JavaScript instead of TypeScript Severity: Low Diﬃculty: Low Type: Conﬁguration Finding ID: TOB-CHPT-11 Target: The chainport-app repository Description The ChainPort front end is developed with JavaScript instead of TypeScript. TypeScript is a strongly typed language that compiles to JavaScript. It allows developers to specify the types of variables and function arguments, and TypeScript code will fail to compile if there are type mismatches. Contrarily, JavaScript code will crash (or worse) during runtime if there are type mismatches. In summary, TypeScript is preferred over JavaScript for the following reasons: ● It improves code readability; developers can easily identify variable types and the types that functions receive. ● It improves security by providing static type checking that catches errors during compilation. ● It improves support for integrated development environments (IDEs) and other tools by allowing them to reason about the types of variables. Exploit Scenario A bug in the front-end application is missed, and the code is deployed in production. The bug causes the application to crash, preventing users from using it. This bug would have been caught if the front-end application were written in TypeScript. Recommendations Short term, rewrite newer parts of the application in TypeScript. TypeScript can be used side-by-side with JavaScript in the same application, allowing it to be introduced gradually. Long term, gradually rewrite the whole application in TypeScript. 
12. Use of .format to create SQL queries Severity: Informational Diﬃculty: Medium Type: Data Validation Finding ID: TOB-CHPT-12 Target: [REDACTED] Description The back end builds SQL queries with the .format function. An attacker that controls one of the variables that the function is formatting will be able to inject SQL code to steal information or damage the database. [REDACTED] Figure 12.1: chainport-backend/project/data/db/postgres.py#L4-L24 [REDACTED] Figure 12.2: chainport-backend/project/lambdas/database_monitor/clear_lock.py#L29-L31 None of the ﬁelds described above are attacker-controlled, so we set the severity of this ﬁnding to informational. However, the use of .format to create SQL queries is an anti-pattern; parameterized queries should be used instead. Exploit Scenario A developer copies the vulnerable code to create a new SQL query. This query receives an attacker-controlled string. The attacker conducts a time-based SQL injection attack, leaking the whole database. Recommendations Short term, use parameterized queries instead of building strings with variables by hand. Long term, create or use a static analysis check that forbids this pattern. This will ensure that this pattern is never reintroduced by a less security-aware developer. 
13. Many rules are disabled in the ESLint conﬁguration Severity: Informational Diﬃculty: High Type: Testing Finding ID: TOB-CHPT-13 Target: chainport-app/.eslintrc.js Description There are 34 rules disabled in the front-end eslint conﬁguration. Disabling some of these rules does not cause problems, but disabling others reduces the code’s security and reliability (e.g., react/no-unescaped-entities, consistent-return, no-shadow) and the code’s readability (e.g., react/jsx-boolean-value, react/jsx-one-expression-per-line). Furthermore, the code contains 46 inline eslint-disable comments to disable speciﬁc rules. While disabling some of these rules in this way may be valid, we recommend adding a comment to each instance explaining why the speciﬁc rule was disabled. Recommendations Short term, create a list of rules that can be safely disabled without reducing the code’s security or readability, document the justiﬁcation, and enable every other rule. Fix any ﬁndings that these rules may report. For rules that are disabled with inline eslint-disable comments, include explanatory comments justifying why they are disabled. 
14. Congress can lose quorum after manually setting the quorum value Severity: Medium Diﬃculty: High Type: Conﬁguration Finding ID: TOB-CHPT-14 Target: contracts/governance/ChainportCongressMembersRegistry.sol Description Proposals to the ChainPort congress must be approved by a minimum quorum of members before they can be executed. By default, when a new member is added to the congress, the quorum is updated to be N − 1, where N is the number of congress members. [REDACTED] Figure 14.1: smart-contracts/contracts/governance/ChainportCongressMembersRegistry.so l#L98-L119 However, the congress has the ability to overwrite the quorum number to any nonzero number, including values larger than the current membership. [REDACTED] Figure 14.2: smart-contracts//contracts/governance/ChainportCongressMembersRegistry.s ol#L69-L77 If the congress manually lowers the quorum number and later adds a member, the quorum number will be reset to one less than the total membership. If for some reason certain members are temporarily or permanently unavailable (e.g., they are on vacation or their private keys were destroyed), the minimum quorum would not be reached. Exploit Scenario The ChainPort congress is composed of 10 members. Alice submits a proposal to reduce the minimum quorum to six members to ensure continuity while several members take vacations over a period of several months. During this period, a proposal to add Bob as a new member of the ChainPort congress is passed while Carol and Dave, two other congress members, are on vacation. This unexpectedly resets the minimum quorum to 10 members of the 11-person congress, preventing new proposals from being passed. Recommendations Short term, rewrite the code so that, when a new member is added to the congress, the minimum quorum number increases by one rather than being updated to the current number of congress members subtracted by one. Add a cap to the minimum quorum number to prevent it from being manually set to values larger than the current membership of the congress. Long term, uncouple operations for increasing and decreasing quorum values from operations for making congress membership changes. Instead, require that such operations be included as additional actions in proposals for membership changes. 
15. Potential race condition could allow users to bypass PORTX fee payments Severity: Low Type: Timing Diﬃculty: Medium Finding ID: TOB-CHPT-15 Target: contracts/ChainportFeeManager.sol Description ChainPort fees are paid either as a 0.3% fee deducted from the amount transferred or as a 0.2% fee in PORTX tokens that the user has deposited into the ChainportFeeManager contract. To determine whether a fee should be paid in the base token or in PORTX, the back end checks whether the user has a suﬃcient PORTX balance in the ChainportFeeManager contract. [REDACTED] Figure 15.1: chainport-backend//project/lambdas/fees/fees.py#L219-249 However, the ChainportFeeManager contract does not enforce an unbonding period, a period of time before users can unstake their PORTX tokens. [REDACTED] Figure 15.2: smart-contracts/contracts/ChainportFeeManager.sol#L113-L125 Since pending fee payments are generated as part of deposit, transfer, and burn events but the actual processing is handled by a separate monitor, it could be possible for a user to withdraw her PORTX tokens on-chain after the deposit event has been processed and before the fee payment transaction is conﬁrmed, allowing her to avoid paying a fee for the transfer. Exploit Scenario Alice uses ChainPort to bridge one million USDC from the Ethereum mainnet to Polygon. She has enough PORTX deposited in the ChainportFeeManager contract to cover the $2,000 fee. She watches for the pending fee payment transaction and front-runs it to remove her PORTX from the ChainportFeeManager contract. Her transfer succeeds, but she is not required to pay the fee. Recommendations Short term, add an unbonding period preventing users from unstaking PORTX before the period has passed. Long term, ensure that deposit, transfer, and redemption operations are executed atomically with their corresponding fee payments. 
16. Signature-related code lacks a proper speciﬁcation and documentation Severity: Medium Diﬃculty: High Type: Cryptography Finding ID: TOB-CHPT-16 Target: Signature-related code Description ChainPort uses signatures to ensure that messages to mint and release tokens were generated by the back end. These signatures are not well documented, and the properties they attempt to provide are often unclear. For example, answers to the following questions are not obvious; we provide example answers that could be provided in the documentation of ChainPort’s use of signatures: ● Why does the signed message contain a networkId ﬁeld, and why does it have to be unique? If not, an operation to mint tokens on one chain could be replayed on another chain. ● Why does the signed message contain an action ﬁeld? The action ﬁeld prevents replay attacks in networks that have both a main and side bridge. Without this ﬁeld, a signature for minting tokens could be used on a sidechain contract of the same network to release tokens. ● Why are both the signature and nonce checked for uniqueness in the contracts? The signatures could be represented in more than one format, which means that storing them is not enough to ensure uniqueness. Recommendations Short term, create a speciﬁcation describing what the signatures protect against, what properties they attempt to provide (e.g., integrity, non-repudiation), and how these properties are provided. 
17. Cryptographic primitives lack sanity checks and clear function names Severity: Informational Diﬃculty: High Type: Cryptography Finding ID: TOB-CHPT-17 Target: chainport-backend/modules/cryptography_2key/signatures.py Description Several cryptographic primitives are missing sanity checks on their inputs. Without such checks, problems could occur if the primitives are used incorrectly. The remove_0x function (ﬁgure 17.1) does not check that the input starts with 0x. A similar function in the eth-utils library has a more robust implementation, as it includes a check on its input (ﬁgure 17.2). [REDACTED] Figure 17.1: chainport-backend/modules/cryptography_2key/signatures.py#L10-L16 [REDACTED] Figure 17.2: ethereum/eth-utils/eth_utils/hexadecimal.py#L43-L46 The add_leading_0 function's name does not indicate that the value is padded to a length of 64 (ﬁgure 17.3). [REDACTED] Figure 17.3: chainport-backend/modules/cryptography_2key/signatures.py#L19-L25 The _build_withdraw_message function does not ensure that the beneficiary_address and token_address inputs have the expected length of 66 bytes and that they start with 0x (ﬁgure 17.4). [REDACTED] Figure 17.4: chainport-backend/modules/cryptography_2key/signatures.py#L28-62 We did not identify problems in the way these primitives are currently used in the code, so we set the severity of this ﬁnding to informational. However, if the primitives are used improperly in the future, cryptographic bugs that can have severe consequences could be introduced, which is why we highly recommend ﬁxing the issues described in this ﬁnding. Exploit Scenario A developer fails to understand the purpose of a function or receives an input from outside the system that has an unexpected format. Because the functions lack sanity checks, the code fails to do what the developer expected. This leads to a cryptographic vulnerability and the loss of funds. Recommendations Short term, add the missing checks and ﬁx the naming issues described above. Where possible, use well-reviewed libraries rather than implementing cryptographic primitives in-house. Long term, review all the cryptographic primitives used in the codebase to ensure that the functions’ purposes are clear and that functions perform sanity checks, preventing them from being used improperly. Where necessary, add comments to describe the functions’ purposes. 
18. Use of requests without the timeout argument Severity: Low Diﬃculty: High Type: Denial of Service Finding ID: TOB-CHPT-18 Target: The chainport-backend repository Description The Python requests library is used in the ChainPort back end without the timeout argument. By default, the requests library will wait until the connection is closed before fulﬁlling a request. Without the timeout argument, the program will hang indeﬁnitely. The following locations in the back-end code are missing the timeout argument: ● chainport-backend/modules/coingecko/api.py#L29 ● chainport-backend/modules/requests_2key/requests.py#L14 ● chainport-backend/project/stats/cg_prices.py#L74 ● chainport-backend/project/stats/cg_prices.py#L95 The code in these locations makes requests to the following websites: ● https://api.coingecko.com ● https://ethgasstation.info ● https://gasstation-mainnet.matic.network If any of these websites hang indeﬁnitely, so will the back-end code. Exploit Scenario One of the requested websites hangs indeﬁnitely. This causes the back end to hang, and token ports from other users cannot be processed. Recommendations Short term, add the timeout argument to each of the code locations indicated above. This will ensure that the code will not hang if the website being requested hangs. Long term, integrate Semgrep into the CI pipeline to ensure that uses of the requests library always have the timeout argument. 
19. Lack of noopener attribute on external links Severity: Low Diﬃculty: High Type: Conﬁguration Finding ID: TOB-CHPT-19 Target: chainport-app/src/modules/exchange/components/PortOutModal.jsx Description In the ChainPort front-end application, there are links to external websites that have the target attribute set to _blank but lack the noopener attribute. Without this attribute, an attacker could perform a reverse tabnabbing attack. [REDACTED] Figure 19.1: chainport-app/src/modules/exchange/components/PortOutModal.jsx#L126 Exploit Scenario An attacker takes control of one of the external domains linked by the front end. The attacker prepares a malicious script on the domain that uses the window.opener variable to control the parent window’s location. A user clicks on the link in the ChainPort front end. The malicious website is opened in a new window, and the original ChainPort front end is seamlessly replaced by a phishing website. The victim then returns to a page that appears to be the original ChainPort front end but is actually a web page controlled by the attacker. The attacker tricks the user into transferring his funds to the attacker. Recommendations Short term, add the missing rel="noopener noreferrer" attribute to the anchor tags. References ● OWASP: Reverse tabnabbing attacks 
20. Use of urllib could allow users to leak local ﬁles Severity: Undetermined Diﬃculty: High Type: Data Exposure Finding ID: TOB-CHPT-20 Target: chainport-backend/modules/infrastructure/aws/s3.py Description To upload images of new tokens to S3, the upload_media_from_url_to_s3 function uses the urllib library (ﬁgure 20.1), which supports the file:// scheme; therefore, if a malicious actor controls a dynamic value uploaded to S3, she could read arbitrary local ﬁles. [REDACTED] Figure 20.1: chainport-backend/modules/infrastructure/aws/s3.py#L25-29 The code in ﬁgure 20.2 replicates this issue. [REDACTED] Figure 20.2: Code to test urlopen’s support of the file:// scheme We set the severity of this ﬁnding to undetermined because it is unclear whether an attacker (e.g., a token owner) would have control over token images uploaded to S3 and whether the server holds ﬁles that an attacker would want to extract. Exploit Scenario A token owner makes the image of his token point to a local ﬁle (e.g., file:///etc/passwd). This local ﬁle is uploaded to the S3 bucket and is shown to an attacker attempting to port his own token into the ChainPort front end. The local ﬁle is leaked to the attacker. Recommendations Short term, use the requests library instead of urllib. The requests library does not support the file:// scheme. 
21. The front end is vulnerable to iFraming Severity: Low Diﬃculty: High Type: Conﬁguration Finding ID: TOB-CHPT-21 Target: The chainport-app repository Description The ChainPort front end does not prevent other websites from iFraming it. Figure 21.1 shows an example of how another website could iFrame the ChainPort front end. [REDACTED] Figure 21.1: An example of how another website could iFrame the ChainPort front end Exploit Scenario An attacker creates a website that iFrames ChainPort’s front end. The attacker performs a clickjacking attack to trick users into submitting malicious transactions. Recommendations Short term, add the X-Frame-Options: DENY header on every server response. This will prevent other websites from iFraming the ChainPort front end. 
22. Lack of CSP header in the ChainPort front end Severity: Low Diﬃculty: High Type: Conﬁguration Finding ID: TOB-CHPT-22 Target: The chainport-app repository Description The ChainPort front end lacks a Content Security Policy (CSP) header, leaving it vulnerable to cross-site scripting (XSS) attacks. A CSP header adds extra protection against XSS and data injection attacks by enabling developers to select the sources that the browser can execute or render code from. This safeguard requires the use of the CSP HTTP header and appropriate directives in every server response. Exploit Scenario An attacker ﬁnds an XSS vulnerability in the ChainPort front end and crafts a custom XSS payload. Because of the lack of a CSP header, the browser executes the attack, enabling the attacker to trick users into transferring their funds to him. Recommendations Short term, use a CSP header in the ChainPort front end and validate it with the CSP Evaluator. This will help mitigate the eﬀects of XSS attacks. Long term, track the development of the CSP header and similar web browser features that help mitigate security risks. Ensure that new protections are adopted as quickly as possible. References ● HTTP Content Security Policy (CSP) ● Google CSP Evaluator ● Google Web Security Fundamentals: Eval ● Google Web Security Fundamentals: Inline code is considered harmful 
