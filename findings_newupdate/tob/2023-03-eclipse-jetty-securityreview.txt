1. Risk of integer overﬂow that could allow HpackDecoder to exceed maxHeaderSize Severity: Medium Diﬃculty: High Type: Denial of Service Finding ID: TOB-JETTY-1 Target: org.eclipse.jetty.http2.hpack.internal.MetaDataBuilder , org.eclipse.jetty.http2.hpack.HpackDecoder Description An integer overﬂow could occur in the MetaDataBuilder.checkSize function, which would allow HPACK header values to exceed their size limit. MetaDataBuilder.checkSize determines whether a header name or value exceeds the size limit and throws an exception if the limit is exceeded: public void checkSize ( int length, boolean huffman) throws SessionException { 291 292 293 294 295 296 297 _size + length, _maxSize); 298 } // Apply a huffman fudge factor if (huffman) length = (length * 4 ) / 3 ; if ((_size + length) > _maxSize) throw new HpackException.SessionException( "Header too large %d > %d" , Figure 1.1: MetaDataBuilder.checkSize However, when the value of length is very large and huffman is true , the multiplication of length by 4 in line 295 will overﬂow, and length will become negative. This will cause the result of the sum of _size and length to be negative, and the check on line 296 will not be triggered. Exploit Scenario An attacker repeatedly sends HTTP messages with the HPACK header 0x00ffffffffff02 . Each time this header is decoded, the following occurs: ● HpackDecode.decode determines that a Huﬀman-coded value of length 805306494 needs to be decoded. 36 OSTIF Eclipse: Jetty Security Assessment ● MetaDataBuilder.checkSize approves this length. ● Huffman.decode allocates a 1.6 GB string array. ● Huffman.decode experiences a buﬀer overﬂow error, and the array is deallocated the next time garbage collection happens. (Note that this deallocation can be delayed by appending valid Huﬀman-coded characters to the end of the header.) Depending on the timing of garbage collection, the number of threads, and the amount of memory available on the server, this may cause the server to run out of memory. Recommendations Short term, have MetaDataBuilder.checkSize check that length is below a threshold before performing the multiplication. Long term, use fuzzing to check for similar errors; we found this issue by fuzzing HpackDecode . 37 OSTIF Eclipse: Jetty Security Assessment 
2. Cookie parser accepts unmatched quotation marks Severity: Informational Diﬃculty: High Type: Error Reporting Finding ID: TOB-JETTY-2 Target: org.eclipse.jetty.http.RFC6265CookieParser Description The RFC6265CookieParser.parseField function does not check for unmatched quotation marks. For example, parseField(“\””) will execute without raising an exception. This issue is unlikely to lead to any vulnerabilities, but it could lead to problems if users or developers expect the function to accept only valid strings. Recommendations Short term, modify the function to check that the state at the end of the given string is not IN_QUOTED_VALUE . Long term, when using a state machine, ensure that the code always checks that the state is valid before exiting. 38 OSTIF Eclipse: Jetty Security Assessment 
3. Errant command quoting in CGI servlet Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-3 Target: org.eclipse.jetty.ee10.servlets.CGI , org.eclipse.jetty.ee9.servlets.CGI Description If a user sends a request to a CGI servlet for a binary with a space in its name, the servlet will escape the command by wrapping it in quotation marks. This wrapped command, plus an optional command preﬁx, will then be executed through a call to Runtime.exec . If the original binary name provided by the user contains a quotation mark followed by a space, the resulting command line will contain multiple tokens instead of one. For example, if a request references a binary called file” name “here , the escaping algorithm will generate the command line string “file” name “here” , which will invoke the binary named file , not the one that the user requested. if (execCmd.length() > 0 && execCmd.charAt( 0 ) != '"' && execCmd.contains( " " )) execCmd = "\"" + execCmd + "\"" ; Figure 3.1: CGI.java#L337–L338 Exploit Scenario The cgi-bin directory contains a binary named exec and a subdirectory named exec” commands , which contains a ﬁle called bin1 . A user sends to the CGI servlet a request for the ﬁlename exec” commands/bin1 . This request passes the ﬁle existence check on lines 194 through 205 in CGI.java . The servlet adds quotation marks around this ﬁlename, resulting in the command line string “exec” commands/bin1” . When this string is passed to Runtime.exec , instead of executing the bin1 binary, the server executes the exec binary with the argument commands/bin1” . This behavior is incorrect and could bypass alias checks; it could also cause other unintended behaviors if a command preﬁx is conﬁgured. Additionally, if the useFullPath conﬁguration setting is oﬀ, the command would not need to pass the existence check. Without this setting, an attacker exploiting this issue would not have to rely on a binary and subdirectory with similar names, and the attack could succeed on a much wider variety of directory structures. 39 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, update line 346 in CGI.java to replace the call to exec(String command, String[] env, File dir) with a call to exec(String[] cmdarray, String[] env, File dir) so that the quotation mark escaping algorithm does not create new tokens in the command line string. Long term, update the quotation mark escaping algorithm so that any unescaped quotation marks in the original name of the command are properly escaped, resulting in one double-quoted token instead of multiple adjacent quoted strings. Additionally, the expression execCmd.charAt(0) != '"' on line 337 of CGI.java is intended to avoid adding additional quotation marks to an already-quoted command string. If this check is unnecessary, it should be removed. If it is necessary, it should be replaced by a more robust check that accurately detects properly formatted double-quoted strings. 40 OSTIF Eclipse: Jetty Security Assessment 
4. Symlink-allowed alias checker ignores protected targets list Severity: High Diﬃculty: Medium Type: Access Controls Finding ID: TOB-JETTY-4 Target: org.eclipse.jetty.server.SymlinkAllowedResourceAliasChecker Description The class SymlinkAllowedResourceAliasChecker is an alias checker that permits users to access a symlink as long as the symlink is stored within an allowed directory. The following comment appears on line 76 of this class: // TODO: return !getContextHandler().isProtectedTarget(realURI.toString()); Figure 4.1: SymlinkAllowedResourceAliasChecker.java#L76 As this comment suggests, the alias checker does not yet enforce the context handler’s protected resource list. That is, if a symlink is contained in an allowed directory but points to a target on the protected resource list, the alias checker will return a positive match. During our review, we found that some other modules, but not all, independently enforce the protected resource list and will decline to serve resources on the list even if the alias checker returns a positive result. But the modules that do not independently enforce the protected resource list could serve protected resources to attackers conducting symlink attacks. Exploit Scenario An attacker induces the creation of a symlink (or a system administrator accidentally creates one) in a web-accessible directory that points to a protected resource (e.g., a child of WEB-INF ). By requesting this symlink through a servlet that uses the SymlinkAllowedResourceAliasChecker class, the attacker bypasses the protected resource list and accesses the sensitive ﬁles. Recommendations Short term, implement the check referenced in the comment so that the alias checker rejects symlinks that point to a protected resource or a child of a protected resource. Long term, consider clarifying and documenting the responsibilities of diﬀerent components for enforcing protected resource lists. Consider implementing redundant checks in multiple modules for purposes of layered security. 41 OSTIF Eclipse: Jetty Security Assessment 
5. Missing check for malformed Unicode escape sequences in QuotedStringTokenizer.unquote Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-5 Target: org.eclipse.jetty.util.QuotedStringTokenizer Description The QuotedStringTokenizer class’s unquote method parses \u#### Unicode escape sequences, but it does not ﬁrst check that the escape sequence is properly formatted or that the string is of a suﬃcient length: case 'u' : b.append(( char )( (TypeUtil.convertHexDigit(( byte )s.charAt(i++)) << 24 ) + (TypeUtil.convertHexDigit(( byte )s.charAt(i++)) << 16 ) + (TypeUtil.convertHexDigit(( byte )s.charAt(i++)) << 8 ) + (TypeUtil.convertHexDigit(( byte )s.charAt(i++))) ) ); break ; Figure 5.1: QuotedStringTokenizer.java#L547–L555 Any calls to this function with an argument ending in an incomplete Unicode escape sequence, such as “str\u0” , will cause the code to throw a java.lang.NumberFormatException exception. The only known execution path that will cause this method to be called with a parameter ending in an invalid Unicode escape sequence is to induce the processing of an ETag Matches header by the ResourceService class, which calls EtagUtils.matches , which calls QuotedStringTokenizer.unquote . Exploit Scenario An attacker introduces a maliciously crafted ETag into a browser’s cache. Each subsequent request for the aﬀected resource causes a server-side exception, preventing the server from producing a valid response so long as the cached ETag remains in place. Recommendations Short term, add a try-catch block around the aﬀected code that drops malformed escape sequences. 42 OSTIF Eclipse: Jetty Security Assessment Long term, implement a suitable workaround for lenient mode that passes the raw bytes of the malformed escape sequence into the output. 43 OSTIF Eclipse: Jetty Security Assessment 
6. WebSocket frame length represented with 32-bit integer Severity: High Diﬃculty: Medium Type: Data Validation Finding ID: TOB-JETTY-6 Target: org.eclipse.jetty.websocket.core.internal.Parser Description The WebSocket standard (RFC 6455) allows for frames with a size of up to 2 64 bytes. However, the WebSocket parser represents the frame length with a 32-bit integer: private int payloadLength; // ...[snip]... case PAYLOAD_LEN_BYTES: { } byte b = buffer.get(); --cursor; payloadLength |= (b & 0xFF ) << ( 8 * cursor); // ...[snip]... Figure 6.1: Parser.java , lines 57 and 147–151 As a result, this parsing algorithm will incorrectly parse some length ﬁelds as negative integers, causing a java.lang.IllegalArgumentException exception to be thrown when the parser tries to set the limit of a Buffer object to a negative number (refer to TOB-JETTY-7 ). Consequently, Jetty’s WebSocket implementation cannot properly process frames with certain lengths that are compliant with RFC 6455. Even if no exception results, this logic error will cause the parser to incorrectly identify the sizes of WebSocket frames and the boundaries between them. If the server passes these frames to another WebSocket connection, this bug could enable attacks similar to HTTP request smuggling, resulting in bypasses of security controls. Exploit Scenario A Jetty WebSocket server is deployed in a reverse proxy conﬁguration in which both Jetty and another web server parse the same stream of WebSocket frames. An attacker sends a frame with a length that the Jetty parser incorrectly truncates to a 32-bit integer. Jetty and the other server interpret the frames diﬀerently, which causes errors in the implementation of security controls, such as WAF ﬁlters. 44 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, change the payloadLength variable to use the long data type instead of an int . Long term, audit all arithmetic operations performed on this payloadLength variable to ensure that it is always used as an unsigned integer instead of a signed one. The standard library’s Integer class can provide this functionality. 45 OSTIF Eclipse: Jetty Security Assessment 
7. WebSocket parser does not check for negative payload lengths Severity: Low Diﬃculty: Low Type: Data Validation Finding ID: TOB-JETTY-7 Target: org.eclipse.jetty.websocket.core.internal.Parser Description The WebSocket parser’s checkFrameSize method checks for payload lengths that exceed the current conﬁguration’s maximum, but it does not check for payload lengths that are lower than zero. If the payload length is lower than zero, the code will throw an exception when the payload length is passed to a call to buffer.limit . Exploit Scenario An attacker sends a WebSocket payload with a length ﬁeld that parses to a negative signed integer (refer to TOB-JETTY-6 ). This payload causes an exception to be thrown and possibly the server process to crash. Recommendations Short term, update checkFrameSize to throw an org.eclipse.jetty.websocket.core.exception.ProtocolException exception if the frame’s length ﬁeld is less than zero. 46 OSTIF Eclipse: Jetty Security Assessment 8. WebSocket parser greedily allocates ByteBu ers for large frames Severity: Medium Diﬃculty: Low Type: Denial of Service Finding ID: TOB-JETTY-8 Target: org.eclipse.jetty.websocket.core.internal.Parser Description When the WebSocket parser receives a partial frame in a ByteBuffer object and auto-fragmenting is disabled, the parser allocates a buﬀer of a size suﬃcient to store the entire frame at once: if (aggregate == null ) { if (available < payloadLength) { // not enough to complete this frame // Can we auto-fragment if (configuration.isAutoFragment() && isDataFrame) return autoFragment(buffer, available); // No space in the buffer, so we have to copy the partial payload aggregate = bufferPool.acquire(payloadLength, false ); BufferUtil.append(aggregate.getByteBuffer(), buffer); return null ; } //...[snip]... } Figure 8.1: Parser.java , lines 323–336 An attacker could send a WebSocket frame with a large payload length ﬁeld, causing the server to allocate a buﬀer of a size equal to the speciﬁed payload length, without ever sending the entire frame contents. Therefore, an attacker can induce the consumption of gigabytes (or potentially exabytes; refer to TOB-JETTY-6 ) of memory by sending only hundreds or thousands of bytes over the wire. Exploit Scenario An attacker crafts a malicious WebSocket frame with a large payload length ﬁeld but incomplete payload contents. The server then allocates a buﬀer of a size equal to the payload length ﬁeld, causing an excessive consumption of RAM. To ensure that the connection is not promptly dropped, the attacker continues sending parts of this payload a few seconds apart, conducting a slow HTTP attack. 47 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, ensure that the default maximum payload size remains at a low value that is suﬃcient for most purposes (such as the current default of 64 KB). Long term, to better support large WebSocket frames, update the use of ByteBuffer objects in the WebSocket parser so that the parser does not allocate the entire buﬀer as soon as it parses the ﬁrst fragment. Instead, the buﬀer should be expanded in relatively small increments (e.g., 10 MB or 100 MB at a time) and then written to only once the data sent by the client exceeds the length of the current buﬀer. That way, in order to induce the consumption of a large amount of RAM, an attacker would need to send a commensurate number of bytes over the wire. 48 OSTIF Eclipse: Jetty Security Assessment 9. Risk of integer overﬂow in HPACK's NBitInteger.decode Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-9 Target: org.eclipse.jetty.http2.hpack.internal.NBitInteger Description The static function NBitInteger.decode is used to decode bytestrings in HPACK's integer format. It should return only positive integers since HPACK’s integer format is not intended to support negative numbers. However, the following loop in NBitInteger.decode is susceptible to integer overﬂows in its multiplication and addition operations: public static int decode (ByteBuffer buffer, int n) { if (n == 8 ) { // ... } int nbits = 0xFF >>> ( 8 - n); int i = buffer.get(buffer.position() - 1 ) & nbits; if (i == nbits) { int m = 1 ; int b; do { b = 0xff & buffer.get(); i = i + (b & 127 ) * m; m = m * 128 ; } while ((b & 128 ) == 128 ); } return i; } Figure 9.1: NBitInteger.java , lines 105–145 For example, NBitInteger.decode(0xFF8080FFFF0F, 7) returns -16257 . Any overﬂow that occurs in the function would not be a problem on its own since, in general, the output of this function ought to be validated before it is used; however, when coupled with other issues (refer to TOB-JETTY-10 ), an overﬂow can cause vulnerabilities. 49 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, modify NBitInteger.decode to check that its result is nonnegative before returning it. Long term, consider merging the QPACK and HPACK implementations for NBitInteger , since they perform the same functionality; the QPACK implementation of NBitInteger checks for overﬂows. 50 OSTIF Eclipse: Jetty Security Assessment 10. MetaDataBuilder.checkSize accepts headers of negative lengths Severity: Medium Diﬃculty: High Type: Denial of Service Finding ID: TOB-JETTY-10 Target: org.eclipse.jetty.http2.hpack.internal.MetaDataBuilder Description The MetaDataBuilder.checkSize function accepts user-entered HPACK header values of negative sizes, which could cause a very large buﬀer to be allocated later when the user-entered size is multiplied by 2. MetaDataBuilder.checkSize determines whether a header name or value exceeds the size limit and throws an exception if the limit is exceeded: public void checkSize ( int length, boolean huffman) throws SessionException { // Apply a huffman fudge factor if (huffman) length = (length * 4 ) / 3 ; if ((_size + length) > _maxSize) throw new HpackException.SessionException( "Header too large %d > %d" , _size + length, _maxSize); } Figure 10.1: MetaDataBuilder.java , lines 291–298 However, it does not throw an exception if the size is negative. Later, the Huffman.decode function multiplies the user-entered length by 2 before allocating a buﬀer: public static String decode (ByteBuffer buffer, int length) throws HpackException.CompressionException { Utf8StringBuilder utf8 = new Utf8StringBuilder(length * 2 ); // ... Figure 10.2: Huffman.java , lines 357–359 This means that if a user provides a negative length value (or, more precisely, a length value that becomes negative when multiplied by the 4/3 fudge factor), and this length value becomes a very large positive number when multiplied by 2, then the user can cause a very large buﬀer to be allocated on the server. 51 OSTIF Eclipse: Jetty Security Assessment Exploit Scenario An attacker repeatedly sends HTTP messages with the HPACK header 0x00ff8080ffff0b . Each time this header is decoded, the following occurs: ● HpackDecode.decode determines that a Huﬀman-coded value of length -1073758081 needs to be decoded. ● MetaDataBuilder.checkSize approves this length. ● The number is multiplied by 2, resulting in 2147451134 , and Huffman.decode allocates a 2.1 GB string array. ● Huffman.decode experiences a buﬀer overﬂow error, and the array is deallocated the next time garbage collection happens. (Note that this deallocation can be delayed by adding valid Huﬀman-coded characters to the end of the header.) Depending on the timing of garbage collection, the number of threads, and the amount of memory available on the server, this may cause the server to run out of memory. Recommendations Short term, have MetaDataBuilder.checkSize check that the given length is positive directly before adding it to _size and comparing it with _maxSize . Long term, add checks for integer overﬂows in Huffman.decode and in NBitInteger.decode (refer to TOB-JETTY-9 ) for added redundancy. 52 OSTIF Eclipse: Jetty Security Assessment 11. Insu cient space allocated when encoding QPACK instructions and entries Severity: Low Diﬃculty: High Type: Denial of Service Finding ID: TOB-JETTY-11 Target: ● org.eclipse.jetty.http3.qpack.internal.instruction.IndexedName EntryInstruction ● org.eclipse.jetty.http3.qpack.internal.instruction.LiteralName EntryInstruction ● org.eclipse.jetty.http3.qpack.internal.instruction.EncodableEn try Description Multiple expressions do not allocate enough buﬀer space when encoding QPACK instructions and entries, which could result in a buﬀer overﬂow exception. In IndexedNameEntry , the following expression determines how much space to allocate when encoding the instruction: int size = NBitIntegerEncoder.octetsNeeded( 6 , _index) + (_huffman ? HuffmanEncoder.octetsNeeded(_value) : _value.length()) + 2 ; Figure 11.1: IndexedNameEntry.java , line 58 Later, the following two lines encode the value size for Huﬀman-coded and non-Huﬀman-coded strings, respectively: NBitIntegerEncoder.encode(byteBuffer, 7 , HuffmanEncoder.octetsNeeded(_value)); // ... NBitIntegerEncoder.encode(byteBuffer, 7 , _value.length()); Figure 11.2: IndexedNameEntry.java , lines 71 and 77 These encodings can take up more than 1 byte if the value’s length is over 126 because the number will ﬁll up the 7 bits given to it in the ﬁrst byte. However, the int size expression in ﬁgure 11.1 assumes that it will take up only 1 byte. Thus, if the value’s length is over 126, too few bytes may be allocated for the instruction, causing a buﬀer overﬂow. The same problem occurs in LiteralNameEntryInstruction : 53 OSTIF Eclipse: Jetty Security Assessment int size = (_huffmanName ? HuffmanEncoder.octetsNeeded(_name) : _name.length()) + (_huffmanValue ? HuffmanEncoder.octetsNeeded(_value) : _value.length()) + 2 ; Figure 11.3: LiteralNameEntryInstruction.java , lines 59–60 This expression assumes that the name's length will ﬁt into 5 bits and that the value’s length will ﬁt into 7 bits. If the name’s length is over 30 bytes or the value’s length is over 126 bytes, these assumptions will be false and too little space may be allocated for the instruction, which could cause a buﬀer overﬂow. A similar problem occurs in EncodableEntry.ReferencedNameEntry . The getRequiredSize method in this ﬁle calculates how much space should be allocated for its encoding: public int getRequiredSize ( int base) { String value = getValue(); int relativeIndex = _nameEntry.getIndex() - base; int valueLength = _huffman ? HuffmanEncoder.octetsNeeded(value) : value.length(); return 1 + NBitIntegerEncoder.octetsNeeded( 4 , relativeIndex) + 1 + NBitIntegerEncoder.octetsNeeded( 7 , valueLength) + valueLength; } Figure 11.4: EncodableEntry.java , lines 181–187 The method returns the wrong size if the value is longer than 126 bytes. Additionally, it assumes that the name will use a post-base reference rather than a normal one, which may be incorrect. An additional problem is present in this method. It assumes that value ’s length in bytes will be returned by value.length() . However, value.length() measures the number of characters in value , not the number of bytes, so if value contains multibyte characters (e.g., UTF-8), too few bytes will be allocated. The length of value should be calculated by using value.getBytes() instead of value.length() . The getRequiredSize method in EncodableEntry.LiteralEntry also incorrectly uses value.length() : public int getRequiredSize ( int base) { String name = getName(); String value = getValue(); int nameLength = _huffman ? HuffmanEncoder.octetsNeeded(name) : name.length(); int valueLength = _huffman ? HuffmanEncoder.octetsNeeded(value) : value.length(); return 2 + NBitIntegerEncoder.octetsNeeded( 3 , nameLength) + nameLength + NBitIntegerEncoder.octetsNeeded( 7 , valueLength) + valueLength; 54 OSTIF Eclipse: Jetty Security Assessment } Figure 11.5: EncodableEntry.java , lines 243–250 Note that name.length() is used to measure the byte length of name , and value.length() is used to measure the byte length of value . Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. Recommendations Short term, change the relevant expressions to account for the extra length. Long term, build out additional test cases for QPACK and other parsers used in HTTP/3 to test for the correct handling of edge cases and identify memory handling exceptions. 55 OSTIF Eclipse: Jetty Security Assessment 12. LiteralNameEntryInstruction incorrectly encodes value length Severity: Medium Diﬃculty: Medium Type: Denial of Service Finding ID: TOB-JETTY-12 Target: org.eclipse.jetty.http3.qpack.internal.instruction.LiteralNameEntryI nstruction Description QPACK instructions for inserting entries with literal names and non-Huﬀman-coded values will be encoded incorrectly when the value’s length is over 30, which could cause values to be sent incorrectly or errors to occur during decoding. The following snippet of the LiteralNameEntryInstruction.encode function is responsible for encoding the header value: if (_huffmanValue) byteBuffer.put(( byte )( 0x80 )); NBitIntegerEncoder.encode(byteBuffer, 7 , HuffmanEncoder.octetsNeeded(_value)); HuffmanEncoder.encode(byteBuffer, _value); 78 79 { 80 81 82 83 } 84 85 { 86 87 88 89 } else byteBuffer.put(( byte )( 0x00 )); NBitIntegerEncoder.encode(byteBuffer, 5 , _value.length()); byteBuffer.put(_value.getBytes()); Figure 12.1: LiteralNameEntryInstruction.java , lines 78–89 On line 87, 5 is the second parameter to NBitIntegerEncoder.encode , indicating that the number will take up 5 bits in the ﬁrst encoded byte; however, the second parameter should be 7 instead. This means that when _value.length() is over 30, it will be incorrectly encoded. Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. 56 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, change the second parameter of the NBitIntegerEncoder.encode function from 5 to 7 in order to reﬂect that the number will take up 7 bits. Long term, write more tests to catch similar encoding/decoding problems. 57 OSTIF Eclipse: Jetty Security Assessment 13. FileInitializer does not check for symlinks Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-13 Target: org.eclipse.jetty.start.FileInitializer Description Module conﬁguration ﬁles can direct Jetty to download a remote ﬁle and save it in the local ﬁlesystem while initializing the module. During this process, the FileInitializer class validates the destination path and throws an IOException exception if the destination is outside the ${jetty.base} directory. However, this validation routine does not check for symlinks: // now on copy/download paths (be safe above all else) if (destination != null && !destination.startsWith(_basehome.getBasePath())) throw new IOException( "For security reasons, Jetty start is unable to process file resource not in ${jetty.base} - " + location); Figure 13.1: FileInitializer.java , lines 112–114 None of the subclasses of FileInitializer check for symlinks either. Thus, if the ${jetty.base} directory contains a symlink, a ﬁle path in a module’s .ini ﬁle beginning with the symlink name will pass the validation check, and the ﬁle will be written to a subdirectory of the symlink’s destination. Exploit Scenario A system’s ${jetty.base} directory contains a symlink called dir , which points to /etc . The system administrator enables a Jetty module whose .ini ﬁle contains a [files] entry that downloads a remote ﬁle and writes it to the relative path dir/config.conf . The ﬁlesystem follows the symlink and writes a new conﬁguration ﬁle to /etc/config.conf , which impacts the server’s system conﬁguration. Additionally, since the FileInitializer class uses the REPLACE_EXISTING ﬂag, this behavior overwrites an existing system conﬁguration ﬁle. Recommendations Short term, rewrite all path checks in FileInitializer and its subclasses to include a call to the Path.toRealPath function, which, by default, will resolve symlinks and produce the real ﬁlesystem path pointed to by the Path object. If this real path is outside ${jetty.base} , the ﬁle write operation should fail. 58 OSTIF Eclipse: Jetty Security Assessment Long term, consolidate all ﬁlesystem operations involving the ${jetty.base} or ${jetty.home} directories into a single centralized class that automatically performs symlink resolution and rejects operations that attempt to read from or write to an unauthorized directory. This class should catch and handle the IOException exception that is thrown in the event of a link loop or a large number of nested symlinks. 59 OSTIF Eclipse: Jetty Security Assessment 14. FileInitializer permits downloading ﬁles via plaintext HTTP Severity: High Diﬃculty: High Type: Data Exposure Finding ID: TOB-JETTY-14 Target: org.eclipse.jetty.start.FileInitializer Description Module conﬁguration ﬁles can direct Jetty to download a remote ﬁle and save it in the local ﬁlesystem while initializing the module. If the speciﬁed URL is a plaintext HTTP URL, Jetty does not raise an error or warn the user. Transmitting ﬁles over plaintext HTTP is intrinsically unsecure and exposes sensitive data to tampering and eavesdropping in transit. Exploit Scenario A system administrator enables a Jetty module that downloads a remote ﬁle over plaintext HTTP during initialization. An attacker with a network intermediary position sniﬀs the traﬃc and infers sensitive information about the design and conﬁguration of the Jetty system under conﬁguration. Alternatively, the attacker actively tampers with the ﬁle during transmission from the remote server to the Jetty installation, which enables the attacker to alter the module’s behavior and launch other attacks against the targeted system. Recommendations Short term, add a check to the FileInitializer class and its subclasses to prohibit downloads over plaintext HTTP. Additionally, add a validation check to the module .ini ﬁle parser to reject any conﬁguration that includes a plaintext HTTP URL in the [files] section. Long term, consolidate all remote ﬁle downloads conducted during module conﬁguration operations into a single centralized class that automatically rejects plaintext HTTP URLs. If current use cases require support of plaintext HTTP URLs, then at a minimum, have Jetty display a prominent warning message and prompt the user for manual conﬁrmation before performing the unencrypted download. 60 OSTIF Eclipse: Jetty Security Assessment 15. NullPointerException thrown by FastCGI parser on invalid frame type Severity: Medium Diﬃculty: Low Type: Data Validation Finding ID: TOB-JETTY-15 Target: org.eclipse.jetty.fcgi.parser.Parser Description Because of a missing null check, the Jetty FastCGI client’s Parser class throws a NullPointerException exception when parsing a frame with an invalid frame type ﬁeld. This exception occurs because the findContentParser function returns null when it does not have a ContentParser object matching the speciﬁed frame type, and the caller never checks the findContentParser return value for null before dereferencing it. case CONTENT: { ContentParser contentParser = findContentParser(headerParser.getFrameType()); if (headerParser.getContentLength() == 0 ) { padding = headerParser.getPaddingLength(); state = State.PADDING; if (contentParser.noContent()) return true ; } else { ContentParser.Result result = contentParser.parse(buffer); // ...[snip]... } break ; } Figure 15.1: Parser.java , lines 82–114 Exploit Scenario An attacker operates a malicious web server that supports FastCGI. A Jetty application communicates with this server by using Jetty’s built-in FastCGI client. The remote server transmits a frame with an invalid frame type, causing a NullPointerException exception and a crash in the Jetty application. Recommendations Short term, add a null check to the parse function to abort the parsing process before dereferencing a null return value from findContentParser . If a null value is detected, 61 OSTIF Eclipse: Jetty Security Assessment parse should throw an appropriate exception, such as IllegalStateException , that Jetty can catch and handle safely. Long term, build out a larger suite of test cases that ensures graceful handling of malformed traﬃc and data. 62 OSTIF Eclipse: Jetty Security Assessment 16. Documentation does not specify that request contents and other user data can be exposed in debug logs Severity: Medium Diﬃculty: High Type: Data Exposure Finding ID: TOB-JETTY-16 Target: Jetty 12 Operations Guide; numerous locations throughout the codebase Description Over 100 times, the system calls LOG.debug with a parameter of the format BufferUtil.toDetailString(buffer) , which outputs up to 56 bytes of the buﬀer into the log ﬁle. Jetty’s implementations of various protocols and encodings, including GZIP, WebSocket, multipart encoding, and HTTP/2, output user data received over the network to the debug log using this type of call. An example instance from Jetty’s WebSocket implementation appears in ﬁgure 16.1. public Frame.Parsed parse (ByteBuffer buffer) throws WebSocketException { try { // parse through while (buffer.hasRemaining()) { if (LOG.isDebugEnabled()) LOG.debug( "{} Parsing {}" , this , BufferUtil.toDetailString(buffer)); // ...[snip]... } // ...[snip]... } // ...[snip]... } Figure 16.1: Parser.java , lines 88–96 Although the Jetty 12 Operations Guide does state that Jetty debugging logs can quickly consume massive amounts of disk space, it does not advise system administrators that the logs can contain sensitive user data, such as personally identiﬁable information. Thus, the possibility of raw traﬃc being captured from debug logs is undocumented. Exploit Scenario A Jetty system administrator turns on debug logging in a production environment. During the normal course of operation, a user sends traﬃc containing sensitive information, such as personally identiﬁable information or ﬁnancial data, and this data is recorded to the 63 OSTIF Eclipse: Jetty Security Assessment debug log. An attacker who gains access to this log can then read the user data, compromising data conﬁdentiality and the user’s privacy rights. Recommendations Short term, update the Jetty Operations Guide to state that in addition to being extremely large, debug logs can contain sensitive user data and should be treated as sensitive. Long term, consider moving all debugging messages that contain buﬀer excerpts into a high-detail debug log that is enabled only for debug builds of the application. 64 OSTIF Eclipse: Jetty Security Assessment 17. HttpStreamOverFCGI internally marks all requests as plaintext HTTP Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-17 Target: org.eclipse.jetty.fcgi.server.internal.HttpStreamOverFCGI Description The HttpStreamOverFCGI class processes FastCGI messages in a format that can be processed by other system components that use the HttpStream interface. This class’s onHeaders callback mistakenly marks each MetaData.Request object as a plaintext HTTP request, as the “TODO” comment shown in ﬁgure 17.1 indicates: public void onHeaders () { String pathQuery = URIUtil.addPathQuery(_path, _query); // TODO https? MetaData.Request request = new MetaData.Request(_method, HttpScheme.HTTP.asString(), hostPort, pathQuery, HttpVersion.fromString(_version), _headers, Long.MIN_VALUE); // ...[snip]... } Figure 17.1: HttpStreamOverFCGI.java , lines 108–119 In some conﬁgurations, other Jetty components could misinterpret a message received over FCGI as a plaintext HTTP message, which could cause a request to be incorrectly rejected, redirected in an inﬁnite loop, or forwarded to another system over a plaintext HTTP channel instead of HTTPS. Exploit Scenario A Jetty instance runs an FCGI server and uses the HttpStream interface to process messages. The MetaData.Request class’s getURI method is used to check the incoming request’s URI. This method mistakenly returns a plaintext HTTP URL due to the bug in HttpStreamOverFCGI.java . One of the following takes place during the processing of this request: ● ● An application-level security control checks the incoming request’s URI to ensure it was received over a TLS-encrypted channel. Since this check fails, the application rejects the request and refuses to process it, causing a denial of service. An application-level security control checks the incoming request’s URI to ensure it was received over a TLS-encrypted channel. Since this check fails, the application 65 OSTIF Eclipse: Jetty Security Assessment attempts to redirect the user to a suitable HTTPS URL. The check fails on this redirected request as well, causing an inﬁnite redirect loop and a denial of service. ● An application processing FCGI messages acts as a proxy, forwarding certain requests to a third HTTP server. It uses MetaData.Request.getURI to check the request’s original URI and mistakenly sends a request over plaintext HTTP. Recommendations Short term, correct the bug in HttpStreamOverFCGI.java to generate the correct URI for the incoming request. Long term, consider streamlining the HTTP implementation to minimize the need for diﬀerent classes to generate URIs from request data. 66 OSTIF Eclipse: Jetty Security Assessment 18. Excessively permissive and non-standards-compliant error handling in HTTP/2 implementation Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-18 Target: The org.eclipse.jetty.http2.parser and org.eclipse.jetty.http2.parser packages Description Jetty’s HTTP/2 implementation violates RFC 9113 in that it fails to terminate a connection with an appropriate error code when the remote peer sends a frame with one of the following protocol violations: ● ● ● A SETTINGS frame with the ACK ﬂag set and a nonzero payload length A PUSH_PROMISE frame in a stream with push disabled A GOAWAY frame with its stream ID not set to zero None of these situations creates an exploitable vulnerability. However, noncompliant protocol implementations can create compatibility problems and could cause vulnerabilities when deployed in combination with other misconﬁgured systems. Exploit Scenario A Jetty instance connects to an HTTP/2 server, or serves a connection from an HTTP/2 client, and the remote peer sends traﬃc that should cause Jetty to terminate the connection. Instead, Jetty keeps the connection alive, in violation of RFC 9113. If the remote peer is programmed to handle the noncompliant traﬃc diﬀerently than Jetty, further problems could result, as the two implementations interpret protocol messages diﬀerently. Recommendations Short term, update the HTTP/2 implementation to check for the following error conditions and terminate the connection with an error code that complies with RFC 9113: ● ● A peer receives a SETTINGS frame with the ACK ﬂag set and a payload length greater than zero. A client receives a PUSH_PROMISE frame after having sent, and received an acknowledgement for, a SETTINGS frame with SETTINGS_ENABLE_PUSH equal to zero. 67 OSTIF Eclipse: Jetty Security Assessment ● A peer receives a GOAWAY frame with the stream identiﬁer ﬁeld not set to zero. Long term, audit Jetty’s implementation of HTTP/2 and other protocols to ensure that Jetty handles errors in a standards-compliant manner and terminates connections as required by the applicable speciﬁcations. 68 OSTIF Eclipse: Jetty Security Assessment 19. XML external entities and entity expansion in Maven package metadata parser Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-19 Target: org.eclipse.jetty.start.fileinits.MavenMetadata Description During module initialization, the MavenMetadata class parses maven-metadata.xml ﬁles when the module conﬁguration includes a maven:// URI in its [files] section. The DocumentBuilderFactory class is used with its default settings, meaning that document type deﬁnitions (DTD) are allowed and are applied. This behavior leaves the MavenMetadata class vulnerable to XML external entity (XXE) and XML entity expansion (XEE) attacks. These vulnerabilities could enable a variety of exploits, including server-side request forgery on the server’s local network and arbitrary ﬁle reads from the server’s ﬁlesystem. Exploit Scenario An attacker causes a Jetty installation to parse a maliciously crafted maven-metadata.xml ﬁle, such as by uploading a malicious package to a Maven repository, inducing an out-of-band download of the malicious package through social engineering, or by placing the maven-metadata.xml ﬁle on the server’s ﬁlesystem through other means. When the XML ﬁle is parsed, the XML-based attack is launched. The attacker could leverage this vector to do any of the following: ● ● ● Induce HTTP requests to servers on the server’s local network Read and exﬁltrate arbitrary ﬁles on the server’s ﬁlesystem Consume excessive system resources with an XEE, causing a denial of service Recommendations Short term, disable parsing of DTDs in MavenMetadata so that maven-metadata.xml ﬁles cannot be used as a vector for XML-based attacks. Disabling DTDs may require knowledge of the underlying XML parser implementation returned by the DocumentBuilderFactory class. Long term, review default conﬁgurations and attributes supported by XML parsers that may be returned by the DocumentBuilderFactory to ensure that DTDs are properly disabled. 69 OSTIF Eclipse: Jetty Security Assessment 20. Use of deprecated AccessController class Severity: Informational Diﬃculty: N/A Type: Code Quality Finding ID: TOB-JETTY-20 Target: ● org.eclipse.jetty.logging.JettyLoggerConfiguration ● org.eclipse.jetty.util.MemoryUtils ● org.eclipse.jetty.util.TypeUtil ● org.eclipse.jetty.util.thread.PrivilegedThreadFactory ● org.eclipse.jetty.ee10.servlet.ServletContextHandler ● org.eclipse.jetty.ee9.nested.ContextHandler Description The classes listed in the “Target” cell above use the java.security.AccessController class, which is a deprecated class slated to be removed in a future Java release. The java.security library documentation states that the AccessController class “is only useful in conjunction with the Security Manager,” which is also deprecated. Thus, the use of AccessController no longer serves any beneﬁcial purpose. The use of this deprecated class could impact Jetty’s compatibility with future releases of the Java SDK. Recommendations Short term, remove all uses of the AccessController class. Long term, audit the Jetty codebase for the use of classes in the java.security package that may not provide any value in Jetty 12, and remove all references to those classes. 70 OSTIF Eclipse: Jetty Security Assessment 21. QUIC server writes SSL private key to temporary plaintext ﬁle Severity: High Diﬃculty: High Type: Cryptography Finding ID: TOB-JETTY-21 Target: org.eclipse.jetty.quic.server.QuicServerConnector Description Jetty’s QUIC implementation uses quiche, a QUIC and HTTP/3 library maintained by Cloudﬂare. When the server’s SSL certiﬁcate is handed oﬀ to quiche, the private key is extracted from the existing keystore and written to a temporary plaintext PEM ﬁle: protected void doStart () throws Exception { // ...[snip]... char [] keyStorePassword = sslContextFactory.getKeyStorePassword().toCharArray(); String keyManagerPassword = sslContextFactory.getKeyManagerPassword(); SSLKeyPair keyPair = new SSLKeyPair( sslContextFactory.getKeyStoreResource().getPath(), sslContextFactory.getKeyStoreType(), keyStorePassword, alias, keyManagerPassword == null ? keyStorePassword : keyManagerPassword.toCharArray() ); File[] pemFiles = keyPair.export( new File(System.getProperty( "java.io.tmpdir" ))); privateKeyFile = pemFiles[ 0 ]; certificateChainFile = pemFiles[ 1 ]; } Figure 21.1: QuicServerConnector.java , lines 154–179 Storing the private key in this manner exposes it to increased risk of theft. Although the QuicServerConnector class deletes the private key ﬁle upon stopping the server, this deleted ﬁle may not be immediately removed from the physical storage medium, exposing the ﬁle to potential theft by attackers who can access the raw bytes on the disk. A review of quiche suggests that the library’s API may not support reading a DES-encrypted keyﬁle. If that is true, then remediating this issue would require updates to the underlying quiche library. 71 OSTIF Eclipse: Jetty Security Assessment Exploit Scenario An attacker gains read access to a Jetty HTTP/3 server’s temporary directory while the server is running. The attacker can retrieve the temporary keyﬁle and read the private key without needing to obtain or guess the encryption key for the original keystore. With this private key in hand, the attacker decrypts and tampers with all TLS communications that use the associated certiﬁcate. Recommendations Short term, investigate the quiche library’s API to determine whether it can readily support password-encrypted private keyﬁles. If so, update Jetty to save the private key in a temporary password-protected ﬁle and to forward that password to quiche. Alternatively, if password-encrypted private keyﬁles can be supported, have Jetty pass the unencrypted private key directly to quiche as a function argument. Either option would obviate the need to store the key in a plaintext ﬁle on the server’s ﬁlesystem. If quiche does not support either of these changes, open an issue or pull request for quiche to implement a ﬁx for this issue. 72 OSTIF Eclipse: Jetty Security Assessment 22. Repeated code between HPACK and QPACK Severity: Informational Diﬃculty: N/A Type: Code Quality Finding ID: TOB-JETTY-22 Target: ● org.eclipse.jetty.http2.hpack.internal.NBitInteger ● org.eclipse.jetty.http2.hpack.internal.Huffman ● org.eclipse.jetty.http3.qpack.internal.util.NBitIntegerParser ● org.eclipse.jetty.http3.qpack.internal.util.NBitIntegerEncode ● org.eclipse.jetty.http3.qpack.internal.util.HuffmanDecoder ● org.eclipse.jetty.http3.qpack.internal.util.HuffmanEncoder Description Classes for dealing with n-bit integers and Huﬀman coding are implemented both in the jetty-http2-hpack and in jetty-http3-qpack libraries. These classes have very similar functionality but are implemented in two diﬀerent places, sometimes with identical code and other times with diﬀerent implementations. In some cases ( TOB-JETTY-9 ), one implementation has a bug that the other implementation does not have. The codebase would be easier to maintain and keep secure if the implementations were merged. Exploit Scenario A vulnerability is found in the Huﬀman encoding implementation, which has identical code in HPACK and QPACK. The vulnerability is ﬁxed in one implementation but not the other, leaving one of the implementations vulnerable. Recommendations Short term, merge the two implementations of n-bit integers and Huﬀman coding classes. Long term, audit the Jetty codebase for other classes with very similar functionality. 73 OSTIF Eclipse: Jetty Security Assessment 23. Various exceptions in HpackDecoder.decode and QpackDecoder.decode Severity: Informational Diﬃculty: N/A Type: Denial of Service Finding ID: TOB-JETTY-23 Target: org.eclipse.jetty.http2.hpack.HpackDecoder , org.eclipse.jetty.http3.qpack.QpackDecoder Description The HpackDecoder and QpackDecoder classes both throw unexpected Java-level exceptions: ● HpackDecoder.decode(0x03) throws BufferUnderflowException . ● HpackDecoder.decode(0x4800) throws NumberFormatException . ● HpackDecoder.decode(0x3fff 2e) throws IllegalArgumentException . ● HpackDecoder.decode(0x3fff 81ff ff2e) throws NullPointerException . ● HpackDecoder.decode(0xffff ffff f8ff ffff ffff ffff ffff ffff ffff ffff ffff ffff 0202 0000) throws ArrayIndexOutOfBoundsException . ● QpackDecoder.decode(..., 0x81, ...) throws IndexOutOfBoundsException . ● QpackDecoder.decode(..., 0xfff8 ffff f75b, ...) throws ArithmeticException . For both HPACK and QPACK, these exceptions appear to be caught higher up in the call chain by catch (Throwable x) statements every time the decode functions are called. However, catching them within decode and throwing a Jetty-level exception within the catch statement would result in cleaner, more robust code. Exploit Scenario Jetty developers refactor the codebase, moving function calls around and introducing a new point in the code where HpackDecoder.decode is called. Assuming that decode will throw only org.jetty… errors, they forget to wrap this call in a catch (Throwable x) statement. This results in a DoS vulnerability. Recommendations Short term, document in the code that Java-level exceptions can be thrown. Long term, modify the decode functions so that they throw only Jetty-level exceptions. 74 OSTIF Eclipse: Jetty Security Assessment 24. Incorrect QPACK encoding when multi-byte characters are used Severity: Medium Diﬃculty: Medium Type: Data Validation Finding ID: TOB-JETTY-24 Target: org.eclipse.jetty.http3.qpack.internal.EncodableEntry Description Java’s string.length() function returns the number of characters in a string, which can be diﬀerent from the number of bytes returned by the string.getBytes() function. However, QPACK encoding methods assume that they return the same number, which could cause incorrect encodings. In EncodableEntry.LiteralEntry , which is used to encode HTTP/3 header ﬁelds, the following method is used for encoding: public void encode (ByteBuffer buffer, int base) 214 215 { 216 byte allowIntermediary = 0x00 ; // TODO: this is 0x10 bit, when should this be set? 217 218 219 220 221 222 223 224 String name = getName(); String value = getValue(); // Encode the prefix code and the name. if (_huffman) { buffer.put(( byte )( 0x28 | allowIntermediary)); NBitIntegerEncoder.encode(buffer, 3 , HuffmanEncoder.octetsNeeded(name)); 225 226 227 HuffmanEncoder.encode(buffer, name); buffer.put(( byte ) 0x80 ); NBitIntegerEncoder.encode(buffer, 7 , HuffmanEncoder.octetsNeeded(value)); 228 229 230 231 232 HuffmanEncoder.encode(buffer, value); } else { // TODO: What charset should we be using? (this applies to the instruction generators as well). 233 234 235 236 237 238 buffer.put(( byte )( 0x20 | allowIntermediary)); NBitIntegerEncoder.encode(buffer, 3 , name.length()); buffer.put(name.getBytes()); buffer.put(( byte ) 0x00 ); NBitIntegerEncoder.encode(buffer, 7 , value.length()); buffer.put(value.getBytes()); 75 OSTIF Eclipse: Jetty Security Assessment 239 240 } } Figure 24.1: EncodableEntry.java , lines 214–240 Note in particular lines 232–238, which are used to encode literal (non-Huﬀman-coded) names and values. The value returned by name.length() is added to the bytestring, followed by the value returned by name.getBytes() . Then, the value returned by value.length() is added to the bytestring, followed by the value returned by value.getBytes() . When this bytestring is decoded, the decoder will read the name length ﬁeld and then read that many bytes as the name. If multibyte characters were used in the name ﬁeld, the decoder will read too few bytes. The rest of the bytestring will also be decoded incorrectly, since the decoder will continue reading at the wrong point in the bytestring. The same issue occurs if multibyte characters were used in the value ﬁeld. The same issue appears in EncodableEntry.ReferencedNameEntry.encode : if (_huffman) 164 // Encode the value. 165 String value = getValue(); 166 167 { 168 169 170 171 } 172 173 { 174 175 176 177 } else buffer.put(( byte ) 0x80 ); NBitIntegerEncoder.encode(buffer, 7 , HuffmanEncoder.octetsNeeded(value)); HuffmanEncoder.encode(buffer, value); buffer.put(( byte ) 0x00 ); NBitIntegerEncoder.encode(buffer, 7 , value.length()); buffer.put(value.getBytes()); Figure 24.2: EncodableEntry.java , lines 164–177 If value has multibyte characters, it will be incorrectly encoded in lines 174–176. Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. Exploit Scenario A Jetty server attempts to add the Set-Cookie header, setting a cookie value to a UTF-8-encoded string that contains multibyte characters. This causes an incorrect cookie value to be set and the rest of the headers in this message to be parsed incorrectly. 76 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, have the encode function in both EncodableEntry.LiteralEntry and EncodableEntry.ReferencedNameEntry encode the length of the string using string.getBytes() rather than string.length() . 77 OSTIF Eclipse: Jetty Security Assessment 25. No limits on maximum capacity in QPACK decoder Severity: High Diﬃculty: Medium Type: Denial of Service Finding ID: TOB-JETTY-25 Target: ● org.eclipse.jetty.http3.qpack.QpackDecoder ● org.eclipse.jetty.http3.qpack.internal.parser.DecoderInstructi onParser ● org.eclipse.jetty.http3.qpack.internal.table.DynamicTable Description In QPACK, an encoder can set the dynamic table capacity of the decoder using a “Set Dynamic Table Capacity” instruction. The HTTP/3 speciﬁcation requires that the capacity be no larger than the SETTINGS_QPACK_MAX_TABLE_CAPACITY limit chosen by the decoder. However, nowhere in the QPACK code is this limit checked for. This means that the encoder can choose whatever capacity it wants (up to Java’s maximum integer value), allowing it to take up large amounts of space on the decoder’s memory. Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. Exploit Scenario A Jetty server supporting QPACK is running. An attacker opens a connection to the server. He sends a “Set Dynamic Table Capacity” instruction, setting the dynamic table capacity to Java’s maximum integer value, 2 31-1 (2.1 GB). He then repeatedly enters very large values into the server’s dynamic table using an “Insert with Literal Name” instruction until the full 2.1 GB capacity is taken up. The attacker repeats this using multiple connections until the server runs out of memory and crashes. Recommendations Short term, enforce the SETTINGS_QPACK_MAX_TABLE_CAPACITY limit on the capacity. Long term, audit Jetty’s implementation of QPACK and other protocols to ensure that Jetty enforces limits as required by the standards. 78 OSTIF Eclipse: Jetty Security Assessment
9. Risk of integer overﬂow in HPACK's NBitInteger.decode Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-9 Target: org.eclipse.jetty.http2.hpack.internal.NBitInteger Description The static function NBitInteger.decode is used to decode bytestrings in HPACK's integer format. It should return only positive integers since HPACK’s integer format is not intended to support negative numbers. However, the following loop in NBitInteger.decode is susceptible to integer overﬂows in its multiplication and addition operations: public static int decode (ByteBuffer buffer, int n) { if (n == 8 ) { // ... } int nbits = 0xFF >>> ( 8 - n); int i = buffer.get(buffer.position() - 1 ) & nbits; if (i == nbits) { int m = 1 ; int b; do { b = 0xff & buffer.get(); i = i + (b & 127 ) * m; m = m * 128 ; } while ((b & 128 ) == 128 ); } return i; } Figure 9.1: NBitInteger.java , lines 105–145 For example, NBitInteger.decode(0xFF8080FFFF0F, 7) returns -16257 . Any overﬂow that occurs in the function would not be a problem on its own since, in general, the output of this function ought to be validated before it is used; however, when coupled with other issues (refer to TOB-JETTY-10 ), an overﬂow can cause vulnerabilities. 49 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, modify NBitInteger.decode to check that its result is nonnegative before returning it. Long term, consider merging the QPACK and HPACK implementations for NBitInteger , since they perform the same functionality; the QPACK implementation of NBitInteger checks for overﬂows. 50 OSTIF Eclipse: Jetty Security Assessment 
10. MetaDataBuilder.checkSize accepts headers of negative lengths Severity: Medium Diﬃculty: High Type: Denial of Service Finding ID: TOB-JETTY-10 Target: org.eclipse.jetty.http2.hpack.internal.MetaDataBuilder Description The MetaDataBuilder.checkSize function accepts user-entered HPACK header values of negative sizes, which could cause a very large buﬀer to be allocated later when the user-entered size is multiplied by 2. MetaDataBuilder.checkSize determines whether a header name or value exceeds the size limit and throws an exception if the limit is exceeded: public void checkSize ( int length, boolean huffman) throws SessionException { // Apply a huffman fudge factor if (huffman) length = (length * 4 ) / 3 ; if ((_size + length) > _maxSize) throw new HpackException.SessionException( "Header too large %d > %d" , _size + length, _maxSize); } Figure 10.1: MetaDataBuilder.java , lines 291–298 However, it does not throw an exception if the size is negative. Later, the Huffman.decode function multiplies the user-entered length by 2 before allocating a buﬀer: public static String decode (ByteBuffer buffer, int length) throws HpackException.CompressionException { Utf8StringBuilder utf8 = new Utf8StringBuilder(length * 2 ); // ... Figure 10.2: Huffman.java , lines 357–359 This means that if a user provides a negative length value (or, more precisely, a length value that becomes negative when multiplied by the 4/3 fudge factor), and this length value becomes a very large positive number when multiplied by 2, then the user can cause a very large buﬀer to be allocated on the server. 51 OSTIF Eclipse: Jetty Security Assessment Exploit Scenario An attacker repeatedly sends HTTP messages with the HPACK header 0x00ff8080ffff0b . Each time this header is decoded, the following occurs: ● HpackDecode.decode determines that a Huﬀman-coded value of length -1073758081 needs to be decoded. ● MetaDataBuilder.checkSize approves this length. ● The number is multiplied by 2, resulting in 2147451134 , and Huffman.decode allocates a 2.1 GB string array. ● Huffman.decode experiences a buﬀer overﬂow error, and the array is deallocated the next time garbage collection happens. (Note that this deallocation can be delayed by adding valid Huﬀman-coded characters to the end of the header.) Depending on the timing of garbage collection, the number of threads, and the amount of memory available on the server, this may cause the server to run out of memory. Recommendations Short term, have MetaDataBuilder.checkSize check that the given length is positive directly before adding it to _size and comparing it with _maxSize . Long term, add checks for integer overﬂows in Huffman.decode and in NBitInteger.decode (refer to TOB-JETTY-9 ) for added redundancy. 52 OSTIF Eclipse: Jetty Security Assessment 11. Insu cient space allocated when encoding QPACK instructions and entries Severity: Low Diﬃculty: High Type: Denial of Service Finding ID: TOB-JETTY-11 Target: ● org.eclipse.jetty.http3.qpack.internal.instruction.IndexedName EntryInstruction ● org.eclipse.jetty.http3.qpack.internal.instruction.LiteralName EntryInstruction ● org.eclipse.jetty.http3.qpack.internal.instruction.EncodableEn try Description Multiple expressions do not allocate enough buﬀer space when encoding QPACK instructions and entries, which could result in a buﬀer overﬂow exception. In IndexedNameEntry , the following expression determines how much space to allocate when encoding the instruction: int size = NBitIntegerEncoder.octetsNeeded( 6 , _index) + (_huffman ? HuffmanEncoder.octetsNeeded(_value) : _value.length()) + 2 ; Figure 11.1: IndexedNameEntry.java , line 58 Later, the following two lines encode the value size for Huﬀman-coded and non-Huﬀman-coded strings, respectively: NBitIntegerEncoder.encode(byteBuffer, 7 , HuffmanEncoder.octetsNeeded(_value)); // ... NBitIntegerEncoder.encode(byteBuffer, 7 , _value.length()); Figure 11.2: IndexedNameEntry.java , lines 71 and 77 These encodings can take up more than 1 byte if the value’s length is over 126 because the number will ﬁll up the 7 bits given to it in the ﬁrst byte. However, the int size expression in ﬁgure 11.1 assumes that it will take up only 1 byte. Thus, if the value’s length is over 126, too few bytes may be allocated for the instruction, causing a buﬀer overﬂow. The same problem occurs in LiteralNameEntryInstruction : 53 OSTIF Eclipse: Jetty Security Assessment int size = (_huffmanName ? HuffmanEncoder.octetsNeeded(_name) : _name.length()) + (_huffmanValue ? HuffmanEncoder.octetsNeeded(_value) : _value.length()) + 2 ; Figure 11.3: LiteralNameEntryInstruction.java , lines 59–60 This expression assumes that the name's length will ﬁt into 5 bits and that the value’s length will ﬁt into 7 bits. If the name’s length is over 30 bytes or the value’s length is over 126 bytes, these assumptions will be false and too little space may be allocated for the instruction, which could cause a buﬀer overﬂow. A similar problem occurs in EncodableEntry.ReferencedNameEntry . The getRequiredSize method in this ﬁle calculates how much space should be allocated for its encoding: public int getRequiredSize ( int base) { String value = getValue(); int relativeIndex = _nameEntry.getIndex() - base; int valueLength = _huffman ? HuffmanEncoder.octetsNeeded(value) : value.length(); return 1 + NBitIntegerEncoder.octetsNeeded( 4 , relativeIndex) + 1 + NBitIntegerEncoder.octetsNeeded( 7 , valueLength) + valueLength; } Figure 11.4: EncodableEntry.java , lines 181–187 The method returns the wrong size if the value is longer than 126 bytes. Additionally, it assumes that the name will use a post-base reference rather than a normal one, which may be incorrect. An additional problem is present in this method. It assumes that value ’s length in bytes will be returned by value.length() . However, value.length() measures the number of characters in value , not the number of bytes, so if value contains multibyte characters (e.g., UTF-8), too few bytes will be allocated. The length of value should be calculated by using value.getBytes() instead of value.length() . The getRequiredSize method in EncodableEntry.LiteralEntry also incorrectly uses value.length() : public int getRequiredSize ( int base) { String name = getName(); String value = getValue(); int nameLength = _huffman ? HuffmanEncoder.octetsNeeded(name) : name.length(); int valueLength = _huffman ? HuffmanEncoder.octetsNeeded(value) : value.length(); return 2 + NBitIntegerEncoder.octetsNeeded( 3 , nameLength) + nameLength + NBitIntegerEncoder.octetsNeeded( 7 , valueLength) + valueLength; 54 OSTIF Eclipse: Jetty Security Assessment } Figure 11.5: EncodableEntry.java , lines 243–250 Note that name.length() is used to measure the byte length of name , and value.length() is used to measure the byte length of value . Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. Recommendations Short term, change the relevant expressions to account for the extra length. Long term, build out additional test cases for QPACK and other parsers used in HTTP/3 to test for the correct handling of edge cases and identify memory handling exceptions. 55 OSTIF Eclipse: Jetty Security Assessment 12. LiteralNameEntryInstruction incorrectly encodes value length Severity: Medium Diﬃculty: Medium Type: Denial of Service Finding ID: TOB-JETTY-12 Target: org.eclipse.jetty.http3.qpack.internal.instruction.LiteralNameEntryI nstruction Description QPACK instructions for inserting entries with literal names and non-Huﬀman-coded values will be encoded incorrectly when the value’s length is over 30, which could cause values to be sent incorrectly or errors to occur during decoding. The following snippet of the LiteralNameEntryInstruction.encode function is responsible for encoding the header value: if (_huffmanValue) byteBuffer.put(( byte )( 0x80 )); NBitIntegerEncoder.encode(byteBuffer, 7 , HuffmanEncoder.octetsNeeded(_value)); HuffmanEncoder.encode(byteBuffer, _value); 78 79 { 80 81 82 83 } 84 85 { 86 87 88 89 } else byteBuffer.put(( byte )( 0x00 )); NBitIntegerEncoder.encode(byteBuffer, 5 , _value.length()); byteBuffer.put(_value.getBytes()); Figure 12.1: LiteralNameEntryInstruction.java , lines 78–89 On line 87, 5 is the second parameter to NBitIntegerEncoder.encode , indicating that the number will take up 5 bits in the ﬁrst encoded byte; however, the second parameter should be 7 instead. This means that when _value.length() is over 30, it will be incorrectly encoded. Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. 56 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, change the second parameter of the NBitIntegerEncoder.encode function from 5 to 7 in order to reﬂect that the number will take up 7 bits. Long term, write more tests to catch similar encoding/decoding problems. 57 OSTIF Eclipse: Jetty Security Assessment 13. FileInitializer does not check for symlinks Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-13 Target: org.eclipse.jetty.start.FileInitializer Description Module conﬁguration ﬁles can direct Jetty to download a remote ﬁle and save it in the local ﬁlesystem while initializing the module. During this process, the FileInitializer class validates the destination path and throws an IOException exception if the destination is outside the ${jetty.base} directory. However, this validation routine does not check for symlinks: // now on copy/download paths (be safe above all else) if (destination != null && !destination.startsWith(_basehome.getBasePath())) throw new IOException( "For security reasons, Jetty start is unable to process file resource not in ${jetty.base} - " + location); Figure 13.1: FileInitializer.java , lines 112–114 None of the subclasses of FileInitializer check for symlinks either. Thus, if the ${jetty.base} directory contains a symlink, a ﬁle path in a module’s .ini ﬁle beginning with the symlink name will pass the validation check, and the ﬁle will be written to a subdirectory of the symlink’s destination. Exploit Scenario A system’s ${jetty.base} directory contains a symlink called dir , which points to /etc . The system administrator enables a Jetty module whose .ini ﬁle contains a [files] entry that downloads a remote ﬁle and writes it to the relative path dir/config.conf . The ﬁlesystem follows the symlink and writes a new conﬁguration ﬁle to /etc/config.conf , which impacts the server’s system conﬁguration. Additionally, since the FileInitializer class uses the REPLACE_EXISTING ﬂag, this behavior overwrites an existing system conﬁguration ﬁle. Recommendations Short term, rewrite all path checks in FileInitializer and its subclasses to include a call to the Path.toRealPath function, which, by default, will resolve symlinks and produce the real ﬁlesystem path pointed to by the Path object. If this real path is outside ${jetty.base} , the ﬁle write operation should fail. 58 OSTIF Eclipse: Jetty Security Assessment Long term, consolidate all ﬁlesystem operations involving the ${jetty.base} or ${jetty.home} directories into a single centralized class that automatically performs symlink resolution and rejects operations that attempt to read from or write to an unauthorized directory. This class should catch and handle the IOException exception that is thrown in the event of a link loop or a large number of nested symlinks. 59 OSTIF Eclipse: Jetty Security Assessment 14. FileInitializer permits downloading ﬁles via plaintext HTTP Severity: High Diﬃculty: High Type: Data Exposure Finding ID: TOB-JETTY-14 Target: org.eclipse.jetty.start.FileInitializer Description Module conﬁguration ﬁles can direct Jetty to download a remote ﬁle and save it in the local ﬁlesystem while initializing the module. If the speciﬁed URL is a plaintext HTTP URL, Jetty does not raise an error or warn the user. Transmitting ﬁles over plaintext HTTP is intrinsically unsecure and exposes sensitive data to tampering and eavesdropping in transit. Exploit Scenario A system administrator enables a Jetty module that downloads a remote ﬁle over plaintext HTTP during initialization. An attacker with a network intermediary position sniﬀs the traﬃc and infers sensitive information about the design and conﬁguration of the Jetty system under conﬁguration. Alternatively, the attacker actively tampers with the ﬁle during transmission from the remote server to the Jetty installation, which enables the attacker to alter the module’s behavior and launch other attacks against the targeted system. Recommendations Short term, add a check to the FileInitializer class and its subclasses to prohibit downloads over plaintext HTTP. Additionally, add a validation check to the module .ini ﬁle parser to reject any conﬁguration that includes a plaintext HTTP URL in the [files] section. Long term, consolidate all remote ﬁle downloads conducted during module conﬁguration operations into a single centralized class that automatically rejects plaintext HTTP URLs. If current use cases require support of plaintext HTTP URLs, then at a minimum, have Jetty display a prominent warning message and prompt the user for manual conﬁrmation before performing the unencrypted download. 60 OSTIF Eclipse: Jetty Security Assessment 15. NullPointerException thrown by FastCGI parser on invalid frame type Severity: Medium Diﬃculty: Low Type: Data Validation Finding ID: TOB-JETTY-15 Target: org.eclipse.jetty.fcgi.parser.Parser Description Because of a missing null check, the Jetty FastCGI client’s Parser class throws a NullPointerException exception when parsing a frame with an invalid frame type ﬁeld. This exception occurs because the findContentParser function returns null when it does not have a ContentParser object matching the speciﬁed frame type, and the caller never checks the findContentParser return value for null before dereferencing it. case CONTENT: { ContentParser contentParser = findContentParser(headerParser.getFrameType()); if (headerParser.getContentLength() == 0 ) { padding = headerParser.getPaddingLength(); state = State.PADDING; if (contentParser.noContent()) return true ; } else { ContentParser.Result result = contentParser.parse(buffer); // ...[snip]... } break ; } Figure 15.1: Parser.java , lines 82–114 Exploit Scenario An attacker operates a malicious web server that supports FastCGI. A Jetty application communicates with this server by using Jetty’s built-in FastCGI client. The remote server transmits a frame with an invalid frame type, causing a NullPointerException exception and a crash in the Jetty application. Recommendations Short term, add a null check to the parse function to abort the parsing process before dereferencing a null return value from findContentParser . If a null value is detected, 61 OSTIF Eclipse: Jetty Security Assessment parse should throw an appropriate exception, such as IllegalStateException , that Jetty can catch and handle safely. Long term, build out a larger suite of test cases that ensures graceful handling of malformed traﬃc and data. 62 OSTIF Eclipse: Jetty Security Assessment 16. Documentation does not specify that request contents and other user data can be exposed in debug logs Severity: Medium Diﬃculty: High Type: Data Exposure Finding ID: TOB-JETTY-16 Target: Jetty 12 Operations Guide; numerous locations throughout the codebase Description Over 100 times, the system calls LOG.debug with a parameter of the format BufferUtil.toDetailString(buffer) , which outputs up to 56 bytes of the buﬀer into the log ﬁle. Jetty’s implementations of various protocols and encodings, including GZIP, WebSocket, multipart encoding, and HTTP/2, output user data received over the network to the debug log using this type of call. An example instance from Jetty’s WebSocket implementation appears in ﬁgure 16.1. public Frame.Parsed parse (ByteBuffer buffer) throws WebSocketException { try { // parse through while (buffer.hasRemaining()) { if (LOG.isDebugEnabled()) LOG.debug( "{} Parsing {}" , this , BufferUtil.toDetailString(buffer)); // ...[snip]... } // ...[snip]... } // ...[snip]... } Figure 16.1: Parser.java , lines 88–96 Although the Jetty 12 Operations Guide does state that Jetty debugging logs can quickly consume massive amounts of disk space, it does not advise system administrators that the logs can contain sensitive user data, such as personally identiﬁable information. Thus, the possibility of raw traﬃc being captured from debug logs is undocumented. Exploit Scenario A Jetty system administrator turns on debug logging in a production environment. During the normal course of operation, a user sends traﬃc containing sensitive information, such as personally identiﬁable information or ﬁnancial data, and this data is recorded to the 63 OSTIF Eclipse: Jetty Security Assessment debug log. An attacker who gains access to this log can then read the user data, compromising data conﬁdentiality and the user’s privacy rights. Recommendations Short term, update the Jetty Operations Guide to state that in addition to being extremely large, debug logs can contain sensitive user data and should be treated as sensitive. Long term, consider moving all debugging messages that contain buﬀer excerpts into a high-detail debug log that is enabled only for debug builds of the application. 64 OSTIF Eclipse: Jetty Security Assessment 17. HttpStreamOverFCGI internally marks all requests as plaintext HTTP Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-17 Target: org.eclipse.jetty.fcgi.server.internal.HttpStreamOverFCGI Description The HttpStreamOverFCGI class processes FastCGI messages in a format that can be processed by other system components that use the HttpStream interface. This class’s onHeaders callback mistakenly marks each MetaData.Request object as a plaintext HTTP request, as the “TODO” comment shown in ﬁgure 17.1 indicates: public void onHeaders () { String pathQuery = URIUtil.addPathQuery(_path, _query); // TODO https? MetaData.Request request = new MetaData.Request(_method, HttpScheme.HTTP.asString(), hostPort, pathQuery, HttpVersion.fromString(_version), _headers, Long.MIN_VALUE); // ...[snip]... } Figure 17.1: HttpStreamOverFCGI.java , lines 108–119 In some conﬁgurations, other Jetty components could misinterpret a message received over FCGI as a plaintext HTTP message, which could cause a request to be incorrectly rejected, redirected in an inﬁnite loop, or forwarded to another system over a plaintext HTTP channel instead of HTTPS. Exploit Scenario A Jetty instance runs an FCGI server and uses the HttpStream interface to process messages. The MetaData.Request class’s getURI method is used to check the incoming request’s URI. This method mistakenly returns a plaintext HTTP URL due to the bug in HttpStreamOverFCGI.java . One of the following takes place during the processing of this request: ● ● An application-level security control checks the incoming request’s URI to ensure it was received over a TLS-encrypted channel. Since this check fails, the application rejects the request and refuses to process it, causing a denial of service. An application-level security control checks the incoming request’s URI to ensure it was received over a TLS-encrypted channel. Since this check fails, the application 65 OSTIF Eclipse: Jetty Security Assessment attempts to redirect the user to a suitable HTTPS URL. The check fails on this redirected request as well, causing an inﬁnite redirect loop and a denial of service. ● An application processing FCGI messages acts as a proxy, forwarding certain requests to a third HTTP server. It uses MetaData.Request.getURI to check the request’s original URI and mistakenly sends a request over plaintext HTTP. Recommendations Short term, correct the bug in HttpStreamOverFCGI.java to generate the correct URI for the incoming request. Long term, consider streamlining the HTTP implementation to minimize the need for diﬀerent classes to generate URIs from request data. 66 OSTIF Eclipse: Jetty Security Assessment 18. Excessively permissive and non-standards-compliant error handling in HTTP/2 implementation Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-18 Target: The org.eclipse.jetty.http2.parser and org.eclipse.jetty.http2.parser packages Description Jetty’s HTTP/2 implementation violates RFC 9113 in that it fails to terminate a connection with an appropriate error code when the remote peer sends a frame with one of the following protocol violations: ● ● ● A SETTINGS frame with the ACK ﬂag set and a nonzero payload length A PUSH_PROMISE frame in a stream with push disabled A GOAWAY frame with its stream ID not set to zero None of these situations creates an exploitable vulnerability. However, noncompliant protocol implementations can create compatibility problems and could cause vulnerabilities when deployed in combination with other misconﬁgured systems. Exploit Scenario A Jetty instance connects to an HTTP/2 server, or serves a connection from an HTTP/2 client, and the remote peer sends traﬃc that should cause Jetty to terminate the connection. Instead, Jetty keeps the connection alive, in violation of RFC 9113. If the remote peer is programmed to handle the noncompliant traﬃc diﬀerently than Jetty, further problems could result, as the two implementations interpret protocol messages diﬀerently. Recommendations Short term, update the HTTP/2 implementation to check for the following error conditions and terminate the connection with an error code that complies with RFC 9113: ● ● A peer receives a SETTINGS frame with the ACK ﬂag set and a payload length greater than zero. A client receives a PUSH_PROMISE frame after having sent, and received an acknowledgement for, a SETTINGS frame with SETTINGS_ENABLE_PUSH equal to zero. 67 OSTIF Eclipse: Jetty Security Assessment ● A peer receives a GOAWAY frame with the stream identiﬁer ﬁeld not set to zero. Long term, audit Jetty’s implementation of HTTP/2 and other protocols to ensure that Jetty handles errors in a standards-compliant manner and terminates connections as required by the applicable speciﬁcations. 68 OSTIF Eclipse: Jetty Security Assessment 19. XML external entities and entity expansion in Maven package metadata parser Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-19 Target: org.eclipse.jetty.start.fileinits.MavenMetadata Description During module initialization, the MavenMetadata class parses maven-metadata.xml ﬁles when the module conﬁguration includes a maven:// URI in its [files] section. The DocumentBuilderFactory class is used with its default settings, meaning that document type deﬁnitions (DTD) are allowed and are applied. This behavior leaves the MavenMetadata class vulnerable to XML external entity (XXE) and XML entity expansion (XEE) attacks. These vulnerabilities could enable a variety of exploits, including server-side request forgery on the server’s local network and arbitrary ﬁle reads from the server’s ﬁlesystem. Exploit Scenario An attacker causes a Jetty installation to parse a maliciously crafted maven-metadata.xml ﬁle, such as by uploading a malicious package to a Maven repository, inducing an out-of-band download of the malicious package through social engineering, or by placing the maven-metadata.xml ﬁle on the server’s ﬁlesystem through other means. When the XML ﬁle is parsed, the XML-based attack is launched. The attacker could leverage this vector to do any of the following: ● ● ● Induce HTTP requests to servers on the server’s local network Read and exﬁltrate arbitrary ﬁles on the server’s ﬁlesystem Consume excessive system resources with an XEE, causing a denial of service Recommendations Short term, disable parsing of DTDs in MavenMetadata so that maven-metadata.xml ﬁles cannot be used as a vector for XML-based attacks. Disabling DTDs may require knowledge of the underlying XML parser implementation returned by the DocumentBuilderFactory class. Long term, review default conﬁgurations and attributes supported by XML parsers that may be returned by the DocumentBuilderFactory to ensure that DTDs are properly disabled. 69 OSTIF Eclipse: Jetty Security Assessment 20. Use of deprecated AccessController class Severity: Informational Diﬃculty: N/A Type: Code Quality Finding ID: TOB-JETTY-20 Target: ● org.eclipse.jetty.logging.JettyLoggerConfiguration ● org.eclipse.jetty.util.MemoryUtils ● org.eclipse.jetty.util.TypeUtil ● org.eclipse.jetty.util.thread.PrivilegedThreadFactory ● org.eclipse.jetty.ee10.servlet.ServletContextHandler ● org.eclipse.jetty.ee9.nested.ContextHandler Description The classes listed in the “Target” cell above use the java.security.AccessController class, which is a deprecated class slated to be removed in a future Java release. The java.security library documentation states that the AccessController class “is only useful in conjunction with the Security Manager,” which is also deprecated. Thus, the use of AccessController no longer serves any beneﬁcial purpose. The use of this deprecated class could impact Jetty’s compatibility with future releases of the Java SDK. Recommendations Short term, remove all uses of the AccessController class. Long term, audit the Jetty codebase for the use of classes in the java.security package that may not provide any value in Jetty 12, and remove all references to those classes. 70 OSTIF Eclipse: Jetty Security Assessment 21. QUIC server writes SSL private key to temporary plaintext ﬁle Severity: High Diﬃculty: High Type: Cryptography Finding ID: TOB-JETTY-21 Target: org.eclipse.jetty.quic.server.QuicServerConnector Description Jetty’s QUIC implementation uses quiche, a QUIC and HTTP/3 library maintained by Cloudﬂare. When the server’s SSL certiﬁcate is handed oﬀ to quiche, the private key is extracted from the existing keystore and written to a temporary plaintext PEM ﬁle: protected void doStart () throws Exception { // ...[snip]... char [] keyStorePassword = sslContextFactory.getKeyStorePassword().toCharArray(); String keyManagerPassword = sslContextFactory.getKeyManagerPassword(); SSLKeyPair keyPair = new SSLKeyPair( sslContextFactory.getKeyStoreResource().getPath(), sslContextFactory.getKeyStoreType(), keyStorePassword, alias, keyManagerPassword == null ? keyStorePassword : keyManagerPassword.toCharArray() ); File[] pemFiles = keyPair.export( new File(System.getProperty( "java.io.tmpdir" ))); privateKeyFile = pemFiles[ 0 ]; certificateChainFile = pemFiles[ 1 ]; } Figure 21.1: QuicServerConnector.java , lines 154–179 Storing the private key in this manner exposes it to increased risk of theft. Although the QuicServerConnector class deletes the private key ﬁle upon stopping the server, this deleted ﬁle may not be immediately removed from the physical storage medium, exposing the ﬁle to potential theft by attackers who can access the raw bytes on the disk. A review of quiche suggests that the library’s API may not support reading a DES-encrypted keyﬁle. If that is true, then remediating this issue would require updates to the underlying quiche library. 71 OSTIF Eclipse: Jetty Security Assessment Exploit Scenario An attacker gains read access to a Jetty HTTP/3 server’s temporary directory while the server is running. The attacker can retrieve the temporary keyﬁle and read the private key without needing to obtain or guess the encryption key for the original keystore. With this private key in hand, the attacker decrypts and tampers with all TLS communications that use the associated certiﬁcate. Recommendations Short term, investigate the quiche library’s API to determine whether it can readily support password-encrypted private keyﬁles. If so, update Jetty to save the private key in a temporary password-protected ﬁle and to forward that password to quiche. Alternatively, if password-encrypted private keyﬁles can be supported, have Jetty pass the unencrypted private key directly to quiche as a function argument. Either option would obviate the need to store the key in a plaintext ﬁle on the server’s ﬁlesystem. If quiche does not support either of these changes, open an issue or pull request for quiche to implement a ﬁx for this issue. 72 OSTIF Eclipse: Jetty Security Assessment 22. Repeated code between HPACK and QPACK Severity: Informational Diﬃculty: N/A Type: Code Quality Finding ID: TOB-JETTY-22 Target: ● org.eclipse.jetty.http2.hpack.internal.NBitInteger ● org.eclipse.jetty.http2.hpack.internal.Huffman ● org.eclipse.jetty.http3.qpack.internal.util.NBitIntegerParser ● org.eclipse.jetty.http3.qpack.internal.util.NBitIntegerEncode ● org.eclipse.jetty.http3.qpack.internal.util.HuffmanDecoder ● org.eclipse.jetty.http3.qpack.internal.util.HuffmanEncoder Description Classes for dealing with n-bit integers and Huﬀman coding are implemented both in the jetty-http2-hpack and in jetty-http3-qpack libraries. These classes have very similar functionality but are implemented in two diﬀerent places, sometimes with identical code and other times with diﬀerent implementations. In some cases ( TOB-JETTY-9 ), one implementation has a bug that the other implementation does not have. The codebase would be easier to maintain and keep secure if the implementations were merged. Exploit Scenario A vulnerability is found in the Huﬀman encoding implementation, which has identical code in HPACK and QPACK. The vulnerability is ﬁxed in one implementation but not the other, leaving one of the implementations vulnerable. Recommendations Short term, merge the two implementations of n-bit integers and Huﬀman coding classes. Long term, audit the Jetty codebase for other classes with very similar functionality. 73 OSTIF Eclipse: Jetty Security Assessment 23. Various exceptions in HpackDecoder.decode and QpackDecoder.decode Severity: Informational Diﬃculty: N/A Type: Denial of Service Finding ID: TOB-JETTY-23 Target: org.eclipse.jetty.http2.hpack.HpackDecoder , org.eclipse.jetty.http3.qpack.QpackDecoder Description The HpackDecoder and QpackDecoder classes both throw unexpected Java-level exceptions: ● HpackDecoder.decode(0x03) throws BufferUnderflowException . ● HpackDecoder.decode(0x4800) throws NumberFormatException . ● HpackDecoder.decode(0x3fff 2e) throws IllegalArgumentException . ● HpackDecoder.decode(0x3fff 81ff ff2e) throws NullPointerException . ● HpackDecoder.decode(0xffff ffff f8ff ffff ffff ffff ffff ffff ffff ffff ffff ffff 0202 0000) throws ArrayIndexOutOfBoundsException . ● QpackDecoder.decode(..., 0x81, ...) throws IndexOutOfBoundsException . ● QpackDecoder.decode(..., 0xfff8 ffff f75b, ...) throws ArithmeticException . For both HPACK and QPACK, these exceptions appear to be caught higher up in the call chain by catch (Throwable x) statements every time the decode functions are called. However, catching them within decode and throwing a Jetty-level exception within the catch statement would result in cleaner, more robust code. Exploit Scenario Jetty developers refactor the codebase, moving function calls around and introducing a new point in the code where HpackDecoder.decode is called. Assuming that decode will throw only org.jetty… errors, they forget to wrap this call in a catch (Throwable x) statement. This results in a DoS vulnerability. Recommendations Short term, document in the code that Java-level exceptions can be thrown. Long term, modify the decode functions so that they throw only Jetty-level exceptions. 74 OSTIF Eclipse: Jetty Security Assessment 24. Incorrect QPACK encoding when multi-byte characters are used Severity: Medium Diﬃculty: Medium Type: Data Validation Finding ID: TOB-JETTY-24 Target: org.eclipse.jetty.http3.qpack.internal.EncodableEntry Description Java’s string.length() function returns the number of characters in a string, which can be diﬀerent from the number of bytes returned by the string.getBytes() function. However, QPACK encoding methods assume that they return the same number, which could cause incorrect encodings. In EncodableEntry.LiteralEntry , which is used to encode HTTP/3 header ﬁelds, the following method is used for encoding: public void encode (ByteBuffer buffer, int base) 214 215 { 216 byte allowIntermediary = 0x00 ; // TODO: this is 0x10 bit, when should this be set? 217 218 219 220 221 222 223 224 String name = getName(); String value = getValue(); // Encode the prefix code and the name. if (_huffman) { buffer.put(( byte )( 0x28 | allowIntermediary)); NBitIntegerEncoder.encode(buffer, 3 , HuffmanEncoder.octetsNeeded(name)); 225 226 227 HuffmanEncoder.encode(buffer, name); buffer.put(( byte ) 0x80 ); NBitIntegerEncoder.encode(buffer, 7 , HuffmanEncoder.octetsNeeded(value)); 228 229 230 231 232 HuffmanEncoder.encode(buffer, value); } else { // TODO: What charset should we be using? (this applies to the instruction generators as well). 233 234 235 236 237 238 buffer.put(( byte )( 0x20 | allowIntermediary)); NBitIntegerEncoder.encode(buffer, 3 , name.length()); buffer.put(name.getBytes()); buffer.put(( byte ) 0x00 ); NBitIntegerEncoder.encode(buffer, 7 , value.length()); buffer.put(value.getBytes()); 75 OSTIF Eclipse: Jetty Security Assessment 239 240 } } Figure 24.1: EncodableEntry.java , lines 214–240 Note in particular lines 232–238, which are used to encode literal (non-Huﬀman-coded) names and values. The value returned by name.length() is added to the bytestring, followed by the value returned by name.getBytes() . Then, the value returned by value.length() is added to the bytestring, followed by the value returned by value.getBytes() . When this bytestring is decoded, the decoder will read the name length ﬁeld and then read that many bytes as the name. If multibyte characters were used in the name ﬁeld, the decoder will read too few bytes. The rest of the bytestring will also be decoded incorrectly, since the decoder will continue reading at the wrong point in the bytestring. The same issue occurs if multibyte characters were used in the value ﬁeld. The same issue appears in EncodableEntry.ReferencedNameEntry.encode : if (_huffman) 164 // Encode the value. 165 String value = getValue(); 166 167 { 168 169 170 171 } 172 173 { 174 175 176 177 } else buffer.put(( byte ) 0x80 ); NBitIntegerEncoder.encode(buffer, 7 , HuffmanEncoder.octetsNeeded(value)); HuffmanEncoder.encode(buffer, value); buffer.put(( byte ) 0x00 ); NBitIntegerEncoder.encode(buffer, 7 , value.length()); buffer.put(value.getBytes()); Figure 24.2: EncodableEntry.java , lines 164–177 If value has multibyte characters, it will be incorrectly encoded in lines 174–176. Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. Exploit Scenario A Jetty server attempts to add the Set-Cookie header, setting a cookie value to a UTF-8-encoded string that contains multibyte characters. This causes an incorrect cookie value to be set and the rest of the headers in this message to be parsed incorrectly. 76 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, have the encode function in both EncodableEntry.LiteralEntry and EncodableEntry.ReferencedNameEntry encode the length of the string using string.getBytes() rather than string.length() . 77 OSTIF Eclipse: Jetty Security Assessment 25. No limits on maximum capacity in QPACK decoder Severity: High Diﬃculty: Medium Type: Denial of Service Finding ID: TOB-JETTY-25 Target: ● org.eclipse.jetty.http3.qpack.QpackDecoder ● org.eclipse.jetty.http3.qpack.internal.parser.DecoderInstructi onParser ● org.eclipse.jetty.http3.qpack.internal.table.DynamicTable Description In QPACK, an encoder can set the dynamic table capacity of the decoder using a “Set Dynamic Table Capacity” instruction. The HTTP/3 speciﬁcation requires that the capacity be no larger than the SETTINGS_QPACK_MAX_TABLE_CAPACITY limit chosen by the decoder. However, nowhere in the QPACK code is this limit checked for. This means that the encoder can choose whatever capacity it wants (up to Java’s maximum integer value), allowing it to take up large amounts of space on the decoder’s memory. Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. Exploit Scenario A Jetty server supporting QPACK is running. An attacker opens a connection to the server. He sends a “Set Dynamic Table Capacity” instruction, setting the dynamic table capacity to Java’s maximum integer value, 2 31-1 (2.1 GB). He then repeatedly enters very large values into the server’s dynamic table using an “Insert with Literal Name” instruction until the full 2.1 GB capacity is taken up. The attacker repeats this using multiple connections until the server runs out of memory and crashes. Recommendations Short term, enforce the SETTINGS_QPACK_MAX_TABLE_CAPACITY limit on the capacity. Long term, audit Jetty’s implementation of QPACK and other protocols to ensure that Jetty enforces limits as required by the standards. 78 OSTIF Eclipse: Jetty Security Assessment
12. LiteralNameEntryInstruction incorrectly encodes value length Severity: Medium Diﬃculty: Medium Type: Denial of Service Finding ID: TOB-JETTY-12 Target: org.eclipse.jetty.http3.qpack.internal.instruction.LiteralNameEntryI nstruction Description QPACK instructions for inserting entries with literal names and non-Huﬀman-coded values will be encoded incorrectly when the value’s length is over 30, which could cause values to be sent incorrectly or errors to occur during decoding. The following snippet of the LiteralNameEntryInstruction.encode function is responsible for encoding the header value: if (_huffmanValue) byteBuffer.put(( byte )( 0x80 )); NBitIntegerEncoder.encode(byteBuffer, 7 , HuffmanEncoder.octetsNeeded(_value)); HuffmanEncoder.encode(byteBuffer, _value); 78 79 { 80 81 82 83 } 84 85 { 86 87 88 89 } else byteBuffer.put(( byte )( 0x00 )); NBitIntegerEncoder.encode(byteBuffer, 5 , _value.length()); byteBuffer.put(_value.getBytes()); Figure 12.1: LiteralNameEntryInstruction.java , lines 78–89 On line 87, 5 is the second parameter to NBitIntegerEncoder.encode , indicating that the number will take up 5 bits in the ﬁrst encoded byte; however, the second parameter should be 7 instead. This means that when _value.length() is over 30, it will be incorrectly encoded. Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. 56 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, change the second parameter of the NBitIntegerEncoder.encode function from 5 to 7 in order to reﬂect that the number will take up 7 bits. Long term, write more tests to catch similar encoding/decoding problems. 57 OSTIF Eclipse: Jetty Security Assessment 
13. FileInitializer does not check for symlinks Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-13 Target: org.eclipse.jetty.start.FileInitializer Description Module conﬁguration ﬁles can direct Jetty to download a remote ﬁle and save it in the local ﬁlesystem while initializing the module. During this process, the FileInitializer class validates the destination path and throws an IOException exception if the destination is outside the ${jetty.base} directory. However, this validation routine does not check for symlinks: // now on copy/download paths (be safe above all else) if (destination != null && !destination.startsWith(_basehome.getBasePath())) throw new IOException( "For security reasons, Jetty start is unable to process file resource not in ${jetty.base} - " + location); Figure 13.1: FileInitializer.java , lines 112–114 None of the subclasses of FileInitializer check for symlinks either. Thus, if the ${jetty.base} directory contains a symlink, a ﬁle path in a module’s .ini ﬁle beginning with the symlink name will pass the validation check, and the ﬁle will be written to a subdirectory of the symlink’s destination. Exploit Scenario A system’s ${jetty.base} directory contains a symlink called dir , which points to /etc . The system administrator enables a Jetty module whose .ini ﬁle contains a [files] entry that downloads a remote ﬁle and writes it to the relative path dir/config.conf . The ﬁlesystem follows the symlink and writes a new conﬁguration ﬁle to /etc/config.conf , which impacts the server’s system conﬁguration. Additionally, since the FileInitializer class uses the REPLACE_EXISTING ﬂag, this behavior overwrites an existing system conﬁguration ﬁle. Recommendations Short term, rewrite all path checks in FileInitializer and its subclasses to include a call to the Path.toRealPath function, which, by default, will resolve symlinks and produce the real ﬁlesystem path pointed to by the Path object. If this real path is outside ${jetty.base} , the ﬁle write operation should fail. 58 OSTIF Eclipse: Jetty Security Assessment Long term, consolidate all ﬁlesystem operations involving the ${jetty.base} or ${jetty.home} directories into a single centralized class that automatically performs symlink resolution and rejects operations that attempt to read from or write to an unauthorized directory. This class should catch and handle the IOException exception that is thrown in the event of a link loop or a large number of nested symlinks. 59 OSTIF Eclipse: Jetty Security Assessment 
14. FileInitializer permits downloading ﬁles via plaintext HTTP Severity: High Diﬃculty: High Type: Data Exposure Finding ID: TOB-JETTY-14 Target: org.eclipse.jetty.start.FileInitializer Description Module conﬁguration ﬁles can direct Jetty to download a remote ﬁle and save it in the local ﬁlesystem while initializing the module. If the speciﬁed URL is a plaintext HTTP URL, Jetty does not raise an error or warn the user. Transmitting ﬁles over plaintext HTTP is intrinsically unsecure and exposes sensitive data to tampering and eavesdropping in transit. Exploit Scenario A system administrator enables a Jetty module that downloads a remote ﬁle over plaintext HTTP during initialization. An attacker with a network intermediary position sniﬀs the traﬃc and infers sensitive information about the design and conﬁguration of the Jetty system under conﬁguration. Alternatively, the attacker actively tampers with the ﬁle during transmission from the remote server to the Jetty installation, which enables the attacker to alter the module’s behavior and launch other attacks against the targeted system. Recommendations Short term, add a check to the FileInitializer class and its subclasses to prohibit downloads over plaintext HTTP. Additionally, add a validation check to the module .ini ﬁle parser to reject any conﬁguration that includes a plaintext HTTP URL in the [files] section. Long term, consolidate all remote ﬁle downloads conducted during module conﬁguration operations into a single centralized class that automatically rejects plaintext HTTP URLs. If current use cases require support of plaintext HTTP URLs, then at a minimum, have Jetty display a prominent warning message and prompt the user for manual conﬁrmation before performing the unencrypted download. 60 OSTIF Eclipse: Jetty Security Assessment 
15. NullPointerException thrown by FastCGI parser on invalid frame type Severity: Medium Diﬃculty: Low Type: Data Validation Finding ID: TOB-JETTY-15 Target: org.eclipse.jetty.fcgi.parser.Parser Description Because of a missing null check, the Jetty FastCGI client’s Parser class throws a NullPointerException exception when parsing a frame with an invalid frame type ﬁeld. This exception occurs because the findContentParser function returns null when it does not have a ContentParser object matching the speciﬁed frame type, and the caller never checks the findContentParser return value for null before dereferencing it. case CONTENT: { ContentParser contentParser = findContentParser(headerParser.getFrameType()); if (headerParser.getContentLength() == 0 ) { padding = headerParser.getPaddingLength(); state = State.PADDING; if (contentParser.noContent()) return true ; } else { ContentParser.Result result = contentParser.parse(buffer); // ...[snip]... } break ; } Figure 15.1: Parser.java , lines 82–114 Exploit Scenario An attacker operates a malicious web server that supports FastCGI. A Jetty application communicates with this server by using Jetty’s built-in FastCGI client. The remote server transmits a frame with an invalid frame type, causing a NullPointerException exception and a crash in the Jetty application. Recommendations Short term, add a null check to the parse function to abort the parsing process before dereferencing a null return value from findContentParser . If a null value is detected, 61 OSTIF Eclipse: Jetty Security Assessment parse should throw an appropriate exception, such as IllegalStateException , that Jetty can catch and handle safely. Long term, build out a larger suite of test cases that ensures graceful handling of malformed traﬃc and data. 62 OSTIF Eclipse: Jetty Security Assessment 
16. Documentation does not specify that request contents and other user data can be exposed in debug logs Severity: Medium Diﬃculty: High Type: Data Exposure Finding ID: TOB-JETTY-16 Target: Jetty 12 Operations Guide; numerous locations throughout the codebase Description Over 100 times, the system calls LOG.debug with a parameter of the format BufferUtil.toDetailString(buffer) , which outputs up to 56 bytes of the buﬀer into the log ﬁle. Jetty’s implementations of various protocols and encodings, including GZIP, WebSocket, multipart encoding, and HTTP/2, output user data received over the network to the debug log using this type of call. An example instance from Jetty’s WebSocket implementation appears in ﬁgure 16.1. public Frame.Parsed parse (ByteBuffer buffer) throws WebSocketException { try { // parse through while (buffer.hasRemaining()) { if (LOG.isDebugEnabled()) LOG.debug( "{} Parsing {}" , this , BufferUtil.toDetailString(buffer)); // ...[snip]... } // ...[snip]... } // ...[snip]... } Figure 16.1: Parser.java , lines 88–96 Although the Jetty 12 Operations Guide does state that Jetty debugging logs can quickly consume massive amounts of disk space, it does not advise system administrators that the logs can contain sensitive user data, such as personally identiﬁable information. Thus, the possibility of raw traﬃc being captured from debug logs is undocumented. Exploit Scenario A Jetty system administrator turns on debug logging in a production environment. During the normal course of operation, a user sends traﬃc containing sensitive information, such as personally identiﬁable information or ﬁnancial data, and this data is recorded to the 63 OSTIF Eclipse: Jetty Security Assessment debug log. An attacker who gains access to this log can then read the user data, compromising data conﬁdentiality and the user’s privacy rights. Recommendations Short term, update the Jetty Operations Guide to state that in addition to being extremely large, debug logs can contain sensitive user data and should be treated as sensitive. Long term, consider moving all debugging messages that contain buﬀer excerpts into a high-detail debug log that is enabled only for debug builds of the application. 64 OSTIF Eclipse: Jetty Security Assessment 
17. HttpStreamOverFCGI internally marks all requests as plaintext HTTP Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-17 Target: org.eclipse.jetty.fcgi.server.internal.HttpStreamOverFCGI Description The HttpStreamOverFCGI class processes FastCGI messages in a format that can be processed by other system components that use the HttpStream interface. This class’s onHeaders callback mistakenly marks each MetaData.Request object as a plaintext HTTP request, as the “TODO” comment shown in ﬁgure 17.1 indicates: public void onHeaders () { String pathQuery = URIUtil.addPathQuery(_path, _query); // TODO https? MetaData.Request request = new MetaData.Request(_method, HttpScheme.HTTP.asString(), hostPort, pathQuery, HttpVersion.fromString(_version), _headers, Long.MIN_VALUE); // ...[snip]... } Figure 17.1: HttpStreamOverFCGI.java , lines 108–119 In some conﬁgurations, other Jetty components could misinterpret a message received over FCGI as a plaintext HTTP message, which could cause a request to be incorrectly rejected, redirected in an inﬁnite loop, or forwarded to another system over a plaintext HTTP channel instead of HTTPS. Exploit Scenario A Jetty instance runs an FCGI server and uses the HttpStream interface to process messages. The MetaData.Request class’s getURI method is used to check the incoming request’s URI. This method mistakenly returns a plaintext HTTP URL due to the bug in HttpStreamOverFCGI.java . One of the following takes place during the processing of this request: ● ● An application-level security control checks the incoming request’s URI to ensure it was received over a TLS-encrypted channel. Since this check fails, the application rejects the request and refuses to process it, causing a denial of service. An application-level security control checks the incoming request’s URI to ensure it was received over a TLS-encrypted channel. Since this check fails, the application 65 OSTIF Eclipse: Jetty Security Assessment attempts to redirect the user to a suitable HTTPS URL. The check fails on this redirected request as well, causing an inﬁnite redirect loop and a denial of service. ● An application processing FCGI messages acts as a proxy, forwarding certain requests to a third HTTP server. It uses MetaData.Request.getURI to check the request’s original URI and mistakenly sends a request over plaintext HTTP. Recommendations Short term, correct the bug in HttpStreamOverFCGI.java to generate the correct URI for the incoming request. Long term, consider streamlining the HTTP implementation to minimize the need for diﬀerent classes to generate URIs from request data. 66 OSTIF Eclipse: Jetty Security Assessment 
18. Excessively permissive and non-standards-compliant error handling in HTTP/2 implementation Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-18 Target: The org.eclipse.jetty.http2.parser and org.eclipse.jetty.http2.parser packages Description Jetty’s HTTP/2 implementation violates RFC 9113 in that it fails to terminate a connection with an appropriate error code when the remote peer sends a frame with one of the following protocol violations: ● ● ● A SETTINGS frame with the ACK ﬂag set and a nonzero payload length A PUSH_PROMISE frame in a stream with push disabled A GOAWAY frame with its stream ID not set to zero None of these situations creates an exploitable vulnerability. However, noncompliant protocol implementations can create compatibility problems and could cause vulnerabilities when deployed in combination with other misconﬁgured systems. Exploit Scenario A Jetty instance connects to an HTTP/2 server, or serves a connection from an HTTP/2 client, and the remote peer sends traﬃc that should cause Jetty to terminate the connection. Instead, Jetty keeps the connection alive, in violation of RFC 9113. If the remote peer is programmed to handle the noncompliant traﬃc diﬀerently than Jetty, further problems could result, as the two implementations interpret protocol messages diﬀerently. Recommendations Short term, update the HTTP/2 implementation to check for the following error conditions and terminate the connection with an error code that complies with RFC 9113: ● ● A peer receives a SETTINGS frame with the ACK ﬂag set and a payload length greater than zero. A client receives a PUSH_PROMISE frame after having sent, and received an acknowledgement for, a SETTINGS frame with SETTINGS_ENABLE_PUSH equal to zero. 67 OSTIF Eclipse: Jetty Security Assessment ● A peer receives a GOAWAY frame with the stream identiﬁer ﬁeld not set to zero. Long term, audit Jetty’s implementation of HTTP/2 and other protocols to ensure that Jetty handles errors in a standards-compliant manner and terminates connections as required by the applicable speciﬁcations. 68 OSTIF Eclipse: Jetty Security Assessment 19. XML external entities and entity expansion in Maven package metadata parser Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-JETTY-19 Target: org.eclipse.jetty.start.fileinits.MavenMetadata Description During module initialization, the MavenMetadata class parses maven-metadata.xml ﬁles when the module conﬁguration includes a maven:// URI in its [files] section. The DocumentBuilderFactory class is used with its default settings, meaning that document type deﬁnitions (DTD) are allowed and are applied. This behavior leaves the MavenMetadata class vulnerable to XML external entity (XXE) and XML entity expansion (XEE) attacks. These vulnerabilities could enable a variety of exploits, including server-side request forgery on the server’s local network and arbitrary ﬁle reads from the server’s ﬁlesystem. Exploit Scenario An attacker causes a Jetty installation to parse a maliciously crafted maven-metadata.xml ﬁle, such as by uploading a malicious package to a Maven repository, inducing an out-of-band download of the malicious package through social engineering, or by placing the maven-metadata.xml ﬁle on the server’s ﬁlesystem through other means. When the XML ﬁle is parsed, the XML-based attack is launched. The attacker could leverage this vector to do any of the following: ● ● ● Induce HTTP requests to servers on the server’s local network Read and exﬁltrate arbitrary ﬁles on the server’s ﬁlesystem Consume excessive system resources with an XEE, causing a denial of service Recommendations Short term, disable parsing of DTDs in MavenMetadata so that maven-metadata.xml ﬁles cannot be used as a vector for XML-based attacks. Disabling DTDs may require knowledge of the underlying XML parser implementation returned by the DocumentBuilderFactory class. Long term, review default conﬁgurations and attributes supported by XML parsers that may be returned by the DocumentBuilderFactory to ensure that DTDs are properly disabled. 69 OSTIF Eclipse: Jetty Security Assessment 20. Use of deprecated AccessController class Severity: Informational Diﬃculty: N/A Type: Code Quality Finding ID: TOB-JETTY-20 Target: ● org.eclipse.jetty.logging.JettyLoggerConfiguration ● org.eclipse.jetty.util.MemoryUtils ● org.eclipse.jetty.util.TypeUtil ● org.eclipse.jetty.util.thread.PrivilegedThreadFactory ● org.eclipse.jetty.ee10.servlet.ServletContextHandler ● org.eclipse.jetty.ee9.nested.ContextHandler Description The classes listed in the “Target” cell above use the java.security.AccessController class, which is a deprecated class slated to be removed in a future Java release. The java.security library documentation states that the AccessController class “is only useful in conjunction with the Security Manager,” which is also deprecated. Thus, the use of AccessController no longer serves any beneﬁcial purpose. The use of this deprecated class could impact Jetty’s compatibility with future releases of the Java SDK. Recommendations Short term, remove all uses of the AccessController class. Long term, audit the Jetty codebase for the use of classes in the java.security package that may not provide any value in Jetty 12, and remove all references to those classes. 70 OSTIF Eclipse: Jetty Security Assessment 21. QUIC server writes SSL private key to temporary plaintext ﬁle Severity: High Diﬃculty: High Type: Cryptography Finding ID: TOB-JETTY-21 Target: org.eclipse.jetty.quic.server.QuicServerConnector Description Jetty’s QUIC implementation uses quiche, a QUIC and HTTP/3 library maintained by Cloudﬂare. When the server’s SSL certiﬁcate is handed oﬀ to quiche, the private key is extracted from the existing keystore and written to a temporary plaintext PEM ﬁle: protected void doStart () throws Exception { // ...[snip]... char [] keyStorePassword = sslContextFactory.getKeyStorePassword().toCharArray(); String keyManagerPassword = sslContextFactory.getKeyManagerPassword(); SSLKeyPair keyPair = new SSLKeyPair( sslContextFactory.getKeyStoreResource().getPath(), sslContextFactory.getKeyStoreType(), keyStorePassword, alias, keyManagerPassword == null ? keyStorePassword : keyManagerPassword.toCharArray() ); File[] pemFiles = keyPair.export( new File(System.getProperty( "java.io.tmpdir" ))); privateKeyFile = pemFiles[ 0 ]; certificateChainFile = pemFiles[ 1 ]; } Figure 21.1: QuicServerConnector.java , lines 154–179 Storing the private key in this manner exposes it to increased risk of theft. Although the QuicServerConnector class deletes the private key ﬁle upon stopping the server, this deleted ﬁle may not be immediately removed from the physical storage medium, exposing the ﬁle to potential theft by attackers who can access the raw bytes on the disk. A review of quiche suggests that the library’s API may not support reading a DES-encrypted keyﬁle. If that is true, then remediating this issue would require updates to the underlying quiche library. 71 OSTIF Eclipse: Jetty Security Assessment Exploit Scenario An attacker gains read access to a Jetty HTTP/3 server’s temporary directory while the server is running. The attacker can retrieve the temporary keyﬁle and read the private key without needing to obtain or guess the encryption key for the original keystore. With this private key in hand, the attacker decrypts and tampers with all TLS communications that use the associated certiﬁcate. Recommendations Short term, investigate the quiche library’s API to determine whether it can readily support password-encrypted private keyﬁles. If so, update Jetty to save the private key in a temporary password-protected ﬁle and to forward that password to quiche. Alternatively, if password-encrypted private keyﬁles can be supported, have Jetty pass the unencrypted private key directly to quiche as a function argument. Either option would obviate the need to store the key in a plaintext ﬁle on the server’s ﬁlesystem. If quiche does not support either of these changes, open an issue or pull request for quiche to implement a ﬁx for this issue. 72 OSTIF Eclipse: Jetty Security Assessment 22. Repeated code between HPACK and QPACK Severity: Informational Diﬃculty: N/A Type: Code Quality Finding ID: TOB-JETTY-22 Target: ● org.eclipse.jetty.http2.hpack.internal.NBitInteger ● org.eclipse.jetty.http2.hpack.internal.Huffman ● org.eclipse.jetty.http3.qpack.internal.util.NBitIntegerParser ● org.eclipse.jetty.http3.qpack.internal.util.NBitIntegerEncode ● org.eclipse.jetty.http3.qpack.internal.util.HuffmanDecoder ● org.eclipse.jetty.http3.qpack.internal.util.HuffmanEncoder Description Classes for dealing with n-bit integers and Huﬀman coding are implemented both in the jetty-http2-hpack and in jetty-http3-qpack libraries. These classes have very similar functionality but are implemented in two diﬀerent places, sometimes with identical code and other times with diﬀerent implementations. In some cases ( TOB-JETTY-9 ), one implementation has a bug that the other implementation does not have. The codebase would be easier to maintain and keep secure if the implementations were merged. Exploit Scenario A vulnerability is found in the Huﬀman encoding implementation, which has identical code in HPACK and QPACK. The vulnerability is ﬁxed in one implementation but not the other, leaving one of the implementations vulnerable. Recommendations Short term, merge the two implementations of n-bit integers and Huﬀman coding classes. Long term, audit the Jetty codebase for other classes with very similar functionality. 73 OSTIF Eclipse: Jetty Security Assessment 23. Various exceptions in HpackDecoder.decode and QpackDecoder.decode Severity: Informational Diﬃculty: N/A Type: Denial of Service Finding ID: TOB-JETTY-23 Target: org.eclipse.jetty.http2.hpack.HpackDecoder , org.eclipse.jetty.http3.qpack.QpackDecoder Description The HpackDecoder and QpackDecoder classes both throw unexpected Java-level exceptions: ● HpackDecoder.decode(0x03) throws BufferUnderflowException . ● HpackDecoder.decode(0x4800) throws NumberFormatException . ● HpackDecoder.decode(0x3fff 2e) throws IllegalArgumentException . ● HpackDecoder.decode(0x3fff 81ff ff2e) throws NullPointerException . ● HpackDecoder.decode(0xffff ffff f8ff ffff ffff ffff ffff ffff ffff ffff ffff ffff 0202 0000) throws ArrayIndexOutOfBoundsException . ● QpackDecoder.decode(..., 0x81, ...) throws IndexOutOfBoundsException . ● QpackDecoder.decode(..., 0xfff8 ffff f75b, ...) throws ArithmeticException . For both HPACK and QPACK, these exceptions appear to be caught higher up in the call chain by catch (Throwable x) statements every time the decode functions are called. However, catching them within decode and throwing a Jetty-level exception within the catch statement would result in cleaner, more robust code. Exploit Scenario Jetty developers refactor the codebase, moving function calls around and introducing a new point in the code where HpackDecoder.decode is called. Assuming that decode will throw only org.jetty… errors, they forget to wrap this call in a catch (Throwable x) statement. This results in a DoS vulnerability. Recommendations Short term, document in the code that Java-level exceptions can be thrown. Long term, modify the decode functions so that they throw only Jetty-level exceptions. 74 OSTIF Eclipse: Jetty Security Assessment 24. Incorrect QPACK encoding when multi-byte characters are used Severity: Medium Diﬃculty: Medium Type: Data Validation Finding ID: TOB-JETTY-24 Target: org.eclipse.jetty.http3.qpack.internal.EncodableEntry Description Java’s string.length() function returns the number of characters in a string, which can be diﬀerent from the number of bytes returned by the string.getBytes() function. However, QPACK encoding methods assume that they return the same number, which could cause incorrect encodings. In EncodableEntry.LiteralEntry , which is used to encode HTTP/3 header ﬁelds, the following method is used for encoding: public void encode (ByteBuffer buffer, int base) 214 215 { 216 byte allowIntermediary = 0x00 ; // TODO: this is 0x10 bit, when should this be set? 217 218 219 220 221 222 223 224 String name = getName(); String value = getValue(); // Encode the prefix code and the name. if (_huffman) { buffer.put(( byte )( 0x28 | allowIntermediary)); NBitIntegerEncoder.encode(buffer, 3 , HuffmanEncoder.octetsNeeded(name)); 225 226 227 HuffmanEncoder.encode(buffer, name); buffer.put(( byte ) 0x80 ); NBitIntegerEncoder.encode(buffer, 7 , HuffmanEncoder.octetsNeeded(value)); 228 229 230 231 232 HuffmanEncoder.encode(buffer, value); } else { // TODO: What charset should we be using? (this applies to the instruction generators as well). 233 234 235 236 237 238 buffer.put(( byte )( 0x20 | allowIntermediary)); NBitIntegerEncoder.encode(buffer, 3 , name.length()); buffer.put(name.getBytes()); buffer.put(( byte ) 0x00 ); NBitIntegerEncoder.encode(buffer, 7 , value.length()); buffer.put(value.getBytes()); 75 OSTIF Eclipse: Jetty Security Assessment 239 240 } } Figure 24.1: EncodableEntry.java , lines 214–240 Note in particular lines 232–238, which are used to encode literal (non-Huﬀman-coded) names and values. The value returned by name.length() is added to the bytestring, followed by the value returned by name.getBytes() . Then, the value returned by value.length() is added to the bytestring, followed by the value returned by value.getBytes() . When this bytestring is decoded, the decoder will read the name length ﬁeld and then read that many bytes as the name. If multibyte characters were used in the name ﬁeld, the decoder will read too few bytes. The rest of the bytestring will also be decoded incorrectly, since the decoder will continue reading at the wrong point in the bytestring. The same issue occurs if multibyte characters were used in the value ﬁeld. The same issue appears in EncodableEntry.ReferencedNameEntry.encode : if (_huffman) 164 // Encode the value. 165 String value = getValue(); 166 167 { 168 169 170 171 } 172 173 { 174 175 176 177 } else buffer.put(( byte ) 0x80 ); NBitIntegerEncoder.encode(buffer, 7 , HuffmanEncoder.octetsNeeded(value)); HuffmanEncoder.encode(buffer, value); buffer.put(( byte ) 0x00 ); NBitIntegerEncoder.encode(buffer, 7 , value.length()); buffer.put(value.getBytes()); Figure 24.2: EncodableEntry.java , lines 164–177 If value has multibyte characters, it will be incorrectly encoded in lines 174–176. Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. Exploit Scenario A Jetty server attempts to add the Set-Cookie header, setting a cookie value to a UTF-8-encoded string that contains multibyte characters. This causes an incorrect cookie value to be set and the rest of the headers in this message to be parsed incorrectly. 76 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, have the encode function in both EncodableEntry.LiteralEntry and EncodableEntry.ReferencedNameEntry encode the length of the string using string.getBytes() rather than string.length() . 77 OSTIF Eclipse: Jetty Security Assessment 25. No limits on maximum capacity in QPACK decoder Severity: High Diﬃculty: Medium Type: Denial of Service Finding ID: TOB-JETTY-25 Target: ● org.eclipse.jetty.http3.qpack.QpackDecoder ● org.eclipse.jetty.http3.qpack.internal.parser.DecoderInstructi onParser ● org.eclipse.jetty.http3.qpack.internal.table.DynamicTable Description In QPACK, an encoder can set the dynamic table capacity of the decoder using a “Set Dynamic Table Capacity” instruction. The HTTP/3 speciﬁcation requires that the capacity be no larger than the SETTINGS_QPACK_MAX_TABLE_CAPACITY limit chosen by the decoder. However, nowhere in the QPACK code is this limit checked for. This means that the encoder can choose whatever capacity it wants (up to Java’s maximum integer value), allowing it to take up large amounts of space on the decoder’s memory. Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. Exploit Scenario A Jetty server supporting QPACK is running. An attacker opens a connection to the server. He sends a “Set Dynamic Table Capacity” instruction, setting the dynamic table capacity to Java’s maximum integer value, 2 31-1 (2.1 GB). He then repeatedly enters very large values into the server’s dynamic table using an “Insert with Literal Name” instruction until the full 2.1 GB capacity is taken up. The attacker repeats this using multiple connections until the server runs out of memory and crashes. Recommendations Short term, enforce the SETTINGS_QPACK_MAX_TABLE_CAPACITY limit on the capacity. Long term, audit Jetty’s implementation of QPACK and other protocols to ensure that Jetty enforces limits as required by the standards. 78 OSTIF Eclipse: Jetty Security Assessment
20. Use of deprecated AccessController class Severity: Informational Diﬃculty: N/A Type: Code Quality Finding ID: TOB-JETTY-20 Target: ● org.eclipse.jetty.logging.JettyLoggerConfiguration ● org.eclipse.jetty.util.MemoryUtils ● org.eclipse.jetty.util.TypeUtil ● org.eclipse.jetty.util.thread.PrivilegedThreadFactory ● org.eclipse.jetty.ee10.servlet.ServletContextHandler ● org.eclipse.jetty.ee9.nested.ContextHandler Description The classes listed in the “Target” cell above use the java.security.AccessController class, which is a deprecated class slated to be removed in a future Java release. The java.security library documentation states that the AccessController class “is only useful in conjunction with the Security Manager,” which is also deprecated. Thus, the use of AccessController no longer serves any beneﬁcial purpose. The use of this deprecated class could impact Jetty’s compatibility with future releases of the Java SDK. Recommendations Short term, remove all uses of the AccessController class. Long term, audit the Jetty codebase for the use of classes in the java.security package that may not provide any value in Jetty 12, and remove all references to those classes. 70 OSTIF Eclipse: Jetty Security Assessment 
21. QUIC server writes SSL private key to temporary plaintext ﬁle Severity: High Diﬃculty: High Type: Cryptography Finding ID: TOB-JETTY-21 Target: org.eclipse.jetty.quic.server.QuicServerConnector Description Jetty’s QUIC implementation uses quiche, a QUIC and HTTP/3 library maintained by Cloudﬂare. When the server’s SSL certiﬁcate is handed oﬀ to quiche, the private key is extracted from the existing keystore and written to a temporary plaintext PEM ﬁle: protected void doStart () throws Exception { // ...[snip]... char [] keyStorePassword = sslContextFactory.getKeyStorePassword().toCharArray(); String keyManagerPassword = sslContextFactory.getKeyManagerPassword(); SSLKeyPair keyPair = new SSLKeyPair( sslContextFactory.getKeyStoreResource().getPath(), sslContextFactory.getKeyStoreType(), keyStorePassword, alias, keyManagerPassword == null ? keyStorePassword : keyManagerPassword.toCharArray() ); File[] pemFiles = keyPair.export( new File(System.getProperty( "java.io.tmpdir" ))); privateKeyFile = pemFiles[ 0 ]; certificateChainFile = pemFiles[ 1 ]; } Figure 21.1: QuicServerConnector.java , lines 154–179 Storing the private key in this manner exposes it to increased risk of theft. Although the QuicServerConnector class deletes the private key ﬁle upon stopping the server, this deleted ﬁle may not be immediately removed from the physical storage medium, exposing the ﬁle to potential theft by attackers who can access the raw bytes on the disk. A review of quiche suggests that the library’s API may not support reading a DES-encrypted keyﬁle. If that is true, then remediating this issue would require updates to the underlying quiche library. 71 OSTIF Eclipse: Jetty Security Assessment Exploit Scenario An attacker gains read access to a Jetty HTTP/3 server’s temporary directory while the server is running. The attacker can retrieve the temporary keyﬁle and read the private key without needing to obtain or guess the encryption key for the original keystore. With this private key in hand, the attacker decrypts and tampers with all TLS communications that use the associated certiﬁcate. Recommendations Short term, investigate the quiche library’s API to determine whether it can readily support password-encrypted private keyﬁles. If so, update Jetty to save the private key in a temporary password-protected ﬁle and to forward that password to quiche. Alternatively, if password-encrypted private keyﬁles can be supported, have Jetty pass the unencrypted private key directly to quiche as a function argument. Either option would obviate the need to store the key in a plaintext ﬁle on the server’s ﬁlesystem. If quiche does not support either of these changes, open an issue or pull request for quiche to implement a ﬁx for this issue. 72 OSTIF Eclipse: Jetty Security Assessment 
22. Repeated code between HPACK and QPACK Severity: Informational Diﬃculty: N/A Type: Code Quality Finding ID: TOB-JETTY-22 Target: ● org.eclipse.jetty.http2.hpack.internal.NBitInteger ● org.eclipse.jetty.http2.hpack.internal.Huffman ● org.eclipse.jetty.http3.qpack.internal.util.NBitIntegerParser ● org.eclipse.jetty.http3.qpack.internal.util.NBitIntegerEncode ● org.eclipse.jetty.http3.qpack.internal.util.HuffmanDecoder ● org.eclipse.jetty.http3.qpack.internal.util.HuffmanEncoder Description Classes for dealing with n-bit integers and Huﬀman coding are implemented both in the jetty-http2-hpack and in jetty-http3-qpack libraries. These classes have very similar functionality but are implemented in two diﬀerent places, sometimes with identical code and other times with diﬀerent implementations. In some cases ( TOB-JETTY-9 ), one implementation has a bug that the other implementation does not have. The codebase would be easier to maintain and keep secure if the implementations were merged. Exploit Scenario A vulnerability is found in the Huﬀman encoding implementation, which has identical code in HPACK and QPACK. The vulnerability is ﬁxed in one implementation but not the other, leaving one of the implementations vulnerable. Recommendations Short term, merge the two implementations of n-bit integers and Huﬀman coding classes. Long term, audit the Jetty codebase for other classes with very similar functionality. 73 OSTIF Eclipse: Jetty Security Assessment 
23. Various exceptions in HpackDecoder.decode and QpackDecoder.decode Severity: Informational Diﬃculty: N/A Type: Denial of Service Finding ID: TOB-JETTY-23 Target: org.eclipse.jetty.http2.hpack.HpackDecoder , org.eclipse.jetty.http3.qpack.QpackDecoder Description The HpackDecoder and QpackDecoder classes both throw unexpected Java-level exceptions: ● HpackDecoder.decode(0x03) throws BufferUnderflowException . ● HpackDecoder.decode(0x4800) throws NumberFormatException . ● HpackDecoder.decode(0x3fff 2e) throws IllegalArgumentException . ● HpackDecoder.decode(0x3fff 81ff ff2e) throws NullPointerException . ● HpackDecoder.decode(0xffff ffff f8ff ffff ffff ffff ffff ffff ffff ffff ffff ffff 0202 0000) throws ArrayIndexOutOfBoundsException . ● QpackDecoder.decode(..., 0x81, ...) throws IndexOutOfBoundsException . ● QpackDecoder.decode(..., 0xfff8 ffff f75b, ...) throws ArithmeticException . For both HPACK and QPACK, these exceptions appear to be caught higher up in the call chain by catch (Throwable x) statements every time the decode functions are called. However, catching them within decode and throwing a Jetty-level exception within the catch statement would result in cleaner, more robust code. Exploit Scenario Jetty developers refactor the codebase, moving function calls around and introducing a new point in the code where HpackDecoder.decode is called. Assuming that decode will throw only org.jetty… errors, they forget to wrap this call in a catch (Throwable x) statement. This results in a DoS vulnerability. Recommendations Short term, document in the code that Java-level exceptions can be thrown. Long term, modify the decode functions so that they throw only Jetty-level exceptions. 74 OSTIF Eclipse: Jetty Security Assessment 
24. Incorrect QPACK encoding when multi-byte characters are used Severity: Medium Diﬃculty: Medium Type: Data Validation Finding ID: TOB-JETTY-24 Target: org.eclipse.jetty.http3.qpack.internal.EncodableEntry Description Java’s string.length() function returns the number of characters in a string, which can be diﬀerent from the number of bytes returned by the string.getBytes() function. However, QPACK encoding methods assume that they return the same number, which could cause incorrect encodings. In EncodableEntry.LiteralEntry , which is used to encode HTTP/3 header ﬁelds, the following method is used for encoding: public void encode (ByteBuffer buffer, int base) 214 215 { 216 byte allowIntermediary = 0x00 ; // TODO: this is 0x10 bit, when should this be set? 217 218 219 220 221 222 223 224 String name = getName(); String value = getValue(); // Encode the prefix code and the name. if (_huffman) { buffer.put(( byte )( 0x28 | allowIntermediary)); NBitIntegerEncoder.encode(buffer, 3 , HuffmanEncoder.octetsNeeded(name)); 225 226 227 HuffmanEncoder.encode(buffer, name); buffer.put(( byte ) 0x80 ); NBitIntegerEncoder.encode(buffer, 7 , HuffmanEncoder.octetsNeeded(value)); 228 229 230 231 232 HuffmanEncoder.encode(buffer, value); } else { // TODO: What charset should we be using? (this applies to the instruction generators as well). 233 234 235 236 237 238 buffer.put(( byte )( 0x20 | allowIntermediary)); NBitIntegerEncoder.encode(buffer, 3 , name.length()); buffer.put(name.getBytes()); buffer.put(( byte ) 0x00 ); NBitIntegerEncoder.encode(buffer, 7 , value.length()); buffer.put(value.getBytes()); 75 OSTIF Eclipse: Jetty Security Assessment 239 240 } } Figure 24.1: EncodableEntry.java , lines 214–240 Note in particular lines 232–238, which are used to encode literal (non-Huﬀman-coded) names and values. The value returned by name.length() is added to the bytestring, followed by the value returned by name.getBytes() . Then, the value returned by value.length() is added to the bytestring, followed by the value returned by value.getBytes() . When this bytestring is decoded, the decoder will read the name length ﬁeld and then read that many bytes as the name. If multibyte characters were used in the name ﬁeld, the decoder will read too few bytes. The rest of the bytestring will also be decoded incorrectly, since the decoder will continue reading at the wrong point in the bytestring. The same issue occurs if multibyte characters were used in the value ﬁeld. The same issue appears in EncodableEntry.ReferencedNameEntry.encode : if (_huffman) 164 // Encode the value. 165 String value = getValue(); 166 167 { 168 169 170 171 } 172 173 { 174 175 176 177 } else buffer.put(( byte ) 0x80 ); NBitIntegerEncoder.encode(buffer, 7 , HuffmanEncoder.octetsNeeded(value)); HuffmanEncoder.encode(buffer, value); buffer.put(( byte ) 0x00 ); NBitIntegerEncoder.encode(buffer, 7 , value.length()); buffer.put(value.getBytes()); Figure 24.2: EncodableEntry.java , lines 164–177 If value has multibyte characters, it will be incorrectly encoded in lines 174–176. Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. Exploit Scenario A Jetty server attempts to add the Set-Cookie header, setting a cookie value to a UTF-8-encoded string that contains multibyte characters. This causes an incorrect cookie value to be set and the rest of the headers in this message to be parsed incorrectly. 76 OSTIF Eclipse: Jetty Security Assessment Recommendations Short term, have the encode function in both EncodableEntry.LiteralEntry and EncodableEntry.ReferencedNameEntry encode the length of the string using string.getBytes() rather than string.length() . 77 OSTIF Eclipse: Jetty Security Assessment 
25. No limits on maximum capacity in QPACK decoder Severity: High Diﬃculty: Medium Type: Denial of Service Finding ID: TOB-JETTY-25 Target: ● org.eclipse.jetty.http3.qpack.QpackDecoder ● org.eclipse.jetty.http3.qpack.internal.parser.DecoderInstructi onParser ● org.eclipse.jetty.http3.qpack.internal.table.DynamicTable Description In QPACK, an encoder can set the dynamic table capacity of the decoder using a “Set Dynamic Table Capacity” instruction. The HTTP/3 speciﬁcation requires that the capacity be no larger than the SETTINGS_QPACK_MAX_TABLE_CAPACITY limit chosen by the decoder. However, nowhere in the QPACK code is this limit checked for. This means that the encoder can choose whatever capacity it wants (up to Java’s maximum integer value), allowing it to take up large amounts of space on the decoder’s memory. Jetty’s HTTP/3 code is still considered experimental, so this issue should not aﬀect production code, but it should be ﬁxed before announcing HTTP/3 support to be production-ready. Exploit Scenario A Jetty server supporting QPACK is running. An attacker opens a connection to the server. He sends a “Set Dynamic Table Capacity” instruction, setting the dynamic table capacity to Java’s maximum integer value, 2 31-1 (2.1 GB). He then repeatedly enters very large values into the server’s dynamic table using an “Insert with Literal Name” instruction until the full 2.1 GB capacity is taken up. The attacker repeats this using multiple connections until the server runs out of memory and crashes. Recommendations Short term, enforce the SETTINGS_QPACK_MAX_TABLE_CAPACITY limit on the capacity. Long term, audit Jetty’s implementation of QPACK and other protocols to ensure that Jetty enforces limits as required by the standards. 78 OSTIF Eclipse: Jetty Security Assessment 
