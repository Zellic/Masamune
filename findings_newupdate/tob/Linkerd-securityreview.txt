1. Various unhandled errors Severity: Undetermined Diﬃculty: High Type: Error Reporting Finding ID: TOB-LNKD-1 Target: Various Description The linkerd codebase contains various methods with unhandled errors. In most cases, errors returned by functions are simply not checked; in other cases, functions that surround deferred error-returning functions do not capture the relevant errors. Using gosec and errcheck, we detected a large number of such cases, which we cannot enumerate in this report. We recommend running these tools to uncover and resolve these cases. Figures 1.1 and 1.2 provide examples of functions in the codebase with unhandled errors: func (h *handler) handleProfileDownload(w http.ResponseWriter, req *http.Request, params httprouter.Params) { [...] w.Write(profileYaml.Bytes()) } Figure 1.1: web/srv/handlers.go#L65-L91 func renderStatStats(rows []*pb.StatTable_PodGroup_Row, options *statOptions) string { [...] writeStatsToBuffer(rows, w, options) w.Flush() [...] } Figure 1.2: viz/cmd/stat.go#L295-L302 We could not determine the severity of all of the unhandled errors detected in the codebase. Exploit Scenario While an operator of the Linkerd infrastructure interacts with the system, an uncaught error occurs. Due to the lack of error reporting, the operator is unaware that the operation did not complete successfully, and he produces further undeﬁned behavior. Recommendations Short term, run gosec and errcheck across the codebase. Resolve all issues pertaining to unhandled errors by checking them explicitly. Long term, ensure that all functions that return errors have explicit checks for these errors. Consider integrating the abovementioned tooling into the CI/CD pipeline to prevent undeﬁned behavior from occurring in the aﬀected code paths. 
2. The use of time.After() in select statements can lead to memory leaks Severity: Low Type: Timing Diﬃculty: High Finding ID: TOB-LNKD-2 Target: cli/cmd/metrics_diagnostics_util.go Description Calls to time.After in for/select statements can lead to memory leaks because the garbage collector does not clean up the underlying Timer object until the timer ﬁres. A new timer, which requires resources, is initialized at each iteration of the for loop (and, hence, the select statement). As a result, many routines originating from the time.After call could lead to overconsumption of the memory. wait: for { select { case result := <-resultChan: results = append(results, result) case <-time.After(waitingTime): break wait // timed out } if atomic.LoadInt32(&activeRoutines) == 0 { break } } Figure 2.1: cli/cmd/metrics_diagnostics_util.go#L131-L142 Recommendations Short term, consider refactoring the code that uses the time.After function in for/select loops using tickers. This will prevent memory leaks and crashes caused by memory exhaustion. Long term, ensure that the time.After method is not used in for/select routines. Periodically use the Semgrep query to check for and detect similar patterns. References ● Use with caution time.After Can cause memory leak (golang) ● Golang <-time.After() is not garbage collected before expiry 
3. Use of string.Contains instead of string.HasPreﬁx to check for preﬁxes Severity: Undetermined Diﬃculty: Undetermined Type: Data Validation Finding ID: TOB-LNKD-3 Target: multicluster/service-mirror/events_formatting.go Description When formatting event metadata, the formatMetadata method checks whether a given string in the metadata map contains a given preﬁx. However, rather than using string.HasPrefix to perform this check, it uses string.Contains, which returns true if the given preﬁx string is located anywhere in the target string. for k, v := range meta { if strings.Contains(k, consts.Prefix) || strings.Contains(k, consts.ProxyConfigAnnotationsPrefix) { metadata = append(metadata, fmt.Sprintf("%s=%s", k, v)) } } Figure 3.1: multicluster/service-mirror/events_formatting.go#L23-L27 Recommendations Short term, refactor the preﬁx checks to use string.HasPrefix rather than string.Contains. This will ensure that preﬁxes within strings are properly validated. 
4. Risk of resource exhaustion due to the use of defer inside a loop Severity: Informational Diﬃculty: High Type: Denial of Service Finding ID: TOB-LNKD-4 Target: pkg/healthcheck/healthcheck.go Description The runCheck function, responsible for performing health checks for various services, performs its core functions inside of an inﬁnite for loop. runCheck is called with a timeout stored in a context object. The cancel() function is deferred at the beginning of the loop. Calling defer inside of a loop could cause resource exhaustion conditions because the deferred function is called when the function exits, not at the end of each loop. As a result, resources from each context object are accumulated until the end of the for statement. While this may not cause noticeable issues in the current state of the application, it is best to call cancel() at the end of each loop to prevent unforeseen issues. func (hc *HealthChecker) runCheck(category *Category, c *Checker, observer CheckObserver) bool { for { ctx, cancel := context.WithTimeout(context.Background(), RequestTimeout) defer cancel() err := c.check(ctx) if se, ok := err.(*SkipError); ok { log.Debugf("Skipping check: %s. Reason: %s", c.description, se.Reason) return true } Figure 4.1: pkg/healthcheck/healthcheck.go#L1619-L1628 Recommendations Short term, rather than deferring the call to cancel(), add a call to cancel() at the end of the loop. 
5. Lack of maximum request and response body constraint Severity: Informational Diﬃculty: High Type: Denial of Service Finding ID: TOB-LNKD-5 Target: Various APIs Description The ioutil.ReadAll function reads from source until an error or an end-of-ﬁle (EOF) condition occurs, at which point it returns the data that it read. There is no limit on the maximum size of request and response bodies, so using ioutil.ReadAll to parse requests and responses could cause a denial of service (due to insuﬃcient memory). A denial of service could also occur if an exhaustive resource is loaded multiple times. This method is used in the following locations of the codebase: File Purpose controller/heartbeat/heartbeat.go:239 Reads responses for heartbeat requests pkg/profiles/openapi.go:32 pkg/version/channels.go:83 controller/webhook/server.go:124 pkg/protohttp/protohttp.go:48 pkg/protohttp/protohttp.go:170 Reads the body of ﬁle for the profile command Reads responses from requests for obtaining Linkerd versions Reads requests for the webhook and metrics servers Reads all requests sent to the metrics and TAP APIs Reads error responses from the metrics and TAP APIs In the case of pkg/protohttp/protohttp.go, the readAll function can be called to read POST requests, making it easier for an attacker to exploit the misuse of the ReadAll function. Recommendations Short term, place a limit on the maximum size of request and response bodies. For example, this limitation can be implemented by using the io.LimitReader function. Long term, place limits on request and response bodies globally in other places within the application to prevent denial-of-service attacks. 
6. Potential goroutine leak in Kubernetes port-forwarding initialization logic Severity: Informational Diﬃculty: High Type: Denial of Service Finding ID: TOB-LNKD-6 Target: pkg/healthcheck/healthcheck.go Description The Init function responsible for initializing port-forwarding connections for Kubernetes causes a goroutine leak when connections succeed. This is because the failure channel in the Init function is set up as an unbuﬀered channel. Consequently, the failure channel blocks the execution of the anonymous goroutine in which it is used unless an error is received from pf.run(). Whenever a message indicating success is received by readChan, the Init function returns without ﬁrst releasing the resources allocated by the anonymous goroutine, causing those resources to be leaked. func (pf *PortForward) Init() error { // (...) failure := make(chan error) go func() { if err := pf.run(); err != nil { failure <- err } }() // (...)` select { case <-pf.readyCh: log.Debug("Port forward initialised") case err := <-failure: log.Debugf("Port forward failed: %v", err) return err } Figure 6.1: pkg/k8s/portforward.go#L200-L220 Recommendations Short term, make the failure channel a buﬀered channel of size 1. That way, the goroutine will be cleaned and destroyed when the function returns regardless of which case occurs ﬁrst. Long term, run GCatch against goroutine-heavy packages to detect the mishandling of channel bugs. Refer to appendix C for guidance on running GCatch. Basic instances of this issue can also be detected by running this Semgrep rule. 
7. Risk of log injection in TAP service API Severity: Low Diﬃculty: High Type: Auditing and Logging Finding ID: TOB-LNKD-7 Target: viz/tap/api/handlers.go Description Requests sent to the TAP service API endpoint, /apis/tap, via the POST method are handled by the handleTap method. This method parses a namespace and a name obtained from the URL of the request. Both the namespace and name variables are then used in a log statement for printing debugging messages to standard output. Because both ﬁelds are user controllable, an attacker could perform log injection attacks by calling such API endpoints with a namespace or name with newline indicators, such as \n. func (h *handler) handleTap(w http.ResponseWriter, req *http.Request, p httprouter.Params) { namespace := p.ByName("namespace") name := p.ByName("name") resource := "" // (...) h.log.Debugf("SubjectAccessReview: namespace: %s, resource: %s, name: %s, user: <%s>, group: <%s>", namespace, resource, name, h.usernameHeader, h.groupHeader, ) Figure 7.1: viz/tap/api/handlers.go#L106-L125 Exploit Scenario An attacker submits a POST request to the TAP service API using the URL /apis/tap.linkerd.io/v1alpha1/watch/myns\nERRO[0000]<attacker’s log message>/tap, causing invalid logs to be printed and tricking an operator into falsely believing there is a failure. Recommendations Short term, ensure that all user-controlled input is sanitized before it is used in the logging function. Additionally, use the format speciﬁer %q instead of %s to prompt Go to perform basic sanitation of strings. 
8. TLS conﬁguration does not enforce minimum TLS version Severity: Low Diﬃculty: High Type: Conﬁguration Finding ID: TOB-LNKD-8 Targets: controller\webhook\server.go, viz\tap\api\sever.go Description Transport Layer Security (TLS) is used in multiple locations throughout the codebase. In two cases, TLS conﬁgurations do not have a minimum version requirement, allowing connections from TLS 1.0 and later. This may leave the webhook and TAP API servers vulnerable to protocol downgrade and man-in-the-middle attacks. // NewServer returns a new instance of Server func NewServer( ctx context.Context, api *k8s.API, addr, certPath string, handler Handler, component string, ) (*Server, error) { [...] server := &http.Server{ Addr: addr, TLSConfig: &tls.Config{}, } Figure 8.1: controller/webhook/server.go#L43-L64 // NewServer creates a new server that implements the Tap APIService. func NewServer( ctx context.Context, addr string, k8sAPI *k8s.API, grpcTapServer pb.TapServer, disableCommonNames bool, ) (*Server, error) { [...] httpServer := &http.Server{ Addr: addr, TLSConfig: &tls.Config{ ClientAuth: tls.VerifyClientCertIfGiven, ClientCAs: clientCertPool, }, } Figure 8.2: viz/tap/api/sever.go#L34-L76 Exploit Scenario Due to the lack of minimum TLS version enforcement, certain established connections lack suﬃcient authentication and cryptography. These connections do not protect against man-in-the-middle attacks. Recommendations Short term, review all TLS conﬁgurations and ensure the MinVersion ﬁeld is set to require connections to be TLS 1.2 or newer. Long term, ensure that all TLS conﬁgurations across the codebase enforce a minimum version requirement and employ veriﬁcation where possible. 
1. Various unhandled errors Severity: Undetermined Diﬃculty: High Type: Error Reporting Finding ID: TOB-LNKD-1 Target: Various Description The linkerd codebase contains various methods with unhandled errors. In most cases, errors returned by functions are simply not checked; in other cases, functions that surround deferred error-returning functions do not capture the relevant errors. Using gosec and errcheck, we detected a large number of such cases, which we cannot enumerate in this report. We recommend running these tools to uncover and resolve these cases. Figures 1.1 and 1.2 provide examples of functions in the codebase with unhandled errors: func (h *handler) handleProfileDownload(w http.ResponseWriter, req *http.Request, params httprouter.Params) { [...] w.Write(profileYaml.Bytes()) } Figure 1.1: web/srv/handlers.go#L65-L91 func renderStatStats(rows []*pb.StatTable_PodGroup_Row, options *statOptions) string { [...] writeStatsToBuffer(rows, w, options) w.Flush() [...] } Figure 1.2: viz/cmd/stat.go#L295-L302 We could not determine the severity of all of the unhandled errors detected in the codebase. Exploit Scenario While an operator of the Linkerd infrastructure interacts with the system, an uncaught error occurs. Due to the lack of error reporting, the operator is unaware that the operation did not complete successfully, and he produces further undeﬁned behavior. Recommendations Short term, run gosec and errcheck across the codebase. Resolve all issues pertaining to unhandled errors by checking them explicitly. Long term, ensure that all functions that return errors have explicit checks for these errors. Consider integrating the abovementioned tooling into the CI/CD pipeline to prevent undeﬁned behavior from occurring in the aﬀected code paths. 
2. The use of time.After() in select statements can lead to memory leaks Severity: Low Type: Timing Diﬃculty: High Finding ID: TOB-LNKD-2 Target: cli/cmd/metrics_diagnostics_util.go Description Calls to time.After in for/select statements can lead to memory leaks because the garbage collector does not clean up the underlying Timer object until the timer ﬁres. A new timer, which requires resources, is initialized at each iteration of the for loop (and, hence, the select statement). As a result, many routines originating from the time.After call could lead to overconsumption of the memory. wait: for { select { case result := <-resultChan: results = append(results, result) case <-time.After(waitingTime): break wait // timed out } if atomic.LoadInt32(&activeRoutines) == 0 { break } } Figure 2.1: cli/cmd/metrics_diagnostics_util.go#L131-L142 Recommendations Short term, consider refactoring the code that uses the time.After function in for/select loops using tickers. This will prevent memory leaks and crashes caused by memory exhaustion. Long term, ensure that the time.After method is not used in for/select routines. Periodically use the Semgrep query to check for and detect similar patterns. References ● Use with caution time.After Can cause memory leak (golang) ● Golang <-time.After() is not garbage collected before expiry 
3. Use of string.Contains instead of string.HasPreﬁx to check for preﬁxes Severity: Undetermined Diﬃculty: Undetermined Type: Data Validation Finding ID: TOB-LNKD-3 Target: multicluster/service-mirror/events_formatting.go Description When formatting event metadata, the formatMetadata method checks whether a given string in the metadata map contains a given preﬁx. However, rather than using string.HasPrefix to perform this check, it uses string.Contains, which returns true if the given preﬁx string is located anywhere in the target string. for k, v := range meta { if strings.Contains(k, consts.Prefix) || strings.Contains(k, consts.ProxyConfigAnnotationsPrefix) { metadata = append(metadata, fmt.Sprintf("%s=%s", k, v)) } } Figure 3.1: multicluster/service-mirror/events_formatting.go#L23-L27 Recommendations Short term, refactor the preﬁx checks to use string.HasPrefix rather than string.Contains. This will ensure that preﬁxes within strings are properly validated. 
4. Risk of resource exhaustion due to the use of defer inside a loop Severity: Informational Diﬃculty: High Type: Denial of Service Finding ID: TOB-LNKD-4 Target: pkg/healthcheck/healthcheck.go Description The runCheck function, responsible for performing health checks for various services, performs its core functions inside of an inﬁnite for loop. runCheck is called with a timeout stored in a context object. The cancel() function is deferred at the beginning of the loop. Calling defer inside of a loop could cause resource exhaustion conditions because the deferred function is called when the function exits, not at the end of each loop. As a result, resources from each context object are accumulated until the end of the for statement. While this may not cause noticeable issues in the current state of the application, it is best to call cancel() at the end of each loop to prevent unforeseen issues. func (hc *HealthChecker) runCheck(category *Category, c *Checker, observer CheckObserver) bool { for { ctx, cancel := context.WithTimeout(context.Background(), RequestTimeout) defer cancel() err := c.check(ctx) if se, ok := err.(*SkipError); ok { log.Debugf("Skipping check: %s. Reason: %s", c.description, se.Reason) return true } Figure 4.1: pkg/healthcheck/healthcheck.go#L1619-L1628 Recommendations Short term, rather than deferring the call to cancel(), add a call to cancel() at the end of the loop. 
5. Lack of maximum request and response body constraint Severity: Informational Diﬃculty: High Type: Denial of Service Finding ID: TOB-LNKD-5 Target: Various APIs Description The ioutil.ReadAll function reads from source until an error or an end-of-ﬁle (EOF) condition occurs, at which point it returns the data that it read. There is no limit on the maximum size of request and response bodies, so using ioutil.ReadAll to parse requests and responses could cause a denial of service (due to insuﬃcient memory). A denial of service could also occur if an exhaustive resource is loaded multiple times. This method is used in the following locations of the codebase: File Purpose controller/heartbeat/heartbeat.go:239 Reads responses for heartbeat requests pkg/profiles/openapi.go:32 pkg/version/channels.go:83 controller/webhook/server.go:124 pkg/protohttp/protohttp.go:48 pkg/protohttp/protohttp.go:170 Reads the body of ﬁle for the profile command Reads responses from requests for obtaining Linkerd versions Reads requests for the webhook and metrics servers Reads all requests sent to the metrics and TAP APIs Reads error responses from the metrics and TAP APIs In the case of pkg/protohttp/protohttp.go, the readAll function can be called to read POST requests, making it easier for an attacker to exploit the misuse of the ReadAll function. Recommendations Short term, place a limit on the maximum size of request and response bodies. For example, this limitation can be implemented by using the io.LimitReader function. Long term, place limits on request and response bodies globally in other places within the application to prevent denial-of-service attacks. 
6. Potential goroutine leak in Kubernetes port-forwarding initialization logic Severity: Informational Diﬃculty: High Type: Denial of Service Finding ID: TOB-LNKD-6 Target: pkg/healthcheck/healthcheck.go Description The Init function responsible for initializing port-forwarding connections for Kubernetes causes a goroutine leak when connections succeed. This is because the failure channel in the Init function is set up as an unbuﬀered channel. Consequently, the failure channel blocks the execution of the anonymous goroutine in which it is used unless an error is received from pf.run(). Whenever a message indicating success is received by readChan, the Init function returns without ﬁrst releasing the resources allocated by the anonymous goroutine, causing those resources to be leaked. func (pf *PortForward) Init() error { // (...) failure := make(chan error) go func() { if err := pf.run(); err != nil { failure <- err } }() // (...)` select { case <-pf.readyCh: log.Debug("Port forward initialised") case err := <-failure: log.Debugf("Port forward failed: %v", err) return err } Figure 6.1: pkg/k8s/portforward.go#L200-L220 Recommendations Short term, make the failure channel a buﬀered channel of size 1. That way, the goroutine will be cleaned and destroyed when the function returns regardless of which case occurs ﬁrst. Long term, run GCatch against goroutine-heavy packages to detect the mishandling of channel bugs. Refer to appendix C for guidance on running GCatch. Basic instances of this issue can also be detected by running this Semgrep rule. 
7. Risk of log injection in TAP service API Severity: Low Diﬃculty: High Type: Auditing and Logging Finding ID: TOB-LNKD-7 Target: viz/tap/api/handlers.go Description Requests sent to the TAP service API endpoint, /apis/tap, via the POST method are handled by the handleTap method. This method parses a namespace and a name obtained from the URL of the request. Both the namespace and name variables are then used in a log statement for printing debugging messages to standard output. Because both ﬁelds are user controllable, an attacker could perform log injection attacks by calling such API endpoints with a namespace or name with newline indicators, such as \n. func (h *handler) handleTap(w http.ResponseWriter, req *http.Request, p httprouter.Params) { namespace := p.ByName("namespace") name := p.ByName("name") resource := "" // (...) h.log.Debugf("SubjectAccessReview: namespace: %s, resource: %s, name: %s, user: <%s>, group: <%s>", namespace, resource, name, h.usernameHeader, h.groupHeader, ) Figure 7.1: viz/tap/api/handlers.go#L106-L125 Exploit Scenario An attacker submits a POST request to the TAP service API using the URL /apis/tap.linkerd.io/v1alpha1/watch/myns\nERRO[0000]<attacker’s log message>/tap, causing invalid logs to be printed and tricking an operator into falsely believing there is a failure. Recommendations Short term, ensure that all user-controlled input is sanitized before it is used in the logging function. Additionally, use the format speciﬁer %q instead of %s to prompt Go to perform basic sanitation of strings. 
8. TLS conﬁguration does not enforce minimum TLS version Severity: Low Diﬃculty: High Type: Conﬁguration Finding ID: TOB-LNKD-8 Targets: controller\webhook\server.go, viz\tap\api\sever.go Description Transport Layer Security (TLS) is used in multiple locations throughout the codebase. In two cases, TLS conﬁgurations do not have a minimum version requirement, allowing connections from TLS 1.0 and later. This may leave the webhook and TAP API servers vulnerable to protocol downgrade and man-in-the-middle attacks. // NewServer returns a new instance of Server func NewServer( ctx context.Context, api *k8s.API, addr, certPath string, handler Handler, component string, ) (*Server, error) { [...] server := &http.Server{ Addr: addr, TLSConfig: &tls.Config{}, } Figure 8.1: controller/webhook/server.go#L43-L64 // NewServer creates a new server that implements the Tap APIService. func NewServer( ctx context.Context, addr string, k8sAPI *k8s.API, grpcTapServer pb.TapServer, disableCommonNames bool, ) (*Server, error) { [...] httpServer := &http.Server{ Addr: addr, TLSConfig: &tls.Config{ ClientAuth: tls.VerifyClientCertIfGiven, ClientCAs: clientCertPool, }, } Figure 8.2: viz/tap/api/sever.go#L34-L76 Exploit Scenario Due to the lack of minimum TLS version enforcement, certain established connections lack suﬃcient authentication and cryptography. These connections do not protect against man-in-the-middle attacks. Recommendations Short term, review all TLS conﬁgurations and ensure the MinVersion ﬁeld is set to require connections to be TLS 1.2 or newer. Long term, ensure that all TLS conﬁgurations across the codebase enforce a minimum version requirement and employ veriﬁcation where possible. 
9. Nil dereferences in the webhook server Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-LNKD-9 Target: controller/webhook/server.go Description The webhook server’s processReq function, used for handling admission review requests, does not properly validate request objects. As a result, malformed requests result in nil dereferences, which cause panics on the server. If the server receives a request with a body that cannot be decoded by the decode function, shown below, an error is returned, and a panic is triggered when the system attempts to access the Request object in line 154. A panic could also occur if the request is decoded successfully into an AdmissionReview object with a missing Request property. In such a case, the panic would be triggered in line 162. 149 func (s *Server) processReq(ctx context.Context, data []byte) *admissionv1beta1.AdmissionReview { 150 151 152 153 154 155 156 157 158 159 160 161 162 admissionReview, err := decode(data) if err != nil { log.Errorf("failed to decode data. Reason: %s", err) admissionReview.Response = &admissionv1beta1.AdmissionResponse{ admissionReview.Request.UID, UID: Allowed: false, Result: &metav1.Status{ Message: err.Error(), }, } return admissionReview } log.Infof("received admission review request %s", admissionReview.Request.UID) 163 log.Debugf("admission request: %+v", admissionReview.Request) Figure 9.1: controller/webhook/server.go#L149-L163 We tested the panic by getting a shell on a container running in the application namespace and issuing the request in ﬁgure 9.2. However, the Go server recovers from the panics without negatively impacting the application. curl -i -s -k -X $'POST' -H $'Host: 10.100.137.130:443' -H $'Accept: */*' -H $'Content-Length: 6' --data-binary $'aaaaaa' $'https://10.100.137.130:443/inject/test Figure 9.2: The curl request that causes a panic Recommendations Short term, add checks to verify that request objects are not nil before and after they are decoded. Long term, run the invalid-usage-of-modified-variable rule from the set of Semgrep rules in the CI/CD pipeline to detect this type of bug. A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diﬃculty levels used in this document. Vulnerability Categories Category Description Access Controls Insuﬃcient authorization or assessment of rights Auditing and Logging Insuﬃcient auditing of actions or logging of problems Authentication Improper identiﬁcation of users Conﬁguration Misconﬁgured servers, devices, or software components Cryptography A breach of system conﬁdentiality or integrity Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service A system failure with an availability impact Error Reporting Insecure or insuﬃcient reporting of error conditions Patching Use of an outdated software package or library Session Management Improper identiﬁcation of authenticated users Testing Timing Insuﬃcient test methodology or test coverage Race conditions or other order-of-operations ﬂaws Undeﬁned Behavior Undeﬁned behavior triggered within the system Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices. Undetermined The extent of the risk was not determined during this engagement. Low The risk is small or is not one the client has indicated is important. Medium High User information is at risk; exploitation could pose reputational, legal, or moderate ﬁnancial risks. The ﬂaw could aﬀect numerous users and have serious reputational, legal, or ﬁnancial implications. Diﬃculty Levels Diﬃculty Description Undetermined The diﬃculty of exploitation was not determined during this engagement. Low Medium High The ﬂaw is well known; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of the system. An attacker must have privileged access to the system, may need to know complex technical details, or must discover other weaknesses to exploit this issue. B. Code Quality Findings This appendix lists code quality ﬁndings that we identiﬁed through a manual review. Typo in the ﬁlename viz/tap/api/sever.go. The word “sever” should be “server.” Use of fmt.Sprintf instead of net.JoinHostPort. In locations in which host names and port numbers are joined for a target URI, fmt.Sprintf calls are used to format the message instead of net.JoinHostPort. ● controller/api/destination/profile_translator.go#L120 ● controller/api/destination/server.go#L471 ● controller/api/destination/watcher/endpoints_watcher.go (#L753, #L813) ● controller/api/destination/watcher/k8s.go#L96 Redundant error handling in various methods. Various methods check whether an error is nil before returning it; however, continuing down the code path returns a nil. Instead, these methods could return the error whether it is nil or not. ● jaeger/cmd/check.go#L76-L79 ● multicluster/service-mirror/cluster_watcher.go#L1026-L1030 ● pkg/healthcheck/healthcheck.go#L1510-L1514 ● viz/cmd/tap.go#L306-L310 ● viz/pkg/healthcheck/healthcheck.go#L244-L248 C. Running GCatch This appendix explains how to use GCatch, a tool that automatically detects concurrency bugs in Go. It also includes relevant output generated by GCatch when it is run over Linkerd (ﬁgure C.1). We omitted from the ﬁgure any output pertaining to packages in which no issues were detected and to packages that did not compile. Additionally, we replaced the preﬁx of the package paths (/home/vagrant/go/src/github.com/linkerd) with "$LINKERD" in the ﬁgure. To run GCatch over the Linkerd project, take the following steps: 
1. Clone the GCatch project as a Go package. For example, if your Go root directory were ~/go, you would clone the repository to the following package: ~/go/src/github.com/system-pclub/GCatch. 
2. Go to the GCatch/GCatch directory and run Installz3.sh and install.sh. 3. Install the project in the Go root directory and enter the project directory (~/go/src/github.com/linkerd/linkerd2). 
4. Run GCatch by using the following command: GCatch -path="$(pwd)" -include=github.com/linkerd/$REPO -checker=BMOC:unlock:double:conflict:structfield:fatal -r -compile-error. ----------Bug[1]---------- Type: BMOC Reason: One or multiple channel operation is blocked. -----Blocking at: File: /$LINKERD/k8s/portforward.go:207 -----Path NO. 0 Entry func at: (*github.com/linkerd/linkerd2/pkg/k8s.PortForward).Init Call :/$LINKERD/k8s/portforward.go:201:12 ChanMake :/$LINKERD/k8s/portforward.go:203:17 '✓' Go :/$LINKERD/k8s/portforward.go:205:2 Select :/$LINKERD/k8s/portforward.go:214:2 Select_case :/$LINKERD/k8s/portforward.go:214:2 Call :/$LINKERD/k8s/portforward.go:216:12 Return :/$LINKERD/k8s/portforward.go:222:2 -----Blocking Path NO. 1 Call :/$LINKERD/k8s/portforward.go:206:19 If :/$LINKERD/k8s/portforward.go:206:27 '✓' '✓' '✓' '✓' '✓' '✓' '✓' '✓' Chan_op :/$LINKERD/k8s/portforward.go:207: Jump :/$LINKERD/k8s/portforward.go:207:12 Return :/$LINKERD/k8s/portforward.go:207:12 '✗' '✗' Figure C.1: GCatch results for Linkerd 
