1. Prover can lock user funds by including ill-formed BigInts in public key commitment Severity: High Diﬃculty: Low Type: Data Validation Finding ID: TOB-SUCCINCT-1 Target: circuits/circuits/rotate.circom Description The Rotate circuit does not check for the validity of BigInts included in pubkeysBigIntY . A malicious prover can lock user funds by carefully selecting malformed public keys and using the Rotate function, which will prevent future provers from using the default witness generator to make new proofs. The Rotate circuit is designed to prove a translation between an SSZ commitment over a set of validator public keys produced by the Ethereum consensus protocol and a Poseidon commitment over an equivalent list. The SSZ commitment is over public keys serialized as 48-byte compressed BLS public keys, specifying an X coordinate and single sign bit, while the Poseidon commitment is over pairs (X, Y) , where X and Y are 7-limb, 55-bit BigInts. The prover speciﬁes the Y coordinate for each public key as part of the witness; the Rotate circuit then uses SubgroupCheckG1WithValidX to constrain Y to be valid in the sense that (X, Y) is a point on the BLS12-381 elliptic curve. However, SubgroupCheckG1WithValidX assumes that its input is a properly formed BigInt, with all limbs less than 2 55 . This property is not validated anywhere in the Rotate circuit. By committing to a Poseidon root containing invalid BigInts, a malicious prover can prevent other provers from successfully proving a Step operation, bringing the light client to a halt and causing user funds to be stuck in the bridge. Furthermore, the invalid elliptic curve points would then be usable in the Step circuit, where they are passed without validation to the EllipticCurveAddUnequal function. The behavior of this function on ill-formed inputs is not speciﬁed and could allow a malicious prover to forge Step proofs without a valid sync committee signature. Figure 1.1 shows where the untrusted pubkeysBigIntY value is passed to the SubgroupCheckG1WithValidX template. /* VERIFY THAT THE WITNESSED Y-COORDINATES MAKE THE PUBKEYS LAY ON THE CURVE */ component isValidPoint[SYNC_COMMITTEE_SIZE]; for ( var i = 0 ; i < SYNC_COMMITTEE_SIZE; i++) { isValidPoint[i] = SubgroupCheckG1WithValidX(N, K); for ( var j = 0 ; j < K; j++) { isValidPoint[i]. in [ 0 ][j] <== pubkeysBigIntX[i][j]; isValidPoint[i]. in [ 1 ][j] <== pubkeysBigIntY[i][j]; } } Figure 1.1: telepathy/circuits/circuits/rotate.circom#101–109 Exploit Scenario Alice, a malicious prover, uses a valid block header containing a sync committee update to generate a Rotate proof. Instead of using correctly formatted BigInts to represent the Y values of each public key point, she modiﬁes the value by subtracting one from the most signiﬁcant limb and adding 2 55 to the second-most signiﬁcant limb. She then posts the resulting proof to the LightClient contract via the rotate function, which updates the sync committee commitment to Alice’s Poseidon commitment containing ill-formed Y coordinates. Future provers would then be unable to use the default witness generator to make new proofs, locking user funds in the bridge. Alice may be able to then exploit invalid assumptions in the Step circuit to forge Step proofs and steal bridge funds. Recommendations Short term, use a Num2Bits component to verify that each limb of the pubkeysBigIntY witness value is less than 2 55 . Long term, clearly document and validate the input assumptions of templates such as SubgroupCheckG1WithValidX . Consider adopting Circom signal tags to automate the checking of these assumptions. 
2. Prover can lock user funds by supplying non-reduced Y values to G1BigIntToSignFlag Severity: High Diﬃculty: Low Type: Data Validation Finding ID: TOB-SUCCINCT-2 Target: circuits/circuits/rotate.circom Description The G1BigIntToSignFlag template does not check whether its input is a value properly reduced mod p . A malicious prover can lock user funds by carefully selecting malformed public keys and using the Rotate function, which will prevent future provers from using the default witness generator to make new proofs. During the Rotate proof, when translating compressed public keys to full (X, Y) form, the prover must supply a Y value with a sign corresponding to the sign bit of the compressed public key. The circuit calculates the sign of Y by passing the Y coordinate (supplied by the prover and represented as a BigInt) to the G1BigIntToSignFlag component (ﬁgure 2.1). This component determines the sign of Y by checking if 2*Y >= p . However, the correctness of this calculation depends on the Y value being less than p ; otherwise, a positive, non-reduced value such as p + 1 will be incorrectly interpreted as negative. A malicious prover could use this fact to commit to a non-reduced form of Y that diﬀers in sign from the correct public key. This invalid commitment would prevent future provers from generating Step circuit proofs and thus halt the LightClient , trapping user funds in the Bridge . template G1BigIntToSignFlag(N, K) { signal input in [K]; signal output out; var P[K] = getBLS128381Prime(); var LOG_K = log_ceil(K); component mul = BigMult(N, K); signal two[K]; for ( var i = 0 ; i < K; i++) { if (i == 0 ) { two[i] <== 2 ; } else { two[i] <== 0 ; } } for ( var i = 0 ; i < K; i++) { mul.a[i] <== in [i]; mul.b[i] <== two[i]; } component lt = BigLessThan(N, K); for ( var i = 0 ; i < K; i++) { lt.a[i] <== mul.out[i]; lt.b[i] <== P[i]; } out <== 1 - lt.out; } Figure 2.1: telepathy/circuits/circuits/bls.circom#197–226 Exploit Scenario Alice, a malicious prover, uses a valid block header containing a sync committee update to generate a Rotate proof. When one of the new sync committee members’ public key Y value has a negative sign, Alice substitutes it with 2P - Y . This value is congruent to -Y mod p , and thus has positive sign; however, the G1BigIntToSignFlag component will determine that it has negative sign and validate the inclusion in the Poseidon commitment. Future provers will then be unable to generate proofs from this commitment since the committed public key set does not match the canonical sync committee. Recommendations Short term, constrain the pubkeysBigIntY values to be less than p using BigLessThan . Long term, constrain all private witness values to be in canonical form before use. Consider adopting Circom signal tags to automate the checking of these assumptions. 
3. Incorrect handling of point doubling can allow signature forgery Severity: High Diﬃculty: High Type: Data Validation Finding ID: TOB-SUCCINCT-3 Target: telepathy/circuits/circuits/bls.circom Description When verifying the sync committee signature, individual public keys are aggregated into an overall public key by repeatedly calling G1Add in a tree structure. Due to the mishandling of elliptic curve point doublings, a minority of carefully selected public keys can cause the aggregation to result in an arbitrary, maliciously chosen public key, allowing signature forgeries and thus malicious light client updates. When bit1 and bit2 of G1Add are both set, G1Add computes out by calling EllipticCurveAddUnequal : template parallel G1Add(N, K) { var P[ 7 ] = getBLS128381Prime(); signal input pubkey1[ 2 ][K]; signal input pubkey2[ 2 ][K]; signal input bit1; signal input bit2; /* COMPUTE BLS ADDITION */ signal output out[ 2 ][K]; signal output out_bit; out_bit <== bit1 + bit2 - bit1 * bit2; component adder = EllipticCurveAddUnequal( 55 , 7 , P); for ( var i = 0 ; i < 2 ; i++) { for ( var j = 0 ; j < K; j++) { adder.a[i][j] <== pubkey1[i][j]; adder.b[i][j] <== pubkey2[i][j]; } } Figure 3.1: telepathy/circuits/circuits/bls.circom#82– The results of EllipticCurveAddUnequal are constrained by equations that reduce to 0 = 0 if a and b are equal: // constrain x_3 by CUBIC (x_1 + x_2 + x_3) * (x_2 - x_1)^2 - (y_2 - y_1)^2 = 0 mod p component dx_sq = BigMultShortLong(n, k, 2 *n+LOGK+ 2 ); // 2k-1 registers abs val < k*2^{2n} component dy_sq = BigMultShortLong(n, k, 2 *n+LOGK+ 2 ); // 2k-1 registers < k*2^{2n} for ( var i = 0 ; i < k; i++){ dx_sq.a[i] <== b[ 0 ][i] - a[ 0 ][i]; dx_sq.b[i] <== b[ 0 ][i] - a[ 0 ][i]; dy_sq.a[i] <== b[ 1 ][i] - a[ 1 ][i]; dy_sq.b[i] <== b[ 1 ][i] - a[ 1 ][i]; } [...] component cubic_mod = SignedCheckCarryModToZero(n, k, 4 *n + LOGK3, p); for ( var i= 0 ; i<k; i++) cubic_mod. in [i] <== cubic_red.out[i]; // END OF CONSTRAINING x3 // constrain y_3 by (y_1 + y_3) * (x_2 - x_1) = (y_2 - y_1)*(x_1 - x_3) mod p component y_constraint = PointOnLine(n, k, p); // 2k-1 registers in [0, k*2^{2n+1}) for ( var i = 0 ; i < k; i++) for ( var j= 0 ; j< 2 ; j++){ y_constraint. in [ 0 ][j][i] <== a[j][i]; y_constraint. in [ 1 ][j][i] <== b[j][i]; y_constraint. in [ 2 ][j][i] <== out[j][i]; } // END OF CONSTRAINING y3 Figure 3.2: telepathy/circuits/circuits/pairing/curve.circom#182–221 If any inputs to G1Add are equal, a malicious prover can choose outputs to trigger this bug repeatedly and cause the signature to be checked with a public key of their choice. Each input to G1Add can be either a committee member public key or an intermediate aggregate key. Exploit Scenario Alice, a malicious prover, registers public keys A = aG , B = bG and C = (a+b)G . She waits for a sync committee selection in which A , B and C are all present and located in the same subtree of the sync committee participation array. By setting all other participation bits in that subtree to zero, Alice can force EllipticCurveAddUnequal to be called on A+B and C . Using the underconstrained point addition formula, she can prove that the sum of these points is equal to the next subtree root, and repeat until she has arbitrarily selected the aggregated public key. Alice can then forge a signature for an arbitrary block header and steal all user funds. Recommendations Short term, change G1Add to use EllipticCurveAdd , which correctly handles equal inputs. Long term, review all uses of EllipticCurveAddUnequal to ensure that the inputs have diﬀerent X components. 
4. EllipticCurveAdd mishandles points at inﬁnity Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-SUCCINCT-4 Target: circuits/circuits/{curve.circom, curve_fp2.circom} Description The EllipticCurveAdd and EllipticCurveAddFp2 templates contain a logic bug when handling points at inﬁnity, which can cause them to return incorrect results for speciﬁc sequences of elliptic curve point additions. The EllipticCurveAdd template is currently unused in the Telepathy codebase, while EllipticCurveAddFp2 is used only in the context of cofactor clearing during the hash-to-curve process. Because the bug is triggered only in special sequences of operations, as described below, the random inputs generated by the hashing process are extremely unlikely to trigger the bug. However, if EllipticCurveAdd were to be used in the future (e.g., as we recommend in TOB-SUCCINCT-3 ), this bug may be exploitable using carefully chosen malicious inputs. Figure 4.1 shows the logic, contained in EllipticCurveAdd and EllipticCurveAddFp2 , that determines whether the point returned from EllipticCurveAdd is the point at inﬁnity. // If isInfinity = 1, replace `out` with `a` so if `a` was on curve, so is output ... // out = O iff ( a = O AND b = O ) OR ( x_equal AND NOT y_equal ) signal ab0; ab0 <== aIsInfinity * bIsInfinity; signal anegb; anegb <== x_equal.out - x_equal.out * y_equal.out; isInfinity <== ab0 + anegb - ab0 * anegb; // OR gate Figure 4.1: telepathy/circuits/circuits/pairing/curve.circom#344–349 When point A is the point at inﬁnity, represented in projective coordinates as (X, Y, 0) , and B is the point (X, -Y, 1) , EllipticCurveAdd should return B unchanged and in particular should set isInfinity to zero. However, because the x_equal AND NOT y_equal clause is satisﬁed, the EllipticCurveAdd function returns A (a point at inﬁnity). This edge case is reachable by computing the sequence of additions (A - A) - A , for any point A , which will return O instead of the correct result of -A . This edge case was ﬁrst noted in a GitHub issue ( #13 ) in the upstream yi-sun/circom-pairing library. We discovered that the edge case is in fact reachable via the sequence above and upstreamed a patch . Exploit Scenario The Succinct Labs developers modify the G1Add template as recommended in TOB-SUCCINCT-3 . A malicious sync committee member then constructs public keys such that the G1Add process produces a sequence of additions that trigger the bug. Honest provers then cannot create proofs due to the miscomputed aggregate public key, causing funds to become stuck in the bridge. Recommendations Short term, update the pairing circuits to match the latest version of yi-sun/circom-pairing . Long term, consider making the pairing and SHA-256 libraries npm dependencies or Git submodules so that developers can easily keep up to date with security ﬁxes in the upstream libraries. 
5. Circom circuits lack adequate testing framework Severity: Informational Diﬃculty: Low Type: Testing Finding ID: TOB-SUCCINCT-5 Target: circuits/test Description The Telepathy Circom circuits do not have functioning unit tests or a systematic testing framework. Running the end-to-end circuit tests requires a large amount of RAM, disk space, and CPU time, and is infeasible on typical developer machines. Because it is diﬃcult to rapidly develop and run tests, new code changes are likely to be insuﬃciently tested before deployment. The presence of a testing framework greatly aids security engineers, as it allows for the rapid adaptation of testing routines into security testing routines. Recommendations Short term, begin writing unit tests for each sub-circuit and requiring tests for all new code. Long term, implement a framework for rapidly running all unit tests as well as end-to-end tests on scaled-down versions of the full circuits. 
6. Poseidon commitment uses a non-standard hash construction Severity: Informational Diﬃculty: High Type: Cryptography Finding ID: TOB-SUCCINCT-6 Target: circuits/circuits/poseidon.circom Description Telepathy commits to the set of sync committee public keys with a Poseidon-based hash function. This hash function uses a construction with poor theoretical properties. The hash is computed by PoseidonFieldArray , using a Merkle–Damgård construction with circomlib ’s Poseidon template as the compression function: template PoseidonFieldArray(LENGTH) { signal input in [LENGTH]; signal output out ; var POSEIDON_SIZE = 15 ; var NUM_HASHERS = (LENGTH \ POSEIDON_SIZE) + 1 ; component hashers[NUM_HASHERS]; for ( var i = 0 ; i < NUM_HASHERS; i++) { if (i > 0 ) { POSEIDON_SIZE = 16 ; } hashers[i] = Poseidon(POSEIDON_SIZE); for ( var j = 0 ; j < 15 ; j++) { if (i * 15 + j >= LENGTH ) { hashers[i].inputs[j] <== 0 ; } else { hashers[i].inputs[j] <== in [i*15 + j]; } } if (i > 0 ) { hashers[i].inputs[15] <== hashers[i- 1]. out ; } } out <== hashers[NUM_HASHERS-1]. out ; } Figure 6.1: telepathy/circuits/circuits/poseidon.circom#25–51 The Poseidon authors recommend using a sponge construction, which has better provable security properties than the MD construction. One could implement a sponge by using PoseidonEx with nOuts = 1 for intermediate calls and nOuts = 2 for the ﬁnal call. For each call, out[0] should be passed into the initialState of the next PoseidonEx component, and out[1] should be used for the ﬁnal output. By maintaining out[0] as hidden capacity, the overall construction will closely approximate a pseudorandom function. Although the MD construction oﬀers suﬃcient protection against collision for the current commitment use case, hash functions constructed in this manner do not fully model random functions. Future uses of the PoseidonFieldArray circuit may expect stronger cryptographic properties, such as resistance to length extension. Additionally, by utilizing the initialState input, as shown in ﬁgure 6.2, on each permutation call, 16 inputs can be compressed per template instantiation, as opposed to the current 15, without any additional cost per compression. This will reduce the number of compressions required and thus reduce the size of the circuit. template PoseidonEx(nInputs, nOuts) { signal input inputs[nInputs]; signal input initialState; signal output out [nOuts]; Figure 6.2: circomlib/circuits/poseidon.circom#67–70 Recommendations Short term, convert PoseidonFieldArray to use a sponge construction, ensuring that out[0] is preserved as a hidden capacity value. Long term, ensure that all hashing primitives are used in accordance with the published recommendations. 
7. Merkle root reconstruction is vulnerable to forgery via proofs of incorrect length Severity: High Diﬃculty: Low Type: Cryptography Finding ID: TOB-SUCCINCT-7 Target: contracts/src/libraries/SimpleSerialize.sol Description The TargetAMB contract accepts and veriﬁes Merkle proofs that a particular smart contract event was issued in a particular Ethereum 2.0 beacon block. Because the proof validation depends on the length of the proof rather than the index of the value to be proved, Merkle proofs with invalid lengths can be used to mislead the veriﬁer and forge proofs for nonexistent transactions. The SSZ.restoreMerkleRoot function reconstructs a Merkle root from the user-supplied transaction receipt and Merkle proof; the light client then compares the root against the known-good value stored in the LightClient contract. The index argument to restoreMerkleRoot determines the speciﬁc location in the block state tree at which the leaf node is expected to be found. The arguments leaf and branch are supplied by the prover, while the index argument is calculated by the smart contract veriﬁer. function restoreMerkleRoot ( bytes32 leaf , uint256 index , bytes32 [] memory branch) internal pure returns ( bytes32 ) { } bytes32 value = leaf; for ( uint256 i = 0 ; i < branch.length; i++) { if ((index / ( 2 ** i)) % 2 == 1 ) { value = sha256( bytes .concat(branch[i], value)); } else { value = sha256( bytes .concat(value, branch[i])); } } return value; Figure 7.1: telepathy/contracts/src/libraries/SimpleSerialize.sol#24–38 A malicious user may supply a proof (i.e., a branch list) that is longer or shorter than the number of bits in the index . In this case, the leaf value will not in fact correspond to the receiptRoot but to some other value in the tree. In particular, the user can convince the smart contract that receiptRoot is the value at any generalized index given by truncating the leftmost bits of the true index or by extending the index by arbitrarily many zeroes following the leading set bit. If one of these alternative indexes contains data controllable by the user, who may for example be the block proposer, then the user can forge a proof for a transaction that did not occur and thus steal funds from bridges relying on the TargetAMB . Exploit Scenario Alice, a malicious ETH2.0 validator, encodes a fake transaction receipt hash encoding a deposit to a cross-chain bridge into the graffiti ﬁeld of a BeaconBlock . She then waits for the block to be added to the HistoricalBlocks tree and further for the generalized index of the historical block to coincide with an allowable index for the Merkle tree reconstruction. She then calls executeMessageFromLog with the transaction receipt, allowing her to withdraw from the bridge based on a forged proof of deposit and steal funds. Recommendations Short term, rewrite restoreMerkleRoot to loop over the bits of index , e.g. with a while loop terminating when index = 1 . Long term, ensure that proof veriﬁcation routines do not use control ﬂow determined by untrusted input. The veriﬁcation routine for each statement to be proven should treat all possible proofs uniformly. 
8. LightClient forced ﬁnalization could allow bad updates in case of a DoS Severity: High Diﬃculty: Medium Type: Access Controls Finding ID: TOB-SUCCINCT-8 Target: contracts/src/lightclient/LightClient.sol Description Under periods of delayed ﬁnality, the LightClient may ﬁnalize block headers with few validators participating. If the Telepathy provers were targeted by a denial-of-service (DoS) attack, this condition could be triggered and used by a malicious validator to take control of the LightClient and ﬁnalize malicious block headers. The LightClient contract typically considers a block header to be ﬁnalized if it is associated with a proof that more than two-thirds of sync committee participants have signed the header. Typically, the sync committee for the next period is determined from a ﬁnalized block in the current period. However, in the case that the end of the sync committee period is reached before any block containing a sync committee update is ﬁnalized, a user may call the LightClient.force function to apply the update with the most signatures, even if that update has less than a majority of signatures. A forced update may have as few as 10 participating signers, as determined by the constant MIN_SYNC_COMMITTEE_PARTICIPANTS . /// @notice In the case there is no finalization for a sync committee rotation, this method /// is used to apply the rotate update with the most signatures throughout the period. /// @param period The period for which we are trying to apply the best rotate update for. function force ( uint256 period ) external { LightClientRotate memory update = bestUpdates[period]; uint256 nextPeriod = period + 1 ; if (update.step.finalizedHeaderRoot == 0 ) { revert( "Best update was never initialized" ); } else if (syncCommitteePoseidons[nextPeriod] != 0 ) { revert( "Sync committee for next period already initialized." ); } else if (getSyncCommitteePeriod(getCurrentSlot()) < nextPeriod) { revert( "Must wait for current sync committee period to end." ); } setSyncCommitteePoseidon(nextPeriod, update.syncCommitteePoseidon); } Figure 8.1: telepathy/contracts/src/lightclient/LightClient.sol#123– Proving sync committee updates via the rotate ZK circuit requires signiﬁcant computational power; it is likely that there will be only a few provers online at any given time. In this case, a DoS attack against the active provers could cause the provers to be oﬄine for a full sync committee period (~27 hours), allowing the attacker to force an update with a small minority of validator stake. The attacker would then gain full control of the light client and be able to steal funds from any systems dependent on the correctness of the light client. Exploit Scenario Alice, a malicious ETH2.0 validator, controls about 5% of the total validator stake, split across many public keys. She waits for a sync committee period, includes at least 10 of her public keys, then launches a DoS against the active Telepathy provers, using an attack such as that described in TOB-SUCCINCT-1 or an attack against the oﬀchain prover/relayer client itself. Alice creates a forged beacon block with a new sync committee containing only her own public keys, then uses her 10 active committee keys to sign the block. She calls LightClient.rotate with this forged block and waits until the sync committee period ends, ﬁnally calling LightClient.force to gain control over all future light client updates. Recommendations Short term, consider removing the LightClient.force function, extending the waiting period before updates may be forced, or introducing a privileged role to mediate forced updates. Long term, explicitly document expected liveness behavior and associated safety tradeoﬀs. 
9. G1AddMany does not check for the point at inﬁnity Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-SUCCINCT-9 Target: circuits/circuits/{sync_committee.circom, bls.circom} Description The G1AddMany circuit aggregates multiple public keys into a single public key before verifying the BLS signature. The outcome of the aggregation is used within CoreVerifyPubkeyG1 as the public key. However, G1AddMany ignores the value of the ﬁnal out_bits , and wrongly converts a point at inﬁnity to a diﬀerent point when all participation bits are zero. template G1AddMany(SYNC_COMMITTEE_SIZE, LOG_2_SYNC_COMMITTEE_SIZE, N, K) { signal input pubkeys[SYNC_COMMITTEE_SIZE][ 2 ][K]; signal input bits[SYNC_COMMITTEE_SIZE]; signal output out[ 2 ][K]; [...] for ( var i = 0 ; i < 2 ; i++) { for ( var j = 0 ; j < K; j++) { out[i][j] <== reducers[LOG_2_SYNC_COMMITTEE_SIZE- 1 ].out[ 0 ][i][j]; } } } Figure 9.1: BLS key aggregation without checks for all-zero participation bits ( telepathy/circuits/circuits/bls.circom#16–48 ) Recommendations Short term, augment the G1AddMany template with an output signal that indicates whether the aggregated public key is the point at inﬁnity. Check that the aggregated public key is non-zero in the calling circuit by verifying that the output of G1AddMany is not the point at inﬁnity (for instance, in VerifySyncCommitteeSignature ). Long term, assert that all provided elliptic curve points are non-zero before converting them to aﬃne form and using them where a non-zero point is expected. 
10. TargetAMB receipt proof may behave unexpectedly on future transaction types Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-SUCCINCT-10 Target: contracts/src/libraries/StateProofHelper.sol Description The TargetAMB contract can relay transactions from the SourceAMB via events logged in transaction receipts. The contract currently ignores the version speciﬁer in these receipts, which could cause unexpected behavior in future upgrade hard-forks. To relay a transaction from a receipt, the user provides a Merkle proof that a particular transaction receipt is present in a speciﬁed block; the relevant event is then parsed from the transaction receipt by the TargetAMB . function getEventTopic (...){ ... bytes memory value = MerklePatriciaProofVerifier.extractProofValue(receiptRoot, key, proofAsRLP); RLPReader.RLPItem memory valueAsItem = value.toRlpItem(); if (!valueAsItem.isList()) { // TODO: why do we do this ... valueAsItem.memPtr++; valueAsItem.len--; } RLPReader.RLPItem[] memory valueAsList = valueAsItem.toList(); require (valueAsList.length == 4 , "Invalid receipt length" ); // In the receipt, the 4th entry is the logs RLPReader.RLPItem[] memory logs = valueAsList[ 3 ].toList(); require (logIndex < logs.length, "Log index out of bounds" ); RLPReader.RLPItem[] memory relevantLog = logs[logIndex].toList(); ... } Figure 10.1: telepathy/contracts/src/libraries/StateProofHelper.sol#L44–L82 The logic in ﬁgure 10.1 checks if the transaction receipt is an RLP list; if it is not, the logic skips one byte of the receipt before continuing with parsing. This logic is required in order to properly handle legacy transaction receipts as deﬁned in EIP-2718 . Legacy transaction receipts directly contain the RLP-encoded list rlp([status, cumulativeGasUsed, logsBloom, logs]) , whereas EIP- TransactionType|| TransactionPayload , where TransactionType is a one-byte indicator between 0x00 and 0x7f and TransactionPayload may vary depending on the transaction type. Current valid transaction types are 0x01 and 0x02 . New transaction types may be added during routine Ethereum upgrade hard-forks. The TransactionPayload ﬁeld of type 0x01 and 0x02 transactions corresponds exactly to the LegacyTransactionReceipt format; thus, simply skipping the initial byte is suﬃcient to handle these cases. However, EIP-2718 does not guarantee this backward compatibility, and future hard-forks may introduce transaction types for which this parsing method gives incorrect results. Because the current implementation lacks explicit validation of the transaction type, this discrepancy may go unnoticed and lead to unexpected behavior. Exploit Scenario An Ethereum upgrade fork introduces a new transaction type with a corresponding transaction receipt format that diﬀers from the legacy format. If the new format has the same number of ﬁelds but with diﬀerent semantics in the fourth slot, it may be possible for a malicious user to insert into that slot a value that parses as an event log for a transaction that did not take place, thus forging an arbitrary bridge message. Recommendations Short term, check the ﬁrst byte of valueAsItem against a list of allowlisted transaction types, and revert if the transaction type is invalid. Long term, plan for future incompatibilities due to upgrade forks; for example, consider adding a semi-trusted role responsible for adding new transaction type identiﬁers to an allowlist. 
11. RLPReader library does not validate proper RLP encoding Severity: Low Diﬃculty: Low Type: Data Validation Finding ID: TOB-SUCCINCT-11 Target: contracts/lib/Solidity-RLP/RLPReader.sol Description The TargetAMB uses the external RLPReader dependency to parse RLP-encoded nodes in the Ethereum state trie, including those provided by the user as part of a Merkle proof. When parsing a byte string as an RLPItem , the library does not check that the encoded payload length of the RLPitem matches the length of the underlying bytes. /* * @param item RLP encoded bytes */ function toRlpItem ( bytes memory item) internal pure returns (RLPItem memory ) { uint256 memPtr ; assembly { memPtr := add(item, 0x20 ) } return RLPItem(item.length, memPtr); } Figure 11.1: Solidity-RLP/contracts/RLPReader.sol#51–61 If the encoded byte length of the RLPitem is too long or too short, future operations on the RLPItem may access memory before or after the bounds of the underlying buﬀer. More generally, because the Merkle trie veriﬁer assumes that all input is in the form of valid RLP-encoded data, it is important to check that potentially malicious data is properly encoded. While we did not identify any way to convert improperly encoded proof data into a proof forgery, it is simple to give an example of an out-of-bounds read that could possibly lead in other contexts to unexpected behavior. In ﬁgure 11.2, the result of items[0].toBytes() contains many bytes read from memory beyond the bounds allocated in the initial byte string. RLPReader.RLPItem memory item = RLPReader.toRlpItem( '\xc3\xd0' ); RLPReader.RLPItem[] memory items = item.toList(); assert(items[ 0 ].toBytes().length == 16 ); Figure 11.2: Out-of-of-bounds read due to invalid RLP encoding In this example, RLPReader.toRLPItem should revert because the encoded length of three bytes is longer than the payload length of the string; similarly, the call to toList() should fail because the nested RLPItem encodes a length of 16, again more than the underlying buﬀer. To prevent such ill-constructed nested RLPItem s, the internal numItems function should revert if currPtr is not exactly equal to endPtr at the end of the loop shown in ﬁgure 11.3. // @return number of payload items inside an encoded list. function numItems (RLPItem memory item) private pure returns ( uint256 ) { if (item.len == 0 ) return 0 ; uint256 count = 0 ; uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr); uint256 endPtr = item.memPtr + item.len; while (currPtr < endPtr) { currPtr = currPtr + _itemLength(currPtr); // skip over an item count++; } return count; } Figure 11.3: Solidity-RLP/contracts/RLPReader.sol#256–269 Recommendations Short term, add a check in RLPReader.toRLPItem that validates that the length of the argument exactly matches the expected length of preﬁx + payload based on the encoded preﬁx. Similarly, add a check in RLPReader.numItems , checking that the sum of the encoded lengths of sub-objects matches the total length of the RLP list. Long term, treat any length values or pointers in untrusted data as potentially malicious and carefully check that they are within the expected bounds. 
12. TargetAMB _executeMessage lacks contract existence checks Severity: Low Diﬃculty: Low Type: Error Reporting Finding ID: TOB-SUCCINCT-12 Target: contracts/src/amb/TargetAMB.sol Description When relaying messages on the target chain, the TargetAMB records the success or failure of the external contract call so that oﬀ-chain clients can track the success of their messages. However, if the recipient of the call is an externally owned-account or is otherwise empty, the handleTelepathy call will appear to have succeeded when it was not processed by any recipient. bytes memory recieveCall = abi.encodeWithSelector( ITelepathyHandler.handleTelepathy.selector, message.sourceChainId, message.senderAddress, message.data ); address recipient = TypeCasts.bytes32ToAddress(message.recipientAddress); (status,) = recipient.call(recieveCall); if (status) { messageStatus[messageRoot] = MessageStatus.EXECUTION_SUCCEEDED; } else { messageStatus[messageRoot] = MessageStatus.EXECUTION_FAILED; } Figure 12.1: telepathy/contracts/src/amb/TargetAMB.sol#150–164 Exploit Scenario A user accidentally sends a transaction to the wrong address or an address that does not exist on the target chain. The UI displays the transaction as successful, possibly confusing the user further. Recommendations Short term, change the handleTelepathy interface to expect a return value and check that the return value is some magic constant, such as the four-byte ABI selector. See OpenZeppelin’s safeTransferFrom / IERC721Reciever pattern for an example. Long term, ensure that all low-level calls behave as expected when handling externally owned accounts. 
13. LightClient is unable to verify some block headers Severity: Medium Diﬃculty: Low Type: Authentication Finding ID: TOB-SUCCINCT-13 Target: contracts/src/lightclient/LightClient.sol This issue was discovered and relayed to the audit team by the Telepathy developers. We include it here for completeness and to provide our ﬁx recommendations. Description The LightClient contract expects beacon block headers produced in a period prior to the period in which they are ﬁnalized to be signed by the wrong sync committee; those blocks will not be validated by the LightClient , and AMB transactions in these blocks may be delayed. The Telepathy light client tracks only block headers that are “ﬁnalized,” as deﬁned by the ETH2.0 Casper ﬁnality mechanism. Newly proposed, unﬁnalized beacon blocks contain a finalized_checkpoint ﬁeld with the most recently ﬁnalized block hash. The Step circuit currently exports only the slot number of this nested, ﬁnalized block as a public input. The LightClient contract uses this slot number to determine which sync committee it expects to sign the update. However, the correct slot number for this use is in fact that of the wrapping, unﬁnalized block. In some cases, such as near the edge of a sync committee period or during periods of delayed ﬁnalization, the two slots may not belong to the same sync committee period. In this case, the signature will fail to verify, and the LightClient will become unable to validate the block header. Exploit Scenario A user sends an AMB message using the SourceAMB.sendViaLog function. The beacon block in which this execution block is included is late within a sync committee period and is not ﬁnalized on the beacon chain until the next period. The new sync committee signs the block, but this signature is rejected by the light client because it expects a signature from the old committee. Because this header cannot be ﬁnalized in the light client, the TargetAMB cannot relay the message until some future block in the new sync committee period is ﬁnalized in the light client, causing delivery delays. Recommendations Short term, Include attestedSlot in the public input commitment to the Step circuit. This can be achieved at no extra cost by packing the eight-byte attestedSlot value alongside the eight-byte finalizedSlot value, which currently is padded to 32 bytes. Long term, add additional unit and end-to-end tests to focus on cases where blocks are near the edges of epochs and sync committee periods. Further, reduce gas usage and circuit complexity by packing all public inputs to the step function into a single byte array that is hashed in one pass, rather than chaining successive calls to SHA-256, which reduces the eﬀective rate by half and incurs overhead due to the additional external precompile calls. 
14. OptSimpleSWU2 Y-coordinate output is underconstrained Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-SUCCINCT-14 Target: circuits/circuits/pairing/bls12_381_hash_to_G2.circom Description The OptSimpleSWU2 circuit does not check that its Y-coordinate output is a properly formatted BigInt. This violates the canonicity assumptions of the Fp2Sgn0 circuit and other downstream components, possibly leading to unexpected nondeterminism in the sign of the output of MapToG2 . Incorrect results from MapToG2 would cause the circuit to verify the provided signature against a message diﬀerent from that in the public input. While this does not allow malicious provers to forge signatures on arbitrary messages, this additional degree of freedom in witness generation could interact negatively with future changes to the codebase or instantiations of this circuit. var Y[2][50]; ... component Y_sq = Fp2Multiply(n, k, p); // Y^ 2 == g(X) for ( var i= 0 ; i< 2 ; i++) for ( var idx= 0 ; idx<k; idx++){ out [1][i][idx] <-- Y[i][idx]; Y_sq.a[i][idx] <== out [1][i][idx]; Y_sq.b[i][idx] <== out [1][i][idx]; } for ( var i= 0 ; i< 2 ; i++) for ( var idx= 0 ; idx<k; idx++){ Y_sq. out [i][idx] === isSquare * (gX0. out [i][idx] - gX1. out [i][idx]) + gX1. out [i][idx]; } // sgn0(Y) == sgn0(t) component sgn_Y = Fp2Sgn0(n, k, p); for ( var i= 0 ; i< 2 ; i++) for ( var idx= 0 ; idx<k; idx++) sgn_Y. in [i][idx] <== out [1][i][idx]; sgn_Y. out === sgn_in. out ; Figure 14.1: telepathy/circuits/circuits/pairing/bls12_381_hash_to_G2.circom#199–226 A malicious prover can generate a witness where that Y-coordinate is not in its canonical representation. OptSimpleSWU2 calls Fp2Sgn0 , which in turn calls FpSgn0 . Although FpSgn0 checks that its input is less than p using BigLessThan , that is not suﬃcient to guarantee that its input is canonical. BigLessThan allows limbs of its inputs to be greater than or equal to 2 n , so long as the diﬀerence a[i]-b[i] is in . Violating FpSgn0 ’s 𝑛 𝑛 ) , 2 [− 2 assumption that the limbs are all in cases—for example, if FpSgn0 ’s output is incorrect, MapToG2 could return a point with an incorrect sign. could lead to unexpected behavior in some 𝑛 ) [ 0 , 2 template FpSgn0(n, k, p){ signal input in [k]; signal output out ; // constrain in < p component lt = BigLessThan(n, k); for ( var i= 0 ; i<k; i++){ lt.a[i] <== in [i]; lt.b[i] <== p[i]; } lt. out === 1 ; // note we only need in [0] ! var r = in [0] % 2 ; var q = ( in [0] - r) / 2 ; out <-- r; signal div; div <-- q; out * ( 1 - out ) === 0 ; in [0] === 2 * div + out ; } Figure 14.2: telepathy/circuits/circuits/pairing/fp.circom#229–249 Exploit Scenario A malicious prover can use a malformed BigInt to change the computed sign of the out signal of OptSimpleSWU2 at proving time. That changed sign will cause the rest of the circuit to accept certain incorrect values in place of H(m) when checking the BLS signature. The prover could then successfully generate a proof with certain malformed signatures. Recommendations Short term, use Num2Bits to constrain the Y-coordinate output of OptSimpleSWU2 to be a well-formed BigInt . Long term, clearly document and validate the representation of the output values in templates such as OptSimpleSWU2 . 
