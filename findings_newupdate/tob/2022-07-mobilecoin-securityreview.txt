1. Project contains vulnerable dependencies Severity: Undetermined Diﬃculty: High Type: Patching Finding ID: TOB-MCCT-1 Target: Various Description Running cargo-audit over the codebase revealed that the system under audit uses crates with Rust Security (RustSec) advisories and crates that are no longer maintained. RustSec ID Description Dependency CVSS Score 2022-0006 Data race in Iter and IterMut thread_local 1.0.1 N/A 2020-0071 2021-0003 2022-0013 2020-0036 2018-0017 Potential segfault in the time crate Buﬀer overﬂow in SmallVec::insert_many Regexes with large repetitions on empty sub-expressions take a very long time to parse failure is oﬃcially deprecated/unmaintained time 0.1.43 Medium smallvec 1.2.0 Critical regex 1.3.0 High failure 0.1.8 Critical tempdir has been deprecated; use tempfile instead tempdir 0.3.7 N/A Figure 1.1: cargo-audit results Exploit Scenario Eve discovers a code path leading to a vulnerable crate and uses the code path to conduct exploits such as crashing nodes and corrupting memory. Recommendations Short term, update the vulnerable dependencies to safe versions and use alternatives to the unmaintained/deprecated ones. Long term, regularly run cargo-audit over the codebase. Doing so can help reveal similar bugs. Additionally, consider integrating cargo-audit into the CI/CD pipeline. References ● cargo-audit 
2. MobileCoin Foundation could infer token IDs in certain scenarios Severity: Informational Diﬃculty: High Type: Data Exposure Finding ID: TOB-MCCT-2 Target: Various Description The MobileCoin Foundation is the recipient of all transaction fees and, in certain scenarios, could infer the token ID used in one of multiple transactions included in a block. MCIP-0025 introduced the concept of “conﬁdential token IDs.” The rationale behind the proposal is to allow the MobileCoin network to support tokens other than MOB (MobileCoin’s native token) in the future. Doing so requires not only that these tokens be unequivocally identiﬁable but also that transactions involving any token, MOB or otherwise, have the same conﬁdentiality properties. Before the introduction of the conﬁdential tokens feature, all transaction fees were aggregated by the enclave, which created a single transaction fee output per block; however, the same approach applied to a system that supports transfers of tokens other than MOB could introduce information leakage risks. For example, if two users submit two transactions with the same token ID, there would be a single transaction fee output, and therefore, both users would know that they transacted with the same token. To prevent such a leak of information, MCIP-0025 proposes the following: The number of transaction fee outputs on a block should always equal the minimum value between the number of token IDs and the number of transactions in that block (e.g., num_tx_fee_out = min(num_token_ids, num_transactions)). This essentially means that a block with a single transaction will still have a single transaction fee output, but a block with multiple transactions with the same token ID will have multiple transaction fee outputs, one with the aggregated fee and the others with a zero-value fee. Finally, it is worth mentioning that transaction fees are not paid in MOB but in the token that is being transacted; this creates a better user experience, as users do not need to own MOB to send tokens to other people. While this proposal does indeed preserve the conﬁdentiality requirement, it falls short in one respect: the receiver of all transaction fees in the MobileCoin network is the MobileCoin Foundation, meaning that it will always know the token ID corresponding to a transaction fee output. Therefore, if only a single token is used in a block, the foundation will know the token ID used by all of the transactions in that block. Exploit Scenario Alice and Bob use the MobileCoin network to make payments between them. They send each other multiple payments, using the same token, and their transactions are included in a single block. Eve, who has access to the MobileCoin Foundation’s viewing key, is able to decrypt the transaction fee outputs corresponding to that block and, because no other token was used inside the block, is able to infer the token that Alice and Bob used to make the payments. Recommendations Short term, document the fact that transaction token IDs are visible to the MobileCoin Foundation. Transparency on this issue will help users understand the information that is visible by some parties. Additionally, consider implementing the following alternative designs: ● Require that all transaction fees be paid in MOB. This solution would result in a degraded user experience compared to the current design; however, it would address the issue at hand. ● Aggregate fee outputs across multiple blocks. This solution would achieve only “probabilistic conﬁdentiality” of information because if all those blocks transact in the same token, the foundation would still be able to infer the ID. Long term, document the trade-oﬀs between allowing users to pay fees in the tokens they transact with and restricting fee payments to only MOB, and document how these trade-oﬀs could aﬀect the conﬁdentiality of the system. 
3. Token IDs are protected only by SGX Severity: Informational Diﬃculty: High Type: Access Controls Finding ID: TOB-MCCT-3 Target: consensus/enclave/impl/src/lib.rs Description Token IDs are intended to be conﬁdential. However, they are operated on within an SGX enclave. This is an apparent departure from MobileCoin’s previous approach of using SGX as an additional security mechanism, not a primary one. Previously, most conﬁdential information in MobileCoin was protected by SGX and another security mechanism. Examples include the following: ● A transactions’ senders, recipients, and amounts are protected by SGX and ring signatures. ● The transactions a user interacts with through Fog are protected by both SGX and oblivious RAM. However, token IDs are protected by SGX alone. (An example in which a token ID is operated on within an enclave appears in ﬁgure 3.1.) Thus, the incorporation of conﬁdential tokens seems to represent a shift in MobileCoin’s security posture. let token_id = TokenId::from(tx.prefix.fee_token_id); let minimum_fee = ct_min_fees .get(&token_id) .ok_or(TransactionValidationError::TokenNotYetConfigured)?; Figure 3.1: consensus/enclave/impl/src/lib.rs#L239-L243 Exploit Scenario Mallory learns of a vulnerability that allows her to see inside of an SGX enclave. Mallory uses the vulnerability to observe the token IDs used in transactions in a MobileCoin enclave that she runs. Recommendations Short term, document the fact that token IDs are not oﬀered the same level of security as other aspects of MobileCoin. This will help set users’ expectations regarding the conﬁdentiality of their information (i.e., whether it could be revealed to an attacker). Long term, continue to investigate solutions to the security problems surrounding the conﬁdential tokens feature. A solution that does not reveal token IDs to the enclave could exist. 
4. Nonces are not stored per token Severity: Low Diﬃculty: High Type: Denial of Service Finding ID: TOB-MCCT-4 Target: Various Description Mint and mint conﬁguration transaction nonces are not distinguished by the tokens with which they are associated. Malicious minters or governors could use this fact to conduct denial-of-service attacks against other minters and governors. The relevant code appears in ﬁgures 4.1 and 4.2. For each type of transaction, nonces are inserted into a seen_nonces set without regard to the token indicated in the transaction. let mut seen_nonces = BTreeSet::default(); let mut validated_txs = Vec::with_capacity(mint_config_txs.len()); for tx in mint_config_txs { // Ensure all nonces are unique. if !seen_nonces.insert(tx.prefix.nonce.clone()) { return Err(Error::FormBlock(format!( "Duplicate MintConfigTx nonce: {:?}", tx.prefix.nonce ))); } Figure 4.1: consensus/enclave/impl/src/lib.rs#L342-L352 let mut mint_txs = Vec::with_capacity(mint_txs_with_config.len()); let mut seen_nonces = BTreeSet::default(); for (mint_tx, mint_config_tx, mint_config) in mint_txs_with_config { // The nonce should be unique. if !seen_nonces.insert(mint_tx.prefix.nonce.clone()) { return Err(Error::FormBlock(format!( "Duplicate MintTx nonce: {:?}", mint_tx.prefix.nonce ))); } Figure 4.2: consensus/enclave/impl/src/lib.rs#L384-L393 Note that the described attack could be made worse by how nonces are intended to be used. The following passage from the white paper suggests that nonces are generated deterministically from public data. Generating nonces in this way could make them easy for an attacker to predict. When submitting a MintTx, we include a nonce to protect against replay attacks, and a tombstone block to prevent the transaction from being nominated indeﬁnitely, and these are committed to the chain. (For example, in a bridge application, this nonce may be derived from records on the source chain, to ensure that each deposit on the source chain leads to at most one mint.) Exploit Scenario Mallory (a minter) learns that Alice (another minter) intends to submit a mint transaction with a particular nonce. Mallory submits a mint transaction with that nonce ﬁrst, making Alice’s invalid. Recommendations Short term, store nonces per token, instead of all together. Doing so will prevent the denial-of-service attack described above. Long term, when adding new data to blocks or to the blockchain conﬁguration, carefully consider whether it should be stored per token. Doing so could help to prevent denial-of-service attacks. 
5. Clients have no option for verifying blockchain conﬁguration Severity: Informational Diﬃculty: High Type: Authentication Finding ID: TOB-MCCT-5 Target: Various Description Clients have no way to verify whether the MobileCoin node they connect to is using the correct blockchain conﬁguration. This exposes users to attacks, as detailed in the white paper: Similarly to how the nodes ensure that they are similarly conﬁgured during attestation, (by mixing a hash of their conﬁguration into the responder id used during attestation), the peer- to-node attestation channels could also do this, so that users can fail to attest immediately if malicious manipulation of conﬁguration has occurred. The problem with this approach is that the users have no particularly good source of truth around the correct runtime conﬁguration of the services. The problem that “users have no particularly good source of truth” could be solved by publishing the latest blockchain conﬁguration via a separate channel (e.g., a publicly accessible server). Furthermore, allowing users to opt in to such additional checks would provide additional security to users who desire it. Exploit Scenario Alice falls victim to the attack described in the white paper. The attack would have been thwarted had Alice known that the node she connected to was not using the correct blockchain conﬁguration. Recommendations Short term, make the current blockchain conﬁguration publicly available, and allow nodes to attest to clients using their conﬁguration. Doing so will help security-conscious users to better protect themselves. Long term, avoid withholding data from clients during attestation. Adopt a general principle that if data should be included in node-to-node attestation, then it should be included in node-to-client attestation as well. Doing so will help to ensure the security of users. 
6. Conﬁdential tokens cannot support frequent price swings Severity: Informational Diﬃculty: High Type: Denial of Service Finding ID: TOB-MCCT-6 Target: Various Description The method for determining tokens’ minimum fees has limited applicability. In particular, it cannot support tokens whose prices change frequently. In principle, a token’s minimum fee should be comparable in value to the MOB minimum fee. Thus, if a token’s price increases relative to the price of MOB, the token’s minimum fee should decrease. Similarly, if a token’s price decreases relative to the price of MOB, the token’s minimum fee should increase. However, an enclave sets its fee map from the blockchain conﬁguration during initialization (ﬁgure 6.1) and does not change the fee map thereafter. Thus, the enclave would seem to have to be restarted if its blockchain conﬁguration and fee map were to change. This fact implies that the current setup cannot support tokens whose prices shift frequently. fn enclave_init( &self, peer_self_id: &ResponderId, client_self_id: &ResponderId, sealed_key: &Option<SealedBlockSigningKey>, blockchain_config: BlockchainConfig, ) -> Result<(SealedBlockSigningKey, Vec<String>)> { // Check that fee map is actually well formed FeeMap::is_valid_map(blockchain_config.fee_map.as_ref()).map_err(Error::FeeMap)?; // Validate governors signature. if !blockchain_config.governors_map.is_empty() { let signature = blockchain_config .governors_signature .ok_or(Error::MissingGovernorsSignature)?; let minting_trust_root_public_key = Ed25519Public::try_from(&MINTING_TRUST_ROOT__KEY[..]) .map_err(Error::ParseMintingTrustRootPublicKey)?; minting_trust_root_public_key .verify_governors_map(&blockchain_config.governors_map, &signature) .map_err(|_| Error::InvalidGovernorsSignature)?; } self.ct_min_fee_map .set(Box::new( blockchain_config.fee_map.as_ref().iter().collect(), )) .expect("enclave was already initialized"); Figure 6.1: consensus/enclave/impl/src/lib.rs#L454-L483 Exploit Scenario MobileCoin integrates token T. The value of T decreases, but the minimum fee remains the same. Users pay the minimum fee, resulting in lost income to the MobileCoin Foundation. Recommendations Short term, accept only tokens with a history of price stability. Doing so will ensure that the new features are used only with tokens that can be supported. Long term, consider including two inputs in each transaction, one for the token transferred and one to pay the fee in MOB, as suggested in TOB-MCCT-2. 
7. Overﬂow handling could allow recovery of transaction token ID Severity: Medium Diﬃculty: High Type: Data Exposure Finding ID: TOB-MCCT-7 Target: consensus/enclave/impl/src/lib.rs Description The system’s fee calculation could overﬂow a u64 value. When this occurs, the fee is divided up into multiple smaller fees, each ﬁtting into a u64 value. Under certain conditions, this behavior could be abused to reveal whether a token ID is used in a block. The relevant code appears in ﬁgure 7.1. The hypothetical attack is described in the exploit scenario below. loop { let output_fee = min(total_fee, u64::MAX as u128) as u64; outputs.push(mint_output( config.block_version, &fee_recipient, FEES_OUTPUT_PRIVATE_KEY_DOMAIN_TAG.as_bytes(), parent_block, &transactions, Amount { value: output_fee, token_id, }, outputs.len(), )); total_fee -= output_fee as u128; if total_fee == 0 { break; } } Figure 7.1: consensus/enclave/impl/src/lib.rs#L855-L873 Exploit Scenario Mallory is a (malicious) minter of token T. Suppose B is a recently minted block whose total number of fee outputs is equal to the number of tokens, which is less than the number of transactions in B. Further suppose that Mallory wishes to determine whether B contains a transaction involving T. Mallory does the following: 1. She puts her node into its state just prior to the minting of B. 2. She mints to herself a quantity of T worth ⌊u64::MAX / min_fee⌋ * min_fee. Call this quantity F. 3. She submits to her node a transaction with a fee of F. 4. She allows the block to be minted. 5. She observes the number of fee outputs in the modiﬁed block, B’: a. b. If B does not contain a transaction involving T, then B contains a fee output for T equal to zero, and B’ contains a fee output for T equal to F. If B does contain a transaction involving T, then B contains a fee output for T equal to at least min_fee, and B’ contains two fee outputs for T, one of which is equal to u64::MAX. Thus, by observing the number of outputs in B’, Mallory can determine whether B contains a transaction involving T. Recommendations Short term, require the total supply of all incorporated tokens not to exceed a u64 value. Doing so will eliminate the possibility of overﬂow and prevent the attack described above. Long term, consider incorporating randomness into the number of fee outputs generated. This could provide an alternative means of preventing the attack in a way that still allows for overﬂow. Alternatively, consider including two inputs in each transaction, one for the token transferred and one to pay the fee in MOB, as suggested in TOB-MCCT-2. 
