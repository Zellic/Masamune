1. Risk of misconﬁgured GasPriceOracle state variables that can lock L2 Severity: Undetermined Diﬃculty: Medium Type: Data Validation Finding ID: TOB-OPTEST-1 Target: optimism/packages/contracts/L2/predeploys/OVM_GasPriceOracle.sol , op-geth/core/rollup_l1_cost.go Description When bootstrapping the L2 network operated by op-geth , the GasPriceOracle contract is pre-deployed to L2, and its contract state variables are used to specify the L1 costs to be charged on L2. Three state variables are used to compute the costs— decimals , overhead , and scalar —which can be updated through transactions sent to the node. However, these state variables could be misconﬁgured in a way that sets gas prices high enough to prevent transactions from being processed. For example, if overhead were set to the maximum value, a 256-bit unsigned integer, the subsequent transactions would not be accepted. In an end-to-end test of the above example, contract bindings used in op-e2e tests (such as the GasPriceOracle bindings used to update the state variables) were no longer able to make subsequent transactions/updates, as calls to SetOverhead or SetDecimals resulted in a deadlock. Sending a transaction directly through the RPC client did not produce a transaction receipt that could be fetched. Recommendations Short term, implement checks to ensure that GasPriceOracle parameters can be updated if fee parameters were previously misconﬁgured. This could be achieved by adding an exception to GasPriceOracle fees when the contract owner calls methods within the contract or by setting a maximum fee cap. Long term, develop operational procedures to ensure the system is not deployed in or otherwise entered into an unexpected state as a result of operator actions. A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diﬃculty levels used in this document. Vulnerability Categories Category Description Access Controls Insuﬃcient authorization or assessment of rights Auditing and Logging Insuﬃcient auditing of actions or logging of problems Authentication Improper identiﬁcation of users Conﬁguration Misconﬁgured servers, devices, or software components Cryptography A breach of system conﬁdentiality or integrity Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service A system failure with an availability impact Error Reporting Insecure or insuﬃcient reporting of error conditions Patching Use of an outdated software package or library Session Management Improper identiﬁcation of authenticated users Testing Timing Insuﬃcient test methodology or test coverage Race conditions or other order-of-operations ﬂaws Undeﬁned Behavior Undeﬁned behavior triggered within the system Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices. Undetermined The extent of the risk was not determined during this engagement. Low The risk is small or is not one the client has indicated is important. Medium High User information is at risk; exploitation could pose reputational, legal, or moderate ﬁnancial risks. The ﬂaw could aﬀect numerous users and have serious reputational, legal, or ﬁnancial implications. Diﬃculty Levels Diﬃculty Description Undetermined The diﬃculty of exploitation was not determined during this engagement. Low Medium High The ﬂaw is well known; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of the system. An attacker must have privileged access to the system, may need to know complex technical details, or must discover other weaknesses to exploit this issue. B. Testing the Project Targets This section describes how to execute the tests that ran during the engagement. Echidna Fuzz Tests (Bedrock Contracts): Echidna is an Ethereum smart contract fuzzer that allows users to write on-chain property tests to verify the expected states of their applications. We provided Git patches for each project target alongside the report containing the tests generated during the course of the assessment. To prepare the environment for fuzz testing, we removed the optimism/packages/contracts-bedrock/contracts/test directory, as it contained unlinked libraries that are incompatible with Echidna in a default deployment scheme. Additionally, we updated the Hardhat and Foundry compilation conﬁgurations so that they did not strip bytecode hash metadata, which is required by Echidna to match deployed contracts. To run the Echidna fuzz tests, take the following steps: ● ● To compile the project, invoke Hardhat in the optimism/packages/contracts-bedrock directory by running the following commands: ○ npx hardhat clean ○ npx hardhat compile Invoke Echidna against a contract containing property tests by running the following command. This will tell Echidna to use the previously created compilation and to target the provided contract in a fuzzing campaign: echidna-test --contract <contract_name> --crytic-args --hardhat-ignore-compile . Go Test Tests (op-node, op-e2e, op-geth) The go test command invokes unit, integration, and fuzz tests written using Golang’s native testing package. We produced unit and fuzz tests for op-node and op-geth , as described in the Automated Testing table. ● To run the end-to-end tests within the optimism/op-e2e directory and the op-node unit tests within the optimism/op-node directory alongside any existing tests, run the following command from the respective directories: ○ go test -v ./… ● To run individual unit tests, use the following command instead: ○ go test -v -run <TestName> ● To run fuzz tests written for op-node and op-geth , run the following command from the directory containing the test ﬁle. The tests will run until the process is killed or interrupted: ○ go test -v -fuzz <TestName> C. Recommendations for Improving Testability This section includes recommendations for improving the testability of the codebase. Solidity Smart Contract Testing ● ● To use on-chain property fuzzers, such as Echidna, property tests are written in Solidity. However, on-chain property tests cannot access various aspects of the chain state or results. Therefore, we recommend designing functionality in a way that allows the results to be tested on-chain. To ensure that all of the routines in a given contract can be tested, verify that the relevant inputs, state changes, and outputs can be captured by a separate method in the contract. For instance, emitted events cannot be queried on-chain; they can be veriﬁed only oﬀ-chain. ○ If a test intends to verify values within an emitted event, consider splitting the relevant method into a helper function that returns the values rather than emitting them in an event. The original method could use this helper function to perform the underlying work and later emit the output data in an event itself, while test methods could target the helper directly to verify output methods. ■ For example, one could split the OptimismPortal.depositTransaction logic into a helper method that returns values rather than simply emitting a log, as these values can be validated by a test using the helper method. Alternatively, one could wrap the emitted event in a separate virtual function that can be overridden by a test contract derived from OptimismPortal so that it can capture these values. ● Ensure that the contracts can be easily deployed from a separate contract where possible. Echidna deploys compiled contracts with no constructor arguments and executes transactions against publicly accessible methods in an attempt to produce state changes. ○ For contracts that take constructor arguments, consider either creating a deriving contract that satisﬁes the constructor arguments with hard-coded values or creating a separate contract to deploy such contracts with the appropriate constructor arguments used for testing. ■ Carefully consider the tested contracts’ code composition when making such decisions. ○ For complex contract developments, consider using Etheno alongside Echidna. ● Consider integrating the project’s Echidna fuzz tests to the project’s CI/CD pipeline, possibly through the use of Echidna GitHub Actions . ○ ○ Leverage the test-limit conﬁguration variable to limit the duration of the fuzzing campaign in the CI process. Ensure that the fuzz tests are run at regular intervals. Tests that pass do not necessarily indicate a lack of vulnerabilities. The constraints required to violate a property test may not be found in one run, but the fuzzer may catch the latent issue in a later run. ● Consider adding rules to Slither’s existing set of static analysis rules by plugging detectors or other custom scripts into Slither’s detector API. To observe how the Slither API can be used to verify the integrity of a codebase, run the following command from the optimism/packages/contracts-bedrock directory: python3 ./slither_api_example.py As a proof of concept, this script discovers all Echidna property tests and the contracts they live within, speciﬁes the contracts that they immediately inherit from, and performs a check against OptimismPortal.depositTransaction to ensure that no high-level calls were added/removed and that an if statement exists for _isCreation that contains only a require statement comparing _to to address(0) . Note that the test against OptimismPortal was written to check every AST node and its underlying IR to show how Slither can be used to iterate over every statement or expression in a method and detect speciﬁc patterns or variables across multiple expressions. However, the test could be simpliﬁed to instead check the source text for speciﬁc segments. The use of the Slither API can enable the CI/CD pipeline to catch issues that arise from changes mistakenly introduced by developers, such as changes that violate some property of a given method. For instance, a Slither script could be written to diﬀerentiate between internal and external calls to ensure that no external calls are performed in a given method. L1/L2/op-node Testing ● We recommend creating an API that simpliﬁes the project’s end-to-end testing.: ○ ○ ○ The API should provide methods to initialize accounts with diﬀerent balances on L1 and L2 and provide a simpliﬁed test account structure with the key path, private key, and TransactOpts , alongside other account properties. The API should ensure that timeout-based tests do not fail simply because the timeouts are set too low. For example, throughout the op-e2e tests, various statements wait one second for a block to propagate, which may not be long enough. Increasing the timeout may reduce the likelihood of false-positive test failures for slower systems (such as the CI process). The API should include methods to execute actions such as sending deposit transactions, sending withdrawal requests, creating arbitrary transfer transactions on L1/L2, and causing fork conditions on L1/L2. The testing harness could automatically execute these actions and update expected values, such as expected balances/nonces on L1/L2, which are automatically asserted at the end of the test alongside any conditions that the tester asserts within the test immediately. ■ ■ ■ ■ Simulating fork conditions may require support for rolling back previous actions (and their changes to expected values). Ideally, the system should allow these actions to be invoked in parallel (from goroutines) to simulate typical network behavior (e.g., multiple L1 deposit transactions submitted at once). The system should ensure that blocks produced in tests simulate conditions for multiple Optimism system–related transactions included both simultaneously and individually in a single block. Consider writing all relevant end-to-end tests so that they can be run against various system conﬁgurations, such as diﬀering sequence windows and gas fees. ○ Finally, the API should ensure that the same test can be easily rerun with diﬀering system conﬁgurations; this will ensure that the system does not exhibit undeﬁned behavior as a result of edge cases arising from various conﬁgurations. ● For unit tests that depend on the result of processing certain data and making sure routines succeed or fail as expected, ensure that as many permutations of the input data as possible are tested. Review the existing unit tests to identify hard-coded values that would increase test coverage if they were randomized or fuzzed values instead. ○ For example, some unit tests within op-node depend on the MarshalDepositLogEvent method to produce a deposit event that is used as input to test deposit derivation functions. By reviewing this method, we can see that deposit versions are hard-coded to valid values. Modifying the unit tests’ helper methods to accept additional ﬁelds (such as the deposit version ﬁeld) will add the ﬂexibility necessary to test additional invariants (such as whether deposit logs with an invalid version produce derived deposits). 
