1. Project dependencies are not monitored for vulnerabilities Severity: High Type: Patching Diﬃculty: Medium Finding ID: TOB-ATL-1 Target: osquery table dependencies Description The osquery project depends on a large number of dependencies to realize the functionality of the existing tables. They are included as Git submodules in the project. The build mechanism of each dependency has been rewritten to suit the speciﬁc needs of osquery (e.g., so that it has as few dynamically loaded libraries as possible), but there is no process in place to detect published vulnerabilities in the dependencies. As a result, osquery could continue to use code with known vulnerabilities in the dependency projects. Exploit Scenario An attacker, who has gained a foothold on a machine running osquery, leverages an existing vulnerability in a dependency to exploit osquery. He escalates his privileges to those of the osquery agent or carries out a denial-of-service attack to block the osquery agent from sending data. Recommendations Short term, regularly update the dependencies to their latest versions. Long term, establish a process within the osquery project to detect published vulnerabilities in its dependencies. 15 Atlassian: osquery Security Assessment 
2. No separation of privileges when executing dependency code Severity: High Diﬃculty: Medium Type: Conﬁguration Finding ID: TOB-ATL-2 Target: osquery table dependencies Description In several places in the codebase, the osquery agent realizes the functionality of a table by invoking code in a dependency project. For example, the yara table is implemented by invoking code in libyara. However, there is no separation of privileges or sandboxing in place when the code in the dependency library is called, so the library code executes with the same privileges as the osquery agent. Considering the project’s numerous dependencies, this issue increases the osquery agent’s attack surface and would exacerbate the eﬀects of any vulnerabilities in the dependencies. Exploit Scenario An attacker ﬁnds a vulnerability in a dependency library that allows her to gain code execution, and she elevates her privileges to that of the osquery agent. Recommendations Short term, regularly update the dependencies to their latest versions. Long term, create a security barrier against the dependency library code to minimize the impact of vulnerabilities. 16 Atlassian: osquery Security Assessment 
3. No limit on the amount of information that can be read from the Firefox add-ons table Severity: Low Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-3 Target: osquery/tables/applications/browser_firefox.cpp Description The implementation of the Firefox add-ons table has no limit on the amount of information that it can read from JSON ﬁles while enumerating the add-ons installed on a user proﬁle. This is because to directly read and parse the Firefox proﬁle JSON ﬁle, the parseJSON implementation in the osquery agent uses boost::property_tree, which does not have this limit. pt::ptree tree; if (!osquery::parseJSON(path + kFirefoxExtensionsFile, tree).ok()) { TLOG << "Could not parse JSON from: " << path + kFirefoxExtensionsFile; return; } Figure 3.1: The osquery::parseJSON function has no limit on the amount of data it can read. Exploit Scenario An attacker crafts a large, valid JSON ﬁle and stores it on the Firefox proﬁle path as extensions.json (e.g., in ~/Library/Application Support/Firefox/Profiles/foo/extensions.json on a macOS system). When osquery executes a query using the firefox_addons table, the parseJSON function reads and parses the complete ﬁle, causing high resource consumption. Recommendations Short term, enforce a maximum ﬁle size within the Firefox table, similar to the limits on other tables in osquery. Long term, consider removing osquery::parseJSON and implementing a single, standard way to parse JSON ﬁles across osquery. The osquery project currently uses both boost::property_tree and RapidJSON libraries to parse JSON ﬁles, resulting in the use of diﬀerent code paths to handle untrusted content. 17 Atlassian: osquery Security Assessment 
4. The SIP status on macOS may be misreported Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-ATL-4 Target: osquery/tables/system/darwin/sip_config.cpp Description If System Integrity Protection (SIP) is disabled on a Mac running osquery, the SIP conﬁguration table might not report the correct value in the enabled column for the config_flag: sip row. For this misreporting to happen, extra ﬂags need to be present in the value returned by csr_get_active_config and absent in the osquery kRootlessConfigFlags list. This is the case for the ﬂags CSR_ALLOW_ANY_RECOVERY_OS, CSR_ALLOW_UNAPPROVED_KEXTS, CSR_ALLOW_EXECUTABLE_POLICY_OVERRIDE, and CSR_ALLOW_UNAUTHENTICATED_ROOT in xnu-7195.141.2/bsd/sys/csr.h (compare ﬁgure 4.1 and ﬁgure 4.3). /* CSR configuration flags */ #define CSR_ALLOW_UNTRUSTED_KEXTS (1 << 0) #define CSR_ALLOW_UNRESTRICTED_FS (1 << 1) #define CSR_ALLOW_TASK_FOR_PID (1 << 2) #define CSR_ALLOW_KERNEL_DEBUGGER (1 << 3) #define CSR_ALLOW_APPLE_INTERNAL (1 << 4) #define CSR_ALLOW_DESTRUCTIVE_DTRACE (1 << 5) /* name deprecated */ #define CSR_ALLOW_UNRESTRICTED_DTRACE (1 << 5) #define CSR_ALLOW_UNRESTRICTED_NVRAM (1 << 6) #define CSR_ALLOW_DEVICE_CONFIGURATION (1 << 7) #define CSR_ALLOW_ANY_RECOVERY_OS (1 << 8) #define CSR_ALLOW_UNAPPROVED_KEXTS (1 << 9) #define CSR_ALLOW_EXECUTABLE_POLICY_OVERRIDE (1 << 10) #define CSR_ALLOW_UNAUTHENTICATED_ROOT (1 << 11) Figure 4.1: The CSR ﬂags in xnu-7159.141.2 18 Atlassian: osquery Security Assessment QueryData results; csr_config_t config = 0; csr_get_active_config(&config); csr_config_t valid_allowed_flags = 0; for (const auto& kv : kRootlessConfigFlags) { valid_allowed_flags |= kv.second; } Row r; r["config_flag"] = "sip"; if (config == 0) { // SIP is enabled (default) r["enabled"] = INTEGER(1); r["enabled_nvram"] = INTEGER(1); } else if ((config | valid_allowed_flags) == valid_allowed_flags) { // mark SIP as NOT enabled (i.e. disabled) if // any of the valid_allowed_flags is set r["enabled"] = INTEGER(0); r["enabled_nvram"] = INTEGER(0); } results.push_back(r); Figure 4.2: How the SIP state is computed in genSIPConfig // rootless configuration flags // https://opensource.apple.com/source/xnu/xnu-3248.20.55/bsd/sys/csr.h const std::map<std::string, uint32_t> kRootlessConfigFlags = { // CSR_ALLOW_UNTRUSTED_KEXTS {"allow_untrusted_kexts", (1 << 0)}, // CSR_ALLOW_UNRESTRICTED_FS {"allow_unrestricted_fs", (1 << 1)}, // CSR_ALLOW_TASK_FOR_PID {"allow_task_for_pid", (1 << 2)}, // CSR_ALLOW_KERNEL_DEBUGGER {"allow_kernel_debugger", (1 << 3)}, // CSR_ALLOW_APPLE_INTERNAL {"allow_apple_internal", (1 << 4)}, // CSR_ALLOW_UNRESTRICTED_DTRACE {"allow_unrestricted_dtrace", (1 << 5)}, // CSR_ALLOW_UNRESTRICTED_NVRAM {"allow_unrestricted_nvram", (1 << 6)}, // CSR_ALLOW_DEVICE_CONFIGURATION {"allow_device_configuration", (1 << 7)}, }; Figure 4.3: The ﬂags currently supported by osquery 19 Atlassian: osquery Security Assessment Exploit Scenario An attacker, who has gained a foothold with root privileges, disables SIP on a device running macOS and sets the csr_config ﬂags to 0x3e7. When building the response for the sip_config table, osquery misreports the state of SIP. Recommendations Short term, consider reporting SIP as disabled if any ﬂag is present or if any of the known ﬂags are present (e.g., if (config & valid_allowed_flags) != 0). Long term, add support for reporting the raw ﬂag values to the table speciﬁcation and code so that the upstream server can make the ﬁnal determination on the state of SIP, irrespective of the ﬂags supported by the osquery daemon. Additionally, monitor for changes and add support for new ﬂags as they are added on the macOS kernel. 20 Atlassian: osquery Security Assessment 
5. The OpenReadableFile function can hang on reading a ﬁle Severity: Medium Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-5 Target: osquery/filesystem/filesystem.cpp Description The OpenReadableFile function creates an instance of the PlatformFile class, which is used for reading and writing ﬁles. The constructor of PlatformFile uses the open syscall to obtain a handle to the ﬁle. The OpenReadableFile function by default opens the ﬁle using the O_NONBLOCK ﬂag, but if PlatformFile’s isSpecialFile method returns true, it opens the ﬁle without using O_NONBLOCK. On the POSIX platform, the isSpecialFile method returns true for ﬁles in which fstat returns a size of zero. If the ﬁle to be read is a FIFO, the open syscall in the second invocation of PlatformFile’s constructor blocks the osquery thread until another thread opens the FIFO ﬁle to write to it. struct OpenReadableFile : private boost::noncopyable { public: explicit OpenReadableFile(const fs::path& path, bool blocking = false) : blocking_io(blocking) { int mode = PF_OPEN_EXISTING | PF_READ; if (!blocking) { mode |= PF_NONBLOCK; } // Open the file descriptor and allow caller to perform error checking. fd = std::make_unique<PlatformFile>(path, mode); if (!blocking && fd->isSpecialFile()) { // A special file cannot be read in non-blocking mode, reopen in blocking // mode mode &= ~PF_NONBLOCK; blocking_io = true; fd = std::make_unique<PlatformFile>(path, mode); } } public: std::unique_ptr<PlatformFile> fd{nullptr}; 21 Atlassian: osquery Security Assessment bool blocking_io; }; Figure 5.1: The OpenReadableFile function can block the osquery thread. Exploit Scenario An attacker creates a special ﬁle, such as a FIFO, in a path known to be read by the osquery agent. When the osquery agent attempts to open and read the ﬁle, it blocks the osquery thread indeﬁnitely, in eﬀect making osquery unable to report the status to the server. Recommendations Short term, ensure that the ﬁle operations in filesystem.cpp do not block the osquery thread. Long term, introduce a timeout on ﬁle operations so that a block does not stall the osquery thread. References ● The Single Unix Speciﬁcation, Version 2 22 Atlassian: osquery Security Assessment 
6. Methods in POSIX PlatformFile class are susceptible to race conditions Severity: Low Type: Timing Diﬃculty: Medium Finding ID: TOB-ATL-6 Target: osquery/filesystem/posix/fileops.cpp Description The POSIX implementation of the methods in the PlatformFile class includes several methods that return the current properties of a ﬁle. However, the properties can change during the lifetime of the ﬁle descriptor, so the return values of these methods may not reﬂect the actual properties. For example, the isSpecialFile method, which is used to determine the strategy for reading the ﬁle, calls the size method. However, the ﬁle size can change between the time of the call and the reading operation, in which case the wrong strategy for reading the ﬁle could be used. bool PlatformFile::isSpecialFile() const { return (size() == 0); } static uid_t getFileOwner(PlatformHandle handle) { struct stat file; if (::fstat(handle, &file) < 0) { return -1; } return file.st_uid; } Status PlatformFile::isOwnerRoot() const { if (!isValid()) { return Status(-1, "Invalid handle_"); } uid_t owner_id = getFileOwner(handle_); if (owner_id == (uid_t)-1) { return Status(-1, "fstat error"); } if (owner_id == 0) { return Status::success(); } return Status(1, "Owner is not root"); } Status PlatformFile::isOwnerCurrentUser() const { 23 Atlassian: osquery Security Assessment if (!isValid()) { return Status(-1, "Invalid handle_"); } uid_t owner_id = getFileOwner(handle_); if (owner_id == (uid_t)-1) { return Status(-1, "fstat error"); } if (owner_id == ::getuid()) { return Status::success(); } return Status(1, "Owner is not current user"); } Status PlatformFile::isExecutable() const { struct stat file_stat; if (::fstat(handle_, &file_stat) < 0) { return Status(-1, "fstat error"); } if ((file_stat.st_mode & S_IXUSR) == S_IXUSR) { return Status::success(); } return Status(1, "Not executable"); } Status PlatformFile::hasSafePermissions() const { struct stat file; if (::fstat(handle_, &file) < 0) { return Status(-1, "fstat error"); } // We allow user write for now, since our main threat is external // modification by other users if ((file.st_mode & S_IWOTH) == 0) { return Status::success(); } return Status(1, "Writable"); } Figure 6.1: The methods in PlatformFile could cause race issues. Exploit Scenario A new function is added to osquery that uses hasSafePermissions to determine whether to allow a potentially unsafe operation. An attacker creates a ﬁle that passes the hasSafePermissions check, then changes the permissions and alters the ﬁle contents before the ﬁle is further processed by the osquery agent. 24 Atlassian: osquery Security Assessment Recommendations Short term, refactor the operations of the relevant PlatformFile class methods to minimize the race window. For example, the only place hasSafePermissions is currently used is in the safePermissions function, in which it is preceded by a check that the ﬁle is owned by root or the current user, which eliminates the possibility of an adversary using the race condition; therefore, refactoring may not be necessary in this method. Add comments to these methods describing possible adverse eﬀects. Long term, refactor the interface of PlatformFile to contain the potential race issues within the class. For example, move the safePermissions function into the PlatformFile class so that hasSafePermissions is not exposed outside of the class. 25 Atlassian: osquery Security Assessment 
7. No limit on the amount of data that parsePlist can parse Severity: Low Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-7 Target: osquery/utils/darwin/plist.mm Description To support several macOS-speciﬁc tables, osquery contains a function called osquery::parsePlist, which reads and parses property list (.plist) ﬁles by using the Apple Foundation framework class NSPropertyListSerialization. The parsePlist function is used by tables such as browser_plugins and xprotect_reports to read user-accessible ﬁles. The function does not have any limit on the amount of data that it will parse. id ns_path = [NSString stringWithUTF8String:path.string().c_str()]; id stream = [NSInputStream inputStreamWithFileAtPath:ns_path]; if (stream == nil) { return Status(1, "Unable to read plist: " + path.string()); } // Read file content into a data object, containing potential plist data. NSError* error = nil; [stream open]; id plist_data = [NSPropertyListSerialization propertyListWithStream:stream options:0 format:NULL error:&error]; Figure 7.1: The parsePlist implementation does not have a limit on the amount of data that it can deserialize. 26 Atlassian: osquery Security Assessment auto info_path = path + "/Contents/Info.plist"; // Ensure that what we're processing is actually a plug-in. if (!pathExists(info_path)) { return; } if (osquery::parsePlist(info_path, tree).ok()) { // Plugin did not include an Info.plist, or it was invalid for (const auto& it : kBrowserPluginKeys) { r[it.second] = tree.get(it.first, ""); // Convert bool-types to an integer. jsonBoolAsInt(r[it.second]); } } Figure 7.2: browser_plugins uses parsePlist on user-controlled ﬁles. Exploit Scenario An attacker crafts a large, valid .plist ﬁle and stores it in ~/Library/Internet Plug-Ins/foo/Contents/Info.plist on a macOS system running the osquery daemon. When osquery executes a query using the browser_plugins table, it reads and parses the complete ﬁle, causing high resource consumption. Recommendations Short term, modify the browser_plugins and xprotect_reports tables to enforce a maximum ﬁle size (e.g., by combining readFile and parsePlistContent). Long term, to prevent this issue in future tables, consider removing the parsePlist function or rewriting it as a helper function around a safer implementation. 27 Atlassian: osquery Security Assessment 
8. The parsePlist function can hang on reading certain ﬁles Severity: Medium Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-8 Target: osquery/utils/darwin/plist.mm Description The osquery codebase contains a function called osquery::parsePlist, which reads and parses .plist ﬁles. This function opens the target ﬁle directly by using the inputStreamWithFileAtPath method from NSInputStream, as shown in ﬁgure 7.1 in the previous ﬁnding, and passes the resulting input stream to NSPropertyListSerialization for direct consumption. However, parsePlist can hang on reading certain ﬁles. For example, if the ﬁle to be read is a FIFO, the function blocks the osquery thread until another program or thread opens the FIFO to write to it. Exploit Scenario An attacker creates a FIFO ﬁle on a macOS device in ~/Library/Internet Plug-Ins/foo/Contents/Info.plist or ~/Library/Logs/DiagnosticReports/XProtect-foo using the mkfifo command. The osquery agent attempts to open and read the ﬁle when building a response for queries on the browser_plugins and xprotect_reports tables, but parsePlist blocks the osquery thread indeﬁnitely, leaving osquery unable to respond to the query request. Recommendations Short term, implement a check in parsePlist to verify that the .plist ﬁle to be read is not a special ﬁle. Long term, introduce a timeout on ﬁle operations so that a block does not stall the osquery thread. Also consider replacing parsePlist in favor of the parsePlistContent function and standardizing all ﬁle reads on a single code path to prevent similar issues going forward. 28 Atlassian: osquery Security Assessment 9. The parseJSON function can hang on reading certain ﬁles on Linux and macOS Severity: Medium Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-9 Target: osquery/filesystem/filesystem.cpp Description The osquery codebase contains a function called osquery::parseJSON, which reads and parses JSON ﬁles. This function opens the target ﬁle by passing a ﬁlename directly to boost::property_tree::read_json. On macOS and Linux, parseJSON can hang on reading certain ﬁles. For example, if the ﬁle to be read is a FIFO, the function blocks the osquery thread until another program or thread opens the FIFO to write to it. This function is currently used by the firefox_addons table. Status parseJSON(const fs::path& path, pt::ptree& tree) { try { pt::read_json(path.string(), tree); } catch (const pt::json_parser::json_parser_error& /* e */) { return Status(1, "Could not parse JSON from file"); } return Status::success(); } Figure 9.1: osquery uses boost::property_tree to read and parse the ﬁle in the path. void genFirefoxAddonsFromExtensions(const std::string& uid, const std::string& path, QueryData& results) { pt::ptree tree; if (!osquery::parseJSON(path + kFirefoxExtensionsFile, tree).ok()) { TLOG << "Could not parse JSON from: " << path + kFirefoxExtensionsFile; return; } Figure 9.2: parseJSON reads the extensions.json ﬁle from the Firefox proﬁle. 29 Atlassian: osquery Security Assessment Exploit Scenario An attacker creates a FIFO ﬁle named extensions.json using mkfifo and stores it on the Firefox proﬁle path (e.g., in ~/.mozilla/firefox/bar/extensions.json on a Linux system). The osquery agent attempts to respond to a query on the firefox_addons table and opens the ﬁle. parseJSON blocks the osquery thread indeﬁnitely, leaving osquery unable to respond to further requests. Recommendations Short term, implement a check in parseJSON to verify that the JSON ﬁle to be read is not a special ﬁle. Long term, introduce a timeout on ﬁle operations so that a block does not stall the osquery thread. Also consider replacing osquery::parseJSON in favor of the parseJSONContent function or the osquery::JSON helpers and standardizing all ﬁle reads on a single code path to prevent similar issues going forward. 30 Atlassian: osquery Security Assessment 10. No limit on the amount of data read or expanded from the Safari extensions table Severity: Low Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-10 Target: osquery/tables/applications/darwin/browser_plugins.cpp Description The safari_extensions table allows the agent to query installed Safari extensions on a certain user proﬁle. Said extensions consist of extensible archive format (XAR) compressed archives with the .safariextz ﬁle extension, which are stored in the ~/Library/Safari/Extensions folder. The osquery program does not have a limit on the amount of data that can be processed when reading and inﬂating the Safari extension contents; a large amount of data may cause a denial of service. 31 Atlassian: osquery Security Assessment xar_t xar = xar_open(path.c_str(), READ); if (xar == nullptr) { TLOG << "Cannot open extension archive: " << path; return; } xar_iter_t iter = xar_iter_new(); xar_file_t xfile = xar_file_first(xar, iter); size_t max_files = 500; for (size_t index = 0; index < max_files; ++index) { if (xfile == nullptr) { break; } char* xfile_path = xar_get_path(xfile); if (xfile_path == nullptr) { break; } // Clean up the allocated content ASAP. std::string entry_path(xfile_path); free(xfile_path); if (entry_path.find("Info.plist") != std::string::npos) { if (xar_verify(xar, xfile) != XAR_STREAM_OK) { TLOG << "Extension info extraction failed verification: " << path; } size_t size = 0; char* buffer = nullptr; if (xar_extract_tobuffersz(xar, xfile, &buffer, &size) != 0 || size == 0) { break; } std::string content(buffer, size); free(buffer); pt::ptree tree; if (parsePlistContent(content, tree).ok()) { for (const auto& it : kSafariExtensionKeys) { r[it.second] = tree.get(it.first, ""); } } break; } 32 Atlassian: osquery Security Assessment xfile = xar_file_next(iter); } Figure 10.1: genSafariExtension extracts the full Info.plist to memory. Exploit Scenario An attacker crafts a valid extension containing a large Info.plist ﬁle and stores it in ~/Library/Safari/Extensions/foo.safariextz. When the osquery agent attempts to respond to a query on the safari_extensions table, it opens the archive and expands the full Info.plist ﬁle in memory, causing high resource consumption. Recommendations Short term, enforce a limit on the amount of information that can be extracted from an XAR archive. Long term, add guidelines to the development documentation on handling untrusted input data. For instance, advise developers to limit the amount of data that may be ingested, processed, or read from untrusted sources such as user-writable ﬁles. Enforce said guidelines by performing code reviews on new contributions. 33 Atlassian: osquery Security Assessment 11. Extended attributes table may read uninitialized or out-of-bounds memory Severity: Medium Diﬃculty: Medium Type: Timing Finding ID: TOB-ATL-11 Target: osquery/tables/system/darwin/extended_attributes.cpp Description The extended_attributes table calls the listxattr function twice: ﬁrst to query the extended attribute list size and then to actually retrieve the list of attribute names. Additionally, the return values from the function calls are not checked for errors. This leads to a race condition in the parseExtendedAttributeList osquery function, in which the content buﬀer is left uninitialized if the target ﬁle is deleted in the time between the two listxattr calls. As a result, std::string will consume uninitialized and unbounded memory, potentially leading to out-of-bounds memory reads. std::vector<std::string> attributes; ssize_t value = listxattr(path.c_str(), nullptr, (size_t)0, 0); char* content = (char*)malloc(value); if (content == nullptr) { return attributes; } ssize_t ret = listxattr(path.c_str(), content, value, 0); if (ret == 0) { free(content); return attributes; } char* stable = content; do { attributes.push_back(std::string(content)); content += attributes.back().size() + 1; } while (content - stable < value); free(stable); return attributes; Figure 11.1: parseExtendedAttributeList calls listxattr twice. 34 Atlassian: osquery Security Assessment Exploit Scenario An attacker creates and runs a program to race osquery while it is fetching extended attributes from the ﬁle system. The attacker is successful and causes the osquery agent to crash with a segmentation fault. Recommendations Short term, rewrite the aﬀected code to check the return values for errors. Replace listxattr with flistxattr, which operates on opened ﬁle descriptors, allowing it to continue to query extended attributes even if the ﬁle is removed (unlink-ed) from the ﬁle system. Long term, establish and enforce best practices for osquery contributions by leveraging automated tooling and code reviews to prevent similar issues from reoccurring. For example, use ﬁle descriptors instead of ﬁle paths when you need to perform more than one operation on a ﬁle to ensure that the ﬁle is not deleted or replaced mid-operation. Consider using static analysis tools such as CodeQL to look for other instances of similar issues in the code and to detect new instances of the problem on new contributions. 35 Atlassian: osquery Security Assessment 12. The readFile function can hang on reading a ﬁle Severity: Medium Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-12 Target: osquery/filesystem/filesystem.cpp Description The readFile function is used to provide a standardized way to read ﬁles. It uses the read_max variable to prevent the functions from reading excessive amounts of data. It also selects one of two modes, blocking or non-blocking, depending on the ﬁle properties. When using the blocking approach, it reads block_size-sized chunks of the ﬁle, with a minimum of 4,096 bytes, and returns the chunks to the caller. However, the call to read can block the osquery thread when reading certain ﬁles. if (handle.blocking_io) { // Reset block size to a sane minimum. block_size = (block_size < 4096) ? 4096 : block_size; ssize_t part_bytes = 0; bool overflow = false; do { std::string part(block_size, '\0'); part_bytes = handle.fd->read(&part[0], block_size); if (part_bytes > 0) { total_bytes += static_cast<off_t>(part_bytes); if (total_bytes >= read_max) { return Status::failure("File exceeds read limits"); } if (file_size > 0 && total_bytes > file_size) { overflow = true; part_bytes -= (total_bytes - file_size); } predicate(part, part_bytes); } } while (part_bytes > 0 && !overflow); } else { Figure 12.1: The blocking_io ﬂow can stall. 36 Atlassian: osquery Security Assessment Exploit Scenario An attacker creates a symlink to /dev/tty in a path known to be read by the osquery agent. When the osquery agent attempts to read the ﬁle, it stalls. Recommendations Short term, ensure that the ﬁle operations in filesystem.cpp do not block the osquery thread. Long term, introduce a timeout on ﬁle operations so that a block does not stall the osquery thread. 37 Atlassian: osquery Security Assessment 13. The POSIX PlatformFile constructor may block the osquery thread Severity: Medium Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-13 Target: osquery/filesystem/posix/fileops.cpp Description The POSIX implementation of PlatformFile’s constructor uses the open syscall to obtain a handle to the ﬁle. If the ﬁle to be opened is a FIFO, the call to open blocks the osquery thread unless the O_NONBLOCK ﬂag is used. There are several places in the codebase in which the constructor is called without the PF_NONBLOCK ﬂag set; all of these calls may stall on opening a FIFO. PlatformFile::PlatformFile(const fs::path& path, int mode, int perms) : fname_(path) { ... if ((mode & PF_NONBLOCK) == PF_NONBLOCK) { oflag |= O_NONBLOCK; is_nonblock_ = true; } if ((mode & PF_APPEND) == PF_APPEND) { oflag |= O_APPEND; } if (perms == -1 && may_create) { perms = 0666; } boost::system::error_code ec; if (check_existence && (!fs::exists(fname_, ec) || ec.value() != errc::success)) { handle_ = kInvalidHandle; } else { handle_ = ::open(fname_.c_str(), oflag, perms); } } Figure 13.1: The POSIX PlatformFile constructor 38 Atlassian: osquery Security Assessment ./filesystem/file_compression.cpp:26: PlatformFile inFile(in, PF_OPEN_EXISTING | PF_READ); ./filesystem/file_compression.cpp:32: PlatformFile outFile(out, PF_CREATE_ALWAYS | PF_WRITE); ./filesystem/file_compression.cpp:102: PlatformFile inFile(in, PF_OPEN_EXISTING | PF_READ); ./filesystem/file_compression.cpp:108: PlatformFile outFile(out, PF_CREATE_ALWAYS | PF_WRITE); ./filesystem/file_compression.cpp:177: PlatformFile pFile(f, PF_OPEN_EXISTING | PF_READ); ./filesystem/filesystem.cpp:242: PlatformFile fd(path, PF_OPEN_EXISTING | PF_WRITE); ./filesystem/filesystem.cpp:258: PlatformFile fd(path, PF_OPEN_EXISTING | PF_READ); ./filesystem/filesystem.cpp:531: PlatformFile fd(path, PF_OPEN_EXISTING | PF_READ); ./carver/carver.cpp:230: PlatformFile src(srcPath, PF_OPEN_EXISTING | PF_READ); Figure 13.2: Uses of PlatformFile without PF_NONBLOCK Exploit Scenario An attacker creates a FIFO ﬁle that is opened by one of the functions above, stalling the osquery agent. Recommendations Short term, investigate the uses of PlatformFile to identify possible blocks. Long term, use a static analysis tool such as CodeQL to scan the code for instances in which uses of the open syscall block the osquery thread. 39 Atlassian: osquery Security Assessment 14. No limit on the amount of data the Carver::blockwiseCopy method can write Severity: Medium Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-14 Target: osquery/carver/carver.cpp Description The Carver::blockwiseCopy method copies ﬁles matching a requested carving operation. It does so by reading a block of carver_block_size bytes from the source ﬁle and then writing the data to the destination ﬁle. However, the copy loop does not check read_max, so there is no limit on how much data can be written. Furthermore, the source ﬁle is not opened using the PF_NONBLOCK ﬂag, so the reading operation can block the osquery thread. Refer to TOB-ATL-12 for more detail. Status Carver::blockwiseCopy(PlatformFile& src, PlatformFile& dst) { auto blkCount = ceil(static_cast<double>(src.size()) / static_cast<double>(FLAGS_carver_block_size)); std::vector<char> inBuff(FLAGS_carver_block_size, 0); for (size_t i = 0; i < blkCount; i++) { auto bytesRead = src.read(inBuff.data(), FLAGS_carver_block_size); if (bytesRead > 0) { auto bytesWritten = dst.write(inBuff.data(), bytesRead); if (bytesWritten < 0) { return Status(1, "Error writing bytes to tmp fs"); } } } return Status::success(); }; Figure 14.1: The Carver::blockwiseCopy method has no limit on the amount of data it can write. Exploit Scenario An attacker creates a large sparse ﬁle on disk in a location in which a carving operation is performed. When the carving operation is performed, the large ﬁle consumes the available space on the destination ﬁle system. 40 Atlassian: osquery Security Assessment Recommendations Short term, implement read_max in blockwiseCopy to limit the size of the data that it can copy. Long term, refactor the code to eliminate the need to copy ﬁles. For example, refactor the code to read the ﬁles in place when adding them to the archive or create symlinks in the target directory. 41 Atlassian: osquery Security Assessment 15. The carves table truncates large ﬁle sizes to 32 bits Severity: Informational Diﬃculty: Low Type: Data Validation Finding ID: TOB-ATL-15 Target: osquery/tables/forensic/carves.cpp Description The enumerateCarves function uses rapidjson::Value::GetInt() to retrieve a size value from a JSON string. The GetInt return type is int, so it cannot represent sizes exceeding 32 bits; as a result, the size of larger ﬁles will be truncated. void enumerateCarves(QueryData& results, const std::string& new_guid) { std::vector<std::string> carves; scanDatabaseKeys(kCarves, carves, kCarverDBPrefix); for (const auto& carveGuid : carves) { std::string carve; auto s = getDatabaseValue(kCarves, carveGuid, carve); if (!s.ok()) { VLOG(1) << "Failed to retrieve carve GUID"; continue; } JSON tree; s = tree.fromString(carve); if (!s.ok() || !tree.doc().IsObject()) { VLOG(1) << "Failed to parse carve entries: " << s.getMessage(); return; } Row r; if (tree.doc().HasMember("time")) { r["time"] = INTEGER(tree.doc()["time"].GetUint64()); } if (tree.doc().HasMember("size")) { r["size"] = INTEGER(tree.doc()["size"].GetInt()); } stringToRow("sha256", r, tree); 42 Atlassian: osquery Security Assessment stringToRow("carve_guid", r, tree); stringToRow("request_id", r, tree); stringToRow("status", r, tree); stringToRow("path", r, tree); // This table can be used to request a new carve. // If this is the case then return this single result. auto new_request = (!new_guid.empty() && new_guid == r["carve_guid"]); r["carve"] = INTEGER((new_request) ? 1 : 0); results.push_back(r); } } } // namespace Figure 15.1: The enumerateCarves function truncates ﬁles of large sizes. Exploit Scenario An attacker creates a ﬁle on disk of a size that overﬂows 32 bits by only a small amount, such as 0x100001336. The carves tables reports the ﬁle size incorrectly as 0x1336 bytes. The attacker bypasses checks based on the reported ﬁle size. Recommendations Short term, use GetUint64 instead of GetInt to retrieve the ﬁle size. Long term, use static analysis tools such as CodeQL to look for other instances in which a type of size int is retrieved from JSON and stored in an INTEGER ﬁeld. 43 Atlassian: osquery Security Assessment 16. The time table may not null-terminate strings correctly Severity: Informational Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-ATL-16 Target: osquery/tables/utility/time.cpp Description The osquery time table uses strftime to format time information, such as the time zone name, into user-friendly strings. If the amount of information to be written does not ﬁt in the provided buﬀer, strftime returns zero and leaves the buﬀer contents in an undeﬁned state. QueryData genTime(QueryContext& context) { Row r; time_t osquery_time = getUnixTime(); struct tm gmt; gmtime_r(&osquery_time, &gmt); struct tm now = gmt; auto osquery_timestamp = toAsciiTime(&now); char local_timezone[5] = {0}; { } struct tm local; localtime_r(&osquery_time, &local); strftime(local_timezone, sizeof(local_timezone), "%Z", &local); char weekday[10] = {0}; strftime(weekday, sizeof(weekday), "%A", &now); char timezone[5] = {0}; strftime(timezone, sizeof(timezone), "%Z", &now); Figure 16.1: genTime uses strftime to get the time zone name and day of the week. The strings to be written vary depending on the locale conﬁguration, so some strings may not ﬁt in the provided buﬀer. The code does not check the return value of strftime and assumes that the string buﬀer is always null-terminated, which may not always be the case. 44 Atlassian: osquery Security Assessment Exploit Scenario An attacker ﬁnds a way to change the time zone on a system in which %Z shows the full time zone name. When the osquery agent attempts to respond to a query on the time table, it triggers undeﬁned behavior. Recommendations Short term, add a check to verify the return value of each strftime call made by the table implementation. If the function returns zero, ensure that the system writes a valid string in the buﬀer before it is used as part of the table response. Long term, perform code reviews on new contributions and consider using automated code analysis tools to prevent these kinds of issues from reoccurring. 45 Atlassian: osquery Security Assessment 17. The elf_info table can crash the osquery agent Severity: Medium Diﬃculty: Medium Type: Data Validation Finding ID: TOB-ATL-17 Target: osquery/tables/system/linux/elf_info.cpp Description The elf_info table uses the libelfin library to read properties of ELF ﬁles. The library maps the entire ELF binary into virtual memory and then uses memory accesses to read the data. Speciﬁcally, the load method of the mmap_loader class returns a pointer to the data for a given oﬀset and size. To ensure that the memory access stays within the bounds of the memory-mapped ﬁle, the library checks that the result of adding the oﬀset and the size is less than the size of the ﬁle. However, this check does not account for the possibility of overﬂows in the addition operation. For example, an oﬀset of 0xffffffffffffffff and a size of 1 would overﬂow to the value 0. This makes it possible to bypass the check and to create references to memory outside of the bounds. The elf_info table indirectly uses this function when loading section headers from an ELF binary. class mmap_loader : public loader { public: void *base; size_t lim; mmap_loader(int fd) { off_t end = lseek(fd, 0, SEEK_END); if (end == (off_t)-1) throw system_error(errno, system_category(), "finding file length"); lim = end; base = mmap(nullptr, lim, PROT_READ, MAP_SHARED, fd, 0); if (base == MAP_FAILED) throw system_error(errno, system_category(), "mmap'ing file"); close(fd); } ... 46 Atlassian: osquery Security Assessment const void *load(off_t offset, size_t size) { } }; if (offset + size > lim) throw range_error("offset exceeds file size"); return (const char*)base + offset; Figure 17.1: The libenfin library’s limit check does not account for overﬂows. Exploit Scenario An attacker knows of a writable path in which osquery scans ELF binaries. He creates a malformed ELF binary, causing the pointer returned by the vulnerable function to point to an arbitrary location. He uses this to make the osquery agent crash, leak information from the process memory, or circumvent address space layout randomization (ASLR). Recommendations Short term, work with the developers of the libelfbin project to account for overﬂows in the check. Long term, implement the recommendations in TOB-ATL-2 to minimize the impact of similar issues. 47 Atlassian: osquery Security Assessment
10. No limit on the amount of data read or expanded from the Safari extensions table Severity: Low Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-10 Target: osquery/tables/applications/darwin/browser_plugins.cpp Description The safari_extensions table allows the agent to query installed Safari extensions on a certain user proﬁle. Said extensions consist of extensible archive format (XAR) compressed archives with the .safariextz ﬁle extension, which are stored in the ~/Library/Safari/Extensions folder. The osquery program does not have a limit on the amount of data that can be processed when reading and inﬂating the Safari extension contents; a large amount of data may cause a denial of service. 31 Atlassian: osquery Security Assessment xar_t xar = xar_open(path.c_str(), READ); if (xar == nullptr) { TLOG << "Cannot open extension archive: " << path; return; } xar_iter_t iter = xar_iter_new(); xar_file_t xfile = xar_file_first(xar, iter); size_t max_files = 500; for (size_t index = 0; index < max_files; ++index) { if (xfile == nullptr) { break; } char* xfile_path = xar_get_path(xfile); if (xfile_path == nullptr) { break; } // Clean up the allocated content ASAP. std::string entry_path(xfile_path); free(xfile_path); if (entry_path.find("Info.plist") != std::string::npos) { if (xar_verify(xar, xfile) != XAR_STREAM_OK) { TLOG << "Extension info extraction failed verification: " << path; } size_t size = 0; char* buffer = nullptr; if (xar_extract_tobuffersz(xar, xfile, &buffer, &size) != 0 || size == 0) { break; } std::string content(buffer, size); free(buffer); pt::ptree tree; if (parsePlistContent(content, tree).ok()) { for (const auto& it : kSafariExtensionKeys) { r[it.second] = tree.get(it.first, ""); } } break; } 32 Atlassian: osquery Security Assessment xfile = xar_file_next(iter); } Figure 10.1: genSafariExtension extracts the full Info.plist to memory. Exploit Scenario An attacker crafts a valid extension containing a large Info.plist ﬁle and stores it in ~/Library/Safari/Extensions/foo.safariextz. When the osquery agent attempts to respond to a query on the safari_extensions table, it opens the archive and expands the full Info.plist ﬁle in memory, causing high resource consumption. Recommendations Short term, enforce a limit on the amount of information that can be extracted from an XAR archive. Long term, add guidelines to the development documentation on handling untrusted input data. For instance, advise developers to limit the amount of data that may be ingested, processed, or read from untrusted sources such as user-writable ﬁles. Enforce said guidelines by performing code reviews on new contributions. 33 Atlassian: osquery Security Assessment 
11. Extended attributes table may read uninitialized or out-of-bounds memory Severity: Medium Diﬃculty: Medium Type: Timing Finding ID: TOB-ATL-11 Target: osquery/tables/system/darwin/extended_attributes.cpp Description The extended_attributes table calls the listxattr function twice: ﬁrst to query the extended attribute list size and then to actually retrieve the list of attribute names. Additionally, the return values from the function calls are not checked for errors. This leads to a race condition in the parseExtendedAttributeList osquery function, in which the content buﬀer is left uninitialized if the target ﬁle is deleted in the time between the two listxattr calls. As a result, std::string will consume uninitialized and unbounded memory, potentially leading to out-of-bounds memory reads. std::vector<std::string> attributes; ssize_t value = listxattr(path.c_str(), nullptr, (size_t)0, 0); char* content = (char*)malloc(value); if (content == nullptr) { return attributes; } ssize_t ret = listxattr(path.c_str(), content, value, 0); if (ret == 0) { free(content); return attributes; } char* stable = content; do { attributes.push_back(std::string(content)); content += attributes.back().size() + 1; } while (content - stable < value); free(stable); return attributes; Figure 11.1: parseExtendedAttributeList calls listxattr twice. 34 Atlassian: osquery Security Assessment Exploit Scenario An attacker creates and runs a program to race osquery while it is fetching extended attributes from the ﬁle system. The attacker is successful and causes the osquery agent to crash with a segmentation fault. Recommendations Short term, rewrite the aﬀected code to check the return values for errors. Replace listxattr with flistxattr, which operates on opened ﬁle descriptors, allowing it to continue to query extended attributes even if the ﬁle is removed (unlink-ed) from the ﬁle system. Long term, establish and enforce best practices for osquery contributions by leveraging automated tooling and code reviews to prevent similar issues from reoccurring. For example, use ﬁle descriptors instead of ﬁle paths when you need to perform more than one operation on a ﬁle to ensure that the ﬁle is not deleted or replaced mid-operation. Consider using static analysis tools such as CodeQL to look for other instances of similar issues in the code and to detect new instances of the problem on new contributions. 35 Atlassian: osquery Security Assessment 
12. The readFile function can hang on reading a ﬁle Severity: Medium Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-12 Target: osquery/filesystem/filesystem.cpp Description The readFile function is used to provide a standardized way to read ﬁles. It uses the read_max variable to prevent the functions from reading excessive amounts of data. It also selects one of two modes, blocking or non-blocking, depending on the ﬁle properties. When using the blocking approach, it reads block_size-sized chunks of the ﬁle, with a minimum of 4,096 bytes, and returns the chunks to the caller. However, the call to read can block the osquery thread when reading certain ﬁles. if (handle.blocking_io) { // Reset block size to a sane minimum. block_size = (block_size < 4096) ? 4096 : block_size; ssize_t part_bytes = 0; bool overflow = false; do { std::string part(block_size, '\0'); part_bytes = handle.fd->read(&part[0], block_size); if (part_bytes > 0) { total_bytes += static_cast<off_t>(part_bytes); if (total_bytes >= read_max) { return Status::failure("File exceeds read limits"); } if (file_size > 0 && total_bytes > file_size) { overflow = true; part_bytes -= (total_bytes - file_size); } predicate(part, part_bytes); } } while (part_bytes > 0 && !overflow); } else { Figure 12.1: The blocking_io ﬂow can stall. 36 Atlassian: osquery Security Assessment Exploit Scenario An attacker creates a symlink to /dev/tty in a path known to be read by the osquery agent. When the osquery agent attempts to read the ﬁle, it stalls. Recommendations Short term, ensure that the ﬁle operations in filesystem.cpp do not block the osquery thread. Long term, introduce a timeout on ﬁle operations so that a block does not stall the osquery thread. 37 Atlassian: osquery Security Assessment 
13. The POSIX PlatformFile constructor may block the osquery thread Severity: Medium Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-13 Target: osquery/filesystem/posix/fileops.cpp Description The POSIX implementation of PlatformFile’s constructor uses the open syscall to obtain a handle to the ﬁle. If the ﬁle to be opened is a FIFO, the call to open blocks the osquery thread unless the O_NONBLOCK ﬂag is used. There are several places in the codebase in which the constructor is called without the PF_NONBLOCK ﬂag set; all of these calls may stall on opening a FIFO. PlatformFile::PlatformFile(const fs::path& path, int mode, int perms) : fname_(path) { ... if ((mode & PF_NONBLOCK) == PF_NONBLOCK) { oflag |= O_NONBLOCK; is_nonblock_ = true; } if ((mode & PF_APPEND) == PF_APPEND) { oflag |= O_APPEND; } if (perms == -1 && may_create) { perms = 0666; } boost::system::error_code ec; if (check_existence && (!fs::exists(fname_, ec) || ec.value() != errc::success)) { handle_ = kInvalidHandle; } else { handle_ = ::open(fname_.c_str(), oflag, perms); } } Figure 13.1: The POSIX PlatformFile constructor 38 Atlassian: osquery Security Assessment ./filesystem/file_compression.cpp:26: PlatformFile inFile(in, PF_OPEN_EXISTING | PF_READ); ./filesystem/file_compression.cpp:32: PlatformFile outFile(out, PF_CREATE_ALWAYS | PF_WRITE); ./filesystem/file_compression.cpp:102: PlatformFile inFile(in, PF_OPEN_EXISTING | PF_READ); ./filesystem/file_compression.cpp:108: PlatformFile outFile(out, PF_CREATE_ALWAYS | PF_WRITE); ./filesystem/file_compression.cpp:177: PlatformFile pFile(f, PF_OPEN_EXISTING | PF_READ); ./filesystem/filesystem.cpp:242: PlatformFile fd(path, PF_OPEN_EXISTING | PF_WRITE); ./filesystem/filesystem.cpp:258: PlatformFile fd(path, PF_OPEN_EXISTING | PF_READ); ./filesystem/filesystem.cpp:531: PlatformFile fd(path, PF_OPEN_EXISTING | PF_READ); ./carver/carver.cpp:230: PlatformFile src(srcPath, PF_OPEN_EXISTING | PF_READ); Figure 13.2: Uses of PlatformFile without PF_NONBLOCK Exploit Scenario An attacker creates a FIFO ﬁle that is opened by one of the functions above, stalling the osquery agent. Recommendations Short term, investigate the uses of PlatformFile to identify possible blocks. Long term, use a static analysis tool such as CodeQL to scan the code for instances in which uses of the open syscall block the osquery thread. 39 Atlassian: osquery Security Assessment 14. No limit on the amount of data the Carver::blockwiseCopy method can write Severity: Medium Diﬃculty: Low Type: Denial of Service Finding ID: TOB-ATL-14 Target: osquery/carver/carver.cpp Description The Carver::blockwiseCopy method copies ﬁles matching a requested carving operation. It does so by reading a block of carver_block_size bytes from the source ﬁle and then writing the data to the destination ﬁle. However, the copy loop does not check read_max, so there is no limit on how much data can be written. Furthermore, the source ﬁle is not opened using the PF_NONBLOCK ﬂag, so the reading operation can block the osquery thread. Refer to TOB-ATL-12 for more detail. Status Carver::blockwiseCopy(PlatformFile& src, PlatformFile& dst) { auto blkCount = ceil(static_cast<double>(src.size()) / static_cast<double>(FLAGS_carver_block_size)); std::vector<char> inBuff(FLAGS_carver_block_size, 0); for (size_t i = 0; i < blkCount; i++) { auto bytesRead = src.read(inBuff.data(), FLAGS_carver_block_size); if (bytesRead > 0) { auto bytesWritten = dst.write(inBuff.data(), bytesRead); if (bytesWritten < 0) { return Status(1, "Error writing bytes to tmp fs"); } } } return Status::success(); }; Figure 14.1: The Carver::blockwiseCopy method has no limit on the amount of data it can write. Exploit Scenario An attacker creates a large sparse ﬁle on disk in a location in which a carving operation is performed. When the carving operation is performed, the large ﬁle consumes the available space on the destination ﬁle system. 40 Atlassian: osquery Security Assessment Recommendations Short term, implement read_max in blockwiseCopy to limit the size of the data that it can copy. Long term, refactor the code to eliminate the need to copy ﬁles. For example, refactor the code to read the ﬁles in place when adding them to the archive or create symlinks in the target directory. 41 Atlassian: osquery Security Assessment 15. The carves table truncates large ﬁle sizes to 32 bits Severity: Informational Diﬃculty: Low Type: Data Validation Finding ID: TOB-ATL-15 Target: osquery/tables/forensic/carves.cpp Description The enumerateCarves function uses rapidjson::Value::GetInt() to retrieve a size value from a JSON string. The GetInt return type is int, so it cannot represent sizes exceeding 32 bits; as a result, the size of larger ﬁles will be truncated. void enumerateCarves(QueryData& results, const std::string& new_guid) { std::vector<std::string> carves; scanDatabaseKeys(kCarves, carves, kCarverDBPrefix); for (const auto& carveGuid : carves) { std::string carve; auto s = getDatabaseValue(kCarves, carveGuid, carve); if (!s.ok()) { VLOG(1) << "Failed to retrieve carve GUID"; continue; } JSON tree; s = tree.fromString(carve); if (!s.ok() || !tree.doc().IsObject()) { VLOG(1) << "Failed to parse carve entries: " << s.getMessage(); return; } Row r; if (tree.doc().HasMember("time")) { r["time"] = INTEGER(tree.doc()["time"].GetUint64()); } if (tree.doc().HasMember("size")) { r["size"] = INTEGER(tree.doc()["size"].GetInt()); } stringToRow("sha256", r, tree); 42 Atlassian: osquery Security Assessment stringToRow("carve_guid", r, tree); stringToRow("request_id", r, tree); stringToRow("status", r, tree); stringToRow("path", r, tree); // This table can be used to request a new carve. // If this is the case then return this single result. auto new_request = (!new_guid.empty() && new_guid == r["carve_guid"]); r["carve"] = INTEGER((new_request) ? 1 : 0); results.push_back(r); } } } // namespace Figure 15.1: The enumerateCarves function truncates ﬁles of large sizes. Exploit Scenario An attacker creates a ﬁle on disk of a size that overﬂows 32 bits by only a small amount, such as 0x100001336. The carves tables reports the ﬁle size incorrectly as 0x1336 bytes. The attacker bypasses checks based on the reported ﬁle size. Recommendations Short term, use GetUint64 instead of GetInt to retrieve the ﬁle size. Long term, use static analysis tools such as CodeQL to look for other instances in which a type of size int is retrieved from JSON and stored in an INTEGER ﬁeld. 43 Atlassian: osquery Security Assessment 16. The time table may not null-terminate strings correctly Severity: Informational Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-ATL-16 Target: osquery/tables/utility/time.cpp Description The osquery time table uses strftime to format time information, such as the time zone name, into user-friendly strings. If the amount of information to be written does not ﬁt in the provided buﬀer, strftime returns zero and leaves the buﬀer contents in an undeﬁned state. QueryData genTime(QueryContext& context) { Row r; time_t osquery_time = getUnixTime(); struct tm gmt; gmtime_r(&osquery_time, &gmt); struct tm now = gmt; auto osquery_timestamp = toAsciiTime(&now); char local_timezone[5] = {0}; { } struct tm local; localtime_r(&osquery_time, &local); strftime(local_timezone, sizeof(local_timezone), "%Z", &local); char weekday[10] = {0}; strftime(weekday, sizeof(weekday), "%A", &now); char timezone[5] = {0}; strftime(timezone, sizeof(timezone), "%Z", &now); Figure 16.1: genTime uses strftime to get the time zone name and day of the week. The strings to be written vary depending on the locale conﬁguration, so some strings may not ﬁt in the provided buﬀer. The code does not check the return value of strftime and assumes that the string buﬀer is always null-terminated, which may not always be the case. 44 Atlassian: osquery Security Assessment Exploit Scenario An attacker ﬁnds a way to change the time zone on a system in which %Z shows the full time zone name. When the osquery agent attempts to respond to a query on the time table, it triggers undeﬁned behavior. Recommendations Short term, add a check to verify the return value of each strftime call made by the table implementation. If the function returns zero, ensure that the system writes a valid string in the buﬀer before it is used as part of the table response. Long term, perform code reviews on new contributions and consider using automated code analysis tools to prevent these kinds of issues from reoccurring. 45 Atlassian: osquery Security Assessment 17. The elf_info table can crash the osquery agent Severity: Medium Diﬃculty: Medium Type: Data Validation Finding ID: TOB-ATL-17 Target: osquery/tables/system/linux/elf_info.cpp Description The elf_info table uses the libelfin library to read properties of ELF ﬁles. The library maps the entire ELF binary into virtual memory and then uses memory accesses to read the data. Speciﬁcally, the load method of the mmap_loader class returns a pointer to the data for a given oﬀset and size. To ensure that the memory access stays within the bounds of the memory-mapped ﬁle, the library checks that the result of adding the oﬀset and the size is less than the size of the ﬁle. However, this check does not account for the possibility of overﬂows in the addition operation. For example, an oﬀset of 0xffffffffffffffff and a size of 1 would overﬂow to the value 0. This makes it possible to bypass the check and to create references to memory outside of the bounds. The elf_info table indirectly uses this function when loading section headers from an ELF binary. class mmap_loader : public loader { public: void *base; size_t lim; mmap_loader(int fd) { off_t end = lseek(fd, 0, SEEK_END); if (end == (off_t)-1) throw system_error(errno, system_category(), "finding file length"); lim = end; base = mmap(nullptr, lim, PROT_READ, MAP_SHARED, fd, 0); if (base == MAP_FAILED) throw system_error(errno, system_category(), "mmap'ing file"); close(fd); } ... 46 Atlassian: osquery Security Assessment const void *load(off_t offset, size_t size) { } }; if (offset + size > lim) throw range_error("offset exceeds file size"); return (const char*)base + offset; Figure 17.1: The libenfin library’s limit check does not account for overﬂows. Exploit Scenario An attacker knows of a writable path in which osquery scans ELF binaries. He creates a malformed ELF binary, causing the pointer returned by the vulnerable function to point to an arbitrary location. He uses this to make the osquery agent crash, leak information from the process memory, or circumvent address space layout randomization (ASLR). Recommendations Short term, work with the developers of the libelfbin project to account for overﬂows in the check. Long term, implement the recommendations in TOB-ATL-2 to minimize the impact of similar issues. 47 Atlassian: osquery Security Assessment
15. The carves table truncates large ﬁle sizes to 32 bits Severity: Informational Diﬃculty: Low Type: Data Validation Finding ID: TOB-ATL-15 Target: osquery/tables/forensic/carves.cpp Description The enumerateCarves function uses rapidjson::Value::GetInt() to retrieve a size value from a JSON string. The GetInt return type is int, so it cannot represent sizes exceeding 32 bits; as a result, the size of larger ﬁles will be truncated. void enumerateCarves(QueryData& results, const std::string& new_guid) { std::vector<std::string> carves; scanDatabaseKeys(kCarves, carves, kCarverDBPrefix); for (const auto& carveGuid : carves) { std::string carve; auto s = getDatabaseValue(kCarves, carveGuid, carve); if (!s.ok()) { VLOG(1) << "Failed to retrieve carve GUID"; continue; } JSON tree; s = tree.fromString(carve); if (!s.ok() || !tree.doc().IsObject()) { VLOG(1) << "Failed to parse carve entries: " << s.getMessage(); return; } Row r; if (tree.doc().HasMember("time")) { r["time"] = INTEGER(tree.doc()["time"].GetUint64()); } if (tree.doc().HasMember("size")) { r["size"] = INTEGER(tree.doc()["size"].GetInt()); } stringToRow("sha256", r, tree); 42 Atlassian: osquery Security Assessment stringToRow("carve_guid", r, tree); stringToRow("request_id", r, tree); stringToRow("status", r, tree); stringToRow("path", r, tree); // This table can be used to request a new carve. // If this is the case then return this single result. auto new_request = (!new_guid.empty() && new_guid == r["carve_guid"]); r["carve"] = INTEGER((new_request) ? 1 : 0); results.push_back(r); } } } // namespace Figure 15.1: The enumerateCarves function truncates ﬁles of large sizes. Exploit Scenario An attacker creates a ﬁle on disk of a size that overﬂows 32 bits by only a small amount, such as 0x100001336. The carves tables reports the ﬁle size incorrectly as 0x1336 bytes. The attacker bypasses checks based on the reported ﬁle size. Recommendations Short term, use GetUint64 instead of GetInt to retrieve the ﬁle size. Long term, use static analysis tools such as CodeQL to look for other instances in which a type of size int is retrieved from JSON and stored in an INTEGER ﬁeld. 43 Atlassian: osquery Security Assessment 
16. The time table may not null-terminate strings correctly Severity: Informational Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-ATL-16 Target: osquery/tables/utility/time.cpp Description The osquery time table uses strftime to format time information, such as the time zone name, into user-friendly strings. If the amount of information to be written does not ﬁt in the provided buﬀer, strftime returns zero and leaves the buﬀer contents in an undeﬁned state. QueryData genTime(QueryContext& context) { Row r; time_t osquery_time = getUnixTime(); struct tm gmt; gmtime_r(&osquery_time, &gmt); struct tm now = gmt; auto osquery_timestamp = toAsciiTime(&now); char local_timezone[5] = {0}; { } struct tm local; localtime_r(&osquery_time, &local); strftime(local_timezone, sizeof(local_timezone), "%Z", &local); char weekday[10] = {0}; strftime(weekday, sizeof(weekday), "%A", &now); char timezone[5] = {0}; strftime(timezone, sizeof(timezone), "%Z", &now); Figure 16.1: genTime uses strftime to get the time zone name and day of the week. The strings to be written vary depending on the locale conﬁguration, so some strings may not ﬁt in the provided buﬀer. The code does not check the return value of strftime and assumes that the string buﬀer is always null-terminated, which may not always be the case. 44 Atlassian: osquery Security Assessment Exploit Scenario An attacker ﬁnds a way to change the time zone on a system in which %Z shows the full time zone name. When the osquery agent attempts to respond to a query on the time table, it triggers undeﬁned behavior. Recommendations Short term, add a check to verify the return value of each strftime call made by the table implementation. If the function returns zero, ensure that the system writes a valid string in the buﬀer before it is used as part of the table response. Long term, perform code reviews on new contributions and consider using automated code analysis tools to prevent these kinds of issues from reoccurring. 45 Atlassian: osquery Security Assessment 
17. The elf_info table can crash the osquery agent Severity: Medium Diﬃculty: Medium Type: Data Validation Finding ID: TOB-ATL-17 Target: osquery/tables/system/linux/elf_info.cpp Description The elf_info table uses the libelfin library to read properties of ELF ﬁles. The library maps the entire ELF binary into virtual memory and then uses memory accesses to read the data. Speciﬁcally, the load method of the mmap_loader class returns a pointer to the data for a given oﬀset and size. To ensure that the memory access stays within the bounds of the memory-mapped ﬁle, the library checks that the result of adding the oﬀset and the size is less than the size of the ﬁle. However, this check does not account for the possibility of overﬂows in the addition operation. For example, an oﬀset of 0xffffffffffffffff and a size of 1 would overﬂow to the value 0. This makes it possible to bypass the check and to create references to memory outside of the bounds. The elf_info table indirectly uses this function when loading section headers from an ELF binary. class mmap_loader : public loader { public: void *base; size_t lim; mmap_loader(int fd) { off_t end = lseek(fd, 0, SEEK_END); if (end == (off_t)-1) throw system_error(errno, system_category(), "finding file length"); lim = end; base = mmap(nullptr, lim, PROT_READ, MAP_SHARED, fd, 0); if (base == MAP_FAILED) throw system_error(errno, system_category(), "mmap'ing file"); close(fd); } ... 46 Atlassian: osquery Security Assessment const void *load(off_t offset, size_t size) { } }; if (offset + size > lim) throw range_error("offset exceeds file size"); return (const char*)base + offset; Figure 17.1: The libenfin library’s limit check does not account for overﬂows. Exploit Scenario An attacker knows of a writable path in which osquery scans ELF binaries. He creates a malformed ELF binary, causing the pointer returned by the vulnerable function to point to an arbitrary location. He uses this to make the osquery agent crash, leak information from the process memory, or circumvent address space layout randomization (ASLR). Recommendations Short term, work with the developers of the libelfbin project to account for overﬂows in the check. Long term, implement the recommendations in TOB-ATL-2 to minimize the impact of similar issues. 47 Atlassian: osquery Security Assessment 
