2. Solidity compiler optimizations can be problematic Severity: Undetermined Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-ARCADE-2 Target: hardhat.config.ts Description Arcade has enabled optional compiler optimizations in Solidity. According to a November 2018 audit of the Solidity compiler, the optional optimizations may not be safe. 147 148 149 150 optimizer: { enabled: optimizerEnabled, runs: 200, }, Figure 2.1: The solc optimizer settings in arcade-protocol/hardhat.config.ts High-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten-generated solc-js compiler used by Truﬄe and Remix persisted until late 2018; the ﬁx for this bug was not reported in the Solidity changelog. Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. Another bug due to the incorrect caching of Keccak-256 was reported. It is likely that there are latent bugs related to optimization and that future optimizations will introduce new bugs. Exploit Scenario A latent or future bug in Solidity compiler optimizations—or in the Emscripten transpilation to solc-js—causes a security vulnerability in the Arcade contracts. Recommendations Short term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug. Long term, monitor the development and adoption of Solidity compiler optimizations to assess their maturity. 25 Arcade.xyz V3 Security Assessment 
3. callApprove does not follow approval best practices Severity: Informational Diﬃculty: Medium Type: Undeﬁned Behavior Finding ID: TOB-ARCADE-3 Target: contracts/vault/AssetVault.sol Description The AssetVault.callApprove function has undocumented behaviors and lacks the increase/decrease approval functions, which might impede third-party integrations. A well-known race condition exists in the ERC-20 approval mechanism. The race condition is enabled if a user or smart contract calls approve a second time on a spender that has already been allowed. If the spender sees the transaction containing the call before it has been mined, they can call transferFrom to transfer the previous value and then still receive authorization to transfer the new value. To mitigate this, AssetVault uses the SafeERC20.safeApprove function, which will revert if the allowance is updated from nonzero to nonzero. However, this behavior is not documented, and it might break the protocol’s integration with third-party contracts or oﬀ-chain components. 282 283 284 285 286 287 288 289 290 291 292 293 294 295 37 38 39 40 41 42 function callApprove( address token, address spender, uint256 amount ) external override onlyAllowedCallers onlyWithdrawDisabled nonReentrant { if (!CallWhitelistApprovals(whitelist).isApproved(token, spender)) { revert AV_NonWhitelistedApproval(token, spender); } // Do approval IERC20(token).safeApprove(spender, amount); emit Approve(msg.sender, token, spender, amount); } Figure 3.1: The callApprove function in arcade-protocol/contracts/vault/AssetVault.sol /** * @dev Deprecated. This function has issues similar to the ones found in * {IERC20-approve}, and its usage is discouraged. * * Whenever possible, use {safeIncreaseAllowance} and * {safeDecreaseAllowance} instead. 26 Arcade.xyz V3 Security Assessment */ function safeApprove( IERC20 token, address spender, uint256 value ) internal { 43 44 45 46 47 48 49 50 51 52 53 54 55 56 spender, value)); 57 } // safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' require( (value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" ); _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, Figure 3.2: The safeApprove function in openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol An alternative way to mitigate the ERC-20 race condition is to use the increaseAllowance and decreaseAllowance functions to safely update allowances. These functions are widely used by the ecosystem and allow users to update approvals with less ambiguity. uint256 newAllowance = token.allowance(address(this), spender) + value; _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, } ) internal { function safeIncreaseAllowance( function safeDecreaseAllowance( IERC20 token, address spender, uint256 value 59 60 61 62 63 64 65 spender, newAllowance)); 66 67 68 69 70 71 72 73 74 75 zero"); 76 77 abi.encodeWithSelector(token.approve.selector, spender, newAllowance)); 78 79 uint256 newAllowance = oldAllowance - value; _callOptionalReturn(token, IERC20 token, address spender, uint256 value ) internal { unchecked { } } uint256 oldAllowance = token.allowance(address(this), spender); require(oldAllowance >= value, "SafeERC20: decreased allowance below Figure 3.3: The safeIncreaseAllowance and safeDecreaseAllowance functions in openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol 27 Arcade.xyz V3 Security Assessment Exploit Scenario Alice, the owner of an asset vault, sets up an approval of 1,000 for her external contract by calling callApprove. She later decides to update the approval amount to 1,500 and again calls callApprove. This second call reverts, which she did not expect. Recommendations Short term, take one of the following actions: ● Update the documentation to make it clear to users and other integrating smart contract developers that two transactions are needed to update allowances. ● Add two new functions in the AssetVault contract: callIncreaseAllowance and callDecreaseAllowance, which internally call SafeERC20.safeIncreaseAllowance and SafeERC20.safeDecreaseAllowance, respectively. Long term, when using external libraries/contracts, always ensure that they are being used correctly and that edge cases are explained in the documentation. 28 Arcade.xyz V3 Security Assessment 
4. Risk of confusing events due to missing checks in whitelist contracts Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-ARCADE-4 Target: contracts/vault/CallWhitelist.sol, contracts/vault/CallWhitelistDelegation.sol Description The CallWhitelist contract’s add and remove functions do not check whether the given call has been registered in the whitelist. As a result, add could be used to register calls that have already been registered, and remove could be used to remove calls that have never been registered; these types of calls would still emit events. For example, invoking remove with a call that is not in the whitelist would emit a CallRemoved event even though no call was removed. Such an event could confuse oﬀ-chain monitoring systems, or at least make it more diﬃcult to retrace what happened by looking at the emitted event. 64 65 66 67 function add(address callee, bytes4 selector) external override onlyOwner { whitelist[callee][selector] = true; emit CallAdded(msg.sender, callee, selector); } Figure 4.1: The add function in arcade-protocol/contracts/vault/CallWhitelist.sol 75 76 77 78 function remove(address callee, bytes4 selector) external override onlyOwner { whitelist[callee][selector] = false; emit CallRemoved(msg.sender, callee, selector); } Figure 4.2: The remove function in arcade-protocol/contracts/vault/CallWhitelist.sol A similar problem exists in the CallWhitelistDelegation.setRegistry function. This function can be called to set the registry address to the current registry address. In that case, the emitted RegistryChanged event would be confusing because nothing would have actually changed. 85 86 87 88 89 function setRegistry(address _registry) external onlyOwner { registry = IDelegationRegistry(_registry); emit RegistryChanged(msg.sender, _registry); } 29 Arcade.xyz V3 Security Assessment Figure 4.3: The setRegistry function in arcade-protocol/contracts/vault/CallWhitelistDelegation.sol Arcade has explained that the owner of the whitelist contracts in Arcade V3 will be a (set of) governance contract(s), so it is unlikely that this issue will happen. However, it is possible, and it could be prevented by more validation. Exploit Scenario No calls have yet been added to the whitelist in CallWhitelist. Through the governance system, a proposal to remove a call with the address 0x1 and the selector 0x12345678 is approved. The proposal is executed, and CallWhitelist.remove is called. The transaction succeeds, and a CallRemoved event is emitted, even though the “removed” call was never in the whitelist in the ﬁrst place. Recommendations Short term, add validation to the add, remove, and setRegistry functions. For the add function, it should ensure that the given call is not already in the whitelist. For the remove function, it should ensure that the call is currently in the whitelist. For the setRegistry function, it should ensure that the new registry address is not the current registry address. Adding this validation will prevent confusing events from being emitted and ease the tracing of events in the whitelist over time. Long term, when dealing with function arguments, always ensure that all inputs are validated as tightly as possible and that the subsequent emitted events are meaningful. Additionally, consider setting up an oﬀ-chain monitoring system that will track important system events. Such a system will provide an overview of the events that occur in the contracts and will be useful when incidents occur. 30 Arcade.xyz V3 Security Assessment 
5. Missing checks of _exists() return value Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-ARCADE-5 Target: contracts/PromissoryNote.sol, contracts/vault/VaultFactory.sol Description The ERC-721 _exists() function returns a Boolean value that indicates whether a token with the speciﬁed tokenId exists. In two instances in Arcade’s codebase, the function is called but its return value is not checked, bypassing the intended result of the existence check. In particular, in the PromissoryNote.tokenURI() and VaultFactory.tokenURI() functions, _exists() is called before the URI for the tokenId is returned, but its return value is not checked. If the given NFT does not exist, the URI returned by the tokenURI() function will be incorrect, but this error will not be detected due to the missing return value check on _exists(). 165 function tokenURI(uint256 tokenId) public view override(INFTWithDescriptor, ERC721) returns (string memory) { 166 167 168 169 } _exists(tokenId); return descriptor.tokenURI(address(this), tokenId); Figure 5.1: The tokenURI function in arcade-protocol/contracts/PromissoryNote.sol 48 function tokenURI(address, uint256 tokenId) external view override returns (string memory) { 49 return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : ""; 50 } Figure 5.2: The tokenURI function in arcade-protocol/contracts/nft/BaseURIDescriptor.sol Exploit Scenario Bob, a developer of a front-end blockchain application that interacts with the Arcade contracts, develops a page that lists users' promissory notes and vaults with their respective URIs. He accidentally passes a nonexistent tokenId to tokenURI(), causing his application to show an incorrect or incomplete URI. 31 Arcade.xyz V3 Security Assessment Recommendations Short term, add a check for the _exists() function’s return value to both of the tokenURI() functions to prevent them from returning an incomplete URI for nonexistent tokens. Long term, add new test cases to verify the expected return values of tokenURI() in all contracts that use it, with valid and invalid tokens as arguments. 32 Arcade.xyz V3 Security Assessment 
6. Incorrect deployers in integration tests Severity: Informational Diﬃculty: High Type: Testing Finding ID: TOB-ARCADE-6 Target: test/Integration.ts Description The ﬁxture deployment function in the provided integration tests uses diﬀerent signers for deploying the Arcade contracts before performing the tests. All Arcade contracts are meant to be deployed by the protocol team, except for vaults, which are deployed by users using the VaultFactory contract. However, in the ﬁxture deployment function, some contracts are deployed from the borrower account instead of the admin account. Some examples are shown in ﬁgure 6.1; however, there are other instances in which contracts are not deployed from the admin account. const whitelist = <CallWhitelist>await deploy("CallWhitelist", signers[0], const signers: SignerWithAddress[] = await ethers.getSigners(); const [borrower, lender, admin] = signers; 71 72 73 74 []); 75 76 77 signers[0], [BASE_URI]) 78 [vaultTemplate.address, whitelist.address, feeController.address, descriptor.address]); const vaultTemplate = <AssetVault>await deploy("AssetVault", signers[0], []); const feeController = <FeeController>await deploy("FeeController", admin, []); const descriptor = <BaseURIDescriptor>await deploy("BaseURIDescriptor", const vaultFactory = <VaultFactory>await deploy("VaultFactory", signers[0], Figure 6.1: A snippet of the tests in arcade-protocol/test/Integration.ts Exploit Scenario Alice, a developer on the Arcade team, adds a new permissioned feature to the protocol. She adds the relevant integration tests for her feature, and all tests pass. However, because the deployer for the test contracts was not the admin account, those tests should have failed, and the contracts are deployed to the network with a bug. Recommendations Short term, correct all of the instances of incorrect deployers for the contracts in the integration tests ﬁle. 33 Arcade.xyz V3 Security Assessment Long term, add additional test cases to ensure that the account permissions in all deployed contracts are correct. 34 Arcade.xyz V3 Security Assessment 
7. Risk of out-of-gas revert due to use of transfer() in claimFees Severity: Informational Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-ARCADE-7 Target: contracts/vault/VaultFactory.sol Description The VaultFactory.claimFees function uses the low-level transfer() operation to move the collected ETH fees to another arbitrary address. The transfer() operation sends only 2,300 units of gas with this operation. As a result, if the recipient is a contract with logic inside the receive() function, which would use extra gas, the operation will probably (depending on the gas cost) fail due to an out-of-gas revert. 194 195 196 197 198 199 function claimFees(address to) external onlyRole(FEE_CLAIMER_ROLE) { uint256 balance = address(this).balance; payable(to).transfer(balance); emit ClaimFees(to, balance); } Figure 7.1: The claimFees function in arcade-protocol/contracts/vault/VaultFactory.sol The Arcade team has explained that the recipient will be a treasury contract with no logic inside the receive() function, meaning the current use of transfer() will not pose any problems. However, if at some point the recipient does contain logic inside the receive() function, then claimFees will likely revert and the contract will not be able to claim the funds. Note, however, that the fees could be claimed by another address (i.e., the fees will not be stuck). The withdrawETH function in the AssetVault contract uses Address.sendValue instead of transfer(). function withdrawETH(address to) external override onlyOwner 223 onlyWithdrawEnabled nonReentrant { 224 225 226 227 228 // perform transfer uint256 balance = address(this).balance; payable(to).sendValue(balance); emit WithdrawETH(msg.sender, to, balance); } 35 Arcade.xyz V3 Security Assessment Figure 7.2: The withdrawETH function in arcade-protocol/contracts/vault/AssetVault.sol Address.sendValue internally uses the call() operation, passing along all of the remaining gas, so this function could be a good candidate to replace use of transfer() in claimFees. However, doing so could introduce other risks like reentrancy attacks. Note that neither the withdrawETH function nor the claimFees function is currently at risk of reentrancy attacks. Exploit Scenario Alice, a developer on the Arcade team, deploys a new treasury contract that contains an updated receive() function that also writes the received ETH amount into a storage array in the treasury contract. Bob, whose account has the FEE_CLAIMER_ROLE role in the VaultFactory contract, calls claimFees with the newly deployed treasury contract as the recipient. The transaction fails because the write to storage exceeds the passed along 2,300 units of gas. Recommendations Short term, consider replacing the claimFees function’s use of transfer() with Address.sendValue; weigh the risk of possibly introducing vulnerabilities like reentrancy attacks against the beneﬁt of being able to one day add logic in the fee recipient’s receive() function. If the decision is to have claimFees continue to use transfer(), update the NatSpec comments for the function so that readers will be aware of the 2,300 gas limit on the fee recipient. Long term, when deciding between using the low-level transfer() and call() operations, consider how malicious smart contracts may be able to exploit the lack of limits on the gas available in the recipient function. Additionally, consider the likelihood that the recipient will be a smart wallet or multisig (or other smart contract) with logic inside the receive() function, as the 2,300 gas from transfer() might not be suﬃcient for those recipients. 36 Arcade.xyz V3 Security Assessment 
8. Risk of lost funds due to lack of zero-address check in functions Severity: Medium Diﬃculty: High Type: Data Validation Finding ID: TOB-ARCADE-8 Target: contracts/vault/VaultFactory.sol, contracts/RepaymentController.sol, contracts/LoanCore.sol Description The VaultFactory.claimFees (ﬁgure 8.1), RepaymentController.redeemNote (ﬁgure 8.2), LoanCore.withdraw, and LoanCore.withdrawProtocolFees functions are all missing a check to ensure that the to argument does not equal the zero address. As a result, these functions could transfer funds to the zero address. 194 195 196 197 198 199 function claimFees(address to) external onlyRole(FEE_CLAIMER_ROLE) { uint256 balance = address(this).balance; payable(to).transfer(balance); emit ClaimFees(to, balance); } Figure 8.1: The claimFees function in arcade-protocol/contracts/vault/VaultFactory.sol function redeemNote(uint256 loanId, address to) external override { LoanLibrary.LoanData memory data = loanCore.getLoan(loanId); (, uint256 amountOwed) = loanCore.getNoteReceipt(loanId); if (data.state != LoanLibrary.LoanState.Repaid) revert address lender = lenderNote.ownerOf(loanId); if (lender != msg.sender) revert RC_OnlyLender(lender, msg.sender); uint256 redeemFee = (amountOwed * feeController.get(FL_09)) / 126 127 128 129 130 RC_InvalidState(data.state); 131 132 133 134 BASIS_POINTS_DENOMINATOR; 135 136 137 } loanCore.redeemNote(loanId, redeemFee, to); Figure 8.2: The redeemNote function in arcade-protocol/contracts/RepaymentController.sol Exploit Scenario A script that is used to periodically withdraw the protocol fees (calling LoanCore.withdrawProtocolFees) is updated. Due to a mistake, the to argument is left 37 Arcade.xyz V3 Security Assessment uninitialized. The script is executed, and the to argument defaults to the zero address, causing withdrawProtocolFees to transfer the protocol fees to the zero address. Recommendations Short term, add a check to verify that to does not equal the zero address to the following functions: ● VaultFactory.claimFees ● RepaymentController.redeemNote ● LoanCore.withdraw ● LoanCore.withdrawProtocolFees Long term, use the Slither static analyzer to catch common issues such as this one. Consider integrating a Slither scan into the project’s CI pipeline, pre-commit hooks, or build scripts. 38 Arcade.xyz V3 Security Assessment 
9. The maximum value for FL_09 is not set by FeeController Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-ARCADE-9 Target: contracts/FeeController.sol Description The FeeController constructor initializes all of the maximum values for the fees deﬁned in the FeeLookups contract except for FL_09 (LENDER_REDEEM_FEE). Because the maximum value is not set, it is possible to set any amount, with no upper bound, for that particular fee. The lender's redeem fee is used in RepaymentController’s redeemNote function to calculate the fee paid by the lender to the protocol in order to receive their funds back. If the protocol team accidentally sets the fee to 100%, all of the users' funds to be redeemed would instead be used to pay the protocol. 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 constructor() { /// @dev Vault mint fee - gross maxFees[FL_01] = 1 ether; /// @dev Origination fees - bps maxFees[FL_02] = 10_00; maxFees[FL_03] = 10_00; /// @dev Rollover fees - bps maxFees[FL_04] = 20_00; maxFees[FL_05] = 20_00; /// @dev Loan closure fees - bps maxFees[FL_06] = 10_00; maxFees[FL_07] = 50_00; maxFees[FL_08] = 10_00; } Figure 9.1: The constructor in arcade-protocol/contracts/FeeController.sol function redeemNote(uint256 loanId, address to) external override { LoanLibrary.LoanData memory data = loanCore.getLoan(loanId); (, uint256 amountOwed) = loanCore.getNoteReceipt(loanId); 126 127 128 129 130 RC_InvalidState(data.state); 131 if (data.state != LoanLibrary.LoanState.Repaid) revert address lender = lenderNote.ownerOf(loanId); 39 Arcade.xyz V3 Security Assessment if (lender != msg.sender) revert RC_OnlyLender(lender, msg.sender); uint256 redeemFee = (amountOwed * feeController.get(FL_09)) / 132 133 134 BASIS_POINTS_DENOMINATOR; 135 136 137 } loanCore.redeemNote(loanId, redeemFee, to); Figure 9.2: The redeemNote function in arcade-protocol/contracts/RepaymentController.sol Exploit Scenario Charlie, a member of the Arcade protocol team, has access to the privileged account that can change the protocol fees. He wants to set LENDERS_REDEEM_FEE to 5%, but he accidentally types a 0 and sets it to 50%. Users can now lose half of their funds to the new protocol fee, causing distress and lack of trust in the team. Recommendations Short term, set a maximum boundary for the FL_09 fee in FeeController’s constructor. Long term, improve the test suite to ensure that all fee-changing functions test for out-of-bounds values for all fees, not just FL_02. 40 Arcade.xyz V3 Security Assessment 
10. Fees can be changed while a loan is active Severity: Low Type: Timing Diﬃculty: High Finding ID: TOB-ARCADE-10 Target: contracts/FeeController.sol Description All fees in the protocol are calculated using the current fees, as informed by the FeeController contract. However, fees can be changed by the team at any time, so the eﬀective rollover and closure fees that the users will pay can change once their loans are already initialized; therefore, these fees are impossible to know in advance. For example, in the code shown in ﬁgure 10.1, the LENDER_INTEREST_FEE and LENDER_PRINCIPAL_FEE values are read when a loan is about to be repaid, but these values can be diﬀerent from the values the user agreed to when the loan was initialized. The same can happen in OriginationController and other functions in RepaymentController. function _prepareRepay(uint256 loanId) internal view returns (uint256 LoanLibrary.LoanData memory data = loanCore.getLoan(loanId); if (data.state == LoanLibrary.LoanState.DUMMY_DO_NOT_USE) revert if (data.state != LoanLibrary.LoanState.Active) revert 149 amountFromBorrower, uint256 amountToLender) { 150 151 RC_CannotDereference(loanId); 152 RC_InvalidState(data.state); 153 154 155 156 terms.proratedInterestRate); 157 158 BASIS_POINTS_DENOMINATOR; 159 BASIS_POINTS_DENOMINATOR; 160 161 162 163 } LoanLibrary.LoanTerms memory terms = data.terms; uint256 interest = getInterestAmount(terms.principal, uint256 interestFee = (interest * feeController.get(FL_07)) / uint256 principalFee = (terms.principal * feeController.get(FL_08)) / amountFromBorrower = terms.principal + interest; amountToLender = amountFromBorrower - interestFee - principalFee; Figure 10.1: The _prepareRepay function in arcade-protocol/contracts/RepaymentController.sol 41 Arcade.xyz V3 Security Assessment Exploit Scenario Lucy, the lender, and Bob, the borrower, agree on the current loan conditions and fees at a certain point in time. Some weeks later, when the time comes to repay the loan, they learn that the protocol team decided to change the fees while their loan was active. Lucy’s earnings are now diﬀerent from what she expected. Recommendations Short term, consider storing (for example, in the LoanTerms structure) the fee values that both counterparties agree on when a loan is initialized, and use those local values for the full lifetime of the loan. Long term, document all of the conditions that are agreed on by the counterparties and that should be constant during the lifetime of the loan, and make sure they are preserved. Add a speciﬁc integration or fuzzing test for these conditions. 42 Arcade.xyz V3 Security Assessment 
11. Asset vault nesting can lead to loss of assets Severity: Low Diﬃculty: High Type: Access Controls Finding ID: TOB-ARCADE-11 Target: contracts/vault/VaultFactory.sol, contracts/vault/AssetVault.sol Description Allowing asset vaults to be nested (e.g., vault A is owned by vault B, and vault B is owned by vault X, etc.) could result in a situation in which multiple asset vaults own each other. This would result in a deadlock preventing assets in the aﬀected asset vaults from ever being withdrawn again. Asset vaults are designed to hold diﬀerent types of assets, including ERC-721 tokens. The ownership of an asset vault is tracked by an accompanying ERC-721 token that is minted (ﬁgure 11.1) when the asset vault is deployed through the VaultFactory contract. 164 (uint256) { 165 166 167 mintFee); 168 169 170 171 172 173 mintFee); 174 175 176 177 } function initializeBundle(address to) external payable override returns uint256 mintFee = feeController.get(FL_01); if (msg.value < mintFee) revert VF_InsufficientMintFee(msg.value, address vault = _create(); _mint(to, uint256(uint160(vault))); emit VaultCreated(vault, to); return uint256(uint160(vault)); if (msg.value > mintFee) payable(msg.sender).transfer(msg.value - Figure 11.1: The initializeBundle function in arcade-protocol/contracts/vault/VaultFactory.sol To add an ERC-721 asset to an asset vault, it needs to be transferred to the asset vault’s address. Because the ownership of an asset vault is tracked by an ERC-721 token, it is possible to transfer the ownership of an asset vault to another asset vault by simply transferring the ERC-721 token representing vault ownership. To withdraw ERC-721 tokens from an asset vault, the owner (the holder of the asset vault’s ERC-721 token) needs to 43 Arcade.xyz V3 Security Assessment enable withdrawals (using the enableWithdraw function) and then call the withdrawERC721 (or withdrawBatch) function. 121 122 123 124 150 151 152 153 154 155 156 function enableWithdraw() external override onlyOwner onlyWithdrawDisabled { withdrawEnabled = true; emit WithdrawEnabled(msg.sender); } Figure 11.2: The enableWithdraw function in arcade-protocol/contracts/vault/AssetVault.sol function withdrawERC721( address token, uint256 tokenId, address to ) external override onlyOwner onlyWithdrawEnabled { _withdrawERC721(token, tokenId, to); } Figure 11.3: The withdrawERC721 function in arcade-protocol/contracts/vault/AssetVault.sol Only the owner of an asset vault can enable and perform withdrawals. Therefore, if two (or more) vaults own each other, it would be impossible for a user to enable or perform withdrawals on the aﬀected vaults, permanently locking all assets (ERC-721, ERC-1155, ERC-20, ETH) within them. The severity of the issue depends on the UI, which was out of scope for this review. If the UI does not prevent vaults from owning each other, the severity of this issue is higher. In terms of likelihood, this issue would require a user to make a mistake (although a mistake that is far more likely than the transfer of tokens to a random address) and would require the UI to fail to detect and prevent or warn the user from making such a mistake. We therefore rated the diﬃculty of this issue as high. Exploit Scenario Alice decides to borrow USDC by putting up some of her NFTs as collateral: 1. Alice uses the UI to create an asset vault (vault A) and transfers ﬁve of her CryptoPunks to the asset vault. 2. The UI shows that Alice has another existing vault (vault X), which contains two Bored Apes. She wants to use these two vaults together to borrow a higher amount of USDC. She clicks on vault A and selects the “Add Asset” option. 3. The UI shows a list of assets that Alice owns, including the ERC-721 token that represents ownership of vault X. Alice clicks on “Add”, the transaction succeeds, and the vault X NFT is transferred to vault A. Vault X is now owned by vault A. 44 Arcade.xyz V3 Security Assessment 4. Alice decides to add another Bored Ape NFT that she owns to vault X. She opens the vault X page and clicks on “Add Assets”, and the list of assets that she can add shows the ERC-721 token that represents ownership of vault A. 5. Alice is confused and wonders if adding vault X to vault A worked (step 3). She decides to add vault A to vault X instead. The transaction succeeds, and now vault A owns vault X and vice versa. Alice is now unable to withdraw any of the assets from either vault. Recommendations Short term, take one of the following actions: ● Disallow the nesting of asset vaults. That is, prevent users from being able to transfer ownership of an asset vault to another asset vault. This would prevent the issue altogether. ● If allowing asset vaults to be nested is a desired feature, update the UI to prevent two or more asset vaults from owning each other (if it does not already do so). Also, update the documentation so that other integrating smart contract protocols are aware of the issue. Long term, when dealing with the nesting of assets, consider edge cases and write extensive tests that ensure these edge cases are handled correctly and that users do not lose access to their assets. Other than unit tests, we recommend writing invariants and testing them using property-based testing with Echidna. 45 Arcade.xyz V3 Security Assessment 
12. Risk of locked assets due to use of _mint instead of _safeMint Severity: Medium Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-ARCADE-12 Target: contracts/vault/VaultFactory.sol, contracts/PromissoryNote.sol Description The asset vault and promissory note ERC-721 tokens are minted via the _mint function rather than the _safeMint function. The _safeMint function includes a necessary safety check that validates a recipient contract’s ability to receive and handle ERC-721 tokens. Without this safeguard, tokens can inadvertently be sent to an incompatible contract, causing them, and any assets they hold, to become irretrievable. 164 (uint256) { 165 166 167 mintFee); 168 169 170 171 172 173 mintFee); 174 175 176 177 } function initializeBundle(address to) external payable override returns uint256 mintFee = feeController.get(FL_01); if (msg.value < mintFee) revert VF_InsufficientMintFee(msg.value, address vault = _create(); _mint(to, uint256(uint160(vault))); emit VaultCreated(vault, to); return uint256(uint160(vault)); if (msg.value > mintFee) payable(msg.sender).transfer(msg.value - Figure 12.1: The initializeBundle function in arcade-protocol/contracts/vault/VaultFactory.sol function mint(address to, uint256 loanId) external override returns (uint256) if (!hasRole(MINT_BURN_ROLE, msg.sender)) revert 135 { 136 PN_MintingRole(msg.sender); 137 138 139 140 return loanId; _mint(to, loanId); } Figure 12.2: The mint function in arcade-protocol/contracts/PromissoryNote.sol 46 Arcade.xyz V3 Security Assessment The _safeMint function’s built-in safety check ensures that the recipient contract has the necessary ERC721Receiver implementation, verifying the contract’s ability to receive and manage ERC-721 tokens. 258 259 260 261 262 263 264 265 266 267 268 function _safeMint( address to, uint256 tokenId, bytes memory _data ) internal virtual { _mint(to, tokenId); require( _checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer" ); } Figure 12.3: The _safeMint function in openzeppelin-contracts/contracts/token/ERC721/ERC721.sol The _checkOnERC721Received method invokes the onERC721Received method on the receiving contract, expecting a return value containing the bytes4 selector of the onERC721Received method. A successful pass of this check implies that the contract is indeed capable of receiving and processing ERC-721 tokens. The _safeMint function does allow for reentrancy through the calling of _checkOnERC721Received on the receiver of the token. However, based on the order of operations in the aﬀected functions in Arcade (ﬁgures 12.1 and 12.2), this poses no risk. Exploit Scenario Alice initializes a new asset vault by invoking the initializeBundle function of the VaultFactory contract, passing in her smart contract wallet address as the to argument. She transfers her valuable CryptoPunks NFT, intended to be used for collateral, to the newly created asset vault. However, she later discovers that her smart contract wallet lacks support for ERC-721 tokens. As a result, both her asset vault token and the CryptoPunks NFT become irretrievable, stuck within her smart wallet contract due to the absence of a mechanism to handle ERC-721 tokens. Recommendations Short term, use the _safeMint function instead of _mint in the PromissoryNote and VaultFactory contracts. The _safeMint function includes vital checks that ensure the recipient is equipped to handle ERC-721 tokens, thus mitigating the risk that NFTs could become frozen. Long term, enhance the unit testing suite. These tests should encompass more negative paths and potential edge cases, which will help uncover any hidden vulnerabilities or bugs like this one. Additionally, it is critical to test user-provided inputs extensively, covering a 47 Arcade.xyz V3 Security Assessment broad spectrum of potential scenarios. This rigorous testing will contribute to building a more secure, robust, and reliable system. 48 Arcade.xyz V3 Security Assessment 
13. Borrowers cannot realize full loan value without risking default Severity: Medium Diﬃculty: Low Type: Timing Finding ID: TOB-ARCADE-13 Target: contracts/LoanCore.sol Description To fully capitalize on their loans, borrowers need to retain their loaned assets and the owed interest for the entire term of their loans. However, if a borrower waits until the loan’s maturity date to repay it, they become immediately vulnerable to liquidation of their collateral by the lender. As soon as the block.timestamp value exceeds the dueDate value, a lender can invoke the claim function to liquidate the borrower’s collateral. 293 294 295 // First check if the call is being made after the due date. uint256 dueDate = data.startDate + data.terms.durationSecs; if (dueDate >= block.timestamp) revert LC_NotExpired(dueDate); Figure 13.1: A snippet of the claim function in arcade-protocol/contracts/LoanCore.sol Owing to the inherent nature of the blockchain, achieving precise synchronization between the block.timestamp and the dueDate is practically impossible. Moreover, repaying a loan before the dueDate would result in a loss of some of the loan’s inherent value because the protocol’s interest assessment design does not refund any part of the interest for early repayment. In a scenario in which block.timestamp is greater than dueDate, a lender can preempt a borrower’s loan repayment attempt, invoke the claim function, and liquidate the borrower’s collateral. Frequently, collateral will be worth more than the loaned assets, giving lenders an incentive to do this. Given the protocol’s interest assessment design, the Arcade team should implement a grace period following the maturity date where no additional interest is expected to be assessed beyond the period agreed to in the loan terms. This buﬀer would give the borrower an opportunity to fully capitalize on the term of their loan without the risk of defaulting and losing their collateral. 49 Arcade.xyz V3 Security Assessment Exploit Scenario Alice, a borrower, takes out a loan from Eve using Arcade’s NFT lending protocol. Alice deposits her rare CryptoPunk as collateral, which is more valuable than the assets loaned to her, so that her position is over-collateralized. Alice plans to hold on to the lent assets for the entire duration of the loan period in order to maximize her beneﬁt-to-cost ratio. Eve, the lender, is monitoring the blockchain for the moment when the block.timestamp is greater than or equal to the dueDate so that she can call the claim function and liquidate Alice’s CryptoPunk. As soon as the loan term is up, Alice submits a transaction to the repay function, and Eve front-runs that transaction with her own call to the claim function. As a result, Eve is able to liquidate Alice’s CryptoPunk collateral. Recommendations Short term, introduce a grace period after the loan's maturity date during which the lender cannot invoke the claim function. This buﬀer would give the borrower suﬃcient time to repay the loan without the risk of immediate collateral liquidation. Long term, revise the protocol's interest assessment design to allow a portion of the interest to be refunded in cases of early repayment. This change could reduce the incentive for borrowers to delay repayment until the last possible moment. Additionally, provide better education for borrowers on how the lending protocol works, particularly around critical dates and actions, and improve communication channels for borrowers to raise concerns or seek clariﬁcation. 50 Arcade.xyz V3 Security Assessment 
14. itemPredicates encoded incorrectly according to EIP-712 Severity: Low Diﬃculty: Low Type: Conﬁguration Finding ID: TOB-ARCADE-14 Target: contracts/OriginationController.sol Description The itemPredicates parameter is not encoded correctly, so the signer cannot see the veriﬁer address when signing. The veriﬁer address receives each batch of listed assets to check them for correctness and existence, which is vital to ensuring the security and integrity of the lending transaction. According to EIP-712, structured data should be hashed in conjunction with its typeHash. The following is the hashStruct function as deﬁned in EIP-712: hashStruct(s : 𝕊) = keccak256(typeHash ‖ encodeData(s)) where typeHash = keccak256(encodeType(typeOf(s))) In the protocol, the recoverItemsSignature function hashes an array of Predicate[] structs that are passed in as the itemPredicates argument. The function encodes and hashes the array without adding the Predicate typeHash to each member of the array. The hashed output of that operation is then included in the _ITEMS_TYPEHASH variable as a bytes32 type, referred to as itemsHash. 208 209 210 211 212 213 214 (bytes32 sighash, address externalSigner) = recoverItemsSignature( loanTerms, sig, nonce, neededSide, keccak256(abi.encode(itemPredicates)) ); Figure 14.1: A snippet of the initializeLoanWithItems function in arcade-protocol/contracts/OriginationController.sol keccak256( bytes32 private constant _ITEMS_TYPEHASH = 85 86 87 88 proratedInterestRate,uint256 principal,address collateralAddress,bytes32 itemsHash,address payableCurrency,bytes32 affiliateCode,uint160 nonce,uint8 side)" 89 // solhint-disable max-line-length "LoanTermsWithItems(uint32 durationSecs,uint32 deadline,uint160 ); 51 Arcade.xyz V3 Security Assessment Figure 14.2: The _ITEMS_TYPEHASH variable in arcade-protocol/contracts/OriginationController.sol However, this method of encoding an array of structs is not consistent with the EIP-712 guidelines, which stipulates the following: “The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents (i.e., the encoding of SomeType[5] is identical to that of a struct containing ﬁve members of type SomeType). The struct values are encoded recursively as hashStruct(value). This is undeﬁned for cyclical data.” Therefore, the protocol should iterate over the itemPredicates array, encoding each Predicate instance separately with its respective typeHash. Exploit Scenario Alice creates a loan oﬀering that takes CryptoPunks as collateral. She submits the loan terms to the Arcade protocol. Bob, a CryptoPunk holder, navigates the Arcade UI to accept Alice’s loan terms. An EIP-712 signature request appears in MetaMask for Bob to sign. Bob cannot validate whether the message he is signing uses the CryptoPunk veriﬁer contract because that information is not included in the hash. Recommendations Short term, adjust the encoding of itemPredicates to comply with EIP-712 standards. Have the code iterate through the itemPredicates array and encode each Predicate instance separately with its associated typeHash. Additionally, refactor the _ITEMS_TYPEHASH variable so that the Predicate typeHash deﬁnition is appended to it and replace the bytes32 itemsHash parameter with Predicate[] items. This revision will allow the signer to see the veriﬁer address of the message they are signing, ensuring the validity of each batch of items, in addition to complying with the EIP-712 standard. Long term, strictly adhere to established Ethereum protocols such as EIP-712. These standards exist to ensure interoperability, security, and predictable behavior in the Ethereum ecosystem. Violating these norms can lead to unforeseen security vulnerabilities. 52 Arcade.xyz V3 Security Assessment 
15. The fee values can distort the incentives for the borrowers and lenders Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-ARCADE-15 Target: contracts/FeeController.sol Description Arcade V3 contains nine fee settings. Six of these fees are to be paid by the lender, two are to be paid by the borrower, and the remaining fee is to be paid by the borrower if they decide to mint a new vault for their collateral. Depending on the values of these settings, the incentives can change for both loan counterparties. For example, to create a new loan, both the borrower and lender have to pay origination fees, and eventually, the loan must be rolled over, repaid, or defaulted. In the ﬁrst case, both the new lender and borrower pay rollover fees; note that the original lender pays no fees at all for closing the loan. In the second case, the lender pays interest fees and principal fees on closing the loan. Finally, if the loan is defaulted, the lender pays a default fee to liquidate the collateral. The various fees paid based on the outcome of the loan can result in an interesting incentive game for investors in the protocol, depending on the actual values of the fee settings. If the lender rollover fee is cheaper than the origination fee, investors may be incentivized to roll over existing loans instead of creating new ones, beneﬁting the original lenders by saving them the closing fees, and harming the borrowers by indirectly raising the interest rates to compensate. Similarly, if the lender rollover fees are higher than the closing fees, lenders will be less incentivized to rollover loans. In summary, having such ﬁne control over possible fee settings introduces hard-to-predict incentives scenarios that can scare users away or cause users who do not account for fees to inadvertently lose proﬁts. Recommendations Short term, clearly inform borrowers and lenders of all of the existing fees and their current values at the moment a loan is opened, as well as the various possible outcomes, including the expected net proﬁts if the loan is repaid, rolled over, defaulted, or redeemed. Long term, add interactive ways for users to calculate their expected proﬁts, such as a loan simulator. 53 Arcade.xyz V3 Security Assessment 
1. Di erent zero-address errors thrown by single and batch NFT withdrawal functions Severity: Informational Diﬃculty: High Type: Error Reporting Finding ID: TOB-ARCADE-1 Target: contracts/vault/AssetVault.sol Description The withdrawBatch function throws an error that is diﬀerent from the single NFT withdrawal functions (withdrawERC721, withdrawERC1155). This could confuse users and other applications that interact with the Arcade contracts. The withdrawBatch function throws a custom error (AV_ZeroAddress) if the to parameter is set to the zero address. The single NFT withdrawal functions withdrawERC721 and withdrawERC1155 do not explicitly check the to parameter. All three of these functions internally call the _withdrawERC721 and _withdrawERC1155 functions, which also do not explicitly check the to parameter. The lack of such a check is not a problem: according to the ERC-721 and ERC-1155 standards, a transfer must revert if to is the zero address, so the single NFT withdrawal functions will revert on this condition. However, they will revert with the error message that is deﬁned inside the actual NFT contract instead of the Arcade AV_ZeroAddress error, which is thrown when withdrawBatch reverts. ) external override onlyOwner onlyWithdrawEnabled { uint256 tokensLength = tokens.length; if (tokensLength > MAX_WITHDRAW_ITEMS) revert address[] calldata tokens, uint256[] calldata tokenIds, TokenType[] calldata tokenTypes, address to function withdrawBatch( 193 194 195 196 197 198 199 200 AV_TooManyItems(tokensLength); 201 202 AV_LengthMismatch("tokenType"); 203 204 205 206 if (to == address(0)) revert AV_ZeroAddress(); for (uint256 i = 0; i < tokensLength; i++) { if (tokens[i] == address(0)) revert AV_ZeroAddress(); if (tokensLength != tokenIds.length) revert AV_LengthMismatch("tokenId"); if (tokensLength != tokenTypes.length) revert 22 Arcade.xyz V3 Security Assessment Figure 1.1: A snippet of the withdrawBatch function in arcade-protocol/contracts/vault/AssetVault.sol Additionally, the CryptoPunks NFT contract does not follow the ERC-721 and ERC-1155 standards and contains no check that prevents funds from being transferred to the zero address (and the function is called transferPunk instead of the standard transfer). An explicit check to ensure that to is not the zero address inside the withdrawPunk function is therefore recommended. 114 115 116 117 118 119 120 121 122 123 124 125 126 it. 127 128 129 130 131 132 133 134 function transferPunk(address to, uint punkIndex) { if (!allPunksAssigned) throw; if (punkIndexToAddress[punkIndex] != msg.sender) throw; if (punkIndex >= 10000) throw; if (punksOfferedForSale[punkIndex].isForSale) { punkNoLongerForSale(punkIndex); } punkIndexToAddress[punkIndex] = to; balanceOf[msg.sender]--; balanceOf[to]++; Transfer(msg.sender, to, 1); PunkTransfer(msg.sender, to, punkIndex); // Check for the case where there is a bid from the new owner and refund // Any other bid can stay in place. Bid bid = punkBids[punkIndex]; if (bid.bidder == to) { // Kill bid and refund value pendingWithdrawals[to] += bid.value; punkBids[punkIndex] = Bid(false, punkIndex, 0x0, 0); } } Figure 1.2: The transferPunk function in CryptoPunksMarket contract (Etherscan) Lastly, there is no string argument to the AV_ZeroAddress error to indicate which variable equaled the zero address and caused the revert, unlike the AV_LengthMismatch error. For example, in the batch function (ﬁgure 1.1), the AV_ZeroAddress could be thrown in line 203 or 206. Exploit Scenario Bob, a developer of a front-end blockchain application that interacts with the Arcade contracts, develops a page that interacts with an AssetVault contract. In his implementation, he catches speciﬁc errors that are thrown so that he can show an informative message to the user. Because the batch and withdrawal functions throw diﬀerent errors when to is the zero address, he needs to write two versions of error handlers instead of just one. 23 Arcade.xyz V3 Security Assessment Recommendations Short term, add the zero address check with the custom error to the _withdrawERC721 and _withdrawERC1155 functions. This will cause the same custom error to be thrown for all of the single and batch NFT withdrawal functions. Also, add an explicit zero-address check inside the withdrawPunk function. Lastly, add a string argument to the AV_ZeroAddress custom error that is used to indicate the name of the variable that triggered the error (similar to the one in AV_LengthMismatch). Long term, ensure consistency in the errors thrown throughout the implementation. This will allow users and developers to understand errors that are thrown and will allow the Arcade team to test fewer errors. 24 Arcade.xyz V3 Security Assessment 
2. Solidity compiler optimizations can be problematic Severity: Undetermined Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-ARCADE-2 Target: hardhat.config.ts Description Arcade has enabled optional compiler optimizations in Solidity. According to a November 2018 audit of the Solidity compiler, the optional optimizations may not be safe. 147 148 149 150 optimizer: { enabled: optimizerEnabled, runs: 200, }, Figure 2.1: The solc optimizer settings in arcade-protocol/hardhat.config.ts High-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten-generated solc-js compiler used by Truﬄe and Remix persisted until late 2018; the ﬁx for this bug was not reported in the Solidity changelog. Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. Another bug due to the incorrect caching of Keccak-256 was reported. It is likely that there are latent bugs related to optimization and that future optimizations will introduce new bugs. Exploit Scenario A latent or future bug in Solidity compiler optimizations—or in the Emscripten transpilation to solc-js—causes a security vulnerability in the Arcade contracts. Recommendations Short term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug. Long term, monitor the development and adoption of Solidity compiler optimizations to assess their maturity. 25 Arcade.xyz V3 Security Assessment 
3. callApprove does not follow approval best practices Severity: Informational Diﬃculty: Medium Type: Undeﬁned Behavior Finding ID: TOB-ARCADE-3 Target: contracts/vault/AssetVault.sol Description The AssetVault.callApprove function has undocumented behaviors and lacks the increase/decrease approval functions, which might impede third-party integrations. A well-known race condition exists in the ERC-20 approval mechanism. The race condition is enabled if a user or smart contract calls approve a second time on a spender that has already been allowed. If the spender sees the transaction containing the call before it has been mined, they can call transferFrom to transfer the previous value and then still receive authorization to transfer the new value. To mitigate this, AssetVault uses the SafeERC20.safeApprove function, which will revert if the allowance is updated from nonzero to nonzero. However, this behavior is not documented, and it might break the protocol’s integration with third-party contracts or oﬀ-chain components. 282 283 284 285 286 287 288 289 290 291 292 293 294 295 37 38 39 40 41 42 function callApprove( address token, address spender, uint256 amount ) external override onlyAllowedCallers onlyWithdrawDisabled nonReentrant { if (!CallWhitelistApprovals(whitelist).isApproved(token, spender)) { revert AV_NonWhitelistedApproval(token, spender); } // Do approval IERC20(token).safeApprove(spender, amount); emit Approve(msg.sender, token, spender, amount); } Figure 3.1: The callApprove function in arcade-protocol/contracts/vault/AssetVault.sol /** * @dev Deprecated. This function has issues similar to the ones found in * {IERC20-approve}, and its usage is discouraged. * * Whenever possible, use {safeIncreaseAllowance} and * {safeDecreaseAllowance} instead. 26 Arcade.xyz V3 Security Assessment */ function safeApprove( IERC20 token, address spender, uint256 value ) internal { 43 44 45 46 47 48 49 50 51 52 53 54 55 56 spender, value)); 57 } // safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' require( (value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" ); _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, Figure 3.2: The safeApprove function in openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol An alternative way to mitigate the ERC-20 race condition is to use the increaseAllowance and decreaseAllowance functions to safely update allowances. These functions are widely used by the ecosystem and allow users to update approvals with less ambiguity. uint256 newAllowance = token.allowance(address(this), spender) + value; _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, } ) internal { function safeIncreaseAllowance( function safeDecreaseAllowance( IERC20 token, address spender, uint256 value 59 60 61 62 63 64 65 spender, newAllowance)); 66 67 68 69 70 71 72 73 74 75 zero"); 76 77 abi.encodeWithSelector(token.approve.selector, spender, newAllowance)); 78 79 uint256 newAllowance = oldAllowance - value; _callOptionalReturn(token, IERC20 token, address spender, uint256 value ) internal { unchecked { } } uint256 oldAllowance = token.allowance(address(this), spender); require(oldAllowance >= value, "SafeERC20: decreased allowance below Figure 3.3: The safeIncreaseAllowance and safeDecreaseAllowance functions in openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol 27 Arcade.xyz V3 Security Assessment Exploit Scenario Alice, the owner of an asset vault, sets up an approval of 1,000 for her external contract by calling callApprove. She later decides to update the approval amount to 1,500 and again calls callApprove. This second call reverts, which she did not expect. Recommendations Short term, take one of the following actions: ● Update the documentation to make it clear to users and other integrating smart contract developers that two transactions are needed to update allowances. ● Add two new functions in the AssetVault contract: callIncreaseAllowance and callDecreaseAllowance, which internally call SafeERC20.safeIncreaseAllowance and SafeERC20.safeDecreaseAllowance, respectively. Long term, when using external libraries/contracts, always ensure that they are being used correctly and that edge cases are explained in the documentation. 28 Arcade.xyz V3 Security Assessment 
4. Risk of confusing events due to missing checks in whitelist contracts Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-ARCADE-4 Target: contracts/vault/CallWhitelist.sol, contracts/vault/CallWhitelistDelegation.sol Description The CallWhitelist contract’s add and remove functions do not check whether the given call has been registered in the whitelist. As a result, add could be used to register calls that have already been registered, and remove could be used to remove calls that have never been registered; these types of calls would still emit events. For example, invoking remove with a call that is not in the whitelist would emit a CallRemoved event even though no call was removed. Such an event could confuse oﬀ-chain monitoring systems, or at least make it more diﬃcult to retrace what happened by looking at the emitted event. 64 65 66 67 function add(address callee, bytes4 selector) external override onlyOwner { whitelist[callee][selector] = true; emit CallAdded(msg.sender, callee, selector); } Figure 4.1: The add function in arcade-protocol/contracts/vault/CallWhitelist.sol 75 76 77 78 function remove(address callee, bytes4 selector) external override onlyOwner { whitelist[callee][selector] = false; emit CallRemoved(msg.sender, callee, selector); } Figure 4.2: The remove function in arcade-protocol/contracts/vault/CallWhitelist.sol A similar problem exists in the CallWhitelistDelegation.setRegistry function. This function can be called to set the registry address to the current registry address. In that case, the emitted RegistryChanged event would be confusing because nothing would have actually changed. 85 86 87 88 89 function setRegistry(address _registry) external onlyOwner { registry = IDelegationRegistry(_registry); emit RegistryChanged(msg.sender, _registry); } 29 Arcade.xyz V3 Security Assessment Figure 4.3: The setRegistry function in arcade-protocol/contracts/vault/CallWhitelistDelegation.sol Arcade has explained that the owner of the whitelist contracts in Arcade V3 will be a (set of) governance contract(s), so it is unlikely that this issue will happen. However, it is possible, and it could be prevented by more validation. Exploit Scenario No calls have yet been added to the whitelist in CallWhitelist. Through the governance system, a proposal to remove a call with the address 0x1 and the selector 0x12345678 is approved. The proposal is executed, and CallWhitelist.remove is called. The transaction succeeds, and a CallRemoved event is emitted, even though the “removed” call was never in the whitelist in the ﬁrst place. Recommendations Short term, add validation to the add, remove, and setRegistry functions. For the add function, it should ensure that the given call is not already in the whitelist. For the remove function, it should ensure that the call is currently in the whitelist. For the setRegistry function, it should ensure that the new registry address is not the current registry address. Adding this validation will prevent confusing events from being emitted and ease the tracing of events in the whitelist over time. Long term, when dealing with function arguments, always ensure that all inputs are validated as tightly as possible and that the subsequent emitted events are meaningful. Additionally, consider setting up an oﬀ-chain monitoring system that will track important system events. Such a system will provide an overview of the events that occur in the contracts and will be useful when incidents occur. 30 Arcade.xyz V3 Security Assessment 
5. Missing checks of _exists() return value Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-ARCADE-5 Target: contracts/PromissoryNote.sol, contracts/vault/VaultFactory.sol Description The ERC-721 _exists() function returns a Boolean value that indicates whether a token with the speciﬁed tokenId exists. In two instances in Arcade’s codebase, the function is called but its return value is not checked, bypassing the intended result of the existence check. In particular, in the PromissoryNote.tokenURI() and VaultFactory.tokenURI() functions, _exists() is called before the URI for the tokenId is returned, but its return value is not checked. If the given NFT does not exist, the URI returned by the tokenURI() function will be incorrect, but this error will not be detected due to the missing return value check on _exists(). 165 function tokenURI(uint256 tokenId) public view override(INFTWithDescriptor, ERC721) returns (string memory) { 166 167 168 169 } _exists(tokenId); return descriptor.tokenURI(address(this), tokenId); Figure 5.1: The tokenURI function in arcade-protocol/contracts/PromissoryNote.sol 48 function tokenURI(address, uint256 tokenId) external view override returns (string memory) { 49 return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : ""; 50 } Figure 5.2: The tokenURI function in arcade-protocol/contracts/nft/BaseURIDescriptor.sol Exploit Scenario Bob, a developer of a front-end blockchain application that interacts with the Arcade contracts, develops a page that lists users' promissory notes and vaults with their respective URIs. He accidentally passes a nonexistent tokenId to tokenURI(), causing his application to show an incorrect or incomplete URI. 31 Arcade.xyz V3 Security Assessment Recommendations Short term, add a check for the _exists() function’s return value to both of the tokenURI() functions to prevent them from returning an incomplete URI for nonexistent tokens. Long term, add new test cases to verify the expected return values of tokenURI() in all contracts that use it, with valid and invalid tokens as arguments. 32 Arcade.xyz V3 Security Assessment 
6. Incorrect deployers in integration tests Severity: Informational Diﬃculty: High Type: Testing Finding ID: TOB-ARCADE-6 Target: test/Integration.ts Description The ﬁxture deployment function in the provided integration tests uses diﬀerent signers for deploying the Arcade contracts before performing the tests. All Arcade contracts are meant to be deployed by the protocol team, except for vaults, which are deployed by users using the VaultFactory contract. However, in the ﬁxture deployment function, some contracts are deployed from the borrower account instead of the admin account. Some examples are shown in ﬁgure 6.1; however, there are other instances in which contracts are not deployed from the admin account. const whitelist = <CallWhitelist>await deploy("CallWhitelist", signers[0], const signers: SignerWithAddress[] = await ethers.getSigners(); const [borrower, lender, admin] = signers; 71 72 73 74 []); 75 76 77 signers[0], [BASE_URI]) 78 [vaultTemplate.address, whitelist.address, feeController.address, descriptor.address]); const vaultTemplate = <AssetVault>await deploy("AssetVault", signers[0], []); const feeController = <FeeController>await deploy("FeeController", admin, []); const descriptor = <BaseURIDescriptor>await deploy("BaseURIDescriptor", const vaultFactory = <VaultFactory>await deploy("VaultFactory", signers[0], Figure 6.1: A snippet of the tests in arcade-protocol/test/Integration.ts Exploit Scenario Alice, a developer on the Arcade team, adds a new permissioned feature to the protocol. She adds the relevant integration tests for her feature, and all tests pass. However, because the deployer for the test contracts was not the admin account, those tests should have failed, and the contracts are deployed to the network with a bug. Recommendations Short term, correct all of the instances of incorrect deployers for the contracts in the integration tests ﬁle. 33 Arcade.xyz V3 Security Assessment Long term, add additional test cases to ensure that the account permissions in all deployed contracts are correct. 34 Arcade.xyz V3 Security Assessment 
7. Risk of out-of-gas revert due to use of transfer() in claimFees Severity: Informational Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-ARCADE-7 Target: contracts/vault/VaultFactory.sol Description The VaultFactory.claimFees function uses the low-level transfer() operation to move the collected ETH fees to another arbitrary address. The transfer() operation sends only 2,300 units of gas with this operation. As a result, if the recipient is a contract with logic inside the receive() function, which would use extra gas, the operation will probably (depending on the gas cost) fail due to an out-of-gas revert. 194 195 196 197 198 199 function claimFees(address to) external onlyRole(FEE_CLAIMER_ROLE) { uint256 balance = address(this).balance; payable(to).transfer(balance); emit ClaimFees(to, balance); } Figure 7.1: The claimFees function in arcade-protocol/contracts/vault/VaultFactory.sol The Arcade team has explained that the recipient will be a treasury contract with no logic inside the receive() function, meaning the current use of transfer() will not pose any problems. However, if at some point the recipient does contain logic inside the receive() function, then claimFees will likely revert and the contract will not be able to claim the funds. Note, however, that the fees could be claimed by another address (i.e., the fees will not be stuck). The withdrawETH function in the AssetVault contract uses Address.sendValue instead of transfer(). function withdrawETH(address to) external override onlyOwner 223 onlyWithdrawEnabled nonReentrant { 224 225 226 227 228 // perform transfer uint256 balance = address(this).balance; payable(to).sendValue(balance); emit WithdrawETH(msg.sender, to, balance); } 35 Arcade.xyz V3 Security Assessment Figure 7.2: The withdrawETH function in arcade-protocol/contracts/vault/AssetVault.sol Address.sendValue internally uses the call() operation, passing along all of the remaining gas, so this function could be a good candidate to replace use of transfer() in claimFees. However, doing so could introduce other risks like reentrancy attacks. Note that neither the withdrawETH function nor the claimFees function is currently at risk of reentrancy attacks. Exploit Scenario Alice, a developer on the Arcade team, deploys a new treasury contract that contains an updated receive() function that also writes the received ETH amount into a storage array in the treasury contract. Bob, whose account has the FEE_CLAIMER_ROLE role in the VaultFactory contract, calls claimFees with the newly deployed treasury contract as the recipient. The transaction fails because the write to storage exceeds the passed along 2,300 units of gas. Recommendations Short term, consider replacing the claimFees function’s use of transfer() with Address.sendValue; weigh the risk of possibly introducing vulnerabilities like reentrancy attacks against the beneﬁt of being able to one day add logic in the fee recipient’s receive() function. If the decision is to have claimFees continue to use transfer(), update the NatSpec comments for the function so that readers will be aware of the 2,300 gas limit on the fee recipient. Long term, when deciding between using the low-level transfer() and call() operations, consider how malicious smart contracts may be able to exploit the lack of limits on the gas available in the recipient function. Additionally, consider the likelihood that the recipient will be a smart wallet or multisig (or other smart contract) with logic inside the receive() function, as the 2,300 gas from transfer() might not be suﬃcient for those recipients. 36 Arcade.xyz V3 Security Assessment 
8. Risk of lost funds due to lack of zero-address check in functions Severity: Medium Diﬃculty: High Type: Data Validation Finding ID: TOB-ARCADE-8 Target: contracts/vault/VaultFactory.sol, contracts/RepaymentController.sol, contracts/LoanCore.sol Description The VaultFactory.claimFees (ﬁgure 8.1), RepaymentController.redeemNote (ﬁgure 8.2), LoanCore.withdraw, and LoanCore.withdrawProtocolFees functions are all missing a check to ensure that the to argument does not equal the zero address. As a result, these functions could transfer funds to the zero address. 194 195 196 197 198 199 function claimFees(address to) external onlyRole(FEE_CLAIMER_ROLE) { uint256 balance = address(this).balance; payable(to).transfer(balance); emit ClaimFees(to, balance); } Figure 8.1: The claimFees function in arcade-protocol/contracts/vault/VaultFactory.sol function redeemNote(uint256 loanId, address to) external override { LoanLibrary.LoanData memory data = loanCore.getLoan(loanId); (, uint256 amountOwed) = loanCore.getNoteReceipt(loanId); if (data.state != LoanLibrary.LoanState.Repaid) revert address lender = lenderNote.ownerOf(loanId); if (lender != msg.sender) revert RC_OnlyLender(lender, msg.sender); uint256 redeemFee = (amountOwed * feeController.get(FL_09)) / 126 127 128 129 130 RC_InvalidState(data.state); 131 132 133 134 BASIS_POINTS_DENOMINATOR; 135 136 137 } loanCore.redeemNote(loanId, redeemFee, to); Figure 8.2: The redeemNote function in arcade-protocol/contracts/RepaymentController.sol Exploit Scenario A script that is used to periodically withdraw the protocol fees (calling LoanCore.withdrawProtocolFees) is updated. Due to a mistake, the to argument is left 37 Arcade.xyz V3 Security Assessment uninitialized. The script is executed, and the to argument defaults to the zero address, causing withdrawProtocolFees to transfer the protocol fees to the zero address. Recommendations Short term, add a check to verify that to does not equal the zero address to the following functions: ● VaultFactory.claimFees ● RepaymentController.redeemNote ● LoanCore.withdraw ● LoanCore.withdrawProtocolFees Long term, use the Slither static analyzer to catch common issues such as this one. Consider integrating a Slither scan into the project’s CI pipeline, pre-commit hooks, or build scripts. 38 Arcade.xyz V3 Security Assessment 
9. The maximum value for FL_09 is not set by FeeController Severity: Low Diﬃculty: High Type: Data Validation Finding ID: TOB-ARCADE-9 Target: contracts/FeeController.sol Description The FeeController constructor initializes all of the maximum values for the fees deﬁned in the FeeLookups contract except for FL_09 (LENDER_REDEEM_FEE). Because the maximum value is not set, it is possible to set any amount, with no upper bound, for that particular fee. The lender's redeem fee is used in RepaymentController’s redeemNote function to calculate the fee paid by the lender to the protocol in order to receive their funds back. If the protocol team accidentally sets the fee to 100%, all of the users' funds to be redeemed would instead be used to pay the protocol. 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 constructor() { /// @dev Vault mint fee - gross maxFees[FL_01] = 1 ether; /// @dev Origination fees - bps maxFees[FL_02] = 10_00; maxFees[FL_03] = 10_00; /// @dev Rollover fees - bps maxFees[FL_04] = 20_00; maxFees[FL_05] = 20_00; /// @dev Loan closure fees - bps maxFees[FL_06] = 10_00; maxFees[FL_07] = 50_00; maxFees[FL_08] = 10_00; } Figure 9.1: The constructor in arcade-protocol/contracts/FeeController.sol function redeemNote(uint256 loanId, address to) external override { LoanLibrary.LoanData memory data = loanCore.getLoan(loanId); (, uint256 amountOwed) = loanCore.getNoteReceipt(loanId); 126 127 128 129 130 RC_InvalidState(data.state); 131 if (data.state != LoanLibrary.LoanState.Repaid) revert address lender = lenderNote.ownerOf(loanId); 39 Arcade.xyz V3 Security Assessment if (lender != msg.sender) revert RC_OnlyLender(lender, msg.sender); uint256 redeemFee = (amountOwed * feeController.get(FL_09)) / 132 133 134 BASIS_POINTS_DENOMINATOR; 135 136 137 } loanCore.redeemNote(loanId, redeemFee, to); Figure 9.2: The redeemNote function in arcade-protocol/contracts/RepaymentController.sol Exploit Scenario Charlie, a member of the Arcade protocol team, has access to the privileged account that can change the protocol fees. He wants to set LENDERS_REDEEM_FEE to 5%, but he accidentally types a 0 and sets it to 50%. Users can now lose half of their funds to the new protocol fee, causing distress and lack of trust in the team. Recommendations Short term, set a maximum boundary for the FL_09 fee in FeeController’s constructor. Long term, improve the test suite to ensure that all fee-changing functions test for out-of-bounds values for all fees, not just FL_02. 40 Arcade.xyz V3 Security Assessment 
10. Fees can be changed while a loan is active Severity: Low Type: Timing Diﬃculty: High Finding ID: TOB-ARCADE-10 Target: contracts/FeeController.sol Description All fees in the protocol are calculated using the current fees, as informed by the FeeController contract. However, fees can be changed by the team at any time, so the eﬀective rollover and closure fees that the users will pay can change once their loans are already initialized; therefore, these fees are impossible to know in advance. For example, in the code shown in ﬁgure 10.1, the LENDER_INTEREST_FEE and LENDER_PRINCIPAL_FEE values are read when a loan is about to be repaid, but these values can be diﬀerent from the values the user agreed to when the loan was initialized. The same can happen in OriginationController and other functions in RepaymentController. function _prepareRepay(uint256 loanId) internal view returns (uint256 LoanLibrary.LoanData memory data = loanCore.getLoan(loanId); if (data.state == LoanLibrary.LoanState.DUMMY_DO_NOT_USE) revert if (data.state != LoanLibrary.LoanState.Active) revert 149 amountFromBorrower, uint256 amountToLender) { 150 151 RC_CannotDereference(loanId); 152 RC_InvalidState(data.state); 153 154 155 156 terms.proratedInterestRate); 157 158 BASIS_POINTS_DENOMINATOR; 159 BASIS_POINTS_DENOMINATOR; 160 161 162 163 } LoanLibrary.LoanTerms memory terms = data.terms; uint256 interest = getInterestAmount(terms.principal, uint256 interestFee = (interest * feeController.get(FL_07)) / uint256 principalFee = (terms.principal * feeController.get(FL_08)) / amountFromBorrower = terms.principal + interest; amountToLender = amountFromBorrower - interestFee - principalFee; Figure 10.1: The _prepareRepay function in arcade-protocol/contracts/RepaymentController.sol 41 Arcade.xyz V3 Security Assessment Exploit Scenario Lucy, the lender, and Bob, the borrower, agree on the current loan conditions and fees at a certain point in time. Some weeks later, when the time comes to repay the loan, they learn that the protocol team decided to change the fees while their loan was active. Lucy’s earnings are now diﬀerent from what she expected. Recommendations Short term, consider storing (for example, in the LoanTerms structure) the fee values that both counterparties agree on when a loan is initialized, and use those local values for the full lifetime of the loan. Long term, document all of the conditions that are agreed on by the counterparties and that should be constant during the lifetime of the loan, and make sure they are preserved. Add a speciﬁc integration or fuzzing test for these conditions. 42 Arcade.xyz V3 Security Assessment 
11. Asset vault nesting can lead to loss of assets Severity: Low Diﬃculty: High Type: Access Controls Finding ID: TOB-ARCADE-11 Target: contracts/vault/VaultFactory.sol, contracts/vault/AssetVault.sol Description Allowing asset vaults to be nested (e.g., vault A is owned by vault B, and vault B is owned by vault X, etc.) could result in a situation in which multiple asset vaults own each other. This would result in a deadlock preventing assets in the aﬀected asset vaults from ever being withdrawn again. Asset vaults are designed to hold diﬀerent types of assets, including ERC-721 tokens. The ownership of an asset vault is tracked by an accompanying ERC-721 token that is minted (ﬁgure 11.1) when the asset vault is deployed through the VaultFactory contract. 164 (uint256) { 165 166 167 mintFee); 168 169 170 171 172 173 mintFee); 174 175 176 177 } function initializeBundle(address to) external payable override returns uint256 mintFee = feeController.get(FL_01); if (msg.value < mintFee) revert VF_InsufficientMintFee(msg.value, address vault = _create(); _mint(to, uint256(uint160(vault))); emit VaultCreated(vault, to); return uint256(uint160(vault)); if (msg.value > mintFee) payable(msg.sender).transfer(msg.value - Figure 11.1: The initializeBundle function in arcade-protocol/contracts/vault/VaultFactory.sol To add an ERC-721 asset to an asset vault, it needs to be transferred to the asset vault’s address. Because the ownership of an asset vault is tracked by an ERC-721 token, it is possible to transfer the ownership of an asset vault to another asset vault by simply transferring the ERC-721 token representing vault ownership. To withdraw ERC-721 tokens from an asset vault, the owner (the holder of the asset vault’s ERC-721 token) needs to 43 Arcade.xyz V3 Security Assessment enable withdrawals (using the enableWithdraw function) and then call the withdrawERC721 (or withdrawBatch) function. 121 122 123 124 150 151 152 153 154 155 156 function enableWithdraw() external override onlyOwner onlyWithdrawDisabled { withdrawEnabled = true; emit WithdrawEnabled(msg.sender); } Figure 11.2: The enableWithdraw function in arcade-protocol/contracts/vault/AssetVault.sol function withdrawERC721( address token, uint256 tokenId, address to ) external override onlyOwner onlyWithdrawEnabled { _withdrawERC721(token, tokenId, to); } Figure 11.3: The withdrawERC721 function in arcade-protocol/contracts/vault/AssetVault.sol Only the owner of an asset vault can enable and perform withdrawals. Therefore, if two (or more) vaults own each other, it would be impossible for a user to enable or perform withdrawals on the aﬀected vaults, permanently locking all assets (ERC-721, ERC-1155, ERC-20, ETH) within them. The severity of the issue depends on the UI, which was out of scope for this review. If the UI does not prevent vaults from owning each other, the severity of this issue is higher. In terms of likelihood, this issue would require a user to make a mistake (although a mistake that is far more likely than the transfer of tokens to a random address) and would require the UI to fail to detect and prevent or warn the user from making such a mistake. We therefore rated the diﬃculty of this issue as high. Exploit Scenario Alice decides to borrow USDC by putting up some of her NFTs as collateral: 
1. Alice uses the UI to create an asset vault (vault A) and transfers ﬁve of her CryptoPunks to the asset vault. 
2. The UI shows that Alice has another existing vault (vault X), which contains two Bored Apes. She wants to use these two vaults together to borrow a higher amount of USDC. She clicks on vault A and selects the “Add Asset” option. 
3. The UI shows a list of assets that Alice owns, including the ERC-721 token that represents ownership of vault X. Alice clicks on “Add”, the transaction succeeds, and the vault X NFT is transferred to vault A. Vault X is now owned by vault A. 44 Arcade.xyz V3 Security Assessment 
4. Alice decides to add another Bored Ape NFT that she owns to vault X. She opens the vault X page and clicks on “Add Assets”, and the list of assets that she can add shows the ERC-721 token that represents ownership of vault A. 
5. Alice is confused and wonders if adding vault X to vault A worked (step 3). She decides to add vault A to vault X instead. The transaction succeeds, and now vault A owns vault X and vice versa. Alice is now unable to withdraw any of the assets from either vault. Recommendations Short term, take one of the following actions: ● Disallow the nesting of asset vaults. That is, prevent users from being able to transfer ownership of an asset vault to another asset vault. This would prevent the issue altogether. ● If allowing asset vaults to be nested is a desired feature, update the UI to prevent two or more asset vaults from owning each other (if it does not already do so). Also, update the documentation so that other integrating smart contract protocols are aware of the issue. Long term, when dealing with the nesting of assets, consider edge cases and write extensive tests that ensure these edge cases are handled correctly and that users do not lose access to their assets. Other than unit tests, we recommend writing invariants and testing them using property-based testing with Echidna. 45 Arcade.xyz V3 Security Assessment 
12. Risk of locked assets due to use of _mint instead of _safeMint Severity: Medium Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-ARCADE-12 Target: contracts/vault/VaultFactory.sol, contracts/PromissoryNote.sol Description The asset vault and promissory note ERC-721 tokens are minted via the _mint function rather than the _safeMint function. The _safeMint function includes a necessary safety check that validates a recipient contract’s ability to receive and handle ERC-721 tokens. Without this safeguard, tokens can inadvertently be sent to an incompatible contract, causing them, and any assets they hold, to become irretrievable. 164 (uint256) { 165 166 167 mintFee); 168 169 170 171 172 173 mintFee); 174 175 176 177 } function initializeBundle(address to) external payable override returns uint256 mintFee = feeController.get(FL_01); if (msg.value < mintFee) revert VF_InsufficientMintFee(msg.value, address vault = _create(); _mint(to, uint256(uint160(vault))); emit VaultCreated(vault, to); return uint256(uint160(vault)); if (msg.value > mintFee) payable(msg.sender).transfer(msg.value - Figure 12.1: The initializeBundle function in arcade-protocol/contracts/vault/VaultFactory.sol function mint(address to, uint256 loanId) external override returns (uint256) if (!hasRole(MINT_BURN_ROLE, msg.sender)) revert 135 { 136 PN_MintingRole(msg.sender); 137 138 139 140 return loanId; _mint(to, loanId); } Figure 12.2: The mint function in arcade-protocol/contracts/PromissoryNote.sol 46 Arcade.xyz V3 Security Assessment The _safeMint function’s built-in safety check ensures that the recipient contract has the necessary ERC721Receiver implementation, verifying the contract’s ability to receive and manage ERC-721 tokens. 258 259 260 261 262 263 264 265 266 267 268 function _safeMint( address to, uint256 tokenId, bytes memory _data ) internal virtual { _mint(to, tokenId); require( _checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer" ); } Figure 12.3: The _safeMint function in openzeppelin-contracts/contracts/token/ERC721/ERC721.sol The _checkOnERC721Received method invokes the onERC721Received method on the receiving contract, expecting a return value containing the bytes4 selector of the onERC721Received method. A successful pass of this check implies that the contract is indeed capable of receiving and processing ERC-721 tokens. The _safeMint function does allow for reentrancy through the calling of _checkOnERC721Received on the receiver of the token. However, based on the order of operations in the aﬀected functions in Arcade (ﬁgures 12.1 and 12.2), this poses no risk. Exploit Scenario Alice initializes a new asset vault by invoking the initializeBundle function of the VaultFactory contract, passing in her smart contract wallet address as the to argument. She transfers her valuable CryptoPunks NFT, intended to be used for collateral, to the newly created asset vault. However, she later discovers that her smart contract wallet lacks support for ERC-721 tokens. As a result, both her asset vault token and the CryptoPunks NFT become irretrievable, stuck within her smart wallet contract due to the absence of a mechanism to handle ERC-721 tokens. Recommendations Short term, use the _safeMint function instead of _mint in the PromissoryNote and VaultFactory contracts. The _safeMint function includes vital checks that ensure the recipient is equipped to handle ERC-721 tokens, thus mitigating the risk that NFTs could become frozen. Long term, enhance the unit testing suite. These tests should encompass more negative paths and potential edge cases, which will help uncover any hidden vulnerabilities or bugs like this one. Additionally, it is critical to test user-provided inputs extensively, covering a 47 Arcade.xyz V3 Security Assessment broad spectrum of potential scenarios. This rigorous testing will contribute to building a more secure, robust, and reliable system. 48 Arcade.xyz V3 Security Assessment 
13. Borrowers cannot realize full loan value without risking default Severity: Medium Diﬃculty: Low Type: Timing Finding ID: TOB-ARCADE-13 Target: contracts/LoanCore.sol Description To fully capitalize on their loans, borrowers need to retain their loaned assets and the owed interest for the entire term of their loans. However, if a borrower waits until the loan’s maturity date to repay it, they become immediately vulnerable to liquidation of their collateral by the lender. As soon as the block.timestamp value exceeds the dueDate value, a lender can invoke the claim function to liquidate the borrower’s collateral. 293 294 295 // First check if the call is being made after the due date. uint256 dueDate = data.startDate + data.terms.durationSecs; if (dueDate >= block.timestamp) revert LC_NotExpired(dueDate); Figure 13.1: A snippet of the claim function in arcade-protocol/contracts/LoanCore.sol Owing to the inherent nature of the blockchain, achieving precise synchronization between the block.timestamp and the dueDate is practically impossible. Moreover, repaying a loan before the dueDate would result in a loss of some of the loan’s inherent value because the protocol’s interest assessment design does not refund any part of the interest for early repayment. In a scenario in which block.timestamp is greater than dueDate, a lender can preempt a borrower’s loan repayment attempt, invoke the claim function, and liquidate the borrower’s collateral. Frequently, collateral will be worth more than the loaned assets, giving lenders an incentive to do this. Given the protocol’s interest assessment design, the Arcade team should implement a grace period following the maturity date where no additional interest is expected to be assessed beyond the period agreed to in the loan terms. This buﬀer would give the borrower an opportunity to fully capitalize on the term of their loan without the risk of defaulting and losing their collateral. 49 Arcade.xyz V3 Security Assessment Exploit Scenario Alice, a borrower, takes out a loan from Eve using Arcade’s NFT lending protocol. Alice deposits her rare CryptoPunk as collateral, which is more valuable than the assets loaned to her, so that her position is over-collateralized. Alice plans to hold on to the lent assets for the entire duration of the loan period in order to maximize her beneﬁt-to-cost ratio. Eve, the lender, is monitoring the blockchain for the moment when the block.timestamp is greater than or equal to the dueDate so that she can call the claim function and liquidate Alice’s CryptoPunk. As soon as the loan term is up, Alice submits a transaction to the repay function, and Eve front-runs that transaction with her own call to the claim function. As a result, Eve is able to liquidate Alice’s CryptoPunk collateral. Recommendations Short term, introduce a grace period after the loan's maturity date during which the lender cannot invoke the claim function. This buﬀer would give the borrower suﬃcient time to repay the loan without the risk of immediate collateral liquidation. Long term, revise the protocol's interest assessment design to allow a portion of the interest to be refunded in cases of early repayment. This change could reduce the incentive for borrowers to delay repayment until the last possible moment. Additionally, provide better education for borrowers on how the lending protocol works, particularly around critical dates and actions, and improve communication channels for borrowers to raise concerns or seek clariﬁcation. 50 Arcade.xyz V3 Security Assessment 
14. itemPredicates encoded incorrectly according to EIP-712 Severity: Low Diﬃculty: Low Type: Conﬁguration Finding ID: TOB-ARCADE-14 Target: contracts/OriginationController.sol Description The itemPredicates parameter is not encoded correctly, so the signer cannot see the veriﬁer address when signing. The veriﬁer address receives each batch of listed assets to check them for correctness and existence, which is vital to ensuring the security and integrity of the lending transaction. According to EIP-712, structured data should be hashed in conjunction with its typeHash. The following is the hashStruct function as deﬁned in EIP-712: hashStruct(s : 𝕊) = keccak256(typeHash ‖ encodeData(s)) where typeHash = keccak256(encodeType(typeOf(s))) In the protocol, the recoverItemsSignature function hashes an array of Predicate[] structs that are passed in as the itemPredicates argument. The function encodes and hashes the array without adding the Predicate typeHash to each member of the array. The hashed output of that operation is then included in the _ITEMS_TYPEHASH variable as a bytes32 type, referred to as itemsHash. 208 209 210 211 212 213 214 (bytes32 sighash, address externalSigner) = recoverItemsSignature( loanTerms, sig, nonce, neededSide, keccak256(abi.encode(itemPredicates)) ); Figure 14.1: A snippet of the initializeLoanWithItems function in arcade-protocol/contracts/OriginationController.sol keccak256( bytes32 private constant _ITEMS_TYPEHASH = 85 86 87 88 proratedInterestRate,uint256 principal,address collateralAddress,bytes32 itemsHash,address payableCurrency,bytes32 affiliateCode,uint160 nonce,uint8 side)" 89 // solhint-disable max-line-length "LoanTermsWithItems(uint32 durationSecs,uint32 deadline,uint160 ); 51 Arcade.xyz V3 Security Assessment Figure 14.2: The _ITEMS_TYPEHASH variable in arcade-protocol/contracts/OriginationController.sol However, this method of encoding an array of structs is not consistent with the EIP-712 guidelines, which stipulates the following: “The array values are encoded as the keccak256 hash of the concatenated encodeData of their contents (i.e., the encoding of SomeType[5] is identical to that of a struct containing ﬁve members of type SomeType). The struct values are encoded recursively as hashStruct(value). This is undeﬁned for cyclical data.” Therefore, the protocol should iterate over the itemPredicates array, encoding each Predicate instance separately with its respective typeHash. Exploit Scenario Alice creates a loan oﬀering that takes CryptoPunks as collateral. She submits the loan terms to the Arcade protocol. Bob, a CryptoPunk holder, navigates the Arcade UI to accept Alice’s loan terms. An EIP-712 signature request appears in MetaMask for Bob to sign. Bob cannot validate whether the message he is signing uses the CryptoPunk veriﬁer contract because that information is not included in the hash. Recommendations Short term, adjust the encoding of itemPredicates to comply with EIP-712 standards. Have the code iterate through the itemPredicates array and encode each Predicate instance separately with its associated typeHash. Additionally, refactor the _ITEMS_TYPEHASH variable so that the Predicate typeHash deﬁnition is appended to it and replace the bytes32 itemsHash parameter with Predicate[] items. This revision will allow the signer to see the veriﬁer address of the message they are signing, ensuring the validity of each batch of items, in addition to complying with the EIP-712 standard. Long term, strictly adhere to established Ethereum protocols such as EIP-712. These standards exist to ensure interoperability, security, and predictable behavior in the Ethereum ecosystem. Violating these norms can lead to unforeseen security vulnerabilities. 52 Arcade.xyz V3 Security Assessment 
15. The fee values can distort the incentives for the borrowers and lenders Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-ARCADE-15 Target: contracts/FeeController.sol Description Arcade V3 contains nine fee settings. Six of these fees are to be paid by the lender, two are to be paid by the borrower, and the remaining fee is to be paid by the borrower if they decide to mint a new vault for their collateral. Depending on the values of these settings, the incentives can change for both loan counterparties. For example, to create a new loan, both the borrower and lender have to pay origination fees, and eventually, the loan must be rolled over, repaid, or defaulted. In the ﬁrst case, both the new lender and borrower pay rollover fees; note that the original lender pays no fees at all for closing the loan. In the second case, the lender pays interest fees and principal fees on closing the loan. Finally, if the loan is defaulted, the lender pays a default fee to liquidate the collateral. The various fees paid based on the outcome of the loan can result in an interesting incentive game for investors in the protocol, depending on the actual values of the fee settings. If the lender rollover fee is cheaper than the origination fee, investors may be incentivized to roll over existing loans instead of creating new ones, beneﬁting the original lenders by saving them the closing fees, and harming the borrowers by indirectly raising the interest rates to compensate. Similarly, if the lender rollover fees are higher than the closing fees, lenders will be less incentivized to rollover loans. In summary, having such ﬁne control over possible fee settings introduces hard-to-predict incentives scenarios that can scare users away or cause users who do not account for fees to inadvertently lose proﬁts. Recommendations Short term, clearly inform borrowers and lenders of all of the existing fees and their current values at the moment a loan is opened, as well as the various possible outcomes, including the expected net proﬁts if the loan is repaid, rolled over, defaulted, or redeemed. Long term, add interactive ways for users to calculate their expected proﬁts, such as a loan simulator. 53 Arcade.xyz V3 Security Assessment 
16. Malicious borrowers can use forceRepay to grief lenders Severity: Medium Diﬃculty: Low Type: Data Validation Finding ID: TOB-ARCADE-16 Target: contracts/RepaymentController.sol Description A malicious borrower can grief a lender by calling the forceRepay function instead of the repay function; doing so would allow the borrower to pay less in gas fees and require the lender to perform a separate transaction to retrieve their funds (using the redeemNote function) and to pay a redeem fee. At any time after the loan is set and before the lender claims the collateral if the loan is past its due date, the borrower has to pay their full debt back in order to recover their assets. For doing so, there are two functions in RepaymentController: repay and forceRepay. The diﬀerence between them is that the latter transfers the tokens to the LoanCore contract instead of directly to the lender. It is meant to allow the borrower to pay their obligations when the lender cannot receive tokens for any reason. For the lender to get their tokens back in this scenario, they must call the redeemNote function in RepaymentController, which in turn calls LoanCore.redeemNote, which transfers the tokens to an address set by the lender in the call. Because the borrower is free to decide which function to call to repay their debt, they can arbitrarily decide to do so via forceRepay, obligating the lender to send a transaction (with its associated gas fees) to recover their tokens. Additionally, depending on the conﬁguration of the protocol, it is possible that the lender has to pay an additional fee (LENDER_REDEEM_FEE) to get back their own tokens, cutting their proﬁts with no chance to opt out. 126 127 128 129 130 RC_InvalidState(data.state); 131 132 133 134 BASIS_POINTS_DENOMINATOR; function redeemNote(uint256 loanId, address to) external override { LoanLibrary.LoanData memory data = loanCore.getLoan(loanId); (, uint256 amountOwed) = loanCore.getNoteReceipt(loanId); if (data.state != LoanLibrary.LoanState.Repaid) revert address lender = lenderNote.ownerOf(loanId); if (lender != msg.sender) revert RC_OnlyLender(lender, msg.sender); uint256 redeemFee = (amountOwed * feeController.get(FL_09)) / 54 Arcade.xyz V3 Security Assessment 135 136 137 } loanCore.redeemNote(loanId, redeemFee, to); Figure 16.1: The redeemNote function in arcade-protocol/contracts/RepaymentController.sol Note that, from the perspective of the borrower, it is actually cheaper to call forceRepay than repay because of the gas saved by not transferring the tokens to the lender and not burning one of the promissory notes. Exploit Scenario Bob has to pay back his loan, and he decides to do so via forceRepay to save gas in the transaction. Lucy, the lender, wants her tokens back. She is now forced to call redeemNote to get them. In this transaction, she lost the gas fees that the borrower would have paid to send the tokens directly to her, and she has to pay an additional fee (LENDER_REDEEMER_FEE), causing her to receive less value from the loan than she originally expected. Recommendations Short term, remove the incentive (the lower gas cost) for the borrower to call forceRepay instead of repay. Consider taking one of the following actions: ● Force the lender to always pull their funds using the redeemNote function. This can be achieved by removing the repay function and requiring the borrower to call forceRepay. ● Remove the forceRepay function and modify the repay function so that it transfers the funds to the lender in a try/catch statement and creates a redeem note (which the lender can exchange for their funds using the redeemNote function) only if that transfer fails. Long term, when designing a smart contract protocol, always consider the incentives for each party to perform actions in the protocol, and avoid making an actor pay for the mistakes or maliciousness of others. By thoroughly documenting the incentives structure, ﬂaws can be spotted and mitigated before the protocol goes live. 55 Arcade.xyz V3 Security Assessment A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diﬃculty levels used in this document. Vulnerability Categories Category Description Access Controls Insuﬃcient authorization or assessment of rights Auditing and Logging Insuﬃcient auditing of actions or logging of problems Authentication Improper identiﬁcation of users Conﬁguration Misconﬁgured servers, devices, or software components Cryptography A breach of system conﬁdentiality or integrity Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service A system failure with an availability impact Error Reporting Insecure or insuﬃcient reporting of error conditions Patching Use of an outdated software package or library Session Management Improper identiﬁcation of authenticated users Testing Timing Insuﬃcient test methodology or test coverage Race conditions or other order-of-operations ﬂaws Undeﬁned Behavior Undeﬁned behavior triggered within the system 56 Arcade.xyz V3 Security Assessment Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices. Undetermined The extent of the risk was not determined during this engagement. Low The risk is small or is not one the client has indicated is important. Medium High User information is at risk; exploitation could pose reputational, legal, or moderate ﬁnancial risks. The ﬂaw could aﬀect numerous users and have serious reputational, legal, or ﬁnancial implications. Diﬃculty Levels Diﬃculty Description Undetermined The diﬃculty of exploitation was not determined during this engagement. Low Medium High The ﬂaw is well known; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of the system. An attacker must have privileged access to the system, may need to know complex technical details, or must discover other weaknesses to exploit this issue. 57 Arcade.xyz V3 Security Assessment B. Code Maturity Categories The following tables describe the code maturity categories and rating criteria used in this document. Code Maturity Categories Category Description Arithmetic The proper use of mathematical operations and semantics Auditing The use of event auditing and logging to support monitoring Authentication / Access Controls The use of robust access controls to handle identiﬁcation and authorization and to ensure safe interactions with the system Complexity Management The presence of clear structures designed to manage system complexity, including the separation of system logic into clearly deﬁned functions Decentralization The presence of a decentralized governance structure for mitigating insider threats and managing risks posed by contract upgrades Documentation The presence of comprehensive and readable codebase documentation Transaction Ordering Risks Low-Level Manipulation Testing and Veriﬁcation Rating Criteria Rating Strong The system’s resistance to front-running attacks The justiﬁed use of inline assembly and low-level calls The presence of robust testing procedures (e.g., unit tests, integration tests, and veriﬁcation methods) and suﬃcient test coverage Description No issues were found, and the system exceeds industry standards. Satisfactory Minor issues were found, but the system is compliant with best practices. Moderate Some issues that may aﬀect system safety were found. Weak Many issues that aﬀect system safety were found. Missing A required component is missing, signiﬁcantly aﬀecting system safety. 58 Arcade.xyz V3 Security Assessment Not Applicable The category is not applicable to this review. Not Considered The category was not considered in this review. Further Investigation Required Further investigation is required to reach a meaningful conclusion. 59 Arcade.xyz V3 Security Assessment C. Code Quality Recommendations The following recommendations are not associated with speciﬁc vulnerabilities. However, they enhance code readability and may prevent the introduction of vulnerabilities in the future. ● Make fee names more explicit and add getters for each fee. The names used for the various fee values (e.g., FL_0x) do not clearly describe the fees. Readers of the code will have to navigate between the current contract and the FeeLookups contract to determine the type of each fee. Additionally, adding custom getter functions to the FeeController contract (e.g., getLenderFee()) can simplify the system by allowing FeeLookups to be removed from the inheritance chain of the OriginationController, RepaymentController, and VaultFactory contracts. ● Ensure that veriﬁers follow the provided documentation. According to the _runPredicatesCheck() NatSpec documentation, the function reverts if a veriﬁer returns false. However, some of the implemented veriﬁers can return true or false or instead revert. Even though this discrepancy has no direct impact on the system, an external entity interacting with Arcade may be confused by getting an IV_xxx error when they expected an OC_PredicateFailed error. ● Ensure that structure names are unique throughout the system. There are two structures named SignatureItem: one in ArtBlocksVerifier and the other in ItemsVerifier. Even though they are deﬁned in diﬀerent namespaces, it can be confusing to identify them because they have diﬀerent members. Moreover, in the provided test suite, they are referred to as ArtBlocksItem and SignatureItem, respectively, making it more confusing for readers. ● Use automatically generated getters for public variables. OriginationController deﬁnes the mappings allowedVerifiers, allowedCurrencies, and allowedCollateral as public. The Solidity compiler automatically adds getters for these variables, but manual getters were added by the team (isAllowedVerifier, isAllowedCurrency, and isAllowedCollateral) with no additional functionality from the default getters. ● Ensure that comments in the code reﬂect the code’s intended behavior. Here are two examples of oﬀ-by-one comments in OriginationController: OriginationController.sol#L669 and OriginationController.sol#L673. ● Ensure that contract names match their ﬁlenames. The verifiers/ItemsVerifier.sol ﬁle contains the ArcadeItemsVerifier contract. 60 Arcade.xyz V3 Security Assessment ● Remove variables that are never used or are used only once. For example, id in ArcadeItemsVerifier.verifyPredicates() is used only once in the function body. ● Avoid redeﬁning constants. FL_01 in FeeLookups was redeﬁned in VaultFactory. ● Remove unneeded or unreachable code. For example, the else condition in the ArcadeItemsVerifier.verifyPredicates function can never be reached because abi.decode will revert for incorrect CollateralType enum values. 61 Arcade.xyz V3 Security Assessment D. Risks with Approving NFTs for Use as Collateral The Arcade protocol aims to whitelist NFT contracts to be used as collateral to back loans. These NFTs could introduce problems that could allow attackers to steal funds or otherwise impede the correct functioning of the system. We recommend that the Arcade team exercise caution in approving NFTs for use as collateral to ensure that the system keeps working correctly and that no user loses access to funds. Follow these guidelines when considering which NFTs to approve: ● Tokens should never be upgradeable. Upgradeable ERC-721 tokens can introduce substantial risks when used as collateral in an NFT lending protocol. Therefore, smart contract developers should either prevent upgradeable tokens from being used as collateral or implement robust safeguards against the associated risks. Some of these risks include the following: ○ Unpredictable token logic changes: Because the contract owner or a designated admin can alter the logic of an upgradeable token, the token’s behavior could change unpredictably during the loan period. This could aﬀect the value of the collateral, render it worthless, or prevent its return. ○ Centralization and minimized trust: Upgradeable contracts introduce an element of centralization, as the power to upgrade the contract typically lies with a speciﬁc address or addresses. This could be a risk in a decentralized environment, where the ethos is to minimize trust in individual parties. The contract's owner could, maliciously or unintentionally, make an upgrade that jeopardizes the token's role as collateral. ○ Complexity and potential bugs: Upgradeable contracts are more complex than their non-upgradeable counterparts. This added complexity increases the risk of bugs and vulnerabilities, which could be exploited to the detriment of Arcade’s lending protocol and its users. ● Tokens should not have a self-destruct capability. The self-destruct function allows a contract to be destroyed by its owner, which essentially removes the contract's bytecode from the Ethereum blockchain, making it nonfunctional. Here are some of the risks of using self-destructible tokens as collateral: ○ Total loss of collateral: If an ERC-721 token used as collateral has a self-destruct function and that function is invoked during the loan's lifecycle, the token will be rendered worthless. The borrower could default on their loan and the lender would not be able to claim the collateral, leading to a complete loss. 62 Arcade.xyz V3 Security Assessment ○ Damage to the integrity of Arcade’s lending protocol: Such tokens can undermine the integrity of the lending protocol. Lenders will be unwilling to participate if they believe that the collateral could self-destruct, making it harder for the protocol to attract and retain users. ○ Lack of recourse: In traditional ﬁnance, there are legal protections to prevent the destruction of assets used as collateral. In contrast, in the blockchain world, there is no way to recover a contract once it has self-destructed, making it a signiﬁcant risk for lenders. ● Tokens should not be pausable. A "pause" function, when present in a smart contract, allows certain privileged accounts such as contract owners and administrators to stop speciﬁc activities such as token transfers for a period of time. Although this functionality can be useful for halting activities in case of a detected vulnerability or bug, it can pose signiﬁcant risks to an NFT lending protocol, such as the following: ○ Possible prevention of repayment and collateral retrieval: If a token used as collateral is paused, that token cannot be transferred. This means that a borrower could not repay their loan and retrieve their collateral, and similarly, a lender could not claim the collateral if the loan defaults. ○ Market manipulation: In a worst-case scenario, a malicious token owner could strategically pause and unpause a token, disrupting the market and possibly manipulating the token’s value. ● Tokens should not be burnable by some authorized third-party. Tokens that can be burned by a third-party or token admin should not be permitted as collateral in an NFT lending protocol. “Burning” is a process by which tokens are permanently removed from circulation, thereby reducing the total supply of tokens. Although this feature can be useful in certain contexts, it can introduce the following risks when used in an NFT lending protocol: ○ Total loss of collateral: If the token used as collateral can be burned by an admin or third party, it could be burned during the duration of the loan, which would leave the lender unprotected in the case of a default. ○ Loan-to-value manipulation: Those with the ability to burn tokens could engage in manipulative behaviors that disrupt the loan-to-value ratio, such as artiﬁcially inﬂuencing a token’s scarcity and thereby its market value, thus leading to over-collateralization or under-collateralization. ● Tokens should not hold or have access to other assets. Tokens can be structured to hold or interact with other assets on the blockchain. An ERC-721 token can be a 63 Arcade.xyz V3 Security Assessment "wrapper" for speciﬁc ERC-20 tokens, generate yields from a DeFi protocol, or represent in-game characters with their own assets. Using them as collateral in lending protocol comes with the following risks: ○ Value ﬂuctuation: If the token holds or has access to other assets, its value can change during the loan period if the value of the underlying assets changes. If a collateral changes value, it may no longer cover the value of the loan, creating signiﬁcant risk for the lender. ○ Asset removal or addition: If the token allows assets to be added to or removed from it, the value of the collateral could be altered during the life cycle of the loan. A borrower or a third party could remove assets from the collateral, decreasing the collateral’s value; the lender and the protocol would have no means to prevent this. ○ Valuation complexity: Valuing tokens that hold other assets is more complex than valuing simpler tokens. Some assets are interest bearing, some undergo rebasing, and most are traded on public markets. The complexities involved in accurately determining the value of such tokens introduces additional risks and complexities for the lender, the borrower, and the protocol in general. ● Gaming tokens with alterable intrinsic value should be avoided. Tokens are often used to represent unique digital assets in gaming environments, such as characters, equipment, and virtual real estate. Using them as collateral in a lending protocol carries some risks, such as the following: ○ Developer control: Game developers often maintain a degree of control over in-game assets, which may include the ability to create, modify, or destroy assets. If a game developer decides to ﬂood the market with copies of a previously rare asset, or alter its capabilities within the game, the value of the collateral could be signiﬁcantly aﬀected. ○ In-game rules and actions: In-game actions by other players or changes to in-game rules can inﬂuence the value of the token. For instance, if the game involves player competition, other players’ actions could diminish the value of the collateral token. 64 Arcade.xyz V3 Security Assessment E. Token Integration Checklist The following checklist provides recommendations for interactions with arbitrary tokens. Every unchecked item should be justiﬁed, and its associated risks, understood. For an up-to-date version of the checklist, see crytic/building-secure-contracts. For convenience, all Slither utilities can be run directly on a token address, such as the following: slither-check-erc 0xdac17f958d2ee523a2206206994597c13d831ec7 TetherToken --erc erc20 slither-check-erc 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d KittyCore --erc erc721 To follow this checklist, use the below output from Slither for the token: slither-check-erc [target] [contractName] [optional: --erc ERC_NUMBER] slither [target] --print human-summary slither [target] --print contract-summary slither-prop . --contract ContractName # requires configuration, and use of Echidna and Manticore General Considerations ❏ The contract has a security review. Avoid interacting with contracts that lack a security review. Check the length of the assessment (i.e., the level of eﬀort), the reputation of the security ﬁrm, and the number and severity of the ﬁndings. ❏ You have contacted the developers. You may need to alert their team to an incident. Look for appropriate contacts on blockchain-security-contacts. ❏ They have a security mailing list for critical announcements. Their team should advise users (like you!) when critical issues are found or when upgrades occur. Contract Composition ❏ The contract avoids unnecessary complexity. The token should be a simple contract; a token with complex code requires a higher standard of review. Use Slither’s human-summary printer to identify complex code. ❏ The contract uses SafeMath. Contracts that do not use SafeMath require a higher standard of review. Inspect the contract by hand for SafeMath usage. ❏ The contract has only a few non-token-related functions. Non-token-related functions increase the likelihood of an issue in the contract. Use Slither’s contract-summary printer to broadly review the code used in the contract. 65 Arcade.xyz V3 Security Assessment ❏ The token has only one address. Tokens with multiple entry points for balance updates can break internal bookkeeping based on the address (e.g., balances[token_address][msg.sender] may not reﬂect the actual balance). Owner Privileges ❏ The token is not upgradeable. Upgradeable contracts may change their rules over time. Use Slither’s human-summary printer to determine whether the contract is upgradeable. ❏ The owner has limited minting capabilities. Malicious or compromised owners can abuse minting capabilities. Use Slither’s human-summary printer to review minting capabilities, and consider manually reviewing the code. ❏ The token is not pausable. Malicious or compromised owners can trap contracts relying on pausable tokens. Identify pausable code by hand. ❏ The owner cannot blacklist the contract. Malicious or compromised owners can trap contracts relying on tokens with a blacklist. Identify blacklisting features by hand. ❏ The team behind the token is known and can be held responsible for abuse. Contracts with anonymous development teams or teams that reside in legal shelters require a higher standard of review. ERC20 Tokens ERC20 Conformity Checks Slither includes a utility, slither-check-erc, that reviews the conformance of a token to many related ERC standards. Use slither-check-erc to review the following: ❏ Transfer and transferFrom return a boolean. Several tokens do not return a boolean on these functions. As a result, their calls in the contract might fail. ❏ The name, decimals, and symbol functions are present if used. These functions are optional in the ERC20 standard and may not be present. ❏ Decimals returns a uint8. Several tokens incorrectly return a uint256. In such cases, ensure that the value returned is below 255. ❏ The token mitigates the known ERC20 race condition. The ERC20 standard has a known ERC20 race condition that must be mitigated to prevent attackers from stealing tokens. Slither includes a utility, slither-prop, that generates unit tests and security properties that can discover many common ERC ﬂaws. Use slither-prop to review the following: 66 Arcade.xyz V3 Security Assessment ❏ The contract passes all unit tests and security properties from slither-prop. Run the generated unit tests and then check the properties with Echidna and Manticore. Risks of ERC20 Extensions The behavior of certain contracts may diﬀer from the original ERC speciﬁcation. Conduct a manual review of the following conditions: ❏ The token is not an ERC777 token and has no external function call in transfer or transferFrom. External calls in the transfer functions can lead to reentrancies. ❏ Transfer and transferFrom should not take a fee. Deﬂationary tokens can lead to unexpected behavior. ❏ Potential interest earned from the token is taken into account. Some tokens distribute interest to token holders. This interest may be trapped in the contract if not taken into account. Token Scarcity Reviews of token scarcity issues must be executed manually. Check for the following conditions: ❏ The supply is owned by more than a few users. If a few users own most of the tokens, they can inﬂuence operations based on the tokens’ repartition. ❏ The total supply is suﬃcient. Tokens with a low total supply can be easily manipulated. ❏ The tokens are located in more than a few exchanges. If all the tokens are in one exchange, a compromise of the exchange could compromise the contract relying on the token. ❏ Users understand the risks associated with a large amount of funds or ﬂash loans. Contracts relying on the token balance must account for attackers with a large amount of funds or attacks executed through ﬂash loans. ❏ The token does not allow ﬂash minting. Flash minting can lead to substantial swings in the balance and the total supply, which necessitate strict and comprehensive overﬂow checks in the operation of the token. 67 Arcade.xyz V3 Security Assessment ERC721 Tokens ERC721 Conformity Checks The behavior of certain contracts may diﬀer from the original ERC speciﬁcation. Conduct a manual review of the following conditions: ❏ Transfers of tokens to the 0x0 address revert. Several tokens allow transfers to 0x0 and consider tokens transferred to that address to have been burned; however, the ERC721 standard requires that such transfers revert. ❏ safeTransferFrom functions are implemented with the correct signature. Several token contracts do not implement these functions. A transfer of NFTs to one of those contracts can result in a loss of assets. ❏ The name, decimals, and symbol functions are present if used. These functions are optional in the ERC721 standard and may not be present. ❏ If it is used, the decimals function returns a uint8(0). Other values are invalid. ❏ The name and symbol functions can return an empty string. This behavior is allowed by the standard. ❏ The ownerOf function reverts if the tokenId is invalid or is set to a token that has already been burned. The function cannot return 0x0. This behavior is required by the standard, but it is not always properly implemented. ❏ A transfer of an NFT clears its approvals. This is required by the standard. ❏ The token ID of an NFT cannot be changed during its lifetime. This is required by the standard. Common Risks of the ERC721 Standard To mitigate the risks associated with ERC721 contracts, conduct a manual review of the following conditions: ❏ The onERC721Received callback is taken into account. External calls in the transfer functions can lead to reentrancies, especially when the callback is not explicit (e.g., in safeMint calls). 68 Arcade.xyz V3 Security Assessment ❏ When an NFT is minted, it is safely transferred to a smart contract. If there is a minting function, it should behave similarly to safeTransferFrom and properly handle the minting of new tokens to a smart contract. This will prevent a loss of assets. ❏ The burning of a token clears its approvals. If there is a burning function, it should clear the token’s previous approvals 69 Arcade.xyz V3 Security Assessment F. Mutation Testing The goal of mutation testing is to gain insight into a codebase’s test coverage. Mutation tests go line-by-line through the target ﬁle, mutate the given line in some way, run tests, and ﬂag changes that do not trigger test failures. Depending on the complexity of the logic in any given line and the tool used to mutate, mutation tests could test upwards of 50 mutants per line of source code. Mutation testing is a slow process, but by highlighting areas of the code with incomplete test coverage, it allows auditors to focus their manual review on the parts of the code that are most likely to contain latent bugs. In this section, we provide information on available mutation testing tools that could be used in the Arcade V3 codebase, and we describe the mutation testing campaign that we conducted during this audit. The following are available mutation testing tools: ● Universalmutator: This tool generates deterministic mutants from regular expressions; it supports many source code languages, including Solidity and Vyper. Refer to the 2018 ICSE paper on the tool and this guest blog post about the tool on the blog for more information. ● Necessist: This tool was developed in-house by . It operates on tests rather than source code, although it has a similar end goal. Necessist could provide a nice complement to source-focused mutation testing. Due to the time-boxed nature of this review, we deprioritized the use of Necessist to conduct an additional mutation testing campaign. ● Vertigo: This tool was developed by security researchers at Consensys Diligence. Integration with Foundry is planned, but the current progress on that work is unclear. Known scalability issues are present in the tool. ● Gambit: This tool generates stochastic mutants by modifying the Solidity AST. It is optimized for integration with the Certora prover. We used universalmutator to conduct a mutation testing campaign during this engagement because the mutants it generates are deterministic and because it is a relatively mature tool with few known issues. This tool can be installed with the following command: pip install universalmutator Figure F.1: The command used to install universalmutator Once installed, a mutation campaign can be run against all Solidity source ﬁles using the following bash script: 70 Arcade.xyz V3 Security Assessment 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 find contracts \ -name '*.sol' \ -not -path '*/interfaces/*' \ -not -path '*/test/*' \ -not -path '*/external/*' \ -print0 | while IFS= read -r -d '' file do name="$(basename "$file" .sol)" dir="mutants/$name" mkdir -p "$dir" echo "Mutating $file" mutate "$file" \ --cmd "timeout 200s npx hardhat test" \ --mutantDir "$dir" \ > "mutants/$name.log" done Figure F.2: A bash script that runs a mutation testing campaign against each Solidity ﬁle in the contracts directory Consider the following notes about the above bash script: ● The overall runtime of the above script against all non-excluded Solidity ﬁles in the target contracts repository is approximately one week on a modern M2 Mac. This execution time is directly related to the npx hardhat test tool runtime and the number of contracts to be mutated. ● The --cmd argument on line 13 speciﬁes the command to run for each mutant. This command is preﬁxed by timeout 200s (timeout is a tool included in the coreutils package on macOS) because a healthy run of the test suite was measured to take approximately 150 seconds. A timeout longer than the average test suite runtime is used only to cut oﬀ test runs that are badly stalled. The results of each target’s mutation tests are saved in a ﬁle, per line 15 of the script in ﬁgure F.2. An illustrative example of such output is shown in ﬁgure F.3. *** UNIVERSALMUTATOR *** MUTATING WITH RULES: audit-arcade/custom-solidity.rules FAILED TO FIND RULE audit-arcade/custom-solidity.rules AS BUILT-IN... SKIPPED 458 MUTANTS ONLY CHANGING STRING LITERALS 2761 MUTANTS GENERATED BY RULES ... PROCESSING MUTANT: 121: OC_ZeroAddress(); ==> OC_ZeroAddress();...INVALID PROCESSING MUTANT: 121: OC_ZeroAddress(); ==> OC_ZeroAddress();...VALID [written to mutants/OriginationController/OriginationController.mutant.25.sol] if (_feeController == address(0)) revert if (_feeController <= address(0)) revert if (_feeController == address(0)) revert if (_feeController != address(0)) revert 71 Arcade.xyz V3 Security Assessment ) public override returns (uint256 newLoanId) { ==> ) public override returns (uint256 newLoanId) { ==> if (_feeController == address(0)) revert if (_feeController >= address(0)) revert {...INVALID PROCESSING MUTANT: 121: OC_ZeroAddress(); ==> OC_ZeroAddress();...INVALID ... PROCESSING MUTANT: 375: ) public override returns (uint256 PROCESSING MUTANT: 375: ) public override returns (uint256 newLoanId) ...INVALID PROCESSING MUTANT: 375: /*_validateLoanTerms(loanTerms);*/...VALID [written to mutants/OriginationController/OriginationController.mutant.46.sol] PROCESSING MUTANT: 375: selfdestruct(msg.sender);...INVALID PROCESSING MUTANT: 375: revert();...INVALID ... 156 VALID MUTANTS 2605 INVALID MUTANTS 0 REDUNDANT MUTANTS Valid Percentage: 5.650126765664615% _validateLoanTerms(loanTerms); ==> _validateLoanTerms(loanTerms); ==> _validateLoanTerms(loanTerms); ==> Figure F.3: Abbreviated output from the mutation testing campaign on OriginationController.sol The output of universalmutator starts with the number of mutants generated and ends with a summary of how many of these mutants are valid. A small percentage of valid mutants indicates thorough test coverage. The ﬁrst highlighted snippet in the middle of the output is focused on mutations made to line 121 of the OriginationController source code. This particular line shows a mutation with a false positive: this means that while the mutant compiles and passes all tests, the mutation does not imply failure in test coverage because the address cannot be negative. Other types of common false positives include removing the public visibility modiﬁer from variable or function declarations. However, the second highlighted snippet shows that commenting out line 375 of the OriginationController source code makes the test run succeed. Because this change can have consequences in the results of the function, this mutant is expected to be invalid given thorough test coverage. In that particular case, it means that none of the implemented tests for the OriginationController contract tries to roll over a loan with invalid loan terms. For auditors, this is a cue to take an extra close look at the implementation of this method and at its use throughout the rest of the codebase. We recommend running mutation tests on the code every time major changes are made to the code or to the test suite, and we recommend ﬁltering the results to ensure that the test coverage is correct. 72 Arcade.xyz V3 Security Assessment G. Incident Response Plan Recommendations This section provides recommendations on formulating an incident response plan. ● Identify the parties (either speciﬁc people or roles) responsible for implementing the mitigations when an issue occurs (e.g., deploying smart contracts, pausing contracts, upgrading the front end, etc.). ● Clearly describe the intended contract deployment process. ● Outline the circumstances under which the Arcade protocol will compensate users aﬀected by an issue (if any). ○ Issues that warrant compensation could include an individual or aggregate loss or a loss resulting from user error, a contract ﬂaw, or a third-party contract ﬂaw. ● Document how the team plans to stay up to date on new issues that could aﬀect the system; awareness of such issues will inform future development work and help the team secure the deployment toolchain and the external on-chain and oﬀ-chain services that the system relies on. ○ Identify sources of vulnerability news for each language and component used in the system, and subscribe to updates from each source. Consider creating a private Discord channel in which a bot will post the latest vulnerability news; this will provide the team with a way to track all updates in one place. Lastly, consider assigning certain team members to track news about vulnerabilities in speciﬁc components of the system. ● Determine when the team will seek assistance from external parties (e.g., auditors, aﬀected users, other protocol developers, etc.) and how it will onboard them. ○ Eﬀective remediation of certain issues may require collaboration with external parties. ● Deﬁne contract behavior that would be considered abnormal by oﬀ-chain monitoring solutions. It is best practice to perform periodic dry runs of scenarios outlined in the incident response plan to ﬁnd omissions and opportunities for improvement and to develop “muscle memory.” Additionally, document the frequency with which the team should perform dry runs of various scenarios, and perform dry runs of more likely scenarios more 73 Arcade.xyz V3 Security Assessment regularly. Create a template to be ﬁlled out with descriptions of any necessary improvements after each dry run. 74 Arcade.xyz V3 Security Assessment H. Fix Review Results When undertaking a ﬁx review, reviews the ﬁxes implemented for issues identiﬁed in the original report. This work involves a review of speciﬁc areas of the source code and system conﬁguration, not comprehensive analysis of the system. On July 24 to July 25, 2023, reviewed the ﬁxes and mitigations implemented by the Arcade team for the issues identiﬁed in this report. We reviewed each ﬁx to determine its eﬀectiveness in resolving the associated issue. In summary, of the 16 issues described in this report, Arcade has resolved 12 issues and has not resolved the remaining four issues. For additional information, please see the Detailed Fix Review Results below. ID Title Severity Status 1 2 3 4 5 6 7 8 Diﬀerent zero-address errors thrown by single and batch NFT withdrawal functions Informational Resolved Solidity compiler optimizations can be problematic Undetermined Unresolved callApprove does not follow approval best practices Informational Resolved Risk of confusing events due to missing checks in whitelist contracts Low Resolved Missing checks of _exists() return value Informational Resolved Incorrect deployers in integration tests Informational Resolved Risk of out-of-gas revert due to use of transfer() in claimFees Informational Resolved Risk of lost funds due to lack of zero-address check in functions Medium Resolved 75 Arcade.xyz V3 Security Assessment 9 The maximum value for FL_09 is not set by FeeController Low Resolved 10 Fees can be changed while a loan is active Low Resolved 11 Asset vault nesting can lead to loss of assets Low Unresolved 12 13 14 15 16 Risk of locked assets due to use of _mint instead of _safeMint Medium Resolved Borrowers cannot realize full loan value without risking default Medium Resolved itemPredicates encoded incorrectly according to EIP-712 Low Resolved The fee values can distort the incentives for the borrowers and lenders Informational Unresolved Malicious borrowers can use forceRepay to grief lenders Medium Unresolved Detailed Fix Review Results TOB-ARCADE-1: Diﬀerent zero-address errors thrown by single and batch NFT withdrawal functions Resolved in commits 00e8130 and 8542c46. The AV_ZeroAddress error was updated to include a string addressType argument that is used to indicate which address parameter violated a zero-address check requirement. Additional zero-address checks were added to functions in the AssetVault contract, unit tests were implemented to ensure that these checks work as expected, and the NatSpec comments were updated to reﬂect this update. TOB-ARCADE-2: Solidity compiler optimizations can be problematic Unresolved. Arcade provided the following statement about this issue: The Arcade team understands that Solidity compiler optimizations may potentially be problematic. However to remove our compiler optimization we would need to downsize four of our smart contracts in extensive ways, breaking them up into smaller contracts and considerably increasing our code footprint, introducing more complexity and possibly new risks. 76 Arcade.xyz V3 Security Assessment We elected not to do this at this time, given that the existence of a vulnerability remains undetermined. Before the next major protocol release, the Arcade team will revisit this issue. TOB-ARCADE-3: callApprove does not follow approval best practices Resolved in commits a3ce932 and 77c1db0. The AssetVault contract now includes two new functions, callIncreaseAllowance and callDecreaseAllowance, which enable safe interactions with Arcade for third-party integrations. The callApprove function was temporarily removed in commit a3ce932 but was subsequently added back in commit 77c1db0. To aid third-party integrators and test the expected functionality of the newly added functions, documentation and unit tests have been added appropriately. TOB-ARCADE-4: Risk of confusing events due to missing checks in whitelist contracts Resolved in commit 2434705. Two new error types, CW_AlreadyWhitelisted and CW_NotWhitelisted, have been added and implemented for whitelisting functions. If the address has already been added or the address targeted for removal is not found, the whitelisting functions will now revert. NatSpec comments have been added to describe each error, and unit tests have been included to test the add and remove functions for the expected revert. TOB-ARCADE-5: Missing checks of _exists() return value Resolved in commit e04502b. New reasons for DoesNotExist reverts were added to the Lending and Vault contracts. The VaultFactory and PromissoryNote contracts now use these revert reasons in the tokenURI functions when the requested tokenId is nonexistent. Additionally, new tests were implemented for VaultFactory and PromissoryNote that check for the expected revert reason when a nonexistent tokenId is used. TOB-ARCADE-6: Incorrect deployers in integration tests Resolved in commit dddc905. The incorrect deployers in integration test cases were changed from signers[0] to admin. A new test was implemented to check that the correct permissions are set when the protocol is deployed. TOB-ARCADE-7: Risk of out-of-gas revert due to use of transfer() in claimFees Resolved in commit a948cfc. Comments were added to inform users and developers about the issue, but no further changes were made to the contract. TOB-ARCADE-8: Risk of lost funds due to lack of zero-address check in functions Resolved in commit a6dbd53. Existing error types related to ZeroAddress were modiﬁed to include a string parameter indicating the address that failed the zero-address check (also refer to the ﬁx status for issue TOB-ARCADE-1). The uses of the old error type with no arguments were replaced with the new version. 77 Arcade.xyz V3 Security Assessment New zero-address checks for the token and destination addresses were implemented in the LoanCore.withdraw and LoanCore.withdrawProtocolFees functions. Checks for the destination address were added to the RepaymentController.redeemNote and VaultFactory.claimFees functions. Existing tests were modiﬁed to account for the new string parameter in error types, and new tests were implemented for zero-address parameters in the ﬁxed functions. TOB-ARCADE-9: The maximum value for FL_09 is not set by FeeController Resolved in commit a51dfd8. The value of maxFees[FL_09] is now set properly in the constructor of the FeeController contract. The unit test suite has also been expanded to include tests that ensure that all maximum fee values are properly set. TOB-ARCADE-10: Fees can be changed while a loan is active Resolved in commit f7b87a7. The ﬁx implemented for this issue consists of several parts. Fee names were changed. Previously, the FeeLookups constants ranged from FL_01 to FL_09, where FL_01 was the vault minting fee and FL_02 to FL_09 were the diﬀerent fees that the borrowers and lenders should pay for a loan. The Arcade team renamed FL_02 through FL_09 to FL_01 through FL_08 and removed the former FL_01 from FeeLookups and replaced it with vaultMintFee in FeeController. The functions for setting and getting the fees were renamed to setLendingFee and getLendingFee, respectively. The new getFeesOrigination and getFeesRollover functions were added to simplify the process of retrieving the fees for the loan origination and rollover processes. A new FeeSnapshot structure was created to take a snapshot of the fee values at the moment a loan is originated to ensure that future changes to fees do not aﬀect existing loans. However, only the values for the default, interest, and principal fees (fees FL_05 through FL_07) are stored, and the redeem fee (FL_08) is read from feeController at the moment of redeeming. Even though this feels counterintuitive, it is consistent with the statement given by Arcade for the ﬁx status of ﬁnding TOB-ARCADE-16; having the redeem fee read from feeController allows protocol admins to change the fee to prevent grieﬁng. Existing tests were modiﬁed to comply with the new changes. New tests were added in RepaymentController and feeController. TOB-ARCADE-11: Asset vault nesting can lead to loss of assets Unresolved. Arcade provided the following statement about this issue: The Arcade team understands the likelihood of this problem occurring is quite low because our UI does not allow for vault keys (vault tracking ERC721 tokens) to be 78 Arcade.xyz V3 Security Assessment deposited inside another vault contract. A power user would need to execute this type of vault key transfer via Etherscan. We elect to address this issue by: ● Thoroughly documenting this risk and providing clear and comprehensive warnings against this speciﬁc action in the documentation ● Maintaining our user interface to ensure that it does not present the option of using vault keys as collateral for loans TOB-ARCADE-12: Risk of locked assets due to use of _mint instead of _safeMint Resolved in commit 20b7c66. The mint function in the PromissoryNote contract has been updated to use _safeMint instead of _mint. Similarly, the initializeBundle function in the VaultFactory contract now uses _safeMint instead of _mint. These changes ensure that an ERC-721 token is not sent to a contract address that is not conﬁgured to receive it. The NatSpec comments have also been updated to reﬂect these changes. Additionally, the unit testing suite and mock contracts have been updated to adequately test the new expected behavior of the two altered functions. TOB-ARCADE-13: Borrowers cannot realize full loan value without risking default Resolved in commits 6586c37 and f1eb8ae. A new grace period after the original loan’s due date was introduced with the ﬁrst commit. The grace period added in this commit was a conﬁgurable setting that can be between one hour and seven days. An admin-only function was added to set the new value, which emits events on changes or errors. A new set of unit tests was added for the setGracePeriod functionality, and existing tests were modiﬁed to take the grace period into account. However, in the second commit, the variable grace period was replaced with a constant 10-minute period. The variable period tests were removed, and the remaining tests were modiﬁed to account for the change. TOB-ARCADE-14: itemPredicates encoded incorrectly according to EIP-712 Resolved in commit c95e21c. Item predicates are now encoded in compliance with the EIP-712 standard. Rather than a hash representing an array of item predicates, an array of the actual Predicate structs to be signed is now presented to the signer. A _PREDICATE_TYPEHASH has been created, and the _ITEMS_TYPEHASH has been updated to correctly account for the array of Predicate structs that is now represented in the signature. The unit tests dealing with signatures that include items have been updated to reﬂect the changes to the signature scheme. TOB-ARCADE-15: The fee values can distort the incentives for the borrowers and lenders Unresolved. Arcade provided the following statement about this issue: 79 Arcade.xyz V3 Security Assessment Our V3 documentation will comprehensively outline all fees within the lending protocol, pointing the users to their values at loan initiation. The Arcade team’s objective is to help users grasp potential proﬁts and anticipated fees linked with loan repayment, rollover, default, or redemption scenarios. TOB-ARCADE-16: Malicious borrowers can use forceRepay to grief lenders Unresolved. Arcade provided the following statement about this issue: The Arcade.xyz team is aware that for honest lenders, having forceRepay called incurs additional gas cost and possible fees. Nevertheless, the team has elected to keep the implementation as-is: we feel that having two separate functions is a more explicit, less "surprising" design compared to having a single function whose eﬀects may change based on external state. In general, we believe the vector allowing borrower grieﬁng is best mitigated through proper incentive management and counterparty relationship management: borrowers who have griefed lenders in the past are likely to receive lending oﬀers with higher premiums, as lenders try to mitigate their risk. In a larger sense, if grieﬁng becomes a protocol-wide issue, redeem fees can be set to 0. 80 Arcade.xyz V3 Security Assessment 
