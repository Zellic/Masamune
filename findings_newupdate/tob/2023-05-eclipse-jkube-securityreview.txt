1. Insecure defaults in generated artifacts Severity: Informational Diﬃculty: Undetermined Type: Conﬁguration Finding ID: TOB-JKUBE-1 Target: Artifacts generated by JKube Description JKube can generate Kubernetes deployment artifacts and deploy applications using those artifacts. By default, many of the security features oﬀered by Kubernetes are not enabled in these artifacts. This can cause the deployed applications to have more permissions than their workload requires. If such an application were compromised, the permissions would enable the attacker to perform further attacks against the container or host. Kubernetes provides several ways to further limit these permissions, some of which are documented in appendix E . Similarly, the generated artifacts do not employ some best practices, such as referencing container images by hash, which could help prevent certain supply chain attacks. We compiled several of the examples contained in the quickstarts folder and analyzed them. We observed instances of the following problems in the artifacts produced by JKube: ● ● ● ● ● ● ● ● Pods have no associated network policies . Dockerﬁles have base image references that use the latest tag. Container image references use the latest tag, or no tag, instead of a named tag or a digest. Resource (CPU, memory) limits are not set. Containers do not have the allowPrivilegeEscalation setting set. Containers are not conﬁgured to use a read-only ﬁlesystem. Containers run as the root user and have privileged capabilities. Seccomp proﬁles are not enabled on containers. ● Service account tokens are mounted on pods where they may not be needed. Exploit Scenario An attacker compromises one application running on a Kubernetes cluster. The attacker takes advantage of the lax security conﬁguration to move laterally and attack other system components. Recommendations Short term, improve the default generated conﬁguration to enhance the security posture of applications deployed using JKube, while maintaining compatibility with most common scenarios. Apply automatic tools such as Checkov during development to review the conﬁguration generated by JKube and identify areas for improvement. Long term, implement mechanisms in JKube to allow users to conﬁgure more advanced security features in a convenient way. References ● ● Appendix D: Docker Recommendations Appendix E: Hardening Containers Run via Kubernetes 
1. Insecure defaults in generated artifacts Severity: Informational Diﬃculty: Undetermined Type: Conﬁguration Finding ID: TOB-JKUBE-1 Target: Artifacts generated by JKube Description JKube can generate Kubernetes deployment artifacts and deploy applications using those artifacts. By default, many of the security features oﬀered by Kubernetes are not enabled in these artifacts. This can cause the deployed applications to have more permissions than their workload requires. If such an application were compromised, the permissions would enable the attacker to perform further attacks against the container or host. Kubernetes provides several ways to further limit these permissions, some of which are documented in appendix E . Similarly, the generated artifacts do not employ some best practices, such as referencing container images by hash, which could help prevent certain supply chain attacks. We compiled several of the examples contained in the quickstarts folder and analyzed them. We observed instances of the following problems in the artifacts produced by JKube: ● ● ● ● ● ● ● ● Pods have no associated network policies . Dockerﬁles have base image references that use the latest tag. Container image references use the latest tag, or no tag, instead of a named tag or a digest. Resource (CPU, memory) limits are not set. Containers do not have the allowPrivilegeEscalation setting set. Containers are not conﬁgured to use a read-only ﬁlesystem. Containers run as the root user and have privileged capabilities. Seccomp proﬁles are not enabled on containers. ● Service account tokens are mounted on pods where they may not be needed. Exploit Scenario An attacker compromises one application running on a Kubernetes cluster. The attacker takes advantage of the lax security conﬁguration to move laterally and attack other system components. Recommendations Short term, improve the default generated conﬁguration to enhance the security posture of applications deployed using JKube, while maintaining compatibility with most common scenarios. Apply automatic tools such as Checkov during development to review the conﬁguration generated by JKube and identify areas for improvement. Long term, implement mechanisms in JKube to allow users to conﬁgure more advanced security features in a convenient way. References ● ● Appendix D: Docker Recommendations Appendix E: Hardening Containers Run via Kubernetes 
2. Risk of command line injection from secret Severity: Low Diﬃculty: Medium Type: Data Validation Finding ID: TOB-JKUBE-2 Target: jkube-kit/jkube-kit-spring-boot/src/main/java/org/eclipse/jkube/spri ngboot/watcher/SpringBootWatcher.java Description As part of the Spring Boot watcher functionality, JKube executes a second Java process. The command line for this process interpolates an arbitrary secret, making it unsafe. This command line is then tokenized by separating on spaces. If the secret contains spaces, this process could allow an attacker to add arbitrary arguments and command-line ﬂags and modify the behavior of this command execution. StringBuilder buffer = new StringBuilder( "java -cp " ); (...) buffer.append( " -Dspring.devtools.remote.secret=" ); buffer.append( remoteSecret ); buffer.append( " org.springframework.boot.devtools.RemoteSpringApplication " ); buffer.append(url); try { String command = buffer.toString(); log.debug( "Running: " + command); final Process process = Runtime.getRuntime().exec(command) ; Figure 2.1: A secret is used without sanitization on a command string that is then executed. ( jkube/jkube-kit/jkube-kit-spring-boot/src/main/java/org/eclipse/jkube/sp ringboot/watcher/SpringBootWatcher.java#136–171 ) Exploit Scenario An attacker forks an open source project that uses JKube and Spring Boot, improves it in some useful way, and introduces a malicious spring.devtools.remote.secret secret in application.properties . A user then ﬁnds this forked project and sets it up locally. When the user runs mvn k8s:watch , JKube invokes a command that includes attacker-controlled content, compromising the user’s machine. Recommendations Short term, rewrite the command-line building code to use an array of arguments instead of a single command-line string. Java provides several variants of the exec method, such as exec(String[]) , which are safer to use when user-provided input is involved. Long term, integrate static analysis tools in the development process and CI/CD pipelines, such as Semgrep and CodeQL, to detect instances of similar problems early on. Review uses of user-controlled input to ensure they are sanitized if necessary and processed safely. A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diﬃculty levels used in this document. Vulnerability Categories Category Description Access Controls Insuﬃcient authorization or assessment of rights Auditing and Logging Insuﬃcient auditing of actions or logging of problems Authentication Improper identiﬁcation of users Conﬁguration Misconﬁgured servers, devices, or software components Cryptography A breach of system conﬁdentiality or integrity Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service A system failure with an availability impact Error Reporting Insecure or insuﬃcient reporting of error conditions Patching Use of an outdated software package or library Session Management Improper identiﬁcation of authenticated users Testing Timing Insuﬃcient test methodology or test coverage Race conditions or other order-of-operations ﬂaws Undeﬁned Behavior Undeﬁned behavior triggered within the system Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices. Undetermined The extent of the risk was not determined during this engagement. Low The risk is small or is not one the client has indicated is important. Medium High User information is at risk; exploitation could pose reputational, legal, or moderate ﬁnancial risks. The ﬂaw could aﬀect numerous users and have serious reputational, legal, or ﬁnancial implications. Diﬃculty Levels Diﬃculty Description Undetermined The diﬃculty of exploitation was not determined during this engagement. Low Medium High The ﬂaw is well known; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of the system. An attacker must have privileged access to the system, may need to know complex technical details, or must discover other weaknesses to exploit this issue. B. Code Maturity Categories The following tables describe the code maturity categories and rating criteria used in this document. Code Maturity Categories Category Description Arithmetic The proper use of mathematical operations and semantics Auditing The use of event auditing and logging to support monitoring Authentication / Access Controls The use of robust access controls to handle identiﬁcation and authorization and to ensure safe interactions with the system Complexity Management The presence of clear structures designed to manage system complexity, including the separation of system logic into clearly deﬁned functions Conﬁguration The conﬁguration of system components in accordance with best practices Cryptography and Key Management The safe use of cryptographic primitives and functions, along with the presence of robust mechanisms for key generation and distribution Data Handling The safe handling of user inputs and data processed by the system Documentation The presence of comprehensive and readable codebase documentation Maintenance The timely maintenance of system components to mitigate risk Memory Safety and Error Handling The presence of memory safety and robust error-handling mechanisms Testing and Veriﬁcation The presence of robust testing procedures (e.g., unit tests, integration tests, and veriﬁcation methods) and suﬃcient test coverage Rating Criteria Rating Strong Description No issues were found, and the system exceeds industry standards. Satisfactory Minor issues were found, but the system is compliant with best practices. Moderate Some issues that may aﬀect system safety were found. Weak Many issues that aﬀect system safety were found. Missing A required component is missing, signiﬁcantly aﬀecting system safety. Not Applicable The category is not applicable to this review. Not Considered The category was not considered in this review. Further Investigation Required Further investigation is required to reach a meaningful conclusion. C. Non-Security-Related Findings The following recommendations are not associated with speciﬁc vulnerabilities. However, implementing them may enhance code readability and may prevent the introduction of vulnerabilities in the future. ● The following if condition is always true. i is always less than objects.length ; otherwise, the for loop would not be executing. The developer likely intended to use ++i instead of i++ . for ( int i = 0 ; i < objects.length; ) { sb.append(objects[i]); if ( i++ < objects.length ) { sb.append(joinWith); } } Figure C.1: This if condition is always true. ( jkube/kube-kit/build/api/src/test/java/org/eclipse/jkube/kit/build/api/h elper/PathTestUtil.java#69–74 ) ● The AssemblyManager singleton may not work as expected on multi-threaded environments. Consider making the initialization synchronized. public static AssemblyManager getInstance () { if (dockerAssemblyManager == null ) { dockerAssemblyManager = new AssemblyManager(); } return dockerAssemblyManager; } Figure C.2: This initialization is not thread-safe. ( jkube/jkube-kit/build/api/src/main/java/org/eclipse/jkube/kit/buil d/api/assembly/AssemblyManager.java#81–86 ) ● The following format string call has more arguments than parameters. throw new DockerAccessException(e, "Unable to add tag [%s] to image [%s]" , targetImage, sourceImage , e ); Figure C.3: This format string has an extra argument. ( jkube/jkube-kit/build/service/docker/src/main/java/org/eclipse/jkube/kit /build/service/docker/access/hc/DockerAccessWithHcClient.java#476–477 ) ● The following issue appears to be ﬁxed upstream. Consider removing the workaround or adjusting the comment if it is still desirable to keep Prometheus disabled. // Switch off Prometheus agent until logging issue with WildFly Swarm is resolved // See: // - https://github.com/fabric8io/fabric8-maven-plugin/issues/1173 // - https://issues.jboss.org/browse/THORN-1859 ret.put( "AB_PROMETHEUS_OFF" , "true" ); ret.put( "AB_OFF" , "true" ); Figure C.4: The code references an upstream issue that has been resolved. ( jkube/jkube-kit/jkube-kit-thorntail-v2/src/main/java/org/eclipse/jkube/t horntail/v2/generator/ThorntailV2Generator.java#41–46 ) ● The parsedCredentials array is indexed without ﬁrst being checked to ensure that it has enough elements. This may cause the program to fail. This code is repeated in jkube/jkube-kit/build/api/src/main/java/org/eclipse/jkube/kit/bui ld/api/auth/RegistryAuth.java . public static AuthConfig fromCredentialsEncoded (String credentialsEncoded, String email) { final String credentials = new String(Base64.decodeBase64(credentialsEncoded)); final String[] parsedCredentials = credentials.split( ":" , 2 ) ; return AuthConfig.builder() .username(parsedCredentials[ 0 ]) .password( parsedCredentials[ 1 ] ) .email(email) .build(); } Figure C.5: parsedCredentials may have a single element in the array. ( jkube/jkube-kit/build/api/src/main/java/org/eclipse/jkube/kit/build/api/ auth/AuthConfig.java#89–97 ) ● The spring.devtools.remote.secret secret is logged as part of the printed command. This might not represent a security issue, as this particular secret is also stored in plaintext, but as a general practice, privileged information should not be logged. log.debug( "Running: " + command ); Figure C.6: The command string contains the mentioned secret. ( jkube/jkube-kit/jkube-kit-spring-boot/src/main/java/org/eclipse/jkube/sp ringboot/watcher/SpringBootWatcher.java#170 ) ● There are several occurrences across the codebase of parseInt calls on user input without adequate error handling. An invalid input on a user-provided property may cause JKube to throw an exception. D. Docker Recommendations This appendix provides general recommendations regarding the use of Docker. We recommend using the steps listed under the "Basic Security" and "Limiting Container Privileges" sections and avoiding the options listed under the "Options to Avoid" section. This appendix also describes the Linux features that form the basis of Docker container security measures and includes a list of additional references. Basic Security ● ● ● ● ● Do not add users to the docker group. Inclusion in the docker group allows a user to escalate his or her privileges to root without authentication. Do not run containers as a root user . If user namespaces are not used, the root user within the container will be the real root user on the host. Instead, create another user within the Docker image and set the container user by using the USER instruction in the image’s Dockerﬁle speciﬁcation. Alternatively, pass in the --user $UID:$GID ﬂag to the docker run command to set the user and user group. Do not use the --privileged ﬂag . Using this ﬂag allows the process within the container to access all host resources, hijacking the machine. Do not mount the Docker daemon socket (usually /var/run/docker.sock ) into the container. A user with access to the Docker daemon socket will be able to spawn a privileged container to “escape” the container and access host resources. Carefully weigh the risks inherent in mounting volumes from special ﬁlesystems such as /proc or /sys into a container. If a container has write access to the mounted paths, a user may be able to gain information about the host machine or escalate his or her own privileges. Limiting Container Privileges ● ● ● Pass the --cap-drop=all ﬂag to the docker run command to drop all Linux capabilities and enable only those capabilities that are necessary to the process within a container using the --cap-add=... ﬂag. Note, though, that adding capabilities could allow the process to escalate its privileges and “escape” the container. Pass the --security-opt=no-new-privileges:true ﬂag to the docker run command to prevent processes from gaining additional privileges. Limit the resources provided to a container process to prevent denial-of-service scenarios. ● Do not use root ( uid=0 or gid=0 ) in a container if it is not needed. Use USER ... in the Dockerﬁle (or use docker run --user $UID:$GID ... ). The following recommendations are optional: ● ● ● Use user namespaces to limit the user and group IDs available in the container to only those that are mapped from the host to the container. Adjust the Seccomp and AppArmor proﬁles to further limit container privileges. Consider using SELinux instead of AppArmor to gain additional control over the operations a given container can execute. Options to Avoid Flag Description --privileged Gives all kernel capabilities to the container and lifts all the limitations enforced by the device cgroup controller (i.e., allowing the container to do almost everything that the host can do) --cap-add=all Adds all Linux capabilities --security-opt apparmor=unconfined --security-opt seccomp=unconfined Disables AppArmor Disables Seccomp --device-cgroup-rule='a *:* rwm' Enables access to all devices (according to this documentation ) --pid=host Uses the host PID namespace --uts=host Uses the host UTS namespace --network=host Uses the host network namespace, which grants access to all network interfaces available on a host Linux Features Foundational to Docker Container Security Feature Description Namespaces This feature is used to isolate or limit the view (and therefore the use) of a global system resource. There are various namespaces, such as PID , network , mount , UTS , IPC , user , and cgroup , each of which wraps a diﬀerent resource. For example, if a process creates a new PID namespace, the process will act as if its PID is 1 and will not be able to send signals to processes created in its parent namespace. The namespaces to which a process belongs are listed in the /proc/$PID/ns/ directory (each with its own ID) and can also be accessed by using the lsns tool . Control groups (cgroups) This is a mechanism for grouping processes/tasks into hierarchical groups and metering or limiting resources within those groups, such as memory, CPUs, I/Os, or networks. Linux capabilities The cgroups to which a process belongs can be read from the /proc/$PID/cgroup ﬁle. A cgroup’s entire hierarchy will be indicated in a /sys/fs/cgroup/<cgroup controller or hierarchy>/ directory if the cgroup controllers are mounted in that directory. (Use the mount | grep cgroup command to see whether they are.) There are two versions of cgroups, cgroups v1 and cgroups v2 , which can be (and often are) used at the same time. This feature splits root privileges into "capabilities." Although this setting is primarily related to the actions a privileged user can take, there are diﬀerent process capability sets, some of which are used to calculate the user’s eﬀective capabilities (such as after running an SUID binary). Therefore, dropping all Linux capabilities from all capability sets will help prevent a process from gaining additional privileges (such as through SUID binaries). The Linux process capability sets for a given process can be read from the /proc/$PID/status ﬁle, speciﬁcally its CapInh , CapPrm , CapEff , CapBnd , and CapAmb values (which correspond to the inherited, permitted, eﬀective, bound, and ambient capability sets, respectively). Those values can be decoded into meaningful capability names by using the capsh --decode=$VALUE tool. While the eﬀective capability set is the one that is directly used by the kernel to execute permission checks, it is best practice to limit all other sets too, since they may allow for gaining more eﬀective capabilities, such as through SUID binaries or programs that have “ ﬁle capabilities ” set. The “no new privileges” ﬂag Enabling this ﬂag for a process will prevent the user who launched the process from gaining additional privileges (such as through SUID binaries). Seccomp BPF syscall ﬁltering Seccomp BPF enables the ﬁltering of arguments passed in to a program and the syscalls executed by it. It does this by writing a “BPF program” that is later run in the kernel. Refer to the Docker default Seccomp policy . One can write a similar proﬁle and apply it with the --security-opt seccomp=<file> ﬂag. AppArmor Linux Security Module (LSM) AppArmor is LSM that limits a container’s access to certain resources by enforcing a mandatory access control. AppArmor proﬁles are loaded into a kernel. A proﬁle can be in either “complain” or “enforce” mode. In “complain” mode, violation attempts are logged only into the syslog; in “enforce” mode, such attempts are blocked. To see which proﬁles are loaded into a kernel, use the aa-status tool . To see whether a given process will work under the rules of an AppArmor proﬁle, read the /proc/$PID/attr/current ﬁle. If AppArmor is not enabled for the process, the ﬁle will contain an unconfined value. If it is enabled, the ﬁle will return the name of the policy and its mode (e.g., docker-default (enforce) ). Refer to the Docker AppArmor proﬁle template and the generated form of the proﬁle . Additional References ● ● ● ● Understanding Docker Container Escapes : A Trail of Bits blog post that breaks down a container escape technique and explains the constraints required to use that technique Namespaces in Operation, Part 1: Namespaces Overview : A seven-part LWN article that provides an overview of Linux namespace features False Boundaries and Arbitrary Code Execution : An old but thorough post about Linux capabilities and the ways that they can be used in privilege escalation attempts Technologies for Container Isolation: A Comparison of AppArmor and SELinux : A comparison of AppArmor and SELinux E. Hardening Containers Run via Kubernetes This appendix gives more context for the hardening of containers spawned by Kubernetes. Please note our deﬁnitions of the following terms: ● ● Container: This is the isolated “environment” created by Linux features such as namespaces, cgroups, Linux capabilities, and AppArmor and secure computing (seccomp) proﬁles. We are speciﬁcally concerned with Docker containers since the tested environment uses Docker as its container engine. Host: This is the unconﬁned environment on the machine running a container (e.g., a process run in global Linux namespaces). Root Inside Container User namespaces allow for the remapping of user and group IDs between a host and a container; unless namespaces are used, the root user inside the container will be the root user in the host. In a default conﬁguration of Docker containers, the container features limit the actions that the root user can take. However, if a process does not need to be run as root, it is best to run it with another user. To run a container with another user, use the USER Dockerﬁle instructions . In Kubernetes, one can specify the user ID (UID) and various group IDs (GIDs) (e.g., a primary GID, a ﬁle system–related GID, and those for supplemental groups) using the runAsUser , runAsGroup , fsGroup , and supplementalGroups attributes of a securityContext ﬁeld of a pod or other objects used to spawn containers. Dropping Linux Capabilities Linux capabilities split the privileged actions that a root user’s process can perform. Docker drops most Linux capabilities for security purposes but leaves others enabled for convenience . We recommend dropping all Linux capabilities and then enabling only those necessary for the application to function properly. Linux capabilities can be dropped in Docker via the --cap-drop=all ﬂag and in Kubernetes by specifying capabilities , drop , and --all in the securityContext key of the deployment’s container conﬁguration. Then, to restore necessary capabilities, use the --cap-add=<cap> ﬂag in a docker run or specify them in capabilities , and use add in the securityContext ﬁeld in the Kubernetes object manifest. NoNewPrivs Flag The NoNewPrivs ﬂag prevents additional privileges for a process or its children from being assigned. For example, it prevents a UID/GID from gaining capabilities or privileges by executing setuid binaries. The NoNewPrivs ﬂag can be enabled in a docker run via the --security-opt=no-new-privileges ﬂag. In a Kubernetes deployment, specify allowPrivilegeEscalation: false in the securityContext ﬁeld to enable it. Seccomp Policies A seccomp policy limits the available system calls and their arguments. Normally, using seccomp requires a call to a prctl syscall with a special structure, but Docker simpliﬁes the process and allows a seccomp policy to be speciﬁed as a JSON ﬁle . Using the default Docker proﬁle is a good start for implementing a speciﬁc policy. Seccomp is disabled by default in Kubernetes . The seccomp policy can be speciﬁed with a --security-opt seccomp=<filepath> ﬂag in Docker. In Kubernetes, the seccomp policy can be set either by using a seccompProfile key in the securityContext ﬁeld of a pod (in Kubernetes v1.19 or later) or by using the container.seccomp.security.alpha.kubernetes.io/<container_name>: <profile_ref> annotation (in pre-v1.19 versions). The Kubernetes documentation includes examples of both methods of setting a speciﬁc seccomp policy . Linux Security Module (AppArmor) The LSM is a mechanism that allows kernel developers to hook various kernel calls. AppArmor is an LSM used by default in Docker . Another popular LSM is SELinux, but since it is more diﬃcult to set up, it is not discussed here. AppArmor limits what a process can do and which resources a process can interact with. Docker uses its default AppArmor proﬁle, which is generated from this template . When Docker is used as a container engine in Kubernetes, the same proﬁle is often used by default, depending on the Kubernetes cluster conﬁguration. One can override the AppArmor proﬁle in Kubernetes with the following annotation (which is further described here ): container.apparmor.security.beta.kubernetes.io/<container_name>: <profile_ref> F. Fix Review Results When undertaking a ﬁx review, reviews the ﬁxes implemented for issues identiﬁed in the original report. This work involves a review of speciﬁc areas of the source code and system conﬁguration, not comprehensive analysis of the system. On July 7, 2023, reviewed the ﬁxes and mitigations implemented by the JKube team for the issues identiﬁed in this report. We reviewed each ﬁx to determine its eﬀectiveness in resolving the associated issue. In summary, of the two issues described in this report, the JKube team has resolved one and has partially resolved the other. In addition to ﬁxing the potential command line injection issue, the ﬁxes include a new enricher that improves the generated conﬁguration for Kubernetes objects, using more secure settings. JKube users must explicitly opt in to use this new enricher. For additional information, please see the Detailed Fix Review Results below. ID Title Severity Status Detailed Fix Review Results TOB-JKUBE-1: Insecure defaults in generated artifacts Partially resolved in PR #2177 and PR #2182 . These pull requests introduce a new enricher that enforces several security best practices and recommendations for Kubernetes objects. However, this enricher is not enabled in the default conﬁguration, which means that the generated deployment artifacts remain insecure by default unless the user enables this new feature. TOB-JKUBE-2: Risk of command line injection from secret Resolved in PR #2169 . Among other changes, this pull request rewrote the command-line building code to use an array of arguments instead of a single command-line string. This way of invoking external programs does not present the same injection risk that was identiﬁed in the previous code with string interpolation. G. Fix Review Status Categories The following table describes the statuses used to indicate whether an issue has been suﬃciently addressed. Fix Status Status Description Undetermined The status of the issue was not determined during this engagement. Unresolved The issue persists and has not been resolved. Partially Resolved The issue persists but has been partially resolved. Resolved The issue has been suﬃciently resolved. 
