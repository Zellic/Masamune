1. API keys are leaked outside of the application server Severity: Low Diﬃculty: High Type: Data Exposure Finding ID: TOB-ASOC-1 Target: clap/internal/dbstore/customer.go Description API key veriﬁcation is handled by the AuthKey function (ﬁgure 1.1). This function uses the auth method, which passes the plaintext value of a key to the database (as part of the database query), as shown in ﬁgure 1.2. func (s *CustomerStore) AuthKey(ctx context.Context, key string) (*clap.User, error) { internalUser, err := s.authInternalKey(ctx, key) if err == store.ErrInvalidAPIKey { return s.auth(ctx, "auth_api_key", key) } else if err != nil { return nil, err } return internalUser, nil } Figure 1.1: The call to the auth method (clap/internal/dbstore/customer.go#L73–L82) func (s *CustomerStore) auth(ctx context.Context, funName string, value interface{}) (*clap.User, error) { user := &clap.User{ Type: clap.UserTypeCustomer, } err := s.db.QueryRowContext(ctx, fmt.Sprintf(` SELECT ws.sid, ws.workspace_id, ws.credential_id FROM console_clap.%s($1) AS ws LEFT JOIN api.disabled_user AS du ON du.user_id = ws.sid WHERE du.user_id IS NULL LIMIT 1 `, pq.QuoteIdentifier(funName)), value).Scan(&user.ID, &user.WorkspaceID, &user.CredentialID) ... } Figure 1.2: The database query, with an embedded plaintext key (clap/internal/dbstore/customer.go#L117–L141) Moreover, keys are generated in the database (ﬁgure 1.3) rather than in the Go code and are then sent back to the API, which increases their exposure. gk := &store.GeneratedKey{} err = tx.QueryRowContext(ctx, ` SELECT sid, key FROM console_clap.key_request() `).Scan(&gk.CustomerID, &gk.Key) Figure 1.3: clap/internal/dbstore/customer.go#L50–L53 Exploit Scenario An attacker gains access to connection traﬃc between the application server and the database, steals the API keys being transmitted, and uses them to impersonate their owners. Recommendations Short term, have the API hash keys before sending them to the database, and generate API keys in the Go code. This will reduce the keys’ exposure. Long term, document the trust boundaries traversed by sensitive data. 
2. Unused insecure authentication mechanism Severity: Informational Diﬃculty: High Type: Data Exposure Finding ID: TOB-ASOC-2 Target: clap Description The clap code contains an unused insecure authentication mechanism, the FixedKeyAuther strategy, that stores conﬁgured plaintext keys (ﬁgure 2.1) and veriﬁes them through a non-constant-time comparison (ﬁgure 2.2). The use of this comparison creates a timing attack risk. /* if cfg.Server.SickMode { if cfg.Server.ApiKey == "" { config") log15.Crit("In sick mode, api key variable must be set in os.Exit(1) } auther = FixedKeyAuther{ ID: -1, Key: cfg.Server.ApiKey, } } else*/ Figure 2.1: clap/server/server.go#L57–L67 type FixedKeyAuther struct { Key string ID int64 } func (a FixedKeyAuther) AuthKey(ctx context.Context, key string) (*clap.User, error) { if key != "" && key == a.Key { return &clap.User{ID: a.ID}, nil } return nil, nil } Figure 2.2: clap/server/auth.go#L19–L29 Exploit Scenario The FixedKeyAuther strategy is enabled. This increases the risk of a key leak, since the authentication mechanism is vulnerable to timing attacks and stores plaintext API keys in memory. Recommendations Short term, to prevent API key exposure, either remove the FixedKeyAuther strategy or change it so that it uses a hash of the API key. Long term, avoid leaving commented-out or unused code in the codebase. 
3. Use of panics to handle user-triggerable errors Severity: Informational Diﬃculty: Low Type: Error Reporting Finding ID: TOB-ASOC-3 Target: clap/lib/clap/request.go Description The clap HTTP handler mechanism uses panic to handle errors that can be triggered by users (ﬁgures 3.1 and 3.2). Handling these unusual cases of panics requires the mechanism to ﬁlter out errors of the RequestError type (ﬁgure 3.3). The use of panics to handle expected errors alters the panic semantics, deviates from callers’ expectations, and makes reasoning about the code and its error handling more diﬃcult. func (r *Request) MustUnmarshal(v interface{}) { ... err := json.NewDecoder(body).Decode(v) if err != nil { panic(BadRequest("Failed to parse request body", "jsonErr", err)) } } Figure 3.1: clap/lib/clap/request.go#L31–L42 // MustBeAuthenticated returns user ID if request authenticated, // otherwise panics. func (r *Request) MustBeAuthenticated() User { user, err := r.User() if err == nil && user == nil { err = errors.New("user is nil") } else if !user.Valid() { err = errors.New("user id is zero") } if err != nil { panic(Error("not authenticated: " + err.Error())) } return *user } Figure 3.2: clap/lib/clap/request.go#L134–L147 defer func() { if e := recover(); e != nil { if err, ok := e.(*RequestError); ok { onError(w, r, err) } else { panic(e) } } }() Figure 3.3: clap/lib/clap/handler.go#L93–L101 Recommendations Short term, change the code in ﬁgures 3.1, 3.2, and 3.3 so that it adheres to the conventions of handling expected errors in Go. This will simplify the error-handling functionality and the process of reasoning about the code. Reserving panics for unexpected situations or bugs in the code will also help surface incorrect assumptions. Long term, use panics only to handle unexpected errors. 
4. Confusing API authentication mechanism Severity: Informational Diﬃculty: High Type: Authentication Finding ID: TOB-ASOC-4 Target: clap Description The clap HTTP endpoint handler code appears to indicate that the handlers perform manual endpoint authentication. This is because when a handler receives a clap.Request, it calls the MustBeAuthenticated method (ﬁgure 4.1). The name of this method could imply that it is called to authenticate the endpoint. However, MustBeAuthenticated returns information on the (already authenticated) user who submitted the request; authentication is actually performed by default by a centralized mechanism before the call to a handler. Thus, the use of this method could cause confusion regarding the timing of authentication. func (h *AlertsHandler) handleGet(r *clap.Request) interface{} { // Parse arguments q := r.URL.Query() var minSeverity uint64 if ms := q.Get("minSeverity"); ms != "" { var err error minSeverity, err = strconv.ParseUint(ms, 10, 8) if err != nil || minSeverity > 5 { return clap.BadRequest("Invalid minSeverity parameter") } } if h.MinSeverity > minSeverity { minSeverity = h.MinSeverity } filterEventType := q.Get("eventType") user := r.MustBeAuthenticated() ... } Figure 4.1: clap/apiv1/alerts.go#L363–L379 Recommendations Short term, add a ServeAuthenticatedAPI interface method that takes an additional user parameter indicating that the handler is already in the authenticated context. Long term, document the authentication system to make it easier for new team members and auditors to understand and to facilitate their onboarding. 
5. Use of MD5 can lead to ﬁlename collisions Severity: Informational Diﬃculty: High Type: Cryptography Finding ID: TOB-ASOC-5 Target: ae Description When generating a ﬁlename, the deriveQueueFile function uses an unsafe MD5 hash function to hash the destinationID that is included in the ﬁlename (ﬁgure 5.1). func deriveQueueFile(outputType, destinationID string) string { return fmt.Sprintf("%s-%x.bdb", outputType, md5.Sum([]byte(destinationID))) } Figure 5.1: ae/config/config.go#L284–L286 Exploit Scenario An attacker with control of a destinationID value modiﬁes the value, with the goal of causing a hash collision. The hash computed by md5.Sum collides with that of an existing ﬁlename. As a result, the existing ﬁle is overwritten. Recommendations Short term, replace the MD5 function with a safer alternative such as SHA-2. Long term, avoid using the MD5 function unless it is necessary for interfacing with a legacy system in a non-security-related context. 
6. Overly broad ﬁle permissions Severity: Informational Diﬃculty: High Type: Access Controls Finding ID: TOB-ASOC-6 Target: ae Description In several parts of the ae code, ﬁles are created with overly broad permissions that allow them to be read by anyone in the system. This occurs in the following code paths: ● ae/tools/copy.go#L50 ● ae/bqimport/import.go#L291 ● ae/tools/migrate.go#L127 ● ae/tools/migrate.go#L223 ● ae/tools/migrate.go#L197 ● ae/tools/copy.go#L16 ● ae/main.go#L319 Recommendations Short term, change the ﬁle permissions, limiting them to only those that are necessary. Long term, always consider the principle of least privilege when making decisions about ﬁle permissions. 
7. Unhandled errors Severity: Informational Diﬃculty: High Type: Error Reporting Finding ID: TOB-ASOC-7 Target: ae and clap Description The gosec tool identiﬁed many unhandled errors in the ae and clap codebases. Recommendations Short term, run gosec on the ae and clap codebases, and address the unhandled errors. Even if an error is considered unimportant, it should still be handled and discarded, and the decision to discard it should be justiﬁed in a code comment. Long term, encourage the team to use gosec, and run it before any major release. 
