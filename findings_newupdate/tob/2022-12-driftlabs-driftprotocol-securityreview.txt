1. Lack of build instructions Severity: Informational Diﬃculty: High Type: Testing Finding ID: TOB-DRIFT-1 Target: README.md Description The Drift Protocol repository does not contain instructions to build, compile, test, or run the project. The project’s README should include at least the following information: ● ● ● Instructions for building the project Instructions for running the built artifacts Instructions for running the project’s tests The closest thing we have found to build instructions appears in a script in the drift-sim repository (ﬁgure 1.1). As shown in the ﬁgure below, building the project is non-trivial. Users should not be required to rediscover these steps on their own. git submodule update --init --recursive # build v2 cd driftpy/protocol-v2 yarn && anchor build # build dependencies for v2 cd deps/serum-dex/dex && anchor build && cd ../../.. # go back to top-level cd ../../ Figure 1.1: drift-sim/setup.sh Additionally, the project relies on serum-dex , which currently has an open issue regarding outdated build instructions. Thus, if a user visits the serum-dex repository to learn how to build the dependency, they will be misled. Exploit Scenario Alice attempts to build and deploy her own copy of the Drift Protocol smart contract. Without instructions, Alice deploys it incorrectly. Users of Alice’s copy of the smart contract suﬀer ﬁnancial loss. Recommendations Short term, add the minimal information listed above to the project’s README . This will help users to build, run, and test the project . Long term, as the project evolves, ensure that the README is updated. This will help ensure that the README does not communicate incorrect information to users . References ● Documentation points to do.sh 
2. Inadequate testing Severity: Informational Diﬃculty: High Type: Testing Finding ID: TOB-DRIFT-2 Target: .github/workflows/main.yml , test-scripts/run-anchor-tests.sh Description The Anchor tests are not run as part of Drift Protocol’s CI process. Moreover, the script responsible for running the Anchor tests does not run all of them. Integrating all Anchor tests into the CI process and updating the script so it runs all tests will help ensure they are run regularly and consistently. Figure 2.1 shows a portion of the project’s main GitHub workﬂow, which runs the project’s unit tests. However, the ﬁle makes no reference to the project’s Anchor tests. - name : Run unit tests run : cargo test --lib # run unit tests Figure 2.1: .github/workflows/main.yml#L52–L53 Furthermore, the script used to run the Anchor tests runs only some of them. The relevant part of the script appears in ﬁgure 2.2. The test_files array contains the names of nearly all of the ﬁles containing tests in the tests directory. However, the array lacks the following entries, and consequently does not run their tests: ● ksolver.ts ● tokenFaucet.ts test_files =( postOnlyAmmFulfillment.ts imbalancePerpPnl.ts ... # 42 entries cancelAllOrders.ts ) Figure 2.2: test-scripts/run-anchor-tests.sh#L7–L53 Exploit Scenario Alice, a Drift Protocol developer, unwittingly introduces a bug into the codebase. The test would be revealed by the Anchor tests. However, because the Anchor tests are not run in CI, the bug goes unnoticed. Recommendations Short term: ● ● Adjust the main GitHub workﬂow so that it runs the Anchor tests. Adjust the run-anchor-tests.sh script so that it runs all Anchor tests (including those in ksolver.ts and tokenFaucet.ts ). Taking these steps will help to ensure that all Anchor tests are run regularly and consistently. Long term, revise the run-anchor-tests.sh script so that the test_files array is not needed. Move ﬁles that do not contain tests into a separate directory, so that only ﬁles containing tests remain. Then, run the tests in all ﬁles in the tests directory. Adopting such an approach will ensure that newly added tests are automatically run. 
3. Invalid audit.toml prevents cargo audit from being run Severity: Informational Diﬃculty: High Type: Auditing and Logging Finding ID: TOB-DRIFT-3 Target: audit.toml Description The project’s anchor.toml ﬁle contains an invalid key. This makes running cargo audit on the project impossible. The relevant part of the audit.toml ﬁle appears in ﬁgure 3.1. The packages key is unrecognized by cargo audit . As a result, cargo audit produces the error in ﬁgure 3.2 when run on the protocol-v2 repository. [packages] source = "all" # "all", "public" or "local" Figure 3.1: .cargo/audit.toml#L27–L28 error: cargo-audit fatal error: parse error: unknown field `packages`, expected one of `advisories`, `database`, `output`, `target`, `yanked` at line 30 column 1 Figure 3.2: Error produced by cargo audit when run on the protocol-v2 repository Exploit Scenario A vulnerability is discovered in a protocol-v2 dependency. A RUSTSEC advisory is issued for the vulnerability, but because cargo audit cannot be run on the repository, the vulnerability goes unnoticed. Users suﬀer ﬁnancial loss. Recommendations Short term, either remove the packages table from the anchor.toml ﬁle or replace it with a table recognized by cargo audit . In the project’s current state, cargo audit cannot be run on the project. Long term, regularly run cargo audit in CI and verify that it runs to completion without producing any errors or warnings. This will help the project receive the full beneﬁts of running cargo audit by identifying dependencies with RUSTSEC advisories. 
4. Race condition in Drift SDK Severity: Undetermined Diﬃculty: Low Type: Undeﬁned Behavior Finding ID: TOB-DRIFT-4 Target: sdk directory Description A race condition in the Drift SDK causes client programs to operate on non-existent or possibly stale data. The race condition aﬀects many of the project’s Anchor tests, making them unreliable. Use of the SDK in production could have ﬁnancial implications. When running the Anchor tests, the error in ﬁgure 4.1 appears frequently. The data ﬁeld that the error refers to is read by the getUserAccount function (ﬁgure 4.2). This function tries to read the data ﬁeld from a DataAndSlot object obtained by calling getUserAccountAndSlot (ﬁgure 4.3). That DataAndSlot object is set by the handleRpcResponse function (ﬁgure 4.4). TypeError: Cannot read properties of undefined (reading 'data') at User.getUserAccount (sdk/src/user.ts:122:56) at DriftClient.getUserAccount (sdk/src/driftClient.ts:663:37) at DriftClient.<anonymous> (sdk/src/driftClient.ts:1005:25) at Generator.next (<anonymous>) at fulfilled (sdk/src/driftClient.ts:28:58) at processTicksAndRejections (node:internal/process/task_queues:96:5) Figure 4.1: Error that appears frequently when running the Anchor tests public getUserAccount(): UserAccount { return this .accountSubscriber.getUserAccountAndSlot(). data ; } Figure 4.2: sdk/src/user.ts#L121–L123 public getUserAccountAndSlot(): DataAndSlot<UserAccount> { this .assertIsSubscribed(); return this .userDataAccountSubscriber. dataAndSlot ; } Figure 4.3: sdk/src/accounts/webSocketUserAccountSubscriber.ts#L72–L75 handleRpcResponse(context: Context , accountInfo?: AccountInfo <Buffer>): void { ... if (newBuffer && (!oldBuffer || !newBuffer.equals(oldBuffer))) { this .bufferAndSlot = { buffer: newBuffer , slot: newSlot , }; const account = this .decodeBuffer(newBuffer); this .dataAndSlot = { data: account , slot: newSlot , }; this .onChange(account); } } Figure 4.4: sdk/src/accounts/webSocketAccountSubscriber.ts#L55–L95 If a developer calls getUserAccount but handleRpcResponse has not been called since the last time the account was updated, stale data will be returned. If handleRpcResponse has never been called for the account in question, an error like that shown in ﬁgure 4.1 arises. Note that a developer can avoid the race by calling WebSocketAccountSubscriber.fetch (ﬁgure 4.5). However, the developer must manually identify locations where such calls are necessary. Errors like the one shown in ﬁgure 4.1 appear frequently when running the Anchor tests, which suggests that identifying such locations is nontrivial. async fetch(): Promise < void > { const rpcResponse = await this .program.provider.connection.getAccountInfoAndContext( this .accountPublicKey, ( this .program.provider as AnchorProvider).opts.commitment ); this .handleRpcResponse(rpcResponse.context, rpcResponse?.value); } Figure 4.5: sdk/src/accounts/webSocketAccountSubscriber.ts#L46–L53 We suspect this problem applies to not just user accounts, but any account fetched via a subscription mechanism (e.g., state accounts or perp market accounts). Note that despite the apparent race condition, Drift Protocol states that the tests run reliably for them. Exploit Scenario Alice, unaware of the race condition, writes client code that uses the Drift SDK. Alice’s code unknowingly operates on stale data and proceeds with a transaction, believing it will result in ﬁnancial gain. However, when processed with actual on-chain data, the transaction results in ﬁnancial loss for Alice. Recommendations Short term, rewrite all account getter functions so that they automatically call WebSocketAccountSubscriber.fetch . This will eliminate the need for developers to deal with the race manually. Long term, investigate whether using a subscription mechanism is actually needed. Another Solana RPC call could solve the same problem yet be more eﬃcient than a subscription combined with a manual fetch. 
5. Loose size coupling between function invocation and requirement Severity: Informational Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-DRIFT-5 Target: programs/drift/src/state/events.rs Description The implementation of the emit_stack function relies on the caller to use a suﬃciently large buﬀer space to hold a Base64-encoded representation of the discriminator along with the serialized event. Failure to provide suﬃcient space will result in an out-of-bounds attempt on either the write operation or the in the base64::encode_config_slice call. emit_stack::<_, 424 >(order_action_record); Figure 5.1: programs/drift/src/controller/orders.rs#L545 pub fn emit_stack <T: AnchorSerialize + Discriminator, const N: usize >(event: T ) { let mut data_buf = [ 0 u8 ; N]; let mut out_buf = [ 0 u8 ; N]; emit_buffers(event, & mut data_buf[..], & mut out_buf[..]) } pub fn emit_buffers <T: AnchorSerialize + Discriminator>( event: T , data_buf: & mut [ u8 ], out_buf: & mut [ u8 ], ) { let mut data_writer = std::io::Cursor::new(data_buf); data_writer .write_all(&<T as Discriminator>::discriminator()) .unwrap(); borsh::to_writer(& mut data_writer, &event).unwrap(); let data_len = data_writer.position() as usize ; let out_len = base64::encode_config_slice( &data_writer.into_inner()[ 0 ..data_len], base64::STANDARD, out_buf, ); let msg_bytes = &out_buf[ 0 ..out_len]; let msg_str = unsafe { std:: str ::from_utf8_unchecked(msg_bytes) }; msg!(msg_str); } Figure 5.2: programs/drift/src/state/events.rs#L482–L511 Exploit Scenario A maintainer of the smart contract is unaware of this implicit size requirement and adds a call to emit_stack using too small a buﬀer, or changes are made to a type without a corresponding change to all places where emit_stack uses that type. If the changed code is not covered by tests, the problem will manifest during contract operation, and could cause an instruction to panic, thereby reverting the transaction. Recommendations Short term, add a size constant to the type, and calculate the amount of space required for holding the respective buﬀers. This ensures that changes to a type's size can be made throughout the code. Long term, create a trait to be used by the types with which emit_stack is intended to work. This can be used to handle the size of the type, and also any other future requirement for types used by emit_stack . 
6. The zero-copy feature in Anchor is experimental Severity: Informational Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-DRIFT-6 Target: State structs Description Several structs for keeping state use Anchor’s zero-copy functionality. The Anchor documentation states that this is still an experimental feature that should be used only when Borsh serialization cannot be used without hitting the stack or heap limits. Exploit Scenario The Anchor framework has a bug in the zero-copy feature, or updates it with a breaking change, in a way that aﬀects the security model of the Drift smart contract. An attacker discovers this problem and leverages it to steal funds from the contract. #[account(zero_copy)] #[derive(Default, Eq, PartialEq, Debug)] #[repr(C)] pub struct User { pub authority: Pubkey , pub delegate: Pubkey , pub name: [ u8 ; 32 ], pub spot_positions: [SpotPosition; 8 ], pub perp_positions: [PerpPosition; 8 ], pub orders: [Order; 32 ], pub last_add_perp_lp_shares_ts: i64 , pub total_deposits: u64 , pub total_withdraws: u64 , pub total_social_loss: u64 , // Fees (taker fees, maker rebate, referrer reward, filler reward) and pnl for perps pub settled_perp_pnl: i64 , // Fees (taker fees, maker rebate, filler reward) for spot pub cumulative_spot_fees: i64 , pub cumulative_perp_funding: i64 , pub liquidation_margin_freed: u64 , // currently unimplemented // currently unimplemented pub liquidation_start_ts: i64 , pub next_order_id: u32 , pub max_margin_ratio: u32 , pub next_liquidation_id: u16 , pub sub_account_id: u16 , pub status: UserStatus , pub is_margin_trading_enabled: bool , pub padding: [ u8 ; 26 ], } Figure 6.1: Example of a struct using zero copy Recommendations Short term, evaluate if it is possible to move away from using zero copy without hitting the stack or heap limits, and do so if possible. Not relying on experimental features reduces the risk of exposure to bugs in the Anchor framework. Long term, adopt a conservative stance by using stable versions of packages and features. This reduces both risk and time spent on maintaining compatibility with code still in ﬂux. 
7. Hard-coded indices into account data Severity: Informational Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-DRIFT-7 Target: perp_market_map.rs, spot_market_map.rs Description The implementations for both PerpMarketMap and SpotMarketMap use hard-coded indices into the accounts data in order to retrieve the marked_index property without having to deserialize all the data. // market index 1160 bytes from front of account let market_index = u16 ::from_le_bytes(*array_ref![data, 1160 , 2 ]); Figure 7.1: programs/drift/src/state/perp_market_map.rs#L110–L111 let market_index = u16 ::from_le_bytes(*array_ref![data, 684 , 2 ]); Figure 7.2: programs/drift/src/state/spot_market_map.rs#L174 Exploit Scenario Alice, a Drift Protocol developer, changes the layout of the structure or the width of the market_index property but fails to update one or more of the hard-coded indices. Mallory notices this bug and ﬁnds a way to use it to steal funds. Recommendations Short term, add consts that include the value of the indices and the type size. Also add comments explaining the calculation of the values. This ensures that by updating the constants, all code relying on the operation will retrieve the correct part of the unlying data. Long term, add an implementation to the struct to unpack the market_index from the serialized state. This reduces the maintenance burden of updating the code that accesses data in this way. 
8. Missing veriﬁcation of maker and maker_stats accounts Severity: Undetermined Diﬃculty: Medium Type: Data Validation Finding ID: TOB-DRIFT-8 Target: programs/drift/src/instructions/user.rs Description The handle_place_and_take_perp_order and handle_place_and_take_spot_order functions retrieve two additional accounts that are passed to the instruction: maker and maker_stats . However, there is no check that the two accounts are linked (i.e., that their authority is the same). Due to time constraints, we were unable to determine the impact of this ﬁnding. pub fn get_maker_and_maker_stats <'a>( account_info_iter: & mut Peekable<Iter<AccountInfo<'a>>>, ) -> DriftResult <(AccountLoader<'a, User>, AccountLoader<'a, UserStats>)> { let maker_account_info = next_account_info(account_info_iter).or( Err (ErrorCode::MakerNotFound))?; validate!( maker_account_info.is_writable, ErrorCode::MakerMustBeWritable )?; let maker: AccountLoader <User> = AccountLoader::try_from(maker_account_info).or( Err (ErrorCode::CouldNotDeserializeMak er))?; let maker_stats_account_info = next_account_info(account_info_iter).or( Err (ErrorCode::MakerStatsNotFound))?; validate!( maker_stats_account_info.is_writable, ErrorCode::MakerStatsMustBeWritable )?; let maker_stats: AccountLoader <UserStats> = AccountLoader::try_from(maker_stats_account_info) .or( Err (ErrorCode::CouldNotDeserializeMakerStats))?; Ok ((maker, maker_stats)) } Figure 8.1: programs/drift/src/instructions/optional_accounts.rs#L47–L74 Exploit Scenario Mallory passes two unlinked accounts of the correct type in the places for maker and maker_stats , respectively. This causes the contract to operate outside of its intended use. Recommendations Short term, add a check that the authority of the accounts are the same. Long term, add all code for authentication of accounts to the front of instruction handlers. This increases the clarity of the checks and helps with auditing the authentication. 
9. Panics used for error handling Severity: Informational Diﬃculty: High Type: Error Reporting Finding ID: TOB-DRIFT-9 Target: Various ﬁles in programs/drift Description In several places, the code panics when an arithmetic overﬂow or underﬂow occurs. Panics should be reserved for programmer errors (e.g., assertion violations). Panicking on user errors dilutes the utility of the panic operation. An example appears in ﬁgure 9.1. The adjust_amm function uses both the question mark operator ( ? ) and unwrap to handle errors resulting from “peg” related calculations. An overﬂow or underﬂow could result from an invalid input to the function. An error should be returned in such cases. budget_delta_peg = budget_i128 .safe_add(adjustment_cost.abs())? .safe_mul(PEG_PRECISION_I128)? .safe_div(per_peg_cost)?; budget_delta_peg_magnitude = budget_delta_peg.unsigned_abs(); new_peg = if budget_delta_peg > 0 { ... } else if market.amm.peg_multiplier > budget_delta_peg_magnitude { market .amm .peg_multiplier .safe_sub(budget_delta_peg_magnitude) .unwrap() } else { 1 }; Figure 9.1: programs/drift/src/math/repeg.rs#L349–L369 Running Clippy with the following command identiﬁes 66 locations in the drift package where expect or unwrap is used: cargo clippy -p drift -- -A clippy::all -W clippy::expect_used -W clippy::unwrap_used Many of those uses appear to be related to invalid input. Exploit Scenario Alice, a Drift Protocol developer, observes a panic in the Drift Protocol codebase. Alice ignores the panic, believing that it is caused by user error, but it is actually caused by a bug she introduced. Recommendations Short term, reserve the use of panics for programmer errors. Have relevant areas of the code return Result::Err on user errors. Adopting such a policy will help to distinguish the two types of errors when they occur. Long term, consider denying the following Clippy lints: ● clippy::expect_used ● clippy::unwrap_used ● clippy::panic Although this will not prevent all panics, it will prevent many of them. 
10. Testing code used in production Severity: Undetermined Diﬃculty: Undetermined Type: Patching Finding ID: TOB-DRIFT-10 Target: programs/drift/src/state/{oracle_map.rs, perp_market.rs} Description In some locations in the Drift Protocol codebase, testing code is mixed with production code with no way to discern between them. Testing code should be clearly indicated as such and guarded by #[cfg(test)] to avoid being called in production. Examples appear in ﬁgures 10.1 and 10.2. The OracleMap struct has a quote_asset_price_data ﬁeld that is used only when get_price_data is passed a default Pubkey . Similarly, the AMM implementation contains functions that are used only for testing and are not guarded by #[cfg(test)] . pub struct OracleMap <'a> { oracles: BTreeMap <Pubkey, AccountInfoAndOracleSource<'a>>, price_data: BTreeMap <Pubkey, OraclePriceData>, pub slot: u64 , pub oracle_guard_rails: OracleGuardRails , pub quote_asset_price_data: OraclePriceData , } impl <'a> OracleMap<'a> { ... pub fn get_price_data (& mut self , pubkey: & Pubkey ) -> DriftResult <&OraclePriceData> { if pubkey == &Pubkey::default() { return Ok (& self .quote_asset_price_data); } Figure 10.1: programs/drift/src/state/oracle_map.rs#L22–L47 impl AMM { pub fn default_test () -> Self { let default_reserves = 100 * AMM_RESERVE_PRECISION; // make sure tests dont have the default sqrt_k = 0 AMM { Figure 10.2: programs/drift/src/state/perp_market.rs#L490–L494 Drift Protocol has indicated that the quote_asset_price_data ﬁeld (ﬁgure 10.1) is used in production. This raises concerns because there is currently no way to set the contents of this ﬁeld, and no asset’s price is perfectly constant (e.g., even stablecoins’ prices ﬂuctuate). For this reason, we have changed this ﬁnding’s severity from Informational to Undetermined. Exploit Scenario Alice, a Drift Protocol developer, introduces code that calls the default_test function, not realizing it is intended only for testing. Alice introduces a bug as a result. Recommendations Short term, to the extent possible, avoid mixing testing and production code by, for example, using separate data types and storing the code in separate ﬁles. When testing and production code must be mixed, clearly mark the testing code as such, and guard it with #[cfg(test)] . These steps will help to ensure that testing code is not deployed in production. Long term, as new code is added to the codebase, ensure that the aforementioned standards are maintained. Testing code is not typically held to the same standards as production code, so it is more likely to include bugs. 
11. Inconsistent use of checked arithmetic Severity: Undetermined Diﬃculty: Undetermined Type: Data Validation Finding ID: TOB-DRIFT-11 Target: Various ﬁles in programs/drift Description In several locations, the Drift Protocol codebase uses unchecked arithmetic. For example, in calculate_margin_requirement_and_total_collateral_and_liability_info (ﬁgure 11.1), the variable num_perp_liabilities is used as an operand in both a checked and an unchecked operation. To protect against overﬂows and underﬂows, unchecked arithmetic should be used sparingly. num_perp_liabilities += 1 ; } with_isolated_liability &= margin_requirement > 0 && market.contract_tier == ContractTier::Isolated; } if num_spot_liabilities > 0 { validate!( margin_requirement > 0 , ErrorCode::InvalidMarginRatio, "num_spot_liabilities={} but margin_requirement=0" , num_spot_liabilities )?; } let num_of_liabilities = num_perp_liabilities.safe_add(num_spot_liabilities) ?; Figure 11.1: programs/drift/src/math/margin.rs#L499–L515 Note that adding the following to the crate root will cause Clippy to fail the build whenever unchecked arithmetic is used: #![deny(clippy::integer_arithmetic)] Exploit Scenario Alice, a Drift Protocol developer, unwittingly introduces an arithmetic overﬂow bug into the codebase. The bug would have been revealed by the use of checked arithmetic. However, because unchecked arithmetic is used, the bug goes unnoticed. Recommendations Short term, add the #![deny(clippy::integer_arithmetic)] attribute to the drift crate root. Add #[allow(clippy::integer_arithmetic)] in rare situations where code is performance critical and its safety can be guaranteed through other means. Taking these steps will reduce the likelihood of overﬂow or underﬂow bugs residing in the codebase. Long term, if additional Solana programs are added to the codebase, ensure the #![deny(clippy::integer_arithmetic)] attribute is also added to them. This will reduce the likelihood that newly introduced crates contain overﬂow or underﬂow bugs. 
12. Inconsistent and incomplete exchange status checks Severity: Medium Diﬃculty: High Type: Access Controls Finding ID: TOB-DRIFT-12 Target: programs/drift/src/instructions/{admin.rs , keeper.rs , user.rs}, programs/drift/src/state/state.rs Description Drift Protocol’s representation of the exchange’s status has several problems: ● ● ● The exchange’s status is represented using an enum , which does not allow more than one individual operation to be paused (ﬁgures 12.1 and 12.2). As a result, an administrator could inadvertently unpause one operation by trying to pause another (ﬁgure 12.3). The ExchangeStatus variants do not map cleanly to exchange operations. For example, handle_transfer_deposit checks whether the exchange status is WithdrawPaused (ﬁgure 12.4). The function’s name suggests that the function checks whether “transfers” or “deposits” are paused. The ExchangeStatus is checked in multiple inconsistent ways. For example, in handle_update_funding_rate (ﬁgure 12.5), both an access_control attribute and the body of the function include a check for whether the exchange status is FundingPaused . pub enum ExchangeStatus { Active, FundingPaused, AmmPaused, FillPaused, LiqPaused, WithdrawPaused, Paused, } Figure 12.1: programs/drift/src/state/state.rs#L36–L44 #[account] #[derive(Default)] #[repr(C)] pub struct State { pub admin: Pubkey , pub whitelist_mint: Pubkey , ... pub exchange_status: ExchangeStatus , pub padding: [ u8 ; 17 ], } Figure 12.2: programs/drift/src/state/state.rs#L8–L33 pub fn handle_update_exchange_status ( ctx: Context <AdminUpdateState>, exchange_status: ExchangeStatus , ) -> Result <()> { ctx.accounts.state.exchange_status = exchange_status; Ok (()) } Figure 12.3: programs/drift/src/instructions/admin.rs#L1917–L1923 #[access_control( withdraw_not_paused (&ctx.accounts.state) )] pub fn handle_transfer_deposit ( ctx: Context <TransferDeposit>, market_index: u16 , amount: u64 , ) -> anchor_lang :: Result <()> { Figure 12.4: programs/drift/src/instructions/user.rs#L466–L473 #[access_control( market_valid(&ctx.accounts.perp_market) funding_not_paused (&ctx.accounts.state) valid_oracle_for_perp_market(&ctx.accounts.oracle, &ctx.accounts.perp_market) )] pub fn handle_update_funding_rate ( ctx: Context <UpdateFundingRate>, perp_market_index: u16 , ) -> Result <()> { ... let is_updated = controller::funding::update_funding_rate( perp_market_index, perp_market, & mut oracle_map, now, &state.oracle_guard_rails, matches! (state.exchange_status, ExchangeStatus::FundingPaused ), None , )?; ... } Figure 12.5: programs/drift/src/instructions/keeper.rs#L1027–L1078 The Medium post describing the incident that occurred around May 11, 2022 suggests that the exchange’s pausing mechanisms contributed to the incident’s subsequent fallout: The protocol did not have a kill-switch where only withdrawals were halted. The protocol was paused in the second pause to prevent a further drain of user funds… This suggests that the pausing mechanisms should receive heightened attention to reduce the damage should another incident occur. Exploit Scenario Mallory tricks an administrator into pausing funding after withdrawals have already been paused. By pausing funding, the administrator unwittingly unpauses withdrawals. Recommendations Short term: ● ● ● Represent the exchange’s status as a set of ﬂags. This will allow individual operations to be paused independently of one another. Ensure exchange statuses map cleanly to the operations that can be paused. Add documentation where there is potential for confusion. This will help ensure developers check the proper exchange statuses. Adopt a single approach for checking the exchange’s status and apply it consistently throughout the codebase. If an exception must be made for a check, explain why in a comment near that check. Adopting such a policy will reduce the likelihood that a missing check goes unnoticed. Long term, periodically review the exchange status checks. Since the exchange status checks represent a form of access control, they deserve heightened scrutiny. Moreover, the exchange’s pausing mechanisms played a role in past incidents. 
13. Spot market access controls are incomplete Severity: Informational Diﬃculty: Undetermined Type: Access Controls Finding ID: TOB-DRIFT-13 Target: programs/drift/src/instructions/{admin.rs , user.rs} Description Functions in admin.rs involving perpetual markets verify that the market is valid, i.e., not delisted (ﬁgure 13.1). However, functions involving spot markets do not include such checks (e.g., ﬁgure 13.2). Drift Protocol has indicated that the spot market implementation is incomplete. #[access_control( market_valid(&ctx.accounts.perp_market) )] pub fn handle_update_perp_market_expiry ( ctx: Context <AdminUpdatePerpMarket>, expiry_ts: i64 , ) -> Result <()> { Figure 13.1: programs/drift/src/instructions/admin.rs#L676–L682 _ pub fn handle_update_spot_market_expiry ( ctx: Context <AdminUpdateSpotMarket>, expiry_ts: i64 , ) -> Result <()> { Figure 13.2: programs/drift/src/instructions/admin.rs#L656–L660 A similar example concerning whether the exchange is paused appears in ﬁgure 13.3 and 13.4. #[access_control( exchange_not_paused(&ctx.accounts.state) )] pub fn handle_place_perp_order (ctx: Context <PlaceOrder>, params: OrderParams ) -> Result <()> { Figure 13.3: programs/drift/src/instructions/user.rs#L687–L690 _ pub fn handle_place_spot_order (ctx: Context <PlaceOrder>, params: OrderParams ) -> Result <()> { Figure 13.4: programs/drift/src/instructions/user.rs#L1022–L1023 Exploit Scenario Mallory tricks an administrator into making a call that re-enables an expiring spot market. Mallory proﬁts by trading against the should-be-expired spot market. Recommendations Short term, add the missing access controls to the spot market functions in admin.rs . This will ensure that an administrator cannot accidentally perform an operation on an expired spot market. Long term, add tests to verify that each function involving spot markets fails when invoked on an expired spot market. This will increase conﬁdence that the access controls have been implemented correctly. 
14. Oracles can be invalid in at most one way Severity: Informational Diﬃculty: High Type: Data Validation Finding ID: TOB-DRIFT-14 Target: programs/drift/src/math/oracle.rs Description The Drift Protocol codebase represents oracle validity using an enum , which does not allow an oracle to be invalid in more than one way. Furthermore, the code that determines an oracle’s validity imposes an implicit hierarchy on the ways an oracle could be invalid. This design is fragile and likely to cause future problems. The OracleValidity enum is shown in ﬁgure 14.1, and the code that determines an oracle’s validity is shown in ﬁgure 14.2. Note that if an oracle is, for example, both “too volatile” and “too uncertain,” the oracle will be labeled simply TooVolatile . A caller that does not account for this fact and simply checks whether an oracle is TooUncertain could overlook oracles that are both “too volatile” and “too uncertain.” pub enum OracleValidity { Invalid, TooVolatile, TooUncertain, StaleForMargin, InsufficientDataPoints, StaleForAMM, Valid, } Figure 14.1: programs/drift/src/math/oracle.rs#L21–L29 pub fn oracle_validity ( last_oracle_twap: i64 , oracle_price_data: & OraclePriceData , valid_oracle_guard_rails: & ValidityGuardRails , ) -> DriftResult <OracleValidity> { ... let oracle_validity = if is_oracle_price_nonpositive { OracleValidity::Invalid } else if is_oracle_price_too_volatile { OracleValidity::TooVolatile } else if is_conf_too_large { OracleValidity::TooUncertain } else if is_stale_for_margin { OracleValidity::StaleForMargin } else if !has_sufficient_number_of_data_points { OracleValidity::InsufficientDataPoints } else if is_stale_for_amm { OracleValidity::StaleForAMM } else { OracleValidity::Valid }; Ok (oracle_validity) } Figure 14.2: programs/drift/src/math/oracle.rs#L163–L230 Exploit Scenario Alice, a Drift Protocol developer, is unaware of the implicit hierarchy among the OracleValidity variants. Alice writes code like oracle_validity != OracleValidity::TooUncertain and unknowingly introduces a bug into the codebase. Recommendations Short term, represent oracle validity as a set of ﬂags. This will allow oracles to be invalid in more than one way, which will result in more robust and maintainable code. Long term, thoroughly test all code that relies on oracle validity. This will help ensure the code’s correctness following the aforementioned change. 
15. Code duplication Severity: Informational Diﬃculty: High Type: Patching Finding ID: TOB-DRIFT-15 Target: Various ﬁles in programs/drift Description Various ﬁles in the programs/drift directory contain duplicate code, which can lead to incomplete ﬁxes or inconsistent behavior (e.g., because the code is modiﬁed in one location but not all). As an example, the code in ﬁgure 15.1 appears nearly verbatim in the functions liquidate_perp , liquidate_spot , liquidate_borrow_for_perp_pnl , and liquidate_perp_pnl_for_deposit . // check if user exited liquidation territory let (intermediate_total_collateral, intermediate_margin_requirement_with_buffer) = if !canceled_order_ids.is_empty() || lp_shares > 0 { ... // 37 lines ( intermediate_total_collateral, intermediate_margin_requirement_plus_buffer, ) } else { (total_collateral, margin_requirement_plus_buffer) }; Figure 15.1: programs/drift/src/controller/liquidation.rs#L201–L246 In some places, the text itself is not obviously duplicated, but the logic it implements is clearly duplicated. An example appears in ﬁgures 15.2 and 15.3. Such “logical” code duplication suggests the code does not use the right abstractions. // Update Market open interest if let PositionUpdateType::Open = update_type { if position.quote_asset_amount == 0 && position.base_asset_amount == 0 { market.number_of_users = market.number_of_users.safe_add( 1 )?; } market.number_of_users_with_base = market.number_of_users_with_base.safe_add( 1 )?; } else if let PositionUpdateType::Close = update_type { if new_base_asset_amount == 0 && new_quote_asset_amount == 0 { market.number_of_users = market.number_of_users.safe_sub( 1 )?; } market.number_of_users_with_base = market.number_of_users_with_base.safe_sub( 1 )?; } Figure 15.2: programs/drift/src/controller/position.rs#L162–L175 if position.quote_asset_amount == 0 && position.base_asset_amount == 0 { market.number_of_users = market.number_of_users.safe_add( 1 )?; } position.quote_asset_amount = position.quote_asset_amount.safe_add(delta)?; market.amm.quote_asset_amount = market.amm.quote_asset_amount.safe_add(delta.cast()?)?; if position.quote_asset_amount == 0 && position.base_asset_amount == 0 { market.number_of_users = market.number_of_users.safe_sub( 1 )?; } Figure 15.3: programs/drift/src/controller/position.rs#L537–L547 Exploit Scenario Alice, a Drift Protocol developer, is asked to ﬁx a bug in liquidate_perp . Alice does not realize that the bug also applies to liquidate_spot , liquidate_borrow_for_perp_pnl , and liquidate_perp_pnl_for_deposit , and ﬁxes the bug in only liquidate_perp . Eve discovers that the bug is not ﬁxed in one of the other three functions and exploits it. Recommendations Short term: ● ● Refactor liquidate_perp , liquidate_spot , liquidate_borrow_for_perp_pnl , and liquidate_perp_pnl_for_deposit to eliminate the code duplication. This will reduce the likelihood of an incomplete ﬁx for a bug aﬀecting more than one of these functions. Identify cases where the code uses the same logic, and implement abstractions to capture that logic. Ensure that code that relies on such logic uses the new abstractions. Consolidating similar pieces of code will make the overall codebase easier to reason about. Long term, adopt code practices that discourage code duplication. This will help to prevent this problem from recurring. 
16. Inconsistent use of integer types Severity: Informational Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-DRIFT-16 Target: Various ﬁles in programs/drift Description The Drift Protocol codebase uses integer types inconsistently; data of similar kinds is represented using diﬀerently sized types or types with diﬀerent signedness. Conversions from one integer type to another present an opportunity for the contracts to fail and should be avoided. For example, the pow method expects a u32 argument. However, in some places u128 values must be cast to u32 values, even though those values are intended to be used as exponents (ﬁgures 16.1, 16.2, and 16.3). let expo_diff = (spot_market.insurance_fund.shares_base - insurance_fund_stake.if_base) . cast::< u32 >() ?; let rebase_divisor = 10_ u128 .pow(expo_diff); Figure 16.1: programs/drift/src/controller/insurance.rs#L154–L157 #[zero_copy] #[derive(Default, Eq, PartialEq, Debug)] #[repr(C)] pub struct InsuranceFund { pub vault: Pubkey , pub total_shares: u128 , pub user_shares: u128 , pub shares_base: u128 , pub unstaking_period: i64 , // if_unstaking_period pub last_revenue_settle_ts: i64 , pub revenue_settle_period: i64 , pub total_factor: u32 , // percentage of interest for total insurance pub user_factor: u32 , // percentage of interest for user staked insurance // exponent for lp shares (for rebasing) } Figure 16.2: programs/drift/src/state/spot_market.rs#L352–L365 #[account(zero_copy)] #[derive(Default, Eq, PartialEq, Debug)] #[repr(C)] pub struct InsuranceFundStake { pub authority: Pubkey , if_shares: u128 , pub last_withdraw_request_shares: u128 , // get zero as 0 when not in escrow pub if_base: u128 , // exponent for if_shares decimal places (for rebase) pub last_valid_ts: i64 , pub last_withdraw_request_value: u64 , pub last_withdraw_request_ts: i64 , pub cost_basis: i64 , pub market_index: u16 , pub padding: [ u8 ; 14 ], } Figure 16.3: programs/drift/src/state/insurance_fund_stake.rs#L10–L24 The following command reveals 689 locations where the cast method appears to be used: grep -r -I '\.cast\>' programs/drift Each such use could lead to a denial of service if an attacker puts the contract into a state where the cast always errors. Many of these uses could be eliminated by more consistent use of integer types. Note that Drift Protocol has indicated that some of the observed inconsistencies are related to reducing rent costs. Exploit Scenario Mallory manages to put the contract into a state such that one of the nearly 700 uses of cast always returns an error. The contract becomes unusable for Alice, who needs to execute a code path involving the vulnerable cast . Recommendations Short term, review all uses of cast to see which might be eliminated by changing the types of the operands. This will reduce the overall number of cast s and reduce the likelihood that one could lead to denial of service. Long term, as new code is introduced into the codebase, review the types used to hold similar kinds of data. This will reduce the likelihood that new cast s are needed. 
17. Use of opaque constants in tests Severity: Informational Diﬃculty: High Type: Testing Finding ID: TOB-DRIFT-17 Target: programs/drift/src/controller/liquidation/tests.rs Description Several of the Drift Protocol tests use constants with no explanation for how they were derived, which makes it diﬃcult to assess whether the tests are functioning correctly. Ten examples appear in ﬁgure 17.1. In each case, a variable or ﬁeld is compared against a constant consisting of 6–12 random-looking digits. Without an explanation for how these digits were obtained, it is diﬃcult to tell whether the constant expresses the correct value. assert_eq! (user.spot_positions[ 0 ].scaled_balance, 45558159000 ); assert_eq! (user.spot_positions[ 1 ].scaled_balance, 406768999 ); ... assert_eq! (margin_requirement, 44744590 ); assert_eq! (total_collateral, 45558159 ); assert_eq! (margin_requirement_plus_buffer, 45558128 ); ... assert_eq! (token_amount, 406769 ); assert_eq! (token_value, 40676900 ); assert_eq! (strict_token_value_1, 4067690 ); // if oracle price is more favorable than twap ... assert_eq! (liquidator.spot_positions[ 0 ].scaled_balance, 159441841000 ); ... assert_eq! (liquidator.spot_positions[ 1 ].scaled_balance, 593824001 ); Figure 17.1: programs/drift/src/controller/liquidation/tests.rs#L1618–L1687 Exploit Scenario Mallory discovers that a constant used in a Drift Protocol test was incorrectly derived and that the tests were actually verifying incorrect behavior. Mallory uses the bug to siphon funds from the Drift Protocol exchange. Recommendations Short term, where possible, compute values using an explicit formula rather than an opaque constant. If using an explicit formula is not possible, include a comment explaining how the constant was derived. This will help to ensure that correct behavior is being tested for. Moreover, the process of giving such explicit formulas could reveal errors. Long term, write scripts to identify constants with high entropy, and run those scripts as part of your CI process. This will help to ensure the aforementioned standards are maintained. 
18. Accounts from contexts are not always used by the instruction Severity: Informational Diﬃculty: High Type: Access Controls Finding ID: TOB-DRIFT-18 Target: programs/drift/src/instructions/admin.rs Description The context deﬁnition for the initialize instruction deﬁnes a drift_signer account. However, this account is not used by the instruction. It appears to be a remnant used to pass the address of the state PDA account; however, the need to do this was eliminated by the use of find_program_address to calculate the address. Also, in the initialize_insurance_fund_stake instruction, the spot_market , user_stats , and state accounts from the context are not used by the instruction. #[derive(Accounts)] pub struct Initialize <'info> { #[account(mut)] pub admin: Signer <'info>, #[account( init, seeds = [b "drift_state" .as_ref()], space = std::mem::size_of::<State>() + 8, bump, payer = admin )] pub state: Box <Account<'info, State>>, pub quote_asset_mint: Box <Account<'info, Mint>>, /// CHECK: checked in `initialize` pub drift_signer: AccountInfo <'info>, pub rent: Sysvar <'info, Rent>, pub system_program: Program <'info, System>, pub token_program: Program <'info, Token>, } Figure 18.1: programs/drift/src/instructions/admin.rs#L1989–L2007 Exploit Scenario Alice, a Drift Protocol developer, assumes that the drift_signer account is used by the instruction, and she uses a diﬀerent address for the account, expecting this account to hold the contract state after the initialize instruction has been called. Recommendations Short term, remove the unused account from the context. This eliminates the possibility of confusion around the use of the accounts. Long term, employ a process where a refactoring of an instruction’s code is followed by a review of the corresponding context deﬁnition. This ensures that the context is in sync with the instruction handlers. 
19. Unaligned references are allowed Severity: Informational Diﬃculty: High Type: Undeﬁned Behavior Finding ID: TOB-DRIFT-19 Target: programs/drift/src/lib.rs Description The Drift Protocol codebase uses the #![allow(unaligned_references)] attribute. This allows the use of unaligned references throughout the program and could mask serious problems in future updates to the contract. #![allow(clippy::too_many_arguments)] #![allow(unaligned_references)] #![allow(clippy::bool_assert_comparison)] #![allow(clippy::comparison_chain)] Figure 19.1: programs/drift/src/lib.rs#L1–L4 Exploit Scenario Alice, a Drift Protocol developer, accidentally introduces errors caused by the use of unaligned references, aﬀecting the contract operation and leading to a loss of funds. Recommendations Short term, remove the attributes. This ensures that the check for unaligned references correctly ﬂag such cases. Long term, be conservative with the use of attributes used to suppress warnings or errors throughout the codebase. If possible, apply them to only the minimum possible amount of code. This minimizes the risk of problems stemming from the suppressed checks. 
20. Size of created accounts derived from in-memory representation Severity: Informational Diﬃculty: High Type: Conﬁguration Finding ID: TOB-DRIFT-20 Target: Files in /programs/drift/src/state/ Description When state accounts are initialized, the size of the account is set to std::mem::size_of::<ACCOUNT_TYPE>() + 8 , where the eight extra bytes are used for the discriminator. The structs for the state types all have a trailing ﬁeld with padding, seemingly to ensure the account size is aligned to eight bytes and to determine the size of the account. In other places, the code relies on the size_of function to determine the type of accounts passed to the instruction. While we could not ﬁnd any security-related problem with the scheme today, this does mean that every account’s in-memory representation is inﬂated by the amount of padding, which could become a problem with respect to the limitation of the stack or heap size. Furthermore, if any of the accounts are updated in such a way that the repr(C) layout size diﬀers from the Anchor space reference , it could cause a problem. For example, if the SpotMarket struct is changed so that its in-memory representation is smaller than the required Anchor size, the initialize_spot_market would fail because the created account would be too small to hold the serialized representation of the data. #[account] #[derive(Default)] #[repr(C)] pub struct State { pub admin: Pubkey , pub whitelist_mint: Pubkey , pub discount_mint: Pubkey , pub signer: Pubkey , pub srm_vault: Pubkey , pub perp_fee_structure: FeeStructure , pub spot_fee_structure: FeeStructure , pub oracle_guard_rails: OracleGuardRails , pub number_of_authorities: u64 , pub number_of_sub_accounts: u64 , pub lp_cooldown_time: u64 , pub liquidation_margin_buffer_ratio: u32 , pub settlement_duration: u16 , pub number_of_markets: u16 , pub number_of_spot_markets: u16 , pub signer_nonce: u8 , pub min_perp_auction_duration: u8 , pub default_market_order_time_in_force: u8 , pub default_spot_auction_duration: u8 , pub exchange_status: ExchangeStatus , pub padding : [ u8 ; 17 ], } Figure 20.1: The State struct, with corresponding padding #[account( init, seeds = [b "drift_state" .as_ref()], space = std::mem::size_of::<State>() + 8 , bump, payer = admin )] pub state: Box <Account<'info, State>>, Figure 20.2: The creation of the State account, using the in-memory size if data.len() < std::mem::size_of::<UserStats>() + 8 { return Ok (( None , None )); } Figure 20.3: An example of the in-memory size used to determine the account type Exploit Scenario Alice, a Drift Protocol developer, unaware of the implicit requirements of the in-memory size, makes changes to a state account’s structure or adds a state structure account such that the in-memory size is smaller than the size needed for the serialized data. As a result, instructions in the contract that save data to the account will fail. Recommendations Short term, add an implementation to each state struct that returns the size to be used for the corresponding Solana account. This avoids the overhead of the padding and removes the dependency on assumption about the in-memory size. Long term, avoid using assumptions about in-memory representation of type within programs created in Rust. This ensures that changes to the representation do not aﬀect the program's operation. 
