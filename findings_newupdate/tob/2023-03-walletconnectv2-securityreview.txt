1. Use of outdated dependencies Severity: Informational Diﬃculty: Undetermined Type: Patching Finding ID: TOB-WCSDK-1 Target: walletconnect-monorepo , walletconnect-utils Description We used npm audit and lerna-audit to detect the use of outdated dependencies in the codebase. These tools discovered a number of vulnerable packages that are referenced by the package-lock.json ﬁles. The following tables describe the vulnerable dependencies used in the walletconnect-utils and walletconnect-monorepo repositories : walletconnect-utils Dependencies Vulnerability Report Vulnerability Description Vulnerable Versions glob-parent CVE-2020-28469 Regular expression denial of service in enclosure regex < 5.1.2 minimatch CVE-2022-3517 Regular expression denial of service when calling the braceExpand function with speciﬁc arguments < 3.0.5 nanoid CVE-2021-23566 Exposure of sensitive information to an unauthorized actor in nanoid 3.0.0–3.1. walletconnect-monorepo Dependencies Vulnerability Report Vulnerability Description Vulnerable Versions flat CVE-2020-36632 flat vulnerable to prototype pollution minimatch CVE-2022-3517 request CVE-2023-28155 Regular expression denial of service when calling the braceExpand function with speciﬁc arguments Bypass of SSRF mitigations via an attacker-controller server that does a cross-protocol redirect (HTTP to HTTPS, or HTTPS to HTTP) < 5.0.1 < 3.0.5 <= 2.88.2 In many cases, the use of a vulnerable dependency does not necessarily mean the application is vulnerable. Vulnerable methods from such packages need to be called within a particular (exploitable) context. To determine whether the WalletConnect SDK is vulnerable to these issues, each issue will have to be manually triaged. While these speciﬁc libraries were outdated at the time of the review, there were already checks in place as part of the CI/CD pipeline of application development of WalletConnect to keep track of these issues. Recommendations Short term, update the project dependencies to their latest versions wherever possible. Use tools such as retire.js , npm audit , and yarn audit to conﬁrm that no vulnerable dependencies remain. 
2. No protocol-level replay protections in WalletConnect Severity: Undetermined Diﬃculty: High Type: Cryptography Finding ID: TOB-WCSDK-2 Target: WalletConnect v2 protocol Description Applications and wallets using WalletConnect v2 can exchange messages using the WalletConnect protocol through a public WebSocket relay server. Exchanged data is encrypted and authenticated with keys unknown to the relay server. However, using dynamic testing during the audit, we observed that the protocol does not protect against replay attacks. The WalletConnect authentication protocol is essentially a challenge-response protocol between users and servers, where users produce signatures using the private keys from their wallets. A signature is performed over a message containing, among many other components, a nonce value chosen by the server. This nonce value is intended presumably to prevent an adversary from replaying an old signature that a user generated to authenticate themselves. However, there does not seem to be any validation against this nonce value (except validation that it exists), so the library would accept replayed signatures. In addition to missing validation of the nonce value, the payload for the signature does not appear to include the pairing topic for the pairing established between a user and the server. Because the authentication protocol runs only over an existing pairing, it would make sense to include the pairing topic value inside the signature payload. Doing so would prevent a malicious user from replaying another user’s previously generated signature for a new pairing that they establish with the server. To repeat our experiment that uncovered this issue, pair the React App demo application with the React Wallet demo application and intercept the traﬃc generated from the React App demo application (e.g., use a local proxy such as BurpSuite). Initiate a transaction from the application, capture the data sent through the WebSocket channel, and conﬁrm the transaction in the wallet. A sample captured message is shown in ﬁgure 2.1. Now, edit the message ﬁeld slightly and add “==” to the end of the string (“=” is the Base64 padding character). Finally, replay (resend) the captured data. A new conﬁrmation dialog box should appear in the wallet. { "id" : 1680643717702847 , "jsonrpc" : "2.0" , "method" : "irn_publish" , "params" : { "topic" : "42507dee006fe8(...)2d797cccf8c71fa9de4" , "message" : "AFv70BclFEn6MteTRFemaxD7Q7(...)y/eAPv3ETRHL0x86cJ6iflkIww" , "ttl" : 300 , "prompt" : true , "tag" : 1108 } } Figure 2.1: A sample message sent from the dApp This ﬁnding is of undetermined severity because it is not obvious whether and how an attacker could use this vulnerability to impact users. When this ﬁnding was originally presented to the WalletConnect team, the recommended remediation was to track and enforce the correct nonce values. However, due to the distributed nature of the WalletConnect system, this could prove diﬃcult in practice. In response, we have updated our recommendation to use timestamps instead. Timestamps are not as eﬀective as nonces are for preventing replay attacks because it is not always possible to have a secure clock that can be relied upon. However, if nonces are infeasible to implement, timestamps are the next best option. Recommendations Short term, update the implementation of the authentication protocol to include timestamps in the signature payload that are then checked against the current time (within a reasonable window of time) upon signature validation. In addition to this, include the pairing topic in the signature payload. Long term, consider including all relevant pairing and authentication data in the signature payload, such as sender and receiver public keys. If possible, consider using nonces instead of timestamps to more eﬀectively prevent replay attacks. 
3. Key derivation code could produce keys composed of all zeroes Severity: Informational Diﬃculty: High Type: Cryptography Finding ID: TOB-WCSDK-3 Target: walletconnect-monorepo/packages/utils/src/crypto.ts Description The current implementation of the code that derives keys using the x25519 library does not enable the rejectZero option. If the counterparty is compromised, this may result in a derived key composed of all zeros, which could allow an attacker to observe or tamper with the communication. export function deriveSymKey(privateKeyA: string , publicKeyB: string ): string { const sharedKey = x25519.sharedKey( fromString(privateKeyA, BASE16), fromString(publicKeyB, BASE16), ); const hkdf = new HKDF(SHA256, sharedKey); const symKey = hkdf.expand(KEY_LENGTH); return toString(symKey, BASE16); } Figure 3.1: The code that derives keys using x25519.sharedKey ( walletconnect-monorepo/packages/utils/src/crypto.ts#35–43 ) The x25519 library includes a warning about this case: /** * Returns a shared key between our secret key and a peer's public key. * * Throws an error if the given keys are of wrong length. * * If rejectZero is true throws if the calculated shared key is all-zero . * From RFC 7748: * * > Protocol designers using Diffie-Hellman over the curves defined in * > this document must not assume "contributory behavior". Specially, * > contributory behavior means that both parties' private keys * > contribute to the resulting shared key. Since curve25519 and * > curve448 have cofactors of 8 and 4 (respectively), an input point of * > small order will eliminate any contribution from the other party's * > private key. This situation can be detected by checking for the all- * > zero output, which implementations MAY do, as specified in Section 6. * > However, a large number of existing implementations do not do this. * * IMPORTANT: the returned key is a raw result of scalar multiplication. * To use it as a key material, hash it with a cryptographic hash function. */ Figure 3.2: Warnings in x25519.sharedKey ( stablelib/packages/x25519/x25519.ts#595–615 ) This ﬁnding is of informational severity because a compromised counterparty would already allow an attacker to observe or tamper with the communication. Exploit Scenario An attacker compromises the web server on which a dApp is hosted and introduces malicious code in the front end that makes it always provide a low-order point during the key exchange. When a user connects to this dApp with their WalletConnect-enabled wallet, the derived key is all zeros. The attacker passively captures and reads the exchanged messages. Recommendations Short term, enable the rejectZero ﬂag for uses of the deriveSymKey function. Long term, when using cryptographic primitives, research any edge cases they may have and always review relevant implementation notes. Follow recommended practices and include any defense-in-depth safety checks to ensure the protocol operates as intended. 
1. Use of outdated dependencies Severity: Informational Diﬃculty: Undetermined Type: Patching Finding ID: TOB-WCSDK-1 Target: walletconnect-monorepo , walletconnect-utils Description We used npm audit and lerna-audit to detect the use of outdated dependencies in the codebase. These tools discovered a number of vulnerable packages that are referenced by the package-lock.json ﬁles. The following tables describe the vulnerable dependencies used in the walletconnect-utils and walletconnect-monorepo repositories : walletconnect-utils Dependencies Vulnerability Report Vulnerability Description Vulnerable Versions glob-parent CVE-2020-28469 Regular expression denial of service in enclosure regex < 5.1.2 minimatch CVE-2022-3517 Regular expression denial of service when calling the braceExpand function with speciﬁc arguments < 3.0.5 nanoid CVE-2021-23566 Exposure of sensitive information to an unauthorized actor in nanoid 3.0.0–3.1. walletconnect-monorepo Dependencies Vulnerability Report Vulnerability Description Vulnerable Versions flat CVE-2020-36632 flat vulnerable to prototype pollution minimatch CVE-2022-3517 request CVE-2023-28155 Regular expression denial of service when calling the braceExpand function with speciﬁc arguments Bypass of SSRF mitigations via an attacker-controller server that does a cross-protocol redirect (HTTP to HTTPS, or HTTPS to HTTP) < 5.0.1 < 3.0.5 <= 2.88.2 In many cases, the use of a vulnerable dependency does not necessarily mean the application is vulnerable. Vulnerable methods from such packages need to be called within a particular (exploitable) context. To determine whether the WalletConnect SDK is vulnerable to these issues, each issue will have to be manually triaged. While these speciﬁc libraries were outdated at the time of the review, there were already checks in place as part of the CI/CD pipeline of application development of WalletConnect to keep track of these issues. Recommendations Short term, update the project dependencies to their latest versions wherever possible. Use tools such as retire.js , npm audit , and yarn audit to conﬁrm that no vulnerable dependencies remain. 
2. No protocol-level replay protections in WalletConnect Severity: Undetermined Diﬃculty: High Type: Cryptography Finding ID: TOB-WCSDK-2 Target: WalletConnect v2 protocol Description Applications and wallets using WalletConnect v2 can exchange messages using the WalletConnect protocol through a public WebSocket relay server. Exchanged data is encrypted and authenticated with keys unknown to the relay server. However, using dynamic testing during the audit, we observed that the protocol does not protect against replay attacks. The WalletConnect authentication protocol is essentially a challenge-response protocol between users and servers, where users produce signatures using the private keys from their wallets. A signature is performed over a message containing, among many other components, a nonce value chosen by the server. This nonce value is intended presumably to prevent an adversary from replaying an old signature that a user generated to authenticate themselves. However, there does not seem to be any validation against this nonce value (except validation that it exists), so the library would accept replayed signatures. In addition to missing validation of the nonce value, the payload for the signature does not appear to include the pairing topic for the pairing established between a user and the server. Because the authentication protocol runs only over an existing pairing, it would make sense to include the pairing topic value inside the signature payload. Doing so would prevent a malicious user from replaying another user’s previously generated signature for a new pairing that they establish with the server. To repeat our experiment that uncovered this issue, pair the React App demo application with the React Wallet demo application and intercept the traﬃc generated from the React App demo application (e.g., use a local proxy such as BurpSuite). Initiate a transaction from the application, capture the data sent through the WebSocket channel, and conﬁrm the transaction in the wallet. A sample captured message is shown in ﬁgure 2.1. Now, edit the message ﬁeld slightly and add “==” to the end of the string (“=” is the Base64 padding character). Finally, replay (resend) the captured data. A new conﬁrmation dialog box should appear in the wallet. { "id" : 1680643717702847 , "jsonrpc" : "2.0" , "method" : "irn_publish" , "params" : { "topic" : "42507dee006fe8(...)2d797cccf8c71fa9de4" , "message" : "AFv70BclFEn6MteTRFemaxD7Q7(...)y/eAPv3ETRHL0x86cJ6iflkIww" , "ttl" : 300 , "prompt" : true , "tag" : 1108 } } Figure 2.1: A sample message sent from the dApp This ﬁnding is of undetermined severity because it is not obvious whether and how an attacker could use this vulnerability to impact users. When this ﬁnding was originally presented to the WalletConnect team, the recommended remediation was to track and enforce the correct nonce values. However, due to the distributed nature of the WalletConnect system, this could prove diﬃcult in practice. In response, we have updated our recommendation to use timestamps instead. Timestamps are not as eﬀective as nonces are for preventing replay attacks because it is not always possible to have a secure clock that can be relied upon. However, if nonces are infeasible to implement, timestamps are the next best option. Recommendations Short term, update the implementation of the authentication protocol to include timestamps in the signature payload that are then checked against the current time (within a reasonable window of time) upon signature validation. In addition to this, include the pairing topic in the signature payload. Long term, consider including all relevant pairing and authentication data in the signature payload, such as sender and receiver public keys. If possible, consider using nonces instead of timestamps to more eﬀectively prevent replay attacks. 
3. Key derivation code could produce keys composed of all zeroes Severity: Informational Diﬃculty: High Type: Cryptography Finding ID: TOB-WCSDK-3 Target: walletconnect-monorepo/packages/utils/src/crypto.ts Description The current implementation of the code that derives keys using the x25519 library does not enable the rejectZero option. If the counterparty is compromised, this may result in a derived key composed of all zeros, which could allow an attacker to observe or tamper with the communication. export function deriveSymKey(privateKeyA: string , publicKeyB: string ): string { const sharedKey = x25519.sharedKey( fromString(privateKeyA, BASE16), fromString(publicKeyB, BASE16), ); const hkdf = new HKDF(SHA256, sharedKey); const symKey = hkdf.expand(KEY_LENGTH); return toString(symKey, BASE16); } Figure 3.1: The code that derives keys using x25519.sharedKey ( walletconnect-monorepo/packages/utils/src/crypto.ts#35–43 ) The x25519 library includes a warning about this case: /** * Returns a shared key between our secret key and a peer's public key. * * Throws an error if the given keys are of wrong length. * * If rejectZero is true throws if the calculated shared key is all-zero . * From RFC 7748: * * > Protocol designers using Diffie-Hellman over the curves defined in * > this document must not assume "contributory behavior". Specially, * > contributory behavior means that both parties' private keys * > contribute to the resulting shared key. Since curve25519 and * > curve448 have cofactors of 8 and 4 (respectively), an input point of * > small order will eliminate any contribution from the other party's * > private key. This situation can be detected by checking for the all- * > zero output, which implementations MAY do, as specified in Section 6. * > However, a large number of existing implementations do not do this. * * IMPORTANT: the returned key is a raw result of scalar multiplication. * To use it as a key material, hash it with a cryptographic hash function. */ Figure 3.2: Warnings in x25519.sharedKey ( stablelib/packages/x25519/x25519.ts#595–615 ) This ﬁnding is of informational severity because a compromised counterparty would already allow an attacker to observe or tamper with the communication. Exploit Scenario An attacker compromises the web server on which a dApp is hosted and introduces malicious code in the front end that makes it always provide a low-order point during the key exchange. When a user connects to this dApp with their WalletConnect-enabled wallet, the derived key is all zeros. The attacker passively captures and reads the exchanged messages. Recommendations Short term, enable the rejectZero ﬂag for uses of the deriveSymKey function. Long term, when using cryptographic primitives, research any edge cases they may have and always review relevant implementation notes. Follow recommended practices and include any defense-in-depth safety checks to ensure the protocol operates as intended. 
4. Insecure storage of session data in local storage Severity: Medium Diﬃculty: High Type: Data Exposure Finding ID: TOB-WCSDK-4 Target: Browser storage Description HTML5 local storage is used to hold session data, including keychain values. Because there are no access controls on modifying and retrieving this data using JavaScript, data in local storage is vulnerable to XSS attacks. Figure 4.1: Keychain data stored in a browser’s localStorage Exploit Scenario Alice discovers an XSS vulnerability in a dApp that supports WalletConnect. This vulnerability allows Alice to retrieve the dApp’s keychain data, allowing her to propose new transactions to the connected wallet. Recommendations Short term, consider using cookies to store and send tokens. Enable cross-site request forgery (CSRF) libraries available to mitigate these attacks. Ensure that cookies are tagged with httpOnly , and preferably secure , to ensure that JavaScript cannot access them. References ● OWASP HTML5 Security Cheat Sheet: Local Storage A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diﬃculty levels used in this document. Vulnerability Categories Category Description Access Controls Insuﬃcient authorization or assessment of rights Auditing and Logging Insuﬃcient auditing of actions or logging of problems Authentication Improper identiﬁcation of users Conﬁguration Misconﬁgured servers, devices, or software components Cryptography A breach of system conﬁdentiality or integrity Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service A system failure with an availability impact Error Reporting Insecure or insuﬃcient reporting of error conditions Patching Use of an outdated software package or library Session Management Improper identiﬁcation of authenticated users Testing Timing Insuﬃcient test methodology or test coverage Race conditions or other order-of-operations ﬂaws Undeﬁned Behavior Undeﬁned behavior triggered within the system Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices. Undetermined The extent of the risk was not determined during this engagement. Low The risk is small or is not one the client has indicated is important. Medium High User information is at risk; exploitation could pose reputational, legal, or moderate ﬁnancial risks. The ﬂaw could aﬀect numerous users and have serious reputational, legal, or ﬁnancial implications. Diﬃculty Levels Diﬃculty Description Undetermined The diﬃculty of exploitation was not determined during this engagement. Low Medium High The ﬂaw is well known; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of the system. An attacker must have privileged access to the system, may need to know complex technical details, or must discover other weaknesses to exploit this issue. B. Code Maturity Categories The following tables describe the code maturity categories and rating criteria used in this document. Code Maturity Categories Category Description Arithmetic The proper use of mathematical operations and semantics Auditing The use of event auditing and logging to support monitoring Authentication / Access Controls The use of robust access controls to handle identiﬁcation and authorization and to ensure safe interactions with the system Complexity Management The presence of clear structures designed to manage system complexity, including the separation of system logic into clearly deﬁned functions Conﬁguration The conﬁguration of system components in accordance with best practices Cryptography and Key Management The safe use of cryptographic primitives and functions, along with the presence of robust mechanisms for key generation and distribution Data Handling The safe handling of user inputs and data processed by the system Documentation The presence of comprehensive and readable codebase documentation Maintenance The timely maintenance of system components to mitigate risk Memory Safety and Error Handling The presence of memory safety and robust error-handling mechanisms Testing and Veriﬁcation The presence of robust testing procedures (e.g., unit tests, integration tests, and veriﬁcation methods) and suﬃcient test coverage Rating Criteria Rating Strong Description No issues were found, and the system exceeds industry standards. Satisfactory Minor issues were found, but the system is compliant with best practices. Moderate Some issues that may aﬀect system safety were found. Weak Many issues that aﬀect system safety were found. Missing A required component is missing, signiﬁcantly aﬀecting system safety. Not Applicable The category is not applicable to this review. Not Considered The category was not considered in this review. Further Investigation Required Further investigation is required to reach a meaningful conclusion. 
