M1 Potential out of gas situation in RewardDistributor and DecollateralisationManager contract STATUS DISMISSED The RewardsDistributor::getAllUnclaimedRewardAmountsForUserAndAsset() function performs a nested loop that iterates over all possible rewards for all amounts staked by a given user. Since both of these amounts are potentially unbounded, an out of gas error may eventually occur. //RewardsDistributor.sol::getAllUnclaimedRewardAmountsForUserAndAsset function getAllUnclaimedRewardAmountsForUserAndAssets( address[] calldata assets, address user external view override returns (address[] memory rewardsList, uint[] memory unclaimedAmounts) RewardsDataTypes.AssetStakedAmounts[] memory assetStakedAmounts = _getAssetStakedAmounts(assets,user); rewardsList = new address[](_rewardsList.length); unclaimedAmounts = new uint[](rewardsList.length); ) {  for (uint i; i < assetStakedAmounts.length; i++) { for (uint r; r < rewardsList.length; r++) { rewardsList[r] = _rewardsList[r]; unclaimedAmounts[r] += _assetData[assetStakedAmounts[i].asset] .rewardDistribution[rewardsList[r]] .userReward[user] .accrued; if (assetStakedAmounts[i].userStake == 0) { continue; } unclaimedAmounts[r] += _computePendingRewardAmountForUser( user, rewardsList[r], assetStakedAmounts[i] ); } } return (rewardsList, unclaimedAmounts); } Similarly, the function getBatchesDecollateralisationInfo() of the contract DecollateralisationManager loops over all batchIds, the number of which could be unbounded. As already mentioned, this might eventually lead to an out of gas failure. //DecollateralisationManger.sol::getBatchesDecollateralisationInfo() function getBatchesDecollateralizationInfo( SolidWorldManagerStorage.Storage storage _storage, uint projectId, uint vintage external view returns (DomainDataTypes.TokenDecollateralizationInfo[] memory result) ) {  DomainDataTypes.TokenDecollateralizationInfo[] memory allInfos = new DomainDataTypes.TokenDecollateralizationInfo[]( _storage.batchIds.length ); uint infoCount; for (uint i; i < _storage.batchIds.length; i++) { uint batchId = _storage.batchIds[i]; if ( _storage.batches[batchId].vintage != vintage || _storage.batches[batchId].projectId != projectId ) { continue; } (uint amountOut, uint minAmountIn, uint minCbtDaoCut) = _simulateDecollateralization( _storage, batchId, DECOLLATERALIZATION_SIMULATION_INPUT ); // Dedaub: part of the code is omitted for brevity infoCount = infoCount + 1; } result = new DomainDataTypes.TokenDecollateralizationInfo[](infoCount); for (uint i; i < infoCount; i++) { result[i] = allInfos[i]; } } This issue was discussed with the Solid World team, who estimated that the protocol will not use enough reward tokens, stakes or batchIds to cause it to run out of gas. 7 LOW SEVERITY: ID Descriptio STATUS Failure to call function updateCarbonRewardDistribution of L1 the RewardsDistributor contract regularly can disrupt the ACKNOWLEDGED normal function of the protocol The RewardsDistributor contract has a public UpdateCarbonRewardDistribution() function that needs to be called by a keeper (or any user of the protocol) once per week in order to mint weekly rewards. A failure to do so leads to two issues. Firstly, any call to the updateCarbonRewardDistribution() function will fail. This will happen because of the canUpdateCarbonRewardDistribution function, which will return false and cause a revert if block.timestamp > nextDistributionEnd. Failure to call updateCarbonRewardDistribution() for a week will make the aforementioned condition evaluate to true. In case this happens, the distributionEnd parameter will need to be manually overridden through a call to RewardsController::configureAssets() by specifying a new cong with a new distributionEnd. //RewardsDistributor.sol::updateCarbonRewardDistribution() function updateCarbonRewardDistribution( address[] calldata assets, address[] calldata rewards, uint[] calldata rewardAmounts ) external override onlyEmissionManager { if ( assets.length != rewards.length || rewards.length != rewardAmounts.length ) {  revert InvalidInput(); } for (uint i; i < assets.length; i++) { if (!_canUpdateCarbonRewardDistribution(assets[i], rewards[i])) { revert UpdateDistributionNotApplicable(assets[i], rewards[i]); } } // Dedaub: part of the code is omitted for brevity } //RewardDistributor.sol::canUpdateCarbonRewardDistribution() function _canUpdateCarbonRewardDistribution(address asset, address reward) internal view returns (bool) { } uint32 currentDistributionEnd = _assetData[asset].rewardDistribution[reward].distributionEnd; uint32 nextDistributionEnd = _computeNewCarbonRewardDistributionEnd(asset, reward); bool isInitializedDistribution = currentDistributionEnd != 0; bool isBetweenDistributions = block.timestamp >= currentDistributionEnd && block.timestamp < nextDistributionEnd; return isInitializedDistribution && isBetweenDistributions; Secondly, a failure to call updateCarbonRewardDistribution() until after what would have been the next distribution end, will cause the rewards of the period in between not to be minted. This is because the SolidMath.computeWeeklyBatchReward() function, which decides how many  rewards to mint, is stateless and does not depend on any parameter which keeps a history of the rewards which should have been issued. //SolidMath.sol::computeWeeklyBatchReward() function computeWeeklyBatchReward( uint certificationDate, uint availableCredits, uint timeAppreciation, uint rewardsFee, uint decimals ) internal view returns (uint netRewardAmount, uint feeAmount) The Solid World team has been aware of the issue and the steps that are required to unblock the system in case it ends up in such a state. 1 CENTRALIZATION ISSUES: It is often desirable for DeFi protocols to assume no trust in a central authority, including the protocols owner. Even if the owner is reputable, users are more likely to engage with a protocol that guarantees no catastrophic failure even in the case the owner gets hacked/compromised. We list issues of this kind below. (These issues should be considered in the context of usage/deployment, as they are not uncommon. Several high-prole, high-value protocols have signicant centralization threats.) ID Description N1 Centralized minting of ForwardContractBatchTokens STATUS OPEN The owner of the SolidWorldManager contract is able to mint ForwardContractBatchToken tokens by creating a new batch using the addBatch() function, which calls the equivalent function from CarbonDomainRepository. //CarbonDomainRepository.sol::addBatch() function addBatch( SolidWorldManagerStorage.Storage storage _storage, DomainDataTypes.Batch calldata batch, uint mintableAmount ) external { // Dedaub: part of the code is omitted for brevity _storage._forwardContractBatch.mint( batch.supplier, batch.id, mintableAmount, "" ); emit BatchCreated(batch.id); } 1 It is understood that this process corresponds to an o-chain process which tokenises the promise of future carbon credits. In addition once a batch has been created, no more ForwardContractBatchToken tokens with the same id can be created, which serves as an additional mitigation. 1 OTHER / ADVISORY ISSUES: This section details issues that are not thought to directly aect the functionality of the project, but we recommend considering them. ID Description STATUS 
A1 Redundant use of the override modier in several contracts RESOLVED In several contracts (most of which have been forked from Aave), many functions are marked with the override modier when no such function is actually inherited by the parent contract. These are probably leftovers from the time (prior to Solidity 0.8.8) when the override keyword was mandatory when a contract was implementing a function from a parent interface EmissionManager  congureAssets  setRewardOracle  setDistributionEnd  setEmissionPerSecond  updateCarbonRewardDistribution  setClaimer  setRewardsVault  setEmissionManager  setSolidStaking  setEmissionAdmin  setCarbonRewardsManager  getRewardsController  getEmissionAdmin  getCarbonRewardsManager RewardsController  getRewardsVault 1  getClaimer  getRewardOracle  congureAssets  setRewardOracle  setClaimer  setRewardsVault  setSolidStaking  handleUserStakeChange  claimAllRewards  claimAllRewardsOnBehalf  claimAllRewardsToSelf RewardsDistributor  getRewardDistributor  getDistributionEnd  getRewardsByAsset  getAllRewards  getUserIndex  getAccruedRewardAmountForUser  getUnclaimedRewardAmountForUserAndAssets  setDistributionEnd  setEmissionPerSecond  updateCarbonRewardDistribution SolidStaking  addToken  stake  withdraw  withdrawStakeAndClaimRewards  balanceOf  totalStaked  getTokensDistributor::getAllUnclaimedReward Resolved in commit 1ad958b6f0d74507c038bd49da281a572e170907. 1 
A2 Creation events could incorporate additional information INFO Creation events, CategoryCreated, ProjectCreated, BatchCreated, could include more information related to the category, project or batch associated with them. 
A3 Storage related gas optimization RESOLVED The elds of DomainDataTypes::Category struct can be reordered to be tighter packed in 4 instead of 5 storage slots. // DomainDataTypes.sol::Category struct Category { uint volumeCoefficient; uint40 decayPerSecond; uint16 maxDepreciation; uint24 averageTA; uint totalCollateralized; uint32 lastCollateralizationTimestamp; uint lastCollateralizationMomentum; } // Dedaub: tighter packed version struct Category { uint volumeCoefficient; uint40 decayPerSecond; uint16 maxDepreciation; uint24 averageTA; uint32 lastCollateralizationTimestamp; uint totalCollateralized; uint lastCollateralizationMomentum; } We measured that in certain test cases the use of less SLOAD and STORE instructions reduced the gas consumption by around 1.5-2% and did not cause any regression in 1 terms of gas consumption (and of course correctness). Resolved in commit b3e79c2456ecca913be0165fd49992eba8e6e1. A4 Compiler version and possible bugs RESOLVED The code is compiled with the floating pragma ^0.8.16. It is recommended that the pragma is xed to a specic version. Versions ^0.8.16 of Solidity in particular, have some known bugs, which we do not believe aect the correctness of the contracts. Resolved in commit d68cfaf512d5eb8da646780350713d6c98ad7da2. 1 
