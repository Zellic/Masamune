L1 closers/liquidator STATUS OPEN Closing large positions cannot be done in a single block, due to the partial close limitation. However, opening a large position can be done in a single block. This could potentially result in some players opening large positions to gain an advantage. Market participants can potentially exploit this limitation, since they can predict that large changes in the mark price will need to happen in order to close or liquidate large positions. 
L2 ClearingHouse::liquidate can be simplied OPEN In ClearingHouse::liquidate it is required that the trader to be liquidated has no open orders. However, the condition upon which the liquidation is decided, accounts for the 0 traders positions as a maker. This condition could thus be simplied both for clarity and gas eiciency. // CH_CLWTISO: cannot liquidate when there is still order require(!IAccountBalance(_accountBalance).hasOrder(trader), "CH_CLWTISO"); require(getAccountValue(trader) < IAccountBalance(_accountBalance).getMarginRequirementForLiquidation(trader ), "CH_EAV" ); More specically, we suggest adding some new functions (essentially variants of getAccountValue and getMarginRequirementForLiquidation as getTakerAccountValue, getTakerMarginRequirementForLiquidation) that will account only for the positions of a trader as a taker. Alternatively, in order to avoid code duplication, another function parameter could be added denoting the accounting only for taker or also for maker positions. Providing such view functions will make it easier to construct liquidation bots, as the eects of CH::cancelExcessOrders will be decoupled from the liquidation condition. We consider the simplicity of the liquidations-related rules important, since the economic viability of this protocol relies on the ability of liquidators to promptly liquidate users positions. L3 Cancel excess orders and liquidate are separate actions OPEN By having separate calls for closing excess positions and liquidations, liquidator bots can be front-run if they chose to invoke these APIs in separate transactions due to gas limitations. It would be reasonable to cancelExcessOrders and liquidate at once, since only liquidations bring prot to the liquidator. 0 OTHER/ ADVISORY ISSUES: This section details issues that are not thought to directly aect the functionality of the project, but we recommend considering them. ID Description 
A1 _isOverPriceLimitBySimulatingClosingPosition is not needed STATUS OPEN The function above, which re-implements a lot of Uniswap V3s logic down the call stack, can be replaced by the actual Uniswap 
V3 swap in a separate internal transaction. If the price goes over the limit, the internal transaction could be reverted via exception handlers, and the alternative logic could be exercised instead. This would not only reduce gas requirements but also the complexity of the protocol. 
A2 Function can be turned into modier OPEN The function ClearingHouseCallee::_requireOnlyClearingHouse can be turned into a modier and applied to the calling function for clarity. 
A3 Debt to InsuranceFund never paid back OPEN In Vault::withdraw some amount might be needed to be borrowed from the InsuranceFund: if (vaultBalanceX10_D < amountX10_D) { uint256 borrowedAmountX10_D = amountX10_D - vaultBalanceX10_D; IInsuranceFund(_insuranceFund).borrow(borrowedAmountX10_D); // Dedaub: debt to InsuranceFund is only growing _totalDebt += borrowedAmountX10_D; } However there is currently no way to pay this debt back. 0 Also, InsuranceFund contract seems to accrue fees from traders that open positions but there is currently no way to retrieve them: function _openPosition(InternalOpenPositionParams memory params) internal returns (IExchange.SwapResponse memory) { IExchange.SwapResponse memory response = IExchange(_exchange).swap( IExchange.SwapParams({ //  }) ); IAccountBalance(_accountBalance).modifyOwedRealizedPnl(_insuranceFund, response.insuranceFundFee.toInt256()) // } 
A4 Gas savings while settleFunding OPEN In Exchange::settleFunding, fundingGrowthGlobal and price TWAPs are always calculated as follows: (fundingGrowthGlobal, markTwap, indexTwap) = _getFundingGrowthGlobalAndTwaps(baseToken); However, for calls within the same block the results will be the same. Since this function is called at every interaction with the system, it is highly likely to be called more than once in a single block. In order to save gas an if statement could be added: if (timestamp != _lastSettledTimestamp[baseToken]){ // call _getFundingGrowthGlobalAndTwaps // call _updateFundingGrowth // update stored vars 0 } else { // call _updateFundingGrowth using stored values of fundingGrowth } 
A5 Gas usage may increase quadratically to positions OPEN Whenever a users position is modied, maintained or liquidated, all of the users token positions need to be queried. For instance, AccountBalance::getTotalDebtValue which gets called on any position action. Therefore, if we assume that a user with more positions and exposures to more tokens needs to maintain their positions, and the number of actions correlates the number of positions, the gas usage really scales quadratically for such a user. 
A6 No functionality to remove pools INFO We recommend the addition of a function MarketRegistry::removePool, to complement the others. 
A7 Current design doesnt allow for multiple pools of the same base token INFO There are several cases where the base token is considered as a unique id for the underlying pool. For example: address pool = IMarketRegistry(_marketRegistry).getPool(params.baseToken); uint256 feeGrowthGlobal
X128 = _feeGrowthGlobalX128Map[params.baseToken]; int24 tick = _getTick(baseToken); This is suicient as long as the protocol only supports a single quote token for all pools but will be a problem in case the protocol is to be extended. 0 A8 Compiler known issues INFO The contracts were compiled with the Solidity compiler v0.7.6 which, at the time of writing, have some known bugs. We inspected the bugs listed for this version and concluded that the subject code is unaected. 01 
