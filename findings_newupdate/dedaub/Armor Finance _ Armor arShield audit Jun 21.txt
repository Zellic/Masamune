H1 Inaccurate tokens conversion Status Resolved In the following code snippet taken from arShield::liqAmts amounts ethOwed and tokensOwed are supposed to represent equal value. ethOwed = covBases[_covId].getShieldOwed( address(this) ); if (ethOwed > 0) tokensOwed = oracle.getTokensOwed(ethOwed, address(pToken), uTokenLink); tokenFees = feesToLiq[_covId]; tokensOwed += tokenFees; require(tokensOwed > 0, "No fees are owed."); uint256 ethFees = ethOwed > 0 ? ethOwed * tokenFees / tokensOwed : getEthValue(tokenFees); ethOwed += ethFees; However, code line tokensOwed += tokenFees; is misplaced resulting in an underpriced ethFees computation. We suggest that it be altered as follows: ethOwed = covBases[_covId].getShieldOwed( address(this) ); if (ethOwed > 0) tokensOwed = oracle.getTokensOwed(ethOwed, address(pToken), uTokenLink); tokenFees = feesToLiq[_covId]; require(tokensOwed + tokenFees > 0, "No fees are owed."); 5 uint256 ethFees = ethOwed > 0 ? ethOwed * tokenFees / tokensOwed : getEthValue(tokenFees); ethOwed += ethFees; tokensOwed += tokenFees; for accuracy. H2 Duplicate subtraction of fees amount Resolved In arShield::payAmts the new ethValue is calculated as follows: // Ether value of all of the contract minus what we're liquidating. ethValue = (pToken.balanceOf( address(this) ) // Dedaub: _tokenFees amount is subtracted twice - _tokenFees - totalFeeAmts()) * _ethOwed / _tokensOwed totalFeeAmounts() also considers all liquidation fees, resulting in _tokenFees being subtracted twice. This can cause important harm to the protocol, as the total value of coverage purchased is underestimated. 6 Medium Severity Id Description M1 Possible non-updated value of totalCost when checkpoint()ing Status Dismissed (it is decided that updateCoverage() will be called frequently enough) Function CoverageBase::updateShield updates the totalEthValue of the purchased coverage and then calls checkpoint() to update the cost-tracking related variables totalEthValue = totalEthValue - uint256(stats.ethValue) + _newEthValue; checkpoint(); Where function checkpoint() internal { } cumCost += costPerEth * (block.timestamp - lastUpdate); costPerEth = totalCost * 1 ether / totalEthValue; lastUpdate = block.timestamp; Variable totalCost gets updated by external calls to updateCoverage(): function updateCoverage()external { ArmorCore.deposit( address(this).balance ); ArmorCore.subscribe( protocol, getCoverage() ); totalCost = getCoverageCost(); checkpoint(); 7 } where an external keeper is responsible to call it whenever needed to maintain up-to-date information. However this gives the ability to an attacker to front-run the updateCoverage transaction so as to have consecutive updateShield() happening without totalCost being updated in the meantime. For example, the attacker could mint arTokens by depositing a large amount of pTokens, then inspect the network for an updateCoverage() transaction so as to front run it with redeem and liquidate transactions. The attacker can benet by lowering the cost of coverage, resulting in underpaid coverage. This is because totalCost affects prices costPerEth and cumCost. The higher the frequency that updateCoverage() is called the lower the possibility of an effective attack of this kind. If updateCoverage() is called frequently enough then its most probably an unprotable attack due to fees (both network fees and protocol fees), but again there is also a dependency on the amount of coverage bought by the user/attacker. For enhanced security, we suggest that totalCost be updated upon each coverage amount change, i.e. the above code snippet from updateShield() to become: totalEthValue = totalEthValue - uint256(stats.ethValue) + _newEthValue; checkpoint(); // Dedaub: update totalCost since totalEthValue changed totalCost = getCoverageCost(); Low Severity [No low severity issues] 8 Other/Advisory Issues This section details issues that are not thought to directly affect the functionality of the project, but we recommend addressing. Id Description 
A1 Unintuitive variable name We suggest that variable totalCost Status Resolved // Current cost per second for all Ether on contract. uint256 public totalCost; is renamed to totalCostPerSec for clarity. 
A2 Old version of SafeMath library Resolved The code of the SafeMath library included is of an old version of compiler (< 0.8.0) being set to pragma solidity 0.8.4. However, compiler versions of 0.8.* revert on overow or underow, so this library has no effect. We suggest ArmorCore.sol not use this library and substitute SafeMath operations to normal ones, as well as SafeMath.sol contract be completely removed. 
A3 Misleading comment Resolved In arShield.sol function confirmHack has a misleading @dev comment: /** * Dedaub: used by governor, not controller * @dev Used by controller to confirm that a hack happened, which then locks the contract in anticipation of claims. **/ function confirmHack( uint256 _payoutBlock, uint256 _payoutAmt ) external isLocked onlyGov 9 A4 Extra protection of refunds in arShield Resolved Function CoverageBase::DisburseClaim is called by governance and transfers ETH amount to a selected _arShield, that is supposed to be used for claim refunds. /** * @dev Governance may disburse funds from a claim to the chosen shields. * @param _shield Address of the shield to disburse funds to. * @param _amount Amount of funds to disburse to the shield. **/ function disburseClaim( address payable _shield, uint256 _amount ) { external onlyGov require(shieldStats[_shield].lastUpdate > 0, "Shield is not authorized to use this contract."); _shield.transfer(_amount); } We suggest that an extra requirement be added, checking that _shield is locked. In the opposite case the ETH amount transferred to the arShield contract as refunds can be immediately transferred to the beneciary. arShields contract locking/unlocking and disburseClaim() are all government-only actions, however this suggestion ensures security in case of false ordering of the governance transactions. 10 
