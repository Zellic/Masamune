H1 DebtToken::accrueInterests algorithm is problematic OPEN Interest compounding (the act of adding interest to the original amount, so that the interest itself is subject to further interest) is typically performed at regular, predened intervals, e.g. once per year, or four times per year. This does not mean that the accounting has to be performed at exactly those intervals, it can certainly be performed more often or less often; however, the formula employed for compounding should ensure that independently from how often the accounting is performed, the nal result is the same: updating the amount 10 times should produce the same amount as if the interest was calculated just once at the predened interval. However, the way DebtToken::accrueInterest is wrien, compounding happens at irregular intervals, depending on when the function happened to be called. If the function is called 10 times in some period of time, the interest calculated will be higher  than it would be if the function was called once in the same period, leading to a non-deterministic behavior which will hinder the use of the protocol. Specically, the code does a linear computation of the current interest to accrue (just multiply a constant by the time elapsed) whereas the accrual between calls is compounding (i.e., exponential). function accrueInterest() external override onlyController returns (uint256 _interestAccumulated) { uint256 _currentBlockNumber = getBlockNumber(); if (lastBlockAccrued == _currentBlockNumber) { return 0; } uint256 _blockDelta = _currentBlockNumber - lastBlockAccrued; uint256 _interestRateToAccrue = syntheticAsset.interestRatePerBlock() * _blockDelta; _interestAccumulated = _interestRateToAccrue.wadMul(totalSupply); totalSupply += _interestAccumulated; debtIndex += _interestRateToAccrue.wadMul(debtIndex); } We suggest to use the following standard formula for performing interest compounding once per year: TS' = TS (1 + IR)^(BD / BPY) where TS : original totalSupply TS' : final totalSupply IR : annual interest rate BD : block delta since the last update BPY : blocks per year The formula has the property that performing an update twice at intervals B
D1 and BD2, is equivalent to performing just once at interval BD1+BD2:  T
D1 and BD2, is equivalent to performing just once at interval BD1+BD2:  TS1 = TS (1 + IR)^(BD1 / BPY) TS2 = TS1 (1 + IR)^(B
D2 / BPY) = TS (1 + IR)^(BD1 / BPY) (1 + IR)^(BD2 / BPY) = TS (1 + IR)^((BD1+BD2) / BPY) If you prefer to compound N times per year, the formula can be changed to: TS' = TS(1 + IR/N)^(N * BD / BPY) where N: number of compounds per year Finally, could be added continuously (the limit of N going to innity), using the following formula: TS' = TS e^(IR * BD / BPY) Both above formulas have the same property of being independent from the number of updates. H2 Price oracle computation can overflow OPEN [This issue is potentially high-severity, but we have not ascertained with high condence. Raising it for the developers review.] In UniswapV2PriceProvider::_getAmountOut, the calculation seems to overflow easily. function _getAmountOut( address _token, address _tokenIn, uint256 _amountIn ) private view returns (uint256 _amountOut) { PairOracleData memory _pairOracle = oracleDataOf[_token]; if (_tokenIn == _pairOracle.token0) { _amountOut = _pairOracle.price0Average.mul(_amountIn).decode144();  } else { require(_tokenIn == _pairOracle.token1, "invalid-token"); _amountOut = _pairOracle.price1Average.mul(_amountIn).decode144(); } } The two _amountOut computations multiply a xpoint 112.112 bits quantity by an amount, which is scaled by e18 = ~60 bits. We believe the 112.112 xpoint should be rst decoded into a uint. MEDIUM SEVERITY: ID Description 
M1 The use of type(uint256).max to denote all users balance is risky, front-runnable STATUS OPEN In Controller.sol, type(uint256).max is used in several places to denote that the user wants to deposit/withdraw/mint/etc all funds in his balance. This functionality adds unnecessary risk of varying severity, depending on the semantics of each function. The most important of all is the case of Controller::repay,when _onBehalfOf != _sender. In this case the sender requests a transaction asking to pay all debts of _onBehalfOf,for any amount (up to his own balance). A malicious beneciary can observe this transaction, front-run it, and arbitrarily increase his own debt, leading to the victim repaying an arbitrarily larger amount than the one he intended to. Controller::deposit poses a similar threat, albeit much harder to exploit. Again, assuming _onBehalfOf != _sender, the sender asks to deposit his entire balance to _onBehalfOf. It could happen that a malicious _onBehalfOf has an outstanding debt towards _sender in any ethereum protocol. By front-running the transaction, the  adversary can repay his debt (which will register as paid in that protocol), causing the _senders balance to increase, knowing that that entire balance will be transferred back to him by Controller::deposit. We believe that this functionality is a syntactic sugar that does not justify the risk, and could be easily moved o-chain to the client-side. We recommend to remove it from all Controller functions. M2 Blocks-per-year constant seems o OPEN The code in SyntheticAsset denes a BLOCKS_PER_YEAR constant: uint256 public constant BLOCKS_PER_YEAR = 2102400; // Dedaub: checked just now, got 2350729, over 10% difference At audit time, this approximate number was signicantly o, as our code comment illustrates. LOW SEVERITY: ID Description 
L1 DepositToken::_transfer is not protected against reentrancy STATUS OPEN All core functions of the Controller contract (e.g. Controller::withdraw) are However, against nonReentrant, DepositToken::_transfer has no such guard, although transferring deposited funds is similar to withdrawing them. reentrancy aacks. protect to the that for Note DepositToken::_transfer, since it checks not only the users balance, but also that the funds are not locked. Balance checks are typically protected via Soliditys checked particularly reentrancy aack high risk of is a  arithmetic: if one tries to withdraw more than his balance via a reentrancy aack, the balance would become negative and an underflow would occur. But such an underflow would not happen if an adversary tries to transfer funds that exist but are locked. In the current code we could not nd any concrete reentrancy aack; nevertheless we believe that the lack of a guard could potentially allow such aacks in future versions of the code. that assume example, For to DepositToken::_beforeTokenTransfer (which currently is empty) allowing code reentrancy. By reentering into DepositToken::_transfer, from within itself (after the onlyIfNotLocked check) an adversary could easily transfer an arbitrary amount of locked funds. functionality added future some is Similarly, the lack of guards allows the code to enter DepositToken::_transfer from within any Controller function. Again, we could not nd a concrete aack, but we think it is likely that such an aack could be made possible in future versions of the code. As a consequence, we recommend to treat DepositToken::_transfer in a similar way as the Controller functions, and implement a cross-contract reentrancy guard. 
L2 Contracts are diicult to initialize due to mutual dependency OPEN The DebtToken and SyntheticAsset contracts mutually depend on each other, in the sense that both contracts initialize function receives an instance of the other contract. Since anyone can call the initialize function, it should be called as early as possible; the OpenZepellin guidelines suggest calling initialize from the constructor of the Proxy contract (assuming that such a Proxy is used). 1 However, the mutual dependency makes it hard to follow this guideline, since one needs to create both contracts before initializing either of them, and only then call the initialize functions. Performing all tasks in a single transaction is non-trivial. If the current design is maintained, it is likely that the contracts will be initialized in separate transactions. In such a case, we recommend paying particular aention and ensuring that all initialize calls succeed. If any such call reverts without being noticed, then the contracts could end up being initialized in an arbitrary way by a malicious adversary. L3 Inconsistent upgrade check quantity OPEN In DebtTokenUpgrader::_checkResults, the decimals quantity is uint8 but its result is read via _checkUint256Results. function _calls() internal pure override returns (bytes[] memory calls) { calls = new bytes[](4); calls[0] = abi.encodeWithSignature("totalSupply()"); calls[1] = abi.encodeWithSignature("decimals()"); ... } function _checkResults(bytes[] memory _beforeResults, bytes[] memory _afterResults) internal pure override { _checkUint256Results(_beforeResults, _afterResults, 0, 1); // checks totalSupply+decimals ... } We believe this works ne, but raise the issue of the inconsistency, in case it has not been considered. OTHER/ ADVISORY ISSUES: This section details issues that are not thought to directly aect the functionality of the project, but we recommend considering them. 11 ID Description 
A1 DepositToken::burnFromUnlocked is not use STATUS OPEN DepositToken::burnFromUnlocked is marked as onlyController, but is not used by the Controller. We recommend removing obsolete functions. 
A2 Multiple loops over all synthetic assets in the system INFO The code contains multiple loops over all synthetic assets, e.g., in Controller:debtOf, Controller::depositOf. It seems that developers are aware of this, since it is mentioned in comments. However, we want to point out that even a loop that iterates over a couple of hundred storage elements may exceed the block gas limit. Any iteration over more than a few tens of storage locations is probably worth optimizing. 
A3 Some assets are assumed to be equivalent to USD INFO We are philosophically against assuming that a token is equivalent to USD and warn about it. Especially when there are on-chain and o-chain reliable pricing data, hard-coding a stable exchange rate of 1:1 for USD seems ill-advised, although the threat sounds exotic. The Oracle contract does exactly that for some assets, marked via flag isUsd. Trusting that some assets are USD-equivalent is the easiest way in which an issue aecting one token will become an ecosystem-wide issue. In terms of threats over top name USD-equivalent assets, we mention that, e.g., USDC is institutionally well-trusted, but, on-chain, its minting is ultimately governed by a single EOA; USDT is alleged to have systemic risks; TUSD is governed by a 2-of-4 multisig. Even if its unlikely that any of these assets fail to keep their peg, due to human error or nancial threat, it will not be astonishing. 
A4 Considerations regarding Uniswap v3 oracles INFO 1 There are standard considerations relative to Uniswap v3 TWAP oracles that the developers are already aware of (e.g., ability to manipulate with limited liquidity). A lesser-known consideration is that Uniswap v3 pools shift to their clients the gas burden to expand the observations array of the pool. This means that for rare assets (which Vesper may want to look up in a Uniswap v3 TWAP) the pool needs its observations array expanded to enough positions to accommodate the pools transactions that have occurred in the last TWAP period. This burden is upon the Vesper deployer. Expanding the observations array requires calling increaseObservationCardinalityNext() on the pool. A secondary consideration is that the code currently uses a 3rd party non-upgradable contract for Uniswap 
V3 oracle computations: /** * @notice The UniswapV3CrossPoolOracle contract address * @dev This is 3rd-party non-upgradable contract * https://etherscan.io/address/0x0f1f5a87f99f0918e6c81f16e59f3518698221ff#code */ IUniswapV3CrossPoolOracle public crossPoolOracle; We only briefly reviewed this (out-of-scope) contract and it seems ne and analogous to computations we have seen elsewhere (e.g., in Chainlink contracts). Still, this is a point of caution to keep in mind. 
A5 Controller privileged functions can be blocked from making INFO progress The code in Controller::removeSyntheticAsset and removeDepositToken has guards of the form: require(_syntheticAsset.totalSupply() == 0, "supply-gt-0"); // Dedaub: but no straightforward way to make it zero 1 We remark that, although privileged, the governor of this contract has no way to ensure progress relative to this requirement. This is a ne design decision, just one to be aware of. A6 Compiler bugs INFO Vesper Synth contracts were compiled with the Solidity compiler v0.8.9 which, at the time of writing, has no known issues. Vesper Pools contracts were compiled with the Solidity compiler v0.8.3 which, at the time of writing, has a known minor issue. We have reviewed the issue and do not believe it to aect the contracts. More specically the known compiler bug associated with Solidity compiler v0.8.3 is:  Memory layout corruption can happen when using abi.decode for the deserialization of two-dimensional arrays. 1 
