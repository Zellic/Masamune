L1 Error-prone dead cod STATUS RESOLVED In ManagerBase.sol function payHub is supposed to handle the necessary payments to the MuinHub contract due to swaps, position opening or updating. function payHub( address token, address payer, uint256 amount ) internal { // Dedaub: user pays with ETH if (token == WET
H9 && address(this).balance >= amount) { // pay with WETH9 IWETH(WETH9).deposit{value: amount}(); // wrap only what is needed to pay IWETH(WETH9).transfer(hub, amount); // Dedaub: this case seems to be unused } else if (payer == address(this)) { // pay with tokens already in the contract SafeTransferLib.safeTransfer(token, hub, amount); // Dedaub: user pays with token } else { 01 // pull payment SafeTransferLib.safeTransferFrom(token, payer, hub, amount); } } A user interacting with the protocol is able to pay either with ETH or with an ER
C20 token (rst and third case as denoted in the snippet above). The case where the payer is a Manager- contract itself (second case in the above snippet) seems to be legacy code, as it is never executed given the current codebase. We consider this nding of low severity since we currently see no way to exploit it, but could be proven to be error-prone in any future updates given its sensitive functionality. L2 Unclear token holding discipline, potential for error RESOLVED (commits 422b3d14, e065176d) The Manager contract should never hold either ETH or WETH between external transactions, or an aacker can drain it of these balances in multiple ways. One way is to indirectly invoke the payHub functionality, in the immediately preceding issue, through a public system action. More straightforwardly, the aacker can call unwrapWETH or refundETH, dened in ManagerBase: function unwrapWETH(uint256 amountMinimum, address recipient) external payable { uint256 balanceWETH = IWETH(WETH9).balanceOf(address(this)); require(balanceWETH >= amountMinimum, "Insufficient WETH"); if (balanceWETH > 0) { IWETH(WETH9).withdraw(balanceWETH); SafeTransferLib.safeTransferETH(recipient, balanceWETH); } } function refundETH() external payable { 01 if (address(this).balance > 0) SafeTransferLib.safeTransferETH(msg.sender, address(this).balance); } Given the danger for user funds, such assumptions (of never holding ETH/WETH in this contract) should be clearly documented. We further note that it is certainly possible for the Manager to receive WETH (or any token) by accident, and not by explicit transfer. For instance, the Muin API is of the following form (shown here for one case of a swap, SwapManager::exactInSingle): function exactInSingle( address tokenIn, address tokenOut, uint256 tierChoices, uint256 amountIn, uint256 amountOutMinimum, address recipient, bool fromAccount, bool toAccount, uint256 deadline ) external payable checkDeadline(deadline) returns (uint256 amountOut) { (, amountOut) = IMuffinHub(hub).swap( tokenIn, tokenOut, tierChoices, amountIn.toInt256(), toAccount ? address(this) : recipient, toAccount ? getAccRefId(recipient) : 0, fromAccount ? getAccRefId(msg.sender) : 0, fromAccount ? new bytes(0) : abi.encode(msg.sender) ); require(amountOut >= amountOutMinimum, "TOO_LITTLE_RECEIVED"); } 01 However, the swap call ends up executing the code below in MuinHub: // Dedaub: called from "swap" function _transferSwap( address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, address recipient, uint256 recipientAccRefId, uint256 senderAccRefId, bytes memory data ) internal {  if (recipientAccRefId == 0) { SafeTransferLib.safeTransfer(tokenOut, recipient, amountOut); }  This means that if the caller of exactInSingle passes a 0-address recipient yet also sets the toAccount flag, the money goes to the Manager contract (address(this) in the SwapManager::exactInSingle code, which becomes recipient in MuffinHub::_transferSwap), and it is eectively unrecoverable/burned, or, if it is WETH, becomes available for anyone to take via one of the earlier-discussed ways. A clearer model of the movement of funds, as well as safeguards, will prevent such errors. There is no reason to set this as the recipient when the funds are expected to go into an internal account (flag toAccount) and not to an external Ethereum account. (Perhaps seing it to msg.sender will prevent some misuse, although we have not conrmed that this will work with the rest of the code.) Furthermore, the code could check that the toAccount flag is never used with a zero-address recipient, since zero is used to indicate toAccount was false in downstream code, such as the MuffinHub::_transferSwap above. 01 OTHER/ ADVISORY ISSUES: This section details issues that are not thought to directly aect the functionality of the project, but we recommend considering them. ID Description 
A1 Library contract imported twice STATUS DISMISSED In contract MuffinHub.sol importing Pools library is redundant: import "./libraries/Pools.sol" contract MuffinHub is IMuffinHub, MuffinHubBase { ... } since it is already imported in the MuffinHubBase parent class: import "./libraries/Pools.sol"; abstract contract MuffinHubBase is IMuffinHubBase { ... } 
A2 Misleading variables naming DISMISSED In SwapMath.sol, functions calcTierAmtsIn, calcTierAmtsOut, variables uint256 num; // uint256 denom; // denominator of sqrt lambda (sum of U
Q200 + amount) numerator of sqrt lambda (sum of UQ128) are falsely named since num is actually the denominator and denom the numerator of the solution. In function _ceilMulDiv in the same le, the name denom is used correctly. 01 
A3 Fallback/proxy code not compatible with further Solidity calls INFO The fallback code of MuinHub is used to proxy (via delegatecall) into MuinHubPositions. This is a simple way to split the contract functionality into two, avoiding the Ethereum contract size restrictions. The code used to proxy is taken from an OpenZeppelin proxy implementation. fallback() external { address _positionController = positionController; assembly { calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), _positionController, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 { revert(0, returndatasize()) } default { return(0, returndatasize()) } } } Out of an abundance of caution, we warn that this implementation explicitly assumes that, upon return from the delegatecall, no further Solidity code will run: the return data is wrien in memory position 0, overwriting the Solidity scratchpad memory. There is currently no issue with this practice in the Muin code: the fallback function cannot be called in a context that returns to Solidity code. However, given that the code base uses MultiCall (elsewhere) developers should be warned of the danger of possibly adding MultiCall functionality to MuinHub in the future: a call delegated through the fallback function will return and further calls will be issued. Without much further low-level exploration, it is not clear that the memory state of MultiCall logic can be indeed aected, and even less that a security issue can arise from such a combination of MultiCall and the above fallback function, but the possibility is suicient for an advisory note. 01 
A4 Assert statements are used to catch invalid inputs INFO The Solidity assert statement is best used to signal that a condition that should never arise (i.e., it represents a logical or code error) has occurred. In contrast, require is the standard way to check for invalid inputs. The codebase often fails via an assert and not a require for invalid inputs. The main example is operations in the Math library: library Math { /// @dev Compute z = x + y, where z must be non-negative /// and fit in a 96-bit unsigned integer function addInt96(uint96 x, int96 y) internal pure returns (uint96 z) { unchecked { int256 s = int256(uint256(x)) + int256(y); assert(s >= 0 && s <= int256(uint256(type(uint96).max))); z = uint96(uint256(s)); } } ... function toInt96(uint96 x) internal pure returns (int96 z) { assert(x <= uint96(type(int96).max)); z = int96(x); } The above function, toInt96, for instance, is used in one of the most major safeguards in the system: in checking that the liquidity parameter supplied to a burn operation (an unsigned integer) does not become negative when cast into a signed integer. (Having this would enable an aacker to burn a negative amount of liquidity, i.e., to add enormous liquidity at will.) Therefore, the assert checks external input and should be a require. It is possible that the developers considered this and chose the assert in order to cause greater damage (by burning all supplied gas, as assert does) to a caller that supplies such invalid values. However, the practice is still questionable. 
A5 Misleading comments RESOLVED 01 In library Ticks.sol the NatSpec comments explaining a Ticks parameters needSettle0, needSettle1 refer to false limit order types: * @param needSettle0 boundary at this tick (i.e. 0 -> 1 limit orders) * @param needSettle1 boundary at this tick (i.e. 1 -> 0 limit orders) True if needed to settle positions with upper tick True if needed to settle positions with lower tick Actually, needSettle0 becomes true if a OneToZero limit order should be seled, while needSettle1 if a ZeroToOne one. In the Math library, the following comment is misleading: /// @dev Compute z = max(x - y, 0) and r = x - z /// Dedaub: above is false function subUntilZero(uint256 x, uint256 y) internal pure returns (uint256 z, uint256 r) { unchecked { if (x >= y) z = x - y; else r = y - x; } } 
A6 Multiple denitions of constants DISMISSED Some constants are dened in both TickMath and Constants.sol: int24 internal constant MIN_TICK = -776363; int24 internal constant MAX_TICK = 776363; uint128 internal constant MIN_SQRT_P = 65539; uint128 internal constant MAX_SQRT_P = 340271175397327323250730767849398346765; 01 
A7 Magic constant RESOLVED In Pools::_addTier, Pools::setTierParameters, 100000 is a magic constant and should ideally be given a name. function _addTier( Pool storage pool, uint24 sqrtGamma, uint128 sqrtPrice ) internal returns (uint256 amount0, uint256 amount1) { uint256 tierId = pool.tiers.length; require(tierId < MAX_TIERS); require(sqrtGamma <= 100000);  
A8 Refactor common code? RESOLVED In Positions::update, it might be more elegant to factor out the statement self.liquidity
D8 = liquidityD8New which is common in all three branches (and a no-op in the unlikely case that no branch is taken). function update( Position storage self, int96 liquidityDeltaD8, uint80 feeGrowthInside0, uint80 feeGrowthInside1, bool collectAllFees ) internal returns (uint256 feeAmtOut0, uint256 feeAmtOut1) { unchecked { ... if (collectAllFees) { ... self.liquidityD8 = liquidityD8New; } else if (liquidityDeltaD8 > 0) { ... 01 self.liquidityD8 = liquidityD8New; ... } else if (liquidityDeltaD8 < 0) { ... self.liquidityD8 = liquidityD8New; } } } A9 Compiler known issues INFO The contracts were compiled with the Solidity compiler v0.8.10 which, at the time of writing, doesnt have any known bugs. 01 
