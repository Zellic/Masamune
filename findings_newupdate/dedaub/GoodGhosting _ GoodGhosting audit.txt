L1 No tolerance to Aave losses Status Resolved (largely) Although Aave aTokens should always be redeemable for (at least an equal amount of) their underlying tokens, the developers could consider refactoring in order to have some tolerance to Aave (in hacks). GoodGhosting::redeemFromExternalPool and GoodGhostingPolygon::redeemFromExternalPool) computation Specically, losses (e.g., due the to uint256 grossInterest = totalBalance.sub(totalGamePrincipal); contains an implicit require in the sub. This means that the transaction will revert if the balance after an Aave withdrawal is lower than the capital invested. It is not clear that this is a condition that should cause a revert. There may be funds that can be withdrawn, although lower than those invested originally. L2 Matic rewards also not claimable if there are no admin fees Resolved In GoodGhostingPolygon::adminFeeWithdraw the following require seems too strict: require(adminFeeAmount > 0, "No Fees Earned"); Although in regular GoodGhosting there is no meaning in calling this function in case of no fees collected (mainly in case of a fee-free game setup), in the GoodGhosting Polygon version this check also prevents the execution of the second part of the function, which is claiming Matic rewards. We recommend turning the check into an if. 5 Other/Advisory Issues This section details issues that are not thought to directly affect the functionality of the project, but we recommend addressing. Id Description 
A1 Function ordering inside contracts Status Resolved Consider adopting the ofcial style guide for function ordering within a contract. In order of priority: external > public > internal > private and view > pure within the same visibility group. https://docs.soliditylang.org/en/v0.4.24/style-guide.html#order-of-functions 
A2 Non-intuitive variable name Resolved In GoodGhostingPolygon::redeemFromExternalPool variable amount holds the accrued rewards of the game. We suggest this variable be renamed to rewardsAmount for clarity. 
A3 Redundant check Dismissed [Clarity of messages more important] In GoodGhosting::makeDeposit the rst of the following requires //check if current segment is currently unpaid require( players[msg.sender].mostRecentSegmentPaid != currentSegment, "Player already paid current segment" ); // check if player has made payments up to the previous segment require( players[msg.sender].mostRecentSegmentPaid == currentSegment.sub(1), "Player didn't pay the previous segment - game over!" ); is redundant, as it is covered by the latter one. We suggest that it be removed in order to save gas. If this is done, the error message should also change for clarity, so as to reect any possible error case. 6 
A4 Inconsistent reference to owner Resolved In owner-only function GoodGhostingPolygon::adminFeeWithdraw the owner of the contract is written both as owner() and msg.sender. emit AdminWithdrawal(owner(), totalGameInterest, adminFeeAmount); require( // Dedaub: owner as owner() IERC20(daiToken).transfer(owner(), adminFeeAmount), "Fail to transfer E
R20 tokens to admin" ); if (rewardsPerPlayer == 0) { uint256 balance = IERC20(matic).balanceOf(address(this)); require( // Dedaub: owner as msg.sender IERC20(matic).transfer(msg.sender, balance), "Fail to transfer ER
C20 tokens on withdraw" ); } We suggest that msg.sender be altered to owner() for consistency and clarity (or the converse, in case the gas savings are considered to be worth it). 
A5 Code simplication/gas savings opportunity Resolved In GoodGhosting::_joinGame the code below if (!canRejoin) { iterablePlayers.push(msg.sender); } require(iterablePlayers.length <= maxPlayersCount, "Reached max quantity of players allowed"); can change to: if (!canRejoin) { iterablePlayers.push(msg.sender); require(iterablePlayers.length <= maxPlayersCount, "Reached max quantity of players allowed"); 7 } The condition in the require clause can only be violated if the if statement executes. The change will result in slightly simpler and more gas-efcient code. 
A6 Small remainder amounts can stay in the contract Due to the integer division in the two withdraw functions GoodGhostingPolygon), small amounts can remain in the contract: Dismissed [already mitigated as much as possible] (GoodGhosting and payout = payout.add(totalGameInterest.div(winners.length)); 
A7 Are Aave referral codes still active? Dismissed [kept even if currently unnecessary] GoodGhosting::_transferDaiToContract contains an Aave deposit with a referral code (155). It is unclear whether this is still useful/used: lendingPool.deposit(address(daiToken), segmentPayment, address(this), 155); A8 Compiler known issues Info The contracts were compiled with the Solidity compiler v0.6.11 which, at the time of writing, has some known bugs (ABIDecodeTwoDimensionalArrayMemory, keccakCaching, EmptyByteArrayCopy, DynamicArrayCleanup). We believe the contract to be unaffected: there is no usage of abi.decode, no keccak hashes of statically known length, no copies of empty byte memory/calldata arrays to storage and the base types of the dynamic arrays are > 16 bytes. 8 
