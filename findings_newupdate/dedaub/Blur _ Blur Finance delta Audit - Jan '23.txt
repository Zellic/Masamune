L1 Schedules already timed-up may not be taken into account if a preceding one hasnt expired ye STATUS RESOLVED The _computeUnlocked() function of the TokenLockup contract iterates over the schedules to calculate the unlocked amount of tokens based on the schedules which the contract has been initialized with. However, there is no guarantee that these schedules are in ascending order based on the endTime eld. As a result, a schedule which expires before its preceding one can lead to the amount of the schedule not being counted until the preceding one expires too. This happens due to the fact that the loop breaks once it reaches a schedule which hasnt expired yet. TokenLockup::_computeUnlocked() function _computeUnlocked( uint256 locked, uint256 time ) internal view returns (uint256) { ... for (uint i; i < scheduleLength; i++) { uint256 portion = schedule[i].portion; uint256 end = schedule[i].endTime; // Dedaub: Here the loop breaks once it finds a schedule // if (time < end) { that hasnt expired yet unlocked += locked * (time - start) * portion / ((end - start) * INVERSE_BASIS_POINTS); break; } else {  unlocked += locked * portion / INVERSE_BASIS_POINTS; start = end; } } return unlocked; } Hence, it could result in geing incorrect information about the unlocked tokens at any particular moment which can also lead to incorrect calculations of the voting power of the users. L2 Schedule portions are not checked whether they add up to 100% RESOLVED Every TokenLockup contract gets a list of schedules upon construction which will release portions of the unallocated tokens. However, there is no check to ensure that the provided portions add up to 100% so that the entire amount of tokens become claimable after an amount of time. TokenLockup::_computeUnlocked() function _computeUnlocked( uint256 locked, uint256 time ) internal view returns (uint256) { ... // Dedaub: This loop iterates over the schedules taking into account each schedules portion, but there is no check that they // all add up to 100% // for (uint i; i < scheduleLength; i++) { uint256 portion = schedule[i].portion; uint256 end = schedule[i].endTime; if (time < end) {  unlocked += locked * (time - start) * portion / ((end - start) * INVERSE_BASIS_POINTS); break; } else { unlocked += locked * portion / INVERSE_BASIS_POINTS; start = end; } } return unlocked; } CENTRALIZATION ISSUES: It is often desirable for DeFi protocols to assume no trust in a central authority, including the protocols owner. Even if the owner is reputable, users are more likely to engage with a protocol that guarantees no catastrophic failure even in the case the owner gets hacked/compromised. We list issues of this kind below. (These issues should be considered in the context of usage/deployment, as they are not uncommon. Several high-prole, high-value protocols have signicant centralization threats.) ID Description STATUS N1 Trusted owners can take over all Governor actions ACKNOWLEDGED The changes in the audit scope implement a voting-based governance facility. However, accounts that have the role of owner for dierent contracts can take over/override governance actions. Specic examples include:   The owner of BlurExchange can directly set the governor.  The owner of BlurToken can add (at any time) any lockups, containing any tokens. All token balances are summed together for voting purposes, with no check that they are over the same token. In fact, there is no guarantee that a supplied lockup is indeed a lockup and not just any contract that answers to balanceOf. OTHER / ADVISORY ISSUES: This section details issues that are not thought to directly aect the functionality of the project, but we recommend considering them. ID Description 
A1 The signicance of BlurToken::delegates should be clearly documented STATUS DISMISSED The issue was invalidated by the nal revision of the code. The delegates function was removed for gas savings. We reiterate our warning about counter-intuitive behavior (without the function) and the need for documentation and user awareness. The seemingly innocuous view function BlurToken::delegates is central to the correct functioning of the voting process. This should be documented, at least via a highly visible code comment (e.g., **WARN**). Specically, the function denition is:  BlurTokens::delegates() function delegates( address account ) public view override returns (address) { address _delegate = ERC20Votes.delegates(account); if (_delegate == address(0)) { _delegate = account; } return _delegate; } This seems to suggest the function is just a no-op convention: an account is itself its delegatee if it would otherwise have none. However, this logic is crucial ERC20Votes protocol. Specically, the protocol documentation warns: in the correct functioning of the OpenZeppelin * By default, token balance does not account for voting power. * This makes transfers cheaper. The downside is that it * requires users to delegate to themselves in order to activate * checkpoints and have their voting power tracked. The overridden delegates function in BlurToken achieves this exact purpose: causes every token transfer (which calls delegates() in the _afterTokenTransfer hook of the ERC20Votes contract) to update (checkpoint) the voting power of all parties. Without the denition of the delegates function, the behavior would be signicantly dierent:  a claim from a TokenLockup would result in lower votes than before (because the Blur token balanceOf would increase without being checkpointed into the votes), while the TokenLockup::balanceOf (which is accounted in BlurGovernor::getVotes) would decrease due to the higher totalClaimed;  correct updates of the voting power would require delegate calls;   gas consumption of BlurToken transfers would be lower. 
A2 Possible out-of-bounds access due to lack of length compatibility RESOLVED The fund() function of the TokenLockup.sol contract, iterates over the amounts[] array for sending the funds to the corresponding recipients. However, the two arrays provided as parameters are not checked for their length compatibility. Thus, if the amounts[] array is larger than the recipients[] one, the loop could try to access items out of bounds and revert. 
A3 Redundant overrides RESOLVED The BlurGovernor.sol contract inherits from several other contracts and some functions should be overridden as they appear in more than one inherited contract. However, the following functions are not needed to be overridden:  votingDelay()  votingPeriod()  quorum(...)  propose(...) Moreover, the following contracts are also not needed to be declared in the inherited list as the rest of the contracts already inherit from them:  Governor  GovernorVotes 
A4 Magic number used in BlurExchange::setFeeRate() RESOLVED Ideally, numeric constants should be visible prominently at the top of a contract, instead of being buried in the code, for easier maintainability and readability. In this case: BlurExchange::setFeeRate() 1 function setFeeRate(uint256 _feeRate) external { require(msg.sender == governor, "Fee rate can only be set by governor"); // Dedaub: Magic constant require(feeRate <= 250, "Fee cannot be more than 2.5%"); ... } A5 Compiler bugs INFO The code is compiled with Solidity 0.8.17. Version 0.8.17, at the time of writing, hasnt any known bugs. 1 
