L1 Struct Consumer can be simplied STATUS Resolved There is lile reason to keep subId both in the key and in the value of the s_consumers mapping. struct Consumer { uint64 subId; uint64 nonce; } mapping(address => mapping(uint64 => Consumer)) /* consumer */ /* subId */ private s_consumers; The information could be kept in a boolean, or encoded in the nonce eld. (E.g., start nonces from 1, to denote an allocated consumer with 0 requests.) 
L2 Unreachable code in getRandomnessFromProof Dismissed Under the current denition of the Chainlink blockhash store, the following is dead code (condition never true). The call to get the blochhash would have reverted. blockHash = BLOCKHASH_STORE.getBlockhash(rc.blockNum); if (blockHash == bytes32(0)) { revert BlockhashNotInStore(rc.blockNum); } Admiedly, it is good to code defensively relative to external calls, so the check is not without merit. 
L3 Extraneous check in fulfillRandomWords Resolved 0 The check if (gasPreCallback < rc.callbackGasLimit) { revert InsufficientGasForConsumer(gasPreCallback, rc.callbackGasLimit); } is unnecessary, given the stronger check that follows inside the call to callWithExactGas, with gasAmount being rc.callbackGasLimit: assembly { let g := gas() ... if iszero(gt(sub(g, div(g, 64)), gasAmount)) { revert(0, 0) } ... 
L4 The meaning of MIN_GAS_LIMIT is unclear Resolved Code comments describe MIN_GAS_LIMIT as: // The minimum gas limit that could be requested for a callback. // Set to 5k to ensure plenty of room to make the call itself. uint256 public constant MIN_GAS_LIMIT = 5_000; and /** ... * The minimum amount of gasAmount is MIN_GAS_LIMIT. (With gasAmount being the callbackGasLimit.) However, MIN_GAS_LIMIT is never compared against the callback gas limit, only against the currently available gas. Our interpretation was that it intends to account for the gas of other VRFCoordinatorV2 contract operations outside the client callback. If so, the limit of 5000 is too low. 0 OTHER/ ADVISORY ISSUES: This section details issues that are not thought to directly aect the functionality of the project, but we recommend considering them. ID Description STATUS 
A1 Variable s_fallbackWeiPerUnitLink left out of Config Dismissed It is unclear why variable s_fallbackWeiPerUnitLink is not included in the Config structure, since it is essentially handled as one of the variables therein. For example, the return statement of getConfig(): return ( config.minimumRequestConfirmations, config.fulfillmentFlatFeeLinkPPM, config.maxGasLimit, config.stalenessSeconds, config.gasAfterPaymentCalculation, config.minimumSubscriptionBalance, s_fallbackWeiPerUnitLink ); Is there some benet in keeping the size of Cong down to one word, given that it seems to be always read/wrien together with s_fallbackWeiPerUnitLink ? 
A2 Gas optimizations using unchecked wrapper Dismissed In VRFCoordinatorV2.sol there are a number of safe mathematical operations that could be made more gas eicient if wrapped in unchecked{} In fulllRandomWords: s_subscriptions[rc.subId].balance -= payment; s_withdrawableTokens[s_provingKeys[keyHash]] += payment; In OracleWithdraw: 0 s_withdrawableTokens[msg.sender] -= amount; s_totalBalance -= amount; In defundSubscription: s_subscriptions[subId].balance -= amount; s_totalBalance -= amount In cancelSubscription: s_totalBalance -= balance However, this recommendation could slightly downgrade readability and clarity. 
A3 Function ordering inside contracts Dismissed Consider adopting the oicial style guide for function ordering within a contract. In order of priority: external > public > internal > private and view > pure within the same visibility group. hps://docs.soliditylang.org/en/v0.8.7/style-guide.html#order-of-functions 
A4 Floating pragma INFO Use of a floating pragma: The floating pragma pragma solidity ^0.8.0; is used, allowing contracts to be compiled with any version of the Solidity compiler that is greater or equal to v0.8.0 and lower than v.0.9.0. Although the dierences between these versions should be small, for deployment, floating pragmas should ideally be avoided and the pragma be xed. A5 Compiler known issues INFO Solidity compiler v0.8.0, at the time of writing, has some known bugs (SignedImmutables, ABIDecodeTwoDimensionalArrayMemory, KeccakCaching). We believe that none of them aects the code: no immutable signed integer variables are declared, no multidimensional arrays seem to be used in the audited contracts, and no keccak hashing of constant memory arrays takes place. 0 0 
