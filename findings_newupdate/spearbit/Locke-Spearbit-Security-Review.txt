5.1.1 UnaccruedSeconds do not increase even if nobody is actively staking Severity: High Risk Context: Lock.sol.sol#L180 Description: The unstreamed variable tracks whether someone is staking in the contract or not. However, because of the division precision loss at Locke.sol#L164-L166 and Locke.sol#L187, unstreamed > 0 may happen even when everyone has already withdrawn all deposited tokens from the contract, i.e. ts.token = 0 for everyone. Consider the following proof of concept with only two users, Alice and Bob: • streamDuration = 8888 • At t = startTime, Alice stakes 1052 wei of deposit tokens. • At t = startTime + 99, Bob stakes 6733 wei of deposit tokens. • At t = startTime + 36, both Alice and Bob exits from the contract. At this point Alice’s and Bob’s ts.tokens are both 0 but unstreamed = 1 wei. The abovementined numbers are the resault of a fuzzing campaign and were not carefully crafted, therefore this issue can also occur under normal circumstances. function updateStreamInternal() internal { ... uint256 tdelta = timestamp - lastUpdate; if (tdelta > 0) { if (unstreamed == 0) { unaccruedSeconds += uint32(tdelta); } else { unstreamed -= uint112(tdelta * unstreamed / (endStream - lastUpdate)); } } ... } Recommendation: Consider using totalVirtualBalance == 0 instead of unstreamed == 0 
5.1.2 Old governor can call acceptGov() after renouncing its role through _abdicate() Severity: High Risk Context: Gov.sol#L30 Description: The __abdicate function does not reset pendingGov value to 0. Therefore, if a pending governor is set the user can become a governor by calling acceptGov. Recommendation: Consider setting pendinGov to address(0) inside the __abdicate function. function __abdicate() governed external override { address old = gov; gov = address(0); pendingGov = address(0); emit NewGov(old, address(0)); + } 9 
5.1.3 User can lose their reward due truncated division Severity: High Risk Context: Locke.sol#L321 Description: The truncated division can cause users to lose rewards in this update round which may happen when any of the following conditions are true: 1. RewardToken.decimals() is too low. 2. Reward is updated too frequently. 3. StreamDuration is too large. 4. TotalVirtualBalance is too large (e.g., stake near the end of stream). This could potentially happen especially when the 1st case is true. Consider the following scenario: • rewardToken.decimals() = 6. • depositToken.decimals() can be any (assume it’s 18). • rewardTokenAmount = 1K * 10**6. • streamDuration = 1209600 (two weeks). • totalVirtualBalance = streamDuration * depositTokenAmount / timeRemaining where depositToken- Amount = 100K 10**18 and timeRemaining = streamDuration (a user stakes 100K at the beginning of the stream) lastApplicableTime() - lastUpdate = 100 (about 7 block-time). Then rewards = 100 * 1000 * 10**6 * 10**18 / 1209600 / (1209600 * 100000 * 10**18 / 1209600) = 0.8267 < 1. User wants to buy the reward token at the price of 100K/1K = 100 deposit token but does not get any because of the truncated division. function rewardPerToken() public override view returns (uint256) { if (totalVirtualBalance == 0) { return cumulativeRewardPerToken; } else { // time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance uint256 rewards; unchecked { rewards = (uint256(lastApplicableTime() - lastUpdate) * rewardTokenAmount * ,! depositDecimalsOne) / streamDuration / totalVirtualBalance; } return cumulativeRewardPerToken + rewards; } } Recommendation: Consider scaling up cumulativeRewardPerToken and users reward. 10 5.2 Medium Risk 
5.2.1 The streamAmt check may prolong a user in the stream Severity: Medium Risk Context: Locke.sol#L165 Description: Assume that the amount of tokens staked by a user (ts.tokens) is low. This check allows another person to deposit a large stake in order to prolong the user in a stream (untilstreamAmt for the user becomes non-zero). For this duration the user would be receiving a bad rate or 0 altogether for the reward token while being unable to exit from the pool. if (streamAmt == 0) revert ZeroAmount(); Therefore, if Alice stakes a small amount of deposit token and Bob comes along and deposits a very large amount of deposit token, tt’s in Alice’s interest to exit the pool as early as possible especially when this is an indefinite stream. Otherwise the user would be receiving a bad rate for their deposit token. Recommendation: The ideal scenario is if streamAmt ends up being zero for a certain accTimeDelta, the user should be able to exit the pool with ts.tokens as long as they don’t receive rewards for the same duration. However, in practice, implementing this may create issues related to unaccured seconds. 
5.2.2 User can stake before the stream creator produced a funding stream Severity: Medium Risk Context: Locke.sol#410 Description: Consider the following scenario: 1. Alice stakes in a stream before the stream starts. 2. Nobody funds the stream,. 3. In case of an indefinite stream Alice loses some of her deposit depending on when she exits the stream. For a usual stream Alice will have her deposit tokens locked until endDepositLock. Recommendation: Two mitigatations are possible: 1. A frontend check warning the user if a stream does not have any reward tokens. 2. A check in the stake function which would revert when rewardTokenAmount == 0. 
5.2.3 Potential funds locked due low token decimal and long stream duration Severity: Medium Risk Context: Locke.sol#L166 Description: In case where the deposit token decimal is too low (4 or less) or when the remaining stream duration is too long, checking streamAmt > 0 may affect regular users. They could be temporarily blocked by the contract, i.e. they cannot stake, withdraw, or get rewards, and should wait until streamAmt > 0 or the stream ends. Altough unlikely to happen it still is a potential lock of funds issue. 11 function updateStreamInternal() internal { ... if (acctTimeDelta > 0) { if (ts.tokens > 0) { uint112 streamAmt = uint112(uint256(acctTimeDelta) * ts.tokens / (endStream - ,! ts.lastUpdate)); if (streamAmt == 0) revert ZeroAmount(); ts.tokens -= streamAmt; } ... } Recommendation: Consider scaling ts.tokens to 18 decimals of precision for internal accounting. 5.3 Low Risk 
5.3.1 Sanity check on the reward token’s decimals Severity: Low Risk Context: Locke.sol#L262 Description: Add sanity check on the reward token’s decimals, which shouldn’t exceed 33 because Token- Stream.rewards has a uint112 type. constructor( ) { uint64 _streamId, address creator, bool _isIndefinite, address _rewardToken, address _depositToken, uint32 _startTime, uint32 _streamDuration, uint32 _depositLockDuration, uint32 _rewardLockDuration, uint16 _feePercent, bool _feeEnabled LockeERC20( _depositToken, _streamId, _startTime + _streamDuration + _depositLockDuration, _startTime + _streamDuration, _isIndefinite ) MinimallyExternallyGoverned(msg.sender) // inherit factory governance // No error code or msg to reduce bytecode size require(_rewardToken != _depositToken); // set fee info feePercent = _feePercent; feeEnabled = _feeEnabled; // limit feePercent require(feePercent < 10000); // store streamParams startTime = _startTime; streamDuration = _streamDuration; // set in shared state 12 endStream = startTime + streamDuration; endDepositLock = endStream + _depositLockDuration; endRewardLock = startTime + _rewardLockDuration; // set tokens depositToken = _depositToken; rewardToken = _rewardToken; // set streamId streamId = _streamId; // set indefinite info isIndefinite = _isIndefinite; streamCreator = creator; uint256 one = ERC20(depositToken).decimals(); if (one > 33) revert BadERC20Interaction(); depositDecimalsOne = uint112(10**one); // set lastUpdate to startTime to reduce codesize and first users gas lastUpdate = startTime; } Recommendation: Consider adding sanity checks on the reward token’s decimals. 
5.3.2 Use a stricter bound for transferability delay Severity: Low Risk Context: LockeErc20.sol#L177 Description: modifier transferabilityDelay { // ensure the time is after end stream if (block.timestamp < endStream) revert NotTransferableYet(); _; } Recommendation: Consider using <= insted of < so that it can cover time up to endStream. block.timestamp <= endStream 
5.3.3 Potential issue with malicious stream creator Severity: Low Risk Context: Locke.sol#L307 Description: Assume that users staked tokens at the beginning. The malicious stream creator could come and stake an extremely large amount of tokens thus driving up the value of totalVirtualBalance. This means that users will barely receive rewards while giving away deposit tokens at the same rate. Users can exit the pool in this case to save their unstreamed tokens. 13 function rewardPerToken() public override view returns (uint256) { if (totalVirtualBalance == 0) { return cumulativeRewardPerToken; } else { unchecked { rewards = (uint256(lastApplicableTime() - lastUpdate) * rewardTokenAmount * ,! depositDecimalsOne) / streamDuration / totalVirtualBalance; } return cumulativeRewardPerToken + rewards; } } Recommendation: Consider constant stream monitoring. 
5.3.4 Users may exit the pool at a small duration before endStream to save tokens Severity: Low Risk Context: Locke.sol#L164 Description: Given a time t, that is very close to endStream and a time period $\Delta t$, assume that rewards for a particular user during this period is 0. Since the amount of deposit token streamed is inversely proportional to the time that is left, i.e. more deposit tokens are exchanged during a time period that is closer to the end of the stream rather than at the beginning of the stream, it is likely that the deposit token sold during $\Delta t$ is non-zero. A user can use this information to exit the stream just before endStream. In this process the user prevents some of their tokens from streaming while receiving no rewards for this duration! Suppose that there is a stream and two tokens testTokenB and testTokenA, where testTokenA is the reward token and testTokenB is the deposit token. Assume that the following conditions are true: assert(testTokenB.balanceOf(alice) == 200); assert(testTokenB.balanceOf(bob) == 100); assert(testTokenA.balanceOf(alice) == 0); assert(testTokenA.balanceOf(bob) == 0); Using the testing conventions from the repository, consider the following stream instance: 14 function test_equality_withdraw() public { testTokenA.approve(address(stream), 1000); stream.fundStream(1000); vm.startPrank(alice); testTokenB.approve(address(stream), 200); stream.stake(200); vm.stopPrank(); vm.startPrank(bob); testTokenB.approve(address(stream), 100); stream.stake(100); vm.warp(endStream - 1); stream.exit(); vm.stopPrank(); vm.warp(endStream + 1); vm.prank(alice); stream.claimReward(); vm.prank(bob); stream.claimReward(); } The above code results in the following assertions to be true after the test: assertEq(testTokenA.balanceOf(alice), 666); assertEq(testTokenA.balanceOf(bob), 333); assertEq(testTokenB.balanceOf(alice), 0); assertEq(testTokenB.balanceOf(bob), 1); The same assertions are true even if Bob does not exit from the stream. In case of an indefinite stream Bob would be able save some of his tokens from being sold. In the desired case Bob prevents some of his tokens from being locked up until endDepositLock is finished, both work in Bob’s favor. 5.4 Gas Optimization 
5.4.1 Moving check require(feePercent < 10000) in updateFeeParams to save gas Severity: Gas Optimization Context: Locke.sol#L237 Description: feePercent comes directly from LockeFactory’s feeParams.feePercent, which is configured in the updateFeeParams function and used across all Stream contracts. Moving this check into the updateFeeParams function can avoid checking in every contract and thus save gas. Recommendation: Consider moving the check in the updateFeeParams function. 15 
5.4.2 Use calldata instead of memory for some function parameters Severity: Gas Optimization Context: MerkleLocke.sol#L10, MerkleLocke.sol#L17 and MerkleLocke.sol#L75 Description: Having function arguments in calldata instead of memory is more optimal in the aforementioned cases. See the following reference. Recommendation: Consider using calldata instead of memory. 
5.4.3 Update cumulativeRewardPerToken only once after stream ends Severity: Gas Optimization Context: Locke.sol#597 Description: Since cumulativeRewardPerToken does not change once it is updated after the stream ends, it has to be updated only once. Recommendation: Consider changing the code as follows: - cumulativeRewardPerToken = rewardPerToken(); + if (lastUpdate < endStream) { + + } cumulativeRewardPerToken = rewardPerToken(); 
5.4.4 Expression 10**one can be unchecked Severity: Gas Optimization Context: Locke.sol#263 Description: uint256 one = ERC20(depositToken).decimals(); if (one > 33) revert BadERC20Interaction(); depositDecimalsOne = uint112(10**one) Recommendation: The following recommendation would perform checked exponentiation which is not that bad and just checks if one > 77 and the revert, otherwise it uses exp(10, one). unchecked { depositDecimalsOne = uint112(10**one) }; 
5.4.5 Calculation of amt can be unchecked Severity: Gas Optimization Context: Locke.sol#L536 Description: The value newBal in this context is always greater than prevBal because of the check located at Locke.sol#534. Therefore, we can use unchecked subtraction. Recommendation: - + + uint112 amt = uint112(newBal - prevBal); uint112 amt; unchecked { amt = uint112(newBal - prevBal); } 16 
5.4.6 Change lastApplicableTime() to endStream Severity: Gas Optimization Context: Locke.sol#L610, Locke.sol#L615, Locke.sol#L642, and Locke.sol#L639. Description: Since block.timestamp >= endStream in the abovementioned cases the lastApplicableTime function will always return endStream. Recommendation: Change lastApplicableTime() to endStream to save gas. 5.5 Informational 
5.5.1 Unused variable _ret Severity: Informational Context: Locke.sol#L812 Recommendation: Unused variable _ret can be either removed or forwarded in case of an error. 
5.5.2 Simplifying code logic Severity: Informational Context: LockeLens.sol#L26-L37 Description: if (timestamp < lastUpdate) { return tokens; } uint32 acctTimeDelta = timestamp - lastUpdate; if (acctTimeDelta > 0) { uint256 streamAmt = uint256(acctTimeDelta) * tokens / (endStream - lastUpdate); return tokens - uint112(streamAmt); } else { return tokens; } 17 function currDepositTokensNotYetStreamed(IStream stream, address who) external view returns (uint256) { unchecked { uint32 timestamp = uint32(block.timestamp); (uint32 startTime, uint32 endStream, ,) = stream.streamParams(); if (block.timestamp >= endStream) return 0; ( uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lastUpdate, bool merkleAccess ) = stream.tokenStreamForAccount(address(who)); if (timestamp < lastUpdate) { return tokens; } uint32 acctTimeDelta = timestamp - lastUpdate; if (acctTimeDelta > 0) { uint256 streamAmt = uint256(acctTimeDelta) * tokens / (endStream - lastUpdate); return tokens - uint112(streamAmt); } else { return tokens; } } } Recommendation: The above code can be optimized as follows: if (timestamp <= lastUpdate) { return tokens; } uint32 acctTimeDelta = timestamp - lastUpdate; uint256 streamAmt = uint256(acctTimeDelta) * tokens / (endStream - lastUpdate); return tokens - uint112(streamAmt); 
5.5.3 Unsused parameter _emergency_governor in constructor Severity: Informational Context: LockeFactory.sol#L29 Recommendation: Remove the unused parameter _emergency_governor from the constructor argument. 18 
5.5.4 Unused Imports Severity: Informational Context: Locke.sol#L6 and SharedState.sol#L3 Recommendation: Remove the aforementioned imports. 19 
