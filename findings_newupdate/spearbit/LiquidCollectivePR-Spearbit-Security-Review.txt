5.1.1 Calculation of CurrentValidatorExitsDemand and TotalValidatorExitsRequested using unsolicited exits can happen at the end of _setStoppedValidatorCounts(...) Severity: Informational Context: • OperatorsRegistry.1.sol#L541-L546 • OperatorsRegistry.1.sol#L569-L574 Description: Calculation of CurrentValidatorExitsDemand and TotalValidatorExitsRequested using unso- licited exits can happen at the end of _setStoppedValidatorCounts(...) to avoid extra operations like taking minimum per iteration of the loops. Note that: an = an(cid:0)1 (cid:0) min(an(cid:0)1, bn) ) an = a0 (cid:0) min(a0, n X i=1 bn) = max(0, a0 (cid:0) n X i=1 bn) Recommendation: Calculate the sum of all unsolicited exits and then add that to TotalValidatorExitsRe- quested and use the above formula to calculate CurrentValidatorExitsDemand at after the 2 for loops. Liquid Collective: Fixed in 86d45e72e83de8ead43b8b5f85fa583d64599330. Spearbit: Fixed. 
5.1.2 Define a new internal function to update TotalValidatorExitsRequested Severity: Informational Context: • OperatorsRegistry.1.sol#L584-L585 • OperatorsRegistry.1.sol#L848-L849 Description/Recommendation: quested and emitting the relevant event by introducing the new internal function: It would be best to refactor the logic of updating TotalValidatorExitsRe- function _setTotalValidatorExitsRequested(uint256 _currentValue, uint256 _newValue) internal { TotalValidatorExitsRequested.set(_newValue); emit SetTotalValidatorExitsRequested(_currentValue, _newValue); } Liquid Collective: Fixed in 18fa86eb117431bb2526d0708a359226fde6678a. Spearbit: Fixed. 4 
5.1.3 use _setCurrentValidatorExitsDemand Severity: Informational Context: • OperatorsRegistry.1.sol#L467 • OperatorsRegistry.1.sol#L589-L592 Description: If an update is needed for CurrentValidatorExitsDemand in _setStoppedValidatorCounts(...), the internal function _setCurrentValidatorExitsDemand is not used. Recommendation: Make sure _setCurrentValidatorExitsDemand is used whenever an update for Current- ValidatorExitsDemand is required Liquid Collective: Fixed in b39846d23642f833246d0d335c4ad2930ecb515e. Spearbit: Fixed. 
5.1.4 Changes to the emission of RequestedValidatorExits event during catch-up Severity: Informational Context: • OperatorsRegistry.1.sol#L488 • OperatorsRegistry.1.sol#L546 Description: The event log will be different between the old and new implementations. In the old implementation, the latest RequestedValidatorExits event in the logs will always contain the most up-to-date count of requested exits (count) of an operator after a "catch-up" attempt. This is because a new RequestedValidatorExits event with the up-to-date currentStoppedCount is emitted at the end of the async requestValidatorExits function call. However, in the new implementation, the latest RequestedValidatorExits event in the logs contains the outdated or previous count of an operator after a "catch-up" attempt since a new RequestedValidatorExits event is not emitted at the end of the Oracle reporting transaction. If any off-chain component depends on the latest RequestedValidatorExits event in the logs to determine the count of requested exits (count), it might potentially cause the off-chain component to read and process outdated information. For instance, an operator's off-chain component might be reading the count within the latest Request- edValidatorExits event in the logs and comparing it against its internal counter to decide if more validators need to be exited. The following shows the discrepancy between the events emitted between the old and new implementations. Catch-up implementation in the previous design 1) Catch-up was carried out async when someone called the requestValidatorExits > _pickNextValida- torsToExitFromActiveOperators function 2) Within the _pickNextValidatorsToExitFromActiveOperators function. Assume an operator called opera It will attempt to "catch-up" by and its currentRequestedExits is less than the currentStoppedCount. performing the following actions: 1) Emit UpdatedRequestedValidatorExitsUponStopped(opera, currentRequestedExits, currentStoppedCount) event. 2) Let x be the no. of validator count to "catch-up" (x = currentStoppedCount (cid:0) currentRequestedExits) 3) opera.picked will be incremented by x. Since opera.picked has not been initialized yet, opera.picked = x 3) Assume that the opera is neither the operator with the highest validation count nor the operator with the second highest. As such, opera is not "picked" to exit its validators 5 4) Near the end of the _pickNextValidatorsToExitFromActiveOperators function, it will loop through all op- erators that have operator .picked > 0 and perform some actions. The following actions will be performed against opera since opera.picked > 0: 1) Emit RequestedValidatorExits(opera, currentStoppedCount) event 2) Set opera.requestedExits = currentStoppedCount. 5) After the transaction, two events were emitted for opera to indicate a catch-up had been attempted. • UpdatedRequestedValidatorExitsUponStopped(opera, currentRequestedExits, currentStoppedCount) • RequestedValidatorExits(opera, currentStoppedCount) Catch-up implementation in the new design 1. Catch-up was carried out within the _setStoppedValidatorCounts function during Oracle reporting. 2. Let _stoppedValidatorCounts[idx] be the currentStoppedCount AND operators.requestedExits be currentRequestedExits 3. Assume an operator called opera and its currentRequestedExits is less than the currentStoppedCount. It will attempt to "catch-up" by performing the following actions: 1. Emit UpdatedRequestedValidatorExitsUponStopped(opera, currentRequestedExits, currentStoppedCount) event. 2. Set opera.requestedExits = currentStoppedCount. 4. After the transaction, only one event was emitted for opera to indicate a catch-up had been attempted. • UpdatedRequestedValidatorExitsUponStopped(opera, currentRequestedExits, currentStoppedCount) In addition, as per the comment below, it was understood that unsolicited exits are considered as if exit requests were performed for them. In this case, the latest RequestedValidatorExits event in the logs should reflect the most up-to-date count of exit requests for an operator including unsolicited exits at any time. File: OperatorsRegistry.1.sol 573: ,! 574: ,! were performed for them vars.currentValidatorExitsDemand); // we decrease the demand, considering unsollicited exits as if the exit requests vars.currentValidatorExitsDemand -= LibUint256.min(unsollicitedExits, Recommendation: Consider updating the implementation to ensure that the latest RequestedValidatorExits event in the logs contains the most up-to-date count of exit requests for an operator including unsolicited exits at any time. Liquid Collective: We indeed considered that emitting RequestedValidatorExits on catch-up could confuse Node Operators because we are not requesting them to exit. So what we can consider is • RequestedValidatorExits is always emitted to signal a NO to perform the action to exit 1 or more validator key. • UpdatedRequestedValidatorExitsUponStopped is emitted so indexers/off-chain system can update requested values but does not signal NOs. Spearbit: Acknowledged. 6 
