4.1.1 The storage slots corresponding to _implementation and _owner could be accidentally overwritten Severity: High Risk Context: ProxyStorage.sol#L7-L10 contract ProxyStorage { address internal _implementation; address internal _owner; } The state variables _implementation and _owner are at slots 0 and 1. The protocol architecture relies on executors calling metaDelegateCall to veriﬁer contracts. Therefore, the storage slots are shared with the storage space of the veriﬁers. Risk: The ﬁrst 2 state variables declared in a veriﬁer will overlap with _im- plementation and _owner. Accidentally changing these variables will result in changing the implementation and changing the owner. Funds could be stolen or made inaccessible (accidentally or on purpose). Recommendations: 1. Store the variables at a quasi random memory location determined by a Keccak-256 hash. This pattern is used in Bit.sol#L33. 2. Let the veriﬁers inherit from ProxyStorage.sol so that the variables _im- plementation and _owner are mapped in storage and will not be overwrit- ten accidentally. It is recommended to check the storage layout using solc --storage-layout or the equivalent standard-json ﬂag to verify that this is indeed the case; we recommend building a small tool for doing this. 3. Store the _implementation and the _owner as constants or immutable. This allows for a smaller proxy that saves gas. However, this requires some architectural changes. 5 Brink: We chose to ﬁx, but took a slightly different approach than any of the recommended ﬁxes. Our ﬁx is closest to recommendation 3.While recommen- dations 1 and 2 would have been simpler to implement, and may prevent an accidental overwrite of the _implementation and _owner values, ﬁxing in this way would not prevent an attacker from overwriting these values by tricking an account owner into signing permissions for the overwrite. We wanted to make the values fully immutable after Proxy deployment. We up- dated Proxy.sol to include two constants: ACCOUNT_IMPLEMENTATION, which is the deterministic address for the Account.sol deployment and will be consis- tent across all chains, and OWNER, which is set as a placeholder address 0xfe- feFEFeFEFEFEFEFeFefefefefeFEfEfefefEfe. We created AccountFactory.sol which dynamically creates Proxy init code, inserting the actual owner address at the same location as the OWNER placeholder. When Proxy makes a dele- gatecall to Account, the value of OWNER is read using extcodecopy (ProxyGet- table.sol). Constant and immutable storage read from a contract executed via delegate will be read from the implementation contract (Account.sol), not the calling contract (Proxy). Using extcodecopy lets us read a constant value from the Proxy deployed bytecode. Note: In order for us to compile Proxy.sol with the OWNER placeholder included in the deployed bytecode, we had to include a reference to it in the contract (out- side of the constructor). We found Proxy.sol#L40 to be the most gas efﬁcient way to accomplish this. We believe it has no security impact on the Proxy, and only increases the gas for incoming ETH transfers by a negligible amount. Brink Update: We updated to use Minimal Proxy with the owner address ap- pended at the end of the deployed bytecode commit 0ed725b. Spearbit: We welcome this change, and performed a follow up review focussed on the modiﬁcation on Minimal Proxy contract. Overall, we agree that the issues are resolved. Detailed comments can be found in the follow up report. 4.2 Medium Risk 
4.2.1 Risk of replay attacks across chains Severity: Medium Risk, Gas Optimization Context: EIP712SignerRecovery.sol#L12-L14 Currently, for deploying on EVM compatible chains, the unique identiﬁer _- chainId is speciﬁed by Brink. The users need to trust the deployer, i.e. Brink 6 to have unique values of _chainId for different chains. If the deployer violates this condition, there is a risk of replay attacks, where signed messages on one chain may be replayed on another chain. Recommendation: Read _chainId on chain directly, using block.chainid (avail- able from Solidity 0.8.0) or using chainid() in inline assembly for older solidity versions, rather than as a constructor parameter. It is also a gas optimization (saves 1 gas). constructor(uint256_chainId) EIP7125SignerRecovery(chainId_){ ... } Brink: Fixed in commit feef7d9. There is potential risk that a chain could hard- fork a change to the chainID value, which would invalidate all signed messages. The main beneﬁt and reason for the ﬁx was so the Account.sol address can be consistent across all chains. Since Proxy.sol now sets this address to the ACCOUNT_IMPLEMENTATION constant, this keeps all Proxy addresses consistent across all chains as well. Spearbit: Resolved. We think that a hardfork / protocol-upgrade that changes the value of chainid is extremely unlikely on almost all big chains, therefore this risk is acceptable. 
4.2.2 Selfdestruct risks in delegateCall() Severity: Medium Risk Context: Account.sol#L48-L57 function delegateCall(address to, bytes memory data) external { require(proxyOwner() == msg.sender, "NOT_OWNER"); assembly { let result := delegatecall(gas(), to, add(data, 0x20), mload(data), 0, 0) if eq(result, 0) { returndatacopy(0, 0, returndatasize()) revert(0, returndatasize()) } } } The address where Account.sol gets deployed can be directly called. There is the risk of a potential selfdestruct, which would result in user wallets getting bricked. This risk depends on the access control of the functions delegateCall, metaDelegateCall, and metaDelegateCall_EIP1271. However, we couldn’t ﬁnd a hole in the access control. We would still recommend the following changes: 7 1. Explicitly enforce that these functions are only delegatecalled. The follow- ing contract demonstrates how this can be achieved. abstract contract OnlyDelegateCallable { address immutable deploymentAddress = address(this); modifier onlyDelegateCallable() { require(address(this) != deploymentAddress); _; } } 2. Note that the Solidity compiler enforces call protection for libraries, i.e., the compiler automatically adds an equivalent of the above onlyDelegate- Callable modiﬁer to state modifying functions. Changing the contract to a library would require additional changes in the codebase. 3. Deploy Account.sol via CREATE2 so it can be redeployed if necessary. Note: Assuming that the current access control can be broken, and that the ad- dress corresponding to the Account.sol contract holds funds, then an attacker can steal this funds from this address. However, this is not the most signiﬁcant risk. Brink: Fixed in commit 3afeaf1. Spearbit: Resolved. 
4.2.3 Check for non-zero data Severity: Medium Risk Context: Account.sol#L76-L78 bytes memory callData = abi.encodePacked(data, unsignedData); The function metaDelegateCall() does not currently check if data is non-empty. Risk: If data.length is equal to 0, it should call the fallback or receive func- tion, however, a malicious veriﬁer can redirect this call to another function by crafting unsignedData. For example, assume that the user signed a meta trans- action to the following contract’s fallback function: 8 contract C { fallback() external { // do something useful } function f() external { // steal funds } } The executor can append the selector of f to unsignedData, thereby executing the call to f instead of to the fallback function. Note: similarly, if the data (signed) is less than 4 bytes in length, i.e., length of a function selector, executors could potentially redirect the actual call to another function in the same contract, and potentially steal funds. Recommendation: Check data.length is greater than or equal to 4 bytes. require(data.length > 4); Brink: We chose not to implement a ﬁx. Our reasoning is that there are many ways for a malicious veriﬁer to attack a user’s account, but all of these attacks re- quire tricking the user into signing a message with the malicious veriﬁer contract set as the to address. Even if we prevent valid signing of empty call data, users could still sign malicious messages with valid call data. Reverting on empty call data doesn’t reduce the potential for this type of attack. These attacks need to be mitigated off-chain. Spearbit: As this falls under the trust model for the protocol, i.e., trusting veriﬁer contracts, we accept Brink’s approach. See the section on veriﬁers that talks about the risk model. 4.3 Low Risk 
4.3.1 Implement SafeERC20 to avoid non-zero to non-zero approvals Severity: Low Risk Context: TransferHelper.sol#L12-L13 (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value)); ,! require(success && (data.length == 0 || abi.decode(data, (bool))), ,! 'APPROVE_FAILED'); 9 Current function allows for non-zero to non-zero approvals, however, some ERC20 tokens would revert in such cases. Reference: approval race protec- tions Recommendations: 1. Implement the SafeERC20 from OpenZeppelin, in particular safeApprove, if it is used. 2. Replace the hex codes with .selector, i.e. abi.encodeWithSelector(token.approve.selector, to, value); 3. The function safeApprove is currently not used. We recommend removing safeApprove(). Brink: We removed TransferHelper from LimitSwapVerifiers commit 7e6df62, because transfer checks were not needed here. It is still used in TransferVeri- fier, but safeApprove() is not used. We will consider implementing this ﬁx for future veriﬁers if safeApprove() is used. Spearbit: Resolved. 4.4 Gas Optimizations and Informational 
4.4.1 The function storageLoad() is not required Severity: Gas Optimization Context: Account.sol#L25-L27 The function storageLoad function is unnecessary. Recommendation: This information can be obtained off-chain using getStor- ageAt JSON RPC method. This will reduce overall gas since the function stor- ageLoad will end up in the function dispatch, making other function calls more expensive. For additional info, here is the part where storageLoad is used from the sdk: Account.js#L269 Brink: Fixed in commit 743eea1. Spearbit: Resolved. 10 
4.4.2 Use _owner directly instead of the function proxyOwner Severity: Gas Optimization The proxyOwner() gettable is called several times in Account.sol. Recommendation: Use _owner directly. mutable and query the owner using a callback to the proxy. If possible, consider making it im- 1. Account.sol#L35 2. Account.sol#L53 3. Account.sol#L83 require(proxyOwner() == signer, "NOT_OWNER"); Note: this optimization may be redundant if a newer version of solidity is used (>= 0.8.2). It has a bytecode level inliner that can inline proxyOwner. Brink: No longer relevant after the changes in proxy: commit d2df98f. Spearbit: Resolved. 
4.4.3 Copy _delegate code to be inline in the fallback() function Severity: Gas Optimization Context: Proxy.sol#L27-L29 fallback() external payable { _delegate(_implementation); } Currently, the function _delegate is declared outside the fallback() function. However, inlining this function would save some gas. Recommendation: 1. Use the code inside the _delegate function inside the fallback() func- tion. Save around 20-30 gas. 2. Remove the _delegate function. Note: the improvements for the inliner in Solidity 0.8.2 is not relevant here, i.e., this function needs to be manually inlined. Brink: Fixed in commit 8ec3c96. 11 Spearbit: Resolved. 
4.4.4 The functions metaDelegateCall() and externalCall can be made payable Severity: Gas Optimization Context: 1. Account.sol#L34 2. Account.sol#L76 Recommendation: Make the metaDelegateCall() function payable. This saves gas by omitting the check for the absence of ETH attached to the call. Brink: Fixed in commit 5014986. Spearbit: Resolved. 
4.4.5 Change memory to calldata Severity: Gas Optimization For external function parameters, it is often more optimal to have the reference location to be calldata instead of memory. Details can be found in the appendix. Examples: 1. The variable signature in the function metaDelegateCall_EIP1271(). Con- text: Account.sol#L109-L116. function metaDelegateCall_EIP1271( address to, bytes memory data, bytes memory signature, bytes memory unsignedData ,! ) external { require(_isValidSignature( proxyOwner(), keccak256(abi.encode(META_DELEGATE_CALL_EIP1271_TYPEHASH, to, keccak256(data))), signature ,! ), , "INVALID_SIGNATURE"); 2. The variable initCode in the function deployAndExecute. Context: De- ployAndExecute.sol#L23. 12 function deployAndExecute(bytes memory initCode, bytes32 salt, bytes memory ,! execData) external { Note: this is assuming that the last suggestion about having the code inline is not implemented. Note: the gas for the deployAndExecute’s unit test decreased by around 1000 after this change. 3. The variable data in the functions tokenToToken, ethToToken, and token- ToEth. Context: LimitSwapVerifier.sol#L33-L34. function tokenToToken( uint256 bitmapIndex, uint256 bit, IERC20 tokenIn, IERC20 tokenOut, uint256 tokenInAmount, uint256 tokenOutAmount, uint256 expiryBlock, address to, bytes memory data ,! ) 4. The variable signature in the function _recoverSigner. Context: EIP712- SignerRecovery.sol#L19. function _recoverSigner(bytes32 dataHash, bytes memory signature) internal view ,! returns (address) { Brink: 1. Fixed in commit 2831884 and commit 68c68ef. 2. DeployAndExecute.sol was replaced with DeployAndCall.sol. With the new AccountFactory.sol there is no initCode parameter. 3. Fixed in commit 1a0345f. 4. Fixed in commit 2831884. Sperabit: Resolved. 
4.4.6 initCode could be hard coded if it is always the same Severity: Gas Optimization Context: DeployAndExecute.sol#L23 function deployAndExecute(bytes memory initCode, bytes32 salt, bytes memory ,! execData) external { Recommendation: Hard code initCode into the contract. This saves a signiﬁ- cant amount of gas, as well as guarantee that the right init code is used. 13 new Proxy{salt: salt}(implementation, proxyOwner); If the code for the deployed contract comes from calldata (as is the case here), it has to go through an inefﬁcient copy to memory (via a for-loop that reads 32- byte chunks of calldata using calldataload, and storing them in memory via mstore). On the other hand, if the initCode is available along with the runtime code of the contract and is called via new Proxy{salt: ...}(...), (it does not matter if it is a create2 or create), it is more efﬁcient, because it uses codecopy to place the underlying initcode in memory rather than the inefﬁcient for loop. this assumes that the initCode remains consistent, which is likely the Note: case for Brink. Brink: We created AccountFactory.sol to deploy Proxy account contracts with constant account implementation addresses and owners, as part of the ﬁx. Proxy initCode is now dynamically created on deploy. Spearbit: Resolved. 
4.4.7 The function proxyCall can be removed Severity: Informational, Gas Optimization Context: CallExecutor.sol#L52 function proxyPayableCall(address to, bytes memory data) public payable { There isn’t a need for proxyCall as proxyPaybleCall is more general. The function selector of the function proxyCall(...) is smaller than the selector of proxyPayableCall. Therefore, in the function dispatch, proxyCall will appear ﬁrst (Note: this is not always true). Recommendation: We recommend getting rid of proxyCall and just use prox- yPayableCall, after, perhaps renaming it. Brink: We chose not to ﬁx because of the low impact, but may ﬁx in future veriﬁer contracts. 
4.4.8 Gas optimization for keccak256() Severity: Gas Optimization 14 Context: Bit.sol#L33 return keccak256(abi.encodePacked("bmp", bitmapIndex)); Currently, Brink.trade is using keccak256() every time on line 33. Recommendation: It may be worth computing the keccak hash as a constant, and the pointer is computed by incrementing this constant. This avoids comput- ing the Keccak-256 hash at runtime. For example, deﬁne a bytes32 initialPtr = keccak256(“bmp”); Then the actual pointer can be computed by: uint256 ptr = initialPtr + n; Note that it’s critical that value of ptr is not the slot 0 or 1. Otherwise, the storage slots will collide with the owner and implementation for proxy. One way to achieve this is by limiting the type of n to be a short unsigned integer type, for example uint16. Brink: Fixed in commit 1fdf2ea. Spearbit: Resolved. 
4.4.9 Use inline assembly to avoid short-circuiting Severity: Gas Optimization Context: Bit.sol#L26-L28. function validBit(uint256 bit) internal pure returns (bool) { return bit > 0 && bit & bit-1 == 0; } Solidity has short-circuiting for boolean operations. The way it’s implemented is by using if (i.e., jumpi instruction) for each sub expression. This can be unnecessary in some cases, especially, when the sub expressions are side- effect free. Recommendation: Implement it using inline assembly to avoid the short-circuiting: isValid := and( iszero(iszero(bit)), iszero(and(bit, sub(bit, 1))) ) 15 Note: this expression is parsed as ((bit > 0) && (bit & (bit - 1))) == 0. If this is the intended, consider adding braces to make it more explicit. Brink: Fixed in commit cb078d3, and commit 5f487e8. Spearbit: Resolved. 
4.4.10 Use nonces for Bit.sol Severity: Gas Optimization, Informational Context: Bit.sol#L8 library Bit { ... } Currently, for replay protection, random storage slots are reused up to 256 times, using 1 bit per transaction. With a large number of transactions more and more storage slots are used. Recommendation: Use nonces for storing transactions that are currently in ﬂight. For example, assuming that there can only be at most 10 in-ﬂight trans- actions, consider a state variable uint256[10] nonces. For each in-ﬂight trans- action, one of the nonces can be used, then incremented during the transaction. An advantage is that each storage slot can be used up to 2**256 times (in con- trast, currently, it can be used at most 256 times), leading to some gas savings. Also if more simultaneous transactions in ﬂight are expected, then a dynamic If you can deﬁne an array should be used to allow for more nonces. Note: upper limit to the transactions in ﬂight, you can use ﬁxed storage slots (0 - 10) in the lower part of the storage, which might be cheaper in the future with the proposed move to stateless ethereum. Note: this suggestion assumes that _implementation and _owner variables are moved to immutable variables; otherwise, using the slots 0 and 1 would lead to storage slot clash and potential lockup of proxied account. Brink: We chose not to ﬁx because of the complexity of implementation com- pared to the relatively small gas savings. We’ll consider this implementation for future veriﬁer contracts. Spearbit: While, this is reasonable, it’s important that all veriﬁers have compat- ible mechanisms to prevent replay prevention. This avoids using a nonce that was scheduled by another veriﬁer, by accident. 16 
4.4.11 Upgrade to the latest compiler version: 0.8.10 Severity: Informational, Gas optimization Context: All contracts. Currently, brink.trade is using the 0.7.6 version of the compiler. Recommendation: Upgrade the compiler to 0.8.10 and lock it for that spe- ciﬁc version. Advantages to switching include external calls requiring less gas (extcodesize is no longer done on functions that have return parameters). Ex- ample of an external call that will be 100 gas cheaper: EIP1271Validator.sol#L19 pragma solidity =0.8.10 Brink: Fixed. • commit 9fb87e4 and • commit 864aef4. Spearbit: Resolved. 
4.4.12 Custom errors from version 0.8.4 are more gas efﬁcient Severity: Gas Optimization Context: All uses of revert strings, for example DeployAndExecute.sol#L29 require(createdContract != address(0), "DeployAndExecute: contract not ,! deployed"); Custom errors from Solidity 0.8.4 are more gas efﬁcient than revert strings, when the revert condition is met, and also decreases deploy time costs. Recommendation: Use 0.8.4’s custom errors instead to save on gas. For more information: Solidity blog. Brink: Fixed commit 1260ad0 and commit d1bf851 Spearbit: Resolved. 
4.4.13 Add call protection to LimitSwapVerifier Severity: Informational 17 The contract LimitSwapVerifier is only meant to be delegatecalled. This can be explicitly enforced by adding call protection. Recommendation: Add call protection or, alternatively, use a library instead of a contract, as the solidity compiler can automatically add this check. Example of call protection: abstract contract OnlyDelegateCallable { address immutable deploymentAddress = address(this); modifier onlyDelegateCallable() { require(address(this) != deploymentAddress); _; } } Brink: We chose not to implement the ﬁx because there is no risk of selfde- struct, or any other consequence of calling LimitSwapVerifier directly. 
4.4.14 Not following solidity memory model in inline assembly usage Severity: Informational Context: 1. Account.sol#L36 assembly { let result := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 { revert(0, returndatasize()) } default { return(0, returndatasize()) } } 2. DeployAndExecute.sol#L32-L42 These inline assembly snippets does not follow Solidity’s memory model. The returndatacopy of calls are stored at memory location starting from 0. How- ever, this may lead to overwriting the free memory pointer as well as writing beyond 0-64. Risk: 18 1. This may cause issues in the future versions, if you need to use stack to memory mover. This is true for almost all inline assembly usage. Refer- ence: (https://twitter.com/ethchris/status/1439879409675259907) 2. The free memory pointer may be overwritten by the return data. If a future refactoring of the code passes the control ﬂow to high-level solidity, i.e., outside the inline assembly block, this would lead to undeﬁned behaviour. Recommendation: This currently will not cause any issues. Be aware of up- grading to a different version of the compiler while using stack to memory mover or a refactoring that passes control ﬂow outside the inline assembly block that overwrites the free memory pointer. The idiomatic approach would be to store dynamic data starting from mload(64) (the free memory pointer) rather than from 0. However, making this change is not strictly necessary right now. Brink: No ﬁx implemented. The current implementation does not adversely affect functionality, and will not have an impact on any of the call data execution that happens before returndatacopy is executed. 
4.4.15 Improving documentation regarding delegatecalls. Severity: Informational Context: Account.sol#L9 There is no explicit documentation stating that the Account contract is supposed to only be delegatecalled. Recommendation: Add a NatSpec comment that the contract is only supposed to be delegatecalled. Brink: Fixed commit c92b533 Spearbit: Resolved. 
4.4.16 Variables can be deﬁned inline Severity: Informational Context: Account.sol#L12-L21 Currently, the constants META_DELEGATE_CALL_TYPEHASH and META_DELEGATE_- CALL_EIP1271_TYPEHASH are not deﬁned inline. They could be deﬁned inline to 19 improve readability. Recommendation: Declare these variables inline. bytes32 constant META_DELEGATE_CALL_TYPEHASH = keccak256("MetaDelegateCall(address to,bytes data)"); ,! bytes32 constant META_DELEGATE_CALL_EIP1271_TYPEHASH = ,! keccak256("MetaDelegateCall_EIP1271(address to,bytes data)"); Brink: Chose not to implement because impact is very low. 
4.4.17 Add events to other functions beyond cancel Severity: Informational Context: CancelVerifier.sol#L16 emit Cancel(bitmapIndex, bit); There is an emit in cancel(), but not other functions. Recommendation: Retrieving the execution state is important for cancel() as well as for other functions. If you are doing an emit, it is probably better to do it from Access.sol. This way it is always there and opens up the opportunity to create a graph or subgraph for it. Brink: We have generally avoided emitting events with data that is already included in functional params. We may actually remove this Cancel event in a future version of CancelVerifier. 
4.4.18 The function proxyCall can be made external Severity: Informational Context: CallExecutor.sol#L30 function proxyCall(address to, bytes memory data) public { Function currently marked public, however, it is never called internally. Recommendation: Mark function external. It is generally a good practice to apply the most constrictive visibility possible. Brink: We chose not to ﬁx because of the low impact, but may ﬁx in future veriﬁer contracts. 20 
4.4.19 Contracts that could be made abstract Severity: Informational It is a good practice to mark contracts that are not meant to be instantiated di- rectly as abstract contracts. This is an idiomatic way to ensure that a contract is not meant to be deployed by itself. The following contracts can be made abstract: 1. EIP712SignerRecovery 2. EIP712Validator 3. ProxySettable 4. ProxyGettable 5. ProxyStorage Brink: Fixed commit 3b6d6dd, and ProxySettable.sol was removed, as it was no longer relevant. Spearbit: Resolved. 
4.4.20 Floating pragma is set Severity: Informational Context: All contracts. The current pragma Solidity directive is ˆ0.7.6. It is recommended to specify a speciﬁc compiler version to ensure that the byte code produced does not vary between builds. Contracts should be deployed using the same compiler ver- sion/ﬂags with which they have been tested. Locking the pragma (for e.g. by not using ˆ in pragma solidity 0.8.10) ensures that contracts do not acciden- tally get deployed using an older compiler version with known compiler bugs. Recommendation: Lock the compiler to a speciﬁc version. pragma solidity =0.7.6; Brink: Fixed • commit 9fb87e4 and • commit 864aef4. 21 Spearbit: Resolved. 5 A note on veriﬁers The Brink protocol relies on veriﬁers, i.e., smart contracts that perform a speciﬁc automation. This is achieved by signing a meta delegatecall to these smart contracts. Because of that, it is very important that these veriﬁer contracts are well vetted. For example, the risk of a malicious veriﬁer directly impacts the user potentially losing all their funds by signing a message to a malicious veriﬁer. There are several ways in which a veriﬁer can hide their malicious behaviour. Some examples are given below: 1. Veriﬁer Contract is upgradable: If a veriﬁer contract is upgradable, and a user signs a message to this contract, the veriﬁer can upgrade the contract just before the execution, to make the signed data malicious. • Since a typical upgradable contract works by delegatecalling its im- plementation, where the implementation is stored in storage, these kinds of contracts are inconsistent with Brink.trade. This is because the meta transactions delegatecalls into the veriﬁer, which means that the veriﬁer cannot use its own storage. • A non-typical upgradable pattern involves CREATE2 deploy + selfde- struct + CREATE2 redeploy, where the second redeploy will deploy a different runtime code. There are some tricks involved getting the same address, but having different runtime code: example. If the signer also signs the extcodehash for the veriﬁer contract, such at- tacks can be prevented. If during execution, the extcodehash is dif- ferent from what was part of the signature, the execution reverts. However, this might not cover all possible cases. 2. If anyone can add arbitrary veriﬁer contracts, you could trick a user in the following way. • The veriﬁer contract has the innocent looking function with signature: cancel(uint248 bitmapIndex, uint248 bit) external. • The veriﬁer contract has a function named safeguardfunds_<nonce>, where nonce is engineered to collide with the selector of the function cancel(uint256,uint256). Such collisions can be easily found in a few minutes or one can also lookup 4byte.directory. 22 • The user may be tricked to sign in to our cancel veriﬁer, however, in turn it executes safeguardfunds_<nonce>, which steals funds. Recommendations: 1. Thoroughly vet all veriﬁer contracts, including the function selectors. 2. Avoid veriﬁer contracts that are upgradable. 3. Consider enforcing that all veriﬁers should be libraries with external func- tions. The solidity compiler enforces that libraries do not have state vari- ables and automatically adds call protection to state modifying functions. 4. Design modular veriﬁers doing only a single task. 6 A note on executors The Brink protocol relies on executors running the transaction when certain conditions are met. For example, assume that a user tries to do a limit swap of 1 ETH to 5000 DAI, an executor is required to watch the ETH to DAI price, and perform a swap when the price is greater than 5000 DAI. The executor proﬁts any difference in price. It is therefore imperative that the protocol relies on more than one executor. This is because a single executor can decide to prolong the execution, for example, by waiting for the ETH price to be 5500 DAI, making a net proﬁt of 500 DAI. Note: This strategy involves the risk of losing out on potential rewards, by wait- ing for the price to move. Regardless, having multiple independent executors would make the protocol more efﬁcient by making the margins low. We recommend Brink to onboard new executors to the platform. The MEV Job Board for example would be a good place to advertise for bots. A second issue is related to how the executors perform the execution. Brink mentioned that currently these transactions are sent to the public mempool (via Alchemy). Assuming permissionless contracts are used all throughout, this leads to front-running risk, as anyone can copy the calldata for the transaction and front-run the transaction. The original executor’s transaction will still end up in the chain, except that the transaction would revert, leading to the executor paying for gas and getting nothing in return. Although front-running does not directly add security risk to the protocol, it indirectly affects it, as being an ex- ecutor becomes less proﬁtable. Note that regardless of the front-running issue, 23 the problem of executors paying the gas for a failed transaction can still happen in practice. If there are multiple executors trying to concurrently send the same transaction to the mempool, only one of them can proﬁt from the opportunity. One way to solve this issue is to use a service like ﬂashbots. This offers two advantages: 1. The transaction will remain private in the mempool, i.e., font-running can be avoided. 2. You can conﬁgure to not include a transaction in the block if it reverts (this is the default conﬁguration). This would prevent executors from paying gas for reverting transactions. Note: an alternative for (2) along with (1) is to use ethermine’s MEV relay. How- ever, it has a lower hash rate than Flashbots. Note: an alternative for (1) is to use taichi’s private transaction. 7 Appendix 7.1 Gas optimization: Use calldata instead of memory for func- tion parameters In some cases, having function arguments in calldata instead of memory is more optimal. Consider the following generic example: contract C { function add(uint[] memory arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < length; i++) { sum += arr[i]; } } } In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefﬁcient. Consider the following snippet instead: 24 contract C { function add(uint[] calldata arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < length; i++) { sum += arr[i]; } } } In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value. Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract. In short, use calldata instead of memory if the function argument is only read. Note that in older Solidity versions, changing some function arguments from memory to calldata may cause “unimplemented feature error”. This can be avoided by using a newer (0.8.*) Solidity compiler. 25 
