4.1.1 Documents Reviewed • PIL – Polynomial Identity Language (PIL): A Machine Description Language for Veriﬁable Computation – v1.0, February 13 2023 • eSTARK – eSTARK: Extending the STARK Protocol with Arguments – v1.0, February 10, 2023 – v1.2, March 15 2023 • Recursion – Recursion, aggregation, and composition of proofs – v1.0 February 13 2023 • fﬂonk – fﬂonk: a Fast-Fourier inspired veriﬁer efﬁcient verson of PlonK – ePrint Archive – Polygon Documentation (February 20 2023) 
4.1.2 PIL + eSTARK Deﬁnition of Connection argument is inconsistent between the PIL and eSTARK v1.0 documents (Informa- tional) The connection argument in Section 1.5 of eSTARK is meant to be identical to Section 1.9, Deﬁnition 4 of the PIL document (labeled Multi-Column Copy-Satisﬁability). However, Section 1.9, Deﬁnition 3 (labeled Connec- tion Argument) refers to the Single-Column variant. • Suggestion: In the PIL documentation, label Deﬁnition 3 to be the Single-Column Connection Argument and specify in the eSTARK documentation in Section 1.5 the description of the Multi-Column Connection Argument. Deﬁnition of Connection argument in eSTARK v1.0 contains inconsistent deﬁnition of partition (Inconsis- tency) The connection argument in Section 1.5 of the eSTARK document deﬁnes a partition T={T1,...,Tk}. This implies that T1,...Tk are partition sets. However, there is no need to limit the number of partition sets to k. As described in Section 1.4, Deﬁnition 4 of the PIL document, the number of columns can (and usually will) differ from the number of partition sets. We believe this might be the result of a mixup of the partition sets and the vectors that will be used to encode the partition permutation. The number of vectors encoding the partition permutation is the same as the number of columns. • Concern Addressed: The Polygon team has addressed this concern with version eSTARK v1.2. In Sec- Unconstrained selectors in selection variants of lookup and multiset equality arguments (Minor) tion 2.4 of the eSTARK document v1.0, step 1 states that the prover sends over the selector polynomials. There are two potential issues here: 1. If the veriﬁer does not take in the selector polynomials as constant (preprocessed) polynomials, then the relation is trivially satisﬁable. The prover can simply set the selectors to be identically 0. Thus, the Selected Vector Argument is meaningless. 2. Further, beyond the trivial satisfying selection described above, if the prover is meant to send their own selectors, there is no veriﬁcation check to conﬁrm the image of the selector polynomials over G is {0,1}. 4 • Suggestion: A self-contained description of the Selected Vector Argument should include a veriﬁcation check that the selector polynomials lie in {0,1} over G. • Concern Addressed: The Polygon team informed us that in the zkEVM context, additional constraints exist to ensure the selector polynomials are in {0,1} when they are prover provided, i.e., they are the result of a lookup from a preprocessed table that only contains {0,1}. Misuse of Poseidon hashing for veriﬁer challenges resulting in unexploitable length-extension weakness In Section 2.2 of the eSTARK documentation v1.0, the strategy to produce a third veriﬁer challenge from (Minor) the 7th, 8th, and 9th ﬁeld elements requires producing a new set of 8 ﬁeld elements (the 9th ﬁeld element is not contained in the previous set). To do this, 8 zeroes are hashed with the previous capacity. This approach produces the same outputs as if hashing the message appended with 8 zeroes: M||00000000. • Suggestion: While this particular instance of misuse as used in the STARK prover may not cause issues as the inputs to the transcript may not be length-extended, we recommend that additional veriﬁer challenges are produced by treating the Poseidon hash function as an XOF for continuous variable-length output. Feed the full 12 elements (capacity + output) into another round of Poseidon permutation. Then use the top 8 (without the capacity) as partial output, repeating as needed. This mimics the squeeze operation of a sponge hash function. Using Poseidon with XOF mode allows for producing as many veriﬁer challenges as needed (Optimization) A number of design decisions are made in eSTARK v1.0 to bound the number of veriﬁer challenges needed. We do not believe there any concerns with the soundness of the proposed design decisions, however if these design decisions were made due to the concern around the feasibilty of generating additional veriﬁer challenges, then this can be avoided. Instead if reducing the number of veriﬁer challenges is already an optimization to reduce the size of the STARK veriﬁer in the recursion, then the following can be ignored. 1. Section 2.2 of the eSTARK documentation v1.0 claims that there is a bound on the number of veriﬁer chal- lenges that can be produced. 2. Section 2.5 of the eSTARK documentation v1.0 claims that the large number of veriﬁer challenges needed to produce the quotient polynomial are hard to produce. 3. Section 2.7 of the eSTARK documentation v1.0 claims that the large number of veriﬁer challenges needed to produce the FRI polynomial is an issue. • Suggestion: All of the above is not an issue using the XOF mode with Poseidon as described above. • Concern Addressed: The Polygon team conﬁrmed that the proposed designs to reduce the number of veriﬁer challenges was not because of perceived infeasibility of producing more veriﬁer challenges, rather it is an optimization to minimize the recursive circuit avoiding additional encodings of Poseidon rounds. In the description of the full Preprocessed polynomials not included in ﬁrst prover message (Informational) protocol in Section 4.5 Round 1 of the eSTARK paper v1.2, the preprocessed polynomials are not included in the Merkle tree commitment. • Suggestion: Include the preprocessed polynomials in the ﬁrst prover message as described in earlier sec- tions. 5 
4.1.3 Recursion In Section 4.2.6 of the recursion Description of rootC used and depicted inconsistently (Inconsistency) document, in Figure 17, the public input rootC is supposed to be multiplexed with a hard-coded rec1 rootC. The paragraph before has some description mistakes. • Suggestion: Follow the diagram from Jordi’s slides that includes the hard-coded rootC and input rootC as argument to the multiplexor fed to both veriﬁers. 
4.1.4 fﬂonk Minor soundness bound error (Informational) There is an off-by-one error int he soundness bound for the proof of Lemma 6.4. Note that A | (p − 1) where p is the size of F . The set S of A-th powers of F includes 0. Thus, |S| = p−1 A + 1. Let Fi be a non-zero polynomial. For a uniformly chosen element of s in S, the probability fi (s) = 0 ≤ def Fi p−1 A + 1 < def(Fi ) · A p − 1 4.2 Code Review 
4.2.1 Scope of Code Review Code Reviewed 1. Recursion pipeline • Repository: zkevm-proverjs at branch v0.8.0.0-rc.2-forkid.2 • Build documentation • The generated STARK veriﬁers in the recursion pipeline for c12a, rec1, rec2, recf, and fﬂonk. 2. STARK prover and veriﬁer for PIL • Repository: pil-stark • Files: stark_gen, stark_setup, stark_verify, starkinfo, starkinfo_cp_prover, starkinfo_cp_veriﬁer, stark- info_fri_prover, starkinfo_fri_veriﬁer, starkinfo_step1, starkinfo_step2, transcript • The STARK proof generation and veriﬁcation code for a given PIL description including encoding of lookup, multiset equality, and connection arguments. Future Code Reviews While the scope of the broader zkEVM security review included a complete code review of all cryptography related parts of the zkEVM, the code review of the following parts have not been done yet (at the time this report was written) but will be completed in the near future. 1. Compilation of PIL ﬁle to data structure input to STARK prover • Repository: pilcom 2. Encoding of PIL-derived STARK veriﬁer to circom 3. Encoding of circom-produced R1CS to PlonK-like PIL 4. FRI (batched) polynomial commitment and opening 6 
4.2.2 Recursion Pipeline Following the latest build documentation provided, we built zkevm-proverjs on branch v0.8.0.0-rc.2-forkid.2. We checked that all the circom ﬁles aligned with out analysis of the recursion pipeline as described in the recursion documentation. Additionally, we reviewed the ﬁnal fﬂonk veriﬁer in Solidity. Build and documentation mismatch (Minor) The final.fflonk.verifier.sol produced by zkevm-proverjs on branch v0.8.0.0-rc.2-forkid.2 uses an outdated template from snarkjs before this commit. This outdated template does not appropriately calculate veriﬁer challenges (does not include preprocessed polynomials and does not keep a continuous transcript state). Further the documentation provided in the README is outdated. • Suggestion: The Polygon team should double check the release version of zevm-proverjs uses the updated template otherwise the produce fﬂonk veriﬁer may have Fiat-Shamir vulnerabilities. • Suggestion: Use the updated documentation provided by Felicia. • Concern Addressed: The Polygon team conﬁrmed that they are using the correct version in their release build pipeline. In the recursive2 circuit, a mux is used to select whether a Batch number comparison logic overﬂow (Minor) hardcoded root or public input root is passed into the subveriﬁer circuits. In the recursivef circuit, a mux is used to select which of two hardcoded roots is passed to the subveriﬁer. Both muxes take in as input a comparison of the form: component test = IsZero(); test.in <== oldBatchNum - newBatchNum -1; .... mux.s <== test.out; Since the bn128 scalar ﬁeld is larger than the goldilocks ﬁeld, there is a potential that overﬂows occur in the ﬁeld arithmetic above. This would affect the comparison logic above done over the goldilocks ﬁeld. • Example: Let p be the order of the larger bn128 scalar ﬁeld, and let q be the order of the goldilocks ﬁeld. Note p > q as the bn128 ﬁeld is much larger than the goldilocks ﬁeld. Deﬁne integers a and b and consider expressions a · q + b and b. Then, aq + b ≡ b (mod q) yet a · q + b 6= b as integers. If oldBatchNum is b − 1 and newBatchNum is a · q + b, then the comparison above would return true and despite the batch numbers not being adjacent. The prover could convince a veriﬁer that they have done a · q + 1 iterations of work by using a valid ﬁnal proof of an execution from b − 1 to b. • Concern Addressed: The Polygon team stated that in final.verifier.circom they do a bit composition of oldBatchNum and newBatchNum into 63 bits. Since 263 < q (the order of the goldilocks ﬁeld), and overﬂow in the comparison logic cannot occur. Minor completeness issue by rejecting the point-at-inﬁnity during on-curve checks (Informational) Valid points on the curve bn128 either satisfy the curve equation or are the point at inﬁnity. In the precompiled contracts (EIP196), (0,0) is the encoding of the point-at-inﬁnity. The check checkPointBelongsToBN128Curve function re- turns true only if the point satisﬁes the curve equation; it rejects the point-at-inﬁnity. There exists valid scenarios where a prover message is identical to the point-at-inﬁnity. • Suggestion: Add the point-at-inﬁnity check to the on-curve check. • Concern Addressed: The Polygon team would like to avoid adding the on-curve check for the point-at-inﬁnity. We have conﬁrmed that due to the random blinding factors and random veriﬁer challenges in the protocol, completeness would only be an issue with negligible probability for an honest prover. 7 
4.2.3 STARK Prover and Veriﬁer We checked the implementation of the STARK prover and veriﬁer and generation of the starkinfo object from the parsed PIL object. We verify that the STARK prover follows the design of the reviewed eSTARK protocol, in particular, the implementation of the newly added lookup, multiset equality, and connection arguments. Misuse of Poseidon hashing for veriﬁer challenges (Minor) We repeat the issue raised during the cryptog- raphy review above. It is represented in transcript (lines 16-20). The suggestion and addressed concern are the same. Unnecessary inclusion of all committed polynomials in FRI polynomial (Optimization) When the prover computes the FRI polynomial in starkinfo_fri_prover (lines 12-19), all committed polynomials are included in the linear combination. All committed polynomials that are involved in constraints will already be included in the linear combination as part of the proof for their correct evaluation, which will attest to the degree bound for the committed polynomial. Thus, the only beneﬁt of adding all committed polynomials to the linear combination is to include a degree bound check for polynomials that are not part of any constraints. • Suggestion: Committed polynomials can be removed from the linear combination computing the FRI polyno- mial. If for some reason it is important to check the degree bound of some committed polynomial that is not included in any constraints, then at the very least, all committed polynomials that are a part of constraints do not need to be included a second time. Unnecessary evaluation of vanishing polynomial in veriﬁer (Optimization) The veriﬁer evaluates the van- ishing polynomial of G on g · z where g is the generator of G and z is the veriﬁer evaluation challenge. However, this evaluation is not needed for veriﬁcation. The evaluation is in stark_verify (line 70). • Suggestion: Remove this evaluation. 8 
