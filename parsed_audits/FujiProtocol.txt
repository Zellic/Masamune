1. Anyone can destroy the FujiVault logic contract if its initialize function was not called during deployment Severity: High DiÔ¨Éculty: Medium Type: Denial of Service Finding ID: TOB-FUJI-001 Target: FujiVault.sol Description Anyone can destroy the FujiVault logic contract if its initialize function has not already been called. Calling initialize on a logic contract is uncommon, as usually nothing is gained by doing so. The deployment script does not call initialize on any logic contract. As a result, the exploit scenario detailed below is possible after deployment. This issue is similar to a bug in AAVE that found in 2020. OpenZeppelin‚Äôs hardhat-upgrades plug-in protects against this issue by disallowing the use of selfdestruct or delegatecall on logic contracts. However, the Fuji Protocol team has explicitly worked around these protections by calling delegatecall in assembly, which the plug-in does not detect. Exploit Scenario The Fuji contracts are deployed, but the initialize functions of the logic contracts are not called. Bob, an attacker, deploys a contract to the address alwaysSelfdestructs, which simply always executes the selfdestruct opcode. Additionally, Bob deploys a contract to the address alwaysSucceeds, which simply never reverts. Bob calls initialize on the FujiVault logic contract, thereby becoming its owner. To make the call succeed, Bob passes 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE as the value for the _collateralAsset and _borrowAsset parameters. He then calls FujiVaultLogic.setActiveProvider(alwaysSelfdestructs), followed by FujiVault.setFujiERC1155(alwaysSucceeds) to prevent an additional revert in the next and Ô¨Ånal call. Finally, Bob calls FujiVault.deposit(1), sending 1 wei. This triggers a delegatecall to alwaysSelfdestructs, thereby destroying the FujiVault logic contract and making the protocol unusable until its proxy contract is upgraded. 14 Fuji Protocol Because OpenZeppelin‚Äôs upgradeable contracts do not check for a contract‚Äôs existence before a delegatecall (TOB-FUJI-003), all calls to the FujiVault proxy contract now succeed. This leads to exploits in any protocol integrating the Fuji Protocol. For example, a call that should repay all debt will now succeed even if no debt is repaid. Recommendations Short term, do not use delegatecall to implement providers. See TOB-FUJI-002 for more information. Long term, avoid the use of delegatecall, as it is diÔ¨Écult to use correctly and can introduce vulnerabilities that are hard to detect. 15 Fuji Protocol 
2. Providers are implemented with delegatecall Severity: Informational DiÔ¨Éculty: Undetermined Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-002 Target: FujiVault.sol, providers Description The system uses delegatecall to execute an active provider's code on a FujiVault, making the FujiVault the holder of the positions in the borrowing protocol. However, delegatecall is generally error-prone, and the use of it introduced the high-severity Ô¨Ånding TOB-FUJI-001. It is possible to make a FujiVault the holder of the positions in a borrowing protocol without using delegatecall. Most borrowing protocols include a parameter that speciÔ¨Åes the receiver of tokens that represent a position. For borrowing protocols that do not include this type of parameter, tokens can be transferred to the FujiVault explicitly after they are received from the borrowing protocol; additionally, the tokens can be transferred from the FujiVault to the provider before they are sent to the borrowing protocol. These solutions are conceptually simpler than and preferred to the current solution. Recommendations Short term, implement providers without the use of delegatecall. Set the receiver parameters to the FujiVault, or transfer the tokens corresponding to the position to the FujiVault. Long term, avoid the use of delegatecall, as it is diÔ¨Écult to use correctly and can introduce vulnerabilities that are hard to detect. 16 Fuji Protocol 
3. Lack of contract existence check on delegatecall will result in unexpected behavior Severity: High DiÔ¨Éculty: High Type: Data Validation Finding ID: TOB-FUJI-003 Target: VaultControlUpgradeable.sol, Proxy.sol Description The VaultControlUpgradeable and Proxy contracts use the delegatecall proxy pattern. If the implementation contract is incorrectly set or self-destructed, the contract may not be able to detect failed executions. The VaultControlUpgradeable contract includes the _execute function, which users can invoke indirectly to execute a transaction to a _target address. This function does not check for contract existence before executing the delegatecall (Ô¨Ågure 3.1). /** * @dev Returns byte response of delegatcalls */ function _execute(address _target, bytes memory _data) internal whenNotPaused returns (bytes memory response) { /* solhint-disable */ assembly { let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 0) let size := returndatasize() response := mload(0x40) mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(response, size) returndatacopy(add(response, 0x20), 0, size) switch iszero(succeeded) case 1 { // throw if delegatecall failed revert(add(response, 0x20), size) } } /* solhint-disable */ } 17 Fuji Protocol Figure 3.1: fuji-protocol/contracts/abstracts/vault/VaultBaseUpgradeable.sol#L93-L11 5 The Proxy contract, deployed by the @openzeppelin/hardhat-upgrades library, includes a payable fallback function that invokes the _delegate function when proxy calls are executed. This function is also missing a contract existence check (Ô¨Ågure 3.2). /** * @dev Delegates the current call to `implementation`. * * This function does not return to its internall call site, it will return directly to the external caller. */ function _delegate(address implementation) internal virtual { // solhint-disable-next-line no-inline-assembly assembly { // Copy msg.data. We take full control of memory in this inline assembly // block because it will not return to Solidity code. We overwrite the // Solidity scratch pad at memory position 0. calldatacopy(0, 0, calldatasize()) // Call the implementation. // out and outsize are 0 because we don't know the size yet. let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) // Copy the returned data. returndatacopy(0, 0, returndatasize()) switch result // delegatecall returns 0 on error. case 0 { revert(0, returndatasize()) } default { return(0, returndatasize()) } } } Figure 3.2: Proxy.sol#L16-L41 A delegatecall to a destructed contract will return success (Ô¨Ågure 3.3). Due to the lack of contract existence checks, a series of batched transactions may appear to be successful even if one of the transactions fails. The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed. Figure 3.3: A snippet of the Solidity documentation detailing unexpected behavior related to delegatecall Exploit Scenario Eve upgrades the proxy to point to an incorrect new implementation. As a result, each 18 Fuji Protocol delegatecall returns success without changing the state or executing code. Eve uses this to scam users. Recommendations Short term, implement a contract existence check before any delegatecall. Document the fact that suicide and selfdestruct can lead to unexpected behavior, and prevent future upgrades from using these functions. Long term, carefully review the Solidity documentation, especially the ‚ÄúWarnings‚Äù section, and the pitfalls of using the delegatecall proxy pattern. References ‚óè Contract Upgrade Anti-Patterns ‚óè Breaking Aave Upgradeability 19 Fuji Protocol 
4. FujiVault.setFactor is unnecessarily complex and does not properly handle invalid input Severity: Informational DiÔ¨Éculty: Undetermined Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-004 Target: FujiVault.sol Description The FujiVault contract‚Äôs setFactor function sets one of four state variables to a given value. Which state variable is set depends on the value of a string parameter. If an invalid value is passed, setFactor succeeds but does not set any of the state variables. This creates edge cases, makes writing correct code more diÔ¨Écult, and increases the likelihood of bugs. function setFactor( uint64 _newFactorA, uint64 _newFactorB, string calldata _type ) external isAuthorized { bytes32 typeHash = keccak256(abi.encode(_type)); if (typeHash == keccak256(abi.encode("collatF"))) { collatF.a = _newFactorA; collatF.b = _newFactorB; } else if (typeHash == keccak256(abi.encode("safetyF"))) { safetyF.a = _newFactorA; safetyF.b = _newFactorB; } else if (typeHash == keccak256(abi.encode("bonusLiqF"))) { bonusLiqF.a = _newFactorA; bonusLiqF.b = _newFactorB; } else if (typeHash == keccak256(abi.encode("protocolFee"))) { protocolFee.a = _newFactorA; protocolFee.b = _newFactorB; } } Figure 4.1: FujiVault.sol#L475-494 Exploit Scenario A developer on the Fuji Protocol team calls setFactor from another contract. He passes a type that is not handled by setFactor. As a result, code that is expected to set a state variable does nothing, resulting in a more severe vulnerability. 20 Fuji Protocol Recommendations Short term, replace setFactor with four separate functions, each of which sets one of the four state variables. Long term, avoid string constants that simulate enumerations, as they cannot be checked by the typechecker. Instead, use enums and ensure that any code that depends on enum values handles all possible values. 21 Fuji Protocol 
5. Preconditions speciÔ¨Åed in docstrings are not checked by functions Severity: Informational DiÔ¨Éculty: Undetermined Type: Data Validation Finding ID: TOB-FUJI-005 Target: FujiVault.sol, Controller.sol Description The docstrings of several functions specify preconditions that the functions do not automatically check for. For example, the docstring of the FujiVault contract‚Äôs setFactor function contains the preconditions shown in Ô¨Ågure 5.1, but the function‚Äôs body does not contain the corresponding checks shown in Ô¨Ågure 5.2. * For safetyF; Sets Safety Factor of Vault, should be > 1, a/b * For collatF; Sets Collateral Factor of Vault, should be > 1, a/b Figure 5.1: FujiVault.sol#L469-470 require(safetyF.a > safetyF.b); ... require(collatF.a > collatF.b); Figure 5.2: The checks that are missing from FujiVault.setFactor Additionally, the docstring of the Controller contract‚Äôs doRefinancing function contains the preconditions shown in Ô¨Ågure 5.3, but the function‚Äôs body does not contain the corresponding checks shown in Ô¨Ågure 5.4. * @param _ratioB: _ratioA/_ratioB <= 1, and > 0 Figure 5.3: Controller.sol#L41 require(ratioA > 0 && ratioB > 0); require(ratioA <= ratioB); Figure 5.4: The checks that are missing from Controller.doRefinancing Exploit Scenario The setFactor function is called with values that violate its documented preconditions. Because the function does not check for these preconditions, unexpected behavior occurs. 22 Fuji Protocol Recommendations Short term, add checks for preconditions to all functions with preconditions speciÔ¨Åed in their docstrings. Long term, ensure that all documentation and code are in sync. 23 Fuji Protocol 
6. The FujiERC1155.burnBatch function implementation is incorrect Severity: High DiÔ¨Éculty: Low Type: Data Validation Finding ID: TOB-FUJI-006 Target: FujiERC1155.sol Description The FujiERC1155 contract‚Äôs burnBatch function deducts the unscaled amount from the user's balance and from the total supply of an asset. If the liquidity index of an asset (index[assetId]) is diÔ¨Äerent from its initialized value, the execution of burnBatch could result in unintended arithmetic calculations. Instead of deducting the amount value, the function should deduct the amountScaled value. function burnBatch( address _account, uint256[] memory _ids, uint256[] memory _amounts ) external onlyPermit { require(_account != address(0), Errors.VL_ZERO_ADDR_1155); require(_ids.length == _amounts.length, Errors.VL_INPUT_ERROR); address operator = _msgSender(); uint256 accountBalance; uint256 assetTotalBalance; uint256 amountScaled; for (uint256 i = 0; i < _ids.length; i++) { uint256 amount = _amounts[i]; accountBalance = _balances[_ids[i]][_account]; assetTotalBalance = _totalSupply[_ids[i]]; amountScaled = _amounts[i].rayDiv(indexes[_ids[i]]); require(amountScaled != 0 && accountBalance >= amountScaled, Errors.VL_INVALID_BURN_AMOUNT); _balances[_ids[i]][_account] = accountBalance - amount; _totalSupply[_ids[i]] = assetTotalBalance - amount; } emit TransferBatch(operator, _account, address(0), _ids, _amounts); } Figure 6.1: FujiERC1155.sol#L218-247 24 Fuji Protocol Exploit Scenario The burnBatch function is called with an asset for which the liquidity index is diÔ¨Äerent from its initialized value. Because amount was used instead of amountScaled, unexpected behavior occurs. Recommendations Short term, revise the burnBatch function so that it uses amountScaled instead of amount when updating a user‚Äôs balance and the total supply of an asset. Long term, use the burn function in the burnBatch function to keep functionality consistent. 25 Fuji Protocol 
7. Error in the white paper‚Äôs equation for the cost of reÔ¨Ånancing Severity: Informational DiÔ¨Éculty: Undetermined Type: Arithmetic Finding ID: TOB-FUJI-007 Target: White paper Description The white paper uses the following equation (equation 4) to describe how the cost of reÔ¨Ånancing is calculated: ùëÖ ùëáùë• ùëêùëúùë†ùë° = ùëîùëéùë† + ùê∫ ùëùùëüùëñùëêùëí + ùê∏ùëáùêª ùëùùëüùëñùëêùëí + ùêµ ùëëùëíùëèùë° + ùêπùêø ùëìùëíùëí ùêµ ùëëùëíùëèùë° is the amount of debt to be reÔ¨Ånanced and is a summand of the equation. This is incorrect, as it implies that the reÔ¨Ånancing cost is always greater than the amount of debt to be reÔ¨Ånanced. A correct version of the equation could be ùëÖ ùêπùêø is an amount, or ùëÖ ùëìùëíùëí ùëáùë• ùëêùëúùë†ùë° = ùëîùëéùë† + ùê∫ ùëùùëüùëñùëêùëí ùëáùë• + ùê∫ + ùê∏ùëáùêª + ùêπùêø ùëêùëúùë†ùë° = + ùê∏ùëáùêª ùëîùëéùë† + ùêµ ùëùùëüùëñùëêùëí * ùêπùêø ùëùùëüùëñùëêùëí ùëëùëíùëèùë° ùëìùëíùëí ùëùùëüùëñùëêùëí , in which ùêπùêø is a ùëìùëíùëí , in which ùëìùëíùëí percentage. Recommendations Short term, Ô¨Åx equation 4 in the white paper. Long term, ensure that the equations in the white paper are correct and in sync with the implementation. 26 Fuji Protocol 
8. Errors in the white paper‚Äôs equation for index calculation Severity: Medium DiÔ¨Éculty: Undetermined Type: Arithmetic Finding ID: TOB-FUJI-008 Target: White paper Description The white paper uses the following equation (equation 1) to describe how the index for a given token at timestamp is calculated: ùë° ùêº ùë° = ùêº ùë°‚àí1 + (ùêµ ùë°‚àí1 )/ùêµ ‚àí ùêµ ùë° ùë°‚àí1 ùêµ is the amount of the given token that the Fuji Protocol owes the provider (the borrowing ùë° protocol) at timestamp .ùë° The index is updated only when the balance changes through the accrual of interest, not when the balance changes through borrowing or repayment operations. This means that ùêµ ‚àí ùêµ is always negative, which is incorrect, as ùë° should calculate the )/ùêµ ‚àí ùêµ ùë° (ùêµ ùë°‚àí1 ùë°‚àí1 ùë°‚àí1 interest rate since the last index update. * ùëü 3 * ùëü 2 * ... * ùëü . A user's current balance is computed by taking the user‚Äôs initial stored ùëõ The index represents the total interest rate since the deployment of the protocol. It is the product of the various interest rates accrued on the active providers during the lifetime of the protocol (measured only during state-changing interactions with the provider): ùëü 1 balance, multiplying it by the current index, and dividing it by the index at the time of the creation of that user's position. The division operation ensures that the user will not owe interest that accrued before the creation of the user‚Äôs position. The index provides an eÔ¨Écient way to keep track of interest rates without having to update each user's balance separately, which would be prohibitively expensive on Ethereum. However, interest is compounded through multiplication, not addition. The formula should use the product sign instead of the plus sign. 27 Fuji Protocol Exploit Scenario Alice decides to use the Fuji Protocol after reading the white paper. She later learns that calculations in the white paper do not match the implementations in the protocol. Because Alice allocated her funds based on her understanding of the speciÔ¨Åcation, she loses funds. Recommendations Short term, replace equation 1 in the white paper with a correct and simpliÔ¨Åed version. For more information on the simpliÔ¨Åed version, see Ô¨Ånding TOB-FUJI-015. ùêº ùë° = ùêº ùë°‚àí1 /ùêµ * ùêµ ùë° ùë°‚àí1 Long term, ensure that the equations in the white paper are correct and in sync with the implementation. 28 Fuji Protocol 
9. FujiERC1155.setURI does not adhere to the EIP-1155 speciÔ¨Åcation Severity: Informational DiÔ¨Éculty: Undetermined Type: Auditing and Logging Finding ID: TOB-FUJI-009 Target: FujiERC1155.sol Description The FujiERC1155 contract‚Äôs setURI function does not emit the URI event. /** * @dev Sets a new URI for all token types, by relying on the token type ID */ function setURI(string memory _newUri) public onlyOwner { _uri = _newUri; } Figure 9.1: FujiERC1155.sol#L266-268 This behavior does not adhere to the EIP-1155 speciÔ¨Åcation, which states the following: Changes to the URI MUST emit the URI event if the change can be expressed with an event (i.e. it isn‚Äôt dynamic/programmatic). Figure 9.2: A snippet of the EIP-1155 speciÔ¨Åcation Recommendations Short term, revise the setURI function so that it emits the URI event. Long term, review the EIP-1155 speciÔ¨Åcation to verify that the contracts adhere to the standard. References ‚óè EIP-1155 29 Fuji Protocol 
10. Partial reÔ¨Ånancing operations can break the protocol Severity: Medium DiÔ¨Éculty: Medium Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-010 Target: FujiVault.sol, Controller.sol, white paper Description The white paper documents the Controller contract‚Äôs ability to perform partial reÔ¨Ånancing operations. These operations move only a fraction of debt and collateral from one provider to another to prevent unproÔ¨Åtable interest rate slippage. However, the protocol does not correctly support partial reÔ¨Ånancing situations in which debt and collateral are spread across multiple providers. For example, payback and withdrawal operations always interact with the current provider, which might not contain enough funds to execute these operations. Additionally, the interest rate indexes are computed only from the debt owed to the current provider, which might not accurately reÔ¨Çect the interest rate across all providers. Exploit Scenario An executor performs a partial reÔ¨Ånancing operation. Interest rates are computed incorrectly, resulting in a loss of funds for either the users or the protocol. Recommendations Short term, disable partial reÔ¨Ånancing until the protocol supports it in all situations. Long term, ensure that functionality that is not fully supported by the protocol cannot be used by accident. 30 Fuji Protocol 
11. Native support for ether increases the codebase‚Äôs complexity Severity: Informational DiÔ¨Éculty: Undetermined Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-011 Target: Throughout Description The protocol supports ERC20 tokens and Ethereum‚Äôs native currency, ether. Ether transfers follow diÔ¨Äerent semantics than token transfers. As a result, many functions contain extra code, like the code shown in Ô¨Ågure 11.1, to handle ether transfers. if (vAssets.borrowAsset == ETH) { require(msg.value >= amountToPayback, Errors.VL_AMOUNT_ERROR); if (msg.value > amountToPayback) { IERC20Upgradeable(vAssets.borrowAsset).univTransfer( payable(msg.sender), msg.value - amountToPayback ); } } else { // Check User Allowance require( IERC20Upgradeable(vAssets.borrowAsset).allowance(msg.sender, address(this)) >= amountToPayback, Errors.VL_MISSING_ERC20_ALLOWANCE ); Figure 11.1: FujiVault.sol#L319-333 This extra code increases the codebase‚Äôs complexity. Furthermore, functions will behave diÔ¨Äerently depending on their arguments. Recommendations Short term, replace native support for ether with support for ERC20 WETH. This will decrease the complexity of the protocol and the likelihood of bugs. 31 Fuji Protocol 
12. Missing events for critical operations Severity: Low DiÔ¨Éculty: Low Type: Auditing and Logging Finding ID: TOB-FUJI-012 Target: Throughout Description Many functions that make important state changes do not emit events. These functions include, but are not limited to, the following: ‚óè All setters in the FujiAdmin contract ‚óè The setFujiAdmin, setFujiERC1155, setFactor, setOracle, and setProviders functions in the FujiVault contract ‚óè The setMapping and setURI functions in the FujiMapping contract ‚óè The setFujiAdmin and setExecutors functions in the Controller contract ‚óè The setURI and setPermit functions in the FujiERC1155 contract ‚óè The setPriceFeed function in the FujiOracle contract Exploit scenario An attacker gains permission to execute an operation that changes critical protocol parameters. She executes the operation, which does not emit an event. Neither the Fuji Protocol team nor the users are notiÔ¨Åed about the parameter change. The attacker uses the changed parameter to steal funds. Later, the attack is detected due to the missing funds, but it is too late to react and mitigate the attack. Recommendations Short term, ensure that all state-changing operations emit events. Long term, use an event monitoring system like Tenderly or Defender, use Defender‚Äôs automated incident response feature, and develop an incident response plan to follow in case of an emergency. 32 Fuji Protocol 13. Indexes are not updated before all operations that require up-to-date indexes Severity: High DiÔ¨Éculty: Low Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-013 Target: FujiVault.sol, FujiERC1155.sol, FLiquidator.sol Description The FujiERC1155 contract uses indexes to keep track of interest rates. Refer to Appendix F for more detail on the index calculation. The FujiVault contract‚Äôs updateF1155Balances function is responsible for updating indexes. However, this function is not called before all operations that read indexes. As a result, these operations use outdated indexes, which results in incorrect accounting and could make the protocol vulnerable to exploits. FujiVault.deposit calls FujiERC1155._mint, which reads indexes but does not call updateF1155Balances. FujiVault.paybackLiq calls FujiERC1155.balanceOf, which reads indexes but does not call updateF1155Balances. Exploit Scenario The indexes have not been updated in one day. User Bob deposits collateral into the FujiVault. Day-old indexes are used to compute Bob‚Äôs scaled amount, causing Bob to gain interest for an additional day for free. Recommendations Short term, ensure that all operations that require up-to-date indexes Ô¨Årst call updateF1155Balances. Write tests for each function that depends on up-to-date indexes with assertions that fail if indexes are outdated. Long term, redesign the way indexes are accessed and updated such that a developer cannot simply forget to call updateF1155Balances. 33 Fuji Protocol 14. No protection against missing index updates before operations that depend on up-to-date indexes Severity: Informational DiÔ¨Éculty: Low Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-014 Target: FujiVault.sol, FujiERC1155.sol, FLiquidator.sol Description The FujiERC1155 contract uses indexes to keep track of interest rates. Refer to Appendix F for more detail on the index calculation. The FujiVault contract‚Äôs updateF1155Balances function is responsible for updating indexes. This function must be called before all operations that read indexes (TOB-FUJI-013). However, the protocol does not protect against situations in which indexes are not updated before they are read; these situations could result in incorrect accounting. Exploit Scenario Developer Bob adds a new operation that reads indexes, but he forgets to add a call to updateF1155Balances. As a result, the new operation uses outdated index values, which causes incorrect accounting. Recommendations Short term, redesign the index calculations so that they provide protection against the reading of outdated indexes. For example, the index calculation process could keep track of the last index update‚Äôs block number and access indexes exclusively through a getter, which updates the index automatically, if it has not already been updated for the current block. Since ERC-1155‚Äôs balanceOf and totalSupply functions do not allow side eÔ¨Äects, this solution would require the use of diÔ¨Äerent functions internally. Long term, use defensive coding practices to ensure that critical operations are always executed when required. 34 Fuji Protocol 15. Formula for index calculation is unnecessarily complex Severity: Informational DiÔ¨Éculty: Undetermined Type: Arithmetic Finding ID: TOB-FUJI-015 Target: FujiERC1155.sol Description Indexes are updated within the FujiERC1155 contract‚Äôs updateState function, shown in Ô¨Ågure 15.1. Refer to Appendix F for more detail on the index calculation. function updateState(uint256 _assetID, uint256 newBalance) external override onlyPermit { uint256 total = totalSupply(_assetID); if (newBalance > 0 && total > 0 && newBalance > total) { uint256 diff = newBalance - total; uint256 amountToIndexRatio = (diff.wadToRay()).rayDiv(total.wadToRay()); uint256 result = amountToIndexRatio + WadRayMath.ray(); result = result.rayMul(indexes[_assetID]); require(result <= type(uint128).max, Errors.VL_INDEX_OVERFLOW); indexes[_assetID] = uint128(result); // TODO: calculate interest rate for a fujiOptimizer Fee. } } Figure 15.1: FujiERC1155.sol#L40-57 The code in Ô¨Ågure 14.1 translates to the following equation: = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 * (1 + (ùëèùëéùëôùëéùëõùëêùëí ùë° ‚àí ùëèùëéùëôùëéùëõùëêùëí )/ùëèùëéùëôùëéùëõùëêùëí ùë°‚àí1 ) ùë°‚àí1 Using the distributive property, we can transform this equation into the following: = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 /ùëèùëéùëôùëéùëõùëêùëí * (1 + ùëèùëéùëôùëéùëõùëêùëí ùë° ùë°‚àí1 This version can then be simpliÔ¨Åed: ‚àí ùëèùëéùëôùëéùëõùëêùëí /ùëèùëéùëôùëéùëõùëêùëí ùë°‚àí1 ) ùë°‚àí1 = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 /ùëèùëéùëôùëéùëõùëêùëí * (1 + ùëèùëéùëôùëéùëõùëêùëí ùë° ùë°‚àí1 ‚àí 1) 35 Fuji Protocol Finally, we can simplify the equation even further: = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 /ùëèùëéùëôùëéùëõùëêùëí * ùëèùëéùëôùëéùëõùëêùëí ùë° ùë°‚àí1 The resulting equation is simpler and more intuitively conveys the underlying idea‚Äîthat the index grows by the same ratio as the balance grew since the last index update. Recommendations Short term, use the simpler index calculation formula in the updateState function of the Fuji1155Contract. This will result in code that is more intuitive and that executes using slightly less gas. Long term, use simpler versions of the equations used by the protocol to make the arithmetic easier to understand and implement correctly. 36 Fuji Protocol 16. Flasher‚Äôs initiateFlashloan function does not revert on invalid Ô¨Çashnum values Severity: Low DiÔ¨Éculty: High Type: Data Validation Finding ID: TOB-FUJI-016 Target: Flasher.sol Description The Flasher contract‚Äôs initiateFlashloan function does not initiate a Ô¨Çash loan or perform a reÔ¨Ånancing operation if the flashnum parameter is set to a value greater than 2. However, the function does not revert on invalid flashnum values. function initiateFlashloan(FlashLoan.Info calldata info, uint8 _flashnum) external isAuthorized { if (_flashnum == 0) { _initiateAaveFlashLoan(info); } else if (_flashnum == 1) { _initiateDyDxFlashLoan(info); } else if (_flashnum == 2) { _initiateCreamFlashLoan(info); } } Figure 16.1: Flasher.sol#L61-69 Exploit Scenario Alice, an executor of the Fuji Protocol, calls Controller. doRefinancing with the flashnum parameter set to 3. As a result, no Ô¨Çash loan is initialized, and no reÔ¨Ånancing happens; only the active provider is changed. This results in unexpected behavior. For example, if a user wants to repay his debt after reÔ¨Ånancing, the operation will fail, as no debt is owed to the active provider. Recommendations Short term, revise initiateFlashloan so that it reverts when it is called with an invalid flashnum value. Long term, ensure that all functions revert if they are called with invalid values. 37 Fuji Protocol 17. Docstrings do not reÔ¨Çect functions‚Äô implementations Severity: Low DiÔ¨Éculty: Undetermined Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-017 Target: FujiVault.sol Description The docstring of the FujiVault contract‚Äôs withdraw function states the following: * @param _withdrawAmount: amount of collateral to withdraw * otherwise pass -1 to withdraw maximum amount possible of collateral (including safety factors) Figure 17.1: FujiVault.sol#L188-189 However, the maximum amount is withdrawn on any negative value, not only on a value of -1. A similar inconsistency between the docstring and the implementation exists in the FujiVault contract‚Äôs payback function. Recommendations Short term, adjust the withdraw and payback functions‚Äô docstrings or their implementations to make them match. Long term, ensure that docstrings always match the corresponding function‚Äôs implementation. 38 Fuji Protocol 18. Harvester‚Äôs getHarvestTransaction function does not revert on invalid _farmProtocolNum and harvestType values Severity: Low DiÔ¨Éculty: Medium Type: Data Validation Finding ID: TOB-FUJI-018 Target: Harvester.sol Description The Harvester contract‚Äôs getHarvestTransaction function incorrectly returns claimedToken and transaction values of 0 if the _farmProtocolNum parameter is set to a value greater than 1 or if the harvestType value is set to value greater than 2. However, the function does not revert on invalid _farmProtocolNum and harvestType values. function getHarvestTransaction(uint256 _farmProtocolNum, bytes memory _data) external view override returns (address claimedToken, Transaction memory transaction) { if (_farmProtocolNum == 0) { transaction.to = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B; transaction.data = abi.encodeWithSelector( bytes4(keccak256("claimComp(address)")), msg.sender ); claimedToken = 0xc00e94Cb662C3520282E6f5717214004A7f26888; } else if (_farmProtocolNum == 1) { uint256 harvestType = abi.decode(_data, (uint256)); if (harvestType == 0) { // claim (, address[] memory assets) = abi.decode(_data, (uint256, address[])); transaction.to = 0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5; transaction.data = abi.encodeWithSelector( bytes4(keccak256("claimRewards(address[],uint256,address)")), assets, type(uint256).max, msg.sender ); } else if (harvestType == 1) { // transaction.to = 0x4da27a545c0c5B758a6BA100e3a049001de870f5; transaction.data = abi.encodeWithSelector(bytes4(keccak256("cooldown()"))); } else if (harvestType == 2) { // transaction.to = 0x4da27a545c0c5B758a6BA100e3a049001de870f5; 39 Fuji Protocol transaction.data = abi.encodeWithSelector( bytes4(keccak256("redeem(address,uint256)")), msg.sender, type(uint256).max ); claimedToken = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9; } } } Figure 18.1: Harvester.sol#L13-54 Exploit Scenario Alice, an executor of the Fuji Protocol, calls getHarvestTransaction with the _farmProtocolNum parameter set to 2. As a result, rather than reverting, the function returns claimedToken and transaction values of 0. Recommendations Short term, revise getHarvestTransaction so that it reverts if it is called with invalid farmProtocolNum or harvestType values. Long term, ensure that all functions revert if they are called with invalid values. 40 Fuji Protocol 19. Lack of data validation in Controller‚Äôs doReÔ¨Ånancing function Severity: Low DiÔ¨Éculty: High Type: Data Validation Finding ID: TOB-FUJI-019 Target: Controller.sol Description The Controller contract‚Äôs doRefinancing function does not check the _newProvider value. Therefore, the function accepts invalid values for the _newProvider parameter. function doRefinancing( address _vaultAddr, address _newProvider, uint256 _ratioA, uint256 _ratioB, uint8 _flashNum ) external isValidVault(_vaultAddr) onlyOwnerOrExecutor { IVault vault = IVault(_vaultAddr); [...] [...] IVault(_vaultAddr).setActiveProvider(_newProvider); } Figure 19.1: Controller.sol#L44-84 Exploit Scenario Alice, an executor of the Fuji Protocol, calls Controller.doRefinancing with the _newProvider parameter set to the same address as the active provider. As a result, unnecessary Ô¨Çash loan fees will be paid. Recommendations Short term, revise the doRefinancing function so that it reverts if _newProvider is set to the same address as the active provider. Long term, ensure that all functions revert if they are called with invalid values. 41 Fuji Protocol 20. Lack of data validation on function parameters Severity: Low DiÔ¨Éculty: Low Type: Data Validation Finding ID: TOB-FUJI-020 Target: Throughout Description Certain setter functions fail to validate the addresses they receive as input. The following addresses are not validated: ‚óè The addresses passed to all setters in the FujiAdmin contract ‚óè The _newFujiAdmin address in the setFujiAdmin function in the Controller and FujiVault contracts ‚óè The _provider address in the FujiVault.setActiveProvider function ‚óè The _oracle address in the FujiVault.setOracle function ‚óè The _providers addresses in the FujiVault.setProviders function ‚óè The newOwner address in the transferOwnership function in the Claimable and ClaimableUpgradeable contracts Exploit scenario Alice, a member of the Fuji Protocol team, invokes the FujiVault.setOracle function and sets the oracle address as address(0). As a result, code relying on the oracle address is no longer functional. Recommendations Short term, add zero-value or contract existence checks to the functions listed above to ensure that users cannot accidentally set incorrect values, misconÔ¨Åguring the protocol. Long term, use Slither, which will catch missing zero checks. 42 Fuji Protocol 21. Solidity compiler optimizations can be problematic Severity: Informational DiÔ¨Éculty: High Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-021 Target: hardhat-config.js Description Fuji Protocol has enabled optional compiler optimizations in Solidity. There have been several optimization bugs with security implications. Moreover, optimizations are actively being developed. Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them. Therefore, it is unclear how well they are being tested and exercised. High-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten-generated solc-js compiler used by TruÔ¨Ñe and Remix persisted until late 2018. The Ô¨Åx for this bug was not reported in the Solidity CHANGELOG. Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. More recently, another bug due to the incorrect caching of keccak256 was reported. A compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe. It is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations. Exploit Scenario A latent or future bug in Solidity compiler optimizations‚Äîor in the Emscripten transpilation to solc-js‚Äîcauses a security vulnerability in the Fuji Protocol contracts. Recommendations Short term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug. Long term, monitor the development and adoption of Solidity compiler optimizations to assess their maturity. 43 Fuji Protocol A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diÔ¨Éculty levels used in this document. Vulnerability Categories Category Description Access Controls InsuÔ¨Écient authorization of users or assessment of rights Auditing and Logging InsuÔ¨Écient auditing of actions or logging of problems Authentication Improper identiÔ¨Åcation of users ConÔ¨Åguration MisconÔ¨Ågured servers, devices, or software components Cryptography Breach of the conÔ¨Ådentiality or integrity of data Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service System failure with an availability impact Error Reporting Insecure or insuÔ¨Écient reporting of error conditions Patching Outdated software package or library Session Management Improper identiÔ¨Åcation of authenticated users Testing Timing InsuÔ¨Écient test methodology or test coverage Race conditions, locking, or other order-of-operations Ô¨Çaws UndeÔ¨Åned Behavior UndeÔ¨Åned behavior triggered within the system 44 Fuji Protocol Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices or defense in depth. Undetermined The extent of the risk was not determined during this engagement. Low Medium High The risk is relatively small or is not a risk the client has indicated is important. Individual users‚Äô information is at risk; exploitation could pose reputational, legal, or moderate Ô¨Ånancial risks to the client. The issue could aÔ¨Äect numerous users and have serious reputational, legal, or Ô¨Ånancial implications for the client. DiÔ¨Éculty Levels DiÔ¨Éculty Description Undetermined The diÔ¨Éculty of exploitation was not determined during this engagement. Low Medium High The Ô¨Çaw is commonly exploited; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of a complex system. An attacker must have privileged insider access to the system, may need to know extremely complex technical details, or must discover other weaknesses to exploit this issue. 45 Fuji Protocol B. Code Maturity Categories The following tables describe the code maturity categories and rating criteria used in this document. Code Maturity Categories Categories Description Access Controls The authentication and authorization of components Arithmetic The proper use of mathematical operations and semantics Assembly Use The use of inline assembly Centralization The existence of a single point of failure Upgradeability Contract upgradeability Function Composition The separation of the logic into functions with clear purposes Front-Running Resistance to front-running Key Management The existence of proper procedures for key generation, distribution, and access Monitoring The use of events and monitoring procedures SpeciÔ¨Åcation The comprehensiveness and readability of codebase documentation and speciÔ¨Åcation Testing and VeriÔ¨Åcation The use of testing techniques (e.g., unit tests and fuzzing) 46 Fuji Protocol Rating Criteria Rating Strong Description The control was robust, documented, automated, and comprehensive. Satisfactory With a few minor exceptions, the control was applied consistently. Moderate The control was applied inconsistently in certain areas. Weak The control was applied inconsistently or not at all. Missing The control was missing. Not Applicable The control is not applicable. Not Considered The control was not reviewed. Further Investigation Required The control requires further investigation. 47 Fuji Protocol C. Token Integration Checklist The following checklist provides recommendations for interactions with arbitrary tokens. Every unchecked item should be justiÔ¨Åed, and its associated risks, understood. Refer to an up-to-date version of the checklist on crytic/building-secure-contracts. For convenience, all Slither utilities can be run directly on a token address, such as the following: slither-check-erc 0xdac17f958d2ee523a2206206994597c13d831ec7 TetherToken To follow this checklist, use the below output from Slither for the token: - slither-check-erc [target] [contractName] [optional: --erc ERC_NUMBER] - slither [target] --print human-summary - slither [target] --print contract-summary - slither-prop . --contract ContractName # requires configuration, and use of Echidna and Manticore General Security Considerations ‚ùè The contract has a security review. Avoid interacting with contracts that lack a security review. Check the length of the assessment (i.e., the level of eÔ¨Äort), the reputation of the security Ô¨Årm, and the number and severity of the Ô¨Åndings. ‚ùè You have contacted the developers. You may need to alert their team to an incident. Look for appropriate contacts on blockchain-security-contacts. ‚ùè They have a security mailing list for critical announcements. Their team should advise users (like you!) when critical issues are found or when upgrades occur. ERC Conformity Slither includes a utility, slither-check-erc, that reviews the conformance of a token to many related ERC standards. Use slither-check-erc to review the following: ‚ùè Transfer and transferFrom return a boolean. Several tokens do not return a boolean on these functions. As a result, their calls in the contract might fail. ‚ùè The name, decimals, and symbol functions are present if used. These functions are optional in the ERC20 standard and may not be present. 48 Fuji Protocol ‚ùè Decimals returns a uint8. Several tokens incorrectly return a uint256. In such cases, ensure that the value returned is below 255. ‚ùè The token mitigates the known ERC20 race condition. The ERC20 standard has a known ERC20 race condition that must be mitigated to prevent attackers from stealing tokens. ‚ùè The token is not an ERC777 token and has no external function call in transfer or transferFrom. External calls in the transfer functions can lead to reentrancies. Slither includes a utility, slither-prop, that generates unit tests and security properties that can discover many common ERC Ô¨Çaws. Use slither-prop to review the following: ‚ùè The contract passes all unit tests and security properties from slither-prop. Run the generated unit tests and then check the properties with Echidna and Manticore. Finally, there are certain characteristics that are diÔ¨Écult to identify automatically. Conduct a manual review of the following conditions: ‚ùè Transfer and transferFrom should not take a fee. DeÔ¨Çationary tokens can lead to unexpected behavior. ‚ùè Potential interest earned from the token is taken into account. Some tokens distribute interest to token holders. This interest may be trapped in the contract if not taken into account. Contract Composition ‚ùè The contract avoids unnecessary complexity. The token should be a simple contract; a token with complex code requires a higher standard of review. Use Slither‚Äôs human-summary printer to identify complex code. ‚ùè The contract uses SafeMath. Contracts that do not use SafeMath require a higher standard of review. Inspect the contract by hand for SafeMath usage. ‚ùè The contract has only a few non-token-related functions. Non-token-related functions increase the likelihood of an issue in the contract. Use Slither‚Äôs contract-summary printer to broadly review the code used in the contract. ‚ùè The token has only one address. Tokens with multiple entry points for balance updates can break internal bookkeeping based on the address (e.g., balances[token_address][msg.sender] may not reÔ¨Çect the actual balance). 49 Fuji Protocol Owner Privileges ‚ùè The token is not upgradeable. Upgradeable contracts may change their rules over time. Use Slither‚Äôs human-summary printer to determine if the contract is upgradeable. ‚ùè The owner has limited minting capabilities. Malicious or compromised owners can abuse minting capabilities. Use Slither‚Äôs human-summary printer to review minting capabilities, and consider manually reviewing the code. ‚ùè The token is not pausable. Malicious or compromised owners can trap contracts relying on pausable tokens. Identify pausable code by hand. ‚ùè The owner cannot blacklist the contract. Malicious or compromised owners can trap contracts relying on tokens with a blacklist. Identify blacklisting features by hand. ‚ùè The team behind the token is known and can be held responsible for abuse. Contracts with anonymous development teams or teams that reside in legal shelters require a higher standard of review. Token Scarcity Reviews of token scarcity issues must be executed manually. Check for the following conditions: ‚ùè The supply is owned by more than a few users. If a few users own most of the tokens, they can inÔ¨Çuence operations based on the tokens‚Äô repartition. ‚ùè The total supply is suÔ¨Écient. Tokens with a low total supply can be easily manipulated. ‚ùè The tokens are located in more than a few exchanges. If all the tokens are in one exchange, a compromise of the exchange could compromise the contract relying on the token. ‚ùè Users understand the risks associated with a large amount of funds or Ô¨Çash loans. Contracts relying on the token balance must account for attackers with a large amount of funds or attacks executed through Ô¨Çash loans. ‚ùè The token does not allow Ô¨Çash minting. Flash minting can lead to substantial swings in the balance and the total supply, which necessitate strict and comprehensive overÔ¨Çow checks in the operation of the token. 50 Fuji Protocol E. Code Quality Recommendations The following recommendations are not associated with speciÔ¨Åc vulnerabilities. However, they enhance code readability and may prevent the introduction of vulnerabilities in the future. General Recommendations ‚óè Consider merging FujiVault, VaultBaseUpgradeable, and VaultControlUpgradeable. These separate contracts are unnecessary and make auditing more diÔ¨Écult. ‚óè Consider removing unused imports from the DyDxFlashLoans, FujiERC115, Harvester, and Swapper contracts. Flasher ‚óè Consider replacing the magic numbers for the flashnum parameter of the initiateFlashloan function with enums. FujiVault ‚óè The fee calculation implemented by _userProtocolFee is repeated inline in the borrow function (line 275). Consider calling _userProtocolFee instead of borrow. ‚óè Consider renaming the _fujiadmin parameter of the initialize function to __fujiAdmin. To prevent shadowing, do not use entirely lowercase names. ‚óè Consider renaming the Factor struct to Ratio, its Ô¨Åeld a to numerator, and its Ô¨Åeld b to denominator; these labels are more self-explanatory. ‚óè Consider changing the type of fujiERC1155 from address to IFujiERC1155; this will reduce boilerplate casts, which decrease readability. ‚óè Both the if and else branch of the deposit function revert if _collateralAmount == 0. Consider moving that check to before the if statement. ‚óè Consider renaming updateF1155Balances to updateF1155Indexes, which more accurately describes what the function does. FujiBaseERC1155 ‚óè Consider removing the unused _beforeTokenTransfer and _asSingletonArray functions. FujiERC1155 51 Fuji Protocol ‚óè Consider renaming the contract to F1155, which is the name used in the white paper. ‚óè Consider renaming updateState to updateIndex, which more accurately describes what the function does. FLiquidator ‚óè Consider renaming the state variable IUniswapV2Router02 public swapper, as it has the same name as the Swapper contract but represents something diÔ¨Äerent. Controller ‚óè Consider renaming the contract to Refinancer or RefinancingController to emphasize that this contract is responsible for reÔ¨Ånancing. DyDxFlashLoans ‚óè Consider renaming the DyDxFlashLoans.sol Ô¨Ålename to avoid inconsistency with the DyDxFlashloanBase contract. 52 Fuji Protocol F. Index Construction for Interest Calculation The Fuji Protocol takes out loans from borrowing protocols like Aave and Compound. As these loans accrue interest over time, debt increases as time progresses. If a user takes out a loan from the Fuji Protocol, she will later have to repay more than the initial value of the loan due to the interest that has accumulated. The exact value she will have to repay is determined by the Ô¨Çoating interest rate of the active borrowing protocol during the time between the borrowing and repayment operations. The interest rate is not Ô¨Åxed but changes based on the supply and demand of the active borrowing protocol‚Äôs assets. Therefore, the interest rate can be diÔ¨Äerent for each block. A naive strategy for handling variable interest rates would be to measure the interest rate on each block and adjust each user's debt accordingly. However, this strategy would require one transaction per block, and the gas costs would scale linearly with the number of users. The resulting gas requirements and costs make this solution impractical on Ethereum. Rather than updating user debt balances on each block, the Fuji Protocol updates them before any operation that depends on up-to-date user debt balances. The interest rate atùëü ùë° time is calculated using the growth between the previous debt balance and the current ùë° debt balance owed to the active borrowing protocol: ùëü ùë° /ùëè = ùëè ùë° ùë°‚àí1 . The Fuji internal debt balance ùëë ùë° of the user is then adjusted by the interest rate: ùëë ùë° = ùëë ùë°‚àí1 * ùëü ùë° . However, each user‚Äôs debt must still be updated individually, resulting in gas requirements that scale with the number of users. The active borrowing protocol gives the same interest to all borrowers at any given point in time. As a result, the interest rate ùëü ùë° is identical for all loans. Therefore, ùëü ùë° = (ùëè ùë° ‚àí ùëè )/ùëè ùë°‚àí1 ùë°‚àí1 = (ùêµ ùë° ‚àí ùêµ )/ùêµ ùë°‚àí1 ùë°‚àí1 , where is an individual user‚Äôs ùëè debt, and is the total debt that the Fuji Protocol owes to the active borrowing protocol. ùêµ From this, it follows that instead of updating each user‚Äôs balance, one can calculate the product of all interest rates ùëü in an index that represents the interest rate of a loan that was ùë° borrowed at the beginning of the protocol‚Äôs lifetime: ùêº ùë° = 1 * ùëü 1 * ùëü 2 * ùëü 3 *... * ùëü . One can ùë° then multiply a user‚Äôs initial debt balance ùëë by to obtain the user‚Äôs current debt balance: 0 ùêº ùë° ùëë ùë° = ùêº ùë° * ùëë . The index starts at 0 ùêº ùë° ùêº 0 = 1 . As a result, a user‚Äôs initial debt balance is multiplied 53 Fuji Protocol by the interest rate only when a user‚Äôs debt balance is requested, not when the interest rate is updated; this process can be implemented much more eÔ¨Éciently on Ethereum. Not all users take out their loans at the beginning of the lifetime of the protocol. If a user takes out her loan at timestamp ùë§! = 0 , then the calculation ùëë ùë° = ùêº ùë° * ùëë ùë§ is incorrect, as it gives the user the interest accumulated before the time she took out the loan. To adjust for this issue, a snapshot of the index at the time the loan was taken out, ùêº ùë§ , is remembered, and the user‚Äôs debt balance is divided by = 1 * ùëü 1 *... * ùëü * ùëü 2 ùë§‚àí1 ùêº ùë§ to divide out the interest rate before the loan is taken out: ùêº ùë° = 1 * ùëü 1 * ùëü 2 * ... * ùëü ùë§‚àí1 * ùëü ùë§ * ùëü ùë§+1 * ùëü ùë§+2 *... * ùëü ùë° ‚áî ùëü ùë§ * ùëü ùë§+1 * ùëü ùë§+2 *... * ùëü ùë° /(1 * ùëü = ùêº 1 ùë° * ùëü 2 *... * ùëü ) ùë§‚àí1 The following is the resulting formula for calculating any user‚Äôs current debt balance: ùëë ùë° = ùëë ùë§ /ùêº * ùêº ùë° ùë§ 54 Fuji Protocol G. Handling Key Material The safety of key material is important in any system, but particularly so in Ethereum; keys dictate access to money and resources. Theft of keys could mean a complete loss of funds or trust in the market. The current conÔ¨Åguration uses an environment variable in production to relay key material to applications that use these keys to interact with on-chain components. However, attackers with local access to the machine may be able to extract these environment variables and steal key material, even without privileged positions. Therefore, we recommend the following: ‚óè Move key material from environment variables to a dedicated secret management system with trusted computing capabilities. The two best options for this are Google Cloud Key Management System (GCKMS) and Hashicorp Vault with hardware security module (HSM) backing. ‚óè Restrict access to GCKMS or Hashicorp Vault to only those applications and administrators that must have access to the credential store. ‚óè Local key material, such as keys used by fund administrators, may be stored in local HSMs, such as YubiHSM2. ‚óè Limit the number of staÔ¨Ä members and applications with access to this machine. ‚óè Segment the machine away from all other hosts on the network. ‚óè Ensure strict host logging, patching, and auditing policies are in place for any machine or application that handles said material. ‚óè Determine the business risk of a lost or stolen key, and determine the disaster recovery and business continuity (DR/BC) policies in the event of a stolen or lost key. 55 Fuji Protocol H. Fix Log On December 3, 2021, reviewed the Ô¨Åxes and mitigations implemented by the Fuji Protocol team for the issues identiÔ¨Åed in this report. The Fuji Protocol team Ô¨Åxed 13 of the issues reported in the original assessment, partially Ô¨Åxed 4, and acknowledged but did not Ô¨Åx the remaining 4. We reviewed each of the Ô¨Åxes to ensure that the proposed remediation would be eÔ¨Äective. The Ô¨Åx commits often contained additional changes not related to the Ô¨Åxes. We did not comprehensively review these changes. For additional information, please refer to the Detailed Fix Log. ID Title Severity Fix Status 1 2 3 4 5 6 7 8 9 Anyone can destroy the FujiVault logic contract if its initialize function was not called during deployment High Partially Fixed (f6858e8) Providers are implemented with delegatecall Informational Lack of contract existence check on delegatecall will result in unexpected behavior High FujiVault.setFactor is unnecessarily complex and does not properly handle invalid input Informational Preconditions speciÔ¨Åed in docstrings are not checked by functions Informational The FujiERC1155.burnBatch function implementation is incorrect High Error in the white paper‚Äôs equation for the cost of reÔ¨Ånancing Informational Errors in the white paper‚Äôs equation for index calculation Medium Risk accepted by the client Partially Ô¨Åxed (03a4aa0) Fixed (9e79d2e) Fixed (2efc1b4, 9e79d2e) Fixed (900f7d7) Fixed (33c8c8b) Fixed (33c8c8b) FujiERC1155.setURI does not adhere to the EIP-1155 speciÔ¨Åcation Informational Partially Ô¨Åxed (3477e6a) 56 Fuji Protocol 13 14 15 16 10 Partial reÔ¨Ånancing operations can break the protocol Medium Fixed (efa86b0) 11 Native support for ether increases the codebase‚Äôs complexity Informational Risk accepted by the client 12 Missing events for critical operations Indexes are not updated before all operations that require up-to-date indexes Low High Fixed (3477e6a) Partially Ô¨Åxed (d17cd77) No protection against missing index updates before operations that depend on up-to-date indexes Informational Risk accepted by the client Formula for index calculation is unnecessarily complex Informational Flasher‚Äôs initiateFlashloan function does not revert on invalid Ô¨Çashnum values Low 17 Docstrings do not reÔ¨Çect functions‚Äô implementations Low 18 19 Harvester‚Äôs getHarvestTransaction function does not revert on invalid _farmProtocolNum and harvestType values Low Lack of data validation in Controller‚Äôs doReÔ¨Ånancing function Low 20 Lack of data validation on function parameters Low Fixed (0cc7032) Fixed (3cc8b21) Fixed (9e79d2e) Fixed (794e5d7) Fixed (2efc1b4) Fixed (293d9aa, 2c96c16, 0d77944) 21 Solidity compiler optimizations can be problematic Informational Risk accepted by the client 57 Fuji Protocol Detailed Fix Log TOB-FUJI-001: Anyone can destroy the FujiVault logic contract if its initialize function was not called during deployment Partially Ô¨Åxed. The Fuji Protocol team modiÔ¨Åed the deployVault.js script to call initialize on the vault if it has not been called already. However, the team did not address the root cause of the issue: the dangerous call to delegatecall. (f6858e8) TOB-FUJI-002: Providers are implemented with delegatecall Risk accepted by the client. The Fuji Protocol team provided the following rationale for its acceptance of this risk: ‚ÄúThe team assumes the risk of maintaining the use of delegatecall; however, the rationale comes after some mitigations and an internal analysis with the following statements: ‚óè Debt positions are not transferable as deposit positions are. ‚óè As explained in the report, it is important that the context of the caller at the underlying lending-borrowing protocols is the FujiVault. Deposit receipt tokens can easily be transferred, however, debt positions cannot. Aave, has a credit delegation feature that could be used to maintain the desired context, but the remaining providers do not have it. To keep call methods universal for all providers it is preferred that all providers are called similarly and delegatecall facilitates this. ‚óè Mitigations to the risks of delegatecall: ‚óè _execute function was changed to private. It now can only be called by only the functions within VaultBaseUpgradeable.sol. This means that future upgrades could easily be checked to maintain _execute only within the context of VaultBaseUpgradeable. ‚óè It was veriÔ¨Åed that _execute can only call addresses deÔ¨Åned by two functions; these are set in: ‚óã setProviders() which is restricted to owner ‚óã setActiveProvider() which is restricted to owner and the controller after a reÔ¨Ånancing. ‚óè A check was introduced in executeSwitch to ensure address passed is a valid provider.‚Äù TOB-FUJI-003: Lack of contract existence check on delegatecall will result in unexpected behavior Partially Ô¨Åxed. The Fuji Protocol team added a contract existence check before the delegatecall in VaultBaseUpgradeable._execute. Also, assembly is no longer used for the implementation of that delegatecall. This makes the call simpler and less error-prone. However, the team is still using OpenZeppelin‚Äôs Proxy contract, which does not check for contract existence before its delegatecall. (03a4aa0) 58 Fuji Protocol TOB-FUJI-004: FujiVault.setFactor is unnecessarily complex and does not properly handle invalid input Fixed. The Fuji Protocol team modiÔ¨Åed the FujiVault.setFactor function so that it reverts if an invalid type is provided. (9e79d2e) TOB-FUJI-005: Preconditions speciÔ¨Åed in docstrings are not checked by functions Fixed. The Fuji Protocol team added the missing checks to Controller.doRefinancing and FujiVault.setFactor. (2efc1b4, 9e79d2e) TOB-FUJI-006: The FujiERC1155.burnBatch function implementation is incorrect Fixed. The Fuji Protocol team replaced amount with amountScaled in the burnBatch and mintBatch functions. Additionally, the team extracted the _mint and _burn functions, which are now reused, leading to less duplicate code and decreasing the chance that similar issues will arise in the burning and minting functions in the future. (900f7d7) TOB-FUJI-007: Error in the white paper‚Äôs equation for the cost of reÔ¨Ånancing Fixed. The Fuji Protocol team Ô¨Åxed equation 4 in the white paper. Additionally, the team Ô¨Åxed mistakes in the equation beyond those that we reported. However, the text below the equation in the white paper is inconsistent with the equation, since is now always a ùêπùêø ùëìùëíùëí percentage. (33c8c8b) TOB-FUJI-008: Errors in the white paper‚Äôs equation for index calculation Fixed. The Fuji Protocol team Ô¨Åxed equation 1 in the white paper. (33c8c8b) TOB-FUJI-009: FujiERC1155.setURI does not adhere to the EIP-1155 speciÔ¨Åcation Partially Ô¨Åxed. FujiERC1155‚Äôs setURI function still does not emit the URI event. The decision not to add this event is understandable, as doing so would require looping over all tokens. However, the Fuji Protocol team documented this behavior and modiÔ¨Åed the function so that it now emits a custom URIGlobalChanged event instead. (3477e6a) TOB-FUJI-010: Partial reÔ¨Ånancing operations can break the protocol Fixed. The Fuji Protocol team removed the ability to perform partial reÔ¨Ånancing operations from the protocol. (efa86b0) TOB-FUJI-011: Native support for ether increases the codebase‚Äôs complexity Risk accepted by the client. The Fuji Protocol team acknowledged the issue and provided the following rationale for its acceptance of this risk: ‚ÄúFuji protocol on Ethereum mainnet has to interact with Compound, which cETH market, operates in native ETH. To support ETH as collateral in Compound the asset must be handled in native form. Excluding Compound as a provider is not an option for the Fuji protocol at the moment.‚Äù 59 Fuji Protocol TOB-FUJI-012: Missing events for critical operations Fixed. The Fuji Protocol team added all missing events to the FujiAdmin, Controller, FujiERC1155, FujiMapping, FujiOracle, and FujiVault contracts. (3477e6a) TOB-FUJI-013: Indexes are not updated before all operations that require up-to-date indexes Partially Ô¨Åxed. The Fuji Protocol team added a call to updateF1155Balances in the deposit function but not in the paybackLiq function. The Ô¨Åx commit also contained some refactoring. We did not have time to check the correctness of this refactoring. (d17cd77) TOB-FUJI-014: No protection against missing index updates before operations that depend on up-to-date indexes Risk accepted by the client. The Fuji protocol team provided the following rationale for its acceptance of this risk: ‚ÄúThe team acknowledges the recommendation; however, the exploit scenario is limited. The team with foresee no future functions in the design pipeline that will involve index value calls. Item point will be considered for future implementation when there is a architecture design change in the protocol.‚Äù TOB-FUJI-015: Formula for index calculation is unnecessarily complex Fixed. The Fuji Protocol team correctly implemented the simpler formula suggested in this report. (0cc7032) TOB-FUJI-016: Flasher‚Äôs initiateFlashloan function does not revert on invalid Ô¨Çashnum values Fixed. The initiateFlashloan function now reverts on invalid _flashnum values. (3cc8b21) TOB-FUJI-017: Docstrings do not reÔ¨Çect functions‚Äô implementations Fixed. The Fuji Protocol team updated the docstrings so that they reÔ¨Çect the implementations. (9e79d2e) TOB-FUJI-018: Harvester‚Äôs getHarvestTransaction function does not revert on invalid _farmProtocolNum and harvestType values Fixed. The VaultHarvester contract‚Äôs getHarvestTransaction function now reverts on invalid _farmProtocolNum and harvestType values. (794e5d7) TOB-FUJI-019: Lack of data validation in Controller‚Äôs doReÔ¨Ånancing function Fixed. The Controller contract‚Äôs doRefinancing function now reverts if the new provider equals the active provider. (2efc1b4) 60 Fuji Protocol TOB-FUJI-020: Lack of data validation on function parameters Fixed. The Fuji Protocol team added missing zero address checks to the following functions: Claimable.transferOwnership, ClaimableUpgradeable.transferOwnership, Controller.setFujiAdmin, FujiVault.setFujiAdmin, FujiVault.setProviders, and FujiVault.setOracle. As of commit 0d77944, the FujiAdmin contract is not missing any checks. The team also added further zero checks. (293d9aa, 2c96c16, 0d77944) TOB-FUJI-021: Solidity compiler optimizations can be problematic Risk accepted by the client. 61 Fuji Protocol
14. No protection against missing index updates before operations that depend on up-to-date indexes Severity: Informational DiÔ¨Éculty: Low Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-014 Target: FujiVault.sol, FujiERC1155.sol, FLiquidator.sol Description The FujiERC1155 contract uses indexes to keep track of interest rates. Refer to Appendix F for more detail on the index calculation. The FujiVault contract‚Äôs updateF1155Balances function is responsible for updating indexes. This function must be called before all operations that read indexes (TOB-FUJI-013). However, the protocol does not protect against situations in which indexes are not updated before they are read; these situations could result in incorrect accounting. Exploit Scenario Developer Bob adds a new operation that reads indexes, but he forgets to add a call to updateF1155Balances. As a result, the new operation uses outdated index values, which causes incorrect accounting. Recommendations Short term, redesign the index calculations so that they provide protection against the reading of outdated indexes. For example, the index calculation process could keep track of the last index update‚Äôs block number and access indexes exclusively through a getter, which updates the index automatically, if it has not already been updated for the current block. Since ERC-1155‚Äôs balanceOf and totalSupply functions do not allow side eÔ¨Äects, this solution would require the use of diÔ¨Äerent functions internally. Long term, use defensive coding practices to ensure that critical operations are always executed when required. 34 Fuji Protocol 
15. Formula for index calculation is unnecessarily complex Severity: Informational DiÔ¨Éculty: Undetermined Type: Arithmetic Finding ID: TOB-FUJI-015 Target: FujiERC1155.sol Description Indexes are updated within the FujiERC1155 contract‚Äôs updateState function, shown in Ô¨Ågure 15.1. Refer to Appendix F for more detail on the index calculation. function updateState(uint256 _assetID, uint256 newBalance) external override onlyPermit { uint256 total = totalSupply(_assetID); if (newBalance > 0 && total > 0 && newBalance > total) { uint256 diff = newBalance - total; uint256 amountToIndexRatio = (diff.wadToRay()).rayDiv(total.wadToRay()); uint256 result = amountToIndexRatio + WadRayMath.ray(); result = result.rayMul(indexes[_assetID]); require(result <= type(uint128).max, Errors.VL_INDEX_OVERFLOW); indexes[_assetID] = uint128(result); // TODO: calculate interest rate for a fujiOptimizer Fee. } } Figure 15.1: FujiERC1155.sol#L40-57 The code in Ô¨Ågure 14.1 translates to the following equation: = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 * (1 + (ùëèùëéùëôùëéùëõùëêùëí ùë° ‚àí ùëèùëéùëôùëéùëõùëêùëí )/ùëèùëéùëôùëéùëõùëêùëí ùë°‚àí1 ) ùë°‚àí1 Using the distributive property, we can transform this equation into the following: = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 /ùëèùëéùëôùëéùëõùëêùëí * (1 + ùëèùëéùëôùëéùëõùëêùëí ùë° ùë°‚àí1 This version can then be simpliÔ¨Åed: ‚àí ùëèùëéùëôùëéùëõùëêùëí /ùëèùëéùëôùëéùëõùëêùëí ùë°‚àí1 ) ùë°‚àí1 = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 /ùëèùëéùëôùëéùëõùëêùëí * (1 + ùëèùëéùëôùëéùëõùëêùëí ùë° ùë°‚àí1 ‚àí 1) 35 Fuji Protocol Finally, we can simplify the equation even further: = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 /ùëèùëéùëôùëéùëõùëêùëí * ùëèùëéùëôùëéùëõùëêùëí ùë° ùë°‚àí1 The resulting equation is simpler and more intuitively conveys the underlying idea‚Äîthat the index grows by the same ratio as the balance grew since the last index update. Recommendations Short term, use the simpler index calculation formula in the updateState function of the Fuji1155Contract. This will result in code that is more intuitive and that executes using slightly less gas. Long term, use simpler versions of the equations used by the protocol to make the arithmetic easier to understand and implement correctly. 36 Fuji Protocol 16. Flasher‚Äôs initiateFlashloan function does not revert on invalid Ô¨Çashnum values Severity: Low DiÔ¨Éculty: High Type: Data Validation Finding ID: TOB-FUJI-016 Target: Flasher.sol Description The Flasher contract‚Äôs initiateFlashloan function does not initiate a Ô¨Çash loan or perform a reÔ¨Ånancing operation if the flashnum parameter is set to a value greater than 2. However, the function does not revert on invalid flashnum values. function initiateFlashloan(FlashLoan.Info calldata info, uint8 _flashnum) external isAuthorized { if (_flashnum == 0) { _initiateAaveFlashLoan(info); } else if (_flashnum == 1) { _initiateDyDxFlashLoan(info); } else if (_flashnum == 2) { _initiateCreamFlashLoan(info); } } Figure 16.1: Flasher.sol#L61-69 Exploit Scenario Alice, an executor of the Fuji Protocol, calls Controller. doRefinancing with the flashnum parameter set to 3. As a result, no Ô¨Çash loan is initialized, and no reÔ¨Ånancing happens; only the active provider is changed. This results in unexpected behavior. For example, if a user wants to repay his debt after reÔ¨Ånancing, the operation will fail, as no debt is owed to the active provider. Recommendations Short term, revise initiateFlashloan so that it reverts when it is called with an invalid flashnum value. Long term, ensure that all functions revert if they are called with invalid values. 37 Fuji Protocol 17. Docstrings do not reÔ¨Çect functions‚Äô implementations Severity: Low DiÔ¨Éculty: Undetermined Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-017 Target: FujiVault.sol Description The docstring of the FujiVault contract‚Äôs withdraw function states the following: * @param _withdrawAmount: amount of collateral to withdraw * otherwise pass -1 to withdraw maximum amount possible of collateral (including safety factors) Figure 17.1: FujiVault.sol#L188-189 However, the maximum amount is withdrawn on any negative value, not only on a value of -1. A similar inconsistency between the docstring and the implementation exists in the FujiVault contract‚Äôs payback function. Recommendations Short term, adjust the withdraw and payback functions‚Äô docstrings or their implementations to make them match. Long term, ensure that docstrings always match the corresponding function‚Äôs implementation. 38 Fuji Protocol 18. Harvester‚Äôs getHarvestTransaction function does not revert on invalid _farmProtocolNum and harvestType values Severity: Low DiÔ¨Éculty: Medium Type: Data Validation Finding ID: TOB-FUJI-018 Target: Harvester.sol Description The Harvester contract‚Äôs getHarvestTransaction function incorrectly returns claimedToken and transaction values of 0 if the _farmProtocolNum parameter is set to a value greater than 1 or if the harvestType value is set to value greater than 2. However, the function does not revert on invalid _farmProtocolNum and harvestType values. function getHarvestTransaction(uint256 _farmProtocolNum, bytes memory _data) external view override returns (address claimedToken, Transaction memory transaction) { if (_farmProtocolNum == 0) { transaction.to = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B; transaction.data = abi.encodeWithSelector( bytes4(keccak256("claimComp(address)")), msg.sender ); claimedToken = 0xc00e94Cb662C3520282E6f5717214004A7f26888; } else if (_farmProtocolNum == 1) { uint256 harvestType = abi.decode(_data, (uint256)); if (harvestType == 0) { // claim (, address[] memory assets) = abi.decode(_data, (uint256, address[])); transaction.to = 0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5; transaction.data = abi.encodeWithSelector( bytes4(keccak256("claimRewards(address[],uint256,address)")), assets, type(uint256).max, msg.sender ); } else if (harvestType == 1) { // transaction.to = 0x4da27a545c0c5B758a6BA100e3a049001de870f5; transaction.data = abi.encodeWithSelector(bytes4(keccak256("cooldown()"))); } else if (harvestType == 2) { // transaction.to = 0x4da27a545c0c5B758a6BA100e3a049001de870f5; 39 Fuji Protocol transaction.data = abi.encodeWithSelector( bytes4(keccak256("redeem(address,uint256)")), msg.sender, type(uint256).max ); claimedToken = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9; } } } Figure 18.1: Harvester.sol#L13-54 Exploit Scenario Alice, an executor of the Fuji Protocol, calls getHarvestTransaction with the _farmProtocolNum parameter set to 2. As a result, rather than reverting, the function returns claimedToken and transaction values of 0. Recommendations Short term, revise getHarvestTransaction so that it reverts if it is called with invalid farmProtocolNum or harvestType values. Long term, ensure that all functions revert if they are called with invalid values. 40 Fuji Protocol 19. Lack of data validation in Controller‚Äôs doReÔ¨Ånancing function Severity: Low DiÔ¨Éculty: High Type: Data Validation Finding ID: TOB-FUJI-019 Target: Controller.sol Description The Controller contract‚Äôs doRefinancing function does not check the _newProvider value. Therefore, the function accepts invalid values for the _newProvider parameter. function doRefinancing( address _vaultAddr, address _newProvider, uint256 _ratioA, uint256 _ratioB, uint8 _flashNum ) external isValidVault(_vaultAddr) onlyOwnerOrExecutor { IVault vault = IVault(_vaultAddr); [...] [...] IVault(_vaultAddr).setActiveProvider(_newProvider); } Figure 19.1: Controller.sol#L44-84 Exploit Scenario Alice, an executor of the Fuji Protocol, calls Controller.doRefinancing with the _newProvider parameter set to the same address as the active provider. As a result, unnecessary Ô¨Çash loan fees will be paid. Recommendations Short term, revise the doRefinancing function so that it reverts if _newProvider is set to the same address as the active provider. Long term, ensure that all functions revert if they are called with invalid values. 41 Fuji Protocol 20. Lack of data validation on function parameters Severity: Low DiÔ¨Éculty: Low Type: Data Validation Finding ID: TOB-FUJI-020 Target: Throughout Description Certain setter functions fail to validate the addresses they receive as input. The following addresses are not validated: ‚óè The addresses passed to all setters in the FujiAdmin contract ‚óè The _newFujiAdmin address in the setFujiAdmin function in the Controller and FujiVault contracts ‚óè The _provider address in the FujiVault.setActiveProvider function ‚óè The _oracle address in the FujiVault.setOracle function ‚óè The _providers addresses in the FujiVault.setProviders function ‚óè The newOwner address in the transferOwnership function in the Claimable and ClaimableUpgradeable contracts Exploit scenario Alice, a member of the Fuji Protocol team, invokes the FujiVault.setOracle function and sets the oracle address as address(0). As a result, code relying on the oracle address is no longer functional. Recommendations Short term, add zero-value or contract existence checks to the functions listed above to ensure that users cannot accidentally set incorrect values, misconÔ¨Åguring the protocol. Long term, use Slither, which will catch missing zero checks. 42 Fuji Protocol 21. Solidity compiler optimizations can be problematic Severity: Informational DiÔ¨Éculty: High Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-021 Target: hardhat-config.js Description Fuji Protocol has enabled optional compiler optimizations in Solidity. There have been several optimization bugs with security implications. Moreover, optimizations are actively being developed. Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them. Therefore, it is unclear how well they are being tested and exercised. High-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten-generated solc-js compiler used by TruÔ¨Ñe and Remix persisted until late 2018. The Ô¨Åx for this bug was not reported in the Solidity CHANGELOG. Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. More recently, another bug due to the incorrect caching of keccak256 was reported. A compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe. It is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations. Exploit Scenario A latent or future bug in Solidity compiler optimizations‚Äîor in the Emscripten transpilation to solc-js‚Äîcauses a security vulnerability in the Fuji Protocol contracts. Recommendations Short term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug. Long term, monitor the development and adoption of Solidity compiler optimizations to assess their maturity. 43 Fuji Protocol A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diÔ¨Éculty levels used in this document. Vulnerability Categories Category Description Access Controls InsuÔ¨Écient authorization of users or assessment of rights Auditing and Logging InsuÔ¨Écient auditing of actions or logging of problems Authentication Improper identiÔ¨Åcation of users ConÔ¨Åguration MisconÔ¨Ågured servers, devices, or software components Cryptography Breach of the conÔ¨Ådentiality or integrity of data Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service System failure with an availability impact Error Reporting Insecure or insuÔ¨Écient reporting of error conditions Patching Outdated software package or library Session Management Improper identiÔ¨Åcation of authenticated users Testing Timing InsuÔ¨Écient test methodology or test coverage Race conditions, locking, or other order-of-operations Ô¨Çaws UndeÔ¨Åned Behavior UndeÔ¨Åned behavior triggered within the system 44 Fuji Protocol Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices or defense in depth. Undetermined The extent of the risk was not determined during this engagement. Low Medium High The risk is relatively small or is not a risk the client has indicated is important. Individual users‚Äô information is at risk; exploitation could pose reputational, legal, or moderate Ô¨Ånancial risks to the client. The issue could aÔ¨Äect numerous users and have serious reputational, legal, or Ô¨Ånancial implications for the client. DiÔ¨Éculty Levels DiÔ¨Éculty Description Undetermined The diÔ¨Éculty of exploitation was not determined during this engagement. Low Medium High The Ô¨Çaw is commonly exploited; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of a complex system. An attacker must have privileged insider access to the system, may need to know extremely complex technical details, or must discover other weaknesses to exploit this issue. 45 Fuji Protocol B. Code Maturity Categories The following tables describe the code maturity categories and rating criteria used in this document. Code Maturity Categories Categories Description Access Controls The authentication and authorization of components Arithmetic The proper use of mathematical operations and semantics Assembly Use The use of inline assembly Centralization The existence of a single point of failure Upgradeability Contract upgradeability Function Composition The separation of the logic into functions with clear purposes Front-Running Resistance to front-running Key Management The existence of proper procedures for key generation, distribution, and access Monitoring The use of events and monitoring procedures SpeciÔ¨Åcation The comprehensiveness and readability of codebase documentation and speciÔ¨Åcation Testing and VeriÔ¨Åcation The use of testing techniques (e.g., unit tests and fuzzing) 46 Fuji Protocol Rating Criteria Rating Strong Description The control was robust, documented, automated, and comprehensive. Satisfactory With a few minor exceptions, the control was applied consistently. Moderate The control was applied inconsistently in certain areas. Weak The control was applied inconsistently or not at all. Missing The control was missing. Not Applicable The control is not applicable. Not Considered The control was not reviewed. Further Investigation Required The control requires further investigation. 47 Fuji Protocol C. Token Integration Checklist The following checklist provides recommendations for interactions with arbitrary tokens. Every unchecked item should be justiÔ¨Åed, and its associated risks, understood. Refer to an up-to-date version of the checklist on crytic/building-secure-contracts. For convenience, all Slither utilities can be run directly on a token address, such as the following: slither-check-erc 0xdac17f958d2ee523a2206206994597c13d831ec7 TetherToken To follow this checklist, use the below output from Slither for the token: - slither-check-erc [target] [contractName] [optional: --erc ERC_NUMBER] - slither [target] --print human-summary - slither [target] --print contract-summary - slither-prop . --contract ContractName # requires configuration, and use of Echidna and Manticore General Security Considerations ‚ùè The contract has a security review. Avoid interacting with contracts that lack a security review. Check the length of the assessment (i.e., the level of eÔ¨Äort), the reputation of the security Ô¨Årm, and the number and severity of the Ô¨Åndings. ‚ùè You have contacted the developers. You may need to alert their team to an incident. Look for appropriate contacts on blockchain-security-contacts. ‚ùè They have a security mailing list for critical announcements. Their team should advise users (like you!) when critical issues are found or when upgrades occur. ERC Conformity Slither includes a utility, slither-check-erc, that reviews the conformance of a token to many related ERC standards. Use slither-check-erc to review the following: ‚ùè Transfer and transferFrom return a boolean. Several tokens do not return a boolean on these functions. As a result, their calls in the contract might fail. ‚ùè The name, decimals, and symbol functions are present if used. These functions are optional in the ERC20 standard and may not be present. 48 Fuji Protocol ‚ùè Decimals returns a uint8. Several tokens incorrectly return a uint256. In such cases, ensure that the value returned is below 255. ‚ùè The token mitigates the known ERC20 race condition. The ERC20 standard has a known ERC20 race condition that must be mitigated to prevent attackers from stealing tokens. ‚ùè The token is not an ERC777 token and has no external function call in transfer or transferFrom. External calls in the transfer functions can lead to reentrancies. Slither includes a utility, slither-prop, that generates unit tests and security properties that can discover many common ERC Ô¨Çaws. Use slither-prop to review the following: ‚ùè The contract passes all unit tests and security properties from slither-prop. Run the generated unit tests and then check the properties with Echidna and Manticore. Finally, there are certain characteristics that are diÔ¨Écult to identify automatically. Conduct a manual review of the following conditions: ‚ùè Transfer and transferFrom should not take a fee. DeÔ¨Çationary tokens can lead to unexpected behavior. ‚ùè Potential interest earned from the token is taken into account. Some tokens distribute interest to token holders. This interest may be trapped in the contract if not taken into account. Contract Composition ‚ùè The contract avoids unnecessary complexity. The token should be a simple contract; a token with complex code requires a higher standard of review. Use Slither‚Äôs human-summary printer to identify complex code. ‚ùè The contract uses SafeMath. Contracts that do not use SafeMath require a higher standard of review. Inspect the contract by hand for SafeMath usage. ‚ùè The contract has only a few non-token-related functions. Non-token-related functions increase the likelihood of an issue in the contract. Use Slither‚Äôs contract-summary printer to broadly review the code used in the contract. ‚ùè The token has only one address. Tokens with multiple entry points for balance updates can break internal bookkeeping based on the address (e.g., balances[token_address][msg.sender] may not reÔ¨Çect the actual balance). 49 Fuji Protocol Owner Privileges ‚ùè The token is not upgradeable. Upgradeable contracts may change their rules over time. Use Slither‚Äôs human-summary printer to determine if the contract is upgradeable. ‚ùè The owner has limited minting capabilities. Malicious or compromised owners can abuse minting capabilities. Use Slither‚Äôs human-summary printer to review minting capabilities, and consider manually reviewing the code. ‚ùè The token is not pausable. Malicious or compromised owners can trap contracts relying on pausable tokens. Identify pausable code by hand. ‚ùè The owner cannot blacklist the contract. Malicious or compromised owners can trap contracts relying on tokens with a blacklist. Identify blacklisting features by hand. ‚ùè The team behind the token is known and can be held responsible for abuse. Contracts with anonymous development teams or teams that reside in legal shelters require a higher standard of review. Token Scarcity Reviews of token scarcity issues must be executed manually. Check for the following conditions: ‚ùè The supply is owned by more than a few users. If a few users own most of the tokens, they can inÔ¨Çuence operations based on the tokens‚Äô repartition. ‚ùè The total supply is suÔ¨Écient. Tokens with a low total supply can be easily manipulated. ‚ùè The tokens are located in more than a few exchanges. If all the tokens are in one exchange, a compromise of the exchange could compromise the contract relying on the token. ‚ùè Users understand the risks associated with a large amount of funds or Ô¨Çash loans. Contracts relying on the token balance must account for attackers with a large amount of funds or attacks executed through Ô¨Çash loans. ‚ùè The token does not allow Ô¨Çash minting. Flash minting can lead to substantial swings in the balance and the total supply, which necessitate strict and comprehensive overÔ¨Çow checks in the operation of the token. 50 Fuji Protocol E. Code Quality Recommendations The following recommendations are not associated with speciÔ¨Åc vulnerabilities. However, they enhance code readability and may prevent the introduction of vulnerabilities in the future. General Recommendations ‚óè Consider merging FujiVault, VaultBaseUpgradeable, and VaultControlUpgradeable. These separate contracts are unnecessary and make auditing more diÔ¨Écult. ‚óè Consider removing unused imports from the DyDxFlashLoans, FujiERC115, Harvester, and Swapper contracts. Flasher ‚óè Consider replacing the magic numbers for the flashnum parameter of the initiateFlashloan function with enums. FujiVault ‚óè The fee calculation implemented by _userProtocolFee is repeated inline in the borrow function (line 275). Consider calling _userProtocolFee instead of borrow. ‚óè Consider renaming the _fujiadmin parameter of the initialize function to __fujiAdmin. To prevent shadowing, do not use entirely lowercase names. ‚óè Consider renaming the Factor struct to Ratio, its Ô¨Åeld a to numerator, and its Ô¨Åeld b to denominator; these labels are more self-explanatory. ‚óè Consider changing the type of fujiERC1155 from address to IFujiERC1155; this will reduce boilerplate casts, which decrease readability. ‚óè Both the if and else branch of the deposit function revert if _collateralAmount == 0. Consider moving that check to before the if statement. ‚óè Consider renaming updateF1155Balances to updateF1155Indexes, which more accurately describes what the function does. FujiBaseERC1155 ‚óè Consider removing the unused _beforeTokenTransfer and _asSingletonArray functions. FujiERC1155 51 Fuji Protocol ‚óè Consider renaming the contract to F1155, which is the name used in the white paper. ‚óè Consider renaming updateState to updateIndex, which more accurately describes what the function does. FLiquidator ‚óè Consider renaming the state variable IUniswapV2Router02 public swapper, as it has the same name as the Swapper contract but represents something diÔ¨Äerent. Controller ‚óè Consider renaming the contract to Refinancer or RefinancingController to emphasize that this contract is responsible for reÔ¨Ånancing. DyDxFlashLoans ‚óè Consider renaming the DyDxFlashLoans.sol Ô¨Ålename to avoid inconsistency with the DyDxFlashloanBase contract. 52 Fuji Protocol F. Index Construction for Interest Calculation The Fuji Protocol takes out loans from borrowing protocols like Aave and Compound. As these loans accrue interest over time, debt increases as time progresses. If a user takes out a loan from the Fuji Protocol, she will later have to repay more than the initial value of the loan due to the interest that has accumulated. The exact value she will have to repay is determined by the Ô¨Çoating interest rate of the active borrowing protocol during the time between the borrowing and repayment operations. The interest rate is not Ô¨Åxed but changes based on the supply and demand of the active borrowing protocol‚Äôs assets. Therefore, the interest rate can be diÔ¨Äerent for each block. A naive strategy for handling variable interest rates would be to measure the interest rate on each block and adjust each user's debt accordingly. However, this strategy would require one transaction per block, and the gas costs would scale linearly with the number of users. The resulting gas requirements and costs make this solution impractical on Ethereum. Rather than updating user debt balances on each block, the Fuji Protocol updates them before any operation that depends on up-to-date user debt balances. The interest rate atùëü ùë° time is calculated using the growth between the previous debt balance and the current ùë° debt balance owed to the active borrowing protocol: ùëü ùë° /ùëè = ùëè ùë° ùë°‚àí1 . The Fuji internal debt balance ùëë ùë° of the user is then adjusted by the interest rate: ùëë ùë° = ùëë ùë°‚àí1 * ùëü ùë° . However, each user‚Äôs debt must still be updated individually, resulting in gas requirements that scale with the number of users. The active borrowing protocol gives the same interest to all borrowers at any given point in time. As a result, the interest rate ùëü ùë° is identical for all loans. Therefore, ùëü ùë° = (ùëè ùë° ‚àí ùëè )/ùëè ùë°‚àí1 ùë°‚àí1 = (ùêµ ùë° ‚àí ùêµ )/ùêµ ùë°‚àí1 ùë°‚àí1 , where is an individual user‚Äôs ùëè debt, and is the total debt that the Fuji Protocol owes to the active borrowing protocol. ùêµ From this, it follows that instead of updating each user‚Äôs balance, one can calculate the product of all interest rates ùëü in an index that represents the interest rate of a loan that was ùë° borrowed at the beginning of the protocol‚Äôs lifetime: ùêº ùë° = 1 * ùëü 1 * ùëü 2 * ùëü 3 *... * ùëü . One can ùë° then multiply a user‚Äôs initial debt balance ùëë by to obtain the user‚Äôs current debt balance: 0 ùêº ùë° ùëë ùë° = ùêº ùë° * ùëë . The index starts at 0 ùêº ùë° ùêº 0 = 1 . As a result, a user‚Äôs initial debt balance is multiplied 53 Fuji Protocol by the interest rate only when a user‚Äôs debt balance is requested, not when the interest rate is updated; this process can be implemented much more eÔ¨Éciently on Ethereum. Not all users take out their loans at the beginning of the lifetime of the protocol. If a user takes out her loan at timestamp ùë§! = 0 , then the calculation ùëë ùë° = ùêº ùë° * ùëë ùë§ is incorrect, as it gives the user the interest accumulated before the time she took out the loan. To adjust for this issue, a snapshot of the index at the time the loan was taken out, ùêº ùë§ , is remembered, and the user‚Äôs debt balance is divided by = 1 * ùëü 1 *... * ùëü * ùëü 2 ùë§‚àí1 ùêº ùë§ to divide out the interest rate before the loan is taken out: ùêº ùë° = 1 * ùëü 1 * ùëü 2 * ... * ùëü ùë§‚àí1 * ùëü ùë§ * ùëü ùë§+1 * ùëü ùë§+2 *... * ùëü ùë° ‚áî ùëü ùë§ * ùëü ùë§+1 * ùëü ùë§+2 *... * ùëü ùë° /(1 * ùëü = ùêº 1 ùë° * ùëü 2 *... * ùëü ) ùë§‚àí1 The following is the resulting formula for calculating any user‚Äôs current debt balance: ùëë ùë° = ùëë ùë§ /ùêº * ùêº ùë° ùë§ 54 Fuji Protocol G. Handling Key Material The safety of key material is important in any system, but particularly so in Ethereum; keys dictate access to money and resources. Theft of keys could mean a complete loss of funds or trust in the market. The current conÔ¨Åguration uses an environment variable in production to relay key material to applications that use these keys to interact with on-chain components. However, attackers with local access to the machine may be able to extract these environment variables and steal key material, even without privileged positions. Therefore, we recommend the following: ‚óè Move key material from environment variables to a dedicated secret management system with trusted computing capabilities. The two best options for this are Google Cloud Key Management System (GCKMS) and Hashicorp Vault with hardware security module (HSM) backing. ‚óè Restrict access to GCKMS or Hashicorp Vault to only those applications and administrators that must have access to the credential store. ‚óè Local key material, such as keys used by fund administrators, may be stored in local HSMs, such as YubiHSM2. ‚óè Limit the number of staÔ¨Ä members and applications with access to this machine. ‚óè Segment the machine away from all other hosts on the network. ‚óè Ensure strict host logging, patching, and auditing policies are in place for any machine or application that handles said material. ‚óè Determine the business risk of a lost or stolen key, and determine the disaster recovery and business continuity (DR/BC) policies in the event of a stolen or lost key. 55 Fuji Protocol H. Fix Log On December 3, 2021, reviewed the Ô¨Åxes and mitigations implemented by the Fuji Protocol team for the issues identiÔ¨Åed in this report. The Fuji Protocol team Ô¨Åxed 13 of the issues reported in the original assessment, partially Ô¨Åxed 4, and acknowledged but did not Ô¨Åx the remaining 4. We reviewed each of the Ô¨Åxes to ensure that the proposed remediation would be eÔ¨Äective. The Ô¨Åx commits often contained additional changes not related to the Ô¨Åxes. We did not comprehensively review these changes. For additional information, please refer to the Detailed Fix Log. ID Title Severity Fix Status 1 2 3 4 5 6 7 8 9 Anyone can destroy the FujiVault logic contract if its initialize function was not called during deployment High Partially Fixed (f6858e8) Providers are implemented with delegatecall Informational Lack of contract existence check on delegatecall will result in unexpected behavior High FujiVault.setFactor is unnecessarily complex and does not properly handle invalid input Informational Preconditions speciÔ¨Åed in docstrings are not checked by functions Informational The FujiERC1155.burnBatch function implementation is incorrect High Error in the white paper‚Äôs equation for the cost of reÔ¨Ånancing Informational Errors in the white paper‚Äôs equation for index calculation Medium Risk accepted by the client Partially Ô¨Åxed (03a4aa0) Fixed (9e79d2e) Fixed (2efc1b4, 9e79d2e) Fixed (900f7d7) Fixed (33c8c8b) Fixed (33c8c8b) FujiERC1155.setURI does not adhere to the EIP-1155 speciÔ¨Åcation Informational Partially Ô¨Åxed (3477e6a) 56 Fuji Protocol 13 14 15 16 10 Partial reÔ¨Ånancing operations can break the protocol Medium Fixed (efa86b0) 11 Native support for ether increases the codebase‚Äôs complexity Informational Risk accepted by the client 12 Missing events for critical operations Indexes are not updated before all operations that require up-to-date indexes Low High Fixed (3477e6a) Partially Ô¨Åxed (d17cd77) No protection against missing index updates before operations that depend on up-to-date indexes Informational Risk accepted by the client Formula for index calculation is unnecessarily complex Informational Flasher‚Äôs initiateFlashloan function does not revert on invalid Ô¨Çashnum values Low 17 Docstrings do not reÔ¨Çect functions‚Äô implementations Low 18 19 Harvester‚Äôs getHarvestTransaction function does not revert on invalid _farmProtocolNum and harvestType values Low Lack of data validation in Controller‚Äôs doReÔ¨Ånancing function Low 20 Lack of data validation on function parameters Low Fixed (0cc7032) Fixed (3cc8b21) Fixed (9e79d2e) Fixed (794e5d7) Fixed (2efc1b4) Fixed (293d9aa, 2c96c16, 0d77944) 21 Solidity compiler optimizations can be problematic Informational Risk accepted by the client 57 Fuji Protocol Detailed Fix Log TOB-FUJI-001: Anyone can destroy the FujiVault logic contract if its initialize function was not called during deployment Partially Ô¨Åxed. The Fuji Protocol team modiÔ¨Åed the deployVault.js script to call initialize on the vault if it has not been called already. However, the team did not address the root cause of the issue: the dangerous call to delegatecall. (f6858e8) TOB-FUJI-002: Providers are implemented with delegatecall Risk accepted by the client. The Fuji Protocol team provided the following rationale for its acceptance of this risk: ‚ÄúThe team assumes the risk of maintaining the use of delegatecall; however, the rationale comes after some mitigations and an internal analysis with the following statements: ‚óè Debt positions are not transferable as deposit positions are. ‚óè As explained in the report, it is important that the context of the caller at the underlying lending-borrowing protocols is the FujiVault. Deposit receipt tokens can easily be transferred, however, debt positions cannot. Aave, has a credit delegation feature that could be used to maintain the desired context, but the remaining providers do not have it. To keep call methods universal for all providers it is preferred that all providers are called similarly and delegatecall facilitates this. ‚óè Mitigations to the risks of delegatecall: ‚óè _execute function was changed to private. It now can only be called by only the functions within VaultBaseUpgradeable.sol. This means that future upgrades could easily be checked to maintain _execute only within the context of VaultBaseUpgradeable. ‚óè It was veriÔ¨Åed that _execute can only call addresses deÔ¨Åned by two functions; these are set in: ‚óã setProviders() which is restricted to owner ‚óã setActiveProvider() which is restricted to owner and the controller after a reÔ¨Ånancing. ‚óè A check was introduced in executeSwitch to ensure address passed is a valid provider.‚Äù TOB-FUJI-003: Lack of contract existence check on delegatecall will result in unexpected behavior Partially Ô¨Åxed. The Fuji Protocol team added a contract existence check before the delegatecall in VaultBaseUpgradeable._execute. Also, assembly is no longer used for the implementation of that delegatecall. This makes the call simpler and less error-prone. However, the team is still using OpenZeppelin‚Äôs Proxy contract, which does not check for contract existence before its delegatecall. (03a4aa0) 58 Fuji Protocol TOB-FUJI-004: FujiVault.setFactor is unnecessarily complex and does not properly handle invalid input Fixed. The Fuji Protocol team modiÔ¨Åed the FujiVault.setFactor function so that it reverts if an invalid type is provided. (9e79d2e) TOB-FUJI-005: Preconditions speciÔ¨Åed in docstrings are not checked by functions Fixed. The Fuji Protocol team added the missing checks to Controller.doRefinancing and FujiVault.setFactor. (2efc1b4, 9e79d2e) TOB-FUJI-006: The FujiERC1155.burnBatch function implementation is incorrect Fixed. The Fuji Protocol team replaced amount with amountScaled in the burnBatch and mintBatch functions. Additionally, the team extracted the _mint and _burn functions, which are now reused, leading to less duplicate code and decreasing the chance that similar issues will arise in the burning and minting functions in the future. (900f7d7) TOB-FUJI-007: Error in the white paper‚Äôs equation for the cost of reÔ¨Ånancing Fixed. The Fuji Protocol team Ô¨Åxed equation 4 in the white paper. Additionally, the team Ô¨Åxed mistakes in the equation beyond those that we reported. However, the text below the equation in the white paper is inconsistent with the equation, since is now always a ùêπùêø ùëìùëíùëí percentage. (33c8c8b) TOB-FUJI-008: Errors in the white paper‚Äôs equation for index calculation Fixed. The Fuji Protocol team Ô¨Åxed equation 1 in the white paper. (33c8c8b) TOB-FUJI-009: FujiERC1155.setURI does not adhere to the EIP-1155 speciÔ¨Åcation Partially Ô¨Åxed. FujiERC1155‚Äôs setURI function still does not emit the URI event. The decision not to add this event is understandable, as doing so would require looping over all tokens. However, the Fuji Protocol team documented this behavior and modiÔ¨Åed the function so that it now emits a custom URIGlobalChanged event instead. (3477e6a) TOB-FUJI-010: Partial reÔ¨Ånancing operations can break the protocol Fixed. The Fuji Protocol team removed the ability to perform partial reÔ¨Ånancing operations from the protocol. (efa86b0) TOB-FUJI-011: Native support for ether increases the codebase‚Äôs complexity Risk accepted by the client. The Fuji Protocol team acknowledged the issue and provided the following rationale for its acceptance of this risk: ‚ÄúFuji protocol on Ethereum mainnet has to interact with Compound, which cETH market, operates in native ETH. To support ETH as collateral in Compound the asset must be handled in native form. Excluding Compound as a provider is not an option for the Fuji protocol at the moment.‚Äù 59 Fuji Protocol TOB-FUJI-012: Missing events for critical operations Fixed. The Fuji Protocol team added all missing events to the FujiAdmin, Controller, FujiERC1155, FujiMapping, FujiOracle, and FujiVault contracts. (3477e6a) TOB-FUJI-013: Indexes are not updated before all operations that require up-to-date indexes Partially Ô¨Åxed. The Fuji Protocol team added a call to updateF1155Balances in the deposit function but not in the paybackLiq function. The Ô¨Åx commit also contained some refactoring. We did not have time to check the correctness of this refactoring. (d17cd77) TOB-FUJI-014: No protection against missing index updates before operations that depend on up-to-date indexes Risk accepted by the client. The Fuji protocol team provided the following rationale for its acceptance of this risk: ‚ÄúThe team acknowledges the recommendation; however, the exploit scenario is limited. The team with foresee no future functions in the design pipeline that will involve index value calls. Item point will be considered for future implementation when there is a architecture design change in the protocol.‚Äù TOB-FUJI-015: Formula for index calculation is unnecessarily complex Fixed. The Fuji Protocol team correctly implemented the simpler formula suggested in this report. (0cc7032) TOB-FUJI-016: Flasher‚Äôs initiateFlashloan function does not revert on invalid Ô¨Çashnum values Fixed. The initiateFlashloan function now reverts on invalid _flashnum values. (3cc8b21) TOB-FUJI-017: Docstrings do not reÔ¨Çect functions‚Äô implementations Fixed. The Fuji Protocol team updated the docstrings so that they reÔ¨Çect the implementations. (9e79d2e) TOB-FUJI-018: Harvester‚Äôs getHarvestTransaction function does not revert on invalid _farmProtocolNum and harvestType values Fixed. The VaultHarvester contract‚Äôs getHarvestTransaction function now reverts on invalid _farmProtocolNum and harvestType values. (794e5d7) TOB-FUJI-019: Lack of data validation in Controller‚Äôs doReÔ¨Ånancing function Fixed. The Controller contract‚Äôs doRefinancing function now reverts if the new provider equals the active provider. (2efc1b4) 60 Fuji Protocol TOB-FUJI-020: Lack of data validation on function parameters Fixed. The Fuji Protocol team added missing zero address checks to the following functions: Claimable.transferOwnership, ClaimableUpgradeable.transferOwnership, Controller.setFujiAdmin, FujiVault.setFujiAdmin, FujiVault.setProviders, and FujiVault.setOracle. As of commit 0d77944, the FujiAdmin contract is not missing any checks. The team also added further zero checks. (293d9aa, 2c96c16, 0d77944) TOB-FUJI-021: Solidity compiler optimizations can be problematic Risk accepted by the client. 61 Fuji Protocol
17. Docstrings do not reÔ¨Çect functions‚Äô implementations Severity: Low DiÔ¨Éculty: Undetermined Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-017 Target: FujiVault.sol Description The docstring of the FujiVault contract‚Äôs withdraw function states the following: * @param _withdrawAmount: amount of collateral to withdraw * otherwise pass -1 to withdraw maximum amount possible of collateral (including safety factors) Figure 17.1: FujiVault.sol#L188-189 However, the maximum amount is withdrawn on any negative value, not only on a value of -1. A similar inconsistency between the docstring and the implementation exists in the FujiVault contract‚Äôs payback function. Recommendations Short term, adjust the withdraw and payback functions‚Äô docstrings or their implementations to make them match. Long term, ensure that docstrings always match the corresponding function‚Äôs implementation. 38 Fuji Protocol 
18. Harvester‚Äôs getHarvestTransaction function does not revert on invalid _farmProtocolNum and harvestType values Severity: Low DiÔ¨Éculty: Medium Type: Data Validation Finding ID: TOB-FUJI-018 Target: Harvester.sol Description The Harvester contract‚Äôs getHarvestTransaction function incorrectly returns claimedToken and transaction values of 0 if the _farmProtocolNum parameter is set to a value greater than 1 or if the harvestType value is set to value greater than 2. However, the function does not revert on invalid _farmProtocolNum and harvestType values. function getHarvestTransaction(uint256 _farmProtocolNum, bytes memory _data) external view override returns (address claimedToken, Transaction memory transaction) { if (_farmProtocolNum == 0) { transaction.to = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B; transaction.data = abi.encodeWithSelector( bytes4(keccak256("claimComp(address)")), msg.sender ); claimedToken = 0xc00e94Cb662C3520282E6f5717214004A7f26888; } else if (_farmProtocolNum == 1) { uint256 harvestType = abi.decode(_data, (uint256)); if (harvestType == 0) { // claim (, address[] memory assets) = abi.decode(_data, (uint256, address[])); transaction.to = 0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5; transaction.data = abi.encodeWithSelector( bytes4(keccak256("claimRewards(address[],uint256,address)")), assets, type(uint256).max, msg.sender ); } else if (harvestType == 1) { // transaction.to = 0x4da27a545c0c5B758a6BA100e3a049001de870f5; transaction.data = abi.encodeWithSelector(bytes4(keccak256("cooldown()"))); } else if (harvestType == 2) { // transaction.to = 0x4da27a545c0c5B758a6BA100e3a049001de870f5; 39 Fuji Protocol transaction.data = abi.encodeWithSelector( bytes4(keccak256("redeem(address,uint256)")), msg.sender, type(uint256).max ); claimedToken = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9; } } } Figure 18.1: Harvester.sol#L13-54 Exploit Scenario Alice, an executor of the Fuji Protocol, calls getHarvestTransaction with the _farmProtocolNum parameter set to 2. As a result, rather than reverting, the function returns claimedToken and transaction values of 0. Recommendations Short term, revise getHarvestTransaction so that it reverts if it is called with invalid farmProtocolNum or harvestType values. Long term, ensure that all functions revert if they are called with invalid values. 40 Fuji Protocol 
19. Lack of data validation in Controller‚Äôs doReÔ¨Ånancing function Severity: Low DiÔ¨Éculty: High Type: Data Validation Finding ID: TOB-FUJI-019 Target: Controller.sol Description The Controller contract‚Äôs doRefinancing function does not check the _newProvider value. Therefore, the function accepts invalid values for the _newProvider parameter. function doRefinancing( address _vaultAddr, address _newProvider, uint256 _ratioA, uint256 _ratioB, uint8 _flashNum ) external isValidVault(_vaultAddr) onlyOwnerOrExecutor { IVault vault = IVault(_vaultAddr); [...] [...] IVault(_vaultAddr).setActiveProvider(_newProvider); } Figure 19.1: Controller.sol#L44-84 Exploit Scenario Alice, an executor of the Fuji Protocol, calls Controller.doRefinancing with the _newProvider parameter set to the same address as the active provider. As a result, unnecessary Ô¨Çash loan fees will be paid. Recommendations Short term, revise the doRefinancing function so that it reverts if _newProvider is set to the same address as the active provider. Long term, ensure that all functions revert if they are called with invalid values. 41 Fuji Protocol 
20. Lack of data validation on function parameters Severity: Low DiÔ¨Éculty: Low Type: Data Validation Finding ID: TOB-FUJI-020 Target: Throughout Description Certain setter functions fail to validate the addresses they receive as input. The following addresses are not validated: ‚óè The addresses passed to all setters in the FujiAdmin contract ‚óè The _newFujiAdmin address in the setFujiAdmin function in the Controller and FujiVault contracts ‚óè The _provider address in the FujiVault.setActiveProvider function ‚óè The _oracle address in the FujiVault.setOracle function ‚óè The _providers addresses in the FujiVault.setProviders function ‚óè The newOwner address in the transferOwnership function in the Claimable and ClaimableUpgradeable contracts Exploit scenario Alice, a member of the Fuji Protocol team, invokes the FujiVault.setOracle function and sets the oracle address as address(0). As a result, code relying on the oracle address is no longer functional. Recommendations Short term, add zero-value or contract existence checks to the functions listed above to ensure that users cannot accidentally set incorrect values, misconÔ¨Åguring the protocol. Long term, use Slither, which will catch missing zero checks. 42 Fuji Protocol 
1. Anyone can destroy the FujiVault logic contract if its initialize function was not called during deployment Severity: High DiÔ¨Éculty: Medium Type: Denial of Service Finding ID: TOB-FUJI-001 Target: FujiVault.sol Description Anyone can destroy the FujiVault logic contract if its initialize function has not already been called. Calling initialize on a logic contract is uncommon, as usually nothing is gained by doing so. The deployment script does not call initialize on any logic contract. As a result, the exploit scenario detailed below is possible after deployment. This issue is similar to a bug in AAVE that found in 2020. OpenZeppelin‚Äôs hardhat-upgrades plug-in protects against this issue by disallowing the use of selfdestruct or delegatecall on logic contracts. However, the Fuji Protocol team has explicitly worked around these protections by calling delegatecall in assembly, which the plug-in does not detect. Exploit Scenario The Fuji contracts are deployed, but the initialize functions of the logic contracts are not called. Bob, an attacker, deploys a contract to the address alwaysSelfdestructs, which simply always executes the selfdestruct opcode. Additionally, Bob deploys a contract to the address alwaysSucceeds, which simply never reverts. Bob calls initialize on the FujiVault logic contract, thereby becoming its owner. To make the call succeed, Bob passes 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE as the value for the _collateralAsset and _borrowAsset parameters. He then calls FujiVaultLogic.setActiveProvider(alwaysSelfdestructs), followed by FujiVault.setFujiERC1155(alwaysSucceeds) to prevent an additional revert in the next and Ô¨Ånal call. Finally, Bob calls FujiVault.deposit(1), sending 1 wei. This triggers a delegatecall to alwaysSelfdestructs, thereby destroying the FujiVault logic contract and making the protocol unusable until its proxy contract is upgraded. 14 Fuji Protocol Because OpenZeppelin‚Äôs upgradeable contracts do not check for a contract‚Äôs existence before a delegatecall (TOB-FUJI-003), all calls to the FujiVault proxy contract now succeed. This leads to exploits in any protocol integrating the Fuji Protocol. For example, a call that should repay all debt will now succeed even if no debt is repaid. Recommendations Short term, do not use delegatecall to implement providers. See TOB-FUJI-002 for more information. Long term, avoid the use of delegatecall, as it is diÔ¨Écult to use correctly and can introduce vulnerabilities that are hard to detect. 15 Fuji Protocol 
2. Providers are implemented with delegatecall Severity: Informational DiÔ¨Éculty: Undetermined Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-002 Target: FujiVault.sol, providers Description The system uses delegatecall to execute an active provider's code on a FujiVault, making the FujiVault the holder of the positions in the borrowing protocol. However, delegatecall is generally error-prone, and the use of it introduced the high-severity Ô¨Ånding TOB-FUJI-001. It is possible to make a FujiVault the holder of the positions in a borrowing protocol without using delegatecall. Most borrowing protocols include a parameter that speciÔ¨Åes the receiver of tokens that represent a position. For borrowing protocols that do not include this type of parameter, tokens can be transferred to the FujiVault explicitly after they are received from the borrowing protocol; additionally, the tokens can be transferred from the FujiVault to the provider before they are sent to the borrowing protocol. These solutions are conceptually simpler than and preferred to the current solution. Recommendations Short term, implement providers without the use of delegatecall. Set the receiver parameters to the FujiVault, or transfer the tokens corresponding to the position to the FujiVault. Long term, avoid the use of delegatecall, as it is diÔ¨Écult to use correctly and can introduce vulnerabilities that are hard to detect. 16 Fuji Protocol 
3. Lack of contract existence check on delegatecall will result in unexpected behavior Severity: High DiÔ¨Éculty: High Type: Data Validation Finding ID: TOB-FUJI-003 Target: VaultControlUpgradeable.sol, Proxy.sol Description The VaultControlUpgradeable and Proxy contracts use the delegatecall proxy pattern. If the implementation contract is incorrectly set or self-destructed, the contract may not be able to detect failed executions. The VaultControlUpgradeable contract includes the _execute function, which users can invoke indirectly to execute a transaction to a _target address. This function does not check for contract existence before executing the delegatecall (Ô¨Ågure 3.1). /** * @dev Returns byte response of delegatcalls */ function _execute(address _target, bytes memory _data) internal whenNotPaused returns (bytes memory response) { /* solhint-disable */ assembly { let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 0) let size := returndatasize() response := mload(0x40) mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f)))) mstore(response, size) returndatacopy(add(response, 0x20), 0, size) switch iszero(succeeded) case 1 { // throw if delegatecall failed revert(add(response, 0x20), size) } } /* solhint-disable */ } 17 Fuji Protocol Figure 3.1: fuji-protocol/contracts/abstracts/vault/VaultBaseUpgradeable.sol#L93-L11 5 The Proxy contract, deployed by the @openzeppelin/hardhat-upgrades library, includes a payable fallback function that invokes the _delegate function when proxy calls are executed. This function is also missing a contract existence check (Ô¨Ågure 3.2). /** * @dev Delegates the current call to `implementation`. * * This function does not return to its internall call site, it will return directly to the external caller. */ function _delegate(address implementation) internal virtual { // solhint-disable-next-line no-inline-assembly assembly { // Copy msg.data. We take full control of memory in this inline assembly // block because it will not return to Solidity code. We overwrite the // Solidity scratch pad at memory position 0. calldatacopy(0, 0, calldatasize()) // Call the implementation. // out and outsize are 0 because we don't know the size yet. let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) // Copy the returned data. returndatacopy(0, 0, returndatasize()) switch result // delegatecall returns 0 on error. case 0 { revert(0, returndatasize()) } default { return(0, returndatasize()) } } } Figure 3.2: Proxy.sol#L16-L41 A delegatecall to a destructed contract will return success (Ô¨Ågure 3.3). Due to the lack of contract existence checks, a series of batched transactions may appear to be successful even if one of the transactions fails. The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed. Figure 3.3: A snippet of the Solidity documentation detailing unexpected behavior related to delegatecall Exploit Scenario Eve upgrades the proxy to point to an incorrect new implementation. As a result, each 18 Fuji Protocol delegatecall returns success without changing the state or executing code. Eve uses this to scam users. Recommendations Short term, implement a contract existence check before any delegatecall. Document the fact that suicide and selfdestruct can lead to unexpected behavior, and prevent future upgrades from using these functions. Long term, carefully review the Solidity documentation, especially the ‚ÄúWarnings‚Äù section, and the pitfalls of using the delegatecall proxy pattern. References ‚óè Contract Upgrade Anti-Patterns ‚óè Breaking Aave Upgradeability 19 Fuji Protocol 
4. FujiVault.setFactor is unnecessarily complex and does not properly handle invalid input Severity: Informational DiÔ¨Éculty: Undetermined Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-004 Target: FujiVault.sol Description The FujiVault contract‚Äôs setFactor function sets one of four state variables to a given value. Which state variable is set depends on the value of a string parameter. If an invalid value is passed, setFactor succeeds but does not set any of the state variables. This creates edge cases, makes writing correct code more diÔ¨Écult, and increases the likelihood of bugs. function setFactor( uint64 _newFactorA, uint64 _newFactorB, string calldata _type ) external isAuthorized { bytes32 typeHash = keccak256(abi.encode(_type)); if (typeHash == keccak256(abi.encode("collatF"))) { collatF.a = _newFactorA; collatF.b = _newFactorB; } else if (typeHash == keccak256(abi.encode("safetyF"))) { safetyF.a = _newFactorA; safetyF.b = _newFactorB; } else if (typeHash == keccak256(abi.encode("bonusLiqF"))) { bonusLiqF.a = _newFactorA; bonusLiqF.b = _newFactorB; } else if (typeHash == keccak256(abi.encode("protocolFee"))) { protocolFee.a = _newFactorA; protocolFee.b = _newFactorB; } } Figure 4.1: FujiVault.sol#L475-494 Exploit Scenario A developer on the Fuji Protocol team calls setFactor from another contract. He passes a type that is not handled by setFactor. As a result, code that is expected to set a state variable does nothing, resulting in a more severe vulnerability. 20 Fuji Protocol Recommendations Short term, replace setFactor with four separate functions, each of which sets one of the four state variables. Long term, avoid string constants that simulate enumerations, as they cannot be checked by the typechecker. Instead, use enums and ensure that any code that depends on enum values handles all possible values. 21 Fuji Protocol 
5. Preconditions speciÔ¨Åed in docstrings are not checked by functions Severity: Informational DiÔ¨Éculty: Undetermined Type: Data Validation Finding ID: TOB-FUJI-005 Target: FujiVault.sol, Controller.sol Description The docstrings of several functions specify preconditions that the functions do not automatically check for. For example, the docstring of the FujiVault contract‚Äôs setFactor function contains the preconditions shown in Ô¨Ågure 5.1, but the function‚Äôs body does not contain the corresponding checks shown in Ô¨Ågure 5.2. * For safetyF; Sets Safety Factor of Vault, should be > 1, a/b * For collatF; Sets Collateral Factor of Vault, should be > 1, a/b Figure 5.1: FujiVault.sol#L469-470 require(safetyF.a > safetyF.b); ... require(collatF.a > collatF.b); Figure 5.2: The checks that are missing from FujiVault.setFactor Additionally, the docstring of the Controller contract‚Äôs doRefinancing function contains the preconditions shown in Ô¨Ågure 5.3, but the function‚Äôs body does not contain the corresponding checks shown in Ô¨Ågure 5.4. * @param _ratioB: _ratioA/_ratioB <= 1, and > 0 Figure 5.3: Controller.sol#L41 require(ratioA > 0 && ratioB > 0); require(ratioA <= ratioB); Figure 5.4: The checks that are missing from Controller.doRefinancing Exploit Scenario The setFactor function is called with values that violate its documented preconditions. Because the function does not check for these preconditions, unexpected behavior occurs. 22 Fuji Protocol Recommendations Short term, add checks for preconditions to all functions with preconditions speciÔ¨Åed in their docstrings. Long term, ensure that all documentation and code are in sync. 23 Fuji Protocol 
6. The FujiERC1155.burnBatch function implementation is incorrect Severity: High DiÔ¨Éculty: Low Type: Data Validation Finding ID: TOB-FUJI-006 Target: FujiERC1155.sol Description The FujiERC1155 contract‚Äôs burnBatch function deducts the unscaled amount from the user's balance and from the total supply of an asset. If the liquidity index of an asset (index[assetId]) is diÔ¨Äerent from its initialized value, the execution of burnBatch could result in unintended arithmetic calculations. Instead of deducting the amount value, the function should deduct the amountScaled value. function burnBatch( address _account, uint256[] memory _ids, uint256[] memory _amounts ) external onlyPermit { require(_account != address(0), Errors.VL_ZERO_ADDR_1155); require(_ids.length == _amounts.length, Errors.VL_INPUT_ERROR); address operator = _msgSender(); uint256 accountBalance; uint256 assetTotalBalance; uint256 amountScaled; for (uint256 i = 0; i < _ids.length; i++) { uint256 amount = _amounts[i]; accountBalance = _balances[_ids[i]][_account]; assetTotalBalance = _totalSupply[_ids[i]]; amountScaled = _amounts[i].rayDiv(indexes[_ids[i]]); require(amountScaled != 0 && accountBalance >= amountScaled, Errors.VL_INVALID_BURN_AMOUNT); _balances[_ids[i]][_account] = accountBalance - amount; _totalSupply[_ids[i]] = assetTotalBalance - amount; } emit TransferBatch(operator, _account, address(0), _ids, _amounts); } Figure 6.1: FujiERC1155.sol#L218-247 24 Fuji Protocol Exploit Scenario The burnBatch function is called with an asset for which the liquidity index is diÔ¨Äerent from its initialized value. Because amount was used instead of amountScaled, unexpected behavior occurs. Recommendations Short term, revise the burnBatch function so that it uses amountScaled instead of amount when updating a user‚Äôs balance and the total supply of an asset. Long term, use the burn function in the burnBatch function to keep functionality consistent. 25 Fuji Protocol 
7. Error in the white paper‚Äôs equation for the cost of reÔ¨Ånancing Severity: Informational DiÔ¨Éculty: Undetermined Type: Arithmetic Finding ID: TOB-FUJI-007 Target: White paper Description The white paper uses the following equation (equation 4) to describe how the cost of reÔ¨Ånancing is calculated: ùëÖ ùëáùë• ùëêùëúùë†ùë° = ùëîùëéùë† + ùê∫ ùëùùëüùëñùëêùëí + ùê∏ùëáùêª ùëùùëüùëñùëêùëí + ùêµ ùëëùëíùëèùë° + ùêπùêø ùëìùëíùëí ùêµ ùëëùëíùëèùë° is the amount of debt to be reÔ¨Ånanced and is a summand of the equation. This is incorrect, as it implies that the reÔ¨Ånancing cost is always greater than the amount of debt to be reÔ¨Ånanced. A correct version of the equation could be ùëÖ ùêπùêø is an amount, or ùëÖ ùëìùëíùëí ùëáùë• ùëêùëúùë†ùë° = ùëîùëéùë† + ùê∫ ùëùùëüùëñùëêùëí ùëáùë• + ùê∫ + ùê∏ùëáùêª + ùêπùêø ùëêùëúùë†ùë° = + ùê∏ùëáùêª ùëîùëéùë† + ùêµ ùëùùëüùëñùëêùëí * ùêπùêø ùëùùëüùëñùëêùëí ùëëùëíùëèùë° ùëìùëíùëí ùëùùëüùëñùëêùëí , in which ùêπùêø is a ùëìùëíùëí , in which ùëìùëíùëí percentage. Recommendations Short term, Ô¨Åx equation 4 in the white paper. Long term, ensure that the equations in the white paper are correct and in sync with the implementation. 26 Fuji Protocol 
8. Errors in the white paper‚Äôs equation for index calculation Severity: Medium DiÔ¨Éculty: Undetermined Type: Arithmetic Finding ID: TOB-FUJI-008 Target: White paper Description The white paper uses the following equation (equation 1) to describe how the index for a given token at timestamp is calculated: ùë° ùêº ùë° = ùêº ùë°‚àí1 + (ùêµ ùë°‚àí1 )/ùêµ ‚àí ùêµ ùë° ùë°‚àí1 ùêµ is the amount of the given token that the Fuji Protocol owes the provider (the borrowing ùë° protocol) at timestamp .ùë° The index is updated only when the balance changes through the accrual of interest, not when the balance changes through borrowing or repayment operations. This means that ùêµ ‚àí ùêµ is always negative, which is incorrect, as ùë° should calculate the )/ùêµ ‚àí ùêµ ùë° (ùêµ ùë°‚àí1 ùë°‚àí1 ùë°‚àí1 interest rate since the last index update. * ùëü 3 * ùëü 2 * ... * ùëü . A user's current balance is computed by taking the user‚Äôs initial stored ùëõ The index represents the total interest rate since the deployment of the protocol. It is the product of the various interest rates accrued on the active providers during the lifetime of the protocol (measured only during state-changing interactions with the provider): ùëü 1 balance, multiplying it by the current index, and dividing it by the index at the time of the creation of that user's position. The division operation ensures that the user will not owe interest that accrued before the creation of the user‚Äôs position. The index provides an eÔ¨Écient way to keep track of interest rates without having to update each user's balance separately, which would be prohibitively expensive on Ethereum. However, interest is compounded through multiplication, not addition. The formula should use the product sign instead of the plus sign. 27 Fuji Protocol Exploit Scenario Alice decides to use the Fuji Protocol after reading the white paper. She later learns that calculations in the white paper do not match the implementations in the protocol. Because Alice allocated her funds based on her understanding of the speciÔ¨Åcation, she loses funds. Recommendations Short term, replace equation 1 in the white paper with a correct and simpliÔ¨Åed version. For more information on the simpliÔ¨Åed version, see Ô¨Ånding TOB-FUJI-015. ùêº ùë° = ùêº ùë°‚àí1 /ùêµ * ùêµ ùë° ùë°‚àí1 Long term, ensure that the equations in the white paper are correct and in sync with the implementation. 28 Fuji Protocol 
9. FujiERC1155.setURI does not adhere to the EIP-1155 speciÔ¨Åcation Severity: Informational DiÔ¨Éculty: Undetermined Type: Auditing and Logging Finding ID: TOB-FUJI-009 Target: FujiERC1155.sol Description The FujiERC1155 contract‚Äôs setURI function does not emit the URI event. /** * @dev Sets a new URI for all token types, by relying on the token type ID */ function setURI(string memory _newUri) public onlyOwner { _uri = _newUri; } Figure 9.1: FujiERC1155.sol#L266-268 This behavior does not adhere to the EIP-1155 speciÔ¨Åcation, which states the following: Changes to the URI MUST emit the URI event if the change can be expressed with an event (i.e. it isn‚Äôt dynamic/programmatic). Figure 9.2: A snippet of the EIP-1155 speciÔ¨Åcation Recommendations Short term, revise the setURI function so that it emits the URI event. Long term, review the EIP-1155 speciÔ¨Åcation to verify that the contracts adhere to the standard. References ‚óè EIP-1155 29 Fuji Protocol 
10. Partial reÔ¨Ånancing operations can break the protocol Severity: Medium DiÔ¨Éculty: Medium Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-010 Target: FujiVault.sol, Controller.sol, white paper Description The white paper documents the Controller contract‚Äôs ability to perform partial reÔ¨Ånancing operations. These operations move only a fraction of debt and collateral from one provider to another to prevent unproÔ¨Åtable interest rate slippage. However, the protocol does not correctly support partial reÔ¨Ånancing situations in which debt and collateral are spread across multiple providers. For example, payback and withdrawal operations always interact with the current provider, which might not contain enough funds to execute these operations. Additionally, the interest rate indexes are computed only from the debt owed to the current provider, which might not accurately reÔ¨Çect the interest rate across all providers. Exploit Scenario An executor performs a partial reÔ¨Ånancing operation. Interest rates are computed incorrectly, resulting in a loss of funds for either the users or the protocol. Recommendations Short term, disable partial reÔ¨Ånancing until the protocol supports it in all situations. Long term, ensure that functionality that is not fully supported by the protocol cannot be used by accident. 30 Fuji Protocol 
11. Native support for ether increases the codebase‚Äôs complexity Severity: Informational DiÔ¨Éculty: Undetermined Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-011 Target: Throughout Description The protocol supports ERC20 tokens and Ethereum‚Äôs native currency, ether. Ether transfers follow diÔ¨Äerent semantics than token transfers. As a result, many functions contain extra code, like the code shown in Ô¨Ågure 11.1, to handle ether transfers. if (vAssets.borrowAsset == ETH) { require(msg.value >= amountToPayback, Errors.VL_AMOUNT_ERROR); if (msg.value > amountToPayback) { IERC20Upgradeable(vAssets.borrowAsset).univTransfer( payable(msg.sender), msg.value - amountToPayback ); } } else { // Check User Allowance require( IERC20Upgradeable(vAssets.borrowAsset).allowance(msg.sender, address(this)) >= amountToPayback, Errors.VL_MISSING_ERC20_ALLOWANCE ); Figure 11.1: FujiVault.sol#L319-333 This extra code increases the codebase‚Äôs complexity. Furthermore, functions will behave diÔ¨Äerently depending on their arguments. Recommendations Short term, replace native support for ether with support for ERC20 WETH. This will decrease the complexity of the protocol and the likelihood of bugs. 31 Fuji Protocol 
12. Missing events for critical operations Severity: Low DiÔ¨Éculty: Low Type: Auditing and Logging Finding ID: TOB-FUJI-012 Target: Throughout Description Many functions that make important state changes do not emit events. These functions include, but are not limited to, the following: ‚óè All setters in the FujiAdmin contract ‚óè The setFujiAdmin, setFujiERC1155, setFactor, setOracle, and setProviders functions in the FujiVault contract ‚óè The setMapping and setURI functions in the FujiMapping contract ‚óè The setFujiAdmin and setExecutors functions in the Controller contract ‚óè The setURI and setPermit functions in the FujiERC1155 contract ‚óè The setPriceFeed function in the FujiOracle contract Exploit scenario An attacker gains permission to execute an operation that changes critical protocol parameters. She executes the operation, which does not emit an event. Neither the Fuji Protocol team nor the users are notiÔ¨Åed about the parameter change. The attacker uses the changed parameter to steal funds. Later, the attack is detected due to the missing funds, but it is too late to react and mitigate the attack. Recommendations Short term, ensure that all state-changing operations emit events. Long term, use an event monitoring system like Tenderly or Defender, use Defender‚Äôs automated incident response feature, and develop an incident response plan to follow in case of an emergency. 32 Fuji Protocol 
13. Indexes are not updated before all operations that require up-to-date indexes Severity: High DiÔ¨Éculty: Low Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-013 Target: FujiVault.sol, FujiERC1155.sol, FLiquidator.sol Description The FujiERC1155 contract uses indexes to keep track of interest rates. Refer to Appendix F for more detail on the index calculation. The FujiVault contract‚Äôs updateF1155Balances function is responsible for updating indexes. However, this function is not called before all operations that read indexes. As a result, these operations use outdated indexes, which results in incorrect accounting and could make the protocol vulnerable to exploits. FujiVault.deposit calls FujiERC1155._mint, which reads indexes but does not call updateF1155Balances. FujiVault.paybackLiq calls FujiERC1155.balanceOf, which reads indexes but does not call updateF1155Balances. Exploit Scenario The indexes have not been updated in one day. User Bob deposits collateral into the FujiVault. Day-old indexes are used to compute Bob‚Äôs scaled amount, causing Bob to gain interest for an additional day for free. Recommendations Short term, ensure that all operations that require up-to-date indexes Ô¨Årst call updateF1155Balances. Write tests for each function that depends on up-to-date indexes with assertions that fail if indexes are outdated. Long term, redesign the way indexes are accessed and updated such that a developer cannot simply forget to call updateF1155Balances. 33 Fuji Protocol 
14. No protection against missing index updates before operations that depend on up-to-date indexes Severity: Informational DiÔ¨Éculty: Low Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-014 Target: FujiVault.sol, FujiERC1155.sol, FLiquidator.sol Description The FujiERC1155 contract uses indexes to keep track of interest rates. Refer to Appendix F for more detail on the index calculation. The FujiVault contract‚Äôs updateF1155Balances function is responsible for updating indexes. This function must be called before all operations that read indexes (TOB-FUJI-013). However, the protocol does not protect against situations in which indexes are not updated before they are read; these situations could result in incorrect accounting. Exploit Scenario Developer Bob adds a new operation that reads indexes, but he forgets to add a call to updateF1155Balances. As a result, the new operation uses outdated index values, which causes incorrect accounting. Recommendations Short term, redesign the index calculations so that they provide protection against the reading of outdated indexes. For example, the index calculation process could keep track of the last index update‚Äôs block number and access indexes exclusively through a getter, which updates the index automatically, if it has not already been updated for the current block. Since ERC-1155‚Äôs balanceOf and totalSupply functions do not allow side eÔ¨Äects, this solution would require the use of diÔ¨Äerent functions internally. Long term, use defensive coding practices to ensure that critical operations are always executed when required. 34 Fuji Protocol 
15. Formula for index calculation is unnecessarily complex Severity: Informational DiÔ¨Éculty: Undetermined Type: Arithmetic Finding ID: TOB-FUJI-015 Target: FujiERC1155.sol Description Indexes are updated within the FujiERC1155 contract‚Äôs updateState function, shown in Ô¨Ågure 15.1. Refer to Appendix F for more detail on the index calculation. function updateState(uint256 _assetID, uint256 newBalance) external override onlyPermit { uint256 total = totalSupply(_assetID); if (newBalance > 0 && total > 0 && newBalance > total) { uint256 diff = newBalance - total; uint256 amountToIndexRatio = (diff.wadToRay()).rayDiv(total.wadToRay()); uint256 result = amountToIndexRatio + WadRayMath.ray(); result = result.rayMul(indexes[_assetID]); require(result <= type(uint128).max, Errors.VL_INDEX_OVERFLOW); indexes[_assetID] = uint128(result); // TODO: calculate interest rate for a fujiOptimizer Fee. } } Figure 15.1: FujiERC1155.sol#L40-57 The code in Ô¨Ågure 14.1 translates to the following equation: = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 * (1 + (ùëèùëéùëôùëéùëõùëêùëí ùë° ‚àí ùëèùëéùëôùëéùëõùëêùëí )/ùëèùëéùëôùëéùëõùëêùëí ùë°‚àí1 ) ùë°‚àí1 Using the distributive property, we can transform this equation into the following: = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 /ùëèùëéùëôùëéùëõùëêùëí * (1 + ùëèùëéùëôùëéùëõùëêùëí ùë° ùë°‚àí1 This version can then be simpliÔ¨Åed: ‚àí ùëèùëéùëôùëéùëõùëêùëí /ùëèùëéùëôùëéùëõùëêùëí ùë°‚àí1 ) ùë°‚àí1 = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 /ùëèùëéùëôùëéùëõùëêùëí * (1 + ùëèùëéùëôùëéùëõùëêùëí ùë° ùë°‚àí1 ‚àí 1) 35 Fuji Protocol Finally, we can simplify the equation even further: = ùëñùëõùëëùëíùë• ùëñùëõùëëùëíùë• ùë° ùë°‚àí1 /ùëèùëéùëôùëéùëõùëêùëí * ùëèùëéùëôùëéùëõùëêùëí ùë° ùë°‚àí1 The resulting equation is simpler and more intuitively conveys the underlying idea‚Äîthat the index grows by the same ratio as the balance grew since the last index update. Recommendations Short term, use the simpler index calculation formula in the updateState function of the Fuji1155Contract. This will result in code that is more intuitive and that executes using slightly less gas. Long term, use simpler versions of the equations used by the protocol to make the arithmetic easier to understand and implement correctly. 36 Fuji Protocol 
16. Flasher‚Äôs initiateFlashloan function does not revert on invalid Ô¨Çashnum values Severity: Low DiÔ¨Éculty: High Type: Data Validation Finding ID: TOB-FUJI-016 Target: Flasher.sol Description The Flasher contract‚Äôs initiateFlashloan function does not initiate a Ô¨Çash loan or perform a reÔ¨Ånancing operation if the flashnum parameter is set to a value greater than 2. However, the function does not revert on invalid flashnum values. function initiateFlashloan(FlashLoan.Info calldata info, uint8 _flashnum) external isAuthorized { if (_flashnum == 0) { _initiateAaveFlashLoan(info); } else if (_flashnum == 1) { _initiateDyDxFlashLoan(info); } else if (_flashnum == 2) { _initiateCreamFlashLoan(info); } } Figure 16.1: Flasher.sol#L61-69 Exploit Scenario Alice, an executor of the Fuji Protocol, calls Controller. doRefinancing with the flashnum parameter set to 3. As a result, no Ô¨Çash loan is initialized, and no reÔ¨Ånancing happens; only the active provider is changed. This results in unexpected behavior. For example, if a user wants to repay his debt after reÔ¨Ånancing, the operation will fail, as no debt is owed to the active provider. Recommendations Short term, revise initiateFlashloan so that it reverts when it is called with an invalid flashnum value. Long term, ensure that all functions revert if they are called with invalid values. 37 Fuji Protocol 
17. Docstrings do not reÔ¨Çect functions‚Äô implementations Severity: Low DiÔ¨Éculty: Undetermined Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-017 Target: FujiVault.sol Description The docstring of the FujiVault contract‚Äôs withdraw function states the following: * @param _withdrawAmount: amount of collateral to withdraw * otherwise pass -1 to withdraw maximum amount possible of collateral (including safety factors) Figure 17.1: FujiVault.sol#L188-189 However, the maximum amount is withdrawn on any negative value, not only on a value of -1. A similar inconsistency between the docstring and the implementation exists in the FujiVault contract‚Äôs payback function. Recommendations Short term, adjust the withdraw and payback functions‚Äô docstrings or their implementations to make them match. Long term, ensure that docstrings always match the corresponding function‚Äôs implementation. 38 Fuji Protocol 
18. Harvester‚Äôs getHarvestTransaction function does not revert on invalid _farmProtocolNum and harvestType values Severity: Low DiÔ¨Éculty: Medium Type: Data Validation Finding ID: TOB-FUJI-018 Target: Harvester.sol Description The Harvester contract‚Äôs getHarvestTransaction function incorrectly returns claimedToken and transaction values of 0 if the _farmProtocolNum parameter is set to a value greater than 1 or if the harvestType value is set to value greater than 2. However, the function does not revert on invalid _farmProtocolNum and harvestType values. function getHarvestTransaction(uint256 _farmProtocolNum, bytes memory _data) external view override returns (address claimedToken, Transaction memory transaction) { if (_farmProtocolNum == 0) { transaction.to = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B; transaction.data = abi.encodeWithSelector( bytes4(keccak256("claimComp(address)")), msg.sender ); claimedToken = 0xc00e94Cb662C3520282E6f5717214004A7f26888; } else if (_farmProtocolNum == 1) { uint256 harvestType = abi.decode(_data, (uint256)); if (harvestType == 0) { // claim (, address[] memory assets) = abi.decode(_data, (uint256, address[])); transaction.to = 0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5; transaction.data = abi.encodeWithSelector( bytes4(keccak256("claimRewards(address[],uint256,address)")), assets, type(uint256).max, msg.sender ); } else if (harvestType == 1) { // transaction.to = 0x4da27a545c0c5B758a6BA100e3a049001de870f5; transaction.data = abi.encodeWithSelector(bytes4(keccak256("cooldown()"))); } else if (harvestType == 2) { // transaction.to = 0x4da27a545c0c5B758a6BA100e3a049001de870f5; 39 Fuji Protocol transaction.data = abi.encodeWithSelector( bytes4(keccak256("redeem(address,uint256)")), msg.sender, type(uint256).max ); claimedToken = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9; } } } Figure 18.1: Harvester.sol#L13-54 Exploit Scenario Alice, an executor of the Fuji Protocol, calls getHarvestTransaction with the _farmProtocolNum parameter set to 2. As a result, rather than reverting, the function returns claimedToken and transaction values of 0. Recommendations Short term, revise getHarvestTransaction so that it reverts if it is called with invalid farmProtocolNum or harvestType values. Long term, ensure that all functions revert if they are called with invalid values. 40 Fuji Protocol 
19. Lack of data validation in Controller‚Äôs doReÔ¨Ånancing function Severity: Low DiÔ¨Éculty: High Type: Data Validation Finding ID: TOB-FUJI-019 Target: Controller.sol Description The Controller contract‚Äôs doRefinancing function does not check the _newProvider value. Therefore, the function accepts invalid values for the _newProvider parameter. function doRefinancing( address _vaultAddr, address _newProvider, uint256 _ratioA, uint256 _ratioB, uint8 _flashNum ) external isValidVault(_vaultAddr) onlyOwnerOrExecutor { IVault vault = IVault(_vaultAddr); [...] [...] IVault(_vaultAddr).setActiveProvider(_newProvider); } Figure 19.1: Controller.sol#L44-84 Exploit Scenario Alice, an executor of the Fuji Protocol, calls Controller.doRefinancing with the _newProvider parameter set to the same address as the active provider. As a result, unnecessary Ô¨Çash loan fees will be paid. Recommendations Short term, revise the doRefinancing function so that it reverts if _newProvider is set to the same address as the active provider. Long term, ensure that all functions revert if they are called with invalid values. 41 Fuji Protocol 
20. Lack of data validation on function parameters Severity: Low DiÔ¨Éculty: Low Type: Data Validation Finding ID: TOB-FUJI-020 Target: Throughout Description Certain setter functions fail to validate the addresses they receive as input. The following addresses are not validated: ‚óè The addresses passed to all setters in the FujiAdmin contract ‚óè The _newFujiAdmin address in the setFujiAdmin function in the Controller and FujiVault contracts ‚óè The _provider address in the FujiVault.setActiveProvider function ‚óè The _oracle address in the FujiVault.setOracle function ‚óè The _providers addresses in the FujiVault.setProviders function ‚óè The newOwner address in the transferOwnership function in the Claimable and ClaimableUpgradeable contracts Exploit scenario Alice, a member of the Fuji Protocol team, invokes the FujiVault.setOracle function and sets the oracle address as address(0). As a result, code relying on the oracle address is no longer functional. Recommendations Short term, add zero-value or contract existence checks to the functions listed above to ensure that users cannot accidentally set incorrect values, misconÔ¨Åguring the protocol. Long term, use Slither, which will catch missing zero checks. 42 Fuji Protocol 
21. Solidity compiler optimizations can be problematic Severity: Informational DiÔ¨Éculty: High Type: UndeÔ¨Åned Behavior Finding ID: TOB-FUJI-021 Target: hardhat-config.js Description Fuji Protocol has enabled optional compiler optimizations in Solidity. There have been several optimization bugs with security implications. Moreover, optimizations are actively being developed. Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them. Therefore, it is unclear how well they are being tested and exercised. High-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten-generated solc-js compiler used by TruÔ¨Ñe and Remix persisted until late 2018. The Ô¨Åx for this bug was not reported in the Solidity CHANGELOG. Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. More recently, another bug due to the incorrect caching of keccak256 was reported. A compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe. It is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations. Exploit Scenario A latent or future bug in Solidity compiler optimizations‚Äîor in the Emscripten transpilation to solc-js‚Äîcauses a security vulnerability in the Fuji Protocol contracts. Recommendations Short term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug. Long term, monitor the development and adoption of Solidity compiler optimizations to assess their maturity. 43 Fuji Protocol A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diÔ¨Éculty levels used in this document. Vulnerability Categories Category Description Access Controls InsuÔ¨Écient authorization of users or assessment of rights Auditing and Logging InsuÔ¨Écient auditing of actions or logging of problems Authentication Improper identiÔ¨Åcation of users ConÔ¨Åguration MisconÔ¨Ågured servers, devices, or software components Cryptography Breach of the conÔ¨Ådentiality or integrity of data Data Exposure Exposure of sensitive information Data Validation Improper reliance on the structure or values of data Denial of Service System failure with an availability impact Error Reporting Insecure or insuÔ¨Écient reporting of error conditions Patching Outdated software package or library Session Management Improper identiÔ¨Åcation of authenticated users Testing Timing InsuÔ¨Écient test methodology or test coverage Race conditions, locking, or other order-of-operations Ô¨Çaws UndeÔ¨Åned Behavior UndeÔ¨Åned behavior triggered within the system 44 Fuji Protocol Severity Levels Severity Description Informational The issue does not pose an immediate risk but is relevant to security best practices or defense in depth. Undetermined The extent of the risk was not determined during this engagement. Low Medium High The risk is relatively small or is not a risk the client has indicated is important. Individual users‚Äô information is at risk; exploitation could pose reputational, legal, or moderate Ô¨Ånancial risks to the client. The issue could aÔ¨Äect numerous users and have serious reputational, legal, or Ô¨Ånancial implications for the client. DiÔ¨Éculty Levels DiÔ¨Éculty Description Undetermined The diÔ¨Éculty of exploitation was not determined during this engagement. Low Medium High The Ô¨Çaw is commonly exploited; public tools for its exploitation exist or can be scripted. An attacker must write an exploit or will need in-depth knowledge of a complex system. An attacker must have privileged insider access to the system, may need to know extremely complex technical details, or must discover other weaknesses to exploit this issue. 45 Fuji Protocol B. Code Maturity Categories The following tables describe the code maturity categories and rating criteria used in this document. Code Maturity Categories Categories Description Access Controls The authentication and authorization of components Arithmetic The proper use of mathematical operations and semantics Assembly Use The use of inline assembly Centralization The existence of a single point of failure Upgradeability Contract upgradeability Function Composition The separation of the logic into functions with clear purposes Front-Running Resistance to front-running Key Management The existence of proper procedures for key generation, distribution, and access Monitoring The use of events and monitoring procedures SpeciÔ¨Åcation The comprehensiveness and readability of codebase documentation and speciÔ¨Åcation Testing and VeriÔ¨Åcation The use of testing techniques (e.g., unit tests and fuzzing) 46 Fuji Protocol Rating Criteria Rating Strong Description The control was robust, documented, automated, and comprehensive. Satisfactory With a few minor exceptions, the control was applied consistently. Moderate The control was applied inconsistently in certain areas. Weak The control was applied inconsistently or not at all. Missing The control was missing. Not Applicable The control is not applicable. Not Considered The control was not reviewed. Further Investigation Required The control requires further investigation. 47 Fuji Protocol C. Token Integration Checklist The following checklist provides recommendations for interactions with arbitrary tokens. Every unchecked item should be justiÔ¨Åed, and its associated risks, understood. Refer to an up-to-date version of the checklist on crytic/building-secure-contracts. For convenience, all Slither utilities can be run directly on a token address, such as the following: slither-check-erc 0xdac17f958d2ee523a2206206994597c13d831ec7 TetherToken To follow this checklist, use the below output from Slither for the token: - slither-check-erc [target] [contractName] [optional: --erc ERC_NUMBER] - slither [target] --print human-summary - slither [target] --print contract-summary - slither-prop . --contract ContractName # requires configuration, and use of Echidna and Manticore General Security Considerations ‚ùè The contract has a security review. Avoid interacting with contracts that lack a security review. Check the length of the assessment (i.e., the level of eÔ¨Äort), the reputation of the security Ô¨Årm, and the number and severity of the Ô¨Åndings. ‚ùè You have contacted the developers. You may need to alert their team to an incident. Look for appropriate contacts on blockchain-security-contacts. ‚ùè They have a security mailing list for critical announcements. Their team should advise users (like you!) when critical issues are found or when upgrades occur. ERC Conformity Slither includes a utility, slither-check-erc, that reviews the conformance of a token to many related ERC standards. Use slither-check-erc to review the following: ‚ùè Transfer and transferFrom return a boolean. Several tokens do not return a boolean on these functions. As a result, their calls in the contract might fail. ‚ùè The name, decimals, and symbol functions are present if used. These functions are optional in the ERC20 standard and may not be present. 48 Fuji Protocol ‚ùè Decimals returns a uint8. Several tokens incorrectly return a uint256. In such cases, ensure that the value returned is below 255. ‚ùè The token mitigates the known ERC20 race condition. The ERC20 standard has a known ERC20 race condition that must be mitigated to prevent attackers from stealing tokens. ‚ùè The token is not an ERC777 token and has no external function call in transfer or transferFrom. External calls in the transfer functions can lead to reentrancies. Slither includes a utility, slither-prop, that generates unit tests and security properties that can discover many common ERC Ô¨Çaws. Use slither-prop to review the following: ‚ùè The contract passes all unit tests and security properties from slither-prop. Run the generated unit tests and then check the properties with Echidna and Manticore. Finally, there are certain characteristics that are diÔ¨Écult to identify automatically. Conduct a manual review of the following conditions: ‚ùè Transfer and transferFrom should not take a fee. DeÔ¨Çationary tokens can lead to unexpected behavior. ‚ùè Potential interest earned from the token is taken into account. Some tokens distribute interest to token holders. This interest may be trapped in the contract if not taken into account. Contract Composition ‚ùè The contract avoids unnecessary complexity. The token should be a simple contract; a token with complex code requires a higher standard of review. Use Slither‚Äôs human-summary printer to identify complex code. ‚ùè The contract uses SafeMath. Contracts that do not use SafeMath require a higher standard of review. Inspect the contract by hand for SafeMath usage. ‚ùè The contract has only a few non-token-related functions. Non-token-related functions increase the likelihood of an issue in the contract. Use Slither‚Äôs contract-summary printer to broadly review the code used in the contract. ‚ùè The token has only one address. Tokens with multiple entry points for balance updates can break internal bookkeeping based on the address (e.g., balances[token_address][msg.sender] may not reÔ¨Çect the actual balance). 49 Fuji Protocol Owner Privileges ‚ùè The token is not upgradeable. Upgradeable contracts may change their rules over time. Use Slither‚Äôs human-summary printer to determine if the contract is upgradeable. ‚ùè The owner has limited minting capabilities. Malicious or compromised owners can abuse minting capabilities. Use Slither‚Äôs human-summary printer to review minting capabilities, and consider manually reviewing the code. ‚ùè The token is not pausable. Malicious or compromised owners can trap contracts relying on pausable tokens. Identify pausable code by hand. ‚ùè The owner cannot blacklist the contract. Malicious or compromised owners can trap contracts relying on tokens with a blacklist. Identify blacklisting features by hand. ‚ùè The team behind the token is known and can be held responsible for abuse. Contracts with anonymous development teams or teams that reside in legal shelters require a higher standard of review. Token Scarcity Reviews of token scarcity issues must be executed manually. Check for the following conditions: ‚ùè The supply is owned by more than a few users. If a few users own most of the tokens, they can inÔ¨Çuence operations based on the tokens‚Äô repartition. ‚ùè The total supply is suÔ¨Écient. Tokens with a low total supply can be easily manipulated. ‚ùè The tokens are located in more than a few exchanges. If all the tokens are in one exchange, a compromise of the exchange could compromise the contract relying on the token. ‚ùè Users understand the risks associated with a large amount of funds or Ô¨Çash loans. Contracts relying on the token balance must account for attackers with a large amount of funds or attacks executed through Ô¨Çash loans. ‚ùè The token does not allow Ô¨Çash minting. Flash minting can lead to substantial swings in the balance and the total supply, which necessitate strict and comprehensive overÔ¨Çow checks in the operation of the token. 50 Fuji Protocol E. Code Quality Recommendations The following recommendations are not associated with speciÔ¨Åc vulnerabilities. However, they enhance code readability and may prevent the introduction of vulnerabilities in the future. General Recommendations ‚óè Consider merging FujiVault, VaultBaseUpgradeable, and VaultControlUpgradeable. These separate contracts are unnecessary and make auditing more diÔ¨Écult. ‚óè Consider removing unused imports from the DyDxFlashLoans, FujiERC115, Harvester, and Swapper contracts. Flasher ‚óè Consider replacing the magic numbers for the flashnum parameter of the initiateFlashloan function with enums. FujiVault ‚óè The fee calculation implemented by _userProtocolFee is repeated inline in the borrow function (line 275). Consider calling _userProtocolFee instead of borrow. ‚óè Consider renaming the _fujiadmin parameter of the initialize function to __fujiAdmin. To prevent shadowing, do not use entirely lowercase names. ‚óè Consider renaming the Factor struct to Ratio, its Ô¨Åeld a to numerator, and its Ô¨Åeld b to denominator; these labels are more self-explanatory. ‚óè Consider changing the type of fujiERC1155 from address to IFujiERC1155; this will reduce boilerplate casts, which decrease readability. ‚óè Both the if and else branch of the deposit function revert if _collateralAmount == 0. Consider moving that check to before the if statement. ‚óè Consider renaming updateF1155Balances to updateF1155Indexes, which more accurately describes what the function does. FujiBaseERC1155 ‚óè Consider removing the unused _beforeTokenTransfer and _asSingletonArray functions. FujiERC1155 51 Fuji Protocol ‚óè Consider renaming the contract to F1155, which is the name used in the white paper. ‚óè Consider renaming updateState to updateIndex, which more accurately describes what the function does. FLiquidator ‚óè Consider renaming the state variable IUniswapV2Router02 public swapper, as it has the same name as the Swapper contract but represents something diÔ¨Äerent. Controller ‚óè Consider renaming the contract to Refinancer or RefinancingController to emphasize that this contract is responsible for reÔ¨Ånancing. DyDxFlashLoans ‚óè Consider renaming the DyDxFlashLoans.sol Ô¨Ålename to avoid inconsistency with the DyDxFlashloanBase contract. 52 Fuji Protocol F. Index Construction for Interest Calculation The Fuji Protocol takes out loans from borrowing protocols like Aave and Compound. As these loans accrue interest over time, debt increases as time progresses. If a user takes out a loan from the Fuji Protocol, she will later have to repay more than the initial value of the loan due to the interest that has accumulated. The exact value she will have to repay is determined by the Ô¨Çoating interest rate of the active borrowing protocol during the time between the borrowing and repayment operations. The interest rate is not Ô¨Åxed but changes based on the supply and demand of the active borrowing protocol‚Äôs assets. Therefore, the interest rate can be diÔ¨Äerent for each block. A naive strategy for handling variable interest rates would be to measure the interest rate on each block and adjust each user's debt accordingly. However, this strategy would require one transaction per block, and the gas costs would scale linearly with the number of users. The resulting gas requirements and costs make this solution impractical on Ethereum. Rather than updating user debt balances on each block, the Fuji Protocol updates them before any operation that depends on up-to-date user debt balances. The interest rate atùëü ùë° time is calculated using the growth between the previous debt balance and the current ùë° debt balance owed to the active borrowing protocol: ùëü ùë° /ùëè = ùëè ùë° ùë°‚àí1 . The Fuji internal debt balance ùëë ùë° of the user is then adjusted by the interest rate: ùëë ùë° = ùëë ùë°‚àí1 * ùëü ùë° . However, each user‚Äôs debt must still be updated individually, resulting in gas requirements that scale with the number of users. The active borrowing protocol gives the same interest to all borrowers at any given point in time. As a result, the interest rate ùëü ùë° is identical for all loans. Therefore, ùëü ùë° = (ùëè ùë° ‚àí ùëè )/ùëè ùë°‚àí1 ùë°‚àí1 = (ùêµ ùë° ‚àí ùêµ )/ùêµ ùë°‚àí1 ùë°‚àí1 , where is an individual user‚Äôs ùëè debt, and is the total debt that the Fuji Protocol owes to the active borrowing protocol. ùêµ From this, it follows that instead of updating each user‚Äôs balance, one can calculate the product of all interest rates ùëü in an index that represents the interest rate of a loan that was ùë° borrowed at the beginning of the protocol‚Äôs lifetime: ùêº ùë° = 1 * ùëü 1 * ùëü 2 * ùëü 3 *... * ùëü . One can ùë° then multiply a user‚Äôs initial debt balance ùëë by to obtain the user‚Äôs current debt balance: 0 ùêº ùë° ùëë ùë° = ùêº ùë° * ùëë . The index starts at 0 ùêº ùë° ùêº 0 = 1 . As a result, a user‚Äôs initial debt balance is multiplied 53 Fuji Protocol by the interest rate only when a user‚Äôs debt balance is requested, not when the interest rate is updated; this process can be implemented much more eÔ¨Éciently on Ethereum. Not all users take out their loans at the beginning of the lifetime of the protocol. If a user takes out her loan at timestamp ùë§! = 0 , then the calculation ùëë ùë° = ùêº ùë° * ùëë ùë§ is incorrect, as it gives the user the interest accumulated before the time she took out the loan. To adjust for this issue, a snapshot of the index at the time the loan was taken out, ùêº ùë§ , is remembered, and the user‚Äôs debt balance is divided by = 1 * ùëü 1 *... * ùëü * ùëü 2 ùë§‚àí1 ùêº ùë§ to divide out the interest rate before the loan is taken out: ùêº ùë° = 1 * ùëü 1 * ùëü 2 * ... * ùëü ùë§‚àí1 * ùëü ùë§ * ùëü ùë§+1 * ùëü ùë§+2 *... * ùëü ùë° ‚áî ùëü ùë§ * ùëü ùë§+1 * ùëü ùë§+2 *... * ùëü ùë° /(1 * ùëü = ùêº 1 ùë° * ùëü 2 *... * ùëü ) ùë§‚àí1 The following is the resulting formula for calculating any user‚Äôs current debt balance: ùëë ùë° = ùëë ùë§ /ùêº * ùêº ùë° ùë§ 54 Fuji Protocol G. Handling Key Material The safety of key material is important in any system, but particularly so in Ethereum; keys dictate access to money and resources. Theft of keys could mean a complete loss of funds or trust in the market. The current conÔ¨Åguration uses an environment variable in production to relay key material to applications that use these keys to interact with on-chain components. However, attackers with local access to the machine may be able to extract these environment variables and steal key material, even without privileged positions. Therefore, we recommend the following: ‚óè Move key material from environment variables to a dedicated secret management system with trusted computing capabilities. The two best options for this are Google Cloud Key Management System (GCKMS) and Hashicorp Vault with hardware security module (HSM) backing. ‚óè Restrict access to GCKMS or Hashicorp Vault to only those applications and administrators that must have access to the credential store. ‚óè Local key material, such as keys used by fund administrators, may be stored in local HSMs, such as YubiHSM2. ‚óè Limit the number of staÔ¨Ä members and applications with access to this machine. ‚óè Segment the machine away from all other hosts on the network. ‚óè Ensure strict host logging, patching, and auditing policies are in place for any machine or application that handles said material. ‚óè Determine the business risk of a lost or stolen key, and determine the disaster recovery and business continuity (DR/BC) policies in the event of a stolen or lost key. 55 Fuji Protocol H. Fix Log On December 3, 2021, reviewed the Ô¨Åxes and mitigations implemented by the Fuji Protocol team for the issues identiÔ¨Åed in this report. The Fuji Protocol team Ô¨Åxed 13 of the issues reported in the original assessment, partially Ô¨Åxed 4, and acknowledged but did not Ô¨Åx the remaining 4. We reviewed each of the Ô¨Åxes to ensure that the proposed remediation would be eÔ¨Äective. The Ô¨Åx commits often contained additional changes not related to the Ô¨Åxes. We did not comprehensively review these changes. For additional information, please refer to the Detailed Fix Log. ID Title Severity Fix Status 1 2 3 4 5 6 7 8 9 Anyone can destroy the FujiVault logic contract if its initialize function was not called during deployment High Partially Fixed (f6858e8) Providers are implemented with delegatecall Informational Lack of contract existence check on delegatecall will result in unexpected behavior High FujiVault.setFactor is unnecessarily complex and does not properly handle invalid input Informational Preconditions speciÔ¨Åed in docstrings are not checked by functions Informational The FujiERC1155.burnBatch function implementation is incorrect High Error in the white paper‚Äôs equation for the cost of reÔ¨Ånancing Informational Errors in the white paper‚Äôs equation for index calculation Medium Risk accepted by the client Partially Ô¨Åxed (03a4aa0) Fixed (9e79d2e) Fixed (2efc1b4, 9e79d2e) Fixed (900f7d7) Fixed (33c8c8b) Fixed (33c8c8b) FujiERC1155.setURI does not adhere to the EIP-1155 speciÔ¨Åcation Informational Partially Ô¨Åxed (3477e6a) 56 Fuji Protocol 13 14 15 16 10 Partial reÔ¨Ånancing operations can break the protocol Medium Fixed (efa86b0) 11 Native support for ether increases the codebase‚Äôs complexity Informational Risk accepted by the client 12 Missing events for critical operations Indexes are not updated before all operations that require up-to-date indexes Low High Fixed (3477e6a) Partially Ô¨Åxed (d17cd77) No protection against missing index updates before operations that depend on up-to-date indexes Informational Risk accepted by the client Formula for index calculation is unnecessarily complex Informational Flasher‚Äôs initiateFlashloan function does not revert on invalid Ô¨Çashnum values Low 17 Docstrings do not reÔ¨Çect functions‚Äô implementations Low 18 19 Harvester‚Äôs getHarvestTransaction function does not revert on invalid _farmProtocolNum and harvestType values Low Lack of data validation in Controller‚Äôs doReÔ¨Ånancing function Low 20 Lack of data validation on function parameters Low Fixed (0cc7032) Fixed (3cc8b21) Fixed (9e79d2e) Fixed (794e5d7) Fixed (2efc1b4) Fixed (293d9aa, 2c96c16, 0d77944) 21 Solidity compiler optimizations can be problematic Informational Risk accepted by the client 57 Fuji Protocol Detailed Fix Log TOB-FUJI-001: Anyone can destroy the FujiVault logic contract if its initialize function was not called during deployment Partially Ô¨Åxed. The Fuji Protocol team modiÔ¨Åed the deployVault.js script to call initialize on the vault if it has not been called already. However, the team did not address the root cause of the issue: the dangerous call to delegatecall. (f6858e8) TOB-FUJI-002: Providers are implemented with delegatecall Risk accepted by the client. The Fuji Protocol team provided the following rationale for its acceptance of this risk: ‚ÄúThe team assumes the risk of maintaining the use of delegatecall; however, the rationale comes after some mitigations and an internal analysis with the following statements: ‚óè Debt positions are not transferable as deposit positions are. ‚óè As explained in the report, it is important that the context of the caller at the underlying lending-borrowing protocols is the FujiVault. Deposit receipt tokens can easily be transferred, however, debt positions cannot. Aave, has a credit delegation feature that could be used to maintain the desired context, but the remaining providers do not have it. To keep call methods universal for all providers it is preferred that all providers are called similarly and delegatecall facilitates this. ‚óè Mitigations to the risks of delegatecall: ‚óè _execute function was changed to private. It now can only be called by only the functions within VaultBaseUpgradeable.sol. This means that future upgrades could easily be checked to maintain _execute only within the context of VaultBaseUpgradeable. ‚óè It was veriÔ¨Åed that _execute can only call addresses deÔ¨Åned by two functions; these are set in: ‚óã setProviders() which is restricted to owner ‚óã setActiveProvider() which is restricted to owner and the controller after a reÔ¨Ånancing. ‚óè A check was introduced in executeSwitch to ensure address passed is a valid provider.‚Äù TOB-FUJI-003: Lack of contract existence check on delegatecall will result in unexpected behavior Partially Ô¨Åxed. The Fuji Protocol team added a contract existence check before the delegatecall in VaultBaseUpgradeable._execute. Also, assembly is no longer used for the implementation of that delegatecall. This makes the call simpler and less error-prone. However, the team is still using OpenZeppelin‚Äôs Proxy contract, which does not check for contract existence before its delegatecall. (03a4aa0) 58 Fuji Protocol TOB-FUJI-004: FujiVault.setFactor is unnecessarily complex and does not properly handle invalid input Fixed. The Fuji Protocol team modiÔ¨Åed the FujiVault.setFactor function so that it reverts if an invalid type is provided. (9e79d2e) TOB-FUJI-005: Preconditions speciÔ¨Åed in docstrings are not checked by functions Fixed. The Fuji Protocol team added the missing checks to Controller.doRefinancing and FujiVault.setFactor. (2efc1b4, 9e79d2e) TOB-FUJI-006: The FujiERC1155.burnBatch function implementation is incorrect Fixed. The Fuji Protocol team replaced amount with amountScaled in the burnBatch and mintBatch functions. Additionally, the team extracted the _mint and _burn functions, which are now reused, leading to less duplicate code and decreasing the chance that similar issues will arise in the burning and minting functions in the future. (900f7d7) TOB-FUJI-007: Error in the white paper‚Äôs equation for the cost of reÔ¨Ånancing Fixed. The Fuji Protocol team Ô¨Åxed equation 4 in the white paper. Additionally, the team Ô¨Åxed mistakes in the equation beyond those that we reported. However, the text below the equation in the white paper is inconsistent with the equation, since is now always a ùêπùêø ùëìùëíùëí percentage. (33c8c8b) TOB-FUJI-008: Errors in the white paper‚Äôs equation for index calculation Fixed. The Fuji Protocol team Ô¨Åxed equation 1 in the white paper. (33c8c8b) TOB-FUJI-009: FujiERC1155.setURI does not adhere to the EIP-1155 speciÔ¨Åcation Partially Ô¨Åxed. FujiERC1155‚Äôs setURI function still does not emit the URI event. The decision not to add this event is understandable, as doing so would require looping over all tokens. However, the Fuji Protocol team documented this behavior and modiÔ¨Åed the function so that it now emits a custom URIGlobalChanged event instead. (3477e6a) TOB-FUJI-010: Partial reÔ¨Ånancing operations can break the protocol Fixed. The Fuji Protocol team removed the ability to perform partial reÔ¨Ånancing operations from the protocol. (efa86b0) TOB-FUJI-011: Native support for ether increases the codebase‚Äôs complexity Risk accepted by the client. The Fuji Protocol team acknowledged the issue and provided the following rationale for its acceptance of this risk: ‚ÄúFuji protocol on Ethereum mainnet has to interact with Compound, which cETH market, operates in native ETH. To support ETH as collateral in Compound the asset must be handled in native form. Excluding Compound as a provider is not an option for the Fuji protocol at the moment.‚Äù 59 Fuji Protocol TOB-FUJI-012: Missing events for critical operations Fixed. The Fuji Protocol team added all missing events to the FujiAdmin, Controller, FujiERC1155, FujiMapping, FujiOracle, and FujiVault contracts. (3477e6a) TOB-FUJI-013: Indexes are not updated before all operations that require up-to-date indexes Partially Ô¨Åxed. The Fuji Protocol team added a call to updateF1155Balances in the deposit function but not in the paybackLiq function. The Ô¨Åx commit also contained some refactoring. We did not have time to check the correctness of this refactoring. (d17cd77) TOB-FUJI-014: No protection against missing index updates before operations that depend on up-to-date indexes Risk accepted by the client. The Fuji protocol team provided the following rationale for its acceptance of this risk: ‚ÄúThe team acknowledges the recommendation; however, the exploit scenario is limited. The team with foresee no future functions in the design pipeline that will involve index value calls. Item point will be considered for future implementation when there is a architecture design change in the protocol.‚Äù TOB-FUJI-015: Formula for index calculation is unnecessarily complex Fixed. The Fuji Protocol team correctly implemented the simpler formula suggested in this report. (0cc7032) TOB-FUJI-016: Flasher‚Äôs initiateFlashloan function does not revert on invalid Ô¨Çashnum values Fixed. The initiateFlashloan function now reverts on invalid _flashnum values. (3cc8b21) TOB-FUJI-017: Docstrings do not reÔ¨Çect functions‚Äô implementations Fixed. The Fuji Protocol team updated the docstrings so that they reÔ¨Çect the implementations. (9e79d2e) TOB-FUJI-018: Harvester‚Äôs getHarvestTransaction function does not revert on invalid _farmProtocolNum and harvestType values Fixed. The VaultHarvester contract‚Äôs getHarvestTransaction function now reverts on invalid _farmProtocolNum and harvestType values. (794e5d7) TOB-FUJI-019: Lack of data validation in Controller‚Äôs doReÔ¨Ånancing function Fixed. The Controller contract‚Äôs doRefinancing function now reverts if the new provider equals the active provider. (2efc1b4) 60 Fuji Protocol TOB-FUJI-020: Lack of data validation on function parameters Fixed. The Fuji Protocol team added missing zero address checks to the following functions: Claimable.transferOwnership, ClaimableUpgradeable.transferOwnership, Controller.setFujiAdmin, FujiVault.setFujiAdmin, FujiVault.setProviders, and FujiVault.setOracle. As of commit 0d77944, the FujiAdmin contract is not missing any checks. The team also added further zero checks. (293d9aa, 2c96c16, 0d77944) TOB-FUJI-021: Solidity compiler optimizations can be problematic Risk accepted by the client. 61 Fuji Protocol 
