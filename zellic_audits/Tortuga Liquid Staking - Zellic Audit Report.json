[
    {
        "title": "3.1 Tortuga coin initialization",
        "target": " tortuga ",
        "category": " Coding Mistakes",
        "severity": " Medium",
        "likelihood": " Medium ",
        "impact": " Medium ",
        "bodyDescription": "The initialize_tortuga_liquid_staking function calls coin:)initialize to instanti- ate the Coin resource. However, within the function body of coin:)initialize is an assertion statement that the creator of the resource matches the deploying package's address.  assert!( coin_address<CoinType>() =) account_addr, error:)invalid_argument(ECOIN_INFO_ADDRESS_MISMATCH),  ); ",
        "bodyImpact": "Users would not be able to access this function and not deploy their own version of StakedAptosCoin. ",
        "bodyRecommendations": "We recommend making this function only accessible for Tortuga's address. ",
        "remediation": "Move Labs fixed this issue in commit ef89a88.  Zellic 9 Move Labs  https://github.com/Tortuga-Finance/tortuga-protocol/commit/ef89a88d86ce945133ea9bb393a0af6568871350  "
    },
    {
        "title": "3.2 Protocol configurations",
        "target": " tortuga ",
        "category": " Coding Mistakes",
        "severity": " Medium",
        "likelihood": " Low ",
        "impact": " Medium ",
        "bodyDescription": "The following setter functions configure the protocol but have no input validation: se t_min_transaction_amount, set_reward_commission, and set_cooldown_period.  public entry fun set_reward_commission( tortuga: &signer, value: u64  ) acquires StakingStatus { let staking_status = borrow_global_mut<StakingStatus>(signer:)address_of(tortuga)); staking_status.reward_commission = value;  }  public entry fun set_cooldown_period( tortuga: &signer, value: u64  ) acquires StakingStatus { let staking_status = borrow_global_mut<StakingStatus>(signer:)address_of(tortuga)); staking_status.cooldown_period = value;  }  public entry fun set_min_transaction_apt_amount( tortuga: &signer, value: u64  ) acquires StakingStatus { let staking_status = borrow_global_mut<StakingStatus>(signer:)address_of(tortuga)); staking_status.min_transaction_apt_amount = value;  } ",
        "bodyImpact": "This could pose as a centralization risk and allow impractical configuration values.  Zellic 10 Move Labs    For example, setting theminimum transaction amount too high could inhibit newusers from entering the protocol, and setting the reward commission too high mistakingly would inhibit validators frombeing able to acquire reasonable amounts of delegations. ",
        "bodyRecommendations": "We recommend adding upper bound checks on these functions to allow for a rea- sonable max threshold. ",
        "remediation": "Move Labs fixed this issue in commit ef89a88.  Zellic 11 Move Labs  https://github.com/Tortuga-Finance/tortuga-protocol/commit/ef89a88d86ce945133ea9bb393a0af6568871350  "
    },
    {
        "title": "3.3 Payouts round down",
        "target": " tortuga ",
        "category": " Coding Mistakes",
        "severity": " Low",
        "likelihood": " Medium ",
        "impact": " Low ",
        "bodyDescription": "It is possible to perform an economically impractical, griefing-style attack that abuses the rounding down behavior of mul_div in disperse_all_payouts to ensure only those with a relatively high number of shares can receive a payout:  let payout_value = math:)mul_div( delegator_shares_for_payout, reserve_balance, reserved_share_supply,  );  If the reserve_balance is low enough, delegators with few shares would receive zero payout while delegators with many shares would receive some. Dust is refunded to the reserve at the end of disperse_all_payouts, meaning repeated, quick calls to dis perse_all_payoutswould result in only high-value delegators getting payouts. ",
        "bodyImpact": "Malicious, high-value delegators (i.e., those with many shares) could cause lower- value delegators to not receive any payouts. ",
        "bodyRecommendations": "A potential solution could be to delay payout until a minimum reserve balance is met. ",
        "remediation": "Move Labs fixed this issue in commit ef89a88.  Zellic 12 Move Labs  https://github.com/Tortuga-Finance/tortuga-protocol/commit/ef89a88d86ce945133ea9bb393a0af6568871350  "
    },
    {
        "title": "3.4 Centralization risk in minimum delegation amount",
        "target": " delegation ",
        "category": " Business Logic",
        "severity": " Low",
        "likelihood": " Medium ",
        "impact": " Low ",
        "bodyDescription": "The set_min_delegation_amount function allows pool owners to set an arbitrary value for the minimum delegation amount without any constraints. So, a pool owner could set the value to the maximum u64, effectively making it impossible for anyone except the owner or protocol to delegate APT to a managed_stake_pool.  public entry fun set_min_delegation_amount(pool_owner: &signer, value: u64) acquires ManagedStakePool { let managed_pool_address = signer:)address_of(pool_owner); let managed_stake_pool = borrow_global_mut<ManagedStakePool>(managed_pool_address); managed_stake_pool.min_delegation_amount = value;  } ",
        "bodyImpact": "Apool owner could set the value to themaximum u64, effectivelymaking it impossible for anyone except the owner or protocol to delegate APT to a managed_stake_pool. ",
        "bodyRecommendations": "Set a hardcoded maximum value for the min_delegation_amount. ",
        "remediation": "Move Labs fixed this issue in commit ef89a88.  Zellic 13 Move Labs  https://github.com/Tortuga-Finance/tortuga-protocol/commit/ef89a88d86ce945133ea9bb393a0af6568871350  "
    },
    {
        "title": "3.5 Precision loss in reward rate calculation",
        "* Target": " oracle ",
        "* Category": " Coding Mistakes",
        "* Likelihood": " Informational ",
        "* Severity": " Informational",
        "* Impact": " Informational ",
        "Description": "When calculating the effective reward rate, the effective_reward_rate function uses an order of operations that is not ideal; we recommend multiplying before dividing in cases where there is little risk of overflow to improve calculation precision. ",
        "Impact": "The effective reward rate may be slightly lower than intended. ",
        "Recommendations": "Change the order of the following operations:  fun effective_reward_rate( stats_config: &StatsConfig, rewards: u128, balance_at_last_update: u128, time_delta: u128,  ): u128 { (rewards * stats_config.rate_normalizer / balance_at_last_update) *  stats_config.time_normalizer / time_delta  (rewards * stats_config.rate_normalizer*stats_config.time_normalizer)/ (balance_at_last_update * time_delta)  } ",
        "Remediation": "In response to this finding, Move Labs noted that:  We have two normalizers just so that we can have double control over preci- sion. rate_normalizer will be as large as possible that still ensures no overflows  Zellic 14 Move Labs    in the first mul_div. Then time_normalizer could be any other reasonable value for precision. Multiplying the normalizers first, as in the recommendation is the same as using just one normalizer. We are hoping to get additional precision if necessary using two normalizers.  Zellic 15 Move Labs    4 Formal Verification  TheMOVE prover allows for formal specifications to bewritten onMOVE code, which can provide guarantees on function behavior.  During the audit period, we provided Move Labs with Move prover specifications, a form of formal verification. We found the prover to be highly effective at evaluating the entirety of certain functions' behavior and recommend theMove Labs team to add more specifications to their code base.  One of the issues we encountered was that the prover does not support recursive code yet. We suggest replacing the recursive functions, specifically the math:)pow functions to a loop form so additional specs can be written on the project.  The following is a sample of the specifications provided.  4.1 tortuga::stake_router  Verifies the result is a multiplication-divide:  spec calc_shares_to_value { requires t_apt_supply !) 0; aborts_if t_apt_supply < num_shares; ensures result <) MAX_U64; ensures result =) num_shares * total_worth / t_apt_supply;  }  Verifies the following resources are created upon initialization:  spec initialize_tortuga_liquid_staking { ensures exists<StakedAptosCapabilities>(signer:)address_of(tortuga)); ensures exists<StakingStatus>(signer:)address_of(tortuga)); ensures exists<validator_router:)Status>(signer:)address_of(tortuga)); ensures exists<validator_router:)DelegationAccounts>(signer:)address_of(tortuga));  }  Verifies values were mutated:  Zellic 16 Move Labs    spec set_min_transaction_amount { ensures borrow_global_mut<StakingStatus>(signer:)address_of(tortuga)).min_transaction_amount =) value;  }  spec set_cooldown_period { ensures borrow_global_mut<StakingStatus>(signer:)address_of(tortuga)).cooldown_period =) value;  }  spec set_reward_commission { ensures borrow_global_mut<StakingStatus>(signer:)address_of(tortuga)).reward_commission =) value;  }  4.2 helpers::circular_buffer  Verifies the buffer always contains the latest value pushed:  spec push { ensures len(old(cbuffer.buffer)) < max_length &) cbuffer.last_index + 1 > len(cbuffer.buffer) ==> contains(cbuffer.buffer, value);  }  Verifies the empty function returns an empty buffer:  spec empty { ensures len(result.buffer) =) 0; ensures result.last_index =) 0;  }  Verifies the length of cbuffer:  spec length {  Zellic 17 Move Labs    ensures len(cbuffer.buffer) =) result; }  Verifies borrow_oldest and round_robin behavior:  spec fun helper_round_robin(a: u64, b: u64): u64 { assert!(b > 0 &) a <) b, error:)invalid_argument(EARITHMETIC_ERROR)); if (a < b) {  a } else {  0 }  } spec round_robin {  aborts_if b > 0 |) a <) b; }  spec borrow_oldest { /) Verifies behavior about the borrow_oldest function in circular_buffer aborts_if cbuffer.last_index + 1 > len(cbuffer.buffer); aborts_if len(cbuffer.buffer) =) 0; let oldest_index = helper_round_robin(cbuffer.last_index +1, len(cbuffer.buffer)); ensures result =) cbuffer.buffer[oldest_index];  }  4.3 tortuga::stakedaptoscoin  Verifies StakedAptosCoin exists after initialization:  spec register_for_t_apt { ensures exists<coin:)CoinStore<StakedAptosCoin>)(signer:)address_of(account));  }  Zellic 18 Move Labs    4.4 helpers::math  Verifies when mul_div aborts and the resulting output:  spec mul_div { aborts_if c =) 0; aborts_if a * b / c > MAX_U64; ensures result <) MAX_U64;  }  Verifies it never aborts, thus actually safe:  spec safe_sub_u128 { aborts_if false;  }  Zellic 19 Move Labs    5 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  5.1 Evolving nature of Aptos core  While the Aptos blockchain prepares for its upcoming mainnet launch in autumn, pe- riodically breaking changes are introduced to aptos-stdlib and aptos-framework. We suspect this will continue to occur, even shortly after launch. We recommend the Tortuga team to stay up to date with any changes that may occur, with a specific at- tention to the stake.move file in aptos-framework, which governs validator behavior.  5.2 Griefing  Certain aspects of the protocol iterate over data structures, for example in tortuga:) delegation_state,  while (pool:)num_share_holders(&shares_data.reserved_pool) > 0)  which pose as a danger for gas limit errors. In this particular instance, Tortuga miti- gated the concern by providing an upperbound of 100 on the number of sharehold- ers. Nevertheless, gas metrics on Aptos are still relatively unclear, and an amount of shareholders close to the maximum limit could pose a threat of out of gas errors.  5.3 Simple map griefing  The SimpleMap data structure is susceptible to out of gas concerns, which potentially could cause an issue if unclaimed_stake_pool_owner_caps gets too large.  Adding a time constraint for an individual to claim their owner cap could mitigate this risk.  5.4 Integration and composability  To improve the interoperability of the protocol within the Aptos ecosystem, various methods for accessing resources from other contracts may be beneficial. For exam-  Zellic 20 Move Labs    ple, a getter method on the number of tickets a delegator has could be useful.  One area inwhich the protocol achieved composabilitywas via the following function:  public fun stake_coins( coins_to_stake: coin:)Coin<AptosCoin>  ): coin:)Coin<StakedAptosCoin>  And we believe adding more secure integration pathways could be beneficial to the success of the protocol.  5.5 Resource inconsistency  Within the code are resources that can be acquired by normal users that should be ideally only be reserved for admin acquisition only. This does not pose as an imme- diate security risk, however the getter methods for these resources would not work.  For instance, one could acquire the StakingStatus resource that exists on the publi- cally available function initialize_tortuga_liquid_staking.  However this following function, which utilizes a getter for this resource  public fun get_total_worth(): u64 acquires StakingStatus { let staking_status = borrow_global<StakingStatus>(@tortuga); let unclaimed_balance =  staking_status.total_claims_balance - staking_status.total_claims_balance_cleared;  validator_router:)get_total_balance() - (unclaimed_balance as u64) }  acquires the resource strictly from the address of @tortuga, rendering the ability for a user to have their own StakingStatus resource impractical.  We suggest the initialization functions to be accessible only for the address of @tortu ga.  Zellic 21 Move Labs    6 Audit Results  At the time of our audit, the codewas not deployed toAptosMainnet as the blockchain had not been launched yet.  During our audit, we discovered five findings. Of these, two were medium risk, two were low risk and one was a suggestion (informational). Move Labs acknowledged all findings and implemented fixes.  6.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 22 Move Labs   \tAbout Zellic \tExecutive Summary \tIntroduction \tAbout Tortuga Liquid Staking \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tTortuga coin initialization \tProtocol configurations \tPayouts round down \tCentralization risk in minimum delegation amount \tPrecision loss in reward rate calculation  \tFormal Verification \ttortuga::stake_router \thelpers::circular_buffer \ttortuga::stakedaptoscoin \thelpers::math  \tDiscussion \tEvolving nature of Aptos core \tGriefing \tSimple map griefing \tIntegration and composability \tResource inconsistency  \tAudit Results \tDisclaimers  "
    }
]