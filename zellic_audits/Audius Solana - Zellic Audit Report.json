[
    {
        "title": "3.1 Missing PDA validation leading to multiple transfers",
        "target": " Rewards Manager",
        "category": " Coding Mistakes",
        "severity": " Critical",
        "likelihood": " High ",
        "impact": " Critical ",
        "bodyDescription": "Rewards are redeemed using a two-step process. First, signed messages are submit- ted and stored on-chain in an account of type VerifiedMessages. When the required amount of signedmessages has been submitted, the EvaluateAttestations instruction is invoked to process the transfer. The instruction performs a number of checks on the provided accounts and then performs the token transfer to the destination account. In order to avoid a single transfer being repeated multiple times, a PDA is created (tr ansfer_account_info), marking the transfer as completed. The PDA is unique for the transfer since the address is derived from the details of the transfer, including a unique ID. In addition, the account containing the VerifiedMessages is deleted by zeroing its lamports. Both these measures are flawed and can be bypassed.  The transfer_account_info account is not checked to be the intended PDA. An at- tacker can supply any signer account as an input to the transaction, and the account will be created successfully. This is because any signer account can be passed to the create_account system instruction, even if the invoke_signed function is used to per- form an invocation with signer seeds for the intended PDA. The signer seeds will just be ignored as they do not correspond to any account in the subtransaction.  It is also possible to reuse the VerifiedMessages account, despite it having zero lam- ports, by referencing it in multiple instructions within the same transaction. This spe- cific issue is discussed more in detail in finding 3.3. ",
        "bodyImpact": "It is possible to redeem rewardsmultiple times. We confirmed this issue bymodifying an existing test. ",
        "bodyRecommendations": "Ensure that the transfer_account_info account matches the expected PDA. Properly invalidate the data stored in the VerifiedMessages accounts so that it cannot be reused  Zellic 8 Audius, Inc    even within the same transaction. ",
        "remediation": "The Audius team was alerted of this issue while the audit was ongoing. The issue was acknowledged within 10 minutes, and a remediation patch was suggested within 40 minutes. The patch was quickly deployed after review from both Zellic and Au- dius engineers to ensure a complete fix to the issue. The complete timeline of events follows (times in UTC, October 15th):  * 17:52 Audius is informed of the issue * 18:02 Audius acknowledges the issue * 18:31 Audius proposes a remediation * 18:35 Zellic confirms that proposed remediation patches the issue, suggesting additional changes to invalidate VerifiedMessages accounts  * ~21:45Audius finalizes remediation commits, including suggested additional changes * ~22:00 Zellic confirms that remediation patches the issue * ~22:00 Audius deploys and tests patch on testnet * 23:31 Audius deploys patch on mainnet  Zellic 9 Audius, Inc   "
    },
    {
        "title": "3.2 Ambiguous format for signed messages",
        "target": " Rewards Manager",
        "category": " Code Maturity",
        "severity": " Informational",
        "likelihood": " N/A ",
        "impact": " Informational ",
        "bodyDescription": "Verified messages are serialized as the concatenation of multiple fields separated by an underscore:  /) Valid senders message let valid_message = [  transfer_data.eth_recipient.as_ref(), b\"_\", transfer_data.amount.to_le_bytes().as_ref(), b\"_\", transfer_data.id.as_ref(), b\"_\", bot_oracle.eth_address.as_ref(),  ] .concat();  This format is inherently prone to ambiguities. Consider the example of the following amount and id variations (other fields left out for simplicity):  amount: 123 id: _myid message: 123__myid  amount: 123_ id: myid message: 123__myid  The same message can be obtained by composing different amounts and ids. ",
        "bodyImpact": "This issue can potentially be exploited to submit manipulated values to invocations of process_evaluate_attestations. The Audius team claimed amounts and ids containing underscores (0x5f bytes) cannot be generated by the relevant off-chain programs;  Zellic 10 Audius, Inc    therefore, the issue is not exploitable in practice. For this reason this potentially critical issue is reported as informational. ",
        "bodyRecommendations": "Even though the issue might not be exploitable at the time of this security audit, we strongly advise to review the message format to make ambiguities impossible in or- der to to harden the code and avoid being exposed to a risk of a critical issue. One remediation option would be to adopt a serialization format where the various fields have a fixed length. Another more flexible (but more complex and bug-prone) option would be to adopt a tag-length-value encoding (or just length-value). ",
        "remediation": "The Audius team acknowledged this finding. No change to the codebasewas deemed to be immediately required.  Zellic 11 Audius, Inc   "
    },
    {
        "title": "3.3 Unsafe account deletion method",
        "target": " Rewards Manager",
        "category": " Coding Mistakes",
        "severity": " Low",
        "likelihood": " N/A ",
        "impact": " Low ",
        "bodyDescription": "The EvaluateAttestations instruction processes an account of type VerifiedMessages containing signed assertions authorizing the transfer of a given amount of tokens to a specific account. Towards the end of the instruction, the VerifiedMessages account is deleted by zeroing its lamports.  This account deletionmethod is unsafe and prone to abuse. The reason is that account deletion does not happen immediately after an instruction is finished processing, and a zero-lamports account is usable by other instructions within the same transaction. ",
        "bodyImpact": "It is possible to reuse a VerifiedMessages account after an EvaluateAttestations in- struction has been processed, despite it having zero lamports, by referencing the same account in multiple instructions within the one transaction. This issue was part of the exploit for issue 3.1. ",
        "bodyRecommendations": "Invalidate or immediately delete VerifiedMessages.  Invalidating the account can be done by zeroing the version field, thus making unpac king the account fail.  Truly and fully deleting the account is not possible; however, it is possible to achieve an equivalent effect by zeroing the account lamports, resizing the account to zero, and transferring the account ownership to the system program. ",
        "remediation": "The Audius team was alerted of this issue while the audit was ongoing, together with issue 3.1. The Audius team quickly applied a remediation that invalidates the account, making unpack fail.  Zellic 12 Audius, Inc   "
    },
    {
        "title": "3.4 Lack of parameters validation in InitRewardManager",
        "* Target": " Rewards Manager",
        "* Category": " Code Maturity",
        "* Likelihood": " N/A ",
        "* Severity": " Informational",
        "* Impact": " Informational ",
        "Description": "The processor for the InitRewardManager is not performing some checks that would prevent misuse of the program outside of the intended functionality.  Specifically, the min_votes parameter is not required to be greater than zero. It would be possible to initialize a RewardManager that requires zero signers. In addition, the mint_info account is not constrained to be the mint of one specific token. ",
        "Impact": "This is an informational finding, and there is no direct security impact. The off-chain programs invoking InitRewardManager are responsible for calling it with appropriate parameters and could potentially invoke it with invalid parameters by mistake, creat- ing a RewardManager that requires no signers. ",
        "Recommendations": "Even though this issue does not pose a direct security vulnerability, we recommend to be as restrictive as possible in the inputs accepted by on-chain programs as a hard- ening measure. ",
        "Remediation": "The Audius team acknowledged this finding. No change to the codebasewas deemed to be immediately required.  Zellic 13 Audius, Inc    4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Ownership change process  The reward manager ChangeManagerAccount instruction allows to change the owner associated with a reward manager. The ownership change process does not require to prove that the new owner account is valid and that the associated private key is known (or that a program that can sign for it exists, in the case of a PDA). A two-step process is quite common to ensure protection against mistaken ownership changes: First, an ownership change is requested, and the to-be admin is stored alongside the old one. A second instruction is then invoked with the second admin as a signer, confirming the ownership transfer and replacing the former admin with the new one. Such a design change could be a minor improvement to Audius design.  4.2 Usage of constant strings instead of enums  The rewardmanager validate_secp_add_delete_sender function takes a message_pref ix string reference, which in practice is always one of the two constant values DELETE_ SENDER_MESSAGE_PREFIX or ADD_SENDER_MESSAGE_PREFIX. A very minor improvement to be considered would be to switch from accepting a string reference to accepting an enum implementing the From and Into traits to aid in converting to and from a string form.  4.3 Lack of discriminators  Solana accounts are, by default, untyped byte bufferswith some associatedmetadata. It is up to the individual programs to discern between the various types of data that can be stored in an account. Audius determines the type of an account by looking at the size of the account's data. Since every type in Audius programs differs in size, this is possible and not ambiguous. However, this prevents Audius from introducing account types with the same size in a future update.  Themost common and general approach, also adopted by Anchor, themost common Solana framework, is to include a discriminator field in the account data, containing a value that is unique for each type of account. This approach allows to introduce new  Zellic 14 Audius, Inc    types (even with identical sizes) without the risk of type confusion.  Audius is not vulnerable to account confusion in the version under review. We note that extreme care by the development team must be taken not to introduce new ac- count types with size conflicting with any other existing type in the future.  4.4 The checks is_signer and owner should be consolidated  In multiple places in the eth registry are seperate is_signer and owner checks per- formed on the Signer Group. The Signer Group does have the SignerGroup:)check_ owner(...))) method, which does both already with the correct error return variants. These scattered is_signer and owner checks should be consolidated into check_owner calls.  4.5 No account ownership enforced in rewardsmanager change manager account instruction  The Solana VM will enforce the property that a program must be the owner account it has performed a write to. This property is commonly leveraged to avoid having to perform an explicit ownership check inside the contract code itself as the Solana VM should enforce this.  This is actually not entirely true. This property is only enforced if there is a change to the account data field. So, if the Solana program writes the same data that already exists in the account on top of the existing data, then the Solana runtime will not re- quire the program to have ownership of the account, since it's data before and after the program executes hasn't changed.  This is typically an issue if the account beingwritten to, or one of the arguments passed in via the instruction, is also being used to perform a write to another important ac- count. In this case, that is not true; therefore, this did not rise to the level of a security issue. Wewanted to note, though, that the following comment found in the code does not always hold for the reason explained above:  /) Note: We do not have to assert that we own the `reward_manager` account /) as we would normally, because in writing to it the runtime /) enforces ownership  Zellic 15 Audius, Inc    5 Audit Results  During our audit, we discovered four findings. Of these, one was of critical severity, one was low risk, and two were suggestions (informational). Audius, Inc acknowl- edged all findings and implemented fixes for the critical and low severity findings.  At the time of our audit, the code was deployed to mainnet Solana. The Audius team was informed of the critical finding as soon as Zellic confirmed exploitability by per- fecting a proof of concept. The Audius team promptly acknowledged, triaged, and remediated the issue, minimizing the risk of the issue being exploited.  5.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 16 Audius, Inc   \tAbout Zellic \tExecutive Summary \tIntroduction \tAbout Audius Solana Programs \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tMissing PDA validation leading to multiple transfers \tAmbiguous format for signed messages \tUnsafe account deletion method \tLack of parameters validation in InitRewardManager  \tDiscussion \tOwnership change process \tUsage of constant strings instead of enums \tLack of discriminators \tThe checks is_signer and owner should be consolidated \tNo account ownership enforced in rewards manager change manager account instruction  \tAudit Results \tDisclaimers  "
    }
]