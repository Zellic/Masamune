[
    {
        "title": "3.1. Possible cross-chain desynchronization of token balances",
        "target": " Pool",
        "category": " Business Logic",
        "severity": " High",
        "likelihood": " High ",
        "impact": " High ",
        "bodyDescription": "The lkbRemove values in cross-chain swap (swap -> swapRemote) payload failed to account for the eqReward, potentially leading to desynchronization of token balances that can be swapped between two chains. In swapRemote, the amount transferred to the user includes s.eqReward, while not being reduced from the cp.balance on the source chain's side.  function swap(uint16 _dstChainId, uint256 _dstPoolId, address _from, uint256  _amountLD, uint256 _minAmountLD, bool newLiquidity) external nonReentrant  onlyRouter returns (SwapObj memory) {  ...  uint256 amountSD = amountLDtoSD(_amountLD);  ...  SwapObj memory s = IStargateFeeLibrary(feeLibrary).getFees(poolId, _dstPoolId,  _dstChainId, _from, amountSD);  ...  // behaviours  //     - protocolFee: booked, stayed and withdrawn at remote.  //     - eqFee: booked, stayed and withdrawn at remote.  //     - lpFee: booked and stayed at remote, can be withdrawn anywhere  s.lkbRemove = amountSD.sub(s.lpFee); <-- eqReward should be included in lkbRemove  too!  Zellic 6 LayerZero Stargate   ",
        "bodyImpact": "The desynchronization of cross-chain balances could possibly lead to a case where the swap may not go through even though the source chain believes it would, breaking the IFG (Instant finality guarantee) and leading to user funds being permanently locked.  We created a proof of concept for this bug that breaks the IFG. An excerpt of the output is shown below:  --------------INITIAL STATE--------------  Balance on chain A -> 10000000000000 Balance on chain B -> 10000000000000 Balance on chain C -> 10000000000000  -----------------------------------------  Performing first swap : 2500 from C to B (1% eqFee fee)  ------------------STATE------------------  Balance on chain A -> 10000000000000 Balance on chain B -> 12475000000000     // B deposited with 2475 (1% fee) Balance on chain C ->  7500000000000     // C reduced by 2500  -----------------------------------------  Performing second swap : 2500 from C to A (0% fee)  ------------------STATE------------------  Balance on chain A -> 12500000000000     // +2500 Balance on chain B -> 12475000000000 Balance on chain C ->  5000000000000     // -2500  -----------------------------------------  Performing third swap : 2500 from B to A (1% eqReward)  ------------------STATE------------------  Balance on chain A -> 12500000000000     // +0: nothing swapped out! Balance on chain B ->  9975000000000     // -2500 Balance on chain C ->  5000000000000  -----------------------------------------  We have provided the PoC to LayerZero for reproduction and remediation.  Zellic 7 LayerZero Stargate   ",
        "bodyRecommendations": "Account for s.eqReward while calculating s.lkbRemove:  s.lkbRemove = amountSD.sub(s.lpFee).add(s.eqReward); ",
        "remediation": "The issue has been acknowledged and fixed by LayerZero. It was also found during an internal audit of the code.  Zellic 8 LayerZero Stargate   "
    },
    {
        "title": "3.2. Insufficient equilibrium fee pool can cause swaps to fail",
        "target": " Pool",
        "category": " Business Logic",
        "severity": " Medium",
        "likelihood": " Medium ",
        "impact": " Medium ",
        "bodyDescription": "In the function swap, s.eqReward is subtracted from eqFeePool using SafeMath, which will revert if s.eqReward is larger than eqFeePool. This can happen either when eqFeePool is very low or a large amount of tokens are being swapped out.  require(!stopSwap, \"Stargate: swap func stopped\");  ChainPath storage cp = getAndCheckCP(_dstChainId, _dstPoolId);  require(cp.ready == true, \"Stargate: counter chainPath is not ready\");  uint256 amountSD = amountLDtoSD(_amountLD);  uint256 minAmountSD = amountLDtoSD(_minAmountLD);  // request fee params from library  SwapObj memory s = IStargateFeeLibrary(feeLibrary).getFees(poolId, _dstPoolId,  _dstChainId, _from, amountSD);  // equilibrium fee and reward. note eqFee/eqReward are separated from swap  liquidity  eqFeePool = eqFeePool.sub(s.eqReward); // This operation may underflow and revert! ",
        "bodyImpact": "Large swaps will fail, wasting users' gas (and money). ",
        "bodyRecommendations": "Compare s.eqReward to s.eqFeePool before subtracting and limit rewards up to the current eqFeePool to avoid arithmetic errors. ",
        "remediation": "The issue has been acknowledged by LayerZero. Their official response is reproduced below:  The equilibrium reward (eqReward) will also only be a fraction of the eqFeePool. This business logic constraint will be enforced in the feeLibrary.  Zellic 9 LayerZero Stargate   "
    },
    {
        "title": "3.3. Unchecked use of mload can potentially lead to an",
        "target": " Multiple contracts",
        "category": " Code Maturity",
        "severity": " Low",
        "likelihood": " High ",
        "impact": " Low ",
        "bodyDescription": "A common pattern used in the codebase is to cast bytes memory into address using inline assembly, like so:  bytes memory _addr = ...;  address castedAddr;  assembly {  castedAddr := mload(add(_addr, 20))  }  Casting bytes memory _addr to address castedAddr.  At the memory location pointed to by _addr, Solidity lays out 32 bytes storing _addr's size, followed by the contents of _addr. The first 20 bytes of the size field are discarded by the add instruction. The mload will load the last 12 bytes of the size field, followed by the first 20 bytes of the contents of _addr, assuming _addr is long enough. The 12 bytes of the size field are discarded when assigning to the destination variable toAddress.  If the byte array _addr is less than 20 bytes long, the mload will read out-of-bounds, returning bytes of undefined value.  We found this pattern used in Bridge.sol, OmnichainFungibleToken.sol, and Router.sol.  We believe this pattern was likely introduced as a gas optimization, but it is undocumented. ",
        "bodyImpact": "We audited all instances of the pattern and found that an attacker may be able to call the function with controlled contents for _addr. Chiefly, Router.redeemLocal is reachable by an attacker; and Bridge.lzReceive may be indirectly called through the LayerZero endpoint via Bridge.swap, via Router.swap.  Although we believe the bug currently has no security impact since it would simply lead to an invalid \"to\" address in each case, the potential for undefined behavior is concerning. In the  Zellic 10 LayerZero Stargate    past, even low-impact vulnerabilities have been chained with other bugs (2) to achieve critical security compromises.  Furthermore, the current implementation relies heavily on Solidity runtime implementation details, like the memory layout of bytes memory (32 bytes size field, followed by contents). In our experience, reliance on implementation details without adequate documentation is error-prone in general. Although StarGate has the Solidity version pinned at 0.7.6, this code may unexpectedly lead to future bugs which are challenging to detect from the code alone. ",
        "bodyRecommendations": "Add an explicit bounds check before each instance of the mload(add(_x, 20)) pattern to ensure that the loaded buffer is at least 20 bytes long. ",
        "remediation": "The issue has been acknowledged by LayerZero. Their official response is reproduced below:  Using bytes instead of address for the _toAddress is for integration with other chains with different address schemes as EVM. if the _toAddress is less than 20 bytes long, we consider that a user configuration problem.  Zellic 11 LayerZero Stargate  https://sector7.computest.nl/post/2021-08-zoom/ https://www.zerodayinitiative.com/blog/2020/3/19/pwn2own-2020-day-one-results https://devblogs.microsoft.com/oldnewthing/20031223-00/?p=41373  "
    },
    {
        "title": "3.4. Usage of calldatacopy in inline assembly is unclear",
        "target": " Bridge",
        "category": " Code Maturity",
        "severity": " n/a",
        "likelihood": " n/a ",
        "impact": " Informational ",
        "bodyDescription": "The function _packedBytesToAddr is implemented correctly, but in a potentially misleading way that is confusing for readers.  function _packedBytesToAddr(bytes calldata _b) private returns (address) {  address addr;  assembly {  let ptr := mload(0x40)  calldatacopy(ptr, sub(_b.offset, 2), add(_b.length, 2))  addr := mload(sub(ptr, 10))  }  return addr;  }  The function implicitly truncates the upper (first) 12 bytes of the mloaded contents when assigning to addr. The current implementation copies 2 bytes of _b's length, which is laid out in calldata memory directly preceding the contents of _b at _b.offset. It unnecessarily mloads these 2 bytes as well as 10 bytes of currently in-use memory whose values are undefined. It is unclear and undocumented why these 12 bytes with undefined behavior are loaded then immediately discarded. ",
        "bodyImpact": "The current implementation is confusing and distracts readers from the overall objective of the function: to cast a bytes calldata _b into an address addr by loading its first 20 bytes. This is potentially misleading and should be avoided. The unnecessary operations also waste gas.  The current implementation loads bytes from memory whose values are undefined. Although these bytes are discarded, undefined behavior should be avoided whenever possible.  Relying on implementation-specific behavior is acceptable in certain situations, but it should be avoided whenever possible. In this situation, the function can be soundly rewritten in a more concise manner.  Zellic 12 LayerZero Stargate   ",
        "bodyRecommendations": "Replace the current implementation with the following suggested implementation, that is more clearly documented:  // Casts a bytes calldata _b into an address by loading its first 20 bytes.  // This function is necessary since Stargate is designed to work with any chain;  // and not all chains have address which are 20 bytes. Hence, addresses are  // represented as byte slices of arbitrary length, rather than a native address  type.  function packedBytesToAddr(bytes calldata _b) public view returns (address) {  address addr;  assembly {  let ptr := mload(0x40) // Current free memory pointer  calldatacopy(ptr, _b.offset, _b.length)  addr := mload(sub(ptr, 12))  }  return addr;  } ",
        "remediation": "The issue has been acknowledged and fixed by LayerZero.  Zellic 13 LayerZero Stargate   "
    },
    {
        "title": "3.5. Missing test suite code coverage",
        "target": " Multiple contracts",
        "category": " Code Maturity",
        "severity": " Low",
        "likelihood": " n/a ",
        "impact": " Informational ",
        "bodyDescription": "Several functions in the smart contract are not covered by any unit or integration tests, to the best of our knowledge. We ran the entire Hardhat test suite and reviewed the Solcov coverage report. The following functions do not have test coverage:  Bridge.sol: forceResumeReceive, setConfig, getConfig, setSendVersion, setReceiveVersion, getSendVersion, getReceiveVersion  OmnichainFungibleToken.sol: forceResumeReceive, setConfig, getConfig, setSendVersion, setReceiveVersion, getSendVersion, getReceiveVersion  These functions are simply wrappers around the LayerZero API, so we do not see them as a significant issue.  LPTokenERC20.sol: increaseAllowance, decreaseAllowance, permit  The functions increaseAllowance and decreaseAllowance are simply wrappers around the OpenZeppelin ERC20 functionality, so we do not see these as a significant issue. The permit  function's implementation seems to be the same as in UniswapV2, a battle-tested project, so we do not see it as an issue either.  We also scanned for functions which had inadequate branch coverage. Reaching 100% branch coverage is ideal, but we understand that, especially for projects under active development like LayerZero, it may not always be a top priority. The most concerning instances of missing branch coverage were:  LPStaking.sol: partial coverage in getMultiplier, pendingStargate, and updatePool  The implementation of LPStaking seems similar to PancakeSwap MasterChef, a battle-tested project. One key difference is the addition of a bonus period, controlled by the variable bonusEndBlock. We reviewed the updated getMultiplier function, but did not find any problems. The pendingStargate function is unchanged from MasterChef. The two uncovered branches in the updatePool function are also unchanged.  Zellic 14 LayerZero Stargate    Pool.sol: partial coverage in _delta  The missing coverage corresponds to running the delta algorithm, but without a full update. It was simple to create new tests to cover this case based on the existing, extensive test suite.  Router.sol: retryRevert, clearCachedSwap, redeemLocalCheckOnRemote, _redeemLocalCallback, _swapRemote  The try-catch error handling code related to reverts is untested. It appears that a Bridge mock is needed to test the revert functionality. We assume LayerZero plans to add tests for this code once a Bridge mock for testing has been implemented.  We reviewed all untested functions with increased scrutiny. Fortunately, we did not find any additional vulnerabilities.  Overall, the project demonstrates excellent test coverage across the whole code base, and we applaud LayerZero for their commitment to thorough testing. ",
        "bodyImpact": "Because correctness is so critically important when developing smart contracts, we recommend that all projects strive for 100% code coverage. Testing should be an essential part of the software development lifecycle. No matter how simple a function may be, untested code is always prone to bugs. ",
        "bodyRecommendations": "Expand the test suite so that all functions and their branches are covered by unit or integration tests. ",
        "remediation": "The issue has been fixed by LayerZero. They have added additional test coverage based on our recommendations.  Zellic 15 LayerZero Stargate   "
    },
    {
        "title": "3.6. Ideally, the usage of the LayerZero API should be more",
        "target": " Multiple contracts",
        "category": " Code Maturity",
        "severity": " Low",
        "likelihood": " n/a ",
        "impact": " Informational ",
        "bodyDescription": "Several of the key contracts (Pool.sol, Bridge.sol, Router.sol, OmnichainFungibleToken.sol) implement or use the LayerZero API in some way. However, the way LayerZero is used is undocumented and confusing to new developers. ",
        "bodyImpact": "Since Stargate will be a first-party consumer of LayerZero API, it is important to have clear documentation on the API usage so that it can serve as a reference to other developers. If they cannot find adequate usage examples, it might lead to mis-usage of the API. ",
        "bodyRecommendations": "Add additional documentation specifically about how the LayerZero API is used, and how the code is interacting with it ",
        "remediation": "The issue has been acknowledged by LayerZero. Additional documentation will be added.  Zellic 16 LayerZero Stargate   "
    },
    {
        "title": "3.7. Use of balanceOf in fee calculations may lead to unfavorable",
        "* Target": " StargateFeeLibraryV02",
        "* Severity": " Low",
        "* Impact": " Informational ",
        "* Category": " Business Logic",
        "* Likelihood": " Low ",
        "Description": "The currentAssetSD amount is set to the balanceOf the pool, which is manipulatable by sending tokens directly to the pool. The tokens would not be registered in the deltaCredit  (and be unusable by any remote chains) but can lead to wrong eqReward calculation.  function getFees( ... ) external view override returns (Pool.SwapObj memory s) { ...  uint256 currentAssetSD = IERC20(tokenAddress).balanceOf(address(pool)).div(pool.convertRate());  uint256 lpAsset = pool.totalLiquidity(); if (lpAsset > currentAssetSD) {  // in deficit uint256 poolDeficit = lpAsset.sub(currentAssetSD); uint256 rewardPoolSize = pool.eqFeePool();  // reward capped at rewardPoolSize uint256 eqRewards = rewardPoolSize.mul(_amountSD).div(poolDeficit); ",
        "Impact": "The calculated eqReward would be lower than it should be, reducing the incentive for the user to swap from low to high liquidity chains. ",
        "Recommendations": "Keep an internal record of deposited tokens and use it to calculate the eqReward. ",
        "Remediation": "The issue has been acknowledged by LayerZero. Because it is a minor issue and is not currently causing any issues, they plan to fix it in the future, in the V3 of the FeeLibrary.  Zellic 17 LayerZero Stargate    4. Discussion  In this section, we discuss miscellaneous interesting observations during the audit that are noteworthy and merit some consideration.  In a parallel, internal audit by the LayerZero team, the following issues were identified and fixed:  * The variable Bool ready was moved to the first place in struct Chainpath for compact packing as a gas optimization.  * The type of dstChainId was fixed to be uint16 instead of uint256, making it consistent all across the project.  * The eqReward is now also added to deltaCredit even in the case when no liquidity is added (i.e. during a remote LP redeem).  * Added creditObj in quoteLayerZeroFee() to correctly calculate the LayerZero Fee.  Zellic 18 LayerZero Stargate  "
    }
]