[
    {
        "title": "3.1 Out-of-bounds write in update test instruction",
        "target": " oracle.c",
        "category": " Coding Mistakes",
        "severity": " High",
        "likelihood": " High ",
        "impact": " High ",
        "bodyDescription": "Pyth exposes two instructions associated with test price accounts - one to initialize them, and another to update the account's pricing information. The update instruction sets pricing, status, and confidence intervals for the test account's price components using a loop that copies over values from the instruction data to the account. This loop iterates a number of times as specified by the caller, incrementing a variable used to index into the price components.  for( uint32_t i=0; i !) cmd->num_; +)i ) { pc_price_comp_t *ptr = &px->comp_[i]; ptr->latest_.status_ = PC_STATUS_TRADING; ptr->latest_.price_ = cmd->price_[i]; ptr->latest_.conf_ = cmd->conf_[i]; ptr->latest_.pub_slot_ = slot + (uint64_t)cmd->slot_diff_[i];  }  upd_aggregate( px, slot+1 );  The supplied number of iterations this loop should run is not bound in any way. This allows a caller to index past the end of the array, which has a fixed size of 32, and can allow an attacker to manipulate memory outside of the pricing components. ",
        "bodyImpact": "Memory corruption is a critical violation of program integrity and safety guarantees. The ability to write out-of-bounds can violate the integrity of data structures and in- variants in the contract. Thankfully, this instruction validates that only two accounts can be supplied in invocation which does help reduce the impact, but this behavior is still dangerous and may result in an attack that could result in price manipulation.  The num_ variable is also referenced in upd_aggregate, which eventually leads an out-  Zellic 7 Pyth Data Association    of-bound stack write that can be potentially leveraged to redirect control flow. ",
        "bodyRecommendations": "The upd_test instruction should validate that cmd->num_ is equal to or less than PC_COMP_SIZE. This will preventing the out-of-bound indexing and write behavior. ",
        "remediation": "The finding has been acknowledged by Pyth Data Association. Their official response is reproduced below:  Pyth Data Association acknowledges the finding and a security fix for this issue will be deployed on or before April 18th.  Zellic 8 Pyth Data Association   "
    },
    {
        "title": "3.2 Lack of rent exemption enforcement",
        "target": " oracle.c",
        "category": " Business Logic",
        "severity": " High",
        "likelihood": " Low ",
        "impact": " High ",
        "bodyDescription": "To support the validators that maintain account state, Solana imposes rent on ac- counts. Every so often, if an account does not have more than the minimum required lamports to qualify as \"rent exempt\", an amount of lamports are collected as rent. If an account's balance hits 0, the data for the account is forgotten, effectively resetting the account. Thus, it is possible to reinitialize accounts which have run out of lamports.  Pyth uses accounts created and supplied by the caller to store data. Pyth does not re- quire that these accounts maintain a balance large enough to qualify as \"rent exempt\". This means that a caller can supply an account with too few lamports, initialize it as a particular account type, and, after rent has drained the account, use the account as if it were brand new.  This type of confusion can be found everywhere in the code as rent is not enforced for any accounts supplied by the user. ",
        "bodyImpact": "The lack of rent exemption checks can result in invariants in the code breaking which can impact clients interacting with the state of these accounts or the contract itself.  For example, product accounts can only be placed into a map if they haven't been initialized yet. This step, using the add_product instruction, requires the product ac- count to be initialized but the data field empty. This should only be true if the product account has never been used before, but because this account can be wiped out due to rent we can actually add this product account to multiple maps resulting in the product's prod_ field pointing to an incorrect map. ",
        "bodyRecommendations": "Pyth should either:  1. Use Program Derived Accounts (PDA) to manage state and delegate signing au- thority in a way similar to Solana's Token accounts (with an owner or authority field on the PDA). These accounts should be created with a minimum \"rent ex- empt\" qualifying balance.  Zellic 9 Pyth Data Association    2. Require all accounts supplied by the user to be rent exempt. It should be suffi- cient to update both valid_signable_account and valid_writable_accountwith this check to get the desired mitigation in place. ",
        "remediation": "The finding has been acknowledged by Pyth Data Association. Their official response is reproduced below:  Pyth Data Association acknowledges the finding and a security fix for this issue will be deployed on or before April 18th.  Zellic 10 Pyth Data Association   "
    },
    {
        "title": "3.3 Inefficient publisher deletion algorithm results in excessive",
        "target": " oracle.c",
        "category": " Optimization",
        "severity": " Low",
        "likelihood": " High ",
        "impact": " Low ",
        "bodyDescription": "The del_publisher instruction allows a caller to remove a publisher from a price ac- count. To do this, the instruction first loops through the publishers on the price ac- count's comp_ array. After identifying the index of comp_ with the publisher account, an inner loop runs which shifts all of the accounts down.  static uint64_t del_publisher( SolParameters *prm, SolAccountInfo *ka ) { ...))  /) try to remove publisher for(uint32_t i=0; i !) sptr->num_; +)i ) {  pc_price_comp_t *iptr = &sptr->comp_[i]; if ( pc_pub_key_equal( &iptr->pub_, &cptr->pub_ ) ) {  for( unsigned j=i+1; j !) sptr->num_; +)j ) { pc_price_comp_t *jptr = &sptr->comp_[j]; iptr[0] = jptr[0]; iptr = jptr;  } --sptr->num_; sol_memset( iptr, 0, sizeof( pc_price_comp_t ) ); /) update size of account sptr->size_ = sizeof( pc_price_t ) - sizeof( sptr->comp_ ) + sptr->num_ * sizeof( pc_price_comp_t );  return SUCCESS; }  } }  This is an inefficient way to remove the publisher account from the price account.  Zellic 11 Pyth Data Association   ",
        "bodyImpact": "This can result in excessive fees for removing a publisher than would otherwise be necessary. It also increases code complexity, which may leads to bugs in the future. ",
        "bodyRecommendations": "Amore efficient solution would be to replace the publisher account with the last pub- lisher account and then clear out the final publisher entry.  A reference implementation is supplied.  for(uint32_t i = 0; i !) sptr->num_; +)i ) { pc_price_comp_t *iptr = &sptr->comp_[i]; /) identify the targeted publisher entry if ( pc_pub_key_equal( &iptr->pub_, &cptr->pub_ ) ) {  /) select the last publisher entry pc_price_comp_t *substitute_ptr = &sptr->comp_[sptr->num_ - 1]; /) swap the current publisher entry with the last one - it's okay  if this is the same entry iptr[0] = substitute_ptr[0]; /) clear out the last publisher sol_memset(substitute_ptr, 0, sizeof( pc_price_comp_t ));  /) reduce the number of publishers by one --sptr->num_; /) recalculate size sptr->size_ = sizeof( pc_price_t ) - sizeof( sptr->comp_ )  + sptr->num_ * sizeof( pc_price_comp_t );  return SUCCESS; }  } ",
        "remediation": "The finding has been acknowledged by Pyth Data Association. Their official response is reproduced below:  Pyth Data Association acknowledges the finding, but doesn't believe it has secu- rity implications. However, we may deploy a bug fix to address it.  Zellic 12 Pyth Data Association   "
    },
    {
        "title": "3.4 Unclear variable names can be potentially confusing",
        "* Target": " Multiple functions",
        "* Severity": " n/a",
        "* Impact": " Informational ",
        "* Category": " Code Maturity",
        "* Likelihood": " n/a ",
        "Description": "Several functions use short, abbreviated variables names such as kptr, pptr, fptr, and prm. ",
        "Impact": "The finding does not have a direct security impact, but we believe it may lead to fu- ture bugs. Although this practice is common in C code, we nevertheless recommend against it. Variable names like these can lead to developer confusion, and ultimately, bugs. These variable names may also lead to the inadvertent misuse of the incorrect variable in place of the correct one. These simple coding mistakes are easy-to-make, hard-to-catch, and often critical in nature. It also makes the code more difficult for auditors and external developers to read, understand, and extend. ",
        "Recommendations": "Given the security-critical and high-assurance nature of the project, we recommend using longer, clearer, and more specific variable names in the future. For instance, pc_price_t *pptr could be instead named pc_price_t *price_ptr. Of course, cus- tomary variable names such as i for loop indices or n for count variables are still fine. ",
        "Remediation": "The finding has been acknowledged by Pyth Data Association. Their official response is reproduced below:  Pyth Data Association acknowledges the finding, but doesn't believe it has secu- rity implications. However, we may deploy a bug fix to address it.  Zellic 13 Pyth Data Association    4 Discussion  In this section, we discussmiscellaneous interesting observations during the audit that are noteworthy and merit some consideration.  Pyth's test suite includes a battery of fuzz tests. Currently, the fuzz testing covers the pd Pyth decimal library. We believe that generative tests, like fuzzing, are an excellent way to improve the security of a project. Thus, we developed a new fuzzing harness for Pyth's sorting algorithm implementation to augment Pyth's test suite.  The fuzzing harness is a straightforward C programwhich reads test cases from stdin, and calls Pyth's sorting library on it. To best reflect real-world conditions, our harness invokes the sorting library with the same parameters and instantiation as is used in Pyth. The harness tests sorting inputs of variable size and variable values. To validate correctness, the harness compares Pyth sort's results against libc's qsort as a ground truth. To validate memory safety, we compiled the harness with clang's AddressSan- itizer (ASAN) and MemorySanitizer (MSAN).  We ran the harness in two regimes: (1) \"dumb\", black-box fuzzing and (2) coverage- guided gray-box fuzzing. For black-box fuzzing, we simply piped /dev/urandom into the harness for each execution. We ran the harness under this regime for 12 hours on a 32-core machine. For coverage-guided fuzzing, we built and ran the harness under the AFL++ fuzzer. Under this regime, we ran 16 instances of the fuzzer for 12 hours on a 32-core machine. The results of the fuzz testing did not yield any memory safety or correctness violations.  To facilitate the integration of this new fuzz test into the development lifecycle as part of continuous integration, we also integrated the harness with LLVM libfuzzer.  As part of this engagement, we provided the fuzzing framework to Pyth Data Asso- ciation, and we recommend integrating fuzz tests with the existing test suite. Fuzzers expand branch, path, and state space coverage and decrease the likelihood of bugs. This is because fuzzers regularly catch corner cases that human programmers fail to consider whenwriting unit tests. Another benefit of fuzz testing is that developers can stress test business-critical invariants that are specific to the application. This ben- efits developer confidence, making the development lifecycle both faster and more secure.  Zellic 14 Pyth Data Association  https://github.com/AFLplusplus/AFLplusplus  \tAbout Zellic \tIntroduction \tAbout Pyth \tMethodology \tScope \tProject Overview \tDisclaimer  \tExecutive Summary \tDetailed Findings \tOut-of-bounds write in update test instruction \tLack of rent exemption enforcement \tInefficient publisher deletion algorithm results in excessive costs \tUnclear variable names can be potentially confusing  \tDiscussion "
    }
]