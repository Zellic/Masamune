[
    {
        "title": "3.1 The transferAVAX function allows arbitrary transfers",
        "target": " Vault.sol",
        "category": " Business Logic",
        "severity": " High",
        "likelihood": " Medium ",
        "impact": " High ",
        "bodyDescription": "The transferAVAX function is used to perform transfers of avax between two registered contracts.  function transferAVAX( string memory fromContractName, string memory toContractName, uint256 amount  ) external onlyRegisteredNetworkContract {  /) Valid Amount? if (amount =) 0) {  revert InvalidAmount(); } /) Emit transfer event emit AVAXTransfer(fromContractName, toContractName, amount);  /) Make sure the contracts are valid, will revert if not getContractAddress(fromContractName); getContractAddress(toContractName); /) Verify there are enough funds if (avaxBalances[fromContractName] < amount) {  revert InsufficientContractBalance(); } /) Update balances avaxBalances[fromContractName] = avaxBalances[fromContractName] - amount; avaxBalances[toContractName] = avaxBalances[toContractName] + amount;  }  Zellic 9 Multisig Labs    The current checks ensure that the msg.sender is a registeredNetworkContract; how- ever, the function lacks a check on whether the msg.sender actually calls the function or not. ",
        "bodyImpact": "Due to the fact that fromContractName can be an arbitrary address, a presumably ma- licious registeredNetwork contract can drain the avax balances of all the other regis- tered contracts. ",
        "bodyRecommendations": "We recommend removing the fromContractName parameter altogether and ensuring that the funds can only be transferred by the caller of the function, msg.sender.  function transferAVAX( /) @audit-info doesn't exist in rocketvault string memory fromContractName, string memory toContractName, uint256 amount  ) external onlyRegisteredNetworkContract {  /) Valid Amount? if (amount =) 0) {  revert InvalidAmount(); } /) Emit transfer event emit AVAXTransfer(msg.sender, toContractName, amount);  /) Make sure the contracts are valid, will revert if not getContractAddress(msg.sender); getContractAddress(toContractName); /) Verify there are enough funds if (avaxBalances[msg.sender] < amount) {  revert InsufficientContractBalance(); } /) Update balances avaxBalances[msg.sender] = avaxBalances[msg.sender] - amount; avaxBalances[toContractName] = avaxBalances[toContractName] + amount;  }  Zellic 10 Multisig Labs   ",
        "remediation": "The issue has been fixed by Multisig Labs in commit 84211f.  Zellic 11 Multisig Labs  https://github.com/multisig-labs/gogopool-contracts/commit/84211f5aa95488610f15456c5f6a1d454e7a9a9d  "
    },
    {
        "title": "3.2 Ocyticus does not include the Staking pause",
        "target": " Ocyticus, Staking",
        "category": " Business Logic",
        "severity": " High",
        "likelihood": " Medium ",
        "impact": " High ",
        "bodyDescription": "The pauseEverything and resumeEverything functions are used to restrict access to important functions.  function pauseEverything() external onlyDefender { ProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\")); dao.pauseContract(\"TokenggAVAX\"); dao.pauseContract(\"MinipoolManager\"); disableAllMultisigs();  }  ///)) @notice Reestablish all contract's abilities ///)) @dev Multisigs will need to be enabled seperately, we dont know which  ones to enable function resumeEverything() external onlyDefender {  ProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\")); dao.resumeContract(\"TokenggAVAX\"); dao.resumeContract(\"MinipoolManager\");  }  Apart from the TokenGGAvax and MinipoolManager, the Staking contract also makes use of the whenNotPaused modifier for its important functions. The paused state, will, however, not trigger at the same time with the pauseEverything call, since the Staking contract is omitted here, both for pausing and resuming. ",
        "bodyImpact": "Should an emergency arise, pauseEverything will be called. In this case, Staking will be omitted, which could put user funds in danger. ",
        "bodyRecommendations": "We recommend ensuring that the Staking contract is also paused in the pauseEveryt hing function as well as un-paused in the resumeEverything function.  Zellic 12 Multisig Labs    function pauseEverything() external onlyDefender { ProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\")); dao.pauseContract(\"TokenggAVAX\"); dao.pauseContract(\"MinipoolManager\"); dao.pauseContract(\"Staking\"); disableAllMultisigs();  }  ///)) @notice Reestablish all contract's abilities ///)) @dev Multisigs will need to be enabled seperately, we dont know which  ones to enable function resumeEverything() external onlyDefender {  ProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\")); dao.resumeContract(\"TokenggAVAX\"); dao.resumeContract(\"MinipoolManager\"); dao.resumeContract(\"Staking\");  } ",
        "remediation": "The issue has been fixed by Multisig Labs in commit dbc499.  Zellic 13 Multisig Labs  https://github.com/multisig-labs/gogopool-contracts/commit/dbc499989a171719194c5d2649e3b0a5a5cb0606  "
    },
    {
        "title": "3.3 The reward amount manipulation",
        "target": " ClaimNodeOp.sol",
        "category": " Business Logic",
        "severity": " High",
        "likelihood": " Medium ",
        "impact": " High  Descriptions  A staker is eligible for the upcoming rewards cycle if they have staked their tokens for a long enough period of time. The reward amount is distributed in proportion to the amount of funds staked by the user from the total amount of funds staked by all users who claim the reward. But since the rewardsStartTime is the time of creation of only the first pool, and during the reward calculations all staked funds are taken into account, even if they have not yet been blocked and can be withdrawn, the attack described below is possible.  The attack scenario:  1. An attacker stakes ggp tokens and creates a minipool with a minimum avaxAssi gnmentRequest value.  2. Themultisig initiates the staking process by calling the claimAndInitiateStaking function.  3. Wait for the time of distribution of rewards.  4. Before the rewarddistribution process begins, the attacker creates a newminipool with the maximum avaxAssignmentRequest value.  5. Initiate the reward distribution process.  6. Immediately after that, the attacker cancels the minipool with cancelMinipool function before the claimAndInitiateStaking function call and returnsmost part of their staked funds. ",
        "bodyImpact": "The attacker can increase their reward portion without actually staking their own funds. ",
        "bodyRecommendations": "Take into account only the funds actually staked, or check that all minipools have been launched.  Zellic 14 Multisig Labs   ",
        "remediation": "The issue has been fixed by Multisig Labs in commits c90b2f and f49931.  Zellic 15 Multisig Labs  https://github.com/multisig-labs/gogopool-contracts/commit/c90b2f6b9f92221bfa6336f5a37a5a9c4e32faba https://github.com/multisig-labs/gogopool-contracts/commit/f49931a059a7ce0f0941d58c1031ba5a4445a96f  "
    },
    {
        "title": "3.4 Network registered contracts have absolute storage control",
        "target": " Project-wide",
        "category": " Business Logic",
        "severity": " High",
        "likelihood": " Low ",
        "impact": " High ",
        "bodyDescription": "The network-registered contracts have absolute control over the storage that all the contracts are associated with through the Storage contract. This is inherent due to the overall design of the protocol, whichmakes use of a single Storage contract eliminating the need of local storage. For that reason any registeredContract can update any storage slot even if it \"belongs\" to another contract.  modifier onlyRegisteredNetworkContract() { if (booleanStorage[keccak256(abi.encodePacked(\"contract.exists\", msg.sender))] =) false &) msg.sender !) guardian) {  revert InvalidOrOutdatedContract(); } _;  }  /) ...)) function setAddress(bytes32 key, address value)  external onlyRegisteredNetworkContract { addressStorage[key] = value;  }  function setBool(bytes32 key, bool value) external onlyRegisteredNetworkContract { booleanStorage[key] = value;  }  function setBytes(bytes32 key, bytes calldata value) external onlyRegisteredNetworkContract { bytesStorage[key] = value;  }  As an example, the setter functions inside the Staking contract have different restric- tions for caller (e.g., the setLastRewardsCycleCompleted function can be called only by ClaimNodeOp contract), but actually the setUint function from it may be called by any  Zellic 16 Multisig Labs    RegisteredNetworkContract. ",
        "bodyImpact": "Webelieve that in a highly unlikely case, amalicious networkRegistered contract could potentially alter the entire protocol Storage to theirwill. Additionally, if itwere possible to setBool of an arbitrary address, then this scenario would be further exploitable by a malicious developer contract. ",
        "bodyRecommendations": "We recommend paying extra attention to the registration of networkContracts, as well as closelymonitoringwhere andwhen the setBool function is used, since the network registration is based on a boolean value attributed to the contract address. ",
        "remediation": "The issue has ben acknowledged by the Multisig Labs. Their official reply is repro- duced below:  While it is true that any registered contract can write to Storage, we view all of the separate contracts comprising the Protocol as a single system. A single entity (either the Guardian Multisig or in future the ProtocolDAO) will be in control of all of the contracts. In this model, if an attacker can register a single malicious contract, then they are also in full control of the Protocol itself. Because all of the contracts are treated as a single entity, there is no additional security benefit to be gained by providing access controls between the various contract's storage slots. As a mitigation, the Protocol will operate several distributedWatchers that will continually scan the central Storage contract, and alert on any changes.  Zellic 17 Multisig Labs   "
    },
    {
        "title": "3.5 Oracle may reflect an outdated price",
        "target": " Oracle",
        "category": " Business Logic",
        "severity": " Medium",
        "likelihood": " Medium ",
        "impact": " Medium ",
        "bodyDescription": "Some functions at protocol-level make use of the getGGPPriceInAvax. This getter re- trieves the price, which is set by the Rialtomultisig.  ///)) @notice Get the price of GGP denominated in AVAX ///)) @return price of ggp in AVAX ///)) @return timestamp representing when it was updated function getGGPPriceInAVAX() external view returns (uint256 price,  uint256 timestamp) { price = getUint(keccak256(\"Oracle.GGPPriceInAVAX\")); if (price =) 0) {  revert InvalidGGPPrice(); } timestamp = getUint(keccak256(\"Oracle.GGPTimestamp\"));  }  Due to the nature of on-chain price feeds, Oracles need to have an as-often-as- possible policy in regards to how often the price gets updated. For that reason, the reliance on the Rialto may be problematic should it fail to update the price often enough. ",
        "bodyImpact": "Should the price be erroneous, possible front-runs may happen at the protocol level, potentially leading to a loss of funds on the user-end side. ",
        "bodyRecommendations": "We recommend implementing a slippage check, which essentially does not allow a price to be used should it have been updated more than x blocks ago. ",
        "remediation": "The finding has been acknowledged by the Multisig Labs team. Their official reply is reproduced below:  Zellic 18 Multisig Labs    The price of GGP is used in the Protocol to determine collateralization ratios for minipools as well as slashing amounts. If the price of GGP is unknown or out- dated, the protocol cannot operate. So our remediation for this will be to have a distributed set ofWatchers that will Pause the Protocol if the GGP Price becomes outdated. At some point in the future the Protocol will use on-chain TWAP price oracles to set the GGP price.  Zellic 19 Multisig Labs   "
    },
    {
        "title": "3.6 Fields are not reset exactly after their usage",
        "target": " MinipoolManager",
        "category": " Business Logic",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "Due to the nature of the protocol, some fields are queried and used in one interme- diary state of the application and then reset in the last state of the application. As an example, see the avaxNodeOpRewardAmt value, which is queried and used in withdrawM inipoolFunds (which can only be called in the WITHDRAWABLE stage)  function withdrawMinipoolFunds(address nodeID) external nonReentrant { int256 minipoolIndex = requireValidMinipool(nodeID); address owner = onlyOwner(minipoolIndex); requireValidStateTransition(minipoolIndex, MinipoolStatus.Finished); setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Finished));  uint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")));  uint256 avaxNodeOpRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpRewardAmt\")));  uint256 totalAvaxAmt = avaxNodeOpAmt + avaxNodeOpRewardAmt;  Staking staking = Staking(getContractAddress(\"Staking\")); staking.decreaseAVAXStake(owner, avaxNodeOpAmt);  Vault vault = Vault(getContractAddress(\"Vault\")); vault.withdrawAVAX(totalAvaxAmt); owner.safeTransferETH(totalAvaxAmt);  }  and then either reset in the recordStakingEnd function, to the new rounds' avaxNodeO pRewardAmt, or set to 0 in recordStakingError.  The protocol's structure assumes that the way in which the states are transitioned  Zellic 20 Multisig Labs    through is consistent. ",
        "bodyImpact": "Shouldmajor changes occur in the future of the protocol, we suspect that some states that are presumably reset in an eventual state of the protocol may be omitted. This could in turn lead to unexpected consequences to the management of the minipool. ",
        "bodyRecommendations": "We highly recommend that once important storage states are used, they should also be reset. In this way, future versions of the protocol will have a solid way of transi- tioning without requiring additional synchronization of storage state. ",
        "remediation": "The issue has ben acknowledged by the Multisig Labs. Their official reply is repro- duced below:  The Protocol maintains some fields in Storage so that data such as avaxNodeO- pRewardAmt can be displayed to the end user. The fields will be reset if the user relaunches aminipool with the same nodeID again in the future. This is by design.  Zellic 21 Multisig Labs   "
    },
    {
        "title": "3.7 Contracts can deposit arbitrary tokens in the Vault",
        "* Target": " Vault.sol",
        "* Category": " Business Logic",
        "* Likelihood": " Medium ",
        "* Severity": " Low",
        "* Impact": " Informational ",
        "Description": "Multiple functions from the Vault contract allow arbitrary tokens to be deposited and withdrawn by networkRegistered contracts. For example, see the depositToken func- tion:  function depositToken(string memory networkContractName, ERC20 tokenContract, uint256 amount  ) external guardianOrRegisteredContracts { /) Valid Amount? if (amount =) 0) {  revert InvalidAmount(); } /) Make sure the network contract is valid (will revert if not) getContractAddress(networkContractName);  /) Get contract key bytes32 contractKey = keccak256(abi.encodePacked(networkContractName, address(tokenContract))); /) Emit token transfer event emit TokenDeposited(contractKey, address(tokenContract), amount); /) Send tokens to this address now, safeTransfer will revert if it fails tokenContract.safeTransferFrom(msg.sender, address(this), amount); /) Update balances tokenBalances[contractKey] = tokenBalances[contractKey] + amount;  } ",
        "Impact": "As per the current implementation, there are no security implications. However, we consider that the Vault plays an essential role in the entire protocol, and thuswe highly recommend fixing this issue for posterity.  Zellic 22 Multisig Labs   ",
        "Recommendations": "Upon discussions with the Multisig Lab team, we settled that the best mitigation is whitelisting the tokenContract that are used in each function. This further allows flexibility and security in smoothly upgrading the Vault should it support more tokens. In that case, the mitigated version of the function could be:  function depositToken(string memory networkContractName, ERC20 tokenContract, uint256 amount  ) external guardianOrRegisteredContracts {  require(whitelisted[tokenContract], \"tokenContract not whitelisted\");  if (amount =) 0) { revert InvalidAmount();  }  /) ...)) ",
        "Remediation": "The issue has ben acknowledged by the Multisig Labs and they have determined that the amounts would not be significant.  Zellic 28 Multisig Labs  https://github.com/multisig-labs/gogopool-contracts/commit/f49931a059a7ce0f0941d58c1031ba5a4445a96f   5 Threat Model  The purpose of this section is to provide a full threat model description for each func- tion.  As time permitted, we analyzed each function in the smart contracts and created a written threat model for some critical functions. A threat model documents a given function's externally controllable inputs and how an attacker could leverage each in- put to cause harm.  5.1 File: TokenggAVAX  Function: initialize()  Intended behavior:  * Should initialize all state variables and function calls required for the contract to function.  Branches and code coverage:  Intended branches:  * Should be callable by anyone? # Test coverage  * Should be called after every upgrade. # Test coverage  Negative behavior:  * Shouldn't allow 2 x calling this. 4# Negative test?  Preconditions:  * Assumes it's not callable by anyone, or that there's no way someone can front- run this transaction  * Assumes that the Storage is adequately configured (should be fine, since guard ian role is assigned in the constructor, for the msg.sender  Zellic 29 Multisig Labs    Inputs:  * asset: - Control: full control  - Checks: no checks  - Impact: used as underlying asset for the vault * storageAddress:  - Control: full control  - Checks: no checks  - Impact: used as upgradeable storage contract.  Function: receive()  Intended behavior:  This function is used for receiving native tokens. It can be called only by the asset address.  Branches and code coverage:  Intended branches:  * Allow asset contract to send native tokens to contract. 4# Test coverage  Negative behavior:  * It cannot be called from any other address. 4# Negative test?  Preconditions:  * the asset should be set after initialize call  Inputs:  * msg.value: - Control: controllable  - Authorization: no  - Impact: - * msg.sender:  - Control: controllable  - Authorization: assert(msg.sender =) address(asset)); - Impact: only accept AVAX via fallback from the WAVAX contract. Oth-  Zellic 30 Multisig Labs    erwise, the balance information may be out of sync.  External call analysis  There are no external calls here.  Function: syncRewards()  Intended behavior:  * Should \"distribute rewards\" to TokenggAVAX holders. Anyone may call this.  lastSync - time of last successful call to this function  rewardsCycleEnd - the time when the total reward will be available;  totalReleasedAssets - the full amount of available tokens for withdrawal + the last reward value from the previous cycle. If the reward was not withdrawn immediately after the end of the cycle when the function syncRewards is called for the next cycle, lastRewardsAmt valuewill be added to the value totalReleasedAssets, and this reward still will be available for withdrawal.  Branches and code coverage:  Intended branches:  * rewardsCycleEnd = deadline for next rewardsCycle # Test coverage  * lastSync = current timestamp # Test coverage  * lastRewardsAmt_ = to the amount that rewards will deplete from. 4# Test coverage  * totalReleasedAssets is calculated correctly for the next cycle - not sure that it is calculated correctly because it happens differently during initialize call # Test coverage  * lastRewardsAmt is calculated for the next cycle if the new rewardwas deposited. # Test coverage  * if rewards didn't deposit, the lastRewardsAmtwill equal 0 for the next cycle # Test coverage  * lastRewardsAmt is calculated correctly and equals 0 for the first cycle # Test coverage  * if nothing changed since the past cycle lastRewardsAmt is calculated correctly and equals 0 and totalReleasedAssetswas increased by the previous lastRewa rdsAmt  Zellic 31 Multisig Labs    # Test coverage * current block.timestamp should be less than rewardsCycleEnd  4# Test coverage  Negative behavior:  * It basically shouldn't update unless stuff unless it's really time to update stuff(see below) # Negative test?  * Shouldn't allow calling unless the rewardsCycle has passed the block.timestamp. 4# Negative test?  Preconditions:  * Assumes that the state variables(lastRewardsAmt, lastSync , rewardsCycleEnd and totalReleasedAssets are properly updated)  * Can be called by anyone.  Inputs:  Function call analysis  * asset.balanceOf(address(this)) - What is controllable? The amount of returned value  - If return value controllable, how is it used and how can it go wrong? It can grow if the asset is artificially pumped in the contract;  - What happens if it reverts, reenters, or does other unusual control flow? Doesn't revert.  Function: totalAssets()  Intended behavior:  * This function returns the total amount of underlying assets held by the vault.  Branches and code coverage:  Intended branches:  * After the current cycle ends and the new one starts, the totalAssets amount will contain the past lastRewardsAmt value. # Test coverage  * totalAssets is calculated correctly if the current cycle is going. # Test coverage  Zellic 32 Multisig Labs    * If the current cycle ends and the new one doesn't start, the totalAssets should be equal totalReleasedAssets_ + lastRewardsAmt # Test coverage  Negative behavior:  * There's multiple types of uints there, should ensure that there's no way that any of them can overflow and block the functionality of the contract. # Negative test?  * must not revert(as per eip4626) # Negative test?  Preconditions:  * Assumes lastSync is different than 0 (default value, which is never initialized)? this is missing  * assumes that block.timestamp is safecasted? just as in syncRewards(currently missing)  Inputs:  There aren't input values here.  Function call analysis  There aren't function calls here.  Function: depositFromStaking()  Intended behavior:  * Should allow converting native AVAX tokens to wAVAX (just like wETH) * Allows to MinipoolManager contract returnwithdrawn funds anddeposit reward.  * It is assumed that, at first will be called MinipoolManager.sol:createMinipool function, which call depositAVAX and after that caller will be able to call withd rawForStaking for previously deposited value over MinipoolManager.sol: claim AndInitiateStaking and only after that depositFromStaking can be called over recordStakingEnd or recordStakingError functions from MinipoolManager.sol  Branches and code coverage:  Intended branches:  * the asset balance of the current contract will increase by the msg.value after the  Zellic 33 Multisig Labs    call # Test coverage  * stakingTotalAssetswill decrease by the baseAmt value after the call # Test coverage  * baseAmt + rewardAmt should be equal msg.value # Test coverage  Negative behavior:  * Shouldn't be callable by anyone(there's a check put in place, such that only onl ySpecificRegisteredContract can call the function.  4# Negative test? * if stakingTotalAssets is less than baseAmt transaction will be rejected  4# Negative test?  Preconditions:  * stakingTotalAssets should contain a value more or equal to baseAmt. It means that this value should have been withdrawn over withdrawForStaking function  * msg.sender should be approved for a call  Inputs:  * msg.value: - Control: controlled, but actually, it is the value from getUint(keccak256(abi  .encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\") ));  - Checks: should be equal baseAmt + rewardAmt - Impact: -  * msg.sender: - Control: only approved MinipoolManager contract  - Checks: onlySpecificRegisteredContract(\"MinipoolManager\", msg.sende r)  - Impact: function should be called only from trusted MinipoolManager con- tract  * uint256 rewardAmt: - Control: partly controlled  - Checks: msg.value == baseAmt + rewardAmt - Impact: -  * uint256 baseAmt: - Control: partly controlled  Zellic 34 Multisig Labs    - Checks: msg.value == baseAmt + rewardAmt - Impact: -  Function call analysis  * IWAVAX(address(asset)).deposit{value: totalAmt}(); - What is controllable? the totalAmt is basically msg.value - If return value controllable, how is it used and how can it go wrong? na  - What happens if it reverts, reenters, or does other unusual control flow? na  Function: withdrawForStaking()  Intended behavior:  * Should perform the withdrawal from wAVAX , for the MinipoolManager  Branches and code coverage:  Intended branches:  * wAVAX.balanceOf(address(this)) -= assets and balanceOf(msg.sender) += as sets # Test coverage  Negative behavior:  * Shouldn't allow unlimited amount to be withdrawn 4# Negative test?  * Shouldn't be callable when it's paused(has the whenNotPaused) modifier 4# Negative test?  * if assetsmore than the amountAvailableForStaking transaction will be rejected 4# Negative test?  * if asset.balanceOf(address(this)) is less than assets transaction will be re- jected # Negative test?  * if msg.sender is not approved transaction will be rejected # Negative test?  Preconditions:  * Assumes that there has been some depositFromStaking beforehand. * Assumes that the same MinipoolManager deposited the amount. And that there  Zellic 35 Multisig Labs    cannot be any issues should one deposit and someone else (with same role) withdraw.  Inputs:  * assets: - Control: full control  - Checks: assets > amountAvailableForStaking()  - Impact: arbitrary input for the amount of assets that are to be withdrawn from the wAVAX  * msg.sender: - Control: only approved MinipoolManager contract  - Checks: onlySpecificRegisteredContract(\"MinipoolManager\", msg.sende r)  - Impact: since the caller can withdraw any amount of funds through this function, it is critically important that it is called only by a trusted contract.  Function call analysis  * withdrawer.receiveWithdrawalAVAX{value: assets}(); - What is controllable? the assets, withdrawer; it basically calls the receive  WithdrawalAVAX on the msg.sender!!! Really important - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? reenters: no problems because the contract being called is trusted. re- verts: no problems  * IWAVAX(address(asset)).withdraw(assets); - What is controllable? the assets value; the asset address is state var - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: depositAVAX compare with deposit() from inherited  Intended behavior:  * Allows any user to deposit AVAX in exchange for wAVAX. It basically doesn't trans- fer the wAVAX back to the user, it keeps it and issues shares to the user.  Zellic 36 Multisig Labs    Branches and code coverage:  Intended branches:  * previewDeposit should issue the amount of shares correctly!! 4# Test coverage  * Should transfer the wAVAX back to the user. 4# Test coverage  * Should exchange user's supplied AVAX into wAVAX 4# Test coverage  Negative behavior:  * Shouldn't issue more or less shares than intended. 4# Negative test?  Preconditions:  * Assumes users would use this function to deposit, rather than depositing on their own.  * Assumes previewDeposit calculates the amount of shares correctly.  Inputs:  * IWAVAX(address(asset)).deposit() - What is controllable? assets - the amount of deposited native tokens - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * afterDeposit() - What is controllable? assets - the amount of deposited native tokens - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * _mint() - What is controllable? msg.sender - is minted tokens receiver address - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Zellic 37 Multisig Labs    * previewDeposit()  convertToShares() - What is controllable? assets - the amount of deposited native tokens - If return value controllable, how is it used and how can it go wrong? if there are any mistakes during shares value calculations, then caller will get more or less shares than expected. If more then caller will be able to drain other users funds, if less then caller will withdraw less native tokens that was deposited.  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: withdrawAvax() compare this with withdraw() from inherited  Intended behavior:  * Supposed to withdraw wAVAX on behalf of the msg.sender, and then transfer the native AVAX back to the msg.sender.  Branches and code coverage:  Intended branches:  * the wavax balance of the contract should decrease(by assets) 4# Test coverage  * the avax balance of user should increase( by assets) # Test coverage  * the shares of the user should decrease(by shares) 4# Test coverage  * make sure that preivewWithdraw calculates the shares properly, in all market conditions # Test coverage  Negative behavior:  * shouldn't allow withdrawing if _burn reverted # Negative test?  * shouldn't allow burning on behalf of other users 4# Negative test?  Preconditions:  * Assumes there are no rounding errors in previewWithdraw or other similar arith- metic issues.  * Assumes that user has enough shares to actually withdraw enough wAVAX  Zellic 38 Multisig Labs    Inputs:  * assets: - Control: full control; the amount of assets that the user intends to with- draw.  - Checks: there is no check here, however, it's assumed that previewWithdra w calculates the amount of shares properly, and then that _burn fails should the msg.sender not have enough shares to actually receive the amount of assets.  - Impact: arbitrary input for the amount of assets that are to be withdrawn from the wAVAX  * msg.sender: - Control: any caller  - Checks: must have the appropriate amount of shares  - Impact: the caller will receive the appropriate amount of native tokens  Function call analysis  * previewWithdraw(assets) - What is controllable? the assets parameter;  - If return value controllable, how is it used and how can it go wrong? re- turn the amount of shares. In case of wrong calculations a caller can burn an excessive number of shares or, conversely, burn too few and receive disproportionately many native tokens.  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * IWAVAX(address(asset)).withdraw(assets); - What is controllable? the assets value; the asset address is state var - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: redeemAVAX() compare with redeem() from inherited  Intended behavior:  * Should redeem the shares for underlying native avax. Similar to how withdraw works.  Zellic 39 Multisig Labs    Branches and code coverage:  * No test coverage  Intended branches:  * assets value is calculated correcly # Test coverage  * totalReleasedAssets is decreased by assets value # Test coverage  * msg.sender received the assets amount of native tokens # Test coverage  * token gg balance of msg.sender is decreased by shares value # Test coverage  Negative behavior:  * shouldn't allow withdrawing if _burn reverted 4# Negative test?  * shouldn't allow burning on behalf of other users # Negative test?  * revert if contract.paused is True 4# Negative test?  Preconditions:  * Assumes that user has enough shares to burn.  Inputs:  * shares: - Control: controlled  - Checks: balance of msg.sender should be more or equal of shares amount - Impact: the number of gg tokens that the user can burn and receive a cer- tain number of native tokens.  * msg.sender: - Control: any caller  - Checks: must have the appropriate amount of shares  - Impact: the caller will receive the appropriate amount of native tokens  Function call analysis  * previewRedeem(shares)  Zellic 40 Multisig Labs    - What is controllable? the shares parameter;  - If return value controllable, how is it used and how can it gowrong? return the amount of assets. In case ofwrong calculations a caller can receive a lot (thereby stealing other users funds) or, conversely, too few native tokens.  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * IWAVAX(address(asset)).withdraw(assets); - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? no problems  5.2 File: ClaimNodeOP  Function: calculateAndDistributeRewards()  Intended behavior:  * Set the share of rewards that a staker is owed.(Fraction of 1 ether)  Branches and code coverage:  Lacks extensive testing.  Intended branches:  * Update the rewardsCycleCount of staker. # Test coverage  * Ensure calculations are properly performed. # Test coverage  * Increase the ggpRewards for the stakerAddr based on the input totalEligibleGG PStaked.  4# Test coverage  Negative behavior:  * Should fail if stakerAddr is not eligible for rewards. 4# Negative test?  Preconditions:  * Assumes stakerAddr is a valid one.  Zellic 41 Multisig Labs    * Assumes that the caller has used the correct totalEligibleGGPStaked amount.  Inputs:  * msg.sender: - Control: -  - Checks: onlyMultisig  - Impact: the access to this function should be restricted because this func- tion allows to assign any part of reward budget to any stakerAddr.  * stakerAddr: - Control: full control  - Checks: no checks at this level; But will revert during the increaseGGPRewa rds function call.  - Impact: the address of valid staker who can claim the reward. * totalEligibleGGPStaked:  - Control: full control  - Checks: there aren't checks  - Impact: the total amount of staked funds, from which the percentage of reward to stakerAddrwill be calculated. So this value allow to control the reward part for stakerAddr.  Function call analysis  * staking.getLastRewardsCycleCompleted(stakerAddr) - What is controllable? stakerAddr is controllable - If return value controllable, how is it used and how can it go wrong? if someone will be able to manipulate lastRewardsCycleCompleted value, the stakerAddrwill be able to double receive the reward.  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * staking.getEffectiveGGPStaked(stakerAddr); - What is controllable? stakerAddr is controllable - If return value controllable, how is it used and how can it go wrong? the amount of staked tokens is used to calculate the percentage of the total staked tokens.  - What happens if it reverts, reenters, or does other unusual control flow? no problem  * staking.setLastRewardsCycleCompleted(stakerAddr, rewardsPool.getRewardsCy cleCount()); - What is controllable? stakerAddr is controllable  Zellic 42 Multisig Labs    - If return value controllable, how is it used and how can it go wrong? there isn't return value.  - What happens if it reverts, reenters, or does other unusual control flow? no problem  * staking.resetAVAXAssignedHighWater(stakerAddr); - What is controllable? stakerAddr is controllable - If return value controllable, how is it used and how can it go wrong? there isn't return value.  - What happens if it reverts, reenters, or does other unusual control flow? no problem  * staking.increaseGGPRewards(stakerAddr, rewardsAmt); - What is controllable? stakerAddr is controllable - If return value controllable, how is it used and how can it go wrong? there isn't return value.  - What happens if it reverts, reenters, or does other unusual control flow? no problem  * staking.setRewardsStartTime(stakerAddr, 0); - What is controllable? stakerAddr is controllable - If return value controllable, how is it used and how can it go wrong? there isn't return value.  - What happens if it reverts, reenters, or does other unusual control flow? no problem  Function: claimAndRestake()  Intended behavior:  * Allows msg.sender to claim the rewards they were allocated.  Branches and code coverage:  Lacks extensive testing.  Intended branches:  * Should decrease rewards balance of msg.sender 4# Test coverage  * Restake the amount of ggpRewards - claimAmt # Test coverage  Negative behavior:  * Should not allow claiming more than msg.senderwas owed  Zellic 43 Multisig Labs    4# Negative test?  Preconditions:  * Assumes msg.sender has some rewards * Assume that the vault holds enough tokens to pay the rewards for msg.sender.  Inputs:  * msg.sender: - Control: -  - Checks: if the ggpRewards value is zero, will revert. - Impact: the address who owns non zero reward value.  * claimAmt: - Control: full control  - Checks: should not be more that the reward: claimAmt > ggpRewards  - Impact: the amount of withdrawn funds, the surplus will be restake.  Function call analysis  * vault.withdrawToken(address(this), ggp, restakeAmt) - What is controllable? restakeAmt is controllable - If return value controllable, how is it used and how can it go wrong? there is no return value here.  - What happens if it reverts, reenters, or does other unusual control flow? will revert if there are not enough tokens.  * staking.getGGPRewards(msg.sender) - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? re- turn value is used for calculating the amount of rewards that msg.sender is owed.  - What happens if it reverts, reenters, or does other unusual control flow? no problems  5.3 File: ClaimProtocolDAO.sol  Function: spend()  Intended behavior:  Allows to spend the ProtocolDAO's GGP rewards  Zellic 44 Multisig Labs    Branches and code coverage:  Intended branches:  * The balance of recipientAddress is increased by amount; there is a revert put in place in case transfer fails.  4# Test coverage  Negative behavior:  * should be rejected if this contract has not enough ggp tokens in the vault.toke nBalance  4# Negative test? * should reject if msg.sender isn't the guardian  4# Negative test?  Preconditions:  * msg.sender is the guardian * tokens should be transferred to ClaimProtocolDAO contract over the vault.tran  sferToken function  Inputs:  * amount: - Control: limited control  - Checks: amount ==0 || amount > vault.balanceOfToken(\"ClaimProtocolDAO\", ggpToken)  - Impact: * recipientAddress:  - Control: controlled  - Checks: there aren't checks here  - Impact: since there are no address checks, in case of a mistake, tokens can be transferred to the wrong user.  * invoiceID: - Control: controlled  - Checks: there aren't checks here  - Impact: no impact * msg.sender:  - Control: -  - Checks: onlyGuardian  - Impact: it allows caller to withdraw the entire balance of ggpToken of this  Zellic 45 Multisig Labs    contract from vault. The access to this function should be restricted.  Function call analysis  * vault.withdrawToken() - What is controllable? recipientAddress, amount  - If return value controllable, how is it used and how can it go wrong? there is no return value here  - What happens if it reverts, reenters, or does other unusual control flow? will revert if msg.sender doesn't have enough tokens  5.4 File: BaseUpgradeable.sol  The contract is inherited from BaseAbstract.sol and Initializable.sol (@openzeppelin/contracts- upgradeable/proxy/utils/Initializable.sol);  Function: __BaseUpgradeable_init()  Allows to initialize the gogoStorage storage address. The function is internal and can be called only once due to onlyInitializingmodifier.  5.5 File: Base.sol  The contract is inherited from BaseAbstract.sol; The contract contains only construc torwith initialization of gogoStorage address.  5.6 File: BaseAbstract.sol  Function: setters()  Intended behavior:  Allows you to make changes to the data stored in the shared storage. All function is internal, therefore, they cannot be called directly. But they are called from various functions from inherited contracts.  5.7 File: Storage.sol  Zellic 46 Multisig Labs    Function: setGuardian()  Intended behavior: Allow to reassign the guardian address. But to complete this pro- cess the new guardian should call confirmGuardian function.  Branches and code coverage:  Intended branches:  * After successful call the guardian address didn't change. 4# Test coverage  Negative behavior:  * Reject if msg.sender isn't the guardian; check put in place. 4# Negative test?  Preconditions:  msg.sender is current guardian.  Inputs:  * msg.sender: - Control: -  - Checks: msg.sender != guardian  - Impact: due to the guardian having a lot of control over the protocol, it's critically important that an untrusted caller doesn't have access to this func- tion.  Function call analysis  There aren't external calls here.  Function: confirmGuardian()  Intended behavior: Allow to reassign the guardian address. But to complete this pro- cess the new guardian should call confirmGuardian function.  Branches and code coverage:  Intended branches:  * After successful call the guardian address is equal to msg.sender and newGuardi an.  Zellic 47 Multisig Labs    4# Test coverage  Negative behavior:  * Reject if msg.sender isn't the newGuardian; check put in place. 4# Negative test?  Preconditions:  The current guardian called the setGuardian function and msg.sender became the new Guardian.  Inputs:  * msg.sender: - Control: -  - Checks: msg.sender != newGuardian - Impact: due to the guardian having a lot of control over the protocol, it's critically important that an untrusted caller doesn't have access to this func- tion.  Function call analysis  There aren't external calls here.  Function: setters()  Intended behavior:  * Should be used among more contracts as a shared means of storage  Branches and code coverage:  Intended branches:  * Should update the {type} of value located at each particular key. # Test coverage; Limited test coverage  Negative behavior:  * Network registered contracts shouldn't abuse the booleanStorage[keccak256(a bi.encodePacked(\"contract.exists\", msg.sender))] modifier. Basically once a contract is whitelisted, it can remove/register other contracts as network regi stered, or modify any other states altogether. # Negative test?  Zellic 48 Multisig Labs    Preconditions:  * Assumes that msg.sender handles the states properly, and doesn't have typos when reading / updating specific states. Basically all functions that interact with the getters/ setters/ deleters from other contracts should be extremely well tested.  5.8 File: TokenGGP.sol  The contract is standard ERC20 from @rari-capital/solmate/src/tokens/ERC20.sol.  5.9 File: Vault.sol  Function: depositAVAX()  Intended behavior:  Allows registered contract to deposit avax.  Branches and code coverage:  Intended branches:  * avaxBalances of msg.sender increased by msg.value 4# Test coverage  Negative behavior:  * if msg.sender is not RegisteredNetworkContract transaction will be reverted 4# Negative test?  * if msg.value == 0, will be reverted 4# Negative test?  Preconditions:  * msg.sender should be registered by the guardian  Inputs:  * msg.sender: - Control: -  - Checks: onlyRegisteredNetworkContract  - Impact: no impact  Zellic 49 Multisig Labs    * msg.value: - Control: limited control  - Checks: msg.value == 0  - Impact: no impact  Function call analysis  There aren't external calls here.  Function: withdrawAVAX()  Intended behavior:  Allows registered contract to withdraw the deposited avax.  Branches and code coverage:  Intended branches:  * after the call avaxBalances[msg.sender] decreased by amount 4# Test coverage  Negative behavior:  * if msg.sender is not RegisteredNetworkContract transaction will be reverted # Negative test?  * if avaxBalances[msg.sender] < amount, transaction will be reverted 4# Negative test?  Preconditions:  * avaxBalances of msg.sender  amount * msg.sender should be registered contract by guardian  Inputs:  * msg.sender: - Control: -  - Checks: onlyRegisteredNetworkContract  - Impact: should has non zero balance for withdraw * amount:  - Control: controlled  - Checks: avaxBalances[getContractName(msg.sender)] < amount  - Impact: must withdraw only his tokens  Zellic 50 Multisig Labs    Function call analysis  * withdrawer.receiveWithdrawalAVAX() - What is controllable? amount - partly controlled, the avaxBalances[msg.s  ender] >) amount - If return value controllable, how is it used and how can it go wrong? there isn't a return value here  - What happens if it reverts, reenters, or does other unusual control flow? function is nonReentrant and state is updated before the external call.  Function: transferAVAX()  Intended behavior:  Allows transferring the balance from one registered contract to another.  Allows a transfer, not from the owner, and there is also no check for an allowance from the owner  Branches and code coverage:  Intended branches:  * avaxBalances[toContractName] is increased amount 4# Test coverage  * avaxBalances[fromContractName] is decreased by amount 4# Test coverage  Negative behavior:  * Should be rejected if avaxBalances[fromContractName] < amount 4# Negative test?  * Should be rejected if toContractName and fromContractName is not added to gogoS- torage  4# Negative test? * Should be rejected if msg.sender is not fromContractName  # Negative test?  Preconditions:  * toContractName and fromContractName is added to gogoStorage * msg.sender is RegisteredNetworkContract * avaxBalances[fromContractName]  amount  Zellic 51 Multisig Labs    Inputs:  * toContractName: - Control: controlled  - Checks: contract name should be saved inside gogoStorage  - Impact: in the case of an incorrect recipient, funds may be lost. * fromContractName:  - Control: controlled  - Checks: contract name should be saved inside gogoStorage  - Impact: the contractwhich fundswill be transferred, in this case themsg.sender has full control  * msg.sender: - Control: -  - Checks: onlyRegisteredNetworkContract  - Impact: - * amount:  - Control: controlled  - Checks: avaxBalances[fromContractName] < amount - Impact: -  Function call analysis  There aren't external calls here.  Function: depositToken()  Intended behavior:  Allows registered contract to deposit any tokens  Branches and code coverage:  Intended branches:  * tokenBalances of networkContractNamecontractKey is increased by amount 4# Test coverage  Negative behavior:  * Should reject if msg.sender is not guardianOrRegisteredContracts 4# Negative test?  Zellic 52 Multisig Labs    Preconditions:  * msg.sender has enough tokens * msg.sender is guardianOrRegisteredContracts  Inputs:  * amount: - Control: limited control  - Checks: amount == 0  - Impact: no problems * tokenContract:  - Control: full control  - Checks: there isn't checks here  - Impact: address of external contract to be called * networkContractName:  - Control: limited control  - Checks: contract name should be saved inside gogoStorage  - Impact: the recipient of tokens, in the case of an incorrect recipient, funds may be lost.  Function call analysis  * tokenContract.safeTransferFrom() - What is controllable? amount - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? will revert if msg.sender doesn't have enough tokens  Function: withdrawToken()  Intended behavior:  * Allow registered msg.sender to withdraw ERC20 tokens.  Branches and code coverage:  Intended branches:  * Check withdrawalAddress? 4# Test coverage  Zellic 53 Multisig Labs    * Decrease tokenBalance[paid(caller, token)] 4# Test coverage  * Validate the tokenContract, such that no arbitrary tokens can be used. # Test coverage  Negative behavior:  * Shouldn't allow withdrawing more than msg.sender owns. 4# Negative test?  Preconditions:  * Assumes msg.sender is registered; * Assumes that the tokenAddress is legit and not some malicious token  Inputs:  * withdrawalAddress: - Control: full control  - Checks: no checks  - Impact: in the case of an incorrect recipient, funds may be lost. * tokenAddress:  - Control: full control  - Checks: no checks  - Impact: should allow to pass only trusted contracts. * amount:  - Control: limited control  - Checks: check that it's !)0 and that user has more balance than it. - Impact: shouldn't allow to pass more tokens amount than caller owns.  Function call analysis  * tokenContract.safeTransfer(withdrawalAddress, amount) - What is controllable? withdrawalAddress, amount - If return value controllable, how is it used and how can it go wrong? no checks on withdrawalAddress.  - What happens if it reverts, reenters, or does other unusual control flow? will revert if msg.sender doesn't have enough tokens  Function: transferToken()  Intended behavior:  Zellic 54 Multisig Labs    * Transfer token from one contract(msg.sender) to another  Branches and code coverage:  Intended branches:  * Validate the tokenContract, such that no arbitrary tokens can be used. # Test coverage  * Assure both contracts are registered. 4# Test coverage  * Compared to the transferAVAX, this function does not allow the transfer from arbitrary tokens, and only from msg.sender # Test coverage  * Increase tokenBalances[to] AND decrease tokenBalances[from] . 4# Test coverage  Negative behavior:  * Revert if msg.sender is not a registered contract. x Test coverage  * Revert if msg.sender doesn't have enough tokens amount. Test coverage  Preconditions:  * Assumes both contracts have been registered beforehand.  Inputs:  * networkContractName: - Control: full  - Checks: check that it's registered  - Impact: in the case of an incorrect recipient, funds may be lost. * tokenAddress:  - Control: full control  - Checks: No checks! Any token  - Impact: should allow to pass only trusted contract address.  Function call analysis  There aren't external calls here.  Zellic 55 Multisig Labs    5.10 File: MinipoolManager  Function: createMinipool()  Intended behavior:  * Create a Minipool. Accepts avax native deposit(which have to be staked in) and it's open to public.  * Allows to any caller to recreate aminipool is current state is finished or canceled.  Branches and code coverage:  Intended branches:  * Ensure that the msg.sender is a registered staker(required checks are added in each underlying function)  4# Test coverage * Should ensure that the avaxAssignmentRequest can be fulfilled (or that it is at least achievable) # Test coverage  * User's avax balance should deplete, and the contract's balance should increase. # Test coverage  * After the call, the current state of the minipool is Prelaunch 4# Test coverage  * native token balance of assets should increase by msg.value 4# Test coverage  * assets balance of vault contract should increase by msg.value 4# Test coverage  * if the pool for nodeID exists and the current state is FinishedorCanceled,minipool data should be reset # Test coverage  * create a new poll if the pool for nodeID did not exist before # Test coverage  * Staking.sol:getRewardsStartTime(msg.sender) should be equal block.timesta mp if RewardsStartTimewas zero before the call  4# Test coverage * Staking.sol:getMinipoolCount(msg.sender) should increase by 1  4# Test coverage * Staking.sol:getAVAXAssigned(msg.sender) should increase by avaxAssignmentR  equest 4# Test coverage  * Staking.sol:getAVAXStake(msg.sender) should increase by msg.value  Zellic 56 Multisig Labs    4# Test coverage  Negative behavior:  * Shouldn't work when the contract is paused?/ 4# Negative test? There isn't test, but function has modifier whenNotPaused  * Should assure that the nodeId hasn't registered beforehand and is unique basi- cally, so no overwrites can be made. # Negative test?  * should revert if minipool for nodeID already exists and the currentStatus  Fin- ished or currentStatus  Canceled # Negative test?  * should revert if msg.sender invalid staker 4# Negative test?  Preconditions:  * Assumes that the supplied msg.value surpasses the minimum staking amount. * Assumes that the multisig that is to be assigned is  0. * Assumes that should the miniPool exist, it can only be overwritten if the node is either finished or cancelled.  * In the case that an already existing miniPoolId exists, it assumes that ALL PRIOR STATES HAVE BEEN RESET(FROM ALL CONTRACTS THAT WOULD HAVE IN- TERACTEDWITH THIS ONE IN THE FIRST)  * msg.sender should be registered staker * msg.sender should stake ggp over Staking.stakeGGP() function  Inputs:  * msg.sender: - Control: controlled  - Checks: staking.increaseAVAXStake()  requireValidStaker() checksmsg.sender address (should stake ggp over stakeGGP() function)  - Impact: N/A * msg.value:  - Control: N/A  - Checks: msg.value should be equal avaxAssignmentRequest - Impact: N/A  * nodeId: - Control: full control  - Checks: there are some checks on whether the nodeID has been registered  Zellic 57 Multisig Labs    before; need to look into this  - Impact: could potentially be overwritten. * duration:  - Control: full control  - Checks: There are no checks on the duration amount  - Impact: N/A * delegationfee:  - Control: full  - Checks: No checks  - Impact: N/A * avaxAssignmentRequest:  - Control: full control; needs to match msg.value since it's the amount of requested AVAX TO BE MATCHED IN THE POOL.  - Checks: there are checks on whether it matches msg.value * there are also some checks on whether it matches the dao details ; assure that the data returned from there is not 0? - Impact: N/A  Function call analysis  !!! Important functions(withdraw/ deposit/ etc) shouldn't work when the contract is paused.  * vault.depositAVAX() - What is controllable? msg.value  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * getCollateralizationRatio() - What is controllable? msg.sender  - If return value controllable, how is it used and how can it go wrong? The returns collateralization ratio also depends on how much msg.sender de- posited ggp  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * increaseMinipoolCount() - What is controllable? msg.sender (had to deposit ggp before)  - If return value controllable, how is it used and how can it go wrong? there isn't return value  Zellic 58 Multisig Labs    - What happens if it reverts, reenters, or does other unusual control flow? no problems  * increaseAVAXAssigned() - What is controllable? msg.sender (had to deposit ggp before), avaxAs- signmentRequest  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * increaseAVAXStake() - What is controllable? msg.sender (had to deposit ggp before), msg.value  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: cancelMinipool()  Intended behavior:  * Allows owner to cancel existing minipool and get back the deposited funds.  Branches and code coverage:  Intended branches:  * Should update all details related to the specific nodeId. In such a way that one can then be re-used eventually(create with same nodeId)  4# Test coverage * Refund all invested funds to the owner(deployer)  # Test coverage * Make sure that theminipool is prelaunch ( NOT CHECKED); it's assured though in  requireValidStateTransitionbasically, since it checks the current status against the wanted status update. # Test coverage  * Staking.sol:getAVAXAssigned(msg.sender) should decrease by avaxLiquidStak erAmt  4# Test coverage * Staking.sol:getAVAXStake(msg.sender) should decrease by avaxNodeOpAmt  4# Test coverage * Staking.sol:getMinipoolCount(msg.sender) should decrease by 1  4# Test coverage  Zellic 59 Multisig Labs    * the native tokens balance of the caller should increase by the amount of funds previously deposited.  4# Test coverage * After the call, the current state of the minipool is Canceled  4# Test coverage  Negative behavior:  * Shouldn't leave previously set fields to their value(eg. the avaxLiquidStakerAmt) 4# Negative test?  * Shouldn't allow unauthorized access(msg.sender has to be the owner) 4# Negative test?  * should revert if the current state of mini pool isn't Prelaunch 4# Negative test?  * should revert if called non-owner of minipool 4# Negative test?  * should revert if minipool for nodeID doesn't exist 4# Negative test?  Preconditions:  * the minipool should be created over the createMinipool function * the current state of the minipool should be Prelaunch * Assumes that the nodeId has been created beforehand and that it's in the prela  unch stage * Assumes that the owner of the nodeID calls it  Inputs:  * nodeId: - Control: full control  - Checks: there's a check on whether the minipool is valid.  - Impact: Id of minipool which will be canceled and funds will returned to owner.  * msg.sender: - Control: onlyOwner of minipool can call  - Checks: onlyOwner(index); - Impact: only the owner should be able to call this function. otherwise, users will maliciously close other people's pools to get more rewards.  Zellic 60 Multisig Labs    Function call analysis  * _cancelMinipoolAndReturnFunds() - What is controllable? the nodeID is controllable. - If return value controllable, how is it used and how can it go wrong? there isn't return value here.  - What happens if it reverts, reenters, or does other unusual control flow? can be reverted if there aren't enough native tokens for withdraw.  * owner.safeTransferETH() - What is controllable? nothing controllable  - If return value controllable, how is it used and how can it go wrong? there isn't return value here.  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * vault.withdrawAVAX() - What is controllable? nothing controllable  - If return value controllable, how is it used and how can it go wrong? there isn't a return value here  - What happens if it reverts, reenters, or does other unusual control flow? will revert if contract has not enough shares  Function: _cancelMinipoolAndReturnFunds()  Intended behavior:  * Internal function. * Main logic of cancelling a minipool and returning the funds that were initially attributed to it.  Branches and code coverage:  Intended branches:  * Ensure that all states are reset after a Minipool has been cancelled and that owner no longer has access to it. # Test coverage  * Ensure that current state allows cancellation. 4# Test coverage  * Ensure that avaxNodeOpAmt is decreased. 4# Test coverage  * Ensure that avaxLiquidStakerAmt is decreased 4# Test coverage  Zellic 61 Multisig Labs    Negative behavior:  * Shouldn't allow cancellation if the current state !) prelaunch 4# Negative test?  * Shouldn't allow cancellation on behalf of msg.sender !) owner 4# Negative test?  Preconditions:  * Assumes that the function has been called from a privileged one(i.e one that has a check that msg.sender =) owner of market)  Inputs:  * nodeID: - Control: full control  - Checks: no checks at this level  - Impact: nothing is done on the nodeId at this level, so not that important * index:  - Control: full control(it's generated in previous function)  - Checks: no checks  - Impact: important, as it allows altering states of the minipool  Function call analysis  * decreaseAVAXStake() - What is controllable? the owner (who's supposed to be the caller of the function)  * it basically decreases the avaxNodeOpAmt value which is originally increased in the pool creation! The detail here is that it uses .avaxNodeOpAmount to store the amount, while it decreases the avaxNodeOpAmt - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? * if it reverts it could affect cancelling the pool. (that's why it's better to only use one type of amount ^ )  * decreaseAVAXAssigned() - What is controllable? nothing, the values are taken from the storage.  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow?  Zellic 62 Multisig Labs    if current avaxAssigned is not enough function will be reverted * resetAVAXAssignedHighWater()  - What is controllable? nothing, the value is taken from the storage.  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? allows to set the avaxAssignedHighWater to the previous value, so that the current value is not used when calculating the reward.  * decreaseMinipoolCount() - What is controllable? nothing, the value is taken from the storage.  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? reduces the number of pools, if it is reset to zero, this staker will not be taken into account when calculating the reward.  Function: withdrawMinipoolFunds()  Intended behavior:  * Node operator can claim all avax they are due.(staked + rewards if any)  Branches and code coverage:  LIMITED TESTING  Intended branches:  * Should decrease msg.sender stake in the minipool by avaxNodeOpAmt # Test coverage  * the native tokens balance of minipool owner should increase by totalAvaxAmt value (deposited amount + reward)  4# Test coverage  Negative behavior:  * Shouldn't be callable by any msg.sender or on any nodeId 4# Negative test?  * should revert if the owner calls it a second time after the successful first execu- tion # Negative test?  * should revert if the current state of mini pool isn't Withdrawable or Error # Negative test?  Zellic 63 Multisig Labs    * should revert if called non-owner of minipool 4# Negative test? There isn't test, but there is a check onlyOwner inside the function  * should revert if minipoll for nodeID doesn't exist 4# Negative test? There isn't test, but there is a check requireValidMinipool inside the function  Preconditions:  * The minipool should be created over the createMinipool function. * Assumes that the state can transition to finished, and that the current state of the minipool should be Withdrawable (after recordStakingEnd call) or Error.  Inputs:  * msg.sender: - Control: -  - Checks: there is a check that msg.sender is owner of minipool  - Impact: allows to owner ofminipoolwithdraw fundswhen staking finished * nodeID:  - Control: controlled  - Checks: there are a check of the status of the minipool and a check of the owner  - Impact: allows to return the funds to the owner of minipool if staking was finished  Function call analysis  * owner.safeTransferETH() - What is controllable? nothing controllable  - If return value controllable, how is it used and how can it go wrong? there isn't return value here.  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * vault.withdrawAVAX() - What is controllable? nothing controllable  - If return value controllable, how is it used and how can it go wrong? there isn't a return value here  - What happens if it reverts, reenters, or does other unusual control flow? will revert if contract has not enough shares  Zellic 64 Multisig Labs    Function: claimAndInitiateStaking()  Intended behavior:  * Remove the minipool's avax from the protocol and stake it on avalanche, reg- ister node as validator.  Branches and code coverage:  Intended branches:  * Ensure only multisig rialto can call this. 4# Test coverage  * Should ensure the status of the minipool is such that it can be launched 4# Test coverage  * Should decrease the avax associated to the pool(something with .avaxLiquidSt akerAmt) # Test coverage  Negative behavior:  * transaction should be rejected if current status  Prelaunch 4# Negative test?  * transaction should be rejected if msg.sender isn't approved address 4# Negative test?  Preconditions:  * Assumes that contract has enough wavax staked that can be withdrawable.  Inputs:  * msg.sender: - Control: -  - Checks: onlyValidMultisig(nodeID) : msg.sender =) assignedMultisig - Impact: only valid multisig can call this function, because the all deposit funds will be transferred to caller.  * nodeID: - Control: full control  - Checks: requireValidMinipool(nodeID) - Impact: no impact  Zellic 65 Multisig Labs    Function call analysis  * msg.sender.safeTransferETH() - What is controllable? msg.sender is controlled  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? will revert in case of error  * vault.withdrawAVAX() - What is controllable? nothing is controlled  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? allows to withdraw avaxNodeOpAmt from vault and transfer this funds to caller  * ggAVAX.withdrawForStaking() - What is controllable? nothing is controlled  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? allows to withdraw avaxLiquidStakerAmt from vault and transfer this funds to caller  Function: recordStakingStart()  Intended behavior:  * Rialto calls after claimAndInitiateStaking succeeded.  Branches and code coverage:  Intended branches:  * Changes the starttime. Make sure it's not in past or future? # Test coverage  * Should transition a nodeID into \"staking\" period. 4# Test coverage  Negative behavior:  * Anyone other than rialto shouldn't be able to call this. 4# Negative test?  * transaction should be rejected if current status  Launched  Zellic 66 Multisig Labs    4# Negative test?  Preconditions:  * Has to assure that enough values are in the minipool  Inputs:  * startTime: - Control: controllable  - Checks: there isn't check  - Impact: if the value is far in the future it will be impossible to complete the stacking successfully only with error state  * txID: - Control: controllable  - Checks: there isn't check  - Impact: n/a * nodeID:  - Control: partly controllable  - Checks: requireValidMinipool(nodeID) - Impact: n/a  * msg.sender: - Control: -  - Checks: onlyValidMultisig(nodeID) : msg.sender =) assignedMultisig - Impact: if a malicious user is able to call the function, he will be able to set startTime value, at which it will be impossible to successfully complete the stacking with only an error state  Function call analysis  There aren't external function calls here.  Function: recordStakingEnd()  Intended behavior:  * Finish the validation period of the staking for the nodeid.  Branches and code coverage:  Intended branches:  Zellic 67 Multisig Labs    * Should update all states accordingly after the transfers occur. 4# Test coverage  * End time should be in the future(starttime and not in past compared to block. timestamp?) # Test coverage  * Should only be callable when the endtime is reached. 4# Test coverage  Negative behavior:  * Shouldn't be callable twice or in any other circumstance other than the transition to withdrawable  4# Negative test? * transaction should be rejected if msg.value is not enought  4# Negative test? * transaction should be rejected if msg.sender isn't approved address  4# Negative test? * transaction should be rejected if current status  Staking  4# Negative test?  Preconditions:  * the current state of the minipool should be Staking.  Inputs:  * msg.value: - Control: -  - Checks: msg.value should be equal totalAvaxAmt + avaxTotalRewardAmt - Impact:  * avaxTotalRewardAmt: - Control: full control  - Checks: msg.value should be equal totalAvaxAmt + avaxTotalRewardAmt - Impact: the value completely controls howmuch reward the owner of the pool will receive.  * endTime: - Control: controllable  - Checks: should be more than the startTime and more than current time  - Impact: no impact * nodeID:  - Control: partly controllable  Zellic 68 Multisig Labs    - Checks: requireValidMinipool(nodeID) - Impact: no impact  * msg.sender: - Control: -  - Checks: onlyValidMultisig(nodeID) : msg.sender =) assignedMultisig - Impact: only valid multisig can control when staking will be finished  Function call analysis  * slash() - What is controllable? minipoolIndex  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? can be reverted if  * ggAVAX.depositFromStaking - What is controllable? avaxLiquidStakerRewardAmt - partly controlled  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? revert if stakingTotalAssets value is less than avaxLiquidStakerAmt  * vault.depositAVAX() - What is controllable? avaxNodeOpRewardAmt - partly controlled  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? revert if previewDeposit returns 0.  Function: recordStakingError()  Intended behavior:  A staking error occurred while registering the node as a validator.  Can be called after claimAndInitiateStaking or recordStakingStart  Branches and code coverage:  Intended branches:  * After the call the new status is Error 4# Test coverage  Zellic 69 Multisig Labs    Negative behavior:  * transaction should be rejected if current status  Staking or Launched 4# Negative test?  Preconditions:  * current status should be Launched or Staking  Inputs:  * msg.value: - Control: -  - Checks: msg.value should be equal avaxNodeOpAmt + avaxLiquidStakerAmt - the withdrawn funds  - Impact: amount of returned to staker funds. must not be less than the funds taken.  * errorCode: - Control: controlled  - Checks: there isn't check here  - Impact: no problems * nodeID:  - Control: controlled  - Checks: check that minipool exists  - Impact: the ID of theminipool that will be completedwith an error without issuing a reward.  Function call analysis  * ggAVAX.depositFromStaking() - What is controllable? nothing is controlled  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? will revert if stakingTotalAssets is less than avaxLiquidStakerAmt  * vault.depositAVAX() - What is controllable? avaxNodeOpRewardAmt - partly controlled  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? revert if previewDeposit returns 0.  Zellic 70 Multisig Labs    5.11 File: MultisigManager  Function: registerMultisig()  Intended behavior:  * Register a multisig. Defaults to disabled when first registered. The index where the multisig is to be added should be the previously increased multisig.count  Branches and code coverage:  Intended branches:  * \"There will never be more than 10 total multisigs\" There should be a check that 10 total multisigs can be registered (index  9) and no more # Test coverage  * Should register the addr as a new multisig, only if it doesn't exist already. 4# Test coverage  Negative behavior:  * Shouldn't allow anyone else other than the guardian to call it 4# Negative test?  * Shouldn't overwrite already existing multisig 4# Negative test?  * Shouldn't also enable the multisig 4# Negative test?  Preconditions:  * Assumes getIndexOf calculates the index properly and that two addresses can- not point to same index.  * Assumes there's away to de-register a Multisig? Currently, there's none; there's only a way to disable them.  Inputs:  Function call analysis  Function: enableMultisig()  Intended behavior:  * Should enable a registered multisig.  Zellic 71 Multisig Labs    Branches and code coverage:  Intended branches:  * The \"enabled\" of the index should be set to true . 4# Test coverage  Negative behavior:  * Shouldn't update the index of another multisig. 4# Negative test?  * Shouldn't be callable by anyone. # Negative test? Not directly, but the registerMultisig which has the same modifier is tested when msg.sender !) guardian  * Shouldn't enable a multisig that doesn't exist. 4# Negative test? Not tested, there is a check in the code that prevents this from happening.  Preconditions:  * Assumes that the multisig has been created beforehand.  Inputs:  Function call analysis  Function: disableMultisig()  Intended behavior:  * Should disable a registered multisig.  Branches and code coverage:  Intended branches:  * The \"enabled\" of the index should be set to false. 4# Test coverage  Negative behavior:  * Shouldn't be callable by any msg.sender 4# Negative test?  * Shouldn't update an non-existing index 4# Negative test? Not tested, there is a check in the code that prevents this from happening.  Zellic 72 Multisig Labs    Preconditions:  * Assumes that it can be called under any circumstances. What if it's called during a transaction where it needs to approve it?  Inputs:  Function call analysis  5.12 File: Ocyticus  Function: addDefender(), removeDefender()  Intended behavior:  * Allow guardian to add or remove defenders.  Branches and code coverage:  Lacks testing  Intended branches:  * Should update the defenders states properly. # Test coverage  Negative behavior:  * Should only be callable by guardian; covered by onlyGuardianmodifier. 4# Negative test?  Preconditions:  * Assumes they are called by external accounts.  Inputs:  n/a  Function call analysis  Function: pauseEverything()  Intended behavior:  * Allows the defender to pause every contract that can be paused.  Zellic 73 Multisig Labs    Branches and code coverage:  Intended branches:  * Pause TokenGGAVAX 4# Test coverage  * Pause MinipoolManager 4# Test coverage  * Pause Staking (MISSING!) - added as remediation # Test coverage  Negative behavior:  Preconditions:  * Assumes that the contracts can be paused. * Assumes that when paused, no important functions from these contracts can be called! Double check this  Inputs:  n/a  Function call analysis  n/a  Function: resumeEverything()  Intended behavior:  Branches and code coverage:  Intended branches:  * Unpause TokenGGAVAX 4# Test coverage  * Unpause MinipoolManager 4# Test coverage  * Unpause Staking - added as remediation # Test coverage  Negative behavior:  Zellic 74 Multisig Labs    Preconditions:  * Assumes that some other function will reenable all multisigs? That's not cov- ered in this contract  Inputs:  n/a  Function call analysis  n/a  5.13 File: Oracle  Function: setGGPPriceInAVAX(), getGGPPriceInAVAXFromOneInch, getGGPPriceI nAVAX  Intended behavior:  * Interface for off-chain aggregated data, used for pricing the tokens and calcu- lating amounts. The getGGPPriceInAVAXFromOneInch should never be used on- chain.  Branches and code coverage:  Lacks testing.  Intended branches:  * The functions/ contracts that make use of the GetGGPPriceInAvax SHOULD have some slippage check in regards to the timestamp when the price has been up- dated: eg. If the price update happened more than 5 blocks away, revert the transaction. # Test coverage  Negative behavior:  * Shouldn't be callable by anyone. Only Multisig modifier put in place. 4# Negative test?  Preconditions:  * getGGPPriceInAVAXFromOneInch should only be called off-chain; it's not reliable enough to be called on chain directly.  Zellic 75 Multisig Labs    * Assumes the Multisig update the getGGPPRiceInAvax quite often and that they are trustworthy.  Inputs:  There aren't input values here.  Function: setOneInch()  Intended behavior:  * Allows to guardian to set the address of the One Inch price aggregator contract  Branches and code coverage:  Intended branches:  * after the call Oracle.OneInch is updated to new address # Test coverage  Negative behavior:  * Revert if caller is not Guardian. 4# Negative test?  Preconditions:  * msg.sender is Guardian  Inputs:  * addr: - Control: controlled  - Checks: There isn't check here.  - Impact: The contract address which will be called inside view getGGPPric eInAVAXFromOneInch function  Function call analysis  There aren't external calls here.  Function: setGGPPriceInAVAX()  Zellic 76 Multisig Labs    Intended behavior:  * The function is used by theMultisig to update the on-chain prices, with presum- ably the data retrieved off-chain from OneInch.  Branches and code coverage:  Intended branches:  * Should update the GGPTimestamp # Test coverage  * Should update the GGPPriceInAvax # Test coverage  Negative behavior:  * Revert if caller is not Multisig # Negative test?  Preconditions:  * msg.sender is Multisig  Inputs:  * price: - Control: controlled  - Checks: price != 0  - Impact: the price value is used during calculateGGPSlashAmt call * timestamp:  - Control: controlled  - Checks: timestamp should be >= lastTimestamp or timestamp should be <= block.timestamp  - Impact: n/a  Function call analysis  There aren't external calls here.  5.14 File: ProtocolDAO  Function: initialize()  Zellic 77 Multisig Labs    Intended behavior:  * Initialize the contract  * Total GGPCirculatingSupply = 18.000.000 but total TokenGGP supply = 22.500.000  Branches and code coverage:  * Not tested in the case of a re-deployment(or upgrade, as discussed with the team).  Intended branches:  * All set parameters should have a getter. 4# Test coverage; not test covered, but verified in the code.  Negative behavior:  * Setters that deal with rates should range from 0.0 - 1.0 ether . This is not di- rectly enforced; The same should be done for the rest of the setter functions from the contract. This was mitigated. # Negative test?  Preconditions:  * Assumes that it can only be called once, and that is through the onlyGuardian * Assumes it will be called BEFORE any other functions that would use the initial- ized variables will be called. Maybe assure in important functions that - getBool(keccak256(\"ProtocolDAO.initialized\"))is TRUE  Inputs:  Function call analysis  5.15 File: RewardsPool  Function: initialize()  Intended behavior:  * Re-initialize all RewardsPool variables for a new RewardsPool; This is upgradeable  Branches and code coverage:  * Not tested in the case of a re-deployment(or upgrade, as discussed with the team).  Zellic 78 Multisig Labs    Intended branches:  * Should set the RewardsPool variables to their initial values. # Test coverage  Negative behavior:  Preconditions:  * Assumes it's the first the this type of contract has been deployed.  Inputs:  There aren't input values here.  Function call analysis  There aren't external calls here.  Function: inflate()  Intended behavior:  * Called to release more GGP from the total supply. * says \"mint\" new tokens, but all of them are already minted.  Branches and code coverage:  Intended branches:  * Should update the rewardsCycle total amount. # Test coverage  * Should update the inflationIntervalElapsedSeconds # Test coverage  * Should increase circulating supply of tokens. # Test coverage  Preconditions:  * Assumes it won't be called that often  Inputs:  There aren't input values here.  Zellic 79 Multisig Labs    Function call analysis  * dao.setTotalGGPCirculatingSupply(newTotalSupply) - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: startRewardsCycle()  Intended behavior:  * Runs a ggp rewards cycle if possible.  Branches and code coverage:  * More extensive testing required.  Intended branches:  * if dao allotment exists  transfer daoAllotment to DAO  its balance should in- crease  4# Test coverage * if nop allotment exists  transfer nopAllotment to NOP  its balance should in- crease  4# Test coverage * if multisig allotmentexists  transfer multisigAllotment to MULTISIG  its bal- ance should increase  4# Test coverage * Make sure allotments add up to 100%(the percentages)  # Test coverage  Negative behavior:  * Shouldn't be callable whenever(rewardscycle should be scheduled) 4# Negative test?  Preconditions:  * Assumes that the rewardsCycle is startable. * Also assumes that each allotment is >0 . works even if that's not the case.  Zellic 80 Multisig Labs    Inputs:  There aren't input values here.  Function call analysis  * nopClaim.setRewardsCycleTotal(nopClaimContractAllotment) - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * vault.transferToken() - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? there isn't return value here  - What happens if it reverts, reenters, or does other unusual control flow? revert if tokenBalance is less than amount value, or if amount is zero  Function: distributeMultisigAllotment()  Intended behavior:  * Should distribute the ggp to the multisigs.  Branches and code coverage:  Intended branches:  * Should only be called with legitimate ggp tokens. 4# Test coverage  Negative behavior:  Lacks negative testing  * Should not distribute rewards to deactivated multisigs. # Test coverage  Preconditions:  * Assumes there aren't that many multisigs * Assumes that if multisigs gets deleted, they won't be eligible for rewards.  Zellic 81 Multisig Labs    Inputs:  * allotment: - Control: value is calculated inside getClaimingContractDistribution(\"Cla  imMultisig\") - Checks: no checks at this function level, however, there may be some left- over tokens due to rounding errors; assure that these are sent somewhere after all allotments? (in startRewardsCycle)  - Impact: determines the total amount of tokens thatwill be sent tomultisigs. * vault:  - Control: address is taken from Vault(getContractAddress(\"Vault\")) - Checks: passed from previous function; same as ggp parameter. - Impact: n/a  * ggp: - Control: address is taken from TokenGGP(getContractAddress(\"TokenGGP\")  ) - Checks: full control; it's passed from the previous function; ENSURE that it's never called somewhere else or with a different GGP than here  - Impact: n/a  Function call analysis  * mm.getCount(); - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? out of gas inside the for loop if count value is too big  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * mm.getMultisig(i) - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? re- turns address and status of multisig, if enabled then this address will re- ceive ggp tokens.  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * vault.withdrawToken(enabledMultisigs[i], ggp, tokensPerMultisig) - What is controllable? since this is an internal call, all input values are taken from storage.  - If return value controllable, how is it used and how can it go wrong? there isn't return value here.  Zellic 82 Multisig Labs    - What happens if it reverts, reenters, or does other unusual control flow? will revert if safeTransfer call reverts and if tokenBalances less than amount value  5.16 File: Staking  Function: GGP staking components  Intended behavior:  * Limited negative testing  * getGGPStake = view current stake * increaseGGPStake = increase .ggpStaked * decreaseGGPStake = decrease .ggpStaked  Branches and code coverage:  Intended branches:  * Should retrieve / increase / decrease the ggpStaked. # Test coverage  Negative behavior:  * Shouldn't update an unregistered stakerIndex. # Negative test?  Preconditions:  * increase assumes that user has deposited the ggp and that the contract's balance has/ will increase  * decrease assumes that the user has withdrawn and that the ggp balance of the contract will decrease + ggp balance of user will increase.  Where are the functions used:  * increaseGGPSTake: Used in _stakeGGP * decreaseGGPStake: Used in slashGGP, withdrawGGP  Function: increaseAVAXStake()  Zellic 83 Multisig Labs    Intended behavior:  Increase the amount of AVAX for stakerAddr.  The function is called only from MinipoolManager.createMinipool.  Branches and code coverage:  Intended branches:  * After the function call the getAVAXStake for stakerAddr increased by the amount value  4# Test coverage  Negative behavior:  * The function will revert if stakerAddr is not valid staker # Negative test?  * The function will revert if msg.sender is not MinipoolManager contract # Negative test?  Preconditions:  * stakerAddr called stakeGGP and was registered as a staker.  Inputs:  * msg.sender: - Control: -  - Checks: onlySpecificRegisteredContract(\"MinipoolManager\", msg.sende r)  - Impact: access to the function by untrusted addresses will allow manipu- lating the number of tokens staked.  * amount: - Control: msg.value is passed from the function MinipoolManager.createMi  nipool to ths function. limited control. - Checks: there are no checks.  - Impact: this value reflects the number of stacked tokens. manipulating this value will allow an attacker to specify the number of tokens that have not actually been deposited.  * stakerAddr: - Control: msg.sender from MinipoolManager.createMinipool. not controlled. - Checks: the requireValidStaker function checks the address. If this ad- dress isn't staker, will revert.  Zellic 84 Multisig Labs    - Impact: in case of full access it will allow any user to increase the number of tokens deposited.  Function call analysis  * requireValidStaker() - What is controllable? stakerAddr - If return value controllable, how is it used and how can it go wrong? re- turn the stakerIndex corresponding to the stakerAddr. The Index must be unique, otherwise will be possible to lose funds.  - What happens if it reverts, reenters, or does other unusual control flow? will be reverted if stakerAddr is not a valid staker.  * addUint() - What is controllable? amount  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? it can be reverted in overflow case,  Function: decreaseAVAXStake()  Intended behavior:  Decrease the amount of AVAX for stakerAddr.  The function is called from MinipoolManager.withdrawMinipoolFunds and MinipoolMan ager._cancelMinipoolAndReturnFunds.  Branches and code coverage:  Intended branches:  * After the function call the getAVAXStake for stakerAddr decreased by the amount value  4# Test coverage  Negative behavior:  * The function will revert if stakerAddr is not valid staker # Negative test?  * The function will revert if the avaxStaked for the stakerAddr is less than amount # Negative test?  * The function will revert if msg.sender is not MinipoolManager contract # Negative test?  Zellic 85 Multisig Labs    Preconditions:  * stakerAddr have called stakeGGP and was registered as a staker. * stakerAddr has non zero avaxStaked value  Inputs:  * msg.sender: - Control: -  - Checks: onlySpecificRegisteredContract(\"MinipoolManager\", msg.sende r)  - Impact: access to the function by untrusted addresses will allow manipu- lating the number of tokens staked  * amount: - Control: getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoo  lIndex, \".avaxNodeOpAmt\"))) value from gogoStorage, limited control. - Checks: this value cannot be more than current the avaxStaked value - Impact: this value reflects the number of stacked tokens. manipulating this value will allow an attacker to specify the number of tokens that have not actually been withdrawn.  * stakerAddr: - Control: owner of minipool. not controlled.  - Checks: the requireValidStaker function checks the address. If this ad- dress isn't staker, will revert.  - Impact: in case of full access it will allow any user to decrease the number of tokens deposited.  Function call analysis  * subUint() - What is controllable? amount  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? will revert if avaxStaked less than amount.  * requireValidStaker() - What is controllable? stakerAddr - If return value controllable, how is it used and how can it go wrong? re- turn the stakerIndex corresponding to the stakerAddr. The Index must be unique, otherwise will be possible to lose funds.  - What happens if it reverts, reenters, or does other unusual control flow?  Zellic 86 Multisig Labs    will be reverted if stakerAddr is not a valid staker.  Function: increaseAVAXAssigned()  Intended behavior:  Increase the amount of AVAX a given staker is assigned by the protocol  The function is called only from MinipoolManager.createMinipool.  Branches and code coverage:  Intended branches:  * After the function call the getAVAXAssigned for stakerAddr increased by the amou nt value  4# Test coverage  Negative behavior:  * The function will revert if stakerAddr is not valid staker # Negative test?  * The function will revert if msg.sender is not MinipoolManager contract # Negative test?  Preconditions:  * stakerAddr have called stakeGGP and was registered as a staker.  Inputs:  * amount: - Control: avaxAssignmentRequest is passed from the function MinipoolMan  ager.createMinipool to ths function and should be equal the msg.sender value. limited control.  - Checks: there are no checks  - Impact: this value reflects the number of assigned tokens. Manipulating this value will allow an attacker to specify the number of tokens that have not actually been assigned.  * msg.sender: - Control: -  - Checks: onlySpecificRegisteredContract(\"MinipoolManager\", msg.sende r)  - Impact: access to the function by untrusted addresses will allow manipu-  Zellic 87 Multisig Labs    lating the number of tokens assigned. * stakerAddr:  - Control: msg.sender from MinipoolManager.createMinipool. not controlled. - Checks: the requireValidStaker function checks the address. If this ad- dress isn't staker, will revert.  - Impact: in case of full access it will allow any user to increase the number of tokens assign.  Function call analysis  * setUint(...))\".avaxAssignedHighWater\") - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * addUint(...))\".avaxAssigned\") - What is controllable? amount  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: decreaseAVAXAssigned()  Intended behavior:  Allows to decrease the amount of AVAX a given staker is assigned by the protocol  The function is called from MinipoolManager.recordStakingEnd and MinipoolManager. recordStakingError and MinipoolManager._cancelMinipoolAndReturnFunds.  Branches and code coverage:  Intended branches:  * After the function call the getAVAXAssigned for stakerAddr decreased by the amo unt value  4# Test coverage  Negative behavior:  * The function will revert if stakerAddr is not valid staker # Negative test?  Zellic 88 Multisig Labs    * The function will revert if the avaxAssigned for the stakerAddr is less than amount # Negative test?  * The function will revert if msg.sender is not MinipoolManager contract # Negative test?  Preconditions:  * stakerAddr have called stakeGGP and was registered as a staker. * stakerAddr has non zero avaxAssigned value  Inputs:  * msg.sender: - Control: -  - Checks: onlySpecificRegisteredContract(\"MinipoolManager\", msg.sende r)  - Impact: access to the function by untrusted addresses will allow manipu- lating the number of tokens assign.  * amount: - Control: getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoo  lIndex, \".avaxLiquidStakerAmt\"))) value from gogoStorage, limited con- trol.  - Checks: this value cannot be more than current the avaxAssigned value - Impact: this value reflects the number of staked tokens. Manipulating this value will allow an attacker to specify the number of tokens that have not actually been deposited.  * stakerAddr: - Control: owner of minipool. not controlled.  - Checks: the requireValidStaker function checks the address. If this ad- dress isn't staker, will revert.  - Impact: in case of full access it will allow any user to decreased the number of tokens assigned.  Function call analysis  * subUint() - What is controllable? amount  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? will revert if avaxAssigned less than amount.  Zellic 89 Multisig Labs    * requireValidStaker() - What is controllable? stakerAddr - If return value controllable, how is it used and how can it go wrong? re- turn the stakerIndex corresponding to the stakerAddr. The Index must be unique, otherwise will be possible to lost funds.  - What happens if it reverts, reenters, or does other unusual control flow? will be reverted if stakerAddr is not a valid staker.  Function: setRewardsStartTime  Intended behavior:  * Rewards start time refers to the timestamp when the staker registered for GGPre wards  Branches and code coverage:  Intended branches:  * Ensure that time is in the future? # Test coverage  * Should allow setting the rewardStartTime # Test coverage  Negative behavior:  * Also, assuming that onlyRegisteredNetworkContract calls it. Also I think they whitelist their own Staking contract(basically address(this) # Negative test?  Preconditions:  * Assumes that it's called from onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender)  Inputs:  * time: - Control: full control  - Checks: there's no check on whether the time is in the future or not - Impact: the value is used during reward distribution, if zero, the staker will not receive reward  Zellic 90 Multisig Labs    Function call analysis  There aren't external calls here.  Where are the functions used:  * setRewardsStartTime: used in MinipoolManager and ClaimNodeOp  Function: GGP Rewards()  Intended behavior:  * Should get, increase, decrease the GGPRewards assigned to a staker.  Branches and code coverage:  Intended branches:  * These should update whenever the staker claims / is issued rewards. # Test coverage  * Should retrieve/ increase/ decrease the amount of GGPrewards a staker has earned and not claimed yet. # Test coverage  Negative behavior:  * Should revert if anyone other than the ClaimNodeOp contract calls them. # Negative test?  Preconditions:  * Assumes that the calling contract holds the correct accounting for how the ggp rewards are issued and maintained.  Function call analysis  There aren't external calls here.  Where are the functions used:  * increaseGGPRewards: used in ClaimNodeOP * decreaseGGPrewards: used in ClaimNodeOP  Function: increaseMinipoolCount()  Zellic 91 Multisig Labs    Intended behavior:  The function is called from MinipoolManager.createMinipool  Increase the number of minipools the given staker has  Branches and code coverage:  Intended branches:  * After the function call the .minipoolCount increased by 1 4# Test coverage  Negative behavior:  * The function will revert if the .minipoolCount is zero # Negative test?  * The function will revert if msg.sender is not MinipoolManager contract # Negative test?  Preconditions:  * stakerAddr have called stakeGGP and was registered as a staker.  Inputs:  * stakerAddr: - Control: owner of minipool. not controlled.  - Checks: the requireValidStaker function checks the address. If this ad- dress isn't staker, will revert.  - Impact: in case of full access it will allow any user to increase the amount of minipools  * msg.sender: - Control: -  - Checks: onlySpecificRegisteredContract(\"MinipoolManager\", msg.sende r)  - Impact: access to the function by untrusted addresses will allow manipu- lating the number of the given staker minipools. The setRewardsStartTime value depends of the amount of minipools, if minipoolCount = 0 RewardsSt artTime will be reset. If RewardsStartTime == 0 then RewardsStartTime will be set during minipool creation. And if RewardsStartTime == 0 then owner of minipool doesn't get the GGP rewards  Zellic 92 Multisig Labs    Function call analysis  * addUint() - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * requireValidStaker() - What is controllable? stakerAddr - If return value controllable, how is it used and how can it go wrong? re- turn the stakerIndex corresponding to the stakerAddr. The Index must be unique, otherwise will be possible to lost funds.  - What happens if it reverts, reenters, or does other unusual control flow? will be reverted if stakerAddr is not a valid staker.  Function: decreaseMinipoolCount()  Intended behavior:  Decrease the number of minipools the given staker has  The function is called from MinipoolManager.recordStakingEnd and MinipoolManager ._cancelMinipoolAndReturnFunds  Branches and code coverage:  Intended branches:  * After the function call the .minipoolCount decreased by 1 4# Test coverage  Negative behavior:  * The function will revert if stakerAddr is not valid staker # Negative test?  * The function will revert if the .minipoolCount is zero # Negative test?  * The function will revert if msg.sender is not MinipoolManager contract # Negative test?  Preconditions:  * stakerAddr have called stakeGGP and was registered as a staker.  Zellic 93 Multisig Labs    * The .minipoolCount is not zero  Inputs:  * stakerAddr: - Control: owner of minipool. not controlled.  - Checks: the requireValidStaker function checks the address. If this ad- dress isn't staker, will revert.  - Impact: in case of full access it will allow any user to decrease the amount of minipools  * msg.sender: - Control: -  - Checks: onlySpecificRegisteredContract(\"MinipoolManager\", msg.sende r)  - Impact: access to the function by untrusted addresses will allow manipu- lating the number of the given staker minipools. The setRewardsStartTime value depends of the amount of minipools, if minipoolCount = 0 RewardsSt artTime will be reset. if RewardsStartTime == 0 then RewardsStartTime will be set during minipool creation. And if RewardsStartTime == 0 then owner of minipoll doesn't get the GGP rewards  Function call analysis  * subUint() - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? will revert if .minipoolCount is 0.  * requireValidStaker() - What is controllable? stakerAddr - If return value controllable, how is it used and how can it go wrong? re- turn the stakerIndex corresponding to the stakerAddr. The Index must be unique, otherwise will be possible to lost funds.  - What happens if it reverts, reenters, or does other unusual control flow? will be reverted if stakerAddr is not a valid staker.  Function: setRewardsStartTime()  Intended behavior:  Set the timestamp when the staker registered for GGP rewards.  Zellic 94 Multisig Labs    The setRewardsStartTime value depends of the amount of minipools, if minipoolCount = 0 RewardsStartTimewill be reset inside the calculateAndDistributeRewards() func- tion, which called from processGGPRewards if isEligible true (is not true if Rewards StartTime == 0). if RewardsStartTime == 0 then RewardsStartTime will be set during minipool creation.  Branches and code coverage:  Intended branches:  * After the function call the .rewardsStartTime is equal to time 4# Test coverage  Negative behavior:  * The function will revert if stakerAddr is not valid staker # Negative test?  * The function will revert if msg.sender is not RegisteredNetworkContract # Negative test?  Preconditions:  * stakerAddr have called stakeGGP and was registered as a staker.  Inputs:  * time: - Control: partly controlled: during minipool creation block.timestamp is passed  - Checks: there aren't any checks  - Impact: if set to 0 than owner of minipool cannot get the GGP rewards and if non zero will be able to get (isEligible(): if (block.timestamp - reward sStartTime)  dao.getRewardsEligibilityMinSeconds())  * stakerAddr: - Control: owner of minipool. not controlled.  - Checks: the requireValidStaker function checks the address. If this ad- dress isn't staker, will revert.  - Impact: in case of full access it will allow any user to set the RewardsStart Time and bypass the isEligible check.  * msg.sender: - Control: -  - Checks: onlyRegisteredNetworkContract - Impact: access to the function by untrusted addresses will allow manipu-  Zellic 95 Multisig Labs    lating the RewardsStartTime value. If RewardsStartTime != 0 then owner of minipool will be able to get the GGP rewards  Function call analysis  * setUint() - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * requireValidStaker() - What is controllable? stakerAddr - If return value controllable, how is it used and how can it go wrong? re- turn the stakerIndex corresponding to the stakerAddr. The Index must be unique, otherwise will be possible to lost funds.  - What happens if it reverts, reenters, or does other unusual control flow? will be reverted if stakerAddr is not a valid staker.  Function: increaseGGPRewards()  Intended behavior:  Increase the amount of GGP rewards the staker has earned and not claimed  The function is called from ClaimNodeOp.calculateAndDistributeRewards  Branches and code coverage:  Intended branches:  * After the call the .ggpRewards amount will be increased by amount 4# Test coverage  Negative behavior:  * The function will revert if stakerAddr is not valid staker # Negative test?  * The function will revert if msg.sender is not ClaimNodeOp contract # Negative test?  Preconditions:  * stakerAddr have called stakeGGP and was registered as a staker.  Zellic 96 Multisig Labs    Inputs:  * amount: - Control:  - Checks: there aren't checks  - Impact: The value determines how much the user will be able to receive rewards. In case of full access to the function, users will be able to steal all funds from the vault.  * stakerAddr: - Control: owner of minipool. not controlled.  - Checks: the requireValidStaker function checks the address. If this ad- dress isn't staker, will revert.  - Impact: in case of full access it will allow any user to increase the .ggpRew ards  * msg.sender: - Control: -  - Checks: onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) - Impact: access to the function by untrusted addresses will allow manipu- lating the .ggpRewards value.  Function call analysis  * requireValidStaker() - What is controllable? stakerAddr - If return value controllable, how is it used and how can it go wrong? re- turn the stakerIndex corresponding to the stakerAddr. The Index must be unique, otherwise will be possible to lost funds.  - What happens if it reverts, reenters, or does other unusual control flow? will be reverted if stakerAddr is not a valid staker.  * addUint() - What is controllable? amount  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: decreaseGGPRewards()  Intended behavior:  Decrease the amount of GGP rewards the staker has earned and not claimed.  Zellic 97 Multisig Labs    The function is called from ClaimNodeOp.claimAndRestake  Branches and code coverage:  Intended branches:  * After the call the .ggpRewards is decreased by the amount value. 4# Test coverage  Negative behavior:  * The function will revert if stakerAddr is not valid staker # Negative test?  * The function will revert if the .ggpRewards is less than amount # Negative test?  * The function will revert if msg.sender is not ClaimNodeOp contract # Negative test?  Preconditions:  * stakerAddr have called stakeGGP and was registered as a staker. * The .ggpRewards is set by the ClaimNodeOp.calculateAndDistributeRewards func- tion call  Inputs:  * amount: - Control: not controlled  - Checks: there aren't checks  - Impact: in case of an untrusted caller, the .ggpRewards can be reset and owner of pool will not be able to get reward  * stakerAddr: - Control: owner of minipool. not controlled.  - Checks: the requireValidStaker function checks the address. If this ad- dress isn't staker, will revert.  - Impact: in case of full access it will allow any user to decrease the .ggpRe wards  * msg.sender: - Control: -  - Checks: onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) - Impact: access to the function by untrusted addresses will allow manipu- lating the .ggpRewards value.  Zellic 98 Multisig Labs    Function call analysis  * requireValidStaker() - What is controllable? stakerAddr - If return value controllable, how is it used and how can it go wrong? re- turn the stakerIndex corresponding to the stakerAddr. The Index must be unique, otherwise will be possible to lost funds.  - What happens if it reverts, reenters, or does other unusual control flow? will be reverted if stakerAddr is not a valid staker.  * subUint() - What is controllable? amount - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? will revert if .ggpRewards is less than amount.  Function: setLastRewardsCycleCompleted()  Intended behavior:  Set the most recent reward cycle number that the staker has been paid out for.  The function is called from ClaimNodeOp.calculateAndDistributeRewards  Branches and code coverage:  Intended branches:  * After the call the .lastRewardsCycleCompleted is equal to the cycleNumber value # Test coverage  Negative behavior:  * The function will revert if stakerAddr is not valid staker # Negative test?  * The function will revert if msg.sender is not ClaimNodeOp contract # Negative test?  Preconditions:  * stakerAddr have called stakeGGP and was registered as a staker.  Inputs:  * cycleNumber:  Zellic 99 Multisig Labs    - Control: the value from the rewardsPool.getRewardsCycleCount() function call  - Checks: there aren't checks  - Impact: prevents re-receiving the reward in the same cycle. * stakerAddr:  - Control: owner of minipool. not controlled.  - Checks: the requireValidStaker function checks the address. If this ad- dress isn't staker, will revert.  - Impact: in case of full access it will allow any user to decrease the .ggpRe wards  * msg.sender: - Control: -  - Checks: onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) - Impact: access to the function by untrusted addresses will allow manipu- lating the .lastRewardsCycleCompleted value.  Function call analysis  * requireValidStaker() - What is controllable? stakerAddr - If return value controllable, how is it used and how can it go wrong? re- turn the stakerIndex corresponding to the stakerAddr. The Index must be unique, otherwise will be possible to lost funds.  - What happens if it reverts, reenters, or does other unusual control flow? will be reverted if stakerAddr is not a valid staker.  * setUint() - What is controllable? cycleNumber - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: getMinimumGGPStake()  Intended behavior:  * Retrieve staker's minimum GGP stake, based on current GGP price.  Branches and code coverage:  Intended branches:  Zellic 100 Multisig Labs    * Ensure that stakerAddr is valid; currently not checked # Test coverage  Preconditions:  * Assumes that the stakerAddr has some avaxAssigned to them.  Function call analysis  * (uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX(); - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? Part of the return value is ignored(that refers to the block.timestamp when the price has been updated) Maybe it's a good idea to also return that? The price could be really outdated; Add something like amax amount of blocks that go without update?  - What happens if it reverts, reenters, or does other unusual control flow? will revert if price is zero  Function: getCollateralizationRatio()  Intended behavior:  * Return collateralization ratio based on current GGP price.  Branches and code coverage:  Intended branches:  * Ensure that stakerAddr is valid; currently not checked # Test coverage  Preconditions:  * Assumes that the stakerAddr has some avaxAssigned to them.  Function call analysis  * (uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX(); - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? Part of the return value is ignored(that refers to the block.timestamp when the price has been updated) Maybe it's a good idea to also return that? The price could be really outdated; Add something like amax amount of blocks  Zellic 101 Multisig Labs    that go without update?  - What happens if it reverts, reenters, or does other unusual control flow? will revert if price is zero  Where is the function used:  * MinipoolManager: * Staking:  Function: getEffectiveRewardsRatio()  Intended behavior:  * return effective collateralization ratio used to pay rewards based on GGP price and AVAX high water.  Branches and code coverage:  Intended branches:  * Ensure that stakerAddr is valid; currently not checked # Test coverage  Preconditions:  * Assumes that the stakerAddr has some GGPstaked already.  Function call analysis  * (uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX(); - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? Part of the return value is ignored(that refers to the block.timestamp when the price has been updated) Maybe it's a good idea to also return that? The price could be really outdated; Add something like amax amount of blocks that go without update?  - What happens if it reverts, reenters, or does other unusual control flow? will revert if price is zero  * dao.getMaxCollateralizationRatio(); - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? re- turn the max collateralization ratio of GGP to Assigned AVAX eligible for rewards. This value is used for EffectiveGGPStaked value calculations for  Zellic 102 Multisig Labs    reward distribution process  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: getEffectiveGGPStaked()  Intended behavior:  * Get amount of ggp that will count towards the rewards cycle.  Branches and code coverage:  Intended branches:  * Ensure that stakerAddr is valid; currently not checked # Test coverage  Preconditions:  * the price value is set inside Oracle contract  Function call analysis  * (uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX(); - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? Part of the return value is ignored(that refers to the block.timestamp when the price has been updated) Maybe it's a good idea to also return that? The price could be really outdated; Add something like amax amount of blocks that go without update?  - What happens if it reverts, reenters, or does other unusual control flow? will revert if price is zero  Where is the function used:  * ClaimNodeOp:  Function: stakeGGP() and _stakeGGP  Intended behavior:  * Should allow any user to stake GGP into the contract.  Zellic 103 Multisig Labs    Branches and code coverage:  Intended branches:  * Should revert if msg.sender transferred less than amount tokens. 4# Test coverage  * The ggp balance of the msg.sender should deplete by amount, whilst the contract should have enough to deposit into the vault(like a middleman)  4# Test coverage * The GGPStake of the user should be increased by the staked amount.  4# Test coverage  Negative behavior:  * Limited negative testing  * Shouldn't allow transferring arbitrary tokens 4# Negative test?  Preconditions:  * Assumes msg.sender is registered as a staker in the contract; however, if that's not the case, it creates an index for a new staker:  * Assumes that msg.senderhas previously approved the amount that is to be trans- ferred by stakeGGP.  Inputs:  * amount: - Control: full control  - Checks: there are no 0 checks, however, they do safeTransferFrom user with the amount  - Impact: n/a  Function call analysis  * ggp.safeTransferFrom() - What is controllable? amount  - If return value controllable, how is it used and how can it go wrong? there ins't return value  - What happens if it reverts, reenters, or does other unusual control flow? will revert if msg.sender doesn't have enough ggp tokens.  * _stakeGGP() - What is controllable? amount  Zellic 104 Multisig Labs    - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: restakeGGP()  Intended behavior:  * allow restaking for claimedGGP rewards  Branches and code coverage:  Intended branches:  * after the call the .ggpStaked value of stakerAddr will be increased by amount value  4# Test coverage  Negative behavior:  Limited negative testing  * if msg.sender doesn't have enough ggp tokens, transaction will be reverted # Negative test?  * if msg.sender is not trusted ClaimNodeOp contract, transaction will be reverted # Negative test?  Preconditions:  * Assumes msg.sender is ClaimNodeOp * msg.sender must have at least the amount value of ggp tokens  Inputs:  * amount: - Control: limited control  - Checks: safeTransferFrom will revert if msg.sender balance less than amou nt  - Impact: - * stakerAddr:  - Control: full control  - Checks: there aren't any checks  - Impact: -  Zellic 105 Multisig Labs    * msg.sender: - Control: -  - Checks: onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender)  - Impact: the function allows caller to increase .ggpStaked value for any user. but caller should send this value of ggp tokens to contract  Function call analysis  * ggp.safeTransferFrom() - What is controllable? amount  - If return value controllable, how is it used and how can it go wrong? there ins't return value  - What happens if it reverts, reenters, or does other unusual control flow? will revert if msg.sender doesn't have enough ggp tokens.  * _stakeGGP() - What is controllable? amount  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: withdrawGGP()  Intended behavior:  * Allows withdrawing GGP tokens.  Branches and code coverage:  Intended branches:  * Should ensure that the .ggpStaked decreases. # Test coverage  Negative behavior:  * Should never lock-up ggp ; this could happen in a scenariowhere the msg.sender is never over 150% collateralization # Negative test?  Preconditions:  * Assumes that the user is over 150% in collateralization ratio.  Zellic 106 Multisig Labs    * Assure that maxCollateralizationRatio is syncedup! Maybe check the last block and compare it with the last block from getCollateralizationRatio as well?! a de-sync could lead to lower threshold of withdrawals. Any huge fluctuations would greatly affect this.  Inputs:  * amount: - Control: full controll  - Checks: checks that amount > getGGPStake and check that getCollaterali zationRatio(msg.sender) at least 150 after withdraw  - Impact: could lead to loss of funds if not depleted properly.  Function: slashGGP()  Intended behavior:  * Should be used by the MinipoolManager in case that a minipool has ended; this happen  Branches and code coverage:  Intended branches:  * Decrease the ggpStake of the staker (assuming staker has some left) 4# Test coverage  * StakerAddrmust be registered. # Test coverage  Negative behavior:  * Only allow minipoolmanager to call this. # Negative test?  Preconditions:  * Assumes that decreaseGGPSTake can be called on the stakerAddr(this implies that stakerAddr has been registered beforehand)  Inputs:  * ggpAmt: - Control: full control  - Checks: assumes that decreaseGGPStake properly decreases the amount  Zellic 107 Multisig Labs    that the stakerAddr has - Impact: n/a  Zellic 108 Multisig Labs    6 Audit Results  At the time of our audit, the code was not deployed to mainnet Avalanche.  During our assessment on the scopedGoGoPool contracts, we discovered seven find- ings. Of the seven findings, four were of high severity, one was of medium severity, one was of low severity and the remaining finding was informational. Multisig Labs acknowledged all findings and implemented fixes.  6.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 109 Multisig Labs   \tAbout Zellic \tExecutive Summary \tIntroduction \tAbout GoGoPool \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tThe transferAVAX function allows arbitrary transfers \tOcyticus does not include the Staking pause \tThe reward amount manipulation \tNetwork registered contracts have absolute storage control \tOracle may reflect an outdated price \tFields are not reset exactly after their usage \tContracts can deposit arbitrary tokens in the Vault  \tDiscussion \tThe rewardsCycleEnd calculation \tLack of checks \tThe process of distributing ggp rewards \tChecks-effects-interactions pattern \tMissing status update \tUnused variables \tContract upgrades \tIWithdrawer inheritance \tProtocol DAO setters range \tLeftover tokens in RewardsPool  \tThreat Model \tFile: TokenggAVAX \tFile: ClaimNodeOP \tFile: ClaimProtocolDAO.sol \tFile: BaseUpgradeable.sol \tFile: Base.sol \tFile: BaseAbstract.sol \tFile: Storage.sol \tFile: TokenGGP.sol \tFile: Vault.sol \tFile: MinipoolManager \tFile: MultisigManager \tFile: Ocyticus \tFile: Oracle \tFile: ProtocolDAO \tFile: RewardsPool \tFile: Staking  \tAudit Results \tDisclaimers  "
    }
]