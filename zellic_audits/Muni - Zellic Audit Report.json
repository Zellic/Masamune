[
    {
        "title": "3.1 Multiple contracts provide a function to renounce owner-",
        "target": " StakingRewards, MUNIState, MUNI",
        "category": " Business Logic",
        "severity": " Informational",
        "likelihood": " N/A ",
        "impact": " Informational ",
        "bodyDescription": "The StakingRewards, MUNIState, and MUNI contracts implement Ownable, which pro- vides a method named renounceOwnership that removes the current owner (refer- ence). This is likely not a desired feature. ",
        "bodyImpact": "If renounceOwnershipwere called, the contract would be left without an owner.  Recommendation  Override the renounceOwnership function:  function renounceOwnership() public { revert(\"This feature is not available.\");  } ",
        "remediation": "DFX Finance acknowledged this finding and created a fix in pull request #35.  Zellic 7 DFX Finance  https://docs.openzeppelin.com/contracts/2.x/api/ownership#Ownable-renounceOwnership-- https://docs.openzeppelin.com/contracts/2.x/api/ownership#Ownable-renounceOwnership-- https://github.com/dfx-finance/asc/pull/35  "
    },
    {
        "title": "3.2 Lack of interfaces for MUNILogicV1 and MUNI",
        "target": " MUNILogicV1, MUNI",
        "category": " Code Maturity",
        "severity": " Informational",
        "likelihood": " N/A ",
        "impact": " Informational ",
        "bodyDescription": "Interfaces for the public APIs of MUNILogicV1 and MUNI do not exist. ",
        "bodyImpact": "Interactions with smart contracts may be more difficult; it is a composability issue for future developers who want to build upon or understand the codebase.  Recommendation  We recommend adding all exposed/public APIs to interfaces in a way that accurately reflects the underlying code. ",
        "remediation": "DFX Finance acknowledged this finding and created a fix in pull request #37.  Zellic 8 DFX Finance  https://github.com/dfx-finance/asc/pull/37  "
    },
    {
        "title": "3.3 Centralization risk in StakingRewards and MUNI and MUNILogi",
        "* Target": " StakingRewards, MUNI, MUNILogicV1",
        "* Category": " Business Logic",
        "* Likelihood": " Informational ",
        "* Severity": " Informational",
        "* Impact": " Informational ",
        "Description": "Using the setRewardsDuration function, the owner can set the duration to a low value to redeem rewards quickly. The rewardsmust be claimed in a separate block because the rewards duration cannot be 0; if it were, the following code in notifyRewardAmou nt would result in a division by zero error--preventing rewards variables from being updated:  if (block.timestamp >) periodFinish) { rewardRate = reward / rewardsDuration;  } else { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rewardRate; rewardRate = (reward + leftover) / rewardsDuration;  }  Although any user has the same ability to claim rewards as the owner after the owner modifies the rewards duration, only the owner has the ability to cause reward tokens to change in value at any time by simply changing the rewards duration.  For example, By changing the duration to a low value, the supply of rewards tokens can quickly increase--causing the token to be worth less.  Additionally, the StakingRewards contract does not own the reward token; that is, a different party owns it and can mint tokens.  There is also an artificial limit on the amount of rewards the StakingRewards contract can provide because transfers would eventually fail when the contract's balance is zero. ",
        "Impact": "A malicious or compromised owner could potentially drain the pool or render the rewards token worthless.  Zellic 9 DFX Finance   ",
        "Recommendations": "Consider using a timelock for additional safety.  Also, the StakingRewards contract should own and manage the rewards token itself. ",
        "Remediation": "DFX Finance acknowledged this finding and created a fix in pull request #40.  Zellic 10 DFX Finance  https://github.com/dfx-finance/asc/pull/40   4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Incomplete test coverage  Testing coverage is adequate but not comprehensive. There are a few functionswhere there is very little or no coverage and where the testing is not comprehensive.  We recommend ensuring complete coverage of the following functions because they are integral to the protocol:  * In StakingRewards, all the functions that deal with rewards (both issuance and transfer): stake, withdraw, getReward.  * InMUNI andMUNILogicV1, all the functions that deal with rebalancing: execut iveRebalance, rebalance.  DFX Finance acknowledged this issue and created a fix in pull request #41.  4.2 Problems in code documentation  We noted a few references to gelato in the code documentation, for example in vari- ables' names:  Muni.sol/ MUNILogicV1.sol  ///)) @notice withdraw manager fees accrued, only gelato executors can call. ///)) Target account to receive fees is managerTreasury, alterable by  manager. ///)) Frequency of withdrawals configured with gelatoWithdrawBPS, alterable  by manager. function withdrawManagerBalance(uint256 feeAmount, address feeToken)  external {  We recommend changing the variable names in the code documentation so that they match the code to improve clarity.  Zellic 11 DFX Finance  https://github.com/dfx-finance/asc/pull/41   We also recommend ensuring all code has documentation. For example, adding doc- umentation to the StakingRewards contract would allow non-technical users to un- derstand how the contract works. Documentation improves code composability for developers.  DFX Finance acknowledged this issue and created a fix in pull request #40.  4.3 Unchecked external call returns  In the MUNI.sol file, the mint function calls pool.mintwithout checking the return val- ues of the function call:  function mint(uint256 mintAmount, address receiver) external nonReentrant returns (  uint256 amount0, uint256 amount1, uint128 liquidityMinted  ) {  /) ...)) } else {  /) if supply is 0 mintAmount =) liquidity to deposit (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(  sqrtRatioX96, lowerTick.getSqrtRatioAtTick, upperTick.getSqrtRatioAtTick, SafeCast.toUint128(mintAmount)  ); }  /) transfer amounts owed to contract if (amount0 > 0) {  token0.safeTransferFrom(msg.sender, address(this), amount0); } if (amount1 > 0) {  token1.safeTransferFrom(msg.sender, address(this), amount1); }  /) ...))  Zellic 12 DFX Finance  https://github.com/dfx-finance/asc/pull/40   pool.mint(address(this), lowerTick, upperTick, liquidityMinted, \"\");  Although this is not necessarily a security issue, the pool.mint call returns the amount of amount0 of token0 and amount1 of token1 that the caller paid for the subsequentmint. Should these values not match the amount the protocol asked the user to send in the following code, the contract would incur monetary loss:  /) ...))  /) transfer amounts owed to contract if (amount0 > 0) {  token0.safeTransferFrom(msg.sender, address(this), amount0); } if (amount1 > 0) {  token1.safeTransferFrom(msg.sender, address(this), amount1); }  /) ...))  We recommend adding an additional check just to ensure that what was asked from the user is indeed the amount that was finally paid to the issuing pool.mint.  /) ...)) (paidAmount0, paidAmount1) = pool.mint(address(this), lowerTick,  upperTick, liquidityMinted, \"\");  require(paidAmount0 =) amount0 &) paidAmount1 =) amount1, \"Mint prices differ\");  DFX Finance acknowledged this issue and created a fix in pull request #39.  Zellic 13 DFX Finance  https://github.com/dfx-finance/asc/pull/39  \tAbout Zellic \tIntroduction \tAbout MUNI \tMethodology \tScope \tProject Overview \tProject Timeline \tDisclaimer  \tExecutive Summary \tDetailed Findings \tMultiple contracts provide a function to renounce ownership \tLack of interfaces for MUNILogicV1 and MUNI \tCentralization risk in StakingRewards and MUNI and MUNILogicV1  \tDiscussion \tIncomplete test coverage \tProblems in code documentation \tUnchecked external call returns  "
    }
]