[
    {
        "title": "3.2 Improperly set parameter in constructor may lead to failed redemptions 10"
    },
    {
        "title": "3.1 Unexpected reverts where overflow may be desireable",
        "target": "   UniswapTwapPriceOracleV2, UniswapTwapPriceOracleV2Root ",
        "category": " Business Logic",
        "severity": " Medium",
        "likelihood": " High ",
        "impact": " High ",
        "bodyDescription": "The   UniswapTwapPriceOracleV2 is a modified version of the Compound   UniswapTwapPr iceOracleV2 contract. The Compound contract used Open Zeppelin's SafeMathUpgrad eable to check for arithmetic overflow and underflow issues.  Midas removed SafeMathUpgradeable and modified the Compound contracts to com- pile with solidity versions >=0.8.0 which by default includes checked arithmetic to revert on overflows and underflows.  The   UniswapTwapPriceOracleV2 imports UniswapTwapPriceOracleV2Root which has also been modified to replace the SafeMathUpgradeable functionality with solidity 0.8.0+ default checked arithmetic. However, in UniswapTwapPriceOracleV2Root there are por- tions of code related to price accumulation (currentPx0Cumu, currentPx1Cumu) and time weighted average price (price0TWAP, price1TWAP) where arithmetic overflow is desir- able. For further reading see Dapp's audit report of Uniswap v2.  This issue was duplicated with a parallel, internal review of the code conducted by Midas. ",
        "bodyImpact": "When calling getUnderlyingPrice, an overflow in either currentPx0Cumu or currentPx1 Cumu would lead to an unexpected transaction reversion, rendering the oracle useless. ",
        "bodyRecommendations": "Review all contracts in the codebase which were updated to compile with solidity 0.8.0+ and place unchecked blocks around code where overflow is desireable. This will allow values to wrap on overflows and underflows as expected in versions of solidity prior to 0.8.0.  Below is an example of corrected code for currentPx0Cumu in UniswapTwapPriceOracl eV2Root:  Zellic 8 Midas Capital  https://dapp.org.uk/reports/uniswapv2.html#orga2dab30   function currentPx0Cumu(address pair) internal view returns (uint256 px0Cumu) { uint32 currTime = uint32(block.timestamp); px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast(); (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves(); if (lastTime != block.timestamp) {  uint32 timeElapsed = currTime - lastTime; /) overflow is desired px0Cumu += uint256((reserve1 <) 112) / reserve0) * timeElapsed; unchecked {  uint32 timeElapsed = currTime - lastTime; /) overflow is desired px0Cumu += uint256((reserve1 <) 112) / reserve0) * timeElapsed;  } }  } ",
        "remediation": "The issue has been fixed by Midas Capital in commit a562fda.  Zellic 9 Midas Capital  https://github.com/Midas-Protocol/contracts/commit/a562fda11a60d818b9a5440a2de7408e9cb6d349  "
    },
    {
        "title": "3.2 Improperly set parameter in constructor may lead to failed",
        "target": " JarvisSynthereumLiquidator ",
        "category": " Business Logic",
        "severity": " Medium",
        "likelihood": " Low ",
        "impact": " High ",
        "bodyDescription": "Lack of input validation in the constructor on the _txExpirationPeriod parameter may lead to failed redemptions. ",
        "bodyImpact": "The variable txExpirationPeriod is included as an anti-slippage measure during re- demptions as it limits the amount of time a transaction can be included in a block. Mistakenly setting the _txExpirationPeriod to 0 or a low value may cause transac- tions to revert which will block user redemptions.  It is evident from Midas' deploy script and tests that they have considered this issue and have appropriately set a _txExpirationPeriod time of +40 minutes. Therefore we do not believe this has a security impact presently, but it may lead to future bugs. ",
        "bodyRecommendations": "Consider including a require statement in the constructor to impose a minimum thresh- old for _txExpirationPeriod. The Jarvis documentation recommends setting the ex- piration period to +30 minutes in the future to account for network congestion. ",
        "remediation": "The issue has been fixed by Midas Capital in commit 782b54.  Zellic 10 Midas Capital  https://github.com/Midas-Protocol/contracts/commit/782b549745b87ac7576b11f0ed3b4af59fdaa60b  "
    },
    {
        "title": "3.3 Lack of input validation in initialize",
        "target": " CurveLpTokenPriceOracleNoRegistry, FusePoolLens",
        "category": " Code Maturity",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "The initialize function in both CurveLpTokenPriceOracleNoRegistry and FusePoolL ens does not validate the passed array parameters which may lead to unintended storage outcomes. ",
        "bodyImpact": "In both of the initialize functions, Midas uses a for-loop to iterate through array parameters and append them to a mapping variable. If the lengths of the arrays are not equal, the initialize call will either revert or complete successfully with missing data.  In CurveLpTokenPriceOracleNoRegistry, the mappings poolOf and underlyingTokens may not be set to the intended values if the length of the array _lpTokens is less than the length of either the _pools or _poolUnderlyings arrays.  In FusePoolLens, the mapping variable hardcoded stores the mapping of token ad- dresses (_hardcodedAddresses) to TokenData which includes a token's name and symbol. If the length of the _hardcodedAddresses array is less than the length of the _hardcod edNames or _hardcodedSymbols arrays, then parameters in those arrays that exist after _hardcodedAddresses.length will not be stored. ",
        "bodyRecommendations": "Consider adding require statements in the initialize function to validate user-controlled data input and to ensure that array lengths are equal. ",
        "remediation": "The issue has been fixed by Midas Capital in commit c71037.  Zellic 11 Midas Capital  https://github.com/Midas-Protocol/contracts/commit/c710370499ddb54deaa7dc688ab7529a4d381aa7  "
    },
    {
        "title": "3.4 Centralization risk over multiple contracts",
        "target": " Multiple ",
        "category": " Code Maturity",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " High ",
        "bodyDescription": "In oracle contracts such as MasterPriceOracle, the contract's admin has central au- thority over functions such as setDefaultOracle. Likewise in FusePoolDirectory, the admin has full control over the deployer whitelist. ",
        "bodyImpact": "In case of a private key compromise, an attacker could change the defaultOracle to one which will report a favorable price, sandwiching their swap transaction between two calls to setDefaultOracle - the first to set a favorable oracle and the second to return the oracle to the benign default oracle. Similarly, an attacker would be able to whitelist malicious deployer addresses in FusePoolDirectory. ",
        "bodyRecommendations": "* Use a multi-signature address wallet, this would prevent an attacker from caus- ing economic damage if a private key were compromised.  * Set critical functions behind a TimeLock to catch malicious executions in the case of compromise. ",
        "remediation": "The issue has been acknowledged by Midas Capital and no changes have been made.  Midas states, \"Before announcing our live platform, we will be transferring admin functionality to MultiSig address, avoiding the risks of single point of failure.\"  Zellic 12 Midas Capital   "
    },
    {
        "title": "3.5 Remove renounceOwnership functionality",
        "target": " FuseFeeDistributor, FusePoolDirectory and CurveLpTokenPriceOracleNoReg- istry ",
        "category": " Business Logic",
        "severity": " Informational",
        "likelihood": " N/A ",
        "impact": " Informational ",
        "bodyDescription": "The FuseFeeDistributor, FusePoolDirectory and CurveLpTokenPriceOracleNoRegistry contracts implement OwnableUpgradeable which provides a method named renoun ceOwnership that removes the current owner (Reference). This is likely not a desired feature. ",
        "bodyImpact": "If renounceOwnership were called, the contract would be left without an owner. ",
        "bodyRecommendations": "Override the renounceOwnership function:  function renounceOwnership() public override onlyOwner{ revert(\"This feature is not available.\");  } ",
        "remediation": "Midas Capital states that they may remove ownership of the contracts in the future, so the renounceOwnership functionality remains. However, they have implemented a two step ownership change pattern for added safety when transferring contract ownership in commit eeea03.  Midas states, \"in the future we may want to completely remove ownership on the contracts and allow the system to work permissionlessly. All of the contracts are set up to make this possible, so we do not see this as an issue.\"  Zellic 13 Midas Capital  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/access/OwnableUpgradeable.sol#L53 https://github.com/Midas-Protocol/contracts/commit/eeea0398817315329a4244163f6324f2b1cf1d40  "
    },
    {
        "title": "3.6 Failing tests and missing coverage in test suite",
        "* Target": " Multiple contracts ",
        "* Category": " Code Maturity",
        "* Likelihood": " N/A ",
        "* Severity": " Low",
        "* Impact": " Informational ",
        "Description": "Several functions in the smart contracts are not covered by any unit or integration tests, to the best of our knowledge. We ran both the Hardhat test suite and the Forge tests.  In the Hardhat test suite, the tests createPoolViaSdk and createPoolViaContract both fail.  The Forge tests cover most of the contracts within the scope of this audit. However, the following contracts have no test coverage to the best of our knowledge:  * FusePoolLens.sol * FusePoolLensSecondary.sol * BlockVerifier.sol * MerklePatriciaVerifier.sol * Rlp.sol * UniswapOracle.sol * UQ112x112.sol ",
        "Impact": "Because correctness is so critically important when developing smart contracts, we recommend that all projects strive for 100% code coverage. Testing should be an essential part of the software development lifecycle. No matter how simple a function may be, untested code is always prone to bugs. ",
        "Recommendations": "Expand the test suite so that all functions and their branches are covered by unit or integration tests. ",
        "Remediation": "The issue has been acknowledged by Midas Capital and no changes have been made.  Midas states that \"The untested codebase is strictly related to the Keydonix imple-  Zellic 14 Midas Capital    mentation, which we currently have no plans of using or deploying. In case we pro- ceed with their usage, we'll proceed with a re-audit and development of the tests for those smart contracts. FusePoolLens.sol and FusePoolLensSecondary.sol are instead tested extensively at the integration level, being core components of both how our SDK fetches data from fuse pools, as well as how the UI displays such data.\"  Zellic 15 Midas Capital    4 Discussion  Strategy contracts  In addition to reviewing the 4626 vault strategies, we also checked the the external vaults with which the strategy contracts interact. It is important to validate that an at- tacker cannot manipulate a value in the external contracts that the strategies rely upon. For example, the function totalAssets is used to calculate the number of shares and assets based on data from external contracts. If an attacker is able to manipulate the totalAssets and call strategy functions before the state of the vault has been updated, then the number of shares issued to the attacker may be inflated.  For example, in the external contract AlpacaVault, the work function executes an ex- ternal call before updating the vaultDebtVal while also transferring out tokens. This is used when calculating totalToken, which the AlpacaERC4626 contract relies upon in the totalAssets() to calculate the total amount of underlying tokens the vault holds.  This can lead to a manipulation of totalAssets during a work call, inflating the shares minted. Currently, the use of a non-reentrant modifier for external functions, such as deposit and withdraw in AlpacaVault, called from afterDeposit and beforeWithdr aw prevents the attack from executing successfully. For more information on similar attacks, read this and this.  function convertToShares(uint256 assets) public view returns (uint256) { uint256 supply = totalSupply; /) Saves an extra SLOAD if totalSupply is non-zero.  return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets() );  }  The share price is based on totalAssets()  function totalAssets() public view override returns (uint256) { return alpacaVault.balanceOf(address(this)).mulDivDown(alpacaVault. totalToken(), alpacaVault.totalSupply());  }  That depends on totalToken(), which can be artifically deflated.  Developers should be aware that an attacker may be able to use an external call from  Zellic 16 Midas Capital  https://inspexco.medium.com/value-defis-invalid-share-calculation-exploit-in-depth-analysis-1c8f97c1416e https://nipunp.medium.com/5-8-21-rari-capital-exploit-timeline-analysis-8beda31cbc1a   the vault to make a reentrant call or a call to an attacker controlled contract so a vault's external calls should be scrutinized. This is very important when external data/calls are used to calculate share prices of an 4626 vault.  Re-entrancy in Compound  We were requested to provide a cursory review of re-entrancy issues in compound right after the rari hack. Following are our recommendations:  * Consider updating the doTransferOut in CEther.sol to prevent possible re-entrancy.  function doTransferOut(address to, uint256 amount) internal override { /) Send the Ether and revert on failure (bool success, ) = to.call{ value: amount }(\"\"); to.transfer(amount); require(success, \"doTransferOut failed\");  }  * Consider updating the borrowInternal in CToken.sol to correctly follow check- effects-interaction, preventing exploitation from exotic ERC20s with callbacks.  function borrowFresh(address borrower, uint256 borrowAmount) internal returns (uint256) { ...)) doTransferOut(borrower, borrowAmount);  /) We write the previously calculated values into storage *) accountBorrows[borrower].principal = vars.accountBorrowsNew; accountBorrows[borrower].interestIndex = borrowIndex; totalBorrows = vars.totalBorrowsNew;  doTransferOut(borrower, borrowAmount);  * If possible, merge patches from latest Compound codebase. This would prevent any known issues from inadvertedly causing unexpected problems in the future.  Documentation  As a consequence of updating the Fuse codebase, which is a modified fork of the Compound codebase, many aspects of the documentation are either outdated, inac- curate or insufficient. The codebase is more difficult to read and reason about than it  Zellic 17 Midas Capital  https://twitter.com/hacxyk/status/1520370421773725698?s=21&t=MiArt55x0TLrZ_2648l6tQ   should be due to the interchangeable use of NativeToken and ETH.  Code maturity is very important in high-assurance projects. Undocumented code may result in developer confusion, potentially leading to future bugs, should the code need to be modified later on. In general, lack of documentation impedes auditors and external developers from reading, understanding, and extending the code. The problem will also be carried over if the code is ever forked or re-used.  Zellic 18 Midas Capital   \tAbout Zellic \tIntroduction \tAbout Midas \tMethodology \tScope \tProject Overview \tProject Timeline \tDisclaimer  \tExecutive Summary \tDetailed Findings \tUnexpected reverts where overflow may be desireable \tImproperly set parameter in constructor may lead to failed redemptions \tLack of input validation in initialize \tCentralization risk over multiple contracts \tRemove renounceOwnership functionality \tFailing tests and missing coverage in test suite  \tDiscussion "
    }
]