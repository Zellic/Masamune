[
    {
        "title": "3.2 IPyth interface and implementation do not follow the recommended"
    },
    {
        "title": "3.1 Possible usage of stale price information",
        "target": " Solana attester, Ethereum and Terra consumer contracts ",
        "category": " Business Logic",
        "severity": " Critical",
        "likelihood": " High ",
        "impact": " Critical ",
        "bodyDescription": "The following four separate issues when chained together lead to a critical outcome:  attest performs insufficient sanity checks  The attest function (from attest.rs) of the Solana attester contract does not enforce any restriction on the publication timestamp of the price being attested. Therefore, it could be leveraged to publish out of date pricing information when the prices have not been updated for a while.  Ethereum contract performs insufficient sanity checks  The Ethereum contract consuming price attestations does not perform any sanity check on the price publication timestamp. A last-resort check is performed in queryP- riceFeed on the price attestation timestamp. This check is not particularly effective as the attestation timestamp represents when the attestation program attested the price information through Wormhole, not when the price itself was published.  Terra contract performs insufficient sanity checks  Similar to the ethereum contract, the terra contract does not perform any validation against the price publication timestamp. A check is performed in the query_price_info method against the attestation timestamp but as stated previously, it is not sufficient to determine the liveliness of the pricing data, but merely the liveness of the stream of pricing information.  Zellic 7 Pyth Data Foundation    Developer documentation misses important safety notice  The documentation does not recommend the user to check the publication timestamp when retrieving a price, significantly increasing the likelihood of an unsafe usage of the API. In addition, users cannot retrieve publication timestamp from IPyth interface but instead have to use queryPriceFeed, which is not a part of IPyth. ",
        "bodyImpact": "Stale price accounts can be passed to the attester program and reach Pyth users on other blockchain platforms. After discussionwith the Pyth team, this category of pub- lishing stale pricing information is considered critical. Pyth users are unlikely to have implemented sanity checks that prevent them from using outdated information since there's no recommendation to do so in Pyth documentation, and would therefore use the stale data.  Recommendation  Regarding the attester program:  * refuse to attest outdated prices, for instance by checking the publish_time field of the PriceAttestation struct  Regarding the Ethereum smart contract:  * If possible, add sanity checks on the price publication timestamp by default to all public facing functions  * Otherwise, expand IPyth to expose the information required to implement those sanity checks, and clearly document the need for it  Regarding the Terra smart contract:  * Implement sanity checks on the price publication timestamp by default for all public facing functions ",
        "remediation": "The finding has been acknowledged by Pyth Data Foundation. Their official response is reproduced below:  Pyth Data Association acknowledges the finding and developed a patch for this issue: https://github.com/pyth-network/pyth2wormhole/pull/194  Zellic 8 Pyth Data Foundation  https://github.com/pyth-network/pyth2wormhole/pull/194   https://github.com/pyth-network/pyth2wormhole/pull/196  Zellic 9 Pyth Data Foundation  https://github.com/pyth-network/pyth2wormhole/pull/194  "
    },
    {
        "title": "3.2 IPyth interface and implementation do not follow the rec-",
        "target": " Pyth2Wormhole ethereum contract ",
        "category": " Code Maturity",
        "severity": " Low",
        "likelihood": " N/A ",
        "impact": " Low ",
        "bodyDescription": "The documentation for the IPyth public interface suggest the following best practices:  * Use products with at least 3 active publishers * Check the status of the product * Use the confidence interval to protect your users from price uncertainty  The first recommendation cannot be followed using only the functions exposed by I- Pyth, and the documentation does not elaborate on what additional functions should be used.  IPyth exposes the following three functions:  function getCurrentPrice(bytes32 id) external view returns (PythStructs. Price memory price);  function getEmaPrice(bytes32 id) external view returns (PythStructs. Price memory price);  function getPrevPriceUnsafe(bytes32 id) external view returns ( PythStructs.Price memory price, uint64 publishTime);  PythStructs.Price does not contain information about how many publishers con- tributed to the given price.  A user could still call queryPriceFeed (a public functionwhich is not part of IPyth). This function returns an instance of PythStructs.PriceFeed, a struct that contains fields that can hold the required information.  However, internally the contract does not copy this information from the price attes- tation.  function newPriceInfo(PythInternalStructs.PriceAttestation memory pa) private view returns (PythInternalStructs.PriceInfo memory info) {  info.attestationTime = pa.timestamp; /) [code shortened for brevity]  Zellic 10 Pyth Data Foundation  https://docs.pyth.network/consumers/best-practices   /) These aren't sent in the wire format yet info.priceFeed.numPublishers = 0; info.priceFeed.maxNumPublishers = 0; return info;  }  This comment appears to be incorrect with respect to the attestation program re- viewed by Zellic. The attest function creates instances of the PriceAttestation struct using PriceAttestation:)from_pyth_price_bytes, which does set the num_publishers and max_num_publishers fields. ",
        "bodyImpact": "Consumers of Pyth data on Ethereummight not follow the documented best practices and use unreliable price information.  Recommendation  * Modify the IPyth interface to provide a way for Pyth users to read how many publishers were aggregated to compute a given price.  * Modify newPriceInfo to read from the price attestation the number of publishers that contributed to the price ",
        "remediation": "The finding has been acknowledged by Pyth Data Foundation. Their official response is reproduced below:  Pyth Data Association acknowledges the finding, but doesn't believe it has secu- rity implications. However, we may deploy a bug fix to address it.  Zellic 11 Pyth Data Foundation   "
    },
    {
        "title": "3.3 Limited test-suite and code coverage",
        "target": " Pyth2Wormhole attester contract ",
        "category": " Code Maturity",
        "severity": " Low",
        "likelihood": " N/A ",
        "impact": " Low ",
        "bodyDescription": "Pyth Solana attester has only one test for the contract main function, attest (located in pyth2wormhole/client/tests/test_attest.rs). ",
        "bodyImpact": "A comprehensive testsuite covering all functionality is very effective in discovering existing bugs and prevent future ones.  Recommendation  We highly recommend Pyth to develop a comprehensive test-suite with maximum code coverage. ",
        "remediation": "The finding has been acknowledged by Pyth Data Foundation. Their official response is reproduced below:  Pyth Data Association acknowledges the finding, but doesn't believe it has secu- rity implications. However, we may deploy a bug fix to address it.  Zellic 12 Pyth Data Foundation   "
    },
    {
        "title": "3.4 Missing access control on initializer function",
        "* Target": " Pyth2Wormhole ethereum contract ",
        "* Category": " Coding Mistakes",
        "* Likelihood": " Low ",
        "* Severity": " Informational",
        "* Impact": " Informational ",
        "Description": "Contract Pyth (Pyth.sol) contains a public initializer function without any modifiers enforcing access control:  function initialize( address wormhole, uint16 pyth2WormholeChainId, bytes32 pyth2WormholeEmitter  ) virtual public { setWormhole(wormhole); setPyth2WormholeChainId(pyth2WormholeChainId); setPyth2WormholeEmitter(pyth2WormholeEmitter);  }  An attacker could call this function and set theWormhole address, Chain ID and Emit- ter address to any arbitrary value.  At present, the function cannot be called by an attacker since it is overridden by Pyt- hUpgradable:)initialize, a function with the same prototype that does perform the appropriate access control checks. However, having such a dangerous function ex- poses Pyth to an unneeded risk of it being inadvertentlymade reachable by an attacker with a future code refactoring. ",
        "Impact": "If the function was to be exposed e.g. in a future code refactor, an attacker could call it and trivially take over the contract by setting arbitrary values for theWormhole and Emitter contracts. This would allow them to submit arbitrary price attestations.  Recommendation  We recommend one of the following remediations:  * Apply initializermodifier to Pyth:)initialize * Rename Pyth:)initialize and mark it as private  Zellic 13 Pyth Data Foundation   ",
        "Remediation": "The finding has been acknowledged by Pyth Data Foundation. Their official response is reproduced below:  Pyth Data Association acknowledges the finding, but doesn't believe it has secu- rity implications. However, we may deploy a bug fix to address it.  Zellic 14 Pyth Data Foundation    4 Discussion  The purpose of this section is to document miscellaneous observations the we made during the assessment. Those observations do not have a security impact, and are expressed with the intent of increasing code quality, efficiency and readability.  4.1 Extraneous test condition in terra test code  The test_verify_vaa_sender_fail_wrong_emitter_address test in the terra codebase is meant to only test that verify_vaa_sender fails if the emitter_address is incorrect. This first tests the intended condition, but then tests that verify_vaa_sender fails if the emitter_chain is incorrect. This is a useful invariant to validate but is already exer- cised by a separate test test_verify_vaa_sender_fail_wrong_emitter_chain already and should be removed from test_verify_vaa_sender_fail_wrong_emitter_address.  4.2 latestPriceInfo does not check if price ID exists  latestPriceInfo (from PythGetters.sol) does not checkwhether the price ID exists in the _state.latestPriceInfo map and therefore returns a zero-initialized struct if the key does not exist.  There are two usages of latestPriceInfo (both in Pyth.sol):  * One usage in queryPriceFeed, where the return value is explicitly checked to ensure the price ID was valid  * One usage in updatePriceBatchFromVm, where no check is performed  It's unclear whether this edge case of latestPriceInfo was considered when writing updatePriceBatchFromVm.  function updatePriceBatchFromVm(bytes memory encodedVm) public returns ( PythInternalStructs.BatchPriceAttestation memory bpa) { /) [shortened for brevity...))] PythInternalStructs.BatchPriceAttestation memory batch = parseBatchPriceAttestation(vm.payload);  for (uint i = 0; i < batch.attestations.length; i++) { PythInternalStructs.PriceAttestation memory attestation = batch.  attestations[i];  Zellic 15 Pyth Data Foundation    PythInternalStructs.PriceInfo memory latestPrice = latestPriceInfo(attestation.priceId);  if(attestation.timestamp > latestPrice.attestationTime) { setLatestPriceInfo(attestation.priceId, newPriceInfo(  attestation)); }  }  return batch; }  If latestPrice is a zero-initialized struct, the attestationTime field has zero value, and the function still behaves correctly treating the attestation as new information to be added to the map.  We strongly suggest putting a notice in latestPriceInfo documentation, explaining the behaviour of the function and instructing the caller on how to check whether the given price ID existed in the map.  Alternatively, we encourage Pyth to consider implementing a safer getter, for instance returning a tuple (PriceInfo result, bool error). This significantly reduces the like- lihood of a caller ignoring the possibility of the price ID not existing in the map due to the additional parameter.  4.3 Extra check in attest  Function attest (from attest.rs) performs a redundant check.  The function expects as input an account structure of type Attest:  #)derive(FromAccounts, ToInstruction)] pub struct Attest<'b> {  /) Payer also used for wormhole pub payer: Mut<Signer<Info<'b>>>, pub system_program: Info<'b>, pub config: P2WConfigAccount<'b, { AccountState:)Initialized }>, /) ...)) more fields  The configmember is a type alias for solitaire Derive type:  Zellic 16 Pyth Data Foundation    pub type P2WConfigAccount<'b, const IsInitialized: AccountState> = Derive<Data<'b, Pyth2WormholeConfig, { IsInitialized }>, \"pyth2wormhole-config\">;`  At the beginning of the function a check is performed to ensure the config account public key is a program derived address (PDA).  pub fn attest(ctx: &ExecutionContext, accs: &mut Attest, data: AttestData ) -> SoliResult<()> { accs.config.verify_derivation(ctx.program_id, None)?; /) ...))  This check is redundant, as the Peel trait for Derived already ensures that the account public key corresponds to the expected one.  4.4 Hardcoded magic value  Pyth.sol contains two instances of the hardcoded literal 0x50325748.  We suggest creating a constant literal such as  /) Comment explaining what this magic value is uint32 constant PYTH_MAGIC = uint32(bytes4(\"P2WH\"));  Zellic 17 Pyth Data Foundation   \tAbout Zellic \tIntroduction \tAbout Pyth2Wormhole \tMethodology \tScope \tProject Overview \tProject Timeline \tDisclaimer  \tExecutive Summary \tDetailed Findings \tPossible usage of stale price information \tIPyth interface and implementation do not follow the recommended best practices \tLimited test-suite and code coverage \tMissing access control on initializer function  \tDiscussion \tExtraneous test condition in terra test code \tlatestPriceInfo does not check if price ID exists \tExtra check in attest \tHardcoded magic value  "
    }
]