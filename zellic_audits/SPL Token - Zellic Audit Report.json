[
    {
        "title": "3.2 Missing check in process_withdraw potentially leading to inflationary bug 12"
    },
    {
        "title": "3.1 Missing check in process_transfer leading to inflationary bug",
        "target": " Confidential Transfer Extension ",
        "category": " Coding Mistakes",
        "severity": " Critical",
        "likelihood": " High ",
        "impact": " Critical ",
        "bodyDescription": "Transfers between confidential accounts require a zero knowledge (ZK) argument prov- ing that the source account balance is greater than the transferred amount and that the transferred amount is not negative.  Confidential token transfer transactions consist of two instructions. The first required instruction contains a cryptographic ZK argument that proves the validity of the trans- fer without disclosing any information about the balances involved or the transferred amount. The other instruction performs the computations and updates the account state to actually perform the transfer.  The ZK argument instruction is processed by a special built-in program that verifies its validity, reverting if validation fails. More specifically, the ZK argument is an equation in which some variables have values that correspond to the state of the accounts involved in the transaction.  The other instruction is processed by the token program. The program verifies that the instruction containing the ZK argument exists and that its inputs are consistent with the state of the involved accounts, tying the ZK argument to the state of the blockchain.  The token program does not correctly verify all the ZK argument inputs. One of the fields associated with the ZK argument, new_source_ciphertext, is ignored. This field contains the expected value of the source account encrypted balance after the trans- fer is performed. The lack of this check implies that the source account encrypted balance is not validated. This effectively decouples the ZK argument from the bal- ance of the source account. ",
        "bodyImpact": "A malicious transaction constructed to exploit the issue allows to perform repeated transfers, totalling an amount bigger than the source account encrypted balance.  We created a proof-of-concept exploit by constructing a transaction with multiple  Zellic 9 Solana Foundation    instructions performing a transfer, all referencing the same instruction containing the ZK argument.  The source account encrypted balance underflows and becomes invalid, but the des- tination account encrypted pending balance is creditedmultiple times, creating tokens out of nothing and inflating the supply. The supply inflation will not be reflected by the information stored in the mint account associated with the token. The destination account is able to apply the pending balance and make use of the unfairly obtained amount normally.  The PoC would perform the following operations:  [!] Starting double transfer PoC [!] Current balances: Alice:  - available balance: 42 - pending balance: 0  Bob: - available balance: 0 - pending balance: 0  [!] Running malicious transaction. Instructions: - Instruction 0: TransferWithFeeData instruction  - amount: 42 - Instruction 1: ConfidentialTransferInstruction:)Transfer instruction - Instruction 2: ConfidentialTransferInstruction:)Transfer  instruction (repeated)  [!] Current balances: Alice: could not decrypt balances Bob:  - available balance: 0 - pending balance: 84  [!] Applying Bob pending balance [!] Current balances: Alice: could not decrypt balances Bob:  - available balance: 84 - pending balance: 0  Zellic 10 Solana Foundation   ",
        "bodyRecommendations": "Ensure that the source account encryptedbalance corresponds to the expected amount contained in the ZK argument (the new_source_ciphertext field of the TransferData struct). ",
        "remediation": "The Solana Foundation team was alerted of this finding while the audit was ongo- ing. The team quickly confirmed the issue and submitted a remediation patch for our review. The patch correctly implements the suggested remediation.  Pull request #3867 fixes the issue following our recommendation. The PR head com- mit c7fbd4bwas merged in the master branch on December 3, 2022.  The confidential token transfer extension was not used at the time the audit was con- ducted; therefore, no funds were at risk.  Zellic 11 Solana Foundation  https://github.com/solana-labs/solana-program-library/pull/3867  "
    },
    {
        "title": "3.2 Missing check in process_withdraw potentially leading to in-",
        "target": " Confidential Transfer Extension ",
        "category": " Coding Mistakes",
        "severity": " Critical",
        "likelihood": " High ",
        "impact": " Critical ",
        "bodyDescription": "Withdrawals froma token account confidential balance to its cleartext balance require a zero knowledge (ZK) argument that proves that the account encrypted balance is greater than the withdrawn amount.  Confidentialwithdraw transactions consist of two instructions. One contains the afore- mentioned ZK argument and is processed by a special built-in program that verifies its validity, reverting the transaction in case of failure. The other instruction, processed by SPL Token 2022, performs the operations on the balances to actually accomplish the withdrawal. The token program verifies that the instruction containing the ZK ar- gument exists and that its inputs are consistentwith the state of the involved accounts, tying the ZK argument to the state of the blockchain.  The token program does not correctly verify that the public key associatedwith the ZK argument corresponds to the public key associated to the source account encrypted balance. This potentially allows an attacker to forge a ZK argument asserting the va- lidity of any desired withdrawal amount, regardless of the actual encrypted balance of the source account.  Refer to 5 for more information on the equations implementing the ZK argument. ",
        "bodyImpact": "An attacker might be able to exploit this issue and withdraw an arbitrary amount of tokens to their cleartext balance, creating tokens fromnothing and inflating the supply. Note that the supply inflationwill not be reflected by the information stored in themint account associatedwith the token. The plaintext balance is spendable, exactly like any other regular plaintext balance on a legitimate account.  We did not fully confirm exploitability of this issue, but the team agreed that it is likely possible to forge a malicious ZK equality argument.  Zellic 12 Solana Foundation   ",
        "bodyRecommendations": "Ensure that the public key associatedwith the source account corresponds to the pub- lic key associated with the ZK argument (the pubkey field of the WithdrawData struct). ",
        "remediation": "The Solana Foundation team was alerted of this finding while the audit was ongoing. The team quickly helped confirm the issue.  Pull request #3768 fixes the issue following our recommendation. The PR head com- mit 94b912awas merged in the master branch on October 27, 2022.  The confidential token transfer extension was not used at the time the audit was con- ducted; therefore, funds were not at risk.  Zellic 13 Solana Foundation  https://github.com/solana-labs/solana-program-library/pull/3768  "
    },
    {
        "title": "3.3 Missing public key check in EmptyAccount leading to defla-",
        "target": " Confidential Transfer Extension ",
        "category": " Coding Mistakes",
        "severity": " High",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "A token account can only be closed if it has a zero balance. This applies to the regu- lar cleartext balance as well as to the balances managed by the confidential transfer extension. Since the latter balances are encrypted, a special instruction called Empt yAccount has to be executed before closing the account, which enables closing the account after verifying a zero knowledge (ZK) argument that proves the account bal- ance is zero.  Similarly to other confidential token operations, a ZK argument has to be embedded in an instruction in the same transaction that invokes EmptyAccount. The processor for EmptyAccount verifies that the ZK argument exists and that it is correctly tied to the current state of the blockchain.  The function processing the EmptyAccount instruction does not check that the pub- lic key associated with the ZK argument corresponds to the public key of the token account to be closed. This might allow an attacker to forge a ZK argument, falsely showing the account balance to be zero. ",
        "bodyImpact": "By closing an account with a nonzero balance, an attacker would be able to decrease the circulating supply without causing an update to the supply information stored in the mint account.  The attacker would have to give up their balance; therefore, it is difficult to imagine an incentive to perform such an attack. Furthermore, the same effect could be obtained by simply keeping the tokens in the attacker's account. For this reason, this issue is classified as low likelihood and low impact. ",
        "bodyRecommendations": "Ensure that the public key associated with the proof corresponds to the public key of the account being closed.  Zellic 14 Solana Foundation   ",
        "remediation": "Pull request #3767 fixes the issue following our recommendation. The PR head com- mit d6a72ebwas merged in the master branch on October 27, 2022.  Zellic 15 Solana Foundation  https://github.com/solana-labs/solana-program-library/pull/3767  "
    },
    {
        "title": "3.4 Confidential transfer amounts information leak via transfer",
        "target": " Confidential Transfer Extension ",
        "category": " Business Logic",
        "severity": " Low",
        "likelihood": " N/A ",
        "impact": " Low ",
        "bodyDescription": "Tokens managed by SPL Token 2022 can be configured to require a transfer fee con- sisting of a percentage of the transferred amount (with the possibility to cap the max- imum fee at a fixed amount). This configuration also applies to confidential transfers, relying on zero-knowledge cryptographic arguments to prove the validity of the en- crypted balances being manipulated.  Information about the value of every transfer is leaked to the owner of the keys con- trolling the transfer fees for the mint. ",
        "bodyImpact": "The owner of the private key associated with management of the transfer fees can gather information on the value of confidential transfers. Since the key is able to de- crypt the fee balance before and after the transfer has occurred, the fee amount for every transfer can be obtained. If the fee is lower than the cap amount, then the exact transferred amount can be inferred. Otherwise, the transferred amount is guaranteed to be at least as big as the minimum amount that would require the maximum fee. ",
        "bodyRecommendations": "Completely blinding the transfer fee amounts appears to be challenging and likely to require a significant engineering effort. If this information leak is accepted, we suggest to informSPL token developers and users of this privacy pitfall of confidential transfers involving fees. ",
        "remediation": "Pull request #3773 addresses the issue by adding more documentation on the confi- dential transfer extension code, acknowledging the potential information leak if a con- fidential transfer with fees is performed. The PR head commit 1c3af5ewas merged in the master branch on October 28, 2022.  Zellic 16 Solana Foundation  https://github.com/solana-labs/solana-program-library/pull/3773  "
    },
    {
        "title": "3.5 Confidential transfer fees' withdrawal instructions ignore",
        "target": " Confidential Transfer Extension ",
        "category": " Coding Mistakes",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "The functions handling the confidential transfer instructions WithdrawWithheldTokensF romAccounts and WithdrawWithheldTokensFromMint ignore some of the restrictions that can be applied to confidential token accounts:  * allow_balance_credits: An account can be configured to deny credits to its pending balance.  * pending_balance_credit_counter: This value should be checkednot to be greater than maximum_pending_balance_credit_counter. The instructions also do not in- crement pending_balance_credit_counter.  We note that these instructions directly add the entire value of the withheld balance to the pending_balance_lo of the destination account. This could potentially cause the pending balance to become bigger than 216 or even 232, making decryption of the balance difficult. ",
        "bodyImpact": "An attacker with control of the keys trusted with managing transfer fees could credit the encrypted pending balance of an account bypassing the configuration applied by the account owner and potentially make it difficult for the victim to decrypt the en- crypted balance. ",
        "bodyRecommendations": "* Revert the transaction if allow_balance_credits is set on the destination ac- count.  * Revert the transaction if pending_balance_credit_counter is not less than maxim um_pending_balance_credit_counter. Increment pending_balance_credit_count er after the transfer taken place.  Since the value of the transferred balances is encrypted, limiting the transferred value to avoid overflowing the soft amount of 232 is challenging andwould require extensive modifications.  Zellic 17 Solana Foundation   ",
        "remediation": "Pull request #3774 fixes the issue following our recommendation. The PR head commit 16384e2was merged in the master branch on October 28, 2022.  The confidential token transfer extension was not used at the time the audit was con- ducted; therefore, funds were not at risk.  Zellic 18 Solana Foundation  https://github.com/solana-labs/solana-program-library/pull/3774  "
    },
    {
        "title": "3.6 Confidential token account public key is not validated",
        "* Target": " Confidential Transfer Extension ",
        "* Category": " Coding Mistakes",
        "* Likelihood": " High ",
        "* Severity": " Low",
        "* Impact": " Informational ",
        "Description": "A confidential token account can be initialized with an arbitrary 32-byte buffer as the public key used to encrypt the account balances. Proving knowledge of the associ- ated private key is not required for initializing a confidential transfer account. Legiti- mate public keys are derived as P = kH , meaning they are an element of the group generated by H . The lack of validation allows to set a potentially invalid public key that can be generically written as P = aH + bG, opening an opportunity for attacks leveraging the invalid pubkey. ",
        "Impact": "Due to the limited amount of time available for the audit, we could not fully evaluate the exploitability of this issue. It appears that controlling an account public key is not enough to forge a ciphertext-commitment equality argument (refer to 5). However, we consider not validating the public key a risk, potentially opening the opportunity for critical exploits. ",
        "Recommendations": "Require proof of knowledge of the secret key associated with the public key when initializing a confidential token account. ",
        "Remediation": "Pull request #28392 on Solana's zk-token-sdk adds a public key validity proof to the ZK token SDK.  Pull request #3784 integrates the public key validity proof with the instruction that initializes the confidential transfer extension for an account. The PR head commit abc 77afwas merged in the master branch on October 30, 2022.  The confidential token transfer extension was not used at the time the audit was con- ducted; therefore, funds were not at risk.  Zellic 19 Solana Foundation  https://github.com/solana-labs/solana-program-library/pull/3784   4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Behavior of multisig accounts with repeated signers  During our audit we observed that it is possible to initialize a multisig account with the same signer repeated multiple times.  The function used for validating the signers of a transaction, validate_owner, counts a signer of a transaction as having signed it the exact number of times the account is repeated, regardless of how many times the account appears in the list of sign- ers. Despite this being reasonable behavior, it is unclear if this specific edge case was considered.  The Solana Foundation engineering team acknowledged this discussion point.  4.2 Unclear purpose for some confidential account fields  The actual_pending_balance_credit_counter and expected_pending_balance_credit_ counter fields contained in the ConfidentialTransferAccount struct seem largely un- used, and their purpose is unclear.  The Solana Foundation engineering team acknowledged this discussion point.  4.3 Unnecessary initialization check in _process_initialize_mi nt  When _process_initialize_mint calls StateWithExtensionMut::<Mint>::unpack_unin itialized(...))), a check is performed internally that validates that the unpacked ac- count is not initialized. This specifically validates that the base field is not initialized. As this condition is validated, the immediately proceding check is unnecessary and can never be true.  if mint.base.is_initialized { return Err(TokenError:)AlreadyInUse.into());  }  Zellic 20 Solana Foundation    The Solana Foundation engineering teamaddressed this discussion point and removed the redundant check in pull request #3763. The head commit of the PR d331f47 was merged in the master branch on October 26, 2022.  4.4 Confusing account owner check  Account ownership checks are performedusing a couple of different patterns through- out the codebase. Themain two checks are via validate_owner(...))) and check_progr am_account(...))), which work well. One area of confusion, though, is that calling get_ required_account_extensions_from_unpacked_mint(...))) performs an account own- ership check. It is suggested that this check be migrated into StateWithExtensions:) unpack and StateWithExtensionsMut:)unpack. The SWE and SWEM unpack methods are only used with accounts that the program should own and would increase the re- siliency of the codebase bymitigating a potential future situation where an account or mint is unpacked and data are used for some decision but program ownership failed to be checked.  The Solana Foundation engineering team acknowledged this discussion point.  4.5 Suggested alternative extension dedup  The implementation of get_total_tlv_len(...))) takes the slice of provided extensio n_types and deduplicates the collection before summing each of their tlv_lens. The implementation uses a for loop that calls Vec:)contains(...))). For small number of extensions this may be okay, but in calls to realloc, this could result in slow code if callers are inefficient with passed up extension (offering duplicates, for example).  A suggested alternative would be to use a HashSet here. For performance, FxHashSet may be used if solving for this situation is desired.  The Solana Foundation engineering team acknowledged this discussion point; their testing shows that for vectors of size 76 and below, Vec:)contains is more efficient than HashSet.  Zellic 21 Solana Foundation    5 Appendix A: ZK equality argument equa- tion  The following paragraph complements finding 3.2 and describes the equation that im- plements one of the two ZK arguments involved in withdrawal transactions. This ZK argument asserts that the plaintext value of a given ciphertext (consisting of a Peder- sen commitment and decryption handle) is the same as that of a different Pedersen commitment.  Prerequisite definitions:  * O is the point at infinity * G is the Ristretto base point * H is the auxiliary point used for construction of the Pedersen commitment scheme * public keys Pi are represented as Pi = aiH + biG  - legitimate public keys are derived from a secret ki as Pi = k-1 i H , so ai =  k-1 i and bi = 0  - rogue public keys could have a nonzero biG term * encrypted values are represented as a tuple Ei = (Ci;Di), where  - Ci = miG+ riH  - Di = riP  - mi is the plaintext  - ri is an arbitrary (normally random) scalar  - P is the public key of the recipient of the ciphertext  The equality argument is constructed, referring to  * the legitimate public key PL = aLH + bLG - this is the pubkey associated with the confidential account  - bL might not be zero when leveraging issue 3.6 * the rogue public key PR = aRH + bRG  - this public key can differ from the legitimate public key when leveraging issue 3.2  * the encrypted balance ES = (CS ;DS) = (mSG+ rSH; rSP1)  * the Pedersen commitment CD = mDG+ rDH  The values provided must satisfy the following relationship:  zSPR-cH-Y0+wzXG+wzSDS-wcCS-wY1+w2zXG+w2zRH-w2cCD-w2Y2 = O  Zellic 22 Solana Foundation    The following additional values have been introduced:  * witness variables c and w - the relationship must hold for any possible value of these variables  * scalars zS , zX and zR - these scalars are completely free and can be set arbitrarily  * points Yi = piH + qiG, for i  0, 1, 2 - these points cannot depend on the value of any witness variable  The relationship can be expanded by expressing all the points as a sum of their two components xH and yG:  (zSaR - c- p0 + wzSrSaL - wcrS - wp1 + w2zR - w2crD - w2p2)H+  (zSbR - q0 + wzX + wzSrSbL - wcmS - wq1 + w2zX - w2cmD - w2q2)G = O  We can set up the following system of equations from the two scalar components of the relationship:  { zSaR - c- p0 + wzSrSaL - wcrS - wp1 + w2zR - w2crD - w2p2  0 (mod ord(H))  zSbR - q0 + wzX + wzSrSbL - wcmS - wq1 + w2zX - w2cmD - w2q2  0 (mod ord(G))  The system can be manipulated to obtain the following,  { (zR - crD - p2)w  2 + (zSrSaL - crS - p1)w + (zSaR - c- p0)  0 (mod ord(H))  (zX - cmD - q2)w 2 + (zSrSbL - cmS - q1 + zX)w + (zSbR - q0)  0 (mod ord(G))  which is satisfied if the following system of equations is satisfied:    zR - crD - p2  0 (mod ord(H))  zSrSaL - crS - p1  0 (mod ord(H))  zSaR - c- p0  0 (mod ord(H))  zX - cmD - q2  0 (mod ord(G))  zSrSbL - cmS - q1 + zX  0 (mod ord(G))  zSbR - q0  0 (mod ord(G))  Zellic 23 Solana Foundation    6 Audit Results  At the time of our audit, the code was partially deployed to mainnet Solana.  During our audit, we discovered six findings. Of these, two were critical, three were low risk, and one was informational. Solana Foundation acknowledged all findings and implemented fixes.  6.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 24 Solana Foundation   \tAbout Zellic \tExecutive Summary \tIntroduction \tAbout SPL Token 2022 \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tMissing check in process_transfer leading to inflationary bug \tMissing check in process_withdraw potentially leading to inflationary bug \tMissing public key check in EmptyAccount leading to deflationary bug \tConfidential transfer amounts information leak via transfer fees \tConfidential transfer fees' withdrawal instructions ignore constraints \tConfidential token account public key is not validated  \tDiscussion \tBehavior of multisig accounts with repeated signers \tUnclear purpose for some confidential account fields \tUnnecessary initialization check in _process_initialize_mint \tConfusing account owner check \tSuggested alternative extension dedup  \tAppendix A: ZK equality argument equation \tAudit Results \tDisclaimers  "
    }
]