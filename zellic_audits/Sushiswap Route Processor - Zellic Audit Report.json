[
    {
        "title": "3.1 The transferred amount may not reflect msg.value",
        "target": " RouteProcessor",
        "category": " Business Logic",
        "severity": " Medium",
        "likelihood": " Medium ",
        "impact": " Medium ",
        "bodyDescription": "The wrapAndDistributeERC20Amounts function wraps the native tokens that were sup- plied by the user and then forwards them to the pools that RouteProcessor interacts with. Here, the msg.value parameter is not checked against the amountTotal variable, leaving room for error.  function wrapAndDistributeERC20Amounts(uint256 stream, address token) private returns (uint256 amountTotal) {  wNATIVE.deposit{value: msg.value}();  uint8 num = stream.readUint8(); amountTotal = 0;  for (uint256 i = 0; i < num; +)i) { address to = stream.readAddress(); uint256 amount = stream.readUint(); amountTotal += amount; IERC20(token).safeTransfer(to, amount);  } } ",
        "bodyImpact": "This could lead to loss of funds for the end user in the case that they transfer more than the required amount.  Zellic 9 Sushiswap   ",
        "bodyRecommendations": "We recommend adding a check to ensure that msg.value =) amountTotal at the end of the function, as shown below:  function wrapAndDistributeERC20Amounts(uint256 stream, address token) private returns (uint256 amountTotal) {  wNATIVE.deposit{value: msg.value}();  uint8 num = stream.readUint8(); amountTotal = 0;  for (uint256 i = 0; i < num; +)i) { address to = stream.readAddress(); uint256 amount = stream.readUint(); amountTotal += amount; IERC20(token).safeTransfer(to, amount);  }  require(msg.value =) amountTotal, \"RouteProcessor: invalid amount\"); } ",
        "remediation": "This issue was fixed by Sushiswap in commit 4aa4bd3.  Zellic 10 Sushiswap  https://github.com/sushiswap/sushiswap/commit/4aa4bd358367c683b6d85e3340c7a231d06d6826  "
    },
    {
        "title": "3.2 Arbitrary token transfers in wrapAndDistributeERC20Amounts",
        "target": " RouteProcessor",
        "category": " Coding Mistakes",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "The wrapAndDistributeERC20Amounts function wraps and then forwards the wrapped tokens from the RouteProcessor contract to the pools that it interacts with.  function wrapAndDistributeERC20Amounts(uint256 stream, address token) private returns (uint256 amountTotal) {  wNATIVE.deposit{value: msg.value}();  uint8 num = stream.readUint8(); amountTotal = 0;  for (uint256 i = 0; i < num; +)i) { address to = stream.readAddress(); uint256 amount = stream.readUint(); amountTotal += amount;  /) @audit arbitrary `token` is passed, instead of `wNATIVE` IERC20(token).safeTransfer(to, amount);  } }  Due to the way the token parameter is passed to the safeTransfer function, it is pos- sible to pass an arbitrary token address to the function. This allows for anyone to send tokens on behalf of the contract.  This is not a highly critical issue, as the RouteProcessor contract should, in theory, be interacted with via the Sushiswap front end, which would generate a legitimate token address in its route generation process. Moreover, it is not expected of the contract to hold any tokens, as it is designed to be used as a one-time transaction.  Zellic 11 Sushiswap   ",
        "bodyImpact": "The transaction is reverted, and the tokens are not sent. In some cases, it could lead to tokens up for grabs in the MEV (e.g., via front-running), should any user unknowingly transfer tokens to the RouteProcessor contract. ",
        "bodyRecommendations": "We recommend removing the token parameter altogether.  function wrapAndDistributeERC20Amounts(uint256 stream) private returns (uint256 amountTotal) {  wNATIVE.deposit{value: msg.value}();  uint8 num = stream.readUint8(); amountTotal = 0;  for (uint256 i = 0; i < num; +)i) { address to = stream.readAddress(); uint256 amount = stream.readUint(); amountTotal += amount;  IERC20(wNATIVE).safeTransfer(to, amount); } require(msg.value =) amountTotal, \"RouteProcessor: invalid amount\");  } ",
        "remediation": "This issue was fixed by Sushiswap in commit 4aa4bd3.  Zellic 12 Sushiswap  https://github.com/sushiswap/sushiswap/commit/4aa4bd358367c683b6d85e3340c7a231d06d6826  "
    },
    {
        "title": "3.3 Usage of transfer()method for native tokens",
        "* Target": " RouteProcessor",
        "* Category": " Business Logic",
        "* Likelihood": " N/A ",
        "* Severity": " Informational",
        "* Impact": " Informational ",
        "Description": "The unwrapNative calls Solidity's transfer method to send full native tokens balance to receiver account. ",
        "Impact": "The transfermethod uses a hardcoded amount of gas (2300) andmay fail if gas costs increase in the future. ",
        "Recommendations": "Consider using the payable(receiver).call.value(value)(\"\") function:  (bool success, ) = payable(receiver).call.value(address(this).balance)(\"\");  require(success, \"Transfer failed.\"); ",
        "Remediation": "The Sushiswap team has decided not to address this particular finding at the time of writing this report and may consider addressing it in the future.  Zellic 13 Sushiswap  https://docs.soliditylang.org/en/v0.8.17/units-and-global-variables.html#members-of-address-types https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/#dont-use-transfer-or-send   4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Disallow tokenIn and tokenOut to be the same  The tokenIn and tokenOut parameters of the processRoute function are currently not checked to be different. As of the current state of the implementation, there seems to be no security implications of this. The sole issue would be the waste of gas for the transaction, which should revert eventually, during the UniswapV2Pair swap call.  However, it is not clear if this would be the case in the future. Therefore, it is recom- mended to add a check that tokenIn and tokenOut are different.  function processRoute( address tokenIn, uint256 amountIn, address tokenOut, uint256 amountOutMin, address to, bytes memory route  ) external payable returns (uint256 amountOut) { require(tokenIn !) tokenOut, \"TokenIn and TokenOut must be different\");  4.2 Passing the tokenIn in a consistent way  In the RouteProcessor contract, the tokenIn parameter is passed in two different ways.  In the distributeBentoShares function, the token parameter is passed as a parameter, called with token = tokenIn in the processRoute parent function.  function processRoute( address tokenIn, uint256 amountIn, address tokenOut, uint256 amountOutMin, address to,  Zellic 14 Sushiswap    bytes memory route ) external payable returns (uint256 amountOut) {  /) ...))  if (commandCode =) 24) amountInAcc += distributeBentoShares(stream, tokenIn);  /) ...)) }  function distributeBentoShares(uint256 stream, address token) private returns (uint256 amountTotal) { /) ...))  }  In the bentoWithdrawAllFromRP, however, the tokenIn from the parent function is dis- regarded, and the token is read from the stream, despite the fact that it is theoretically the same with the tokenIn parameter.  function processRoute( address tokenIn, uint256 amountIn, address tokenOut, uint256 amountOutMin, address to, bytes memory route  ) external payable returns (uint256 amountOut) { /) ...)) else if (commandCode =) 27) bentoWithdrawAllFromRP(stream); /) .)  }  function bentoWithdrawAllFromRP(uint256 stream) private { /) ...)) address token = stream.readAddress(); /) ...))  }  We recommend opting for the first approach and passing the tokenIn as a parameter to all the functions that do not do so already.  Zellic 15 Sushiswap    5 Threat Model  This provides a full threat model description for various functions. As time permitted, we analyzed each function in the smart contracts and created a written threat model for some critical functions. A threat model documents a given function's externally controllable inputs and how an attacker could leverage each input to cause harm. Not all functions in the audit scope may have been modeled. The absence of a threat model in this section does not necessarily suggest that a function is safe.  5.1 File: InputStream  Function: createStream(bytes memory data)  Intended behavior  * Internal function * Allows creating a data stream for a route * Stores the actual data and its length; presumably there's no limit to the length of the data  * Stores everything in memory, and nothing in storage  Branches and code coverage  Intended branches  * Should temporarily store the data in memory starting from pointer 0x40 # Test coverage  Negative behavior  * Memory shouldn't be overwritable # Negative test?  Preconditions  * Assumes the memory is empty at this point  Inputs  * data - Control: Full control; it's passed from a parameter of the external function. - Authorization: No checks whatsoever into what the stream is supposed to  Zellic 16 Sushiswap    do or what it's doing.  - Impact: Could have high impact since you're telling the routeprocessor what route to process for you and what commands to execute.  Function call analysis  There aren't external calls.  Function: isNotEmpty(uint256 stream)  Intended behavior  * Internal function * Supposed to tell whether the current stream has ended or not. The stream ba- sically refers to the memory pointer of the current stream.  Branches and code coverage  Intended branches  * Check whether the current position of the stream is less than the final stored position of the stream # Test coverage  Preconditions  * Assumes that the stream cannot be arbitrarily accessed, other than through the specific internal functions.  Inputs  * stream: - Control: Partial control: it's created through createStream - Authorization: N/A  - Impact: N/A  Function call analysis  There aren't external calls.  Function: readUint8(uint256 stream)  Zellic 17 Sushiswap    Intended behavior  * Internal function * Read the next value from the stream; assumes that it's an uint8  Branches and code coverage  Intended branches  * Move 1 byte to the right (the amount of bytes necessary for an uint8). # Test coverage  * Should return from memory the uint8 value stored at that particular pointer in the stream. # Test coverage  Negative behavior  * Shouldn't allow reading something else other than an uint8. # Negative test?  Preconditions  * Assumes that the next value is indeed an uint8.  Inputs  * stream - Control: Partial control; it's created through createStream - Authorization: N/A  - Impact: N/A  Function call analysis  There aren't external calls.  Function: readUint(uint256 stream)  Intended behavior  * Internal function * Read the next value from the stream, assuming that it's an uint. * The thing here is that it will never fail, even if an address is read instead of an  uint apparently; it will get casted. There's also no input validation so everything is really tricky.  Zellic 18 Sushiswap    Branches and code coverage  Intended branches  * Return the uint stored at that memory pointer. # Test coverage  * Move 32 bytes to the right (amount necessary for uint256 AKA uint ) # Test coverage  Negative behavior  * Shouldn't allow reading a value if it's not uint256; this doesn't appear to be en- forced. # Negative test?  Preconditions  * Assumes that the value that's read really is an uint256.  Inputs  * stream - Control: Partial control; it's created through createStream - Authorization: N/A  - Impact: N/A  Function call analysis  There aren't external calls.  Function: readAddress()  Intended behavior  * Internal function * Read the next value from the stream, assuming it's an address.  Branches and code coverage  Intended branches  * Move 20 bytes to the right, the amount necessary for an address. # Test coverage  Negative behavior  Zellic 19 Sushiswap    * Shouldn't allow reading a value if it's not an address; this doesn't appear to be enforced. # Negative test?  Preconditions  * Assumes that the value that's read really is an address.  Inputs  * stream: - Control: Partial control; it's created through createStream - Authorization: N/A  - Impact: N/A  Function call analysis  There aren't external calls.  Function: readBytes()  Intended behavior  * Internal function * Read the next value from the stream, assuming it's bytes.  Branches and code coverage  Intended branches  * Read 32 bytes and then move all the way to the length of the bytes object. # Test coverage  Negative behavior  * Shouldn't allow reading a value if it's not a bytes; this doesn't appear to be en- forced. # Negative test?  Preconditions  * Assumes that the value that's ready really is of bytes type.  Zellic 20 Sushiswap    Inputs  * stream - Control: Partial control; it's created through createStream - Authorization: N/A  - Impact: N/A  Function call analysis  There aren't external calls.  5.2 File: RouteProcessor  Function: bentoDepositAmountFromBento(uint256 stream, address token)  Intended behavior  * Transfers tokens from BentoBox to a pool.  Branches and code coverage  Intended branches  * Should transfer from BentoBox to a pool. There's nothing enforcing that to is a pool though! It can be anything! # Test coverage  Negative behavior  * Shouldn't allow depositing own balance of token. # Negative test?  Preconditions  * \"Expected to be launched for initial liquidity distribution from user to Bento, so we know exact amount\" - Sushiswap team.  * Native tokens or ERC20 tokens must be present to the bentoBox address. * Assumes that the address.this has been whitelisted by the BentoBox to perform actions on its behalf.  Inputs  * token - Control: Full control; can be arbitrary token  Zellic 21 Sushiswap    - Authorization: No checks  - Impact: The address of ERC20 token contract can be zero address or the bentoBox contract should have non-zero balance of this token  * to - Control: Full control  - Authorization: No checks whether this is an authorized pool or not  - Impact: The receiver of tokens * stream  - Control: Assumed it's correct  - Authorization: N/A  - Impact: In case of incorrect data, the amount value can be parsed incor- rectly  Function call analysis  * bentoBox.deposit() - What is controllable? token, to, amount - If return value controllable, how is it used and how can it go wrong? There isn't a return value here.  - What happens if it reverts, reenters, or does other unusual control flow? Can revert if bentoBox balance of tokens less then amount value.  Function: bentodepositAllFromBento()  Intended behavior  * Similar to bentoDepositAmountFromBento, but the amount value is calculated inside the function.  Function: bentoWithdrawShareFromRP()  Intended behavior  * Withdraw all Bento tokens from Bento to an address.  Branches and code coverage  Intended branches  * Withdraw a share of bentoTokens from the bentoBox. # Test coverage  Negative behavior  Zellic 22 Sushiswap    * No tokens should be left in there after the entire route is executed. # Negative test?  Preconditions  * Assumes token have been deposited on behalf of address(this) beforehand but in the same transaction (since no funds can be leftover).  * This contract is allowed to use funds belonging to the from address.  Inputs  * token - Control: Full control  - Authorization: No checks  - Impact: The address of the ERC20 tokens contract can be zero address, or this contract should have a non-zero balance of these tokens inside the bentoBox contract  * stream - Control: Full control  - Authorization: No checks  - Impact: in case of incorrect data, the amount value can be parsed incor- rectly  Function call analysis  * bentoBox.withdraw() - What is controllable? to - if the address is wrong but exists, the funds may be lost, amount. This is prone to leeching, since if there's a case where someone leaves some tokens, they can be taken away from the contract by front-running for example. Important to keep in mind. Presumably, these types of errors are accounted for in the front end.  - If return value controllable, how is it used and how can it go wrong? This function returns amountOut and shareOut values, but caller function ignores them.  - What happens if it reverts, reenters, or does other unusual control flow? Can revert in some cases: if to - zero or if transfer ends with an error.  Function: bentoWithdrawAllFromRP()  Intended behavior  * Allows to withdraw all user's tokens from bentoBox.  Zellic 23 Sushiswap    * Same happens for this function as the bentoWithdrawShareFromRP function. The main difference is that share = 0 there and amount = 0 here.  Function: swapTrident()  Intended behavior  Allows to perform swap over trident pool.  Branches and code coverage  Intended branches  * The transaction will be successful if the pool address implements the swap func- tion. # Test coverage  * Make sure that the result of the swap is correct. # Test coverage  Negative behavior  * Will revert if the tokens were not previously transferred. # Test coverage  Preconditions  * The token0 and token1 bento balance of the called pool must be replenished beforehand.  Inputs  * swapData  * Control: Controlled - Authorization: No checks  - Impact: Contains the necessary information for performing the swap * pool  - Control: Controlled  - Authorization: No checks  - Impact: The address of pool, which implemented the IPool swap logic - should be trusted pool for user  Function call analysis  * IPool(pool).swap(swapData)  Zellic 24 Sushiswap    - What is controllable? pool, swapData - If return value controllable, how is it used and how can it go wrong? There isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? Canbe reverted as a result of an error in the transfer of funds over bentobox contract  Function: swapUniswapPool  Intended behavior  * Allows to perform swap over sushi/uniswap pool.  Branches and code coverage  Intended branches  * Only allow swapping own funds (as in, same transaction). This is the intended behavior.  4# Test coverage * Whitelist the pools that can be interacted with.  # Test coverage  Negative behavior  * Shouldn't use just any pools # Negative test?  Preconditions  * Assumes the pool is a legitimate one. Anything can be supplied really. * Assumes that the contract has previously supplied collateral to the pool such that the swap can happen.  * Assumes that it's a total swap  0 t0 and all t1 or all t0 and 0 t1.  Inputs  * pool - Control: Full control  - Authorization: N/A  - Impact: The address of pool, which implemented the IUniswapV2Pair swap logic - should be trusted pool for user  * tokenIn  Zellic 25 Sushiswap    - Control: Full control  - Authorization: Limited; perhaps there is some on the pool side, but not trustworthy  - Impact: The address of the token to swap must match one of the tokens' addresses in the pool  Function call analysis  * IUniswapV2Pair(pool).swap() - What is controllable? The pool - can be an arbitrary one - If return value controllable, how is it used and how can it go wrong? There isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? Canbe reverted as a result of an error in the transfer of funds over bentobox contract  Function: distributeERC20Amounts  Intended behavior  * Distributes input ERC20 tokens from msg.sender to addresses. Tokens should be approved.  Branches and code coverage  Intended branches  * Decrease the balance of the msg.sender . # Test coverage  * Increase the balances of all the to addresses by their subsequent amount # Test coverage  Negative behavior  * Shouldn't allow msg.sender not to send enough tokens or to trick the system by sending illegitimate ones. # Negative test?  Preconditions  * Assumes msg.sender has approved the transfer.  Zellic 26 Sushiswap    Inputs  * amount - Control: Full control  - Authorization: N/A; it's assumed that msg.sender has approved the contra ct to transfer  - Impact: N/A * to  - Control: Full control  - Authorization: No checks  - Impact: In case of wrong address, tokens can be lost * token  - Control: Full control  - Authorization: No checks - tokens transfermust be approved for this con- tract  - Impact: N/A  Function call analysis  * IERC20(token).safeTransferFrom(msg.sender, to, amount) - What is controllable? token, amount, to - If return value controllable, how is it used and how can it go wrong? There isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? N/A  Function: wrapAndDistributeERC20Amounts()  Intended behavior  * Should allow wrapping all native tokens and distributing the Wrapped ERC20 to- kens from RP to addresses.  Branches and code coverage  Intended branches  * Balance of contract should decrease by amount. # Test coverage  * Balance of other addresses should increase by amount. # Test coverage  Negative behavior  Zellic 27 Sushiswap    * Shouldn't allow transferring more than msg.value. Otherwise, it could revert or transfer leftover funds. # Negative test?  * Shouldn't allow transferring just any tokens, and should only use wNATIVE. # Negative test?  * Shouldn't allow anyone to front-run/leech off remaining wnative if they didn't supply enough msg.value in the first place. This should in theory be handled, since the entire swaphappens in one long transaction (constructedby the Sushiswap back end). # Negative test?  Preconditions  * Assumes that msg.value is enough to cover for all the amountTotal. Currently there's no check put in place for that.  Inputs  * to - Control: Full control  - Authorization: Presumably it's sent to a pool, so it should be trusted.  - Impact: In case of wrong address, tokens can be lost * token  - Control: Full control  - Authorization: There's no checks; it is necessary to check that token =) wNative  - Impact: N/A * amount  - Control: Full control  - Authorization: There's no checks; it is necessary to check that sharesTotal =) msg.value  - Impact: N/A  Function call analysis  * IERC20(token).safeTransfer(to, amount); - What is controllable? token, amount, to - If return value controllable, how is it used and how can it go wrong? There isn't a return value  - What happens if it reverts, reenters, or does other unusual control flow? N/A  Zellic 28 Sushiswap    Function: distributeBentoShares()  Intended behavior  * Allow distributing input Bento tokens from msg.sender to addresses.  Branches and code coverage  Intended branches  * Balances of the to addresses should increase. # Test coverage  * Balances of the msg.sender should decrease. # Test coverage  * Should be transferred to pools, but there's no enforcing this for the to parame- ters. # Test coverage  * Assumes that the tokens that are about to be transferred are legitimate. # Test coverage  Negative behavior  * Shouldn't allow transferring unwanted token to trick the system by any means. # Negative test?  Preconditions  * Requires that msg.sender has approved the amounts that are about to be trans- ferred.  Inputs  * share - Control: Full control  - Authorization: No checks; thiswill fail if msg.senderdoesn't have enough/has not approved enough anyway  - Impact: The number of shares that will be transferred * token  - Control: Full control  - Authorization: No checks  - Impact: Shares on the balance inside the bentoBox should be enough to transfer  * to - Control: Full control  Zellic 29 Sushiswap    - Authorization: No checks  - Impact: The receiver of shares  Function call analysis  * bentoBox.transfer(token, msg.sender, to, share); - What is controllable? token, to, share - If return value controllable, how is it used and how can it go wrong? There isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? Will revert if to is zero or balance of msg.sender is less than share amount  Function: distributeERC20Shares()  Intended behavior  * Distributes ERC20 tokens from RP to addresses. * Shares are distributed instead of amounts to minimize slippage during swaps.  Branches and code coverage  Intended branches  * Allow transferring from this contract to to the amount of tokens, based on the shares that are calculated above. # Test coverage  Negative behavior  * Shouldn't allow the transfer of just any ERC20. # Negative test?  * Shouldn't allow transferring unwanted token to trick the system by any means. # Negative test?  Preconditions  * Assumes that the contract has enough shares to transfer.  Inputs  * token - Control: Full control (func param)  - Authorization: No checks here; any token can be used - Impact: N/A  Zellic 30 Sushiswap    * shares - Control: Full control; user can transfer however much they want  - Authorization: No authorization checks; anyone can call this  - Impact: The amount of shares that uses for amount of tokens calculations  Function call analysis  * IERC20(token).safeTransfer(to, amount); - What is controllable? token, to, amount - If return value controllable, how is it used and how can it go wrong? There isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? N/A  Function: distributeBentoPortions()  Intended behavior  * Distributes the routeProcessor tokens that the Bento holds to addresses.  Branches and code coverage  Intended branches  * Shouldn't allow leeching off these portions. It's assumed that theywill be stored beforehand so technically anyone couldmake this call. This shouldn't, however, be possible, since no fundwill be left over after a chain of commands (the entire route) is executed. This should happen if that route was generated by the back end. # Test coverage  Negative behavior  * Shouldn't allow transferring unwanted token to trick the system by any means. # Negative test?  Preconditions  * Assumes that address.this has previously deposited some tokens in that Bento and that there's a way to do so anyway.  Inputs  * share / amount  Zellic 31 Sushiswap    - Control: Full control  - Authorization: No checks here; basically anyone can transfer any value if there's enough balance  - Impact: N/A * token  - Control: Full control to any token that can be transferred from bentoBox - Authorization: No checks on the token whatsoever; it's assumed it exists in bentoBox, should fail otherwise  - Impact: The balance of tokens inside bentoBox should be non-zero  Function call analysis  * bentoBox.transfer(token, address(this), to, amount); - What is controllable? token, to, share - If return value controllable, how is it used and how can it go wrong? There isn't a return value  - What happens if it reverts, reenters, or does other unusual control flow? Will revert if to is zero or balance of address(this) is less than amount  Function: unwrapNative()  Intended behavior  * Allow unwrapping the native token and transferring it to the receiver.  Branches and code coverage  Intended branches:  * Should withdraw the entire wnative balance -1 of this contract. This means re- ceiving the native.  4# Test coverage * Transfer the native after it has been received from the wnative to the receiver - thus, receiver.balance += address(this).balance. # Test coverage  Negative behavior:  * Shouldn't allow transferring funds that have been deposited by someone else. This is covered by the \"intended\" usage of the code, since after a route has been executed, no funds should be left in the contract.  4# Negative test?  Zellic 32 Sushiswap    Preconditions  * Assumes no funds will exist in either the wNATIVE or the contract before or after the route execution.  Inputs  * receiver - Control: Full control  - Authorization: There's no checks; however, this is the intended function- ality  - Impact: Arbitrary recipient of native tokens  Function call analysis  * payable(receiver).transfer(address(this).balance); - What is controllable? receiver - If return value controllable, how is it used and how can it go wrong? N/A  - What happens if it reverts, reenters, or does other unusual control flow? There should be no balance left, so reentering is not an issue. Moreover, reverting leads to the entire route execution being reverted.  * wNATIVE.withdraw(IERC20(address(wNATIVE)).balanceOf(address(this)) - What is controllable? - balanceOf(address(this)) - If return value controllable, how is it used and how can it go wrong? - n/a  - What happens if it reverts, reenters, or does other unusual control flow? It means contract doesn't have the required funds for some reason; the entire chain of the route's commands reverts.  Zellic 33 Sushiswap    6 Audit Results  At the time of our audit, the code was not deployed to mainnet EVM.  During our audit, we discovered three findings. Of these, onewas ofmedium risk, one was of low risk, and one was a suggestion (informational). Sushiswap acknowledged all findings and implemented fixes.  6.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 34 Sushiswap   \tAbout Zellic \tExecutive Summary \tGoals of the Assessment \tNon-goals and Limitations \tResults  \tIntroduction \tAbout Route Processor \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tThe transferred amount may not reflect msg.value \tArbitrary token transfers in wrapAndDistributeERC20Amounts \tUsage of transfer() method for native tokens  \tDiscussion \tDisallow tokenIn and tokenOut to be the same \tPassing the tokenIn in a consistent way  \tThreat Model \tFile: InputStream \tFile: RouteProcessor  \tAudit Results \tDisclaimers  "
    }
]