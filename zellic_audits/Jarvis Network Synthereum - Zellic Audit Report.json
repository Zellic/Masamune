[
    {
        "title": "3.1 migratePool results in loss of funds",
        "target": " LendingStorageManager",
        "category": " Business Logic",
        "severity": " Medium",
        "likelihood": " Low ",
        "impact": " High ",
        "bodyDescription": "The lending storage manager includes a function to migrate the multiple liquidity pool to a new address; this function can only be called by the multiple liquidity pool. The migration function does not migrate critical accounting information such as the total number of synthetic tokens or the collateral assets of the liquidity providers.  function migratePool(address oldPool, address newPool) external override nonReentrant onlyPoolFactory  { ...)) /) copy storage to new pool newPoolData.lendingModuleId = oldLendingId; newPoolData.collateral = oldPoolData.collateral; newPoolData.interestBearingToken = oldPoolData.interestBearingToken; newPoolData.jrtBuybackShare = oldPoolData.jrtBuybackShare; newPoolData.daoInterestShare = oldPoolData.daoInterestShare; newPoolData.collateralDeposited = oldPoolData.collateralDeposited; newPoolData.unclaimedDaoJRT = oldPoolData.unclaimedDaoJRT; newPoolData.unclaimedDaoCommission = oldPoolData.unclaimedDaoCommission ;  ...)) }  The following critical accounting information in the pool is not migrated:  contract SynthereumMultiLpLiquidityPool...)) uint256 internal totalSyntheticAsset;  Zellic 8 Jarvis    ...)) mapping(address => LPPosition) internal lpPositions; ...)) ",
        "bodyImpact": "The multiple liquidity pool currently does not implement a function calling the pool migration function; however, implementing a function calling the migration function in its current state would result in lost funds. ",
        "bodyRecommendations": "We recommend removing the function until the implementation is corrected. We further note that fixing these issues will require more than just changing the migrate Pool(...))) function in the lending storage manager; it will also require changes to be made in the multiple liquidity pool to update the fields totalSyntheticAsset and read and update the lpPositionsmapping. ",
        "remediation": "Jarvis has made considerable efforts to address the concerns conveyed in this find- ing. They have created a library for managing the pool migration, which appears to address the main concerns of (1) migrating LP-level collateral and token assets and (2) migrating total pool synthetic tokens. It is important to note, however, that this mi- gration contract lies outside of the core scope of this audit and has hence not received the same level of scrutiny as the rest of the contracts. Furthermore, we have not been presented with an updated multiple liquidity pool contract that utilizes this library for pool migrations. Jarvis appears to be on the right track here, and we look forward to seeing a completed and safely implemented pool migration function in the future.  Zellic 9 Jarvis   "
    },
    {
        "title": "3.2 Swap lacks slippage and path checks",
        "target": " Univ2JRTSwap ",
        "category": " Business logic",
        "severity": " Low",
        "likelihood": " Medium ",
        "impact": " Medium ",
        "bodyDescription": "The Uniswapmodule of swapping collateral into JRT does not support passing a pa- rameter for the slippage check.  amountOut = router.swapExactTokensForTokens( amountIn, 0, /) no slippage check swapInfo.tokenSwapPath, recipient, swapInfo.expiration  )[swapInfo.tokenSwapPath.length - 1];  Moreover, the last element of the swap's path is not checked to be the JRT token. ",
        "bodyImpact": "The protocol may lose tokens due to overallowance of slippage, since the swap itself can get sandwich attacked by front runners. This may heavily affect larger amounts of collateral being swapped. ",
        "bodyRecommendations": "We recommend implementing the minTokensOut field in the SwapInfo and then passing that in the swap function call.  amountOut = router.swapExactTokensForTokens( amountIn, swapInfo.minTokensOut, /) slippage check passed swapInfo.tokenSwapPath, recipient, swapInfo.expiration  )[swapInfo.tokenSwapPath.length - 1];  Moreover, similarly to the BalancerJRTSwap's SwapInfo struct, we recommend adding  Zellic 10 Jarvis  https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L232   the jrtAddress field and checking it to match with the last index of the swap path, like so:  ...)) uint256 swapLength = swapInfo.tokenSwapPath.length; require(  swapInfo.tokenSwapPath[swapLength - 1] =) jrtAddress, 'Wrong swap asset'  ); ...)) ",
        "remediation": "Jarvis has sufficiently addressed the finding by introducing the necessary anti-slippage parameter and required check for the last element of the swap path to be equal to the address of the JRT token.  Zellic 11 Jarvis   "
    },
    {
        "title": "3.3 Centralization risk",
        "target": " Project Wide, IFinder ",
        "category": " Centralization Risk",
        "severity": " Low",
        "likelihood": " N/A ",
        "impact": " Low ",
        "bodyDescription": "The protocol relies heavily on the synthereum finder to provide the correct addresses for critical contract interactions such as the price feed, lending manager, lending stor- agemanager, commission receiver, buy back program receiver, and the interest bear- ing token. For example,  function _getPriceFeedRate( ISynthereumFinder _finder, bytes32 _priceIdentifier  ) internal view returns (uint256) { ISynthereumPriceFeed priceFeed =  ISynthereumPriceFeed( _finder.getImplementationAddress(SynthereumInterfaces.PriceFeed)  );  return priceFeed.getLatestPrice(_priceIdentifier); } ",
        "bodyImpact": "Although the function in _finder that manages the contract addresses is access con- trolled (as shown in the code below), compromised keys could result in exploitation. For example, an attacker could change the priceFeed to a malicious contract. The compromised priceFeed could report a heavily depressed price to allow the attacker to mint a large number of synthetic tokens for very little collateral. The attacker could then massively increase the price to redeem synthetic tokens for a large amount of collateral, effectively draining the pool of its collateral assets.  function changeImplementationAddress( bytes32 interfaceName, address implementationAddress  ) external override onlyMaintainer { interfacesImplemented[interfaceName] = implementationAddress;  Zellic 12 Jarvis    emit InterfaceImplementationChanged(interfaceName, implementationAddress);  } ",
        "bodyRecommendations": "The use of a multisignature address wallet can prevent an attacker from causing eco- nomic damage in the event a private key is compromised. Timelocks can also be used to catch malicious executions, such as a change to the implementationAddressof thepriceFeed. ",
        "remediation": "Jarvis is aware of the centralization risks introduced by the synthereum finder but em- phasizes the importance of the synthereum finder in mitigating attacks from imposter contracts such as fake pools. They acknowledge that the synthereum finder could be compromised by leaked keys and, therefore, have implemented the following multi- stage protection protocol:  1. The synthereum finder is controlled by an Admin account and a Maintainer ac- count. The Admin account controls the Admin and Maintainer roles while the Maintainer controls the addresses pointed to by the synthereum finder. In the event the Maintainer is compromised, the Admin role can revoke its rights.  2. Both the Admin andMaintainer roles aremanaged by two of four signature Gno- sis Safe multisigs.  3. Ledger devices are used as signers of the multisigs to add an additional layer of security over hot wallets. Jarvis has further indicated that the Ledger keys are distributed among different company officers and are stored securely.  In the future, the Admin and Maintainer roles will be moved to an on-chain DAO and the multisig will be upgraded to a three of five. At that time, time-lock mechanisms may also be introduced.  Zellic 13 Jarvis   "
    },
    {
        "title": "3.4 Lack of validation",
        "* Target": " Project Wide ",
        "* Category": " Business Logic",
        "* Likelihood": " N/A ",
        "* Severity": " Informational",
        "* Impact": " Informational  There are several areas lacking validation checks including zero checks, non- zero address checks, and so forth  Below are the listings of each area missing a check:  * AaveV3.sol, deposit/withdraw - check that the moneyMarket argument is not zero or that it is valid  * LendingManager.sol, batchBuyback - check that getCollateralSwapModule returns a non-zero value  * LendingManager.sol, collateralToInterestToken/InterestToCollateralToken - verify the existence of the pool by checking pool.lendingModuleId  * LendingStorageManager.sol, updateValues - verify the existence of the pool by checking poolData.lendingModuleId  * MultiLpLiquidityPool.sol, _setLendingModule - verify that the lendingModuleId is not 0 and change the type of lendingModuleId to accurately reflect the poolStor- age type, which is bytes32  Wealso noted that there are several areaswhere arithemitc operations are not checked and are caught by underflow/overflow reverts, resulting in unclear reverts without er- ror messages. For example,  * LendingManager.sol, claimCommission - check that interestTokenAmount is greater than or equal to poolData.unclaimedDaoCommission + interestSplit.commissio nInterest  * LendingManager.sol, batchBuyback - add a check if the interestTokenAmount is greater than the poolData.unclaimedDaoJRT + interestSplit.jrtInterest  * MultiLpLiquidity.sol, _updateAndDecreaseActualLPCollateral - check that actua lCollateralAmount is greater than _decreaseCollateral ",
        "Impact": "Code maturity is very important in high-assurance projects. Checks help safeguard against unfortunate situations that might occur, help reduce the risk of lost funds and frozen protocols, and improve UX. Adding extra reverts can help clarify the internal mechanisms and reduce potential bugs that future developers might introduce while building on this project.  Zellic 14 Jarvis   ",
        "Recommendations": "We recommend adding the requisite checks/reverts to the areas above or adding documentation to clarify reverts. ",
        "Remediation": "The Jarvis team has acknowledged the lack of validation checks in certain contracts and have indicated their intention to add validation checks where they agree are nec- essary. Any validation checks not added will be documented in both the smart con- tract code comments and the official Jarvis documentation.  Zellic 15 Jarvis    4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Limited control of multiple liquidity pool  * Liquidity providers need to make a complex series of function calls in order to retrieve their collateral from the pool. The process is undocumented and not optimized for gas costs and will result in a frustrating experience for liquidity providers. Jarvis has indicated they are considering including this functionality in the future. We highly encourage this and further suggest documentation of this limitation in the mean time.  * Consider adding functionality to themultiple liquidity pool to deactivate, unreg- ister, and remove liquidity providers. Currently there is no way to stop liquidity providers who may be acting in bad faith from interacting with the pool. In- cluding this functionality may provide users and other liquidity providers with a sense of assurance that the protocol has protections from malicious liquidity providers. This needs to be weighed against the centralized control it offers the protocol maintainers.  * Including functions that can pause external and public functions can provide an added layer of security in the event an exploit is discovered. The abstract Pa usible.sol contract by Open Zeppelin provides pre-packaged functionality for pausing functions, which might be leveraged such as addLiquidity(...))) or rem oveLiquidity(...))). Access to these functions can be restricted when the pro- tocol is _paused using the whenNotPausedmodifier.  * There is currently no implementation in the multiple liquidity pool to call the migrate lending module function in the lending manager. Since only the liq- uidity pool can call this function in the lending manager, the lending module currently cannot be migrated. This is expected to be ugpraded once Jarvis has implemented lending modules servicing money markets other than Aave. The current implementation is correct and can remain in the lending manager for composability.  Zellic 16 Jarvis  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol   4.2 Documentation  The formulas for calculating the interest shares and fee shares are incorrect in the ac- companying documentation and do not reflect the implementation in the code. These errors in documentaiton could result in end-user and developer confusion. However, the in-line code documentation is accurate and informative, and we applaud Jarvis for their committment to quality in-line developer documentation.  Interest shares  Weadvise that the formula for calculating interest shares in the documentation should be changed from  final_share = (minting_capacity_ratio + utilization)/2  to the following:  final_share = (minting_capacity_share + utilization_share)/2  Utilization shares  Where minting_capacity_share correspondswith the definition of minting_capacity_ ratio in the current documentation and utilization_share is given by  utilization[i] / total_utilization  Here, utilization_i corresponds with the utilization of the i'th liquidity provider:  utilization[i] = (tokensCollateralized[i] * price * overCollateralization [i]) / collateralDeposited[i].  This is consistent with the implementation in the multiple liquidity pool shown below:  SynthereumMultiLpLiquidityPool...)) function _calculateInterest(  uint256 _totalInterests, uint256 _price, uint8 _collateralDecimals,  Zellic 17 Jarvis    PositionCache[] memory _positionsCache ) internal view returns (uint256 prevTotalLPsCollateral) { ...))  tempInterstArguments.utilizationShare = tempInterstArguments .isTotUtilizationNotZero ? utilizationShares[j].div(tempInterstArguments.totalUtilization) : 0;  ...))  The economic implications of the implementation of the formula responsible for cal- culating utilization shares is such that, if the entry/exit of LPs was not restricted by whitelist/registration, then an ecomonic attack becomes feasible where an attacker adds many LPs to a pool and collateralizes one token, resulting in 0% capacity shares but a 100% utilization rate. Due to the calculation of utilization shares, which relies on a fraction of the entire utilization, an attacker could steal/earn ~50% of a pool's inter- est due to their enormous stake into the utilization shares as a result of the many LP providers they control with a 100% utilization rate.  While this is not currently an issue due to the whitelist placed on MultiLpPools, if in the future a change was introduced to allow LPs to join freely, such an attack could take place.  Fee splitting  The formula for calculating the fees allocated to each liquidity provider is given by  redeemFeePaid * ratio[i]  Here, redeemFeePaid correspondswith the total fee paid by the synthetic tokenminter:  ratio = (share[i] / totalNumberOfTokens )  /) and  share[i] = (tokensCollateralized[i] / totalNumberOfTokens)  The formula for fees paid to each liquidity provider should be changed to the following:  redeemFeePaid * share[i]  Zellic 18 Jarvis    This is consistent with the implementation in the multiple liquidity pool shown below.  /) SynthereumMultiLpLiquidityPool.sol /) ...)) function _calculateRedeemTokensAndFee(  uint256 _totalNumTokens, uint256 _redeemNumTokens, uint256 _feeAmount, WithdrawDust memory _withdrawDust, PositionCache[] memory _positionsCache  ) internal pure { ...))  redeemSplit.fees = _feeAmount.mul( redeemSplit.lpPosition.tokensCollateralized.div(_totalNumTokens) );  ...))  4.3 Code maturity  Follow the adopted conventions for internal and private varaibles  Best practices for solidity development use the _ to prefix both internal and private variables and functions. We suggested that Revest adopt this practice and they have since made efforts to do.  Reliance on integer underflow reversion  In numerous places reversion by integer underflow is used as an implicit check that withdraw amounts do not exceed available funds. For example this happens in rece iveResonateOutput(...))) as there is no check made on the function parameter quanti ty. It also happens in modifyExistingOrder as there is no check on amount. Including explicit checks on these parameters would send clear messages to protocol users under transaction failure and improve the overall user experience.  Confusing variable names  In general the variables are intuitively named. However, the method getAddressForFN FT(bytes32 fnftId) in ResonateHelper takes an fnftId parameter but is in fact passed a poolId. This can create some developer confusion because the variablle name fnf tId is also used in Resonate to denote the id of the FNFT. We suggest Revest change the paramter name from fnftId to poolId.  Zellic 19 Jarvis    Clearer Comments  At the time of audit the Resonate project is still a work in progress. There are many comments left for other developers that take the form of questions and to do lists. There is also a general lack of good quality comments that would be useful for some- one not intimately familier with the code base. This applies to both the core contracts and their interfaces. For example, the following comment indicates awork in progress but also points to an unused variable:  function maxDeposit(address _account) public view override returns (uint256)  { _account; /) TODO can acc custom logic per depositor VaultAPI _bestVault = yVault; uint256 _totalAssets = _bestVault.totalAssets(); uint256 _depositLimit = _bestVault.depositLimit(); if (_totalAssets >= _depositLimit) return 0; return _depositLimit - _totalAssets;  }  We suggest Revest improve the quality of their code comments.  Unused resources  There are potentially unused resources in the project, for example FullMath is never used for uint256 in Resonate. We suggest Revest review the use of their libraries and remove those which are not used.  Control variables and abstract  Using values of process variables like depositedShares to indicate pool and order con- figurations is challenging to read. And furthermore, as we have seen in these report findings, it is error prone. Revest should consider adding another layer of abstraction to more clearly illustrate pool and order configurations  Zellic 20 Jarvis    4.4 Client response  In response to discussion points 4.1 and 4.3, Jarvis indicated that some of these lim- itations have been addressed. Regarding discussion point 4.2, they indicated their commitment to providing up-to-date and accurate documentation to the public in the near future. Finally, they commended Zellic for the comprehensive audit, great outline of findings, and keen observations made throughout the report.  Zellic 21 Jarvis    5 Audit Results  At the time of our audit, the code was not deployed to mainnet evm.  During our audit, we discovered four findings. Of these, one was of high risk, one of medium, and one of low risk, as well as one that was informational in nature. Jarvis acknowledged all findings, and fixes are pending.  5.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but it may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 22 Jarvis   \tAbout Zellic \tExecutive Summary \tIntroduction \tAbout Synthereum \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tmigratePool results in loss of funds \tSwap lacks slippage and path checks \tCentralization risk \tLack of validation  \tDiscussion \tLimited control of multiple liquidity pool \tDocumentation \tCode maturity \tClient response  \tAudit Results \tDisclaimers  "
    }
]