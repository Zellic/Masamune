[
    {
        "title": "3.1 Integer overflow",
        "* Target": " SequenceBaseSig",
        "* Category": " Coding Mistakes",
        "* Likelihood": " Low ",
        "* Severity": " Low",
        "* Impact": " Informational ",
        "Description": "While the signature tree is being verified, recoverBranch computes the cumulative weight of the nodes.  All node types increase the weight variable by the appropriate value, with the excep- tion of nodes of type FLAG_SUBDIGEST. When processing this specific node type, the weight variable is directly set to type(uint256).max.  A signature tree containing a node of type FLAG_SUBDIGEST authorizing the transac- tion digest followed by another signature node with nonzero weight would cause an integer overflow in the weight variable. ",
        "Impact": "This issue could cause a low-impact accidental denial of service. We believe this issue cannot be triggered by an attacker under common usage scenarios; therefore, this issue is reported as informational. Wedonot believe any reasonable configuration would lead to a permanent denial-of-service condition that would not exist if not for this issue.  We note that the recoverBranch function body is wrapped in an unchecked block. This eliminates the overflow checks normally inserted by the Solidity compiler, which would otherwise lead to the transaction being reverted. Instead, the weightwill over- flow to zero, possibly preventing theweight frombecoming greater than the threshold required to authorize a transaction. ",
        "Recommendations": "One possibility to mitigate this issue would be to use a saturating addition function for incrementing the weight variable, preventing overflows.  Zellic 9 Horizon   ",
        "Remediation": "Horizon acknowledged this finding, opting to not change the code as a signature that contains both FLAG_SUBDIGEST as well as other types of signatures is considered to be malformed. We believe Horizon choice is reasonable, since this issue cannot cause the execution of an unauthorized transaction or a permanent denial of service. We report a verbatim quote from Horizon, explaining their reasoning:  We believe that using FLAG_SUBDIGEST alongside other flags that also increase the total weight should result in a wrongly encoded signature, leading to a failure in the signature verification process, as expected.  Zellic 10 Horizon    4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Signature validation  To execute any transaction using the wallet authority, users must call ModuleCalls:)e xecute:  function execute( Transaction[] calldata _txs, uint256 _nonce, bytes calldata _signature  )  The execute function takes the list of transactions to execute, and a nonce and signa- ture are required to authorize the execution. The authorization check can be summa- rized in two main steps:  1. The nonce is validated to prevent replay attacks.  2. The signature is validated to ensure thewallet owners have authorized the trans- action.  The signature is tied to the given transaction and nonce by signing the hash of both. Signature verification ensures that  * The signature corresponds to the transaction and nonce. * The signature corresponds to the signer configuration (imageHash). * The signers that actually signed have enough weight to authorize execution of a transaction.  Sequence wallets accept four kinds of signatures: LEGACY_TYPE, DYNAMIC_TYPE, NO_CHA IN_ID_TYPE, and CHAINED_TYPE. The type of the signature is encoded in the first byte of _signature.  Signature types  LEGACY_TYPE, DYNAMIC_TYPE, and NO_CHAIN_ID_TYPE signatures  Zellic 11 Horizon    The code path for validating those signatures is as follows:  * ModuleCalls:)execute - user invokes this function. - ModuleCalls:)_validateNonce validates the nonce and updates the stored one.  - ModuleAuth:)_signatureValidation performs signature validation. * ModuleAuth:)signatureRecovery ensures subsignatures correspond to the TXdata and nonce and returns signature weight, threshold and imageHash. - SequenceBaseSig:)recover is code specific to the two signature types being discussed and computes signature weight, threshold and imageHash.  * SequenceBaseSig:)recoverBranch is described below. - ModuleAuthFixed, ModuleAuthUpgradable, or ModuleExtraAuth _isValidImag  e, depending on the wallet configuration, ensures the imageHash computed from the provided signature corresponds to the expected one.  The three signatures types follow virtually identical code paths, all invoking Sequenc eBaseSig:)recover. There are two minor but important differences between legacy signatures and DYNAMIC_TYPE and NO_CHAIN_ID_TYPE signatures. First, in the case of both latter signatures, one byte is stripped from the _signature array before passing it to recover. Second, in the case of NO_CHAIN_ID_TYPE, the digest of the transaction data to be signed is computed without including the chain ID. This allows reuse of the same signature across multiple chains.  CHAINED_TYPE signatures  This signature type allows to delegate signer authority to a different imageHash by chaining multiple signatures together. Each signature in the chain is validated by call- ing ModuleAuth:)signatureRecovery.  The first signature in the chain is computed against the hash of the transaction data and nonce, exactly like the other signature types. Each following signature is computed against the imageHash derived from the preceding signature in the chain. The imageHas h of the last signature in the chain must correspond to the imageHash that is authorized to execute transactions.  Signer configuration and imageHash computation  Sequence wallets allow flexible configuration, supporting a wide array of multisig se- tups. For efficiency, the actual signer configuration is not stored on chain. A crypto- graphic hash (imageHash) of the configuration is stored instead. The signer configura- tion can be thought of as aMerkle tree. InMerkle trees, each node has a corresponding hash, and the hash of each node is derived from the information contained in the node and the hashes of all the underlying child nodes. This implies that the hash of the root of the tree is tied to all the information contained in, and uniquely identifies, the spe-  Zellic 12 Horizon    cific tree instance. The imageHash of the configuration is the hash of the root node of the configuration tree.  This is one example of a configuration requiring the signature of either address A and B or address B, C, and D to authorize a transaction.  Checkpoint  Threshold: 30  FLAG_NODE  FLAG_SIGNATURE Address: 0xA Weight: 10  FLAG_SIGNATURE Address: 0xB Weight: 20  FLAG_NESTED Threshold: 20 Weight: 10  FLAG_SIGNATURE Address: 0xC Weight: 10  FLAG_SIGNATURE Address: 0xD Weight: 10  Signatures should also be thought of as a tree replicating the structure of the configu- ration tree. This allows to compute the imageHash of the configuration corresponding to a given signature. A valid signature has to match the imageHash expected by the wallet, thus only allowing the intended signers to authorize transactions.  A signature tree can contain a number of different node types:  * FLAG_ADDRESS contains just an address and a weight, but no signature. The ad- dress and weight contribute to the imageHash computed for the signature. This node does not count towards the actual weight of the signature, since the ad- dress is not a signer.  * FLAG_SIGNATURE contains a weight and a fixed-length signature. The weight and the signer address recovered from the signature contribute to the imageHash of the signature.  * FLAG_DYNAMIC_SIGNATURE contains aweight, a signature, and the signature length. This allows to embed SIG_TYPE_EIP712 and SIG_TYPE_ETH_SIGN signatures pro- duced by an actual private key, as well as ERC1271 signatures, which are vali- dated by invoking the corresponding smart contract.  * FLAG_NODE contains 32 bytes that contribute directly to the imageHash. This node does not count against the effective weight of the signature.  Zellic 13 Horizon    * FLAG_BRANCH marks the beginning of a subtree. The subtree is recursively pro- cessed, and the imageHash of the subtree contributes to the imageHash of the parent tree.  * FLAG_NESTED marks the beginning of a subtree with a fixed weight and internal threshold. If the cumulated weight of the signatures in the subtree is greater or equal to the internal threshold, the external weight is added to the weight of the parent tree.  * FLAG_SUBDIGEST is a special node that allows to pseudo-sign a fixed digest. If the digest being signed matches the one encoded in this node, the signature weight is set to type(uint256).max.  Initial imageHash validation  When initially deployed, wallets use ModuleAuthFixed:)_isValidImage(bytes32 _imag eHash) to validate the imageHash derived from a signature against the expected image Hash identifying the signer configuration.  The initial imageHash is provided as the salt used by create2 to derive the address of the deployed wallet. This allows to derive the address of a wallet that uses a given imageHash and even to send funds (ETH as well as, for example, ERC20 or ERC721 tokens) before deploying it, while still being secure against attackers deploying and taking control of a wallet to the given address. Also, ModuleAuthFixed verifies that the address of the contract corresponds to the address derived using the imageHash computed from the signature as a salt.  Zellic 14 Horizon    5 Threat Model  This provides a full threat model description for various functions. As time permitted, we analyzed each function in the smart contracts and created a written threat model for some critical functions. A threat model documents a given function's externally controllable inputs and how an attacker could leverage each input to cause harm.  Not all functions in the audit scope may have been modeled. The absence of a threat model in this section does not necessarily suggest that a function is safe.  5.1 File: Factory.sol  Function: deploy  Deploys a new instance of a wallet proxy using the given _salt and _mainModule as, respectively, the initial imageHash and the address of the implementation contract.  The given _salt is used as salt for the create2 instruction. The salt is included in the material hashed to obtain the address of the newly deployed contract, which is cal- culated as follows:  keccak256( abi.encodePacked(  hex\"ff\", FACTORY, /) Address invoking `create2` _imageHash, /) salt INIT_CODE_HASH /) hash of the contract code  ) )  It is therefore possible to derive the address of a wallet and send funds to it before de- ploying it while still being secure against attackers front-running the legitimate wallet deployment. See the section 4.1 for a more in-depth discussion of this aspect.  Branches and code coverage  Intended branches:  * Packs the bytecode used by the new instance and invokes create2 to deploy it. 4# Test coverage  Zellic 15 Horizon    Negative behavior:  * Wallet already exists. # Negative test  Inputs  * _mainModule: - Control: Arbitrary.  - Constraints: None.  - Impact: Address of the implementation contract called by the proxy. * _salt:  - Control: Arbitrary.  - Constraints: None.  - Impact: Represents the imageHash initially accepted by the wallet.  5.2 File: ModuleAuth.sol  Function: signatureRecovery  Given a signature tree and the digest signed, this function returns the signature thresh- old, the cumulative weight of the actual signers, the imageHash, the subdigest of the signed message, and the checkpoint. See the section 4.1 for a more in-depth descrip- tion of signature validation.  Branches and code coverage  Intended branches:  * Handles signatures of type LEGACY_TYPE. 4# Test coverage  * Handles signatures of type DYNAMIC_TYPE. 4# Test coverage  * Handles signatures of type NO_CHAIN_ID_TYPE. 4# Test coverage  * Handles signatures of type CHAINED_TYPE. 4# Test coverage  Negative behavior:  * Invalid signature type.  Zellic 16 Horizon    4# Negative test * Rejects invalid nested signatures.  4# Negative test  Inputs  * _digest: - Control: Arbitrary if called directly; hash of TX data when coming from  _execute. - Constraints: None.  - Impact: Digest of the message that has to be signed. * _signature:  - Control: Arbitrary.  - Constraints: None.  - Impact: Signature tree that has to be validated.  Function call analysis  Section 4.1 explains the code paths taken while validating signatures.  Function: isValidSignature  Two variants of this function exist, implementing the ERC1271 interface. One variant takes a bytes of data, while the other variant takes a bytes32 hash of the data. The special value 0x20c13b0b is returned if the given _signatures are valid for the given _data or _hash, respectively. See the section 4.1 for a more in-depth description of signature validation.  Branches and code coverage  Intended branches:  * Handles signatures of type LEGACY_TYPE. 4# Test coverage  * Handles signatures of type DYNAMIC_TYPE. 4# Test coverage  * Handles signatures of type NO_CHAIN_ID_TYPE. 4# Test coverage  * Handles signatures of type CHAINED_TYPE.  Zellic 17 Horizon    4# Test coverage  Negative behavior:  * Invalid signature type. 4# Negative test  * Rejects invalid signatures. 4# Negative test  * Rejects signatures with insufficient weight. 4# Negative test  Inputs (variant 1)  * _data: - Control: Arbitrary.  - Constraints: None.  - Impact: Data that should be signed by the provided signature. * _signature:  - Control: Arbitrary.  - Constraints: Must be a valid signature, otherwise zero is returned or the transaction is reverted.  - Impact: Should represent a valid signature for the given data.  Inputs (variant 2)  * _hash: - Control: Arbitrary.  - Constraints: None.  - Impact: Hash of the data that should be signed by the provided signature * _signature:  - Control: Arbitrary.  - Constraints: Must be a valid signature, otherwise zero is returned or the transaction is reverted.  - Impact: Should represent a valid signature for the given hash.  Function call analysis  These functions almost exclusively consist in an invocation of ModuleAuth:)_signatu reValidation, which in turn invokes signatureRecovery. Section 4.1 explains the code  Zellic 18 Horizon    paths taken while validating signatures.  Function: updateImageHash  This function updates the imageHash of the signer configuration that is authorized to execute transactions with the wallet.  The function can only be invoked by the wallet itself (through ModuleCalls:)execute).  Branches and code coverage  Intended branches:  * Updates the contract implementation if needed and updates the imageHash in the contract storage.  4# Test coverage  Negative behavior:  * Rejects invalid (zero) imageHash. 4# Test coverage  * Caller is not self. 4# Test coverage  Inputs  * _imageHash: - Control: Arbitrary.  - Constraints: Can be any nonzero bytes32 value. - Impact: Represents the imageHash of the new signer configuration.  Function call analysis  Depending on the current implementation contract, there are twopossible codepaths.  * ModuleAuthUpgradable:)_updateImageHash() updates the imageHash in the con- tract storage.  * What is controllable? imageHash. - If return value controllable, how is it used and how can it go wrong? No return value.  Zellic 19 Horizon    - What happens if it reverts, reenters, or does other unusual control flow? A revert prevents the imageHash from being updated. Reentrancy or unusual control flow are not a concern.  * ModuleAuthFixed:)_updateImageHash()updates the imageHash in the contract stor- age and updates the contract implementation to use an instance of MainModule Upgradable. - What is controllable? imageHash. - If return value controllable, how is it used and how can it go wrong? No return value.  - What happens if it reverts, reenters, or does other unusual control flow? A revert prevents the imageHash from being updated. Reentrancy or unusual control flow are not a concern.  5.3 File: ModuleAuthConvenience.sol  Function: updateImageHashAndIPFS  This function updates the imageHash of the signer configuration that is authorized to execute transactions with the wallet as well as the IPFS root key.  The function can only be invoked by the wallet itself (through ModuleCalls:)execute).  Branches and code coverage  Intended branches:  * Updates the contract implementation if needed and updates the imageHash in the contract storage. Also updates the IPFS root key.  4# Test coverage  Negative behavior:  * Rejects invalid (zero) imageHash. 4# Test coverage (indirectly)  * Caller is not self. 4# Test coverage  Inputs  * _imageHash: - Control: Arbitrary.  Zellic 20 Horizon    - Constraints: Can be any nonzero bytes32 value. - Impact: Represents the imageHash of the new signer configuration.  * _ipfsRoot: - Control: Arbitrary.  - Constraints: Can be any bytes32 value. - Impact: Represents the new IPFS root key.  Function call analysis  Depending on the current implementation contract, there are two possible code paths taken for updating the imageHash.  * ModuleAuthUpgradable:)_updateImageHash() updates the imageHash in the con- tract storage.  * What is controllable? imageHash. - If return value controllable, how is it used and how can it go wrong? No return value.  - What happens if it reverts, reenters, or does other unusual control flow? A revert prevents the imageHash and IPFS root from being updated. Reen- trancy or unusual control flow are not a concern.  * ModuleAuthFixed:)_updateImageHash()updates the imageHash in the contract stor- age and updates the contract implementation to use an instance of MainModule Upgradable. - What is controllable? imageHash. - If return value controllable, how is it used and how can it go wrong? No return value.  - What happens if it reverts, reenters, or does other unusual control flow? A revert prevents the imageHash and IPFS root from being updated. Reen- trancy or unusual control flow are not a concern.  The IPFS root key is also updated by invoking _updateIPFSRoot.  * ModuleIPFS:)_updateIPFSRoot(): - What is controllable? _hash. - If return value controllable, how is it used and how can it go wrong? No return value.  - What happens if it reverts, reenters, or does other unusual control flow? A revert prevents the imageHash and IPFS root from being updated. Reen- trancy or unusual control flow are not a concern.  Zellic 21 Horizon    5.4 File: ModuleCalls.sol  Function: execute  This function is invoked by users to execute transactions with the authority of the wallet. A signature authorizing the transaction must be provided. Refer to section 4.1 for a more in-depth explanation of the signature validation.  Branches and code coverage  Intended branches:  * Validates nonce and signature and executes the transactions. 4# Test coverage  Negative behavior:  * Caller is not EOA or another contract. 4# Test coverage  * Reverts if a transaction marked revertOnError fails. 4# Test coverage  * Reverts if nonce is invalid. 4# Test coverage  * Reverts if signature imageHash is invalid. 4# Test coverage  * Reverts if signer's weight is insufficient. 4# Test coverage  Inputs  * _txs: - Control: Arbitrary.  - Constraints: None.  - Impact: Array of transactions to be executed. * _nonce:  - Control: Arbitrary.  - Constraints: Must be a valid, unused nonce.  - Impact: Nonce used to prevent replay attacks. * _signature:  - Control: Arbitrary.  Zellic 22 Horizon    - Constraints: Must be a valid signature for the given nonce and transactions and match the configured imageHash.  - Impact: Signature authorizing transaction execution.  Function call analysis  * ModuleNonce:)_validateNonce() validates the nonce and updates the nonce in storage to prevent signature replay.  * What is controllable? _nonce. - If return value controllable, how is it used and how can it go wrong? No return value (reverts if nonce is invalid).  - What happens if it reverts, reenters, or does other unusual control flow? Reverts are issues on purpose to reject invalid nonces. Reentrancy or un- usual control flow are not a concern.  * ModuleAuth:)_signatureValidation()updates the imageHash in the contract stor- age and updates the contract implementation to use an instance of MainModule Upgradable.  * What is controllable? _signature. - If return value controllable, how is it used and how can it go wrong? Not controllable.  - What happens if it reverts, reenters, or does other unusual control flow? Reverts are issued in some cases if signature is invalid, preventing unau- thorized transaction execution. Reentrancy or unusual control flow are not a concern.  * ModuleAuth:)_execute() executes the given transactions. - What is controllable? _txs. - If return value controllable, how is it used and how can it go wrong? No return value.  - What happens if it reverts, reenters, or does other unusual control flow? Reverts are issued if a transaction marked revertOnError fails. Reentrancy is possible, but it is not deemed problematic.  Function: selfExecute  This function can only be invoked by thewallet contract itself. No further authorization checks are performed, since a call coming from the wallet itself is considered to be trusted and coming from an authenticated flow.  Zellic 23 Horizon    Branches and code coverage  This function almost exclusively consists of an invocation of ModuleCalls:)_execute. The test cases overlap with tests for ModuleCalls:)execute.  Intended branches:  * Executes a transaction batch. 4# Test coverage  Negative behavior:  * Caller is not self. 4# Test coverage  Inputs  * _txs: - Control: Arbitrary.  - Constraints: None.  - Impact: Array of transactions to be executed.  Function call analysis  * ModuleCalls:)_execute() executes the given transactions. - What is controllable? _txs. - If return value controllable, how is it used and how can it go wrong? No return value (reverts if nonce is invalid).  - What happens if it reverts, reenters, or does other unusual control flow? Reverts might be issued on purpose if a transaction marked revertOnError fails. Direct reentrancy is not possible, since only self calls are allowed.  Zellic 24 Horizon    6 Audit Results  At the time of our audit, the code was not deployed to mainnet Ethereum or other EVM compatible layer two chains.  During our audit, we discovered one informational finding. Horizon acknowledged the finding, which did not require code changes.  6.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 25 Horizon   \tAbout Zellic \tExecutive Summary \tGoals of the Assessment \tNon-goals and Limitations \tResults  \tIntroduction \tAbout Sequence Wallet \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tInteger overflow  \tDiscussion \tSignature validation  \tThreat Model \tFile: Factory.sol \tFile: ModuleAuth.sol \tFile: ModuleAuthConvenience.sol \tFile: ModuleCalls.sol  \tAudit Results \tDisclaimers  "
    }
]