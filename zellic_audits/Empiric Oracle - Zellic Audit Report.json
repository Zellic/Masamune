[
    {
        "title": "3.1 Key used in oracle entry storage is forgable by trusted pub-",
        "target": " oracle/library.cairo",
        "category": " Coding Mistakes",
        "severity": " High",
        "likelihood": " Low ",
        "impact": " High ",
        "bodyDescription": "The oracle/library.cairo code is responsible formuch of the core implementation of the oracle itself. The oracle uses \"entries\" to record the current value for a given asset pair or other kinds of tracked elements. The oracle code defines a \"publish entry\" external function that allows callers to submit an entry to be recorded.  The main authorization check is done by checking that the caller's address is equal to the expected publisher address. The expected publisher address is reported by the publisher registry contract. This check ensures that this transaction can only be performed by a preconfigured publisher. While this check ensures that the caller is, indeed, a preconfigured publisher, it does not key the entry by this caller address.  Entries define multiple relevant properties. Namely, entries define a timestamp, the value, a pair id, a source, and a publisher.  struct Entry: member pair_id : felt member value : felt member timestamp : felt member source : felt member publisher : felt  end  The pair id represents a string of the pair of assets this entry tracks. For example, this could be the felt value that represents the string \"eth/usd\". The other interesting property is the source. The source and the publisher are not necessarily the same. The publisher attests to the value of data from a particular source. Therefore, an entry submitted by a publisher could contain any source string desired.  Entries are stored in amap called Oracle_entry_storage, which is keyed by two values:  Zellic 9 Empiric Network    the entry's pair id and the entry's source. Because entry sources can be any value decided by the publisher and entries are not keyed by their publisher, rogue publishers can overwrite the values set by other publishers. ",
        "bodyImpact": "Approved publishers that have turned rogue can set entries for arbitrary sources and key ids even if those sources are the responsibility of other publishers. ",
        "bodyRecommendations": "Considering either keying on publisher address or tracking which sources a particular publisher is allowed to publish. This will require an additional check that the specified source is allowed to be published by the calling publisher. ",
        "remediation": "The issue was addressed in a later update.  Zellic 10 Empiric Network   "
    },
    {
        "title": "3.2 Publish entry does not validate caller address is not 0",
        "target": " oracle/library.cairo",
        "category": " Coding Mistakes",
        "severity": " Informational",
        "likelihood": " N/A ",
        "impact": " Informational ",
        "bodyDescription": "When contracts in Starknet are directly invoked, the get_caller_address function can return 0. This is a relatively common error or default pattern in Starknet and Cairo, but it can cause security issues when this behavior is unexpected, like in the case of get_caller_address.  In the publish entry codeof the oracle/library.cairo file, the caller address is checked against the publisher address. The publisher address is retrieved by calling into the publisher registry contract and fetching the address of the publisher with a given felt- converted string name. If the publisher specified by this string does not exist, the publisher registry will actually return 0 instead of throwing an error.  func Publisher_get_publisher_address{ syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr  }(publisher : felt) -> (publisher_address : felt): let (publisher_address) = Publisher_publisher_address_storage.read( publisher) return (publisher_address)  end  This is because a read with a key that does not exist will return 0 values instead of throwing an error. Because no check is performed in the publisher registry that val- idates that non-zero values for publisher addresses will be returned, this allows the oracle code to check a 0 publisher address against a potentially 0 caller address, which can occur if the contract is invoked directly with -)no_wallet.  As of Starknet 0.10.0 this will not be an issue, but it is recommended to validate that the publisher registry get publisher address method does not return 0 values and/or the oracle validates the caller is not 0. ",
        "bodyImpact": "If allowed, for example--a pre-0.10.0 Starknet environment would allow a caller to impersonate a publisher as long as the publisher does not exist in the publisher reg- istry. In combination with a previous finding, this would allow an attacker to publish  Zellic 11 Empiric Network    arbitrary entries even if they were not previously added to the registry. ",
        "bodyRecommendations": "Validate, in either the publisher registry, that the returned publisher address is non- zero or that the caller address is not zero. ",
        "remediation": "The issue was addressed in a later update.  Zellic 12 Empiric Network   "
    },
    {
        "title": "3.3 Mathematical expressions could produce incorrect values",
        "target": " oracle/library.cairo",
        "category": " Coding Mistakes",
        "severity": " Medium",
        "likelihood": " Low ",
        "impact": " High ",
        "bodyDescription": "It was observed in the yield curve cairo code that in calculate_future_spot_yield_ point some multiplication occurs with numbers that have not been given an upper bound. While integer overflow conditions are not strictly limited to multiplication, this is where we're most likely to find valid conditions for overflow behavior.  In calculate_future_spot_yield_point, a call is made to starkware.cairo.common.pow where the exponent is output_decimals + spot_decimals - future_decimals. Based on how this function is called, future_decimals can, at least, be 1. No reasonable upper bound exists for the exponent and pow, internally, performs unchecked multiplication. This means that the following expressions  # Shift future/spot to the left by output_decimals + spot_decimals - future_decimals  let (ratio_multiplier) = pow(10, output_decimals + spot_decimals - future_decimals)  let (shifted_ratio, _) = unsigned_div_rem( future_entry.value * ratio_multiplier, spot_entry.value  )  can result in integer overflowwhen performing the pow operation as the exponent cap is 2^251. Note that this is not 251, but 2 raised to the 251. This will easily overflow the ratio_multiplier, causing the ratio to be an unexpected value. ",
        "bodyImpact": "Mathematical expressions can miscalculate, causing incorrect spot pricing. ",
        "bodyRecommendations": "Assert that the exponent passed to pow is less than some amount. Additional, pro- vide additional assertions around entry valuation to ensure the provided number is reasonable and not at the limits of what a felt can support.  Zellic 13 Empiric Network   ",
        "remediation": "The issue was addressed in a later update.  Zellic 14 Empiric Network   "
    },
    {
        "title": "3.4 Faulty implementation of comparison function",
        "target": " lib/time_series/utils.cairo",
        "category": " Coding Mistakes",
        "severity": " Medium",
        "likelihood": " Low ",
        "impact": " Medium ",
        "bodyDescription": "The are_equal function in time_series.utils incorrectly assumes that the is_nn func- tion checks if the argument is negative. According to the documentation, however, this function checks if the argument is non-negative. This leads to an incorrect imple- mentation, causing the are_equal function to return bogus values.  func are_equal{range_check_ptr}(num1: felt, num2: felt) -> (_are_equal: Bool) { alloc_locals; let is_neg1 = is_nn(num1 - num2); let is_neg2 = is_nn(num2 - num1); let _are_equal = is_nn(is_neg1 + is_neg2 - 1); return (_are_equal,);  }  As an example, the are_equal function will have the following trace when run with arguments (3, 4), wrongly returning that the numbers are equal:  is_neg1 = is_nn(3 - 4) => is_nn(-1) => 0; is_neg2 = is_nn(4 - 3) => is_nn(1) => 1 _are_equal = is_nn(0 + 1 - 1) => is_nn(0) => 1 ",
        "bodyImpact": "The faulty are_equal function is used as a helper function by other statistical calcula- tion functions under time_series/, which could lead to incorrect results. ",
        "bodyRecommendations": "Rewrite the code according to the correct specification of the is_nn function: It returns 1 when the argument is non-negative.  Writemore unit tests for individual library functions to catch any incorrect implemen- tations and edge cases that might not show up in an integration test.  Zellic 15 Empiric Network   ",
        "remediation": "The issue was addressed in a later update.  Zellic 16 Empiric Network   "
    },
    {
        "title": "3.5 Incorrect use of library comparison function",
        "target": " computeengines/rebasedenomination/RebaseDenomination.cairo",
        "category": " Coding Mistakes",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "The _decimal_div function uses the is_le function to compare the number of decimals between the numerator and the denominator. The specification of the is_le function states that it returns 1 when the first argument is less than or equal to the second argument:  /) Returns 1 if a <) b (or more precisely 0 <) b - a < RANGE_CHECK_BOUND). /) Returns 0 otherwise. @known_ap_change func is_le{range_check_ptr}(a, b) -> felt {  return is_nn(b - a); }  The implementation of _decimal_div assumes otherwise. The is_le function will re- turn TRUE if b_decimals <) a_decimals or a_decimals >) b_decimals. This is different from the code below, which assumes that the two numbers can only be equal in the else branch.  let b_fewer_dec = is_le(b_decimals, a_decimals); if (b_fewer_dec =) TRUE) {  /) x > y a_to_shift = a_value; result_decimals = a_decimals; tempvar range_check_ptr = range_check_ptr;  } else { /) x <) y  As a result, the case when the two numbers are equal is handled by the first if branch instead of the else branch as expected by the code. ",
        "bodyImpact": "The correctness of the _decimal_div function is not affected by the incorrect usage of the is_le function as the code for handling the first if branch and the equality leads to  Zellic 17 Empiric Network    the same outcome.  However, this same mistake may show up in other places, and such assumptions should be carefully verified before using them in code. ",
        "bodyRecommendations": "Rearrange the if conditions so that the case of equality is handled by the if branch rather than the else branch. ",
        "remediation": "The issue was addressed in a later update.  Zellic 18 Empiric Network   "
    },
    {
        "title": "3.6 Inconsistency in checking of stale entries",
        "* Target": " oracle/library.cairo",
        "* Category": " Coding Mistakes",
        "* Likelihood": " Low ",
        "* Severity": " Low",
        "* Impact": " Low ",
        "Description": "There are two places where entries are checked to be recent: publish_entry and bui ld_entries_array.  The publish_entry verifies the following condition for new entries: (current_timesta mp - TIMESTAMP_BUFFER) <) new_entry.timestamp  let (current_timestamp) = get_block_timestamp(); with_attr error_message(\"Oracle: New entry timestamp is too far in the  past\") { assert_le(current_timestamp - TIMESTAMP_BUFFER, new_entry.timestamp);  }  The build_entries_array checks the following condition to filter entries that are too old: entry.timestamp <) current_timestamp - TIMESTAMP_BUFFER)  let is_entry_stale = is_le(entry.timestamp, current_timestamp - TIMESTAMP_BUFFER);  let should_skip_entry = is_not_zero(is_entry_stale + not_is_entry_initialized);  Ideally both the checks should have the same statement; however, when we rear- range and list them, we see that there is a certain timestampwhere the publish_entry states that the entry is fresh but build_entries_array says that the entry is stale.  /) Entries are fresh if: current_timestamp - TIMESTAMP_BUFFER <= new_entry.timestamp current_timestamp - TIMESTAMP_BUFFER < entry.timestamp ",
        "Impact": "If an entry is on the boundary of being stale, and it is published and fetched at the same timestamp, it will be rejected. While this is not a security concern, it is important to  Zellic 19 Empiric Network    ensure that assumptions and invariants across the project are consistent with each other to prevent bugs from occuring in the future. ",
        "Recommendations": "Ensure that both of the conditions are consistent with each other and check the same thing. ",
        "Remediation": "The issue was addressed in a later update.  Zellic 20 Empiric Network    4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Assert admin_address_storage is set to non-zero value in on ly_admin  The only_admin function, found in the admin/library.cairo file, is used to check if the caller is the specified admin for the contract. This code is used in a couple of contracts in the repository, allowing the protocol operators to perform maintenance tasks like adding publishers.  Currently, the only_admin function does not validate that the admin_address_storage variable was previously initialized. In an uninitialized state, the value of this variable is 0. This, coupled with the fact that get_caller_addresswill return 0 if the contract is directly invoked, suggests that if improper initializationwere to occurwith the contract that callers that directly invoked this contract would be treated as administrators.  Upon review of the codebase, we found no such case of improper initialization of the admin code in any of the in-scope contracts. While this design decision did not rise to the level of a security issue as it was used correctly everywhere, it is our recommen- dation that the check that this field has been initialized be added for future security of any additional admin functionality.  It is worth noting, however, that similar to the \"publish entry non-zero check\" find- ing, that due to the transition to Starknet 0.10.0, this will likely not be an issue going forward.  4.2 Root and publisher key scheme  As part of the audit, we were consulted for ideas on how to address potential design and operational issues. One such topic of discussion was how to design against pub- lisher key compromise. In this situation, a publisher may mismanage their publishing key, allowing an attacker or insider to access the key and begin publishing fraudulent entries to the protocol.  After some discussion and deliberation, we came up with a proposal to have pub- lishers register two keys--a root key and a publisher key. The publisher key would actually allow for publishing entries to the oracle. The root key would only be able to  Zellic 21 Empiric Network    set a given publisher's publishing key. The idea would be that publishers would keep their root key in cold storage, locked away. This would keep the key very safe and away from accidental leakage. Publishers would then use their publisher key on live systems to actually publish entries.  If this key ever need be rotated, the publisher can do that entirely themselves by us- ing their root key to configure a new publisher key with the oracle. Optionally, an additional mechanism to rotate the root key with itself could be envisioned so that publishers can be particularly careful with the root key if they fear it has been com- promised as well.  4.3 Pause functionality  For additional operational control of the contract, itmay be advisable to build in a rapid protocol-pausing functionality if anything were to happen. For example, if a security issue were later identified, being able to pause the protocol before further harm was done, this would be ideal from an incident response standpoint. Even without the presence of a security issue in the protocol itself, it would help to pause the protocol or individual publishers if a publisher's key is determined to be compromised.  This does comewith centralization risk, though, so that should beweighed against the pros and cons for this protocol. MPC could be an alternative to retain some decen- tralized properties despite the presence of the pause functionality.  4.4 Accuracy of data returned by Rebase Denomination  The get_rebased_value_via_usd function returns two values that help the user un- derstand how the data was sourced: last_updated_timestamp and num_sources_aggr egated. These are calculated using the maximum number of sources of each of the currency pairs and the latest of the timestamps when each of the pairs were updated.  This is a bit misleading as it does not signal to the user the risk of a stale or centralized oracle for one of the pairs. We recommend using the minimum function to calculate these values to better convey the accuracy and recency of the data to the users.  Zellic 22 Empiric Network    5 Audit Results  At the time of our audit, the code was not deployed to mainnet.  During our audit, we discovered six findings. Of these, two were high, one medium, two low, and one findingwas a suggestion (informational). Empiric Network acknowl- edged all findings and implemented fixes.  5.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 23 Empiric Network   \tAbout Zellic \tExecutive Summary \tIntroduction \tAbout Empiric Oracle \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tKey used in oracle entry storage is forgable by trusted publisher \tPublish entry does not validate caller address is not 0 \tMathematical expressions could produce incorrect values \tFaulty implementation of comparison function \tIncorrect use of library comparison function \tInconsistency in checking of stale entries  \tDiscussion \tAssert admin_address_storage is set to non-zero value in only_admin \tRoot and publisher key scheme \tPause functionality \tAccuracy of data returned by Rebase Denomination  \tAudit Results \tDisclaimers  "
    }
]