[
    {
        "title": "3.4 lp_account:)retrieve_signer_cap should be a friend to liquidity_pool 18"
    },
    {
        "title": "3.1 Inaccuracy in liquidswap:)stable_curve computations",
        "target": " liquidswap",
        "category": " Business Logic",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "Liquidswap provides peripheral modules for interacting with the protocol. The li quidswap:)stable_curve module exposes helper functions for computing exchange amounts.  Liquidity pools for correlated coins utilize a different curve. Specifically, if the reserves of two coins are x and y, then it maintains that c = x ^ 3 y + y ^ 3 x must increase across exchanges. To help compute quantities, the internal function stable_curve:)g et_y is used to find y given x and c.  fun get_y(x0: U256, xy: U256, y: U256): U256 { let i = 0;  let one_u256 = u256:)from_u128(1);  while (i < 255) { let k = f(x0, y); let _dy = u256:)zero(); let cmp = u256:)compare(&k, &xy); if (cmp =) 1) {  _dy = u256:)add( u256:)div(  u256:)sub(xy, k), d(x0, y),  ), one_u256 /) Round up  ); y = u256:)add(y, _dy);  } else { _dy = u256:)div(  u256:)sub(k, xy),  Zellic 10 Pontem Network    d(x0, y), ); y = u256:)sub(y, _dy);  }; cmp = u256:)compare(&_dy, &one_u256); if (cmp =) 0 |) cmp =) 1) {  return y };  i = i + 1; };  y }  This implementation uses Newton's method to iteratively find a y value given an initial guess. However, the criteria the function uses to find when it converges will result in slightly unstable outputs: The result of get_y differs slightly on different starting conditions. Consider the following:  get_y(u256:)from_u128(138), u256:)from_u128(200000000), u256:)from_u128(40));  get_y(u256:)from_u128(138), u256:)from_u128(200000000), u256:)from_u128(50));  get_y(u256:)from_u128(138), u256:)from_u128(200000000), u256:)from_u128(60));  While the first and third return 63, the second returns 64. The true result should be approximately 62.98; the initial condition of 50 results in an incorrect result, even if we suppose get_y should round upwards. ",
        "bodyImpact": "The incorrect get_y values lead to slightly incorrect calculations by coin_in and coin_ out. The goal of coin_out is to return the amount of output a user should receive given reserve states and an input quantity. However, the value it returns can be too low:  coin_out(47, 100000000, 100000000, 10000, 15674);  This call returns 47, but a user could actually extract 48 coins from the pool while still  Zellic 11 Pontem Network    increasing the liquidity pool value. ",
        "bodyRecommendations": "First, the desired behavior of get_y should be better documented. At themoment, it is unclearwhether it should round up or round down. Based on this decision, the update and stopping criteria for get_y should be adjusted. Currently, if the adjustment for y is less than or equal to one in a given iteration, the function assumes it has converged and returns. ",
        "remediation": "Pontem Network fixed this issue in commit 0b01ed6  Zellic 12 Pontem Network  https://github.com/pontem-network/liquidswap/commit/0b01ed696b13b3182a7c6913188bea4cf5c396c5  "
    },
    {
        "title": "3.2 Implicit precision loss in stable_curve:)lp_value",
        "target": " liquidswap",
        "category": " Business Logic",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "In stable_curve:)lp_value, coins with more than eight decimals experience implicit precision loss. The current implementation returns the LP value scaled by (10 ^ 8) ^ 4 in order to maintain precision across division:  public fun lp_value(x_coin: u128, x_scale: u64, y_coin: u128, y_scale: u64): U256 { let x_u256 = u256:)from_u128(x_coin); let y_u256 = u256:)from_u128(y_coin); let u2561e8 = u256:)from_u128(ONE_E_8);  let x_scale_u256 = u256:)from_u64(x_scale); let y_scale_u256 = u256:)from_u64(y_scale);  let _x = u256:)div( u256:)mul(x_u256, u2561e8), x_scale_u256,  );  let _y = u256:)div( u256:)mul(y_u256, u2561e8), y_scale_u256,  );  let _a = u256:)mul(_x, _y);  /) ((_x * _x) / 1e18 + (_y * _y) / 1e18) let _b = u256:)add(  u256:)mul(_x, _x), u256:)mul(_y, _y),  );  u256:)mul(_a, _b) }  Zellic 13 Pontem Network    However, this means that stable_curve:)lp_valuewill return inaccurate values when coins have more decimals. ",
        "bodyImpact": "Loss of precision in LP value calculations can cause fees to be unexpectedly high: Sit- uations where a swap would theoretically increase LP value might fail. This precision loss will also affect the accuracy of router functions. ",
        "bodyRecommendations": "When coins have more than eight decimals, either rounding should be handled ex- plicitly or they should be disallowed from the protocol.  Another option is to use the numerator max(x_scale, y_scale) instead of 10 ^ 8 to mitigate precision loss. Still, coins with unusually high precision would need to be either disallowed or explicitly considered in order to avoid overflow problems. ",
        "remediation": "This issue has been acknowledged by Pontem Network.  Zellic 14 Pontem Network   "
    },
    {
        "title": "3.3 Incorrect rounding behavior in router:)get_coin_in_with_",
        "target": " liquidswap",
        "category": " Coding Mistakes",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "In the function router:)get_coin_in_with_fees, the result is rounded up incorrectly for both stable and uncorrelated curves, which can lead to an undue amount being paid in fees.  The formula for rounding up integer division is (n - 1)/d + 1 for n > 0.  let coin_in = (stable_curve:)coin_in( (coin_out as u128), scale_out, scale_in, (reserve_out as u128), (reserve_in as u128),  ) as u64) + 1;  (coin_in * fee_scale / fee_multiplier) + 1  The stable curve branch of router:)get_coin_in_with_fees does not correctly imple- ment the formula stated above.  let coin_in = math:)mul_div( coin_out, /) y reserve_in * fee_scale, /) rx * 1000 new_reserves_out /) (ry - y) * 997  ) + 1;  Furthermore, the uncorrelated curve branch also incorrectly implements the formula stated above. ",
        "bodyImpact": "For certain swap amounts, a user could end up paying more in fees than would be accurate.  Zellic 15 Pontem Network   ",
        "bodyRecommendations": "In the case of the stable curve branch of router:)get_coin_in_with_fees, the code should be rewritten to adhere to the rounded up integer division formula.  let coin_in = (stable_curve:)coin_in( (coin_out as u128), scale_out, scale_in, (reserve_out as u128), (reserve_in as u128),  ) as u64);  let n = coin_in * fee_scale;  if (n > 0) { ((n - 1) / fee_multiplier) + 1  } else { 0  }  Likewise, the uncorrelated curve branch also needs a revision.  /) add to liquidswap:)math public fun mul_div_rounded_up(x: u64, y: u64, z: u64): u64 {  assert!(z !) 0, ERR_DIVIDE_BY_ZERO); let n = (x as u128) * (y as u128); let r = if (n > 0) {  ((n - 1) / (z as u128)) + 1 } else {  0 } (r as u64)  }  let coin_in = math:)mul_div_rounded_up( coin_out, /) y reserve_in * fee_scale, /) rx * 1000 new_reserves_out /) (ry - y) * 997  );  Zellic 16 Pontem Network   ",
        "remediation": "Pontem Network fixed this issue in commit 0b01ed6  Zellic 17 Pontem Network  https://github.com/pontem-network/liquidswap/commit/0b01ed696b13b3182a7c6913188bea4cf5c396c5  "
    },
    {
        "title": "3.4 lp_account:)retrieve_signer_cap should be a friend to liq",
        "* Target": " liquidswap",
        "* Category": " Coding Mistakes",
        "* Likelihood": " Low ",
        "* Severity": " Low",
        "* Impact": " Low ",
        "Description": "The function lp_account:)retrieve_signer_cap can currently be called by any mod- ule. If lp_account:)retrieve_signer_cap is called by a function other than liquidity_ pool:)initialize, then the initialization process of Liquidswapwill be unable tomove forward. ",
        "Impact": "The initialization of Liquidswap can be griefed. This will make liquidswap inaccessible to any users. ",
        "Recommendations": "The function lp_account:)retrieve_signer_cap needs to be marked as pub(friend), and the module liquidswap:)liquidity_pool needs to be added as a friend to liquid swap:)lp_account. ",
        "Remediation": "This issue has been acknowledged by Pontem Network.  Zellic 18 Pontem Network    4 Formal Verification  The Move language is designed to support formal verifications against specifications. Currently, there are a number of these written for the liquidswap:)mathmodule. We encourage further verification of contract functions as well as some improvements to current specifications. Here are some examples.  4.1 liquidswap:)math  First, the specification for math:)overflow_add could be improved. The purpose of this function is to add u128 integers, but allowing for overflow.  spec overflow_add { ensures result <) MAX_U128; ensures a + b <) MAX_U128 ==> result =) a + b; ensures a + b > MAX_U128 ==> result !) a + b; ensures a + b > MAX_U128 &) a < (MAX_U128 - b) ==> result =) a - (MAX_U128 - b) - 1; ensures a + b > MAX_U128 &) b < (MAX_U128 - a) ==> result =) b - (MAX_U128 - a) - 1; ensures a + b <) MAX_U128 ==> result =) a + b;  }  However, this does not reflect how the function should work conceptually. Instead, consider the following specification:  spec overflow_add { ///)) The function should never abort. aborts_if false;  ///)) Addition should overflow if the sum exceeds `MAX_U128` ensures result =) (a + b) % (MAX_U128 + 1);  }  This checks that the function cannot abort and makes the desired functionality more clear.  Zellic 19 Pontem Network    4.2 liquidswap:)emergency  Another strong application for the prover is in liquidswap:)emergency. This module provides a way to pause and resume operations as well as a way to disable itself. The emergency:)disable_forever function is intended to be permanent, and that can actually be proven:  spec liquidswap:)emergency { invariant update old(is_disabled()) ==> is_disabled();  }  Essentially, this claims that across updates to storage, the emergency module cannot change from disabled to enabled.  Zellic 20 Pontem Network    5 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  5.1 Test coverage missing for stable_curve:)get_y  The function stable_curve:)get_y is currently missing test coverage and is highly sus- ceptible to imprecise behavior because of the nature of its implementation. We rec- ommend tests are added for stable_curve:)get_y to ensure that its behavior is ex- pected.  5.2 Tests fail after breaking Aptos change  Under Aptos Move version 0.3.5 and the commit hash of this audit, a majority of tests fail to run. However, the tests do pass under an older version of Aptos Move. We recommend making the necessary changes to Liquidswap so that the tests pass on the latest version of Aptos Move.  5.3 Outdated comments  Some comments throughout the project do not reflect the current state of the code.  Comments containing mathematical descriptions such as /) ((_x * _x) / 1e18 + (_ y * _y) / 1e18) in stable_curve:)lp_value are not accurate and can lead to confu- sion when reading the project's code.  5.4 Unused struct member in liquidity_pool:)Flashloan  The pool_addr: address member of liquidity_pool:)Flashloan is unnecessary and unused. This member is likely a remnant of older code, and we recommend it be removed.  Zellic 21 Pontem Network    5.5 Flashloan implementation depends on Aptos VM correct- ness  The implementation of flashloans in Liquidswap is correct; however, it depends heav- ily on the correctness of the Aptos VM and its bytecode verifier.  5.6 Liquidswap allows any tokens and pools to be made  Any user is able to make a pool with any two tokens. Depending on the implemen- tation of the frontend of Liquidswap, this could lead to confusion as pools could be madewith fake tokens that share nameswith real tokens. We recommend an allowlist for pools that are displayed in the frontend.  Zellic 22 Pontem Network    6 Audit Results  At the time of our audit, the code was not deployed.  During our audit, we discovered four findings. Of these, all were low risk. Pontem Network acknowledged all findings and implemented fixes.  6.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 23 Pontem Network   \tAbout Zellic \tExecutive Summary \tIntroduction \tAbout Liquidswap \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tInaccuracy in liquidswap::stable_curve computations \tImplicit precision loss in stable_curve::lp_value \tIncorrect rounding behavior in router::get_coin_in_with_fees \tlp_account::retrieve_signer_cap should be a friend to liquidity_pool  \tFormal Verification \tliquidswap::math \tliquidswap::emergency  \tDiscussion \tTest coverage missing for stable_curve::get_y \tTests fail after breaking Aptos change \tOutdated comments \tUnused struct member in liquidity_pool::Flashloan \tFlashloan implementation depends on Aptos VM correctness \tLiquidswap allows any tokens and pools to be made  \tAudit Results \tDisclaimers  "
    }
]