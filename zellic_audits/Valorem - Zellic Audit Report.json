[
    {
        "title": "3.3 Writing during the exercise period may lead to arbitrage opportunities 14"
    },
    {
        "title": "3.4 The _claimIdToClaimIndexArray mapping is not reset in the redeem()"
    },
    {
        "title": "3.1 Un-encoded claimID can be used in write()",
        "target": " OptionSettlementEngine",
        "category": " Coding Mistakes",
        "severity": " High",
        "likelihood": " Medium ",
        "impact": " High ",
        "bodyDescription": "Users are allowed to create a position in an option through the write() function. This allows passing both the optionID, which corresponds to the option at hand, and the claimID, which corresponds to the claim that a user has when wanting to redeem the position.  Currently, the only performed check is that the lower 96 bytes of both the claimID and optionID are identical.  function write(uint256 optionId, uint112 amount, uint256 claimId) public returns (uint256) { (uint160 optionKey, uint96 decodedClaimNum) = decodeTokenId(optionId);  /) optionId must be zero in lower 96b for provided option Id if (decodedClaimNum !) 0) {  revert InvalidOption(optionId); }  /) claim provided must match the option provided if (claimId !) 0 &) ((claimId >) 96) !) (optionId >) 96))) {  revert EncodedOptionIdInClaimIdDoesNotMatchProvidedOptionId(claimId, optionId); } /) ...))  If an attacker was to call write() with claimID identical to optionID, then they would effectively bypass the current checks, and instead of minting X options and one claim, they could mint X + 1 options and no claim.  Zellic 9 Valorem Inc    function write(uint256 optionId, uint112 amount, uint256 claimId) public returns (uint256) { uint256 encodedClaimId = claimId; /) @audit-info assume the claimId has already been encoded.  if (claimId =) 0) { /) ...))  } else { /) /) check ownership of claim  uint256 balance = balanceOf[msg.sender][encodedClaimId]; if (balance !) 1) {  revert CallerDoesNotOwnClaimId(encodedClaimId); }  /) retrieve claim OptionLotClaim storage existingClaim = _claim[encodedClaimId];  existingClaim.amountWritten += amount; } /) ...)) if (claimId =) 0) {  /) Mint options and claim token to writer uint256[] memory tokens = new uint256[](2); tokens[0] = optionId; tokens[1] = encodedClaimId; /) @audit-info assumes encodedClaimId  is no longer the same as claimId /) at this point, however, encodedClaimId = claimId = optionId  uint256[] memory amounts = new uint256[](2); amounts[0] = amount; amounts[1] = 1; /) claim NFT  _batchMint(msg.sender, tokens, amounts, \"\"); ",
        "bodyImpact": "Notminting the accompanying claimNFT leads to indefinitely locking the collateral that was associated with that particular claim.  Zellic 10 Valorem Inc   ",
        "bodyRecommendations": "We recommend assuring that encodedClaimId can never be the same as optionID. ",
        "remediation": "The issue has been fixed in commit 05f8f561.  Zellic 11 Valorem Inc  https://github.com/valorem-labs-inc/valorem-core/commit/05f8f56161f11372170aab51c3a7935ee0ec1e7c  "
    },
    {
        "title": "3.2 Rounding error in the redeemmechanism",
        "target": " OptionSettlementEngine",
        "category": " Business Logic",
        "severity": " High",
        "likelihood": " High ",
        "impact": " High ",
        "bodyDescription": "During the redeem process, the _getAmountExercised function is called.  function _getAmountExercised(OptionLotClaimIndex storage claimIndex, OptionsDayBucket storage claimBucketInfo) internal view returns (uint256 _exercised, uint256 _unexercised)  { /) The ratio of exercised to written options in the bucket multiplied by the /) number of options actually written in the claim. _exercised = FixedPointMathLib.mulDivDown(  claimBucketInfo.amountExercised, claimIndex.amountWritten, claimBucketInfo.amountWritten  );  /) The ratio of unexercised to written options in the bucket multiplied by the /) number of options actually written in the claim. _unexercised = FixedPointMathLib.mulDivDown(  claimBucketInfo.amountWritten - claimBucketInfo.amountExercised, claimIndex.amountWritten, claimBucketInfo.amountWritten  ); }  Due to the nature of how the amounts of exercised and unexercised options are calcu- lated, there is the possibility of a rounding error. Thismay happen if claimBucketInfo.a mountWritten - claimBucketInfo.amountExercised * claimIndex.amountWritten < cl aimBucketInfo.amountWritten. For example, this applies when the amount that was exercised globally has almost reached the amount that was written globally, and a users written claim is relatively low. In this case, the user will receive no underlying  Zellic 12 Valorem Inc    tokens, even though they have exercised their options, as well as slightly less exercise tokens than they should have. ",
        "bodyImpact": "Depending on the variables of the equations, the user may potentially incur a loss of some or all of their unexercised or exercised tokens. ",
        "bodyRecommendations": "This issue was identified by the Valorem team and verified by Zellic. Valorem imple- mented changes to the calculations in underlying(), redeem(), and claim(), by placing all multiplication before division, to prevent loss of precision. ",
        "remediation": "During the remediation phase of the audit, Valorem implemented significant changes to the options' writing mechanism and overall contract architecture in order to ad- dress the issues that were identified. A thorough examination will be conducted dur- ing the next audit phase to confirm that these changes have effectively resolved the issue.  Zellic 13 Valorem Inc   "
    },
    {
        "title": "3.3 Writing during the exercise period may lead to arbitrage",
        "target": " OptionSettlementEngine",
        "category": " Business Logic",
        "severity": " Medium",
        "likelihood": " Medium ",
        "impact": " Medium ",
        "bodyDescription": "Currently, a user is allowed to write an option until its expiry date. The exercise period, however, lasts from the exercise to the expiry timestamps of an option.  function write(uint256 optionId, uint112 amount, uint256 claimId) public returns (uint256) { /) ...)) Option storage optionRecord = _option[optionKey];  uint40 expiry = optionRecord.expiryTimestamp; if (expiry =) 0) {  revert InvalidOption(optionKey); } if (expiry <) block.timestamp) {  revert ExpiredOption(optionId, expiry); } /) ...))  }  function exercise(uint256 optionId, uint112 amount) external { /) ...)) Option storage optionRecord = _option[optionKey];  if (optionRecord.expiryTimestamp <) block.timestamp) { revert ExpiredOption(optionId, optionRecord.expiryTimestamp);  } /) Require that we have reached the exercise timestamp if (optionRecord.exerciseTimestamp >) block.timestamp) {  revert ExerciseTooEarly(optionId, optionRecord.exerciseTimestamp); } /) ...))  }  Zellic 14 Valorem Inc    This overlapping of thewriting and exercising periods is prone to arbitrage opportuni- ties. Due to the way the options' buckets are organized (per day), one can predict that should a specific exercise happen in today's bucket, writing to it leads to a guaranteed share of the exercise tokens. ",
        "bodyImpact": "The arbitrage opportunity does not lead to loss of funds for the user; however, it may lead to unexpected returns in terms of exercise tokens of an option. ",
        "bodyRecommendations": "We recommend either disallowing the writing of options during the exercise period or creating a time buffer such that only buckets that have been written at least one day prior to the current epoch can be exercised. ",
        "remediation": "During the remediation phase of the audit, Valorem implemented significant changes to the options' writing mechanism and overall contract architecture in order to ad- dress the issues that were identified. A thorough examination will be conducted dur- ing the next audit phase to confirm that these changes have effectively resolved the issue.  Zellic 15 Valorem Inc   "
    },
    {
        "title": "3.4 The _claimIdToClaimIndexArraymapping is not reset in the",
        "target": " OptionSettlementEngine",
        "category": " Business Logic",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "The _claimmapping contains the OptionLotClaimIndex object for claimId. This points the claimId to a claim's indices in the _claimIndexArray array. The information is cre- ated during the _addOrUpdateClaimIndex call. During the redeem call, an internal _getPo sitionsForClaim is called, which in turn retrieves the exercise and underlying amounts of a claim.  function redeem(uint256 claimId) external {  /) ...))  (uint256 exerciseAmount, uint256 underlyingAmount) = _getPositionsForClaim(optionKey, claimId, optionRecord);  /) ...)) }  function _getPositionsForClaim(uint160 optionKey, uint256 claimId, Option storage optionRecord) internal view returns (uint256 exerciseAmount, uint256 underlyingAmount) { OptionLotClaimIndex storage claimIndexArray = _claimIdToClaimIndexArray[claimId];  for (uint256 i = 0; i < claimIndexArray.length; i+)) { OptionLotClaimIndex storage = claimIndexArray[i]; OptionsDayBucket storage claimBucketInfo  = _claimBucketByOption[optionKey][claimIndex.bucketIndex]; (uint256 amountExercised, uint256 amountUnexercised)  = _getAmountExercised(claimIndex, claimBucketInfo); exerciseAmount += optionRecord.exerciseAmount * amountExercised; underlyingAmount += optionRecord.underlyingAmount  * amountUnexercised;  Zellic 16 Valorem Inc    } } ",
        "bodyImpact": "The claimId token is burned, but the storage still contains information about it. This information is no longer necessary, and in the expected behavior of the protocol, it will never be re-used. ",
        "bodyRecommendations": "To avoid further unexpected behavior, we recommend deleting the _claimIdToClaim IndexArray[claimId] object altogether.  function redeem(uint256 claimId) external {  /) ...)) (uint256 exerciseAmount, uint256 underlyingAmount) = _getPositionsForClaim(optionKey, claimId, optionRecord); delete _claimIdToClaimIndexArray[claimId]; /) ...))  } ",
        "remediation": "During the remediation phase of the audit, Valorem implemented significant changes to the options' writing mechanism and overall contract architecture in order to ad- dress the issues that were identified. A thorough examination will be conducted dur- ing the next audit phase to confirm that these changes have effectively resolved the issue.  Zellic 17 Valorem Inc   "
    },
    {
        "title": "3.5 The claimRecord.amountWritten is not reset in the redeem()",
        "* Target": " OptionSettlementEngine",
        "* Category": " Business Logic",
        "* Likelihood": " Low ",
        "* Severity": " Low",
        "* Impact": " Low ",
        "Description": "The _claimmapping contains the OptionLotClaim object for claimId, namely, data on the number of written options and status of claim. This information is created during the write call. During the redeem call the claimed state is changed to true, but the amountWritten value is not reset to zero.  function redeem(uint256 claimId) external { (uint160 optionKey, uint96 claimNum) = decodeTokenId(claimId);  if (claimNum =) 0) { revert InvalidClaim(claimId);  }  uint256 balance = this.balanceOf(msg.sender, claimId);  if (balance !) 1) { revert CallerDoesNotOwnClaimId(claimId);  }  OptionLotClaim storage claimRecord = _claim[claimId]; Option storage optionRecord = _option[optionKey];  if (optionRecord.expiryTimestamp > block.timestamp) { revert ClaimTooSoon(claimId, optionRecord.expiryTimestamp);  }  (uint256 exerciseAmount, uint256 underlyingAmount) = _getPositionsForClaim(optionKey, claimId, optionRecord);  claimRecord.claimed = true;  /) ...))  Zellic 18 Valorem Inc   ",
        "Impact": "The claimId token is burned, but the storage still contains information about it. This information is no longer necessary, and in the expected behavior of the protocol, it will never be used. ",
        "Recommendations": "To avoid further unexpected behavior, we recommend deleting the _claim[claimId] object altogether.  function redeem(uint256 claimId) external { /) ...)) claimRecord.claimed = true; delete _claim[claimId]; /) ...))  } ",
        "Remediation": "During the remediation phase of the audit, Valorem implemented significant changes to the options' writing mechanism and overall contract architecture in order to ad- dress the issues that were identified. A thorough examination will be conducted dur- ing the next audit phase to confirm that these changes have effectively resolved the issue.  Zellic 19 Valorem Inc    4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Reentrancy  Since there is a possibility of reentrancy during the _mint and _batchMint functions call, we recommend performing the underlyingAsset tokens transfer from msg.sender before the mint and _batchMint calls.  4.2 The feeTo address change may be erroneous  Currently, the setFeeTo function is done as  function setFeeTo(address newFeeTo) public { if (msg.sender !) feeTo) {  revert AccessControlViolation(msg.sender, feeTo); } if (newFeeTo =) address(0)) {  revert InvalidFeeToAddress(newFeeTo); } feeTo = newFeeTo;  }  We recommend to use a two-step address change to prevent changing the address to an erroneous one.  function setFeeTo(address newFeeTo) public { if (msg.sender !) feeTo) {  revert AccessControlViolation(msg.sender, feeTo); } if (newFeeTo =) address(0)) {  revert InvalidFeeToAddress(newFeeTo); } _newFeeTo = newFeeTo;  }  Zellic 20 Valorem Inc    ...))  function acceptFeeTo() public { require(_newFeeTo =) msg.sender); feeTo = msg.sender;  }  4.3 Calldata instead of memory for function arguments  The function sweepFees receive arguments in memory; however, the arguments in question are not altered. Arguments that are received as memory need to first be copied to memory, which adds extra gas cost. We recommend switching to calldata to reduce gas cost.  Zellic 21 Valorem Inc    5 Threat Model  This provides a full threat model description for various functions. As time permitted, we analyzed each function in the smart contracts and created a written threat model for some critical functions. A threat model documents a given function's externally controllable inputs and how an attacker could leverage each input to cause harm. Not all functions in the audit scope may have been modeled. The absence of a threat model in this section does not necessarily suggest that a function is safe.  5.1 File: OptionSettlementEngine  Function: underlying()  Intended behavior  * Provide information about the position underlying a token, useful for determin- ing the value.  * returns total amt of underlying and exercise assets currently associated with given optionKey for optionId or claimId.  Branches and code coverage  Intended branches:  * assumes that decodeTokenId call works fine 4# Test coverage  * Ensure that the token it's searched for actually exists. 4# Test coverage  * Ensure that the return values for not exercised claimId are expected (exercise- Position == 0; underlyingPosition == amount * underlyingAmount)  4# Test coverage * Ensure that the return values after exercise are expected  4# Test coverage  Negative behavior:  * will revert if tokenId is not initialized 4# Negative test?  Zellic 22 Valorem Inc    Preconditions  * Assumes that the position actually exists.  Inputs  * tokenId: - Control: full control  - Authorization: checked whether it exists. also if the option attributed to it has been initialized or not  - Impact: allows to get values for any tokenId, can be used for getting infor- mation about which bucket was exercised, if claimId connected with only one bucket  Function call analysis  * decodeTokenId(tokenId)  * What is controllable? tokenId controlled - If return value controllable, how is it used and how can it go wrong?  * used to determine the optionKEY and the claimNum attributed to a certain token Id. - would be bad if two tokenId point to the same thing.  * What happens if it reverts, reenters, or does other unusual control flow? no problems  * isOptionInitialized(optionKey)  * What is controllable? the optionKey that is used through the specified tokenId - If return value controllable, how is it used and how can it go wrong? re- turns whether a option exists at that optionKey.  - What happens if it reverts, reenters, or does other unusual control flow? it means option doesn't exist for that key.  * getPositionsForClaim(optionKey, tokenId, optionRecord) - What is controllable? optionKey, tokenId - If return value controllable, how is it used and how can it go wrong? the return values depends on howmuch tokenswas exercised from the bucket with claimId tokens andhowmuch tokenswaswritten to the current bucket. The wrong value can be returned if there are calculation mistakes.  - What happens if it reverts, reenters, or does other unusual control flow? can be reverted due to underflow  Function: encodeTokenId()  Zellic 23 Valorem Inc    Intended behavior  The pure function. Allow to calculate the tokenId value for given optionKey and clai mNum  Branches and code coverage  Intended branches:  * Ensure that the return values calculated correctly (first 20 bytes is optionKey and the last 12 bytes is claimNum)  4# Test coverage  Inputs  * optionKey:  * Control: full control - Authorization: no checks  - Impact: no impact * claimNum:  - Control: full control  - Authorization: no checks  - Impact: no impact  Function call analysis  There aren't external calls here.  Function: decodeTokenId()  Intended behavior  The pure function. Allows to parse from the tokenId the optionKey and claimNum val- ues.  Branches and code coverage  Intended branches:  * Ensure that the return values calculated correctly (first 20 bytes from tokenId is optionKey and the last 12 bytes is claimNum)  4# Test coverage  Zellic 24 Valorem Inc    Inputs  * tokenId: - Control: full control  - Authorization: no checks  - Impact: no impact  Function call analysis  There aren't external calls here.  Function: newOptionType()  Intended behavior  * Should create a new option if it doesn't already exist.  Branches and code coverage  Intended branches:  * Check that exerciseTimestamp is at least 24h after expiryTimestamp(as per docu- mentation)  4# Test coverage * Check that expiryTimestamp > 24h  4# Test coverage * Check that exerciseTimestamp and expiryTimestamp are both in the future.  4# Test coverage * Check whether the optionType exists. Should revert if true.  4# Test coverage. covered by isOptionInitialized(optionKey)  Negative behavior:  * Make sure underlyingAsset !) exerciseAsset/ 4# Negative test? Covered by if-case  * Revert if expiryTimestamp < 24h 4# Negative test?  * Revert if exercise window is less then 24h 4# Negative test?  Preconditions  * Assumes that a pair with literally the same details doesn't already exist. * Assumes that the encoding used to calculate the optionKey is unique! And that  Zellic 25 Valorem Inc    it cannot be duplicated  Inputs  * underlyingAsset:  * Control: only existing contract address - Authorization: underlyingToken.totalSupply() >= underlyingAmount  - Impact: - * underlyingAmount:  * Control: limited control - Authorization: underlyingToken.totalSupply() >= underlyingAmount  - Impact: - * exerciseAsset:  * Control: only existing contract address - Authorization: exerciseToken.totalSupply() >= exerciseAmount  - Impact: - * exerciseAmount:  * Control: limited control - Authorization: exerciseToken.totalSupply() >= exerciseAmount  - Impact: - * expiryTimestamp:  * Control: full control - Authorization: expiryTimestamp >= (block.timestamp + 1 days)  - Impact: if exerciseTimestamp in the distant future, it will not be possible to call the redeem function!  * exerciseTimestamp: - Control: full control  - Authorization: expiryTimestamp >= (exerciseTimestamp + 1 days)  - Impact: it is possible to call the write and the exercise function the same time  Function call analysis  * isOptionInitialized(optionKey) - What is controllable? to some extent, the optionKey is controllable, since it has just been generated.  - If return value controllable, how is it used and how can it go wrong? re- turn value is used to determine whether the specific optionKey has been  Zellic 26 Valorem Inc    initialized  - What happens if it reverts, reenters, or does other unusual control flow? cannot revert; it can return false though when the optionKey was not ini- tialized.  * underlyingToken.totalSupply() and exerciseToken.totalSupply() - What is controllable? the underlyingToken and exerciseToken are both ar- bitrary;  - If return value controllable, how is it used and how can it go wrong? since both tokens are arbitrary, their totalSupply can be manipulated; it's still a good check since you wouldn't want erroneous tokens like that in your app.  - What happens if it reverts, reenters, or does other unusual control flow? basically need to assess how dangerous supplying arbitrary tokens is.  Function: write()  Intended behavior  * Write an amount of a specified option. * Writes a specified amount of the specified option, returning claim NFT id. * The following situation is possible if function write will be called with optionId  =) claimId and balanceOf[msg.sender][optionId] =) 1, then the functionwon't revert, and a non-existent OptionLotClaim storage existingClaim = _claim[en codedClaimId];will be used, because there isn't check that existingClaim exists. after that, it will be impossible to call redeem for this claimId, and funds can be stuck.  Branches and code coverage  Intended branches:  * Check option expiration. 4# Test coverage  * Check option exists. 4# Test coverage  * If msg.sender has enough tokens and optionId is valid, he receives the expected amount of optionId and one claim NFT  4# Test coverage * Should be called successfully before expiryTimestamp  4# Test coverage  Negative behavior:  Zellic 27 Valorem Inc    * Assumes that a minted option(with specifically crafted underlying) cannot be maliciously used eventually to retrieve good exercising tokens somehow? # Negative test?  * Should revert if msg.sender doesn't have enough underlyingAsset tokens 4# Negative test?  * Should revert if the first 20 bytes of claimId are not the same as optionId 4# Negative test?  * Should revert if msg.sender doesn't own claimId token 4# Negative test?  * Should revert if optionId is invalid (the last 12 bytes is not zero) 4# Negative test?  * Should revert if optionId is not exist 4# Negative test?  * Should revert before exerciseTimestamp 4# Negative test?  * Should revert after expiryTimestamp 4# Negative test?  Preconditions  * Assumes option exists. * Assumes option has not yet expired. * msg.sender should receive a claim token for this particular option. * Assumes safeTransferFrom reverts on failure.  Inputs  * claimId: - Control: full control  - Authorization: should check that decoded(claimId).optionId =) optionID given as parameter;  * basically there is a check for ((claimId >) 96) !) (optionId >) 96)) but if this can be somehow passed then it could be leveraged. - Impact: in case of non-zero, msg.sender should own this token.  * amount: - Control: full control;  - Authorization: to calculate the actual amount of underlying needed, they transfer from msg.sender the (rxAmount + fee)where uint256 rxAmount = amount * optionRecord.underlyingAmount; then the msg.sender is issued a mount shares, which are eventually recalculated.  Zellic 28 Valorem Inc    - Impact: refers to the desired amount of options. not the actual amount of underlying that is to be supplied.  * optionId: - Control: full control; It's used as an optionKey. - Authorization: checks that the option is valid and it has not expired.  - Impact: -  Function call analysis  * SafeTransferLib.safeTransferFrom(ERC20(underlyingAsset), msg.sender, addr ess(this), (rxAmount + fee)); - What is controllable? underlyingAsset, to some degree, msg.sender , rxAm  ount to some degree. - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? writing of the options won't happen if this reverts, since no funds would have been transferred from msg.sender  * _mint(msg.sender, optionId, amount, \"\"); CAN BE RE_ENTERED IN - What is controllable? optionId, amount, msg.sender  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? cannot revert, unless totalSupply was reached(highly unlikely)  * _batchMint(msg.sender, tokens, amounts, \"\"); CAN BE RE_ENTERED IN - What is controllable? tokens, amounts; basically this is used when the cla  imId is 0, meaning the claimNFT also has to be supplied for the user. - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? can revert if the size of tokens and amounts are wrong. Or if msg.sender doesn't support ERC1155. Also does external call of to address, where to is msg.sender, potential reentrancy.  * _addOrUpdateClaimIndex(encodedClaimId, bucketIndex, amount) - What is controllable? encodedClaimId - controlled, amount - limited con- trol  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Zellic 29 Valorem Inc    * _addOrUpdateClaimBucket(optionKey, amount); - What is controllable? optionKey - full control, amount - limited control  - If return value controllable, how is it used and howcan it gowrong? in case of a mistake, it might return the wrong bucketIndex eg. create for the next day if current is not past yet. but the index of bucket is not controllable.  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * decodeTokenId(tokenId) - What is controllable? tokenId the parameter - If return value controllable, how is it used and how can it go wrong?  * used to determine the optionKEY and the claimNum attributed to a certain token Id. - would be bad if two tokenId point to the same thing.  * What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: exercise()  Intended behavior  * Exercise one's option. Swap the underlying to the exerciseAsset. * Exercises the amount of optionId, transferring in the exercise asset from msg.sen  der, and transferring of the underlying asset to msg.sender.  Branches and code coverage  Intended branches:  * Balance of optionId tokens of msg.sender decrease by amount value 4# Test coverage  * Balance of exerciseAsset of contract increase by the exerciseAmount * amount + fee value  4# Test coverage * Balance of underlyingAsset of msg.sender increase by the underlyingAmount *  amount value 4# Test coverage  * Assure that option has not expired and that option can be exercised. 4# Test coverage  * Transfer the exerciseAsset from msg.sender  balanceOf[exerciseAsset][msg.se nder] should decrease  4# Test coverage * Assure that option exists.  Zellic 30 Valorem Inc    4# Test coverage * Should burn the amount of options the msg.senderwants to exercise  4# Test coverage  Negative behavior:  * Shouldn't allow transferring arbitrary underlying UNLESS this underlying was SPECIFICALLY written for this optionID!; Otherwise, malicious options could be leveraged. this should be assured through _assignExercise # Negative test?  * Shouldn't allow burning option that doesn't exist. # Negative test?  * If exerciseTimestamp is equal block.timestamp, the transaction will reverted # Negative test?  * If expiryTimestamp is equal block.timestamp, the transaction will be reverted # Negative test?  * If exerciseTimestamp in the future, the transaction will be reverted 4# Negative test?  * If expiryTimestamp in the past, the transaction will be reverted 4# Negative test?  * If optionId doesn't exist, the transaction will be reverted 4# Negative test?  * If msg.sender doesn't have enough exerciseAsset tokens, the transaction will be reverted  4# Negative test?  Preconditions  * Assumes option exists and is exercisable.  Inputs  * optionId: - Control: limited control, only an existing optionId - Authorization: there is a check that the last 12 bytes are zero because other- wise, it is a claimId. Also, there are the checks that expiryTimestamp should be more than block.timestamp and exerciseTimestamp should be less than block.timestamp.  - Impact: msg.sender should own the optionId tokens. Also msg.sender can control fields of this optionId.  * amount: - Control: limited control  Zellic 31 Valorem Inc    - Authorization: the msg.sender should have at least amount of the options. - Impact: allows the caller to send the specified amount of exerciseAsset to contract and receive the specified amount of underlyingAsset.  * msg.sender: - Control: -  - Authorization: optionId tokens balanceOf msg.sender should be more or equal to the amount value  - Impact: only owner of optionId should be able to call this function  Function call analysis  * SafeTransferLib.safeTransferFrom(ERC20(exerciseAsset), msg.sender, addres s(this), (rxAmount + fee)); - What is controllable? exerciseAsset to some degree, msg.sender (rxAmoun  t + fee) to some degree - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? function fails bc msg.sender doesn't have enough exerciseAsset to back-up the exercise request.  * SafeTransferLib.safeTransfer(ERC20(optionRecord.underlyingAsset), msg.sen der, txAmount); - What is controllable? msg.sender, underlyingAsset, txAmount - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? it's bad if this fails bc it means there's not enough underlying to supply the msg.senderwith, despite the fact that they're entitled to it!  * _burn(msg.sender, optionID, amount); - What is controllable? optionId, amount  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? will revert if msg.sender doesn't have enough  * _assignExercise(optionKey, optionRecord, amount); - What is controllable? optionKey, amount to some degree - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? should return if all buckets are empty?  Zellic 32 Valorem Inc    * decodeTokenId(tokenId) - What is controllable? tokenId the parameter - If return value controllable, how is it used and how can it go wrong?  * used to determine the optionKEY and the claimNum attributed to a certain token Id. - would be bad if two tokenId point to the same thing.  * What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: redeem()  Intended behavior  * Allow underlying suppliers to redeem their claim for an option; msg.sender is to receive either:  1. the desired exercise amount  2. mix of exercise amount and underlying  3. full refund of underlying  Branches and code coverage  Intended branches:  * Balances of underlyingAND/OR exercise of the msg.sender should increase de- pending on the case! Make sure every case is covered.(3 cases) # Test coverage  * Assure claimRecord.amountWritten is depleted. # Test coverage  * assure optionID exists 4# Test coverage  * burn the claim token of a user. 4# Test coverage  Negative behavior:  * Shouldn't allow transferring arbitrary underlying (ORCOLLATERAL)UNLESS this underlying was SPECIFICALLY written for this optionID!; Otherwise, malicious options could be leveraged - this should be assured through _getPositionsForClaim.  Negative test?  Zellic 33 Valorem Inc    Preconditions  * The expiryTimestamp has come * The claimIdwas minted over write function  Inputs  * claimID: - Control: full  - Authorization: must assure that it exists and that the option attributed to it has not expired.  - Impact: Allows the caller to redeem his claim for the underlying and exer cise assets, so it is important to check that caller is owner of claimId and that he didn't redeem it before.  Function call analysis  * _getPositionsForClaim(optionKey, claimId, optionRecord)  * What is controllable? claimId and optionKey, because it is a part of claimId. but it is a limited control because the msg.sender should be owner of claimId - If return value controllable, how is it used and how can it go wrong? the return values are the number of tokens that will be sent to the msg.sende r, so in case of wrong calculation, the caller could steal some tokens or receive less than expected.  - What happens if it reverts, reenters, or does other unusual control flow? will revert in case of wrong claimBucketInfo.amountWritten and claimBuc ketInfo.amountExercised calculation, when amountExercised will be more than amountWritten  * _burn(msg.sender, claimId, 1)  * What is controllable? claimId - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? will revert if msg.sender isn't owner of the claimId token  * SafeTransferLib.safeTransfer - What is controllable? -  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? will revert in case of error inside token contract  Zellic 34 Valorem Inc    Function: sweepFees()  Intended behavior  * Should allow the feeTo address to sweep the amassed fees.  Branches and code coverage  Intended branches:  * Should be callable by anyone, however, the fees should only be transferrable to feeTo.  4# Test coverage * Decrease the balances of each token after they've been withdrawn.  # Test coverage  Negative behavior:  * Shouldn't leave the feeBalance un-updated. 4# Negative test?  Preconditions  * Assumes some fees have accrued. * Assumes there is actually enough tokenBalance to pay for the fees.  Inputs  * tokens: - Control: full control; list of arbitrary addresses  - Authorization: there's a check that the internal balance(called feeBalanc e[token] ) exists and has been increasing. Technically this should guard against draining tokens that shouldn't be drainable.  - Impact: the address of contract which function will be called  Function call analysis  * SafeTransferLib.safeTransfer(ERC20(token), sendFeeTo, sweep); - What is controllable? ERC20(token), sweep - If return value controllable, how is it used and how can it go wrong? n/a  - What happens if it reverts, reenters, or does other unusual control flow? transfer of funds won't happen, and entire transaction fails; won't be an issue since it can be easily reproduced.  Zellic 35 Valorem Inc    Function: _addOrUpdateClaimBucket()  Intended behavior  * Internal function. The function is called only from write function and returns the bucketIndex value.  * Gets _claimBucketByOption by optionKey. The bucketIndex is the current length of _claimBucketByOption[optionKey].  * If _claimBucketByOption[optionKey] is empty, then add the new OptionsDayBuc ket object, update _unexercisedBucketsByOption[optionKey], and return.  * Else gets the last OptionsDayBucket from _claimBucketByOption[optionKey]. * If the next day has come, add the new OptionsDayBucket object, update _unexe  rcisedBucketsByOption[optionKey], and return. * The same actions as the case with empty _claimBucketByOption[optionKey]. * If the same day, increase the current amountWritten by amount, check _doesBuck  etIndexHaveUnexercisedOptions and update if it doesn't have one.  Branches and code coverage  Intended branches:  * Create a claimBucket if one doesn't exist. 4# Test coverage  * Covered all edge cases when querying for current claimBuckets. # Test coverage  * Should be used when writing options; ensure that all fields are updated for the specific optionKey. # Test coverage  Negative behavior:  * Assure that the info gets depleted when used. # Negative test?  * Shouldn't be callable after an option has expired. (this should be covered in write) # Negative test?  Preconditions  * Assumes it's only used when writing an option(basically when the claim is cre- ated).  Zellic 36 Valorem Inc    Inputs  * uint160 optionKey: - Control: full;  - Authorization: no checks at this level  - Impact: * uint112 amount:  - Control: full  - Authorization: no checks at this level  - Impact:  Function call analysis  * _getDaysBucket() - What is controllable?  * the block.timestamp to some degree. - If return value controllable, how is it used and how can it go wrong? no problems  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * *)_updateUnexercisedBucketIndices( optionKey, bucketIndex, unexercised);* * - What is controllable? optionKey; used to update the unexercised bucket indices.  - If return value controllable, how is it used and how can it go wrong? there isn't return value  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: _updateUnexercisedBucketIndices()  Intended behavior  Internal function. The function is called only from _addOrUpdateClaimBucket.  The function allows adding bucketIndex to _unexercisedBucketsByOption[optionKey], whichmaintains amapping from option id to a list of the unexercised bucket (indices).  Also, the bucketIndexwill be marked as an unexercised option inside _doesBucketInd exHaveUnexercisedOptions[optionKey].  Function: _addOrUpdateClaimIndex()  Zellic 37 Valorem Inc    Intended behavior  * Internal function. The function is called only from write. 1. If _claimIdToClaimIndexArray[claimId] is empty add new OptionLotClaim  Index{amountWritten:amount, bucketIndex} object and return. 2. If bucketIndex of the last element is less than the passed bucketIndex value, then add a new OptionLotClaimIndex{amountWritten:amount, bucketIndex } object and return.  3. Otherwise, increase the amountWritten value of the last element.  Branches and code coverage  Intended branches:  Negative behavior:  * Assumes that the indices' amountWritten is eventually depleted when used. # Negative test?  Preconditions  * Assumes it's used when writing an option.  Inputs  * claimId: - Control: partial control  - Authorization: it's called within write; it's checked there - Impact: all written tokens will be counted for this identifier.  * bucketIndex: - Control: little control; used from the return of addOrUpdateClaimBucket - Authorization: should always exist; there's also a check on whether it's identical to last's index or not.  - Impact: the index of the bucket in which the tokens were written * amount:  - Control: full control  - Authorization: it's basically the amount that's written; aka the amount of options that the user buys;  - Impact: the amount of written tokens  Function call analysis  There aren't external calls.  Zellic 38 Valorem Inc    Function: _assignExercise()  Intended behavior  * fair exercise assignment by selecting a claim bucket between initial creation of the option type and today. Buckets are then iterated from oldest to newest; the seed for pseudorandom index is updated accordingly on the option type.  Branches and code coverage  Intended branches:  * Completely exercised arrays shouldn't be accessible by index. # Test coverage  * Should a unexercisedBucket be completely exercised  it should be removed. # Test coverage  * Select an index \"randomly\" and use that for assigning the exercise. # Test coverage  Negative behavior:  * uint112 amountAvailable = claimBucketInfo.amountWritten - claimBucketInfo .amountExercised; Should never revert! # Negative test?  * Shouldn't be biased in any way. # Negative test?  * If no more picks can be made  it should revertwithout consuming the gas. # Negative test?  Preconditions  * Assumes there's multiple buckets to choose from and all of them can be exer- cised.  * Assumes that the functions calling this work fine * Assumes that there's no way that two unexercisedBucketIndices can point to the same claimBucketInfo.  Inputs  * uint160 optionKey: - Control: controlled  - Authorization: all checks are inside the exercise function that calls this one. - Impact: allows to get data about written buckets.  * uint112 amount:  Zellic 39 Valorem Inc    - Control: controlled  - Authorization: all checks are inside the exercise function that calls this one. - Impact: the amount of options which will be executed  Function call analysis  There aren't external calls.  Function: _getAmountExercised()  Intended behavior  * Should return the exercised and unexercised options for a given claim. * Remove empty bucket from the _unexercisedBucketsByOption[optionKey]map- ping  Branches and code coverage  Intended branches:  * Return correct and up-to-date claimBucket and claimIndex information. # Test coverage  Negative behavior  * claimIndex # Negative test?  * claimBucketInfo # Negative test?  Preconditions  * Assumes that the option claimIndex belongs to a claim that can be exercised.  Function call analysis  There aren't external calls.  Function: _getPositionsForClaim()  Intended behavior  Allows to get the exercise and underlying amounts for a claim  Zellic 40 Valorem Inc    Branches and code coverage  Intended branches:  * Ensure that the exerciseAmount and underlyingAmount calculated properly # Test coverage  Negative behavior:  * Shouldn't be callable in cases where the claimId, optionKey and optionRecord are not referring to the same option. This should be covered by the fact that opt ionKey is retrieved through claimId, and that optionRecord accesses the option at that optionKey. # Negative test?  Preconditions  * Assumes that claimId, optionKey and optionRecord are linked and not refer to the same option basically.  Function call analysis  There aren't external calls.  Function: setFeeTo()  Intended behavior  Allows to current FeeTo address to change the feeTo address.  Branches and code coverage  Intended branches:  * After the call newFeeTo is set 4# Test coverage  Negative behavior:  * Revert if newFeeTo is zero address 4# Negative test?  * Revert if msg.sender is not FeeTo 4# Negative test?  Zellic 41 Valorem Inc    Preconditions  * the current FeeTo is not zero address  Inputs  * newFeeTo: - Control: full control  - Authorization: only current FeeTo - Impact: in case of an error when changing the address, the fee will be lost.  External call analysis  There aren't external calls.  5.2 File: TokenURIGenerator  Function: generateNFT()  Intended behavior  * Generate an SVG associated with a NFT option.  Branches and code coverage  Intended branches:  * Generate an unique NFT based on the given parameters.(for the header, amounts and date sections) # Test coverage  Negative behavior:  * Also why return string and then do bytes of it? maybe it could just return bytes and use that in generateName. # Negative test?  * Shouldn't return an unusable SVG. This could happen if there are ' in the param- eters names and so on; # Negative test?  Preconditions  * Assumes each generated SVG is unique.  Zellic 42 Valorem Inc    Inputs  * TokenURIParams params: - Control: full control; MAKE SURE THAT params are checked and not null; otherwise stuff might break in the SVG also that there's no '  - Authorization: n/a  - Impact: data to be added to the generated svg for the NFT  Function call analysis  * ERC20(params.underlyingAsset).decimals(); - What is controllable? params - If return value controllable, how is it used and howcan it gowrong? should be checked at protocol level  - What happens if it reverts, reenters, or does other unusual control flow? no problems  * ERC20(params.exerciseAsset).decimals(); - What is controllable? params - If return value controllable, how is it used and howcan it gowrong? should be checked at protocol level  - What happens if it reverts, reenters, or does other unusual control flow? no problems  Function: constructTokenURI()  Intended behavior  Generates a URI for a claim NFT.  Branches and code coverage  Intended branches:  * Ensure that uri generated properly # Test coverage  Negative behavior:  * revert if params.underlyingAsset or params.exerciseAsset address is zero # Negative test?  Inputs  * TokenURIParams params:  Zellic 43 Valorem Inc    - Control: full control  - Authorization: n/a  - Impact: data to be added to the generated uri  Function call analysis  There aren't external calls here.  Function: generateName()  Intended behavior  Generates a name for the NFT.  Branches and code coverage  Intended branches:  * Ensure that the name generated properly # Test coverage  Negative behavior:  * revert if year, month or day is in the wrong format. # Negative test?  Inputs  * TokenURIParams params: - Control: full control  - Authorization: n/a  - Impact: data to be added to the generated name  Function call analysis  There aren't external calls here.  Function: generateDescription()  Intended behavior  Generates a description for the NFT.  Zellic 44 Valorem Inc    Branches and code coverage  Intended branches:  * Ensure that the description generated properly # Test coverage  Negative behavior:  * revert if params.underlyingAsset or params.exerciseAsset address is zero # Negative test?  Inputs  * TokenURIParams params: - Control: full control  - Authorization: n/a  - Impact: data to be added to the generated description  Function call analysis  There aren't external calls here.  Zellic 45 Valorem Inc    6 Audit Results  At the time of our audit, the code was not deployed to mainnet EVM.  During our audit, we discovered four findings. An additional high impact finding was discovered by Valorem and verified by Zellic. Of these, twowere of high risk, onewas of medium risk, and two were low risk. Valorem Inc acknowledged all findings and implemented fixes.  6.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 46 Valorem Inc   \tAbout Zellic \tExecutive Summary \tGoals of the assessment \tNon-goals and limitations \tResults  \tIntroduction \tAbout Valorem Options \tMethodology \tScope \tProject overview \tProject timeline  \tDetailed Findings \tUn-encoded claimID can be used in write() \tRounding error in the redeem mechanism \tWriting during the exercise period may lead to arbitrage opportunities \tThe _claimIdToClaimIndexArray mapping is not reset in the redeem() function \tThe claimRecord.amountWritten is not reset in the redeem() function  \tDiscussion \tReentrancy \tThe feeTo address change may be erroneous \tCalldata instead of memory for function arguments  \tThreat Model \tFile: OptionSettlementEngine \tFile: TokenURIGenerator  \tAudit Results \tDisclaimers  "
    }
]