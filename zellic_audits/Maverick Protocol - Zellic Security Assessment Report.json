[
    {
        "title": "3.1 Major Attack Scenarios"
    },
    {
        "title": "3.2 Code Maturity Assessment",
        "* Target": " Project-Wide ",
        "* Category": " Code Maturity",
        "* Likelihood": " Informational ",
        "* Severity": " Informational",
        "* Impact": " Informational ",
        "Description": "The pool initializer does not validate the inputted parameters. In the fuzzing tests that Nexus Labs provided to us, for example, the protocolFeeRatio parameter was 1.1e2 (110%). The invalid parameter caused subtle accounting errors that we did not catch until modifying the tests to make them stricter. ",
        "Impact": "An uninformedpool deployermay unintentionally configure invalid settings that cause the pool to be vulnerable or not function properly.  Recommendation  Add require() statements to ensure all pool parameters are valid. ",
        "Remediation": "Nexus Labs noted that only their pool factory can deploy pools, and it is their respon- sibility to deploy with the correct settings.  Zellic 24 Maverick Protocol    7 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  WeadmireNexus Labs for their good test coverage anduse of the fuzzing suite echidna. Their automatic liquidity-concentrating AMM is certainly innovative in the DeFi space.  As described in the Detailed Methodology section, as part of our analysis of the smart contracts, we implemented an end-to-end fuzzing suite to verify that the estimator-- which is used to approximate prices/trades for the pool--was in fact in sync with the pool. We also employed a series of random fuzzing tests to determine the robustness of the pool for extreme imbalances and extreme (but valid) values.  During our fuzzing, we found several edge cases that either rendered the pool unus- able or threw off internal bookkeeping.  7.1 Dependence on block.timestamp  The spread fee--which relies on the configurable time value (default 3600 seconds)-- is increasingly vulnerable to timestampmanipulation byminers (Reference) for smaller T values. This dependence may allow certain arbitrageurs to abuse the block.timest amp to become the winners when a large U-moving transaction occurs.  We believe that for some pools where the underlying assets are volatile, a low value is optimal for T so that the AMM is up to date with moving market prices. Those cases where the T values are low, the pool may be susceptible to block.timestamp manipulation.  For the default T value of 1 hour, we estimate that the spread fee is <1 percent manip- ulable by miners, based on the \"15-second Rule\". Thus, we believe the security risk stemming from this dependence is limited.  7.2 Invalid Pool Parameters in Maverick's Tests  Weobserved that, in the fuzzing tests provided byMaverick, there are invalid (i.e. out- of-bounds) values. For example, the protocolFeeRatio setting is configured as 1.1e2 which results in the occurence of negative numbers in certain areas:  Zellic 25 Maverick Protocol  https://cryptomarketpool.com/block-timestamp-manipulation-attack/ https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/timestamp-dependence/   int256 protocolFee = assetFee.mul( int256(currentState.protocolFeeRatio) * 1e16  ); baseBalance += int128(assetFee - protocolFee);  The above code--with the invalid protocolFeeRatio--takes 110% of the assetFee and subtracts it from assetFee, resulting in a negative number. This lowers the internal quot eBalance/baseBalance. In extreme caseswhen the internal balances of quote/base are small and the amountIn is large enough, the 10%negative offset of the protocolFeeRatio would lower the internal balances to negative ranges--later resulting in reverts.  7.3 Casting to int128May Truncate Numbers  When the incoming quantities are large enough, several places in the code may trun- cate bytes from the numbers resulting in overflow-like behavior; that is, some num- bers may become negative when cast into int128 leading to a revert if passed into sqrt. The solution to this issue is to always use safe casting functions such as those implemented in libraries/Cast.sol.  7.4 Loss of Precision in Decimal Scaling  Scaling of varying decimals resulted in the loss of precision in very small inputs. For example, when doing a small-enough swap with a 24-decimal token where the quo teBalance/baseBalance is scaled down to 18 decimals using standard PRB math, the quoteBalance/baseBalance remains the same resulting in a 0 value of amountIn:  function _quoteTokenBalance(State memory currentState) internal view returns (int256)  { return  SafeTransfer .fromScale(  IERC20(quote).balanceOf(address(this)), currentState.quoteDecimals  ) .toInt256();  }  Zellic 26 Maverick Protocol    amountIn = _quoteTokenBalance(currentState) - totalQuoteBalance;  An amountIn value of 0 causes a revert with the reason string Pool:INSUFFICIENT_SWAP.  Zellic 27 Maverick Protocol   \tAbout Zellic \tIntroduction \tAbout Maverick \tMethodology \tScope \tProject Overview \tProject Timeline \tDisclaimer  \tExecutive Summary \tCoverage \tMajor Attack Scenarios \tCode Maturity Assessment  \tCode Overview \tContract Pool in Pool.sol \tContract Router in Router.sol \tContract Estimator in Estimator.sol \tContract ZeroExRouter in ZeroExRouter.sol \tContract Factory in Factory.sol  \tDetailed Methodology \tManual Static Analysis \tAutomated Static Analysis \tSymbolic Execution and SMT Checking \tFuzzer Dynamic Analysis  \tDetailed Findings \tRounding Issues Caused by Loss of Precision \tInterfaces Inaccurately Describe Contracts \tLack of Documentation \tLack of Pool Parameter Validation  \tDiscussion \tDependence on block.timestamp \tInvalid Pool Parameters in Maverick's Tests \tCasting to int128 May Truncate Numbers \tLoss of Precision in Decimal Scaling  "
    }
]