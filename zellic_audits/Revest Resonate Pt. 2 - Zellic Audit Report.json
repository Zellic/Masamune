[
    {
        "title": "3.1 Inconsistent interest calculations in Resonate",
        "target": " Resonate ",
        "category": " Business Logic",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "In order to convert from the amount of underlying assets to shares, claimInterest uses previewWithdraw(...))):  function previewWithdraw(uint256 assets) public view override returns (uint256)  { return convertToShares(assets);  } [...))] function convertToShares(uint256 assets)  public view override returns (uint256)  { return (assets * yVault.totalSupply()) / getFreeFunds();  }  However, batchClaimInterest uses the following to convert from assets to shares:  uint shareNormalization = vault.totalSupply() * PRECISION / vault. totalAssets();  [...))] uint totalSharesUnderlying = shareNormalization * amountUnderlying /  PRECISION;  Zellic 9 Revest Finance    When interacting with the yearn vault, this results in a difference in interest calcu- lations between the two functions - claimInterest(...))) uses getFreeFunds() in the divisor while batchClaimInterest uses vault.totalAssets();. ",
        "bodyImpact": "The interest calculation of batchClaimInterest would be inflated over claimInterest by the difference in denominator in the asset-to-share conversion. ",
        "bodyRecommendations": "The difference is probably not intended by developers. It would be better to leverage composability and to use previewWithdraw(...))) in batchClaimInterest. This would ensure batchClaimInterest is consistentwith claimInterest across the different adapter implementations. ",
        "remediation": "Revest has followed the recommendation and is using previewWithdraw(...))) in com- mit da89259c00235fdab7edbcb638ec04f3e360ef48.  Zellic 10 Revest Finance   "
    },
    {
        "title": "3.2 Incompletewhitelist andblacklist functionality in Resonate-",
        "target": " ResonateHelper ",
        "category": " Business Logic",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "Once a fxSelector has been added to the whitelist, it cannot later be blacklisted.  For example, if the function has not been blacklisted it can be set in the whitelist:  function whiteListFunction(uint32 selector) external onlySandwichBot glassUnbroken { require(!blackListedFunctionSignatures[selector], \"ER030\"); whiteListedFunctionSignatures[selector] = true;  }  And if the function has been whitelisted, it can still be blacklisted:  function blackListFunction(uint32 selector) external onlySandwichBot glassUnbroken { blackListedFunctionSignatures[selector] = true;  }  However, if a function has been whitelisted and is then blacklisted, it will still pass the validation check in proxyCall(...) because function logic only requires the fxSelector to exist in the whitelist:  function proxyCall(bytes32 poolId, address vault, address[] memory targets, uint[] memory values, bytes[] memory calldatas) external onlySandwichBot glassUnbroken { for (uint256 i = 0; i < targets.length; i++) {  require(calldatas[i].length >) 4, \"ER028\"); /)Prevent calling fallback function for re-entry attack  bytes memory selector = BytesLib.slice(calldatas[i], 0, 4); uint32 fxSelector = BytesLib.toUint32(selector, 0); require(whiteListedFunctionSignatures[fxSelector], \"ER025\");  }  Zellic 11 Revest Finance    ISmartWallet(_getWalletForFNFT(poolId)).proxyCall(vault, targets, values, calldatas);  } ",
        "bodyImpact": "If the sandwichbot were to mistakenly set a dangerous function (or a function that later turned out to be dangerous) to the whitelist they would not be able to later block that function from being passed to proxyCall(...))). ",
        "bodyRecommendations": "Include logic to blacklist previously whitelisted functions. The blacklist should be im- mediately set to include increaseAllowance and approve as these functions can be used to increase spending allowance, which can trigger transactions that would pass the balance checks on proxyCall(...))) in ResonateSmartWallet. ",
        "remediation": "Revest has added in the functionality that would allow for blacklisting of previously whitelisted functions in commit f95f9d5ac4ac31057cef185d57a1a7b03df5f199. The func- tions increaseAllowance and approve have been added to the blacklist in commit f24 28392e0ce022cd6fde9cf41e654879c03119c.  Zellic 12 Revest Finance   "
    },
    {
        "title": "3.3 Missing claim event in batchClaimInterest",
        "* Target": " Resonate ",
        "* Category": " Business Logic",
        "* Likelihood": " N/A ",
        "* Severity": " Informational",
        "* Impact": " Informational ",
        "Description": "There is no event emitted indicating interest has been claimed during a call to batchC laimInterest. ",
        "Impact": "Providing information on interest claimed in batches would be useful to downstream listeners. ",
        "Recommendations": "Include an event announcing interest claimed during batch calls, ideally at the pool level. ",
        "Remediation": "Revest has followed the recommendation and added the event in commit 282616250 47b025bf1baa17fcbb4c8b114878590.  Zellic 13 Revest Finance    4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Oracle attacks  If an attacker got control of the price oracle, they could pass a low price to sharesPer Packet during a call to submitProducer(...):  sharesPerPacket = IOracleDispatch(oracleDispatch[vaultAsset][pool.asset]) .getValueOfAsset(vaultAsset, pool.asset, true);  The depressed price would drive up the number of packets of vault shares for interest claiming.  ...  producerPacket = getAmountPaymentAsset(pool.rate * pool.packetSize/ PRECISION, sharesPerPacket, vaultAsset, vaultAsset);...  producerOrder = Order(uint112(amount/ producerPacket), sharesPerPacket, msg.sender.fillLast12Bytes());  They would get matched with a higher amount of underlying vault principal for the same dollar amount of pool asset deposited, allowing them to earn excessive inter- est. Similar to the points in the section on centralization risk, this attack vector is best managed by 1) using a multisig to set the price oracle address and 2) using a reliable price oracle such as ChainLink.  4.2 Reentrancy  The functions batchClaimInterest(...))) in Resonate and redeem(...))) in ResonateS- martWallet have been added since the last review and do not include the nonReent rant modifiers. While these functions do not appear to be reentrancy concerns, we advise Revest similarly apply the nonReentrantmodifiers to these functions.  The nonReentrantmodifier has been added to redeem(...))) in commit 47d6c1393264ea  Zellic 14 Revest Finance    71cad1fa8a7ae8e24869c5ae37 and to batchClaimInterest(...))) in commit da89259c002 35fdab7edbcb638ec04f3e360ef48.  4.3 Code maturity  Follow the adopted conventions for internal and private variables  Best practices for solidity development use the _ to prefix both internal and private variables and functions.  Thiswas addressed by Revest in commit b81a509b41524c896f8bfa75785b554496e16080.  Reliance on integer underflow reversion  In numerous places reversion by integer underflow is used as an implicit check that withdraw amounts do not exceed available funds. For example, this happens in rece iveResonateOutput(...))) as there is no check made on the function parameter quanti ty. It also happens in modifyExistingOrder as there is no check on amount. Including explicit checks on these parameters would send clear messages to protocol users under transaction failure and improve the overall user experience.  Revest indicated they may address this in the future.  Confusing variable names  In general the variables are intuitively named. However, the method getAddressForFN FT(bytes32 fnftId) in ResonateHelper takes an fnftId parameter but is in fact passed a poolId. This can create some developer confusion because the variable name fnft Id is also used in Resonate to denote the ID of the FNFT. We suggest Revest change the parameter name from fnftId to poolId.  Revest indicated this has been addressed.  Clear comments  At the time of audit the Resonate project is still a work in progress. There are many comments left for other developers that take the form of questions and to-do lists. There is also a general lack of good-quality comments that would be useful for some- one not intimately familiar with the code base. This applies to both the core contracts and their interfaces. For example, the following comment indicates awork in progress but also points to an unused variable:  Zellic 15 Revest Finance    function maxDeposit(address _account) public view override returns (uint256)  { _account; /) TODO can acc custom logic per depositor VaultAPI _bestVault = yVault; uint256 _totalAssets = _bestVault.totalAssets(); uint256 _depositLimit = _bestVault.depositLimit(); if (_totalAssets >= _depositLimit) return 0; return _depositLimit - _totalAssets;  }  Revest has made considerable improvements to the inline documentation.  Unused resources  There are potentially unused resources in the project; for example, FullMath is never used for uint256 in Resonate.  Revest has removed the unused library - 6b1b81f6c0310297f5b6cd9a258b99e43c61b092.  Control variables and abstraction  Using values of process variables like depositedShares to indicate pool and order con- figurations is challenging to read. And furthermore, as we have seen in these report findings, it is error prone. Revest should consider adding another layer of abstraction to more clearly illustrate pool and order configurations.  4.4 Composability  As indicated in the finding on centralization risk 'L!\\TODO{I think this finding is from the previous report, so I might suggest referring to that report here}, the Resonate protocol relies heavily on composability. It is therefore important to note that the improper functioning of any of the composable contracts lying outside of the scope of this audit is likely to cause considerable failure in Resonate. These contracts include the investment vaults (Aave and Yearn), the oracle price sources, Revest, the Revest registry, and the Revest FNFT handler.  It is important to note that similar suggestions and observations presented in the cen-  Zellic 16 Revest Finance    tralization risk finding also apply to these dependencies as well.  Zellic 17 Revest Finance    5 Audit Results  At the time of our audit, the code was not deployed to mainnet evm.  During our audit, we discovered three findings. Two of whichwere low, the remaining was informational.  5.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 18 Revest Finance   \tAbout Zellic \tExecutive Summary \tIntroduction \tAbout Resonate \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tInconsistent interest calculations in Resonate \tIncomplete whitelist and blacklist functionality in ResonateHelper \tMissing claim event in batchClaimInterest  \tDiscussion \tOracle attacks \tReentrancy \tCode maturity \tComposability  \tAudit Results \tDisclaimers  "
    }
]