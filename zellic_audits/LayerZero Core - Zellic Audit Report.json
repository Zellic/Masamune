[
    {
        "title": "3.1 Using non-contract address as destination blocks futuremes-",
        "target": " Endpoint",
        "category": " Coding Mistakes",
        "severity": " Low",
        "likelihood": " Medium ",
        "impact": " Low ",
        "bodyDescription": "An improperly-configured user application (UA) can permanently block itself from communicating with an endpoint by simply sending a message to a UA address that is not a contract.  If a UA sends a message with a destination UA address that is not a contract, the following try/catch statement does not catch the exception (as the control structure only catches failures in an external call) causing a revert on the destination chain:  try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId , _srcAddress, _nonce, _payload) { /) success, do nothing, end of the message delivery  } catch (bytes memory reason) { /) revert nonce if any uncaught errors/exceptions if the ua chooses the blocking mode storedPayload[_srcChainId][_srcAddress] = StoredPayload(uint64( _payload.length), _dstAddress, keccak256(_payload)); emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, reason);  }  If the destination chain reverts, the source chain's nonce remains incremented by 1 while the destination chain's nonce is unchanged. ",
        "bodyImpact": "When the nonces are desynchronized, no messages can be sent to any destination UA address because the destination endpoint assumes the messages are out of order.  Endpoints key the nonce map with the source chain ID and source UA address--  Zellic 7 LayerZero Labs    meaning this issue can only be exploited as self-denial-of-service.  Recommendation  Add a check to ensure the destination UA is a valid contract address before attempt- ing to execute its lzReceive function. If the contract address is invalid, the endpoint should route the message to a default contract address that discards the message to keep the nonces synchronized. ",
        "remediation": "The issue was also discovered in parallel by LayerZero and a fix will be released with UltraLightNode version 2.  Zellic 8 LayerZero Labs   "
    },
    {
        "title": "3.2 Out-of-bounds read in __getPrices",
        "target": " Relayer",
        "category": " Coding Mistakes",
        "severity": " Informational",
        "likelihood": " N/A ",
        "impact": " Informational ",
        "bodyDescription": "The __getPrices function uses the MLOAD instruction to read dstNativeAmt from _ada- pterParameters+66when txType =) 2:  if (txType == 2) { uint dstNativeAmt; assembly {  dstNativeAmt :) mload(add(_adapterParameters, 66)) } require(dstConfig.dstNativeAmtCap >) dstNativeAmt, \"Relayer: dstNativeAmt too large\"); totalRemoteToken = totalRemoteToken.add(dstNativeAmt);  }  At the start of the function, it checks that the size of _adapterParameters is either 34 bytes or greater than 66 bytes:  require(_adapterParameters.length =) 34 |) _adapterParameters.length > 66, \"Relayer: wrong _adapterParameters size\");  Because the assertion allows an _adapterParameters of a size smaller than the offset added to the size of the memory read, the read could potentially be out of bounds. ",
        "bodyImpact": "There is no direct security impact of this instance of out-of-bounds read. However, this code pattern allows undefined behavior and is potentially dangerous. In the past, even low-level vulnerabilities have been chained with other bugs to achieve critical security compromises.  Zellic 9 LayerZero Labs  https://sector7.computest.nl/post/2021-08-zoom/   Recommendation  The size of a uint (which is internally a uint256) is 32 bytes. So, the branch that uses the MLOAD instruction should require that the size of _adapterParameters is greater than or equal to the read size added to offset, or 98 bytes (32+66). ",
        "remediation": "The issue has been acknowledged by LayerZero.  Zellic 10 LayerZero Labs   "
    },
    {
        "title": "3.3 Messaging library provides a function to renounce owner-",
        "target": " UltraLightNode",
        "category": " Business Logic",
        "severity": " Informational",
        "likelihood": " N/A ",
        "impact": " Informational ",
        "bodyDescription": "The messaging library, UltraLightNode (ULN), implements Ownable which provides a method named renounceOwnership that removes the current owner (reference). This is likely not a desired feature of the ULN. ",
        "bodyImpact": "If renounceOwnershipwere called, the contract would be left without an owner.  Recommendation  Override the renounceOwnership function:  function renounceOwnership() public { revert(\"This feature is not available.\");  } ",
        "remediation": "The issue has been acknowledged by LayerZero.  Zellic 11 LayerZero Labs  https://docs.openzeppelin.com/contracts/2.x/api/ownership#Ownable-renounceOwnership--  "
    },
    {
        "title": "3.4 Race condition may enable bypass of library address check",
        "* Target": " Endpoint",
        "* Category": " Business Logic",
        "* Likelihood": " Low ",
        "* Severity": " High",
        "* Impact": " High ",
        "Description": "An obscure scenario may allow a malicious actor to bypass the ULN library address check in receivePayload:  /) authentication to prevent cross-version message validation /) protects against a malicious library from passing arbitrary data if (uaConfig.receiveVersion == DEFAULT_VERSION) {  require(defaultReceiveLibraryAddress =) msg.sender, \"LayerZero: invalid default library\");  } else { require(uaConfig.receiveLibraryAddress =) msg.sender, \"LayerZero: invalid library\");  }  This behavior can only happen in a very specific situation:  1. The originally-configured ULN (hereinafter referred to as the \"untrusted ULN\") must send a message (the \"untrusted message\") to the Endpoint that passes all checks in the receivePayload function but fails for any reason--causing the endpoint to store it.  2. A new ULN must be configured (the \"trusted ULN\"). This may happen if, for ex- ample, the untrusted ULN was found to be malicious or vulnerable.  3. Even though the trusted ULN is now configured--and the untrusted ULN cannot send further messages--the malicious ULN can bypass the ULN address checks and re-send the untrusted message using the retryPayload function.  It is important to understand that the untrustedmessagemust be sent before the con- figured ULN address is changed; that is, this behavior is unlikely to be exploited unless it is advantageous to amalicious actor to wait before sending amessage (e.g. if the at- tackerwants themessage to only be sent after the configuredULN address is changed, or only after some time has passed).  Zellic 12 LayerZero Labs    Because the exploit scenario is incredibly specific and obscure, we consider the like- lihood to be low. ",
        "Impact": "This behavior may lead to the endpoint forwarding an \"untrusted\" message (i.e. a message that the currently-configured ULN considers trustworthy) to the user ap- plication. The impact varies depending on the user application; however, because it is possible the behavior could lead to a negative financial impact, we consider the impact to be High, despite the low risk of exploitation.  Recommendation  A possible solution to this flaw is to clear the stored message entries in storedPay- load whenever the uaConfig's library address or the defaultReceiveLibraryAddress (whichever address should be used, depending on the value of uaConfig.receiveVe- rsion) is changed. The forceResumeReceive function clears only one entry; however, all entries should be considered untrusted and removed.  However, this solution introduces a potential issue where stored messages are not delivered during an upgrade (i.e. when the \"untrusted ULN\" is actually a legitimate, but old library).  Instead, the library upgrade process could clear storedPayload (e.g. by calling fo- rceResumeReceive) only if the upgrader determines the old library is untrustworthy. The storedPayload should be cleared immediately after changing the configured ULN address (within the same transaction) to avoid leaving a window where a malicious actor could call retryPayload. ",
        "Remediation": "The issue has been acknowledged by LayerZero and a fix may be implemented in the future.  Zellic 13 LayerZero Labs    4 Discussion  The purpose of this section is to document miscellaneous observations the we made during the assessment.  4.1 UltraLightNode Version 2  At of the time of writing, LayerZero Labs plans to release an updated ULNv2 with the following changes:  Interface Changes  * ILayerZeroRelayerV2 and ILayerZeroOracleV2: - Merges getPrice and notifyRelayer/notifyOracle interfaces into an ass-  ignJob interface. This change saves gas by avoiding one contract call per notify function.  - Adds a new getPrice function. - Adds a withdraw fee function.  * ILayerZeroUltraLightNodeV2: - Simplifies the withdraw NativeFee interface.  Miscellaneous Changes  * Trims the BlockData size from 2 bytes32 to 1. Saves gas in oracle's updateHash. * Redefines the Packet event to include new fields in the encodedPacket such as  PACKET_VERSION to make the packet translation safer and more efficient. * Adds more assertions to make the ULNv2 safer in general. * Fixes the issuewhere cross-chain contract calls to non-contract addresses cause the nonce to be out of sync, blocking further messages. See Finding 3.1 for more information.  Others  Zellic performed an informal review of the changes included in ULNv2; however, the scope of this report only includes ULNv1 and its associated contracts.  Zellic 14 LayerZero Labs    4.2 Notes on in-scope contracts  Variable naming standards inconsistency  In Endpoint.sol, the variables _send_entered_state and _receive_entered_state should be named _sendEnteredState and _receiveEnteredState (i.e. camel case), respec- tively. These variables, though internal, are not constant.  Warning about pragma locked versions  Many of the files lock pragma to Solidity versions that do not check math operations by default. Thus, it is critical that when future developers write code that performs math operations, they use the SafeMath library, write the code in a way that is safe from overflows and underflows, or be audited for secure operation. At the time of this assessment, all math operations are safe from overflows and underflows.  Additionally, consider locking the pragma to ensure that experimental compilers or compilers that lack recently-added optimizations or security updates cannot be used to compile the contracts.  Relayer/oracle trust dependence  As stated in the LayerZero protocol whitepaper and on the documentation website, the chosen relayer and oracle must be controlled by independent entities; otherwise, they could conspire to falsify messages.  Endpoint may block messages to all UAs if one transaction reverts  If any destination user application (UA)'s lzReceive function reverts, the destination endpoint will prevent all future messages from the source chain and address from being delivered--regardless of the destination UA--until the message is retried suc- cessfully (retryPayload) or forceResumeReceive is called.  The LayerZero Labs team noted that this is the intended design and that this is the only way to ensure messages delivered in the correct order on the entire chain. UAs may be built on top of the endpoint if this behavior is not desired.  4.3 Notes on out-of-scope contracts  packet.ulnAddressmust never be 0x0  The proof validation library (prooflib) was not in scope for this assessment. However, proper implementations of the prooflib must not be able to be manipulated into re-  Zellic 15 LayerZero Labs    turning a packet whose ulnAddress is 0x0; otherwise, malicious relayers may be able to bypass the following assertion in UltraLightNode:  /) (e) assert that the packet was emitted by the source ultra light node require(ulnLookup[_srcChainId] =) _packet.ulnAddress, \"LayerZero:  _packet.ulnAddress is invalid\");  If _srcChainId does not exist in ulnLookup, the operation ulnLookup[_srcChainId]will output 0x0.  The LayerZero Labs team stated that at this time, the intended design of prooflib does not allow the validateProof function to return a packet with a ulnAddress of 0x0.  notifyRelayer is not onlyULN  The notifyRelayer function in Relayer.sol does not restrict the caller to be the ULN only. So, it is critical that any code written in that function in the future either restrict the caller or treat all function inputs as untrusted.  The LayerZero Labs team acknowledged that this function does not restrict the caller, stating that the function may have later use or be implemented in third-party libraries for metadata tracking or accounting purposes.  Demo contracts contain setCaller but do not check caller  The demo user application contracts--which may be used as templates--at mocks/Om- niCounter.sol and mocks/PingPong.sol contain a function called setConfig that allows the caller to modify the ULN's configuration without checking who the caller is:  function setConfig( uint16, /)_version*) uint16 _chainId, uint _configType, bytes calldata _config  ) external override { endpoint.setConfig(endpoint.getSendVersion(address(this)), _chainId, _configType, _config);  }  Although the lack of restriction on the caller presents no immediate security concern to LayerZero, these files may be used as templates and should be secure by default. Any contract containing this setConfig function allows attackers to control the config  Zellic 16 LayerZero Labs    and potentially change configuration settings such as the relay or oracle address.  Additionally, the following functions do not restrict the caller, but modify endpoint or UA configuration:  * OmniCounter.setSendVersion * OmniCounter.setReceiveVersion * OmniCounter.setOracle * OmniCounter.setInboundConfirmations * OmniCounter.setOutboundConfirmations * PingPong.setSendVersion * PingPong.setReceiveVersion  Demo contracts contain notifyOracle functions that are not onlyULN  The demo user application contracts--which may be used as templates--at mocks/- LayerZeroOracleMock.sol and mocks/LayerZeroOracleBadMock.sol do not restrict the caller to the ULN as they should in their notifyOracle functions:  function notifyOracle(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmations) external override { emit OracleNotified(_dstChainId, _outboundProofType, _outboundBlockConfirmations);  }  Although the lack of restriction on the caller presents no immediate security concern to LayerZero, these files may be used as templates and should be secure by default. Any oracle contract using the code provided in these two files will allow allow attack- ers to control the data sent to the off-chain oracle.  We recommend restricting the caller as much as possible. For example, chainlink/- ChainlinkOracleClient.sol properly restricts the caller to the ULN using the function modifier onlyULN:  modifier onlyULN() { require(msg.sender =) address(uln), \"OracleClient: caller must be LayerZero.\"); _;  }  /) ...))  Zellic 17 LayerZero Labs    function notifyOracle(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmations) external override onlyULN {  /) ...))  Multiple functions declared as public that could be external  Many of these functions are from demo files, but it is worth noting that the following functions are declared as public but could be declared as external to save gas per operation:  * Relayer.initialize(address) * ChainlinkOracleClient.withdrawTokens(address,address,uint256) * ChainlinkOracleClient.setJob(uint16,address,bytes32,uint256) * ChainlinkOracleClient.setDeliveryAddress(uint16,address) * ChainlinkOracleClient.fulfillNotificationOfBlock(bytes32,bytes32) * ChainlinkOracleClient.isApproved(address) * LayerZeroOracleBadMock.isApproved(address) * LayerZeroOracleMock.isApproved(address) * MockLinkToken.transferAndCall(address,uint256,bytes) * MockLinkToken.mint(address,uint256) * LayerZeroOracleBadMock.withdraw(address,uint256) * LayerZeroOracleBadMock.setJob(uint16,address,bytes32,uint256) * LayerZeroOracleBadMock.setDeliveryAddress(uint16,address) * LayerZeroOracleMock.withdraw(address,uint256) * LayerZeroOracleMock.setJob(uint16,address,bytes32,uint256) * LayerZeroOracleMock.setDeliveryAddress(uint16,address) * MockToken.mint(address,uint256) * OmniCounter.getCounter() * OmniCounter.incrementCounter(uint16,bytes) * OmniCounter.incrementCounterWithPayload(uint16,bytes,bytes) * OmniCounter.incrementCounterWithAdapterParamsV1(uint16,bytes,uint256) * OmniCounter.incrementCounterWithAdapterParamsV2(uint16,bytes,uint256,uin-  t256,address) * OmniCounter.incrementCounterMulti(uint16[],bytes[],address)  Zellic 18 LayerZero Labs   \tAbout Zellic \tIntroduction \tAbout LayerZero Core \tMethodology \tScope \tProject Overview \tProject Timeline \tDisclaimer  \tExecutive Summary \tDetailed Findings \tUsing non-contract address as destination blocks future messages \tOut-of-bounds read in __getPrices \tMessaging library provides a function to renounce ownership \tRace condition may enable bypass of library address check  \tDiscussion \tUltraLightNode Version 2 \tNotes on in-scope contracts \tNotes on out-of-scope contracts  "
    }
]