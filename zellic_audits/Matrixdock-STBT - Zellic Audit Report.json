[
    {
        "title": "3.1 Custom proxy architecture",
        "target": " STBT.sol",
        "category": " Code Maturity",
        "severity": " Medium",
        "likelihood": " Medium ",
        "impact": " Low ",
        "bodyDescription": "STBT will be deployed through a proxy contract, a common design that allows up- grading the code of a contract.  STBT implements a custom proxy, which has strong constraints in the ability to up- grade the contract code and is arguably more error prone than other existing alterna- tives.  Specifically, the storage layouts of the custom proxy implementation UpgradeableS TBT and of the implementation STBT are required to not clash. This is implemented by replicating the initial part of the storage layout of the implementation contract in the proxy. The STBT contract storage has an uint[300] array of placeholders, where UpgradableSTBT stores the address of the implementation contract.  contract UpgradeableSTBT is Proxy { /) override address public owner; address public issuer; address public controller; address public moderator; /) new state below address public implementation; /) ...))  }  contract STBT is Ownable, ISTBT { /) all the following three roles are contracts of governance/TimelockController.sol address public issuer; address public controller; address public moderator;  Zellic 9 Matrixdock    uint[300] public placeholders; ///)) ...))  }  This coupling of storage layouts is unusual and unnecessary; other proxy implementa- tions move the address of the implementation contract to a different storage location (via inline assembly), in order to not interfere with the implementation storage layout. ",
        "bodyImpact": "This issue does not describe an exploitable security vulnerability in the code as re- viewed and is therefore reported as low severity. However, we believe this design choice introduces a higher risk of errors when upgrading the contract. ",
        "bodyRecommendations": "We recommend evaluating the adoption of one of the several de facto standard proxy architectures that have been developed and proven effective, such as UUPSUpgrade- able. ",
        "remediation": "Matrixdock acknowledged the finding and will not remediate at this time.  Zellic 10 Matrixdock  https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable  "
    },
    {
        "title": "3.2 High rate of failures in test suite",
        "target": " stbt-test.js",
        "category": " Code Maturity",
        "severity": " Medium",
        "likelihood": " High ",
        "impact": " Low ",
        "bodyDescription": "One of the routine steps performed during the evaluation of a codebase is inspection of the accompanying test suite. When running the test suite using the instructions available in the README, we observed a failure rate of 52% (24 out of 46). ",
        "bodyImpact": "Integrating a comprehensive test suitewith a continuous integration service is tremen- dously important for preventing bugs from being deployed.  For example, for one of the tests within it(\"redeem: errors\"...))), it expects a revert to happen because of NO_SEND_PERMISSION, when the revert cause is because the msg .sender is not the issuer.  await expect(stbt.connect(alice).redeem(123, '0x')) .to.be.revertedWith(\"NO_SEND_PERMISSION\"); ",
        "bodyRecommendations": "We recommend fixing the failing tests and running the tests automatically (e.g., by integrating them with a CI service or in Git hooks). ",
        "remediation": "Matrixdock states that this issue was caused by an unsynced test file. The finding was fixed in commit 06c46695 and now all tests pass.  Zellic 11 Matrixdock  https://github.com/Matrixport-STBT/STBT-contracts/commit/06c46695c7976d09aa336df0801df33df0a2b16a  "
    },
    {
        "title": "3.3 Lack of sanity checks",
        "* Target": " STBT.sol",
        "* Category": " Code Maturity",
        "* Likelihood": " Medium ",
        "* Severity": " Medium",
        "* Impact": " Informational ",
        "Description": "Most functions (such as the UpgradableSTBT constructor or the setter functions of STB T) do not perform any sanity check. Sanity checks are commonly included to prevent human error, for instance by checking that an address is not zero or that a numeric parameter is within a reasonable range. ",
        "Impact": "While this issue does not describe an exploitable vulnerability, the lack of sanity checks increases the risk of an incorrect interaction with the contract due to human error. ",
        "Recommendations": "Consider adding sanity checks guarding against trivial user mistakes. ",
        "Remediation": "Matrixdock acknowledged the finding and will not remediate at this time.  Zellic 12 Matrixdock    4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Lack of two-step ownership transfer  Currently, there is a one-step ownership transfer in place. This could threaten a loss of ownership of the contract in the accidental scenario in which a wrong owner is set. A two-step ownership transfer process, in which the new address must claim their ownership, protects against this scenario and could be beneficial from a security standpoint.  4.2 Commented-out code  The codebase includes commented-out code, including entire functions; this makes the codebase less maintainable and is not required since the codebase is maintained through Git.  Zellic 13 Matrixdock    5 Threat Model  This provides a full threat model description for various functions. As time permitted, we analyzed each function in the smart contracts and created a written threat model for some critical functions. A threat model documents a given function's externally controllable inputs and how an attacker could leverage each input to cause harm.  Not all functions in the audit scope may have been modeled. The absence of a threat model in this section does not necessarily suggest that a function is safe.  5.1 File: STBT  Function: distributeInterests()  Intended behavior  Distribute interests, increasing the newTotalSupply and keeping track of the last dis- tribution time.  Branches and code coverage  Intended branches:  * Valid interests are distributed and accounted for in the newTotalSupply. 4# Test coverage  Negative behavior:  * MIN_DISTRIBUTE_INTERVAL_VIOLATED 4# Negative test?  * NOT_ISSUER calling function 4# Negative test?  * MAX_DISTRIBUTE_RATIO_EXCEEDED 4# Negative test?  Preconditions  * Issuer has been set.  Inputs  * interestToTime:  Zellic 14 Matrixdock    - Control: None.  - Authorization: N/A.  - Impact: Any interestToTime can be used; perhaps this should have some input validation. Just used in an event.  * interestFromTime: - Control: None.  - Authorization: N/A.  - Impact: Any interestFromTime can be used; perhaps this should have some input validation. Just used in an event.  * _distributedInterest: - Control: Less than or equal to oldTotalSupply * maxDistributeRatio.  - Authorization: N/A.  - Impact: Only a valid distributedInterest parameter can be used that does not exceed the desired ratio.  Function: issue()  Intended behavior  Mint shares for the supplied tokenHolder.  Branches and code coverage  Intended branches:  * Issue mints the designated value for the tokenHolder. 4# Test coverage  Negative behavior:  * Zero address cannot be receiver. 4# Negative test?  * Non-receive recipient cannot be issued to. 4# Negative test?  * Non-issuer cannot issue. 4# Negative test?  Preconditions  * Issuer is set.  Zellic 15 Matrixdock    Inputs  * _data: - Control: Any data is permissible.  - Authorization: N/A.  - Impact: Data is only used in event emitting, so no major impact. * _value:  - Control: Any value is acceptable.  - Authorization: N/A.  - Impact: A permissible receiver can be minted any amount of shares. * _tokenHolder_:  - Control: Recipient is non-zero address.  - Authorization: Recipient has receive permissions.  - Impact: Only valid recipients can have shares issued to them.  Function call analysis  * getAmountByShares() - What is controllable? The sharesDelta, controllable by the Issuer.  - If return value controllable, how is it used and howcan it gowrong? Return value is only used in event emitting.  - What happens if it reverts, reenters, or does other unusual control flow? Cannot revert unless totalShares is zero, an improbable scenario and no risk of reentrancy.  * _mintSharesWithCheck() - What is controllable? Issuer can control the tokenHolder and sharesDelta.  - If return value controllable, how is it used and how can it go wrong? N/A. No return value.  - What happens if it reverts, reenters, or does other unusual control flow? Shares are not minted under revert scenario, which can only happen if the receiver does not have receive permissions or is address(0) and there are no external calls to risk a reentrancy.  * getSharesByAmount() - What is controllable? The value passed in.  - If return value controllable, how is it used and howcan it gowrong? Return value is the shared for the tokenHolder, only controllable by a valid issuer.  - What happens if it reverts, reenters, or does other unusual control flow? Shares are not minted under revert scenario, no external calls happening to create a reentrancy threat or unusual control flow.  Zellic 16 Matrixdock    Function: redeemFrom()  Intended behavior  Redeem for another tokenHolder address given that the allowance is sufficient.  Branches and code coverage  Intended branches:  * tokenHolder is redeemed. 4# Test coverage  Negative behavior:  * Non-issuer cannot call this function. # Negative test?  * tokenHolder can have send permissions. 4# Negative test?  * Redeem exceeds allowance. 4# Negative test?  Preconditions  * Total supply is not zero. * Issuer has been set.  Inputs  * _data_: - Control: User has full control.  - Authorization: None.  - Impact: Only used in event emitting, so no large impact. * _value:  - Control: User has full control, granted it is less than or equal to the current allowance.  - Authorization: N/A.  - Impact: Can only redeem for an authorized value. * _tokenHolder:  - Control: User has full control.  - Authorization: Has send permissions and sufficient allowance for the spe- cific msg.sender.  - Impact: Redeeming for a particular tokenHoldermust pass allowance checks.  Zellic 17 Matrixdock    Function call analysis  * burnSharesWithCheck() - What is controllable? tokenHolder and sharesDelta.  - If return value controllable, how is it used and how can it go wrong? N/A. No return value.  - What happens if it reverts, reenters, or does other unusual control flow? Can only revert if send permissions are not valid for that tokenHolder or the amount of shares to burn is greater than the user currently holds. No external calls for reentrancy or unusual control flow.  * getSharesByAmountRoundUp() - What is controllable? The value.  - If return value controllable, how is it used and howcan it gowrong? Return value is controllable to the extent that the tokenHolder actually has that amount of shares or more.  - What happens if it reverts, reenters, or does other unusual control flow? Can never revert - the edge case of a totalSupply of zero is accounted for.  5.2 File: StbtTimelockController  Function: schedule()  Intended behavior  Schedules a function call that can be executed after a preconfigured time delay has passed.  Branches and code coverage  Intended branches:  * Gets the delay for the selector and schedules the function call. 4# Test coverage  Negative behavior:  * The selector is not one of the allowed ones. 4# Negative test?  * Caller is unauthorized. 4# Negative test?  Zellic 18 Matrixdock    Preconditions  * Caller has been authorized. * Selector delay has been configured.  Inputs  * target: - Control: None.  - Authorization: N/A.  - Impact: The contract that will be invoked. * value:  - Control: None.  - Authorization: N/A.  - Impact: The ETH value to be used for the call. * data:  - Control: First four bytes must be an approved selector.  - Authorization: N/A.  - Impact: Calldata provided in the call. * predecessor:  - Control: None.  - Authorization: N/A.  - Impact: Identifier of the invocation that must have been executed first to allow execution of this call.  * salt: - Control: None.  - Authorization: N/A.  - Impact: Salt included in the computation of the ID of the call (hash of all parameters).  5.3 File: UpgradeableSTBT  Function: resetImplementation()  Intended behavior  Changes the address of the implementation contract invoked by the proxy.  Branches and code coverage  Intended branches:  Zellic 19 Matrixdock    * Changes the address of the implementation contract. 4# Test coverage  Negative behavior:  * Caller is unauthorized. 4# Negative test?  Preconditions  * Caller has been authorized.  Inputs  * _impl: - Control: None.  - Authorization: N/A.  - Impact: The address of the new implementation contract.  Zellic 20 Matrixdock    6 Audit Results  At the time of our audit, the code was not deployed to mainnet EVM.  During our audit, we discovered three findings. Of these, two were low risk and one was informational in nature. Matrixdock acknowledged all findings and implemented fixes.  6.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 21 Matrixdock   \tAbout Zellic \tExecutive Summary \tGoals of the Assessment \tNon-Goals and Limitations \tResults  \tIntroduction \tAbout Matrixdock-STBT \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tCustom proxy architecture \tHigh rate of failures in test suite \tLack of sanity checks  \tDiscussion \tLack of two-step ownership transfer \tCommented-out code  \tThreat Model \tFile: STBT \tFile: StbtTimelockController \tFile: UpgradeableSTBT  \tAudit Results \tDisclaimers  "
    }
]