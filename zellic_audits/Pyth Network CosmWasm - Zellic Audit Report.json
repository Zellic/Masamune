[
    {
        "title": "3.1 New governance source may break transfer functionality",
        "target": " CosmWasm",
        "category": " Coding Mistakes",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "The AuthorizeGovernanceDataSourceTransfer action is used to modify the currently authorized governance source (i.e., the caller address that may perform governance actions through this contract). This is done through the execute_governance_instruct ion() function.  Specifically, the AuthorizeGovernanceDataSourceTransfer calls into transfer_governan ce(). This action allows the caller (who is the currently authorized governance source) to pass in a claim VAA that contains information about the new governance source to authorize. This claim VAA is supplied by the new governance source.  To prevent replay attacks, the claim VAA also contains a governance_data_source_ind ex, which needs to be larger than the currently stored index. If it is not, it means that a previous AuthorizeGovernanceDataSourceTransfer message is being replayed, and thus the contract will reject it. This check can be seen in the transfer_governance() function:  fn transfer_governance( next_config: &mut ConfigInfo, current_config: &ConfigInfo, parsed_claim_vaa: &ParsedVAA,  ) -> StdResult<Response> { /) [ ...)) ]  match claim_vaa_instruction.action { RequestGovernanceDataSourceTransfer {  governance_data_source_index, } => {  if current_config.governance_source_index >) governance_data_source_index {  Err(PythContractError:)OldGovernanceMessage)?  Zellic 8 Pyth Data Association    }  /) [ ...)) ] } _ => Err(PythContractError:)InvalidGovernancePayload)?,  } }  The governance_source_index configuration property is a u32, so if the newgovernance source passes in a RequestGovernanceDataSourceTransfer action with the governanc e_data_source_index property set to the maximum u32 value, then any subsequent RequestGovernanceDataSourceTransfer action can never have a higher governance_da ta_source_index property, and thus this action can never be performed again. ",
        "bodyImpact": "We do not consider this a security issue, as the new governance source is considered to be a trusted entity by the protocol already. Wedo however recommend that this be fixed, as the new governance source may accidentally brick this governance source transfer functionality of the contract by passing in the maximum u32 value for the gov ernance_data_source_index. ",
        "bodyRecommendations": "Consider adding a check such that the governance_data_source_index is higher than the currently stored governance_source_index but still within a certain amount. ",
        "remediation": "Pyth Data Association acknowledges the finding and developed a patch for this issue: commit 3e104b41.  Zellic 9 Pyth Data Association  https://github.com/pyth-network/pyth-crosschain/commit/3e104b41844019780bdcc0138b09298c3e537552  "
    },
    {
        "title": "3.2 Open TODOs should be addressed",
        "* Target": " CosmWasm",
        "* Category": " Coding Mistakes",
        "* Likelihood": " N/A ",
        "* Severity": " Informational",
        "* Impact": " Informational ",
        "Description": "During the course of the audit, we came across one open TODO. ",
        "Impact": "The open TODO can be seen on line 610 of contract.rs:  /) TODO: pass these in ",
        "Recommendations": "Open TODOs should be addressed prior to final deployment of the contract. ",
        "Remediation": "Pyth Data Association acknowledges the finding and developed a patch for this issue: commit 3e104b41.  Zellic 10 Pyth Data Association  https://github.com/pyth-network/pyth-crosschain/commit/3e104b41844019780bdcc0138b09298c3e537552   4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Implicit trust placed on parameters passed in by callers  Currently, the CosmWasm contract only accepts VAAs from certain whitelisted con- tracts on Pythnet. A trustless relayer can use signed VAAs from one of these contracts to execute price feed updates or governance instructions. The CosmWasm contract functions on the trust assumption that all data published by the emitter is already vali- dated. The CosmWasm contract itself performs very minimal validation on the VAAs. Therefore, it is possible for the attestation contract to publish messages that could brick the contract in the following way (either due to a compromise or accidentally): Prevent the contract from accepting new price feed updates.  Below, wewill dive a little deeper into how a caller may perform the above action, but it is crucial to note that Pyth Network has communicated with us on this issue already. They have stated that the caller is an attestation contract on Pythnet, and that the attestation contract itself enforces that the arguments passed into the CosmWasm contract calls are valid and cannot brick the contract.  Prevent new price feed updates  In the CosmWasmcontract, the update_price_feed_if_new() function is used to check whether a submitted price feed update is considered new or old. New price feed updates have a publish_time property that is after the publish_time property of the previously accepted price feed update. Only new price feed updates can change the state of the contract, as old price feed updates are rejected.  The publish_time property itself is published by the oracle contract on Pythnet. This property has a type of i64. If the oracle contract publishes themaximum i64 value for publish_time (either due to a bug or a compromise), then any subsequent price feed updates will be rejected, as the publish_time cannot go higher than the maximum i64 value.  Wehave verified that the oracle contract simply uses the Solana clock's current times- tamp for the publish_time property of the newprice feed update. Therefore, this issue is currently mitigated, as the caller has noway tomaliciously control the publish_time property of the submitted price feed update.  However, we find it important to note that the core issue here is that the CosmWasm  Zellic 11 Pyth Data Association    contract itself does not completely validate the arguments that are passed to it. There- fore, if the oracle or the attestation contract are compromised, themitigationsmay not exist anymore, and thus the code will become open to exploitation. This would al- low an attacker to submit a price feed update for a non-sensical price, or brick the CosmWasm contract by providing invalid arguments.  Zellic 12 Pyth Data Association    5 Threat Model  This provides a full threat model description for various functions. As time permitted, we analyzed each function in the smart contract and created a written threat model for some critical functions. A threat model documents a given function's externally controllable inputs and how an attacker could leverage each input to cause harm.  Not all functions in the audit scope may have been modeled. The absence of a threat model in this section does not necessarily suggest that a function is safe.  5.1 Module: contract.rs  Function: execute_governance_instruction()  Used to execute new governance instructions.  Inputs  * vaa - Validation: Checked to be a validWormholemessage. Checked to be from an authorized governance source and chain. Checked to ensure that the governance action is valid. Checked to ensure the data source has supplied the necessary fee.  - Impact: The price feed specified in the VAA is updated, with the new price set to the value in the VAA.  Branches and code coverage (including function calls)  Intended branches  4# Valid UpgradeContract actions are handled successfully. 4# Valid AuthorizeGovernanceDataSourceTransfer actions are handled successfully. 4# Valid SetDataSources actions are handled successfully. 4# Valid SetFee actions are handled successfully. 4# Valid SetValidPeriod actions are handled successfully.  Negative behaviour  4# VAA is rejected if the sequence is lower than the currently stored sequence. 4# VAA is rejected if the emitter is not authorized. 4# VAA is rejected if the emitter chain is not valid.  Zellic 13 Pyth Data Association    # VAA is rejected if it cannot be validated bywormhole (i.e., not enoughwormhole guardian signatures).  4# VAA is rejected if the target chain ID is invalid or not 0. 4# VAA is rejected if deserialization fails for any reason.  # VAA is rejected if an invalid fee is provided for the SetFee action. # VAA is rejected if a RequestGovernanceDataSourceTransfer action is specified as a direct governance instruction.  4# VAA is rejected if the wrong module is specified for an action. 4# VAA is rejected if a bad source index is specified for the RequestGovernanceData  SourceTransfer VAA.  Function: update_price_feeds()  Used to submit new price feed updates.  Inputs  * vaa - Validation: Checked to be a valid wormhole message. Checked to be from an authorized data source. Checked to be from a valid chain. Checked to ensure it's not a stale VAA. Checked to ensure the data source has supplied the necessary fee.  - Impact: The price feed specified in the VAA is updated, with the new price set to the value in the VAA.  Branches and code coverage (including function calls)  Intended branches  4# Valid VAAs lead to a successful price feed update 4# Valid VAAwith a stale or duplicate publish_time property does not cause a price update  Negative behaviour  4# VAA is rejected if it does not contain the necessary fee.  # VAA is rejected if it cannot be validated bywormhole (i.e., not enoughwormhole guardian signatures)  4# VAA is rejected if the emitter is not an authorized data source.  Zellic 14 Pyth Data Association    6 Audit Results  At the time of our audit, the code was not deployed in production.  During our audit, we discovered two findings. Of these, one was low risk and one was a suggestion (informational). Pyth Data Association acknowledged all findings and implemented fixes.  6.1 Disclaimer  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any code added to the project after the audit version of our assessment. Furthermore, because a single assessment can never be considered comprehensive, we always recommend multiple independent assessments paired with a bug bounty program.  For each finding, Zellic provides a recommended solution. All code samples in these recommendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 15 Pyth Data Association   \tAbout Zellic \tExecutive Summary \tGoals of the Assessment \tNon-goals and Limitations \tResults  \tIntroduction \tAbout Pyth Network \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tNew governance source may break transfer functionality \tOpen TODOs should be addressed  \tDiscussion \tImplicit trust placed on parameters passed in by callers  \tThreat Model \tModule: contract.rs  \tAudit Results \tDisclaimer  "
    }
]