[
    {
        "title": "3.1 Griefing opportunity may cause users to lose funds",
        "target": " TokenVault.sol",
        "category": " Business Logic",
        "severity": " High",
        "likelihood": " High ",
        "impact": " High ",
        "bodyDescription": "The calculation of lastMul to account for rebase tokens is incorrect and can lead to devaluation of user funds deposited in the vault.  function updateBalance(uint fnftId, uint incomingDeposit) internal { ...)) if(asset !) address(0)){  currentAmount = IERC20(asset).balanceOf(address(this)); } else {  /) Keep us from zeroing out zero assets currentAmount = lastBal;  } tracker.lastMul = lastBal == 0 ? multiplierPrecision : multiplierPrecision * currentAmount / lastBal; ...)) }  The TokenVault supports rebase tokenswith a dynamic supply to achieve certain eco- nomic goals, such as pegging a token to an asset.  In TokenVault, we can see that the currentAmount is the balance of the TokenVault di- vided by lastBal. This checkswhether the asset has rebased since the last interaction, signaling an increase or decrease in supply.  However, an attacker may transfer ERC20 tokens directly to the vault, inflating curr entAmount, leading to an inflated lastMul, thus emulating a rebase. The deposit with inflated lastMulwould be devalued when lastMul is reset back in the next updateBal ance call.  Zellic 7 Revest Finance    Proof of Concept  A sample proof-of-concept can be found here.  The output is as follows:  Minted one FNFT with id -> 0 Current value of FNFT-0 is 10 Transferred 10 tokens to fake a rebase Minted another FNFT with id -> 1 and 100 depositAmount The value should be 100 But the value is 50  The PoC mints two FNFTs. The first one proceeds as normal. Then, tokens are trans- ferred directly to the vault. This transfer emulates a \"fake\" rebase. As a result, when the second FNFT is minted, it has value 50 rather than the correct value of 100. ",
        "bodyImpact": "The victim minting a FNFT following the fake rebase action permanently loses funds. This poses a very large griefing vector for Revest. ",
        "bodyRecommendations": "Alter the logic to properly account for Rebase Tokens. ",
        "remediation": "The Revest team has fixed this issue by proposing a move to a new and improved TokenVaultV2 design, and by deprecating the handling of rebase tokens in TokenVault.  Zellic 8 Revest Finance  https://gist.github.com/zellic-audit/405e13f7b41372d5b7ca687d9fef855b  "
    },
    {
        "title": "3.2 Certain functions' access controls are unnecessarily lax",
        "target": " TokenVault.sol",
        "category": " Business Logic",
        "severity": " N/A",
        "likelihood": " N/A ",
        "impact": " N/A  description  function createFNFT(uint fnftId, IRevest.FNFTConfig memory fnftConfig, uint quantity, address from) external override {  ...)) }  The function createFNFT should not be external, as all of its' internal function calls are restricted to onlyRevestController. ",
        "bodyImpact": "The issue currently has no security impact, but developers should abide by the prin- ciple of least privilege. Limiting a contract's attack surface is a crucial way to mitigate future risks and reduces the overall likelihood and severity of compromises. ",
        "bodyRecommendations": "Add the onlyRevestControllermodifier to createFNFT to restrict access control. ",
        "remediation": "The issue has been acknowledged by Revest team.  Zellic 9 Revest Finance   "
    },
    {
        "title": "3.3 Batched mints can be rejected by a single recipient",
        "target": " FNFTHandler.sol",
        "category": " Business Logic",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "function mintBatchRec(address[] calldata recipients, uint[] calldata quantities, uint id, uint newSupply, bytes memory data) external override onlyRevestController { supply[id] += newSupply; fnftsCreated += 1; for(uint i = 0; i < quantities.length; i+)) {  _mint(recipients[i], id, quantities[i], data); }  }  A batched mint from mintBatchRec is susceptible to being cancelled by a single recip- ient failing the ERC-1155 AcceptanceCheck ",
        "bodyImpact": "Gas is wasted, and other willing recipients do not receive the FNFTs. The batchedmint execution has to be retried.  Recomendations  * Execute the batched mint in a try catch loop and refund if a mint fails. * If intended, document this behaviour. ",
        "remediation": "The issue has been acknowledged by the Revest team, and a fix is pending.  Zellic 10 Revest Finance   "
    },
    {
        "title": "3.4 Unclear documentation of security risks",
        "* Target": " Project-Wide ",
        "* Category": " Business Logic",
        "* Likelihood": " N/A ",
        "* Severity": " N/A",
        "* Impact": " N/A  There are several areas in the project which should be documented more thoroughly, and some areas have no documentation at all. This is especially true in areas where re-entrancy must be considered, so that future contributors are alerted to potential security hazards.  For example, the function createLock accepts several user-controlled inputs like Ora cle and Asset, but this is not documented anywhere as a possible re-entrancy point. The function withdrawTokenmentions a callback to the output receiver. However, the warning is placed deep in the function body, and with no special emphasis. ",
        "Impact": "Code maturity is critical in high-assurance projects. Undocumented code may result in developer confusion, potentially leading to future bugs, should the code need to be modified later on. In general, lack of documentation impedes auditors and external developers from reading, understanding, and extending the code. The problem will also be carried over if the code is ever forked or re-used. It is imperative to clearly andprominently highlight any potential security hazards, such as re-entrancy, as these hazards could be fatal. ",
        "Recommendations": "Clearly document functionswhere there is the risk of re-entrancy, as well as functions where user-controlled inputs are processed. ",
        "Remediation": "The issue has been acknowledged by the Revest team, and a fix is pending.  Zellic 11 Revest Finance    4 Discussion  In this section, we discussmiscellaneous interesting observations during the audit that are noteworthy and merit some consideration.  Revest's approach to standardizing the storage of ERC20 tokens using FNFTs is novel.  We did a preliminary review of TokenVaultV2, which fixes many issues with the cur- rent TokenVault. Instead of storing assets in a single contract, the new vault leverages the CREATE2 opcode to create per-NFT vaults. This greatly simplifies the internal ac- counting, reducing the attack surface. Overall, this represents a major step towards a stronger security posture. The new vaults are not yet production ready. Some fea- tures, such as migrations, are implemented but not yet fully complete and functional.  In the fnft-migrations branch, we noted that the function _beforeTokenTransfer calls back to IOutputReceiverV4. Interestingly, it does not call back on mint operations due to the check from !) 0, whereas it does call back on burn operations. Additionally, the callback on burn operations is only on applied to the first burn if a batch is burned. While none of this poses an explicit security risk, these inconsistencies impede com- posability. We therefore recommend documenting these side-effects or simplifying them.  In MetadataHandler.sol, several setter functions reponsible for setting the rendering and Token URI (e.g., setTokenURI and setRenderTokenURI) lack access controls. That being said, these functions are not crucial to business logic of the system, except for the frontend.  Test suite maturity  We were unable to verify the test suite in its complete capacity, as there were some errors which prevented a successful run. Notwithstanding that, it seems there has been an extensive effort to test functions. Previous bugs and vulnerabilities are exer- cised in regression tests, such as a PoC for a past exploit.  Re-entrancy points  User control of execution mostly stems from the fact that users exercise full control over asset and pipeToContract in FNFTConfig. Users control ValueLock's oracle and AddressLock's trigger, which can also lead to external, user-controlled calls.  Finally, it is important to keep in mind a callback is called on to whenever an ERC1 155 is minted. Although there are so many re-entrancy points, they're not directly exploitable as every external function is marked nonReentrant.  Zellic 12 Revest Finance    Revest.sol  Revest.sol:{333, 354} - user controls fnftConfig.asset  333: IERC20(fnftConfig.asset).safeTransferFrom(_msgSender(), addressesProvider.getAdmin(), totalERC20Fee);  ...)) 354: IERC20(fnftConfig.asset).safeTransferFrom(_msgSender(), vault,  totalQuantity * fnftConfig.depositAmount);  Revest.sol:136 - user controls trigger  136: IAddressLock(trigger).createLock(fnftId, lockId, arguments);  Revest.sol:{203, 248} - user controls pipeToContract  203: IOutputReceiverV3(config.pipeToContract).handleTimelockExtensions( fnftId, endTime, msg.sender);  ...)) 248: IOutputReceiverV3(fnft.pipeToContract).handleAdditionalDeposit(  fnftId, amount, quantity, msg.sender);  Revest.sol:358-362 - ERC1155 _mint executes callback on to  358: if(!isSingular) { 359: getFNFTHandler().mintBatchRec(recipients, quantities, fnftId,  totalQuantity, ''); 360: } else { 361: getFNFTHandler().mint(recipients[0], fnftId, quantities[0], ''); 362: }  LockManager.sol  LockManager.sol:{60, 158} - user controls lock.valueLock.oracle  60: IOracleDispatch oracle = IOracleDispatch(lock.valueLock.oracle); ...))  Zellic 13 Revest Finance    158: IOracleDispatch oracle = IOracleDispatch(lock.valueLock.oracle);  LockManager.sol:{121, 143} - user controls lock.addressLock  121: IAddressLock(addLock).isUnlockable(fnftId, lockId)) ...)) 143: IAddressLock(lock.addressLock).isUnlockable(fnftId, fnftIdToLockId[  fnftId])  TokenVault.sol  TokenVault.sol:{60, 104, 110, 229} - user controls asset  60: currentAmount = IERC20(asset).balanceOf(address(this)); ...)) 104: IERC20(asset).safeTransfer(user, withdrawAmount); ...)) 110: IERC20(asset).safeTransfer(fnft.pipeToContract, withdrawAmount); ...)) 229: currentAmount = IERC20(fnfts[fnftId].asset).balanceOf(address(this))  ;  TokenVault.sol:{114, 224} - user controls pipeToContract  114: IOutputReceiver(pipeTo).receiveRevestOutput(fnftId, asset, payable( user), quantity);  ...)) 224: return IOutputReceiver(fnfts[fnftId].pipeToContract).getValue((  fnftId));  FNFTHandler.sol (fnft-migration branch)  FNFTHandler.sol:{106, 117} - user controls pipeToContract  106: IOutputReceiverV4(config.pipeToContract).onTransferFNFT(ids[0], operator, from, to, amounts[0], data);  Zellic 14 Revest Finance    ...)) 117: IOutputReceiverV4(config.pipeToContract).onTransferFNFT(ids[i],  operator, from, to, amounts[i], data);  Zellic 15 Revest Finance   \tAbout Zellic \tIntroduction \tAbout Revest Finance \tMethodology \tScope \tProject Overview \tProject Timeline \tDisclaimer  \tExecutive Summary \tDetailed Findings \tGriefing opportunity may cause users to lose funds \tCertain functions' access controls are unnecessarily lax \tBatched mints can be rejected by a single recipient \tUnclear documentation of security risks  \tDiscussion "
    }
]