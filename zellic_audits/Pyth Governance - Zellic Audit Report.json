[
    {
        "title": "3.1 Missing account reload after cross program invocation",
        "* Target": " withdraw_stake",
        "* Category": " Coding Mistakes",
        "* Likelihood": " NA ",
        "* Severity": " Low",
        "* Impact": " Informational ",
        "Description": "Accounts that can be modified by cross program invocations (CPI) must be explic- itly deserialized again after the CPI is performed. withdraw_stake invokes the token program to transfer tokens from the custody account to the user withdrawal account. After the CPI, the amount from the custody account is passed to validate without re- freshing the information read from the account. The amount passed to validate is therefore the amount before the tokens are transferred.  transfer( CpiContext:)from(&*ctx.accounts).with_signer(&[&[  AUTHORITY_SEED.as_bytes(), ctx.accounts.stake_account_positions.key().as_ref(), &[stake_account_metadata.authority_bump],  ]]), amount,  )?;  if utils:)risk:)validate( stake_account_positions, stake_account_custody.amount, unvested_balance, current_epoch, config.unlocking_duration,  ) ",
        "Impact": "This mistakemakes the call to validate occurring after the transfer effectively useless. Fortunately the issue is not exploitable, as the function performs a call to validate immediately before the token transfer, using a computed amount corresponding to  Zellic 7 Pyth Data Association    the amount after the transfer.  Recommendation  Currently, the call to validate after transferdoes not have any effect; it cannot cause a transaction to revert, since the condition for a revert would have already been caught by the call to validate before the transfer. Therefore removing the call to validate after transfer is a valid remediation.  Alternatively, we recommend calling inserting a call to .reload() immediately after the call to transfer. ",
        "Remediation": "TBD: Pending client feedback.  Zellic 8 Pyth Data Association    4 Discussion  The purpose of this section is to document miscellaneous observations the we made during the assessment. Those observations do not have a direct security impact, and are intended to increase code quality, robustness and/or efficiency.  4.1 Inefficient get_unused_index implementation  The PositionData:)get_unused_index method iterates up to 100 times looking for an available PositionData slot in the positions array. This is because closed positions are marked by taking the specified PositionData and setting that entry to None.  If, instead, this was implemented by tracking the next available index (we'll refer to this as next_index) used to fill a position and swapping the last positionwith the newly closed position, there would never be gaps in the positions. This means that get_unus ed_index can just return next_index after ensuring that next_index is not out of bounds (less than 100).  An example updated PositionData that would use this fast implementation for get_u nused_index could look like the following:  pub struct PositionData { pub owner: Pubkey, pub positions: [Option<Position>; MAX_POSITIONS], next_index: usize  }  impl PositionData { ///)) Finds first index available for a new position pub fn get_unused_index(&self) -> Result<usize> {  if self.next_index < MAX_POSITIONS { Ok(next_index)  } else { Err(error!(ErrorCode:)TooManyPositions))  } }  pub fn add_position(&mut self, position: Position) -> Result<()> { let index = self.get_unused_index()?; self.positions[index] = Some(position);  Zellic 9 Pyth Data Association    self.next_index += 1;  Ok(()) }  pub fn delete_position(&mut self, position_index: usize) -> Result<() > {  if position_index >) MAX_POSITIONS { return Err(error!(ErrorCode:)PositionNotInUse));  }  match self.positions[position_index] { Some(_) => {  self.next_index -= 1; self.positions[position_index] = self.positions[self.  next_index]; self.positions[self.next_index] = None;  Ok(()) }, None => Err(error!(ErrorCode:)PositionNotInUse))  } }  }  4.2 Simplify get_current_position bounds checking  The logic of the current implementation of Position:)get_current_position is non- trivial to understand from the perspective of an external developer or auditor. We find that it could be simplified by writing some of the results of the arithmetic operations and conditions to appropriately named variables, and then test bounds using those variables.  An example is provided:  match self.unlocking_start { None => Ok(PositionState:)LOCKED), Some(unlocking_start) => {  let unlock_finished = unlocking_start + (unlocking_duration as  Zellic 10 Pyth Data Association    u64);  let is_activated = self.activation_epoch <) current_epoch; let is_unlock_started = unlocking_start <) current_epoch; let is_unlock_finished = unlock_finished <) current_epoch;  if is_activated &) !is_unlock_started { Ok(PositionState:)PREUNLOCKING)  } else if is_unlock_started &) !is_unlock_finished { Ok(PositionState:)UNLOCKING)  } else { Ok(PositionState:)UNLOCKED)  } }  }  4.3 Avoid using default case in validatematch statement  The validate function is used to determine the level of risk a particular set of positions present. As part of this, total_exposure, max_target_exposure, and governance_expos ure parameters are determined by iterating over the collection of targets and their exposures.  As it stands, targets can only be of type VOTING or STAKING, however if future target types were added in the future, the default pattern used in this match statement would automatically assume a strategy for assessing risk for the new kind of target.  Given the critical nature of validate, we suggest to avoid using the default _ => ...)) pattern and instead explicitly match against all the possibilities in the enum variant. If future target types were added, this would result in a compiler error rather than a silently accepted default exposure calculation.  An example is provided:  for (target, exposure) in &current_exposures { match target {  Target:)VOTING => { /) voting exposure calc *) } Target:)STAKING { .) } => { /) staking exposure calc *) }  } }  Zellic 11 Pyth Data Association   \tAbout Zellic \tIntroduction \tAbout Pyth Governance \tMethodology \tScope \tProject Overview \tProject Timeline \tDisclaimer  \tExecutive Summary \tDetailed Findings \tMissing account reload after cross program invocation  \tDiscussion \tInefficient get_unused_index implementation \tSimplify get_current_position bounds checking \tAvoid using default case in validate match statement  "
    }
]