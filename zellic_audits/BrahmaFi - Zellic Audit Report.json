[
    {
        "title": "3.3 Unwanted deposits and withdrawals can be triggered on behalf of an-"
    },
    {
        "title": "3.4 Some emergency-only functions can be called outside of an emer-"
    },
    {
        "title": "3.6 batchDeposit() and batchWithdraw() leave undistributed, unaccounted"
    },
    {
        "title": "3.1 Deposits can be potentially frontrun and stolen",
        "target": " Vault",
        "category": " Business Logic",
        "severity": " High",
        "likelihood": " Medium ",
        "impact": " High ",
        "bodyDescription": "The shares minted in deposit() are calculated as a ratio of totalVaultFunds() and tot alSupply(). The totalVaultFunds() can be potentially inflated, reducing the amounts of shares minted (even 0).  function deposit(uint256 amountIn, address receiver) ...))  shares = totalSupply() > 0 ? (totalSupply() * amountIn) / totalVaultFunds() : amountIn;  IERC20(wantToken).safeTransferFrom(receiver, address(this), amountIn);  _mint(receiver, shares); }  ...))  function totalVaultFunds() public view returns (uint256) { return  IERC20(wantToken).balanceOf(address(this)) + totalExecutorFunds(); }  By transferring wantToken tokens directly, totalVaultFunds() would be inflated (be- cause of balanceOf()) and as the division result is floored, there could be a case when it would essentially mint 0 shares, causing a loss for the depositing user. If an attacker controls all of the share supply before the deposit, they would be be able to withdraw all the user deposited tokens. ",
        "bodyImpact": "Consider the following attack scenario:  Zellic 7 Brahma    1. The Vault contract is deployed.  2. The governance sets batcherOnlyDeposit to false.  3. The attacker deposits[1] X stakeable tokens and receives X LP tokens.  4. The victim tries to deposit Y stakeable tokens.  5. The attacker frontruns the victim's transaction and transfers[2] X * (Y - 1) + 1 stakeable tokens to the Vault contract.  6. The victim's transaction is executed, and the victim receives 0 LP tokens.[3]  7. The attacker redeems her LP tokens, effectively stealing Y stakeable tokens from the victim.  The foregoing is just an example. Variations of the foregoing attack scenario are pos- sible.  The impact of this finding is mitigated by the fact that the default value of batcherOn lyDeposit is true, which allows the keeper of the Batcher contract to: 1) prevent the attacker from acquiring 100% of the total supply of LP tokens; 2) prevent the attacker from redeeming her LP tokens for stakeable tokens. ",
        "bodyRecommendations": "Consider:  * adding an amountOutMin parameter to the deposit(uint256 amountIn, address receiver) function of the Vault contract;  * adding a require statement that ensures that the deposit() function nevermints 0 or less than amountOutMin LP tokens. ",
        "remediation": "The issue has been acknowledged by Brahma and mitigated in commit 413b9cc.  1 By calling the deposit() function of the Vault contract. 2 By calling the transfer() function of the stakeable token contract. This doesn't increase the total supply of LP tokens. The attacker is always able to call transfer() to directly transfer stakeable tokens to the Vault contract, even when batcherOnlyDeposit is set to true.  3 The formula for calculating the number of LP tokens received: LPTokensReceived = Y * totalSupply OfLPTokens / totalStakeableTokensInVault. Substitute totalSupplyOfLPTokens = X and totalStake ableTokensInVault = X + X * (Y - 1) + 1. The result: LPTokensReceived = Y * X / (X + X * (Y - 1) + 1) = Y * X / (X * Y + 1) = 0.  Zellic 8 Brahma  https://github.com/Brahma-fi/protected_moonshots/pull/37/commits/413b9cc5376f8d6feb7404d12f6b241efeeb300f  "
    },
    {
        "title": "3.2 Centralization risks",
        "target": " Batcher, Vault, ConvexTradeExecutor, PerpTradeExecutor, Harvester, Per pPositionHandlerL2 ",
        "category": " Code Maturity",
        "severity": " High",
        "likelihood": " n/a ",
        "impact": " High ",
        "bodyDescription": "The protocol is heavily centralized. This may be by design due to the the nature of yield aggregators.  The governance can call the sweep() function of the Batcher, Vault, ConvexTradeExecut or, PerpTradeExecutor and Harvester contracts, effectively draining the token balances of the aforementioned contracts.  The strategist can call the sweep() function of the PerpPositionHandlerL2 contract, effectively draining the token balances of the aforementioned contract.  The documentation states that 1-10% of the user-deposited funds staywithin the vault as a buffer and only the yield harvested from Curve and Convex is used for trading on Perpetual Protocol. These invariants are not enforced in any way in the Vault contract itself. The keeper can freely move the user-deposited funds between the vault and its trade executors. It is therefore the responsibility of keepers to enforce the aforemen- tioned invariants ",
        "bodyImpact": "Centralization carries heavy risks, most of which have been outlined in the Description section above. A compromised governance, strategist or a keeper could potentially steal all user funds. ",
        "bodyRecommendations": "* Consider setting up multisig wallets for the governance, the strategist and the keeper.  * Consider enforcing, on the protocol level, the invariants outlined in the docu- mentation.  * Consider following best security practices when handling the private keys of the externally-owned accounts.  Zellic 9 Brahma   ",
        "remediation": "The issue has been acknowledged by the Brahma team. Further steps to securing private keys and usage of a multisig address are being addressed.  Zellic 10 Brahma   "
    },
    {
        "title": "3.3 Unwanted deposits and withdrawals can be triggered on",
        "target": " Vault",
        "category": " Business Logic",
        "severity": " High",
        "likelihood": " Medium ",
        "impact": " High ",
        "bodyDescription": "The deposit() and withdraw() functions of the Vault contract accept 2 arguments:  function deposit(uint256 amountIn, address receiver) public override nonReentrant ensureFeesAreCollected returns (uint256 shares)  { ///)) checks for only batcher deposit onlyBatcher();  ...)) }  function withdraw(uint256 sharesIn, address receiver) public override nonReentrant ensureFeesAreCollected returns (uint256 amountOut)  { ///)) checks for only batcher withdrawal onlyBatcher(); ...))  }  Both of the functions call onlyBatcher() to check and enforce the validity of msg.send er:  function onlyBatcher() internal view { if (batcherOnlyDeposit) {  Zellic 11 Brahma    require(msg.sender =) batcher, \"ONLY_BATCHER\"); }  }  Both of the functions perform no other checks of the validity of msg.sender.  By default (batcherOnlyDeposit = true), only the Batcher contract can deposit and withdraw funds on behalf of the receiver.  The governance can change batcherOnlyDeposit to false. When batcherOnlyDepo sit = false, the deposit() and withdraw() functions perform no msg.sender valid- ity checks whatsoever, allowing any third-party user to trigger deposits[4] and with- drawals[5] on behalf of any receiver. ",
        "bodyImpact": "A third party can trigger unwanted deposits and withdrawals on behalf of another user. This can lead to the users' confusion, lost profits and even potentially to a loss of funds. ",
        "bodyRecommendations": "Consider adding if (!batcherOnlyDeposit) { require(msg.sender =) receiver); } checks to the deposit() and withdraw() functions. ",
        "remediation": "The issue has been fixed in commit 32d30c8.  4 Deposits only work if the receiver has approve()d enough of stakeable tokens. 5 Withdrawals only work if the receiver owns enough of the vault LP tokens.  Zellic 12 Brahma  https://github.com/Brahma-fi/protected_moonshots/pull/37/commits/32d30c8f6e9bf9f907debe75089d349556d2e6ef  "
    },
    {
        "title": "3.4 Some emergency-only functions can be called outside of an",
        "target": " Batcher, Vault, ConvexTradeExecutor, PerpTradeExecutor, Harvester, Per pPositionHandlerL2 ",
        "category": " Business Logic",
        "severity": " Medium",
        "likelihood": " High ",
        "impact": " Medium ",
        "bodyDescription": "The project contains 6 contracts that implement a sweep() function:  * Batcher * Vault * ConvexTradeExecutor (derived from BaseTradeExecutor) * PerpTradeExecutor (derived from BaseTradeExecutor) * Harvester * PerpPositionHandlerL2  The sweep() functions in Batcher, Vault, ConvexTradeExecutor and PerpTradeExecutor are documented as callable only in an emergency state.  Only the sweep() function in Vault implements emergency state checks. The sweep() functions in all other contracts do not. ",
        "bodyImpact": "The emergency-only sweep() functions in Batcher, ConvexTradeExecutor and PerpTra deExecutor can be called outside of an emergency state.  The sweep() functions in Harvester and PerpPositionHandlerL2 can also be called out- side of an emergency state, but they are not documented as callable only in an emer- gency state. ",
        "bodyRecommendations": "Consider adding emergency state checks to the sweep() functions of the Batcher, Con vexTradeExecutor and PerpTradeExecutor contracts.  Consider adding emergency state checks to the sweep() function of the Harvester con- tract and documenting it accordingly.  Consider: 1) adding an emergency state variable to the PerpPositionHandlerL2 con-  Zellic 13 Brahma    tract;[6] 2) adding emergency state checks to the sweep() function of the PerpPositio nHandlerL2 contract; 3) documenting this accordingly. ",
        "remediation": "The issue has been acknowledged by the Brahma team.  6 This step is required because the PerpPositionHandlerL2 is deployed on top of Optimism, an L2 net- work, and therefore (and unlike all the other contracts) cannot access the emergency state variable of the Vault contract in a timely manner.  Zellic 14 Brahma   "
    },
    {
        "title": "3.5 Invalid business logic in Batcher.sol",
        "target": " Batcher.sol",
        "category": " Coding Mistakes",
        "severity": " Medium",
        "likelihood": " n/a ",
        "impact": " Medium ",
        "bodyDescription": "The depositFunds() function of the Batcher contract contains this incorrect require statement at L94:  require( IERC20(vaultInfo.vaultAddress).totalSupply() -  pendingDeposit + pendingWithdrawal + amountIn <) vaultInfo.maxAmount,  \"MAX_LIMIT_EXCEEDED\" );  The correct require statement should contain - pendingWithdrawal + pendingDeposit instead of - pendingDeposit + pendingWithdrawal. ",
        "bodyImpact": "The incorrect require statement fails to properly enforce the \"users can deposit only up to vaultInfo.maxAmount of stakeable tokens\" invariant. ",
        "bodyRecommendations": "Consider changing - pendingDeposit + pendingWithdrawal to - pendingWithdrawal + pendingDeposit in the require statement. ",
        "remediation": "The issue has been mitigated and fixed accordingly in commit 0c2c815.  Zellic 15 Brahma  https://github.com/Brahma-fi/protected_moonshots/pull/37/commits/0c2c815533e99a2055c2dfc2719d0b1e2e521e38  "
    },
    {
        "title": "3.6 batchDeposit() and batchWithdraw() leave undistributed, un-",
        "* Target": " Batcher",
        "* Category": " Code Maturity",
        "* Likelihood": " High ",
        "* Severity": " Low",
        "* Impact": " Low ",
        "Description": "The users of the Batcher contract use the depositFunds() function to deposit stakeable tokens into the batcher. The keeper of the Batcher contract uses the batchDeposit() function to merge several user deposits, send the users' stakeable tokens to the vault, receive LP tokens from the vault and distribute them among the users.  The users of the Batcher contract use the initiateWithdrawal() function to deposit LP tokens into the batcher. The keeper of the Batcher contract uses the batchWithdraw() function to merge several user withdrawals, send the users' LP tokens to the vault, receive stakeable tokens from the vault and distribute them among the users.  Here's how batchDeposit() distributes LP tokens:  for (uint256 i = 0; i < users.length; i++) { uint256 userAmount = depositValues[i];  /) Checks if userAmount is not 0, only then proceed to allocate LP tokens if (userAmount > 0) {  uint256 userShare = (userAmount * (lpTokensReceived)) / (amountToDeposit);  /) Allocating LP tokens to user, can be calimed by the user later by calling claimTokens  userLPTokens[users[i]] = userLPTokens[users[i]] + userShare; ++totalUsersProcessed;  } }  The code that distributes stakeable tokens in the batchWithdraw() function is analo- gous.  Consider the following scenario (using the batchDeposit() function as an example):  Zellic 16 Brahma    1. 3 users deposit 1 USDC each.  2. The batcher exchanges the 3 USDC for 2 LP tokens.  3. Each user receives 0.666666 LP tokens; 0.000002 LP tokens stay within the batcher, as unaccounted dust.  The Batcher contract provides no way to withdraw this dust.  There is an analogous issue in the batchWithdraw() function. ",
        "Impact": "Unaccounted, undistributed and unreclaimable dust accumulates within the Batcher contract. ",
        "Recommendations": "Consider introducing: 1) 2 dust counter variables: one for stakeable tokens and an- other for LP tokens; 2) a dust withdrawal function.[7]  Consider modifying the batchWithdraw() and batchDeposit() functions so that they immediately distribute the dust among some of the users.[8][9]  Consider modifying the sweep() function so that it allows the governance to withdraw partial amounts and use that to withdraw the dust.[10] ",
        "Remediation": "The issue has been acknowledged by the Brahma team.  7 This introduces significant additional gas costs. 8 This introduces additional gas costs. 9 This introduces some (hopefully insignificant) unfairness: some of the users receive slightly more tokens, some receive slightly less.  10 This fails to address centralization risks.  Zellic 17 Brahma    4 Discussion  In this section, we discuss miscellaneous interesting observations discovered during the audit that are noteworthy and merit some consideration.  In PerpPositionHandler: There are no events for opening and closing positions. You might want to consider adding them.  function _openPosition(bytes calldata data) internal override { OpenPositionParams memory openPositionParams = abi.decode(  data, (OpenPositionParams)  ); bytes memory L2calldata = abi.encodeWithSelector(  IPositionHandler.openPosition.selector, openPositionParams._isShort, openPositionParams._amount, openPositionParams._slippage  );  sendMessageToL2( positionHandlerL2Address, L2calldata, openPositionParams._gasLimit  ); }  function _closePosition(bytes calldata data) internal override { ClosePositionParams memory closePositionParams = abi.decode(  data, (ClosePositionParams)  ); bytes memory L2calldata = abi.encodeWithSelector(  IPositionHandler.closePosition.selector, closePositionParams._slippage  ); sendMessageToL2(  positionHandlerL2Address, L2calldata, closePositionParams._gasLimit  Zellic 18 Brahma    ); }  In library/AddArrayLib.sol: The removeAddress() function is documented as return- ing boolean. But it returns nothing.  /** * @notice remove an address from the array * @dev finds the element, swaps it with the last element, and then  deletes it; * returns a boolean whether the element was found and deleted * @param self Storage array containing address type variables * @param element the element to remove from the array *)  function removeAddress(Addresses storage self, address element) internal { for (uint256 i = 0; i < self.size(); i++) {  if (self._items[i] == element) { self._items[i] = self._items[self.size() - 1]; self._items.pop();  } }  }  Here is an interesting observation about how fees are charged: Let's say 1000 USDC are deposited into the protocol. The executors manage to lose 500 USDC. The next deposit or withdrawal happens, no fee is charged. Then the executors manage to gain 100 USDC. The next deposit or withdrawal happens, a fee is charged on that 100-USDC \"gain\". The stakers have effectively lost 400 USDC, but still have to pay a fee.  Lax access control in token withdrawals from Harvester: If someone accidentally de- posits token into it, anyone can take them away. This mitigated by the fact that the default user of Harvester, ConvexTradeExecutor, never leaves tokens in Harvester.  ///)) @notice Harvest the entire swap tokens list, i.e convert them into wantToken  ///)) @dev Pulls all swap token balances from the msg.sender, swaps them into wantToken, and sends back the wantToken balance  function harvest() external override { uint256 crvBalance = crv.balanceOf(address(this));  Zellic 19 Brahma    uint256 cvxBalance = cvx.balanceOf(address(this)); uint256 _3crvBalance = _3crv.balanceOf(address(this));  ...)) /) send token usdc back to vault IERC20(vault.wantToken()).safeTransfer(  msg.sender, IERC20(vault.wantToken()).balanceOf(address(this))  ); }  In ConvexPositionHandler.sol: To protect against any possible Curve manipulations, the usage of virtual price has to be taken into account when calcuating the positio nInWantToken, and for that we need to set the parameter to true. Instead of relying on on-chain AMM's pricing when calculating the value of staked and lp tokens in this case, using the virtual_price offered by Curve does not allow for any possible ma- nipulations that an attacker could ever cause.  ...)) (  uint256 stakedLpBalance, uint256 lpTokenBalance, uint256 usdcBalance  ) = _getTotalBalancesInWantToken(true);  Although the usage of the virtual price was set in the _withdraw() function, we also have to take the minimum of the calculated and actual staked balance, such that no overflow can occur:  function _withdraw(bytes calldata _data) internal override { ...)) uint256 lpTokensToUnstake = _USDCValueInLpToken(  amountToUnstake ) > baseRewardPool.balanceOf(address(this))  ? baseRewardPool.balanceOf(address(this)) : _USDCValueInLpToken(amountToUnstake);  ...))  The protection also applies in the case of calculating the amount of lp tokens to convert into USDC:  Zellic 20 Brahma    function _withdraw(bytes calldata _data) internal override { ...)) uint256 lpTokensToConvert = _USDCValueInLpToken(  usdcValueOfLpTokensToConvert ) > lpToken.balanceOf(address(this))  ? lpToken.balanceOf(address(this)) : _USDCValueInLpToken(usdcValueOfLpTokensToConvert);  ...))  This has been found and properly mitigated by the Brahma team.  Zellic 21 Brahma   \tAbout Zellic \tIntroduction \tAbout Brahma Protected MoonShots \tMethodology \tScope \tProject Overview \tProject Timeline \tDisclaimer  \tExecutive Summary \tDetailed Findings \tDeposits can be potentially frontrun and stolen \tCentralization risks \tUnwanted deposits and withdrawals can be triggered on behalf of another user \tSome emergency-only functions can be called outside of an emergency state \tInvalid business logic in Batcher.sol \tbatchDeposit() and batchWithdraw() leave undistributed, unaccounted dust within the Batcher contract  \tDiscussion "
    }
]