[
    {
        "title": "3.1 Voting can potentially be influenced via restaking",
        "target": " GovernanceV2",
        "category": " Business Logic",
        "severity": " High",
        "likelihood": " Low ",
        "impact": " High ",
        "bodyDescription": "Currently, the magnitude of a vote is determined when it is submitted, based on the total stake of the user that submits the vote.  function submitVote(uint256 _proposalId, Vote _vote) external { /) ...))  address voter = msg.sender;  /) ...))  /) Require voter has non-zero total active stake uint256 voterActiveStake = _calculateAddressActiveStake(voter); require(  voterActiveStake > 0, \"Governance: Voter must be address with non-zero total active  stake.\" );  /) Record vote proposals[_proposalId].votes[voter] = _vote;  /) Record voteMagnitude for voter proposals[_proposalId].voteMagnitudes[voter] = voterActiveStake;  /) ...)) }  function _calculateAddressActiveStake(address _address) private view returns (uint256) {  Zellic 9 Tiki Labs Inc.    ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress); DelegateManager delegateManager = DelegateManager(delegateManagerAddress);  /) Amount directly staked by address, if any, in ServiceProviderFactory (uint256 directDeployerStake,,,,,) = spFactory.getServiceProviderDetails(_address);  /) Amount of pending decreasedStakeRequest for address, if any, in ServiceProviderFactory (uint256 lockedDeployerStake,) = spFactory.getPendingDecreaseStakeRequest(_address); /) active deployer stake = (direct deployer stake - locked deployer stake) uint256 activeDeployerStake = directDeployerStake.sub(lockedDeployerStake);  /) Total amount delegated by address, if any, in DelegateManager uint256 totalDelegatorStake = delegateManager.getTotalDelegatorStake(_address); /) Amount of pending undelegateRequest for address, if any, in DelegateManager (,uint256 lockedDelegatorStake, ) = delegateManager.getPendingUndelegateRequest(_address); /) active delegator stake = (total delegator stake - locked delegator stake) uint256 activeDelegatorStake = totalDelegatorStake.sub(lockedDelegatorStake);  /) activeStake = (activeDeployerStake + activeDelegatorStake) uint256 activeStake = activeDeployerStake.add(activeDelegatorStake);  return activeStake; } ",
        "bodyImpact": "As currently designed, there exists no checks on whether the staking/unstaking lock- ing period is greater than the voting period. Imagine the following scenario:  Zellic 10 Tiki Labs Inc.    1. User A votes \"YES\" on a proposal, then unstakes their share and transfers it to user B.  2. User B stakes, then votes \"YES\" on the same proposal, effectively pumping the voting weight.  3. The process could repeat over and over, as long as the staking/unstaking locking periods fit in the voting period of the proposal. ",
        "bodyRecommendations": "Asdiscussedwith theAudius team,wedetermined that currently the contracts are se- cure, since the staking lockup period is greater than the voting period. This means that despite the fact that theoretically the attack may be possible under specific circum- stances (e.g., locking period of staking is way less than the voting period of proposal), it is impossible to perform it as per the current state of the contracts.  The fix, as proposed by the Audius team, would be to enforce that the unstake period is always greater than the voting period of a proposal. ",
        "remediation": "The issue has been addressed in pull request 4358.  Zellic 11 Tiki Labs Inc.  https://github.com/AudiusProject/audius-protocol/pull/4358  "
    },
    {
        "title": "3.2 Initialize check is missing from some functions",
        "target": " DelegateManager(V2), WormholeClient",
        "category": " Coding Mistakes",
        "severity": " Medium",
        "likelihood": " Medium ",
        "impact": " Medium ",
        "bodyDescription": "The _requireIsInitialized function is available in contracts that inherit the Initializ ableV2 contract and is used to ensure that the child contract has been initialized before performing any other function call. Currently, the cancelRemoveDelegatorRequest in De legateManagerV2 and DelegateManager and transferTokens in WormholeClientmiss this important check. ",
        "bodyImpact": "There are no direct security implications of these instances of omitting the _requireIs Initialized check; however, the functions that should implement it and currently do not would revert. ",
        "bodyRecommendations": "In order to keep a consistent code design and follow best practices over all the con- tracts and their functions, we recommend adding the _requireIsInitialized function call in the two functions mentioned above.  /) DelegateManagerV2.sol, DelegateManager.sol  function cancelRemoveDelegatorRequest(address _serviceProvider, address _delegator) external { _requireIsInitialized();  require( msg.sender =) _serviceProvider |) msg.sender =) governanceAddress, ERROR_ONLY_SP_GOVERNANCE  ); require(  removeDelegatorRequests[_serviceProvider][_delegator] !) 0, \"DelegateManager: No pending request\"  ); /) Reset lockup expiry removeDelegatorRequests[_serviceProvider][_delegator] = 0;  Zellic 12 Tiki Labs Inc.    emit RemoveDelegatorRequestCancelled(_serviceProvider, _delegator); }  /) WormholeClient.sol  function transferTokens( address from, uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint deadline, uint8 v, bytes32 r, bytes32 s  ) public {  _requireIsInitialized(); /) ...)) ",
        "remediation": "The issues have been addressed in pull request 4360.  Zellic 13 Tiki Labs Inc.  https://github.com/AudiusProject/audius-protocol/pull/4360  "
    },
    {
        "title": "3.3 Stake contract address should not change once set",
        "target": " Project-wide ",
        "category": " Business Logic",
        "severity": " Medium",
        "likelihood": " N/A ",
        "impact": " Medium ",
        "bodyDescription": "Currently, the address of the staking contract is stored in a variable called stakingAd dress and can be set via the setStakingAddress function, an action that can only be performed by the governanceAddress. There is no check put in place, however, on whether the stakingAddress has been previously set or not. ",
        "bodyImpact": "Changing the staking address after users have already interactedwith it may result in a significant confusion between the user and the contracts they are supposed to interact with. This is mainly because the accountsmapping, which stores the amounts staked by each user, would not reflect what the user has staked in the initial Staking contract. ",
        "bodyRecommendations": "We strongly recommend that once set, the stakingAddress should not be changeable.  function setStakingAddress(address _stakingAddress) external { _requireIsInitialized();  require(stakingAddress =) address(0), ERROR_STAKING_ALREADY_SET); require(msg.sender =) governanceAddress, ERROR_ONLY_GOVERNANCE); stakingAddress = _stakingAddress; emit StakingAddressUpdated(_stakingAddress);  } ",
        "remediation": "The issues have been addressed in pull request 4362.  Zellic 14 Tiki Labs Inc.  https://github.com/AudiusProject/audius-protocol/pull/4362/commits  "
    },
    {
        "title": "3.4 Unused allowance",
        "target": " ClaimsManager ",
        "category": " Coding Mistakes",
        "severity": " Medium",
        "likelihood": " Medium ",
        "impact": " Medium ",
        "bodyDescription": "The initiateRound functions approves a transfer; however, this allowance is not used by the safeTransfer.  function initiateRound() external { ...)) audiusToken.mint(address(this), recurringCommunityFundingAmount);  /) Approve transfer to community pool address audiusToken.approve(communityPoolAddress, recurringCommunityFundingAmount);  /) Transfer to community pool address ERC20(address(audiusToken)).safeTransfer(communityPoolAddress, recurringCommunityFundingAmount); ...)) ",
        "bodyImpact": "This allows communityPoolAddress to receive twice the allotted claims from the claim sManager. Currently this does not pose an active security issue as EthRewardsManager is only managed by governance; however, if the communityPoolAddress changed, this could result in a more severe vulnerability. ",
        "bodyRecommendations": "Remove the approval, or use safeTransferFrom instead of safeTransfer. ",
        "remediation": "The issue has been addressed in pull request 4359.  Zellic 15 Tiki Labs Inc.  https://github.com/AudiusProject/audius-protocol/pull/4359  "
    },
    {
        "title": "3.5 Inconsistent usage of SafeMath",
        "target": " Project-wide ",
        "category": " Coding Mistakes",
        "severity": " Low",
        "likelihood": " Low ",
        "impact": " Low ",
        "bodyDescription": "Solidity version 0.5 does not have inbuilt overflow or underflow protections. As a consequence of this, SafeMath should be used in areas where overflow or underflow are not the intended behavior, such that the operations revert safely. As an example, underflow protection should be implemented in the function below:  function _removeFromInProgressProposals(uint256 _proposalId) internal { ...)) inProgressProposals[index] = inProgressProposals[inProgressProposals.length - 1]; inProgressProposals.pop();  } ",
        "bodyImpact": "In the areas affected, we only noted reverts; however, future commits could change the behaviour of certain affected functions, leading to more severe vulnerabilities. ",
        "bodyRecommendations": "Use SafeMath wherever overflow is not intended behavior. ",
        "remediation": "The issue has been fixed in pull request 4361.  Zellic 16 Tiki Labs Inc.  https://github.com/AudiusProject/audius-protocol/pull/4361  "
    },
    {
        "title": "3.6 Governance should be transferred in two steps",
        "* Target": " Project-wide ",
        "* Category": " Business Logic",
        "* Likelihood": " N/A ",
        "* Severity": " Informational",
        "* Impact": " N/A ",
        "Description": "The governance plays a fundamental role in the logic of all the contracts. It is important that whenever there might occur a transfer in the governance ownership, this transfer happens in two steps. ",
        "Impact": "Currently, the contracts implement a simple transfer of ownership, which is prone to human error. For this reason, a wrong address may be introduced when using the setGovernanceAddress, thus losing the ownership of the contract.  function setGovernanceAddress(address _governanceAddress) external { _requireIsInitialized();  require(msg.sender =) governanceAddress, ERROR_ONLY_GOVERNANCE); _updateGovernanceAddress(_governanceAddress); emit GovernanceAddressUpdated(_governanceAddress);  }  function _updateGovernanceAddress(address _governanceAddress) private { require(  Governance(_governanceAddress).isGovernanceAddress() =) true, \"ClaimsManager: _governanceAddress is not a valid governance  contract\" ); governanceAddress = _governanceAddress;  } ",
        "Recommendations": "We recommend implementing a two-step governance ownership transfer function, such that any issues thatmay arisewhile transferring the governancewill bemitigated.  Zellic 17 Tiki Labs Inc.    function setGovernanceAddress(address _governanceAddress) external { _requireIsInitialized();  require(msg.sender =) governanceAddress, ERROR_ONLY_GOVERNANCE); toBeGovernanceAddress = _governanceAddress;  }  function acceptGovernanceRole() external { _requireIsInitialized();  require(msg.sender =) toBeGovernanceAddress, ERROR_ONLY_GOVERNANCE); _updateGovernanceAddress(toBeGovernanceAddress); emit GovernanceAddressUpdated(_governanceAddress);  }  function _updateGovernanceAddress(address _governanceAddress) private { require(  Governance(_governanceAddress).isGovernanceAddress() =) true, \"ClaimsManager: _governanceAddress is not a valid governance  contract\" ); governanceAddress = _governanceAddress;  } ",
        "Remediation": "The issue has ben acknowledged by the Tiki Labs team. Upon further investigation, the team has decided not to mitigate it as of the time of writing this report.  Zellic 18 Tiki Labs Inc.    4 Discussion  The purpose of this section is to document miscellaneous observations that we made during the assessment.  4.1 Gas inefficiency can result in prohibitively expensive gas costs  There are several areas in the code that use linear array scans to find an element in- stead of a mapping. In Solidity, a storage read has a static gas cost, and as a conse- quence of this, linear array scans are O(n) and storage reads are very expensive.  As a result of the aforementioned, there are several edgecases in which it becomes prohibitively expensive to carry out certain operations. For example,  * calling delegateStake close to maxDelegators results in gas costs around 1.1 mil- lion gas, due to the _DelegatorExistsForSP check using arrays instead of map- pings.  * calling vetoProposal/evaluateProposalOutcome close to maxInProgressPropos- als also becomes expensive due to the _removeFromInProgressProposals using arrays instead of mappings.  * calling slash in DelegateManager/V2 on a service provider with the default max- imum number of delegators (175) costs approximately 3.4 million gas.  * calling submitProposal in GovernanceV2.solwith close tomaxInProgressPropos- als costs around 800 thousand gas.  Zellic 19 Tiki Labs Inc.    5 Audit Results  At the time of our audit, the code was deployed to mainnet evm.  During our audit, we discovered six findings. Of these, one was of high risk, three of medium risk, one of low risk, and one was a suggestion (informational). Tiki Labs Inc. acknowledged all findings and implemented fixes.  5.1 Disclaimers  This assessment does not provide any warranties about finding all possible issues within its scope; in other words, the evaluation results do not guarantee the absence of any subsequent issues. Zellic, of course, also cannot make guarantees about any additional code added to the assessed project after the audit version of our assess- ment. Furthermore, because a single assessment can never be considered compre- hensive, we always recommendmultiple independent assessments pairedwith a bug bounty program.  For each finding, Zellic provides a recommended solution. All code in these recom- mendations are intended to convey how an issue may be resolved (i.e., the idea), but they may not be tested or functional code.  Finally, the contents of this assessment report are for informational purposes only; do not construe any information in this report as legal, tax, investment, or financial advice. Nothing contained in this report constitutes a solicitation or endorsement of a project by Zellic.  Zellic 20 Tiki Labs Inc.   \tAbout Zellic \tExecutive Summary \tIntroduction \tAbout Audius \tMethodology \tScope \tProject Overview \tProject Timeline  \tDetailed Findings \tVoting can potentially be influenced via restaking \tInitialize check is missing from some functions \tStake contract address should not change once set \tUnused allowance \tInconsistent usage of SafeMath \tGovernance should be transferred in two steps  \tDiscussion \tGas inefficiency can result in prohibitively expensive gas costs  \tAudit Results \tDisclaimers  "
    }
]