[
    {
        "title": "1. Unbounded dictionary records might cause denial of service",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/PegBridge.cdc:86, the records dictionary is used to record existing minting and burning hash identiers as seen in lines 223 and 263. While recording the identiers on-chain are required to prevent replay attacks, this would cause the accounts If the account doesnt hold enough Flow tokens storage capacity to increase limitlessly. proportional to the increased storage capacity, this would cause new transactions to fail as it would put the account over its storage capacity. This issue is also found in contracts/SafeBox.cdc in lines 149 and 185 where it holds the deposit and withdrawal hash identiers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Adding delay transfer should not be allowed when the contract is paused",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/DelayedTransfer.cdc:73, through the executeDelayXfer function is allowed even if the contract is paused. If a catastrophic adding delay transfers event happens, users may continuously get exploited since new delay transfers can still be added while most other functionalities in the contract are inaccessible.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Public keys are not validated when updating or resetting signers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/cBridge.cdc:36, the passed signers public keys are directly set without verifying whether the public keys are valid and conform to the hardcoded signature algorithm which is ECDSA_secp256k1. If an invalid public key or a public key with a dierent signature algorithm is passed, the public key construction in lines 61 to 64 would fail, potentially in the causing the whole cBridge contract updateSigners function in lines 157-172. to be unusable. This issue is also present We consider this to be a minor issue since it can only be caused by the admin or existing signers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Duplicate public keys are not removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/cBridge.cdc:36, the passed signers public keys are directly set without verifying whether they are duplicates or not. If a public key is twice in the signers dictionary, the signature validation can be replayed and potentially allow the signer to hold more signing power than intended. This issue is also present in the updateSigners function from in lines 157-172. We consider this to be a minor issue since it can only be caused by the admin or existing signers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing logic validations during struct initialization might cause temporary denial of service",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/PegBridge.cdc:52-53, the TokenCfg structs minBurn and maxBurn values are not validated. Specically, the minimum burn amount should be validated to be lower than the maximum burn amount while the maximum burn amount should be validated to be higher than the minimum burn amount if the value is not 0. If the values are initialized incorrectly, the burn function would fail in lines 255-258. This issue is also found present in contracts/SafeBox.cdc from lines 49-50. We consider this to be a minor issue since it can only be caused by the admin.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Sensitive resources can easily be shared and not revoked",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "Throughout the codebase, every admin resource has a createXAdmin method (where X is a placeholder for the resource) that allows the existing resource to create a new admin resource in contracts/SafeBox.cdc:114-116). Due to this, admin resource ownership can be provided to multiple accounts, which increases the attack surface. Admin permissions cannot be revoked in the current implementation, which exacerbates the issue. assigned account another (e.g. that can be to",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Misconguration of chain identier values might lead to replay attack possibility",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/PegBridge.cdc:190 and contracts/SafeBox.cdc:122, the chain identier values use the chID argument, which is supplied by the contract instantiator. That argument is concatenated with the contracts address and name in the next line. Since the chain identier is solely based on what value the contract instantiator provides, this will open up a replay attack possibility if the same chain identier is used across multiple deployments, for example on mainnet and testnet. As a result, this would cause the domainPrefix value to be the same across the mainnet and testnet contracts (assuming the same contract address and name), potentially allowing an attacker to replay mint and withdrawal operations in contracts/PegBridge.cdc:213-214 and contracts/SafeBox.cdc:172-173. We consider this issue to be minor since it would only occur if the contract instantiator instantiated the chain identiers incorrectly.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Token receiving capability may not exist, which leads to failure of deposits",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/SafeBox.cdc:151, the capability for receiving funds gets accessed. There is no validation though to ensure self.account has the public capability stored at tokenCfg.vaultPub. As a result, the deposit operation would fail every time for the specic whitelisted token.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Delay threshold check should use greater than or equal symbol",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/PegBridge.cdc:229 and contracts/SafeBox.cdc:191, the if statement check uses the greater than symbol > to determine whether the mint or withdrawal amount is required to be delayed. As any amount that reaches the delay threshold should be delayed, the check should include equality of the amounts.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Non-deterministic iterations can cause consensus failures",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "In several instances of the codebase, iterations are done over maps. Since Go map iterations are non-deterministic, this would cause each validator to produce a dierent app hash, causing a consensus failure and potentially leading to a chain halt. Aected code lines:  x/stakeibc/keeper/unbonding_records.go:101-109 and 147-152  x/stakeibc/keeper/msg_server_rebalance_validators.go:61-63  app/app.go:762 and 849  cmd/strided/root.go:349 This issue has independently been detected by the client during the audit, but it is still present in the commit hash that was used for the audit.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. GetHostZoneFromHostDenom incorrectly uppercases user input, which can be used to mint invalid assets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "x/stakeibc/keeper/host_zone.go:57, In the GetHostZoneFromHostDenom keeper function automatically uppercases the denom argument in line 59 and compares it against the zones denom which is also uppercased in line 61. As the denom argument is mostly supplied by the user, this would cause an unintended validation bypass. the users input msg.HostDenom is passed as the denom argument to For example, in GetHostZoneFromHostDenom x/stakeibc/keeper/msg_server_liquid_stake.go:22 when the user wants to liquid stake. A user can provide a mixed case argument such as \"aToM\" which will be validated as \"ATOM\" due to the automatic uppercase handling. As a result, the user can mint invalid stAssets such as \"staToM, which is incorrect and not accepted when redeeming the staked assets via RedeemStake.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Computationally heavy operations in BeginBlocker may slow down or stop block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "BeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. There are two modules within the scope of this audit where the BeginBlocker or EndBlocker contains unbounded loops that can slow or even halt the chain. Both the interchainquery and epochs modules BeginBlocker or EndBlocker functions: contain resource intensive  x/interchainquery/keeper/abci.go:18  x/epochs/keeper/abci.go:14",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. RegisterHostZone does not validate Bech32Prefix which will lead to staked funds being unredeemable if miscongured",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "function RegisterHostZone in The lacking x/stakeibc/keeper/msg_server_register_host_zone.go:15 validations to ensure the msg.Bech32Prefix is valid and not empty. This functionality is the ValidateBasic function for neither performed in RegisterHostZone nor the eld is empty MsgRegisterHostZone. This MsgRedeemStake will error and block all that specic zone since AccAddressFromBech32 will return an error if hostZone.Bech32Prefix is empty. There is no way to update this eld or a hostzone so any funds that get staked to a hostzone will not be redeemable. is a critical check because if redemptions for is We classify this issue as major instead of critical, since only the admins can cause it. Still, it leads to permanently locked funds, that would require a chain upgrade to be resolved. This issue has independently been detected by the client during the audit, but it is still present in the commit hash that was used for the audit.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. RegisterHostZone does not ensure that HostDenom and IbcDenom are unique which may introduce conicts when returning a hostzone from these values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "function RegisterHostZone in The lacking x/stakeibc/keeper/msg_server_register_host_zone.go:15 validations to ensure the hostzone being registered does not contain duplicate elds with existing hostzones. For example, if msg.HostDenom is the same as an existing hostzone it will eectively invalidate any guarantee that GetHostZoneFromHostDenom provides. GetHostZoneFromHostDenom is used in multiple locations to derive the hostzone from a denom passed in so msg.HostDenom should be unique throughout all hostzones. This is the same case with msg.IbcDenom and GetHostZoneFromIBCDenom. is We classify this issue as major instead of critical, since only the admins can cause it. Still, it leads to permanently locked funds, that would require a chain upgrade to be resolved.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Hard-coded admins increase the potential of unauthorized privileged activity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "In utils/utils.go:17-21, a hardcoded slice ADMINS is dened to represent the addresses that may perform a privileged activity. This is problematic because it creates a the admins is situation where it compromised. For example, one of the addresses is labeled as a testnet address which likely has private keys that have been shared amongst the development team. If this address were to remain in ADMINS it would present a serious risk to Stride as the address could perform multiple privileged actions. to control access and respond if one of is dicult",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. OnTimeoutPacket method not implemented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "In x/stakeibc/module_ibc.go:143, OnTimeoutPacket is not implemented and will panic on any timeout. Operations involving token transfers and burns could potentially lead to a state in which a chain updates the state as based on a successful transfer, but ignores the timeout. This can cause balances that arent synchronized between chains, which can ultimately lead to users not being able to redeem their tokens successfully, or even being able to redeem more than what they should.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Misconguring CurrentEpoch and CurrentEpochStartHeight during genesis initialization would cause overow issues",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "In x/epochs/types/genesis.go:51, the genesis initialization parameters are validated via the Validate function to prevent incorrect congurations. There are no validations that verify the value of CurrentEpoch and CurrentEpochStartHeight to not be negative values though. it would cause unintended consequences when converting them into unsigned values using the uint64 function. For example, the epoch number in x/stakeibc/keeper/hooks.go:36 would underow and become a tremendously large value, which is incorrect. they are congured as negative values, If",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Participation rewards congured can be negative",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "In x/mint/types/params.go:177-191, there is no validation that makes sure the participation rewards decimal value is not a negative value. The participation rewards value is used in x/mint/keeper/keeper.go:163 when distributing the minted coins via the DistributeMintedCoin keeper function. A miscongured participation rewards value would cause the execution to panic in x/mint/keeper/keeper.go:135 due to a negative coin amount. As a result, hooks that should be executed after an epoch ends (see x/mint/keeper/hooks.go:16) would keep failing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Queried voting power when executing proposals is set to current height, allowing anyone to execute proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:365, the callers voting power is queried at the current block height to ensure they are one of the DAOs members. This implies that any caller can execute a proposal by staking a small number of funds after the proposal ends and calling the execute_execute function.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Users might be unable to claim NFTs if they unstake a large amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-cw721-staked/src/contract.rs:143-158, the execute_unstake function attempts to validate the outstanding NFT claims is not greater than or equal to the congured max claim amount. Since the outstanding claims do not include the current amount of token_ids to claim, a user can unstake a large number of NFTs in one transaction as long the old outstanding claim amount is smaller than the max claim limit. As result, users would be unable to claim NFTs using the execute_claim_nfts function due to an out-of-gas error. a Please see the test_bypass_max_claims test case to reproduce the issue. We classify this issue as major since it can only happen when the user unstakes a large number of NFTs in one transaction, but the user is not able to recover these NFTs.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Duplicate input elds would be overwritten",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/dao-core/src/contract.rs:76-78, the InitialItem key from the msg.initial_items vector is being saved into the ITEMS storage state. If there were duplicate keys, the previous ones would get overwritten, causing only the last value to be stored. the that, in Besides duplicate contracts/dao-core/src/contract.rs:497-500 addresses in the to_add vector. Consequently, the previous SubDao charter would get overwritten, causing the SUBDAO_LIST only to save the last charter value. execute_update_sub_daos_list function does lter not",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. DumpState query does not paginate proposal modules which can result in out of gas errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "the query_dump_state In contracts/dao-core/src/contract.rs:665-668, function attempts to fetch all proposal modules stored in the PROPOSAL_MODULES storage. The query will fail if too many stored proposal modules exist due to an out-of-gas error. As a result, the active_proposal_module_count and total_proposal_module_count values cannot be queried, representing the number of active proposal modules and the total number of proposal modules. We classify this issue as minor since only the contract admin can instantiate proposal modules.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Admin can replay migration to overwrite dao_uri and re-enable proposal modules when contract is paused",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "The migrate handler in contracts/dao-core/src/contract.rs:831-879 does not ensure the current contract version is lower than the version to migrate to. This is problematic because the contract admin can abuse the migration function to modify the dao_uri and re-enable all proposal modules when the contract is paused, allowing them to partially bypass the contract state. Ideally, a paused contract should not have its storage state mutable until the expiration ends. Please see the test_replay_migrate test case to reproduce the issue. We classify this issue as minor since only the contract admin can perform migrations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. DAO has inuence over voting results",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:285, the voters voting power is determined by querying the congured DAO contract. Since the total voting power is queried and stored as seen in line 207, updating the DAO contract to a dierent address might cause incorrect voting results. Suppose the voter staked more tokens in the newly updated DAO contract. This would cause the execute_vote function to query the new voting power and compare it against the old total voting power, leading to an incorrect voting result. Besides that, the DAO can also update the only_members_execute boolean which aects the execute_execute function. Suppose the only_members_execute conguration is set to true during the proposal creation time and set to false after the proposal passes. The DAO members would expect only they can execute the proposal. However, since the only_members_execute value is loaded from the conguration directly, anyone can execute the proposal. close Lastly, the close_proposal_on_execution_failure boolean can be updated by the DAO to the execute to close_proposal_on_execution_failure was set to false and the message to execute fails in line 409. The DAO can interfere by updating the conguration to true and re-execute the function, causing the proposal status to be set to ExecutionFailed. automatically. proposals Suppose that fail This issue is also present contract. in the contracts/proposal/dao-proposal-single We classify this issue as minor since only the DAO contract can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Too many proposal modules stored would cause migration to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "contracts/dao-core/src/contract.rs:837-859 and In contracts/proposal/dao-proposal-single/src/contract.rs:879-919, all stored proposal modules are collected without pagination. This is problematic because if too many proposal modules were stored, the migrate function would fail due to an out-of-gas error, preventing the admin from migrating the contract to the latest version. We classify this issue as minor since only the contract admin can instantiate proposal modules.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Setting AbsoluteCount to zero will always show proposals as active",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-cw20-staked/src/contract.rs:307-315, no validation ensures the count value inside the ActiveThreshold::AbsoluteCount enum is greater than zero. In comparison, the ActiveThreshold::Percentage enum is validated to ensure the percent value is greater than zero in line 213. If the count value is congured to zero, the query_is_active query will always return true despite the total amount of tokens staked being zero. We classify this issue as minor since only the DAO contract can congure active thresholds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. A counterparty in escrow can always withdraw, resulting in temporary grief",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In the contracts/external/cw-token-swap/src/contract.rs:197, execute_withdraw function allows a counterparty to withdraw the funds deposited in the contract. Since the escrow completion depends on the payment of the last counterparty, whoever deposited rst can always withdraw their (such as frontrunning the other user), causing the transaction never to be completed. funds from the contract",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Active threshold could be set for a very small percentage",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-cw20-staked/src/contract.rs:214-229, the execute_update_active_threshold function allows a DAO to set an active threshold. It validates that the threshold is between 0 to 100, meaning the DAO can set it to a very small percentage (e.g. 2%). This may allow malicious participants to execute an attack on the DAO.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. All implemented electoral schemes are Condorcet-incomplete",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "Both intended electoral systems, ranked choice voting and single-member plurality voting, do not satisfy the Condorcet winner criterion. This means both cannot ensure that the Condorcet winner (the alternative that would win a two-option vote against each of the other options in a plurality vote) wins the vote. A mechanism to pick a Condorcet winner is desirable because it is considered prudent decision-making, particularly regarding budgetary decisions.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Migration does not update the latest contract name and version",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-staking-denom-staked/src/contract.rs:1 16-118, the migrate handler does not automatically set the latest contract name and version. If the admin migrates the contract, the query_info query in line 100 will still show the old contract name and version.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Users can unstake zero amounts of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-native-staked/src/contract.rs:180-197, the execute_unstake function does not validate the amount to be 0. Since the amount is not validated, a valid claim is still created for the user, causing the outstanding claims to be increased in line 182. Consequently, the current outstanding claims will be growing and compared to the MAX_CLAIMS amount, potentially causing the user to be unable to unstake tokens as intended.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Permissionless proposal creation policy could result in spam proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/proposal/dao-proposal-single/src/contract.rs:164-166, the DAO contract allows dierent congurations. If the pre-propose module is unset and the proposal_creation_policy is set to Anyone, malicious users can spam the DAO with unnecessary proposals.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. dao-voting-staking-denom-staked allows malicious actors to manipulate voting power",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-staking-denom-staked/src/contract.rs:5 8-98, the query_voting_power_at_height and query_total_power_at_height function return the current voting power irrespective of the provided height argument. Normally, the total voting power of a proposal is snapshotted at a specic block height using the TotalPowerAtHeight VotingPowerAtHeight is queried with the proposals start height to get the users staked amount. Since both queries return the height based on the users argument value, this means the user-staked amount can be manipulated. contract. When voting votes, user the in a If the user changed their staked amount (e.g., staked more tokens), their staking power would be changed. However, the total power saved in the proposal still uses the old total staking power value. Due to this, users who vote will be queried with current voting power, not snapshotted power. This allows malicious users to manipulate their voting weight. For example, imagine Alice and Bob each have 500 voting power at block height 10. The stored total voting power in the proposal will be 1000 (500+500=1000). At block height 20, Alice stakes more tokens causing her voting power to be 1200. Alice then votes, and the contract queries Alices voting power at block height 10. However, due to the issue described above, her voting power returned will be 1200 instead of 500, causing Alice to have a higher voting power than intended. We classify this issue as minor because ICS chains do not have a staking module, preventing the usage of this contract. However, this would be an issue if the contract is deployed on a chain with a staking module.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Non-token might be miscongured as a staking asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/staking/cw20-stake/src/contract.rs:79, any address could be congured as a staking token, even contracts do not implement token interfaces. We classify this issue as informational because the contract miscongure an incorrect CW20 token address, even if implemented. instantiator can always the recommendation below is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Ranked choice voting not implemented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "The documentation mentions the implementation of ranked choice voting, but it is not implemented.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Multiple choice voting is prone to social engineering attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "Multiple choice voting systems, where users can specify options as free text, are prone to social engineering attacks, as users can try to confuse users with odd alternatives. This is particularly problematic in conjunction with Condorcet-incomplete voting schemes, where minority alternatives can win. Users can try to submit duplicate \"No\"-options or introduce \"quasi-No\"-options and split up the \"No\"-voters into smaller subsets such that they do not get a share of votes to prevent any of the other options. An oversimplied example is illustrated below. Question: What kind of horse should we buy? Answers:  Black  Red  We should discuss this again next year  None of the above While both We should discuss this again next year and None of the above are the equivalent of We shouldn't buy a horse now, one of the options Black or Red might win even if the majority of voters do not want to buy a horse, because the No-votes are split.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Iterations over hooks might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In packages/cw-hooks/src/lib.rs:34-52, gas. iterations over hooks might run out of We classify this issue as informational as only admins can cause it and it is recoverable.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Cache hit counters can be used to crash nodes and halt a chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The VM implementation contains a cache to eciently load smart contract instances that are pinned or used repeatedly. For analytical purposes, that cache increments the hit counters hits_pinned_memory_cache, in packages/vm/src/cache.rs whenever an instance is read from it. These hit counters are incremented using integer addition, which can cause panics in the case of integer overows. hits_memory_cache, hits_fs_cache and An attacker can exploit this issue to crash a node and possibly even halt the chain, for example by repeatedly querying an instance from a CosmWasm smart contract. The hit counters currently use the u32 type. To cause an overow, almost 4.3 billion cash hits are required. While this is a huge number, the counters are only reset upon node restart, so there is a real possibility for long-running nodes to suer from such an overow panic. Moreover, an attacker does not need to cause almost 4.3 billion cache hits within one transaction  such an attack can be executed across many blocks. Query nodes are even easier to target, since they can be queried repeatedly with little resource cost by the attacker.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Gas counting in vm backend does not correctly add externally used gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The packages/vm/src/backend.rs:56: GasInfos add_assign method incorrectly sets in externally_used: self.externally_used + other.cost This implies that the externally_used gas of other is not accounted for. An attacker could call external them, potentially blocking block production. functions without paying gas for We classify this issue as minor since the add_assign method is currently only used in test code.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Overow in gas counting might halt block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "and add_asign process_gas_info The in packages/vm/src/backend.rs:55, 56, packages/vm/src/environment.rs:341 and 352, which could potentially allow an attacker to halt block production of the underlying blockchain if the CosmWasm vm is compiled without overflow-checks enabled for the release prole. functions overow might",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Ed25519 batch verication is not benchmarked, might run out of memory and halt block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The do_ed25519_batch_verify function imposes limits to the number of messages, signatures, and public keys per batch in packages/vm/src/imports.rs:291-305, but there currently exists no benchmarking code in the codebase that veries that these limits are reasonable. production of the underlying blockchain might halt. If the limits are too high, validators might run out of memory, and block",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Unlimited WASM table size may be exploited to crash the node",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "of the states memory While in packages/vm/src/wasm_backend/store.rs:82, tables are not. The WebAssembly (see spec https://webassembly.github.io/spec/core/syntax/types.html#table-types). If such a growth of a table can be triggered from smart contracts, it may exhaust the resources of the underlying node, potentially crashing it and stopping block production. can grow indenitely instances are not limited, limited tables they that is if We tried to write a WASM module using WAT that adds new elements in a loop, but apparently, elem sections need to be at the module top level, so adding more entries to the table would linearly increase the WASM blob size. While we have not been able to exploit this issue by adding elements to the table, there may be other ways to make the table size grow indenitely.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Unbounded iteration over WASM imports may slow down block production or stop the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The check_wasm_imports function collects all into a BTreeSet in packages/vm/src/compatibility.rs:152, which uses an unbounded iteration over the imports. This may be exploited to slow down block production, possibly even stopping the chain. the wasm contract imports of We classify this issue as minor since there is an implicit limit to the number of imports through the WASM size limit.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Compilation of wasm code does not specify memory limit and might halt block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The save_wasm function calls compile in packages/vm/src/cache.rs:154 without setting a memory limit. This could cause the node to run out of memory, potentially halting block production of the underlying blockchain if no mechanism for recovery is implemented. We only consider this to be an informational issue since the underlying blockchain should reject wasm code that is too big, and the singlepass compiler used will execute in linear time, preventing JIT-bombs.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Attribute keys starting with underscores lead to panics, causing smart contract runtime errors in debug mode",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "for attributes constructor The in packages/std/src/results/events.rs:71 if an attribute key starts with an underscore _. This will lead to runtime errors for smart contract projects that have code paths that were not extensively tested. An example could be a DeFi protocol that adds an attribute with an underscore under certain conditions, for example an emergency withdrawal. The panic would prevent the emergency withdrawal, putting user funds at risk. debug panics mode in The check in the constructor does also not guarantee that a key does not start with an underscore, since library users could simply manually push attributes with any key. We classify this issue as informational since it only aects code compiled with debug assertions.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Overows could occur if library users do not enable overow-checks, panics abort execution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "In several places in the codebase, overows are not handled explicitly. This is not a security concern as long as overow-checks are enabled for the release prole, but there is a risk that a library user does not enable overow-checks. Additionally, overow-checks cause overows to panic, which is less user friendly than an overow error message that allows unwinding the operation. A panic in WebAssembly always aborts the execution and does not unwind. Instances of potential overows are: - - - - The nextval function in packages/storage/src/sequence.rs:19. The plus_seconds, plus_nanos, minus_seconds, and minus_nanos methods in packages/std/src/timestamp.rs:37-57. The isqrt method in packages/std/src/math/isqrt.rs:28. The sqrt_with_precision method in packages/std/src/math/decimal.rs:181 and in packages/std/src/math/decimal256.rs:194.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Math method types are inconsistent and not exhaustive",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "In packages/std/src/math, several math types are implemented, such as Decimal, Decimal256, Uint64, Uint128, or Uint256. The API of those math types contains several inconsistencies and functionality diverges or is partially not implemented, even between similar types such as Uint64 and Uint128. These dierences can lead to a decrease in the development experience when using math types of the std package. Examples of these discrepancies are: - - - - - - - - - - - - - - - - Sub and Mul are implemented for Uint128, Uint256 and Uint512, but missing for Uint64. SubAssign and MulAssign are implemented for Uint128, Uint256 and Uint512, but missing for Uint64. wrapping_add, wrapping_sub, wrapping_mul, and wrapping_pow are implemented for Uint64 and Uint128, but missing for Uint256 and Uint512. Mul is implemented for Decimal and Decimal256, but Div is not implemented for them. For Decimal and Decimal256, Div returns a Decimal, while DivAssign returns a Uint128 multily_ratio and full_mul is implemented for Uint64, Uint128 and Uint256 but missing for Uint512. pow is implemented for Uint256 but missing for Uint64, Uint128 and Uint512. checked_pow is implemented for Uint128 and Uint256 but missing for Uint64 and Uint512. saturating_pow is implemented for Uint128, but missing for Uint256 and Uint512. check_div_euclid is implemented for Uint64 and Uint128, but missing for Uint256 and Uint512. Shl is implemented for Uint256, but missing for Uint64, Uint128 and Uint512. ShrAssign is implemented for Uint64, Uint128, Uint256 and Uint512, but ShlAssign is missing for all unsigned integers. checked_shl is implemented for Uint256, but missing for Uint64, Uint128 and Uint512. Inconsistent with other methods, TryFrom<Uint128> for Uint64 is dened in packages/std/src/math/uint128.rs, and not in packages/std/src/math/uint64.rs. Inconsistent with other methods, TryFrom<Uint512> for Uint128 is dened in packages/std/src/math/uint512.rs, and not in packages/std/src/math/uint128.rs. The from_str function results in an error on an empty string in packages/std/src/math/uint256.rs, but not in packages/std/src/math/uint128.rs and packages/std/src/math/uint512.rs, which is inconsistent. - - - - - - - - Inconsistent with other methods, TryFrom<Uint256> for Uint128 is dened in packages/std/src/math/uint256.rs, and not in packages/std/src/math/uint128.rs. In packages/std/src/math/uint128.rs:215, StdError::generic_err is used for parsing errors instead of StdError::parse_err. The new function in packages/std/src/math/uint512.rs is not marked as const, which it is in packages/std/src/math/uint256.rs. Some methods return StdError::generic_err(\"Error parsing whole\") while others return an ParseErr. Some methods return StdError::generic_err(format!(\"Serializing QueryRequest: {}\", serialize_err)) instead of StdError::serialize_err. The wasmer::SerializeError and wasmer::DeserializeError is wrongly transformed into a VmError::cache_err instead of a VmError::serialize_err in packages/vm/src/errors/vm_error.rs:325 and 331. The VmError::cache_err in packages/vm/src/checksum.rs:47 should be a VmError::conversion_err. Some methods use expect, while others use unwrap, which results in panics without messages explaining what went wrong.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Several dependencies are outdated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "There are several dependencies that are not used in their latest version. Some of them contain security vulnerabilities. A subset that might introduce vulnerabilities is: - - - - chrono contains a potential segfault, currently used in version 0.4.19, no safe upgrade available. time contains a potential segfault, currently used in version 0.1.43, upgrade to >= 0.2.23 instead. ed25519-zebra is currently used in version 2.2.0, available in 3.0.0 rand_core is currently used in version 0.5.1 in package cosmwasm-crypto, available in 0.6.3",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Unaudited cryptography library",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The library implementation of ECDSA in crate k256 is unaudited and comes with the following warning in its documentation: Security Warning The elliptic curve arithmetic contained in this crate has never been independently audited! crate This has been designed with the goal of ensuring that secret-dependent operations are performed in constant time (using the subtle crate and constant-time formulas). However, it has not been thoroughly assessed to ensure that generated assembly is constant time on common CPU architectures. USE AT YOUR OWN RISK!",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Ed25519 batch verication succeeds for empty data, which may not be obvious to library users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The ed25519_batch_verify function in packages/crypto/src/ed25519.rs:65 succeeds if provided with an empty collection of messages, signatures, and public keys. This behavior is correctly documented in line 64. Still, an unsuspecting library user might not be aware of this implementation, which could lead to bugs in dependent codebases.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Consuming gas after performing Ed25519 batch verication is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "do_ed25519_batch_verify The in packages/vm/src/imports.rs:312-318 after executing the batch verication in line 311. This is inecient since the verication can be skipped if the gas limit is hit. consumes currently function gas",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Missing overow checks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The workspace manifest Cargo.toml as well as the following packages do not enable overflow-checks for the release prole: packages/profiler/Cargo.toml - packages/crypto/Cargo.toml - packages/derive/Cargo.toml - - packages/schema/Cargo.toml - packages/std/Cargo.toml - packages/storage/Cargo.toml - packages/vm/Cargo.toml",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attackers can block pool tuning by voting on many dummy pools",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "In the contracts/generator_controller/src/contract.rs:398-416, tune_pools function attempts to process each pools votes in an unbounded iteration. In the case that the number of pools is too many, the execution may run out of gas and fail. An attacker can use this loop to block pool tuning: 1. The attacker creates many addresses and stakes xASTRO for minimum voting power",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Finally, the tune_pools function will attempt to process all child contracts added by the attacker in line 399. The attack will succeed when the function fails due to an out-of-gas error. As a result, the TunePools message will always fail, preventing majority-voted pools from receiving allocation points. Please refer to the test_jam_tuning test case for the attack scenario mentioned above. Recommendation We recommend implementing a whitelist of liquidity pool contracts that can be voted on. Status: Resolved 2. Proposals message order not enforced on IBC execution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. KickBlacklistedVoters missing from documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "In contracts/generator_controller/src/contract.rs:89-108, controllers ExecuteMsg::KickBlacklistedVoters is not dened. documented. messages execution are the generator the However,",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Unnecessary CW20 sender validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "contracts/assembly/src/contract.rs:170, In contracts receive_cw20 function performs address validation for the sender parameter of the CW20 message. This is unnecessary because the sender parameter comes from info.sender, validated by Cosmos SDK already. assembly the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Unnecessary conversion to lowercase in addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "The contracts within scope used the addr_validate_to_lower helper function to sanitize addresses. Since CosmWasm 1.0.0, the addr_validate utility also validates address capitalization, hence making it redundant to perform this check manually.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Misleading error messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "In contracts/assembly/src/contract.rs:680 and 683, the assembly contracts update_ibc_proposal_status function returns Unauthorized errors even for cases that are not related to authorization, which can be misleading for users. This is the case if the proposal.status does not match one of the expected ones in line 671. This also happens if config.ibc_controller is congured to None, the if statement in line 669 will result in an Unauthorized error.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Message verication does not require the supermajority of signers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Asteroid Bridge/2024-06-17 Audit Report - Asteroid Bridge v1.0.pdf",
        "body": "contracts/neutron-bridge/src/helpers.rs:16-78, In function verify_signatures takes a message and a list of signatures and veries that at least a number equal to signer_threshold of public keys in the SIGNERS map has signed the message. the The signer_threshold is part of the config and can be set by the protocol owner, with the the be more MIN_SIGNER_THRESHOLD. requirement dened being than only two, by as to However, since the threshold does not depend on the number of registered signers, and no majority or supermajority is required for the verication of signatures, is vulnerable to attacks by malicious coalitions of signers which could execute arbitrary messages or front-run honest signers. the protocol Additionally, there is no misbehavior mechanism to allow shermen and third parties to report and punish signers acting maliciously. We classify this issue as minor since signers are assumed to be trusted.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Signers can replay transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Asteroid Bridge/2024-06-17 Audit Report - Asteroid Bridge v1.0.pdf",
        "body": "contracts/neutron-bridge/src/execute.rs:316, In the bridge_receive function protects against transaction replay by verifying if the provided transaction_hash is already recorded in the HANDLED_TRANSACTIONS map. However, supplied directly by the signers. the transaction_hash is not computed during the contract execution but Consequently, signers, who are responsible for signing an attestation that includes the hash, could potentially submit any arbitrary string as the hash allowing the same transaction to be executed multiple times. We classify this issue as minor since signers are assumed to be trusted.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Unbounded nested iterations in verify_signature could run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Asteroid Bridge/2024-06-17 Audit Report - Asteroid Bridge v1.0.pdf",
        "body": "contracts/neutron-bridge/src/helpers.rs:16-78, function In verify_signatures takes a message and a list of signatures and veries that the message has been signed by at least a threshold of registered signers. the This is achieved by performing a nested iteration: First through all the public keys in the SIGNERS map, and then through all the decoded_signatures. Inside the loops, each combination of key and signature is veried although only a fraction of these combinations is expected to match. The number of iterations is additionally increased by checking the signatures already veried, against other keys. Consequently, if the number of signers and signatures is large, the execution will run out of gas since there is no upper limit enforced in the contract. We are reporting this issue with minor severity since the cardinality of signers is alterable only by the owner and is expected to be small.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Misconguration of the bridge chain ID could result in stuck tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Asteroid Bridge/2024-06-17 Audit Report - Asteroid Bridge v1.0.pdf",
        "body": "In the contracts/neutron-bridge/src/execute.rs:635-642, the protocol owner can update config.bridge_chain_id to an arbitrary chain ID. While this allows the chain ID to be congured in case of chain upgrades that alter the ID, misconguration of the bridge_chain_id could lead to tokens that are unable to be bridged back to the Cosmos Hub as well as the necessity to synchronize signers and the contract to establish consistency between the contract cong and signers attestations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Disabling tokens can lead to inconsistent contract state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Asteroid Bridge/2024-06-17 Audit Report - Asteroid Bridge v1.0.pdf",
        "body": "In contracts/neutron-bridge/src/execute.rs:417-418, the bridge_send function checks whether the ticker and corresponding TokenFactory denomination are disabled. However, when disabling a token, the disable_token function only disables one of them provided as a ticker. Consequently, the user can pass the TokenFactory denomination to the bridge_send function to bypass the aforementioned check. We are reporting this issue as minor because the disable_token function can only be executed by the owner, and the owner can execute it twice on both denoms to mitigate the problem.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. IBC fee excess is accumulated and stuck in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Asteroid Bridge/2024-06-17 Audit Report - Asteroid Bridge v1.0.pdf",
        "body": "contracts/neutron-bridge/src/execute.src:450-457, In the total_fee variable is calculated by summing up various standard IBC fees: ack_fee, recv_fee and timeout_fee. The amount of fee tokens passed by the user is validated to be greater than the total_fee variable. However, Neutrons IBC transfer does not typically utilize all the fees  some are refunded when not used. When a relayer submits an Ack message for a particular packet, the module sends the specied amount of ack_fee to the relayer from the escrow address and returns the specied timeout_fee to the contract that issued the original Transfer message. In case the relayer submits a Timeout message, things go the other way around: the relayer is refunded with timeout_fee and the contract gets ack_fee back. Consequently, the IBC fee excess will be accumulated and stuck in the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Missing validation for public key name identier",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Asteroid Bridge/2024-06-17 Audit Report - Asteroid Bridge v1.0.pdf",
        "body": "contracts/neutron-bridge/src/execute.rs:494-541, In function allows the owner to register a new signer. the add_signer The function ensures that the public_key provided is unique and not already registered, however, it does not verify whether the provided name is already associated with a dierent registered key. Consequently, multiple public keys could be associated with the same name, confusion or misuse in signer identication. leading to",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of validation for the IBC channel",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Asteroid Bridge/2024-06-17 Audit Report - Asteroid Bridge v1.0.pdf",
        "body": "contracts/neutron-bridge/src/contract.rs:42-49, In function stores the provided bridge_ibc_channel. the instantiate However, no validation ensures that the bridge_ibc_channel identier is a registered and active channel. Consequently, this lack of validation could lead to the acceptance of an invalid or closed channel, which would not allow the forwarding of IBC messages to the Cosmos Hub.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Unbounded iteration allows attackers to attack validators, slowing down or even halting block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "App modules implement logic that needs to iterate through slices in order to nd a specic element with the selected ID. This has the consequence of having unbounded loops with an asymptotic cost of O(n). This is even worse when a loop is done over arrays that contain other arrays. In this case, the asymptotic cost is O(n^2) or O(n^3). Unbounded loops can allow two dierent types of attack: 1. Validator slashing A malicious actor could spam a transaction, that he knows performs an unbounded loop, to a particular node trying to force it to be not able to compute the transaction before the BroadcastTxCommit timeout. This can prevent that node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. the NewTxTimeoutHeightDecorator will discard all messages with an Also, elapsed heightTimeout. This could be used in a particular event in order to manipulate it. As the validator was not able to sign the block, it implies that this event is decreasing its sign ratio. That could lead the validator to be slashed. 2. Stop or slow down the block production A malicious actor could spam the previous message to a set of validators. If a signicant number of them hit the timeout and halt simultaneously, block production may stop or slow down. Iterations vulnerable to this attack are:  x/asset/keeper/app.go:117  x/asset/keeper/app.go:262  x/asset/keeper/asset.go:160  x/collector/keeper/collector.go:104  x/locker/keeper/msg_server.go:238  x/locker/keeper/msg_server.go:310  x/vault/keeper/vault.go:47  x/vault/keeper/vault.go:57  x/vault/keeper/vault.go:347  x/vault/keeper/vault.go:421  x/vault/keeper/vault.go:441  x/rewards/keeper/keeper.go:86  x/rewards/keeper/keeper.go:156",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Transaction gas price is not related to execution complexity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "In app/ante.go:47, NewConsumeGasForTxSizeDecorator is calculating the gas cost of a transaction. taking care of This decorator computes the gas cost of a transaction by multiplying the size of transaction in bytes with TxSizeCostPerByte. the Even if this is a good heuristic to estimate the potential transaction cost, thats not enough. Transaction cost should be proportional to the computational complexity of its execution. For instance, a transaction that has an asymptotic complexity of O(1) and that is not doing I/O operations, should not have the same cost as another one that has a O(n) complexity and is executing extensive I/O operations. Messages vulnerable to this attack are:  MsgCreateLockerRequest in x/locker/handler.go:18  MsgCreateRequest in x/vault/handler.go:18  MsgWithdrawRequest in x/vault/handler.go:24  MsgDrawRequest in x/vault/handler.go:27  MsgRepayRequest in x/vault/handler.go:30  MsgCloseRequest in x/vault/handler.go:33  MsgCreateGauge in x/rewards/handler.go:19  MsgMintNewTokensRequest in x/tokenmint/handler.go:21  MsgDepositESM in x/esm/handler.go:18 The current lack of accounting for execution complexity can make it aordable for an attacker to perform DoS spamming with expensive messages that have a small payload.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Vault ID collisions could lead to the loss, tampering or overwriting of existing vault data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The MsgCreate function, in x/vault/keeper/msg_server.go, creates a new CDP or vault with a unique vaultId. In line 148, an ID is assigned to the newVault, concatenating the apps Shortname and the ExtendedPairs vault counter. However, this formula can lead to collisions, either accidental or intentional, which could cause a loss or tampering of existing vault data. Example:  ShortName1=Test1 and updatedCounter=1, with resulting vaultId=Test11  ShortName2=Test and updatedCounter=11, with resulting vaultId=Test11 It should be noted that this also aects stable vault IDs.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Locker ID collisions could lead to the loss, tampering or overwriting of existing locker data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "Similarly to the vault ID collision issue, lockerIds are subject to collision due to the concatenation formula that is used to derive new userLocker.lockerId, in the function MsgCreateLocker, in x/locker/keeper/msg_server.go:85. This could lead to the loss or overwriting of key locker data, either accidentally or intentionally.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Users cannot redeem their collateral assets regardless of the ESM status",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "in if condition x/esm/keeper/msg_server.go:71, The the MsgCollateralRedemption handler, will never be executed, which blocks users from redeeming their collateral assets regardless of the ESM status. If the esmStatus.status is True, the condition in line 68 will be True, returning the ErrCoolOffPeriodRemains. And if the esmStatus.status is False, the condition in line 71 will be also False, preventing the execution of the if-block which contains the collateral redemption logic. in",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. GetPriceForAsset returns price of 2000000 for assets when the market is not found",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The GetPriceForAsset function in x/market/keeper/oracle.go:175 returns a static price of 2000000 for assets when the market is not found. This is problematic because instead of returning an error for this case, the GetPriceForAsset will silently return an incorrect value for the asset's price. This can have unintended consequences that may allow attackers to economically exploit the protocol.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Computationally heavy operations in BeginBlocker and EndBlocker may slow down or stop block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "BeginBlocker and EndBlocker are functions that are executed at the start/end of each block, even if there are no transactions. To not have a negative impact on block production, it should have a light and constant computational footprint. In fact, it is wise to be cautious about adding too much computational weight at the start of each block, as blocks arrive at approximately seven-second intervals. Also, it should be a good practice to make the BeginBlocker/EndBlocker execution independent, or at least with a sub-linear dependency, from the amount of data stored on-chain. A huge workload may slow down the block production, Tendermints proposal timeout is surpassed. in the worst case so much that The codebase implements multiple BeginBlocker/EndBlocker functions that are computationally heavy and/or depend on on-chain state:  x/auction/abci.go:8  x/esm/abci.go:10  x/market/abci.go:10  x/rewards/abci.go:11  x/liquidity/abci.go:12  x/liquidity/abci.go:29",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Multi-purpose BeginBlocker error handling may disable critical functionality if an error is raised",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The BeginBlocker functions in:  x/rewards/abci.go:11  x/auction/abci.go:8 use an error-handling approach that stops the execution if one of the functions returns an error. This means that if the rst function execution returns an error, the other ones that come after that one will not be executed. While this can be a good approach for interdependent functions, it is not a good design in cases when functions are independent. in example, For DebtActivator and DutchActivator are independent SurplusActivator will deny the execution of the other two. the Rewards modules BeginBlocker, SurplusActivator in functions but an error",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "9. Error handling during slices loop terminates the execution without executing the logic for all items",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "In  x/auction/keeper/surplus.go:27,  x/auction/keeper/surplus.go:33,  x/auction/keeper/dutch.go:56,  x/auction/keeper/dutch_lend.go:49,  x/auction/keeper/debt.go:26,  x/auction/keeper/debt.go:32, and  x/esm/abci.go:32-35, error handling logic during a slice iteration terminates the execution without iterating through all items. This behavior could lead to incoherent functionality if the loop triggers an error in the initial slice items. information inside the slice and to disabled This has the consequence of not checking all the items after the faulty one, and in the worst case, if the error is raised in the 0 position of the slice, to not check at all liquidation for collateralized positions.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "10. An attacker could send MsgRemoveMarketForAssetRequest messages every 20 blocks in order to make the Market module unusable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "x/market/handler.go:25, In MsgRemoveMarketForAssetRequest. anyone is allowed to send a An attacker could use this transaction to delete all the Market instances saved in the store, making the Market module unusable. The transaction can be executed every 20 blocks, which is the oracle data fetch interval.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "11. Permissionless Rewards module Whitelisting process allows attackers to manipulate the Asset Whitelist and App Vault Whitelist",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "x/rewards/handler.go, WhitelistAsset, and RemoveWhitelistAppIdVault RemoveWhitelistAsset, are messages In, WhitelistAppIdVault permissionless. Since those messages are responsible for the management of the Asset Whitelist and App Vault Whitelist, they should be executable only from privileged users or through governance. In fact, having those messages executable by anyone makes the Whitelist process ineective and exposes an attack surface. For example a malicious actor could delete all Assets from the AssetWhitelist and make the module unusable, or could add an Asset to the whitelist that should not be allowed.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "12. Gas is not consumed if the transaction returns an error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The ConsumeGas function calls in lines:  x/liquidity/keeper/pool.go:182,  x/liquidity/keeper/pool.go:255,  x/liquidity/keeper/pool.go:313,  x/liquidity/keeper/swap.go:123,  x/liquidity/keeper/swap.go:233,  x/liquidity/keeper/swap.go:292,  x/liquidity/keeper/swap.go:362,  x/liquidity/keeper/rewards.go:312, and  x/liquidity/keeper/rewards.go:424, are located at the end of the transaction execution and are not called if an error occurs. Consequently, a malicious actor is allowed to spam transactions that trigger an error in the middle of the execution without being charged of the dened gas fees.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "13. CosmWasm - State query binding can perform a GRPC call to an arbitrary URL",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "In contracts/governance/src/msg.rs:12, target eld of type String. the InstantiateMsg is expecting a This eld is then used by the contract to perform State queries in  contracts/governance/src/contract.rs:128 and  contracts/governance/src/contract.rs:442 in order to get the state at a particular BlockHeight. The CosmWasm State query binding is resolved in the Cosmos SDK side by the QueryPlugin in app/wasm/query_plugin.go:54 and handled by the QueryState function in x/locker/keeper/locker.go:328. In x/locker/keeper/locker.go:335 the target eld propagated from the CosmWasm contract is used as URL to create a GRPC insecure connection. This mechanism is intended to work to call a Full Node but it has some possible problems:  Every target URL is allowed so an attacker could use this to perform a DOS or to create a botnet using chain nodes to perform a DDOS.  Exposed GRPC port could be not the same in dierent nodes as it can be congured by see https://docs.cosmos.network/master/core/grpc_rest.html#grpc-server, or it could be behind a Load Balancer, Reverse Proxy, Docker network, Ingress, etc. operators, node  It is performing the call with grpc.WithInsecure() so there is no trust to the It MITM GRPC attacks https://grpc.io/docs/guides/auth/#with-server-authentication-ssltls contacted. allows server like  Congurations and security enforcements rules through iptables or ufw or similar softwares on machines where the chain node is hosted could block this type of calls That means that a CosmWasm contract is able to make the chain node perform a GRPC insecure connection to an arbitrary URL by simply using the State query binding.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "14. Error raised in BeginBlocker could lead to state corruption",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The modules that raise errors in BeginBlocker which could lead to a state where partial state changes are performed but other intended state changes are not committed. This function logs errors but has no control over the state and no mechanism to revert partial updates. This implies that if an error is raised in the middle of an execution ow, the execution will stop and log the error, but no action will be taken in order to revert state updates that have been done leading to state corruption.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "15. CosmWasm - Deposited funds of other denom will be stuck in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "In contracts/governance/src/contract.rs:534 in the execute_deposit message, if the voter has made a deposit to the given proposal before, the Coins that were previously added in the rst deposit will be increased with the amount of the new deposit. However, there is no check that info.funds.len == 1, so dierent denoms will be accepted and not accounted for, resulting in these funds remaining permanently stuck in the contract. The same issue occurs if a user only sends one coin of a certain denom to an existing proposal with a dierent denom. After the proposal has passed or been rejected, the execute_refund function in 570 will not return the coins whose denoms are dierent from the original deposit.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "16. UpdateAssetsRecords is not enforcing a unique Denom for an Asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The UpdateAssetsRecords function in x/asset/keeper/asset.go:189 is not consistently handling the Denom to Id mapping when updating an Asset with a new Denom eld. asset.Denom Since the with DeleteAssetForDenom(ctx, asset.Denom) in line 205 is not deleting the mapping with the old Denom but is instead trying to delete the mapping with the new one. msg.Denom updated 203, line in is This has the consequences of not having a unique Denom for an Asset Id in the Denom to Id mapping.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "17. AddAppRecords may overwrite existing app name entries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The AddAppRecords function in x/asset/keeper/app.go:208-210 incorrectly performs an app name validation that will allow for the existing app Id to be overwritten in In line 208 the HasAppForName check is passed msg.ShortName SetAppForName. rather than msg.Name, so in eect the name is not checked currently.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "18. MsgAddWhiteListedAsset allow any caller to add an asset id to a lockers whitelist",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The MsgAddWhiteListedAsset function in x/locker/keeper/msg_server.go:327 does not include any permission checks to ensure only authorized addresses are able to add asset Ids to the lockers whitelist. Currently any user may send this message to add asset Ids to the lockers whitelist.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "19. AddAppRecords may accept invalid GenesisToken array",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The AddAppRecords function in x/asset/keeper/app.go:203 does not perform proper validation on the GenesisToken array before setting it in the store. At a minimum, the function should conrm that the slice of MintGenesisToken does not contain duplicates, and that the Recipient is a valid address. stored invalid An AddAssetInAppRecords CheckIfAssetIsAddedToAppMapping function. GenesisToken messages array during could break the the execution handling of of the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Double refunds on excess oer assets allow draining pools",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-29 Audit Report - Astroport on Osmosis v1.0.pdf",
        "body": "In the contracts/pair_concentrated/src/sudo.rs:238-249, swap_exact_amount_out function computes the excess oer asset amount and refunds it to the sender. This is problematic because the cosmwasmpool module also refunds the excess amount to the sender, resulting in double refunds. an Consequently, call SwapExactAmountOut on the poolmanager module with large token_in_max_amount and low token_out values to drain funds from the pool, causing a loss of funds for liquidity providers. can repeatedly attacker",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attackers can swap any token and drain funds from pools",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-29 Audit Report - Astroport on Osmosis v1.0.pdf",
        "body": "In the contracts/pair_concentrated/src/sudo.rs:78, swap_exact_amount_out function does not validate that token_in_denom is one of the pool assets. This is problematic because users can provide fake or low-value native tokens to swap for other assets in the pool. Consequently, an attacker can create and mint a large amount of a token factory denom and call SwapExactAmountOut on the poolmanager module to trade any token for pool assets, causing a loss of funds for liquidity providers.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Internal price is updated regardless of trade size",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-29 Audit Report - Astroport on Osmosis v1.0.pdf",
        "body": "In the contracts/pair_concentrated/src/sudo.rs:165-171, swap_exact_amount_out function updates the internal oracle price with the last price. This is problematic because the price update should only occur if the trade sizes are small, as seen in contracts/pair_concentrated/src/contract.rs:733-745. Consequently, SwapExactAmountOut sudo call, causing an incorrect price to be used. oracle price will be updated incorrectly during a internal the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. msg.whitelist_code_id eld is ignored during instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-29 Audit Report - Astroport on Osmosis v1.0.pdf",
        "body": "In contracts/factory/src/contract.rs:59, the whitelist_code_id is set to zero. This is problematic because msg.whitelist_code_id is provided in the InstantiateMsg struct, but not used. Consequently, specifying msg.whitelist_code_id during contract instantiation will not be reected in the whitelist_code_id conguration. We classify this issue as informational because the whitelist_code_id conguration is not used across the protocol.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Updated conguration values are not emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-29 Audit Report - Astroport on Osmosis v1.0.pdf",
        "body": "execute_update_config The in contracts/factory/src/contract.rs:215 emits only the action attribute. For state-changing functions, It is best practice to emit events and attributes to support o-chain event listeners and blockchain indexers. function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. General code improvements",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-29 Audit Report - Astroport on Osmosis v1.0.pdf",
        "body": "In several instances of the codebase, the code quality and readability can be improved:  osmosis-test-tube is outdated and contains dependencies with known vulnerabilities (RUSTSEC-2022-0093, RUSTSEC-2023-0052). Consider updating the package to the latest version.  The auto_stake in not arguments the contracts/pair_concentrated/src/contract.rs:297, in receiver contracts/pair_concentrated/src/contract.rs:510. Consider removing them. removed and removed arguments comment comment was was not  contracts/pair_concentrated/src/contract.rs:601-604 and contracts/factory/src/contract.rs:179-184 lack documentation for the the functions in the codebase. arguments. This is inconsistent with the rest of Consider adding them.  The error in contracts/factory/src/error.rs:44 is not used. Consider removing it.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. before_swap_check validation is not implemented in SwapExactAmountOut and reverse simulation queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-29 Audit Report - Astroport on Osmosis v1.0.pdf",
        "body": "In and contracts/pair_concentrated/src/contract.rs:693 contracts/pair_concentrated/src/queries.rs:228, the before_swap_check function is implemented in the internal_swap (when SwapExactAmountIn is called) and query_simulation functions. The before_swap_check function is used to ensure the oer amount is not zero, and the pool assets are not empty. the validation is not However, swap_exact_amount_out query_reverse_simulation functions. (when implemented on the reverse swap mechanism in the and SwapExactAmountOut called) is Implementing the validation helps to save gas fees as the error will be triggered rst during a reverse simulation query, preventing users from initiating a failed transaction.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Schedules start and end point timestamps are not validated to be in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "assert_vesting_schedules The contracts/tokenomics/vesting/src/contract.rs:240-254 ensures that scheduled end point is past the start point. function dened in the However, there is no check in place that enforces the start point or the endpoint to be in the future. This implies that there may be vesting schedules that instantly vest, which will probably only happen unintentionally. We classify this issue as minor because only the contract owner can create vesting schedules.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Unbounded iteration through schedules can permanently inhibit the execution of transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "and In contracts/tokenomics/vesting/src/contract.rs:324 contracts/tokenomics/vesting/src/contract.rs:386, unbounded loops are used to iterate through all the registered schedules. Consequently, if the cardinality of registered schedules is signicant, the execution could run out of gas and revert the transaction. Additionally, since there is no way to remove completed schedules, this could permanently inhibit the execution of transactions. We classify this issue as minor because only the contract owner can create vesting schedules.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Miscongured zero max spread causes swaps to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "In contracts/tokenomics/maker/src/contract.rs:59, the max_spread value is not validated to be greater than zero. If the max_spread value is miscongured as zero, all swaps will fail due to a MaxSlippageAssertion contract error. This issue is also present during the conguration update phase in line 698. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Governance fee percentage is not set to 100 if the staking contract address is not set",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "The documentation in packages/astroport/src/maker.rs:17 states if staking_contract is set to None, the governance_percent value should be equal to 100. that However, this behavior is not enforced during contract instantiation and the UpdateConfig message handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. No events are emitted upon successful contract instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "In contracts/tokenomics/maker/src/contract.rs:97, no custom events or attributes are emitted upon successful contract instantiation. This prevents o-chain listeners from indexing parameters congured by the contract instantiator.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Incomplete parameter documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "In several instances of the codebase, function comments do not include documentation of all parameters:  contracts/tokenomics/maker/src/contract.rs:106-112 and 614-624  second_receiver_params is not included.  contracts/tokenomics/vesting/src/contract.rs:61-75  The RegisterVestingAccounts, WithdrawFromActiveSchedule, ProposeNewOwner, DropOwnershipProposal, and ClaimOwnership messages are not documented.  contracts/tokenomics/vesting/src/contract.rs:369  The account, receiver, and amount parameters are not documented.  contracts/tokenomics/maker/src/utils.rs:132-143  The bridge_token and factory_contract parameters are not documented.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Outstanding TODO comment",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "In contracts/tokenomics/maker/src/utils.rs:21, a TODO comment is present that questions whether the swap simulation should adjust according to the token's precision. This indicates that the codebase might not be ready for production.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Zero amount withdrawal will always fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "contracts/tokenomics/vesting/src/contract.rs:375, the In withdraw_from_active_schedule function does not validate that to withdraw is not zero. As Cosmos SDK prevents zero-amount native token transfers, specifying zero withdrawal amounts will fail. The resulting transfer error might confuse users. the amount",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Redundant check in calc_schedule_unlocked_amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "calc_schedule_unlocked_amount in The the contracts/tokenomics/vesting/src/contract.rs:349 checks whether time_period is not zero. This check is redundant as new schedules are validated through function enforces the assert_vesting_schedules function in line 246. This implying that end_point.time to be strictly greater time_period is always greater than zero. than start_point.time, function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Users can steal all LP tokens from the Apollo static strategy",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "the apollo-static strategy Since in contracts/strategies/apollo-static/src/strategy.rs:38 will query the LP token balance of the contract including all previous deposits by other users. All of these deposits will be assigned to the caller, and the user can then extract all that value by immediately withdrawing/zapping out. LP tokens, the query simply holds",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Registering fees in the factory contract does not update the strategys extension reward index",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "the handle_register_fee in In the contracts/apollo-factory/src/contract.rs:586, strategys EXTENSION_TOTAL_COLLECTED_FEES extension_reward_index eld is not adjusted. That leads to an inconsistent state. Additionally, update_strategy is called, even though there were no changes to the strategy. updated, function are but the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Users are unable to collect rewards after withdrawing/zapping out of strategy",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "In contracts/apollo-factory/src/contract.rs:816, strategies are skipped if a user has no active deposits in a strategy. Users might have withdrawn/zapped out of a strategy, and hence have zero shares, but they might not have collected rewards yet. Such users are unable to collect the condition described above. the rewards from the strategies because of",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Strategies that start with paused rewards can never receive any rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "The rewards_paused eld cannot be updated in the handle_update_strategy function in contracts/apollo-factory/src/contract.rs:516. That means that a strategy that started without rewards can never receive any rewards.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Current block height not used in reward calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "the reward In packages/apollo-protocol/src/vault/vaults/anchor.rs:119, info from Anchor deposits is queried. That query uses a block_height of None, which will cause Anchor to return the latest stored values, rather than recalculating them at the current block height.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. APR calculation might panic if staked liquidity value is zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "When contracts/strategies/apollo-static/src/strategy.rs:493, might panic when staked_liquidity_value is 0. calculating APR the in contract the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Price queries do not ensure that price base is not outdated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "In multiple price queries from the oracle contract, the time since last_updated_quote is asserted to be greater than the strategys price_age_limit. However, the time since last_updated_base is not asserted  which might lead to usage of outdated prices. Instances of that issue are found in:  contracts/strategies/apollo-static/src/strategy.rs:433  contracts/strategies/apollo-static/src/strategy.rs:467  contracts/strategies/apollo-static/src/strategy.rs:481  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:409  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:465  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:479  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:423",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Queried reward and LP token prices in Apollo autocompound strategy are not checked to not be outdated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "the querying When in packages/apollo-protocol/src/strategy/strategies/autocompound/stra tegy.rs:309-325 and in 369-385, a check should be added to ensure these prices are not outdated. reward_token_price lp_token_price and",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Anchor reward rate calculation does not account for overlaps in distribution schedule",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "rate reward in The not packages/apollo-protocol/src/vault/vaults/anchor.rs:147 account for overlaps in the distribution schedule coming from the anchor cong. The Anchor factory does allow overlaps. In the event of an overlap, the reward rate would be o. calculation rewards Anchor does for",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Attackers can drain funds from the pair by providing worthless assets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-30 Audit Report - Astroport Transmuter Pool v1.0.pdf",
        "body": "In contracts/pair_transmuter/src/contract.rs:312-315, the swap function accepts the offer_asset provided by the caller in return for other assets available in the pool. However, no validation ensures that the provided asset is one of the pools supported assets in config.pair_info.asset_infos. This is problematic because attackers can oer any worthless native token in exchange for valuable assets in the pool, thereby proting from the price dierence and causing a loss of funds for liquidity providers. CW20 the assert_sent_native_token_balance function is designed not to Additionally, (see sent validate packages/astroport/src/asset.rs:248). In contrast to the previous scenario, where an attacker supplies worthless native tokens, the attacker can simply specify CW20 tokens as the offer_asset to steal assets directly from the contract without providing actual funds. tokens user the by Please see the test_drain_pool test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Pools can support an arbitrary number of assets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-30 Audit Report - Astroport Transmuter Pool v1.0.pdf",
        "body": "In contracts/pair_transmuter/src/contract.rs:39-42, the instantiate function ensures that at least two assets are submitted. However, no maximum amount of assets is enforced. If the pool is congured to hold a very large number of assets, subsequent code that iterates over all assets leads to high gas expenses and potentially an out-of-gas error. An example of an iteration can be found in contracts/pair_transmuter/src/contract.rs:184 when withdrawing liquidity. We classify this issue as minor because it can only caused by the contract owner, which is a privileged address. Additionally, the contract is still usable even though the asset iteration fails due to an out-of-gas error. It allows users to provide single-sided liquidity, perform imbalance withdrawals, and explicitly specify the return asset during swaps. Since these features do not require iteration over all pool assets, an out-of-gas error will not occur.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Withdrawing liquidity from a pool with an empty side can lead to panic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-30 Audit Report - Astroport Transmuter Pool v1.0.pdf",
        "body": "withdraw_liquidity The in contracts/pair_transmuter/src/contract.rs:165-255 allows users to burn their liquidity pool tokens to withdraw the underlying pool liquidity. function dened However, if the assets vector is not explicitly specied and one of the pools assets is empty, the get_share_in_assets function will in contracts/pair_transmuter/src/utils.rs:50. include a zero-amount return asset Consequently, the transaction will fail when calling BankMsg::Send because Cosmos SDK does not allow zero-amount native token transfers. Please see the test_unbalanced_withdraw test case to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Liquidity pool token contracts use the same symbol",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-30 Audit Report - Astroport Transmuter Pool v1.0.pdf",
        "body": "In contracts/pair_transmuter/src/contract.rs:68, is hardcoded to uLP when instantiating a CW20 liquidity pool token contract. This causes all pair contracts to have the same symbol in their liquidity pool token contract. the token symbol",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Unused elds in ProvideLiquidity and Swap messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-30 Audit Report - Astroport Transmuter Pool v1.0.pdf",
        "body": "ProvideLiquidity The in packages/astroport/src/pair.rs:42-51 as a struct with the following elds: assets, slippage_tolerance, auto_stake, and receiver. message dened is However, the slippage_tolerance and auto_stake parameters are disregarded and unused in contracts/pair_transmuter/src/contract.rs:123-125. Similarly, the Swap message is dened in packages/astroport/src/pair.rs:53-59 as a struct with the following elds: offer_asset, ask_asset_info, belief_price, max_spread, and to. However, the belief_price and max_spread parameters are disregarded and unused in contracts/pair_transmuter/src/contract.rs:126-131. Unused parameters mislead users and decrease the user experience. For example, liquidity providers expect tokens to be auto-staked when specifying the auto_stake parameter as true, which is incorrect because the eld is ignored. liquidity pool their",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Pair conguration override due to custom pair types",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-30 Audit Report - Astroport Transmuter Pool v1.0.pdf",
        "body": "the migrate_pair_configs In contracts/factory/src/migration.rs:45-46, function migrates the OldPairType::Concentrated and OldPairType::Custom state into PairType::Custom. a scenario Assume and OldPairType::Custom(\"concentrated\") is specied. In this case, the concentrated pair type conguration will be overwritten by the custom pair type conguration, as seen in lines 61 and 63. OldPairType::Concentrated where We classify this issue as informational because it can only be caused by the contract owner, which is a privileged role.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Migrated pair congurations can be instantiated by anyone",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-30 Audit Report - Astroport Transmuter Pool v1.0.pdf",
        "body": "contracts/factory/src/migration.rs:56, the migrate_pair_configs In function migrates previous pair congurations and sets the permissioned eld to false. This allows existing pair congurations to be instantiated by anyone, as seen in contracts/factory/src/contract.rs:295-297. We classify this issue as informational because it is a best practice to set default values as restrictive as possible, adhering to the principle of least privilege.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Revoked collateral assets re-activated during contract migration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "When performing the migration of the collateral oracle contract, legacy collateral information is migrated to the new storage layout. During this process, every collateral is marked with in is_revoked: false The contracts/mirror_collateral_oracle/src/migration.rs:112. consequence of this is that collateral that had previously been revoked is now re-activated.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Incorrect specication of migration poll voting period",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "During the creation of a new migration poll, the voting period is dened incorrectly as that of the default poll cong in line contracts/mirror_gov/src/contract.rs:329. The impact of this would be the reduction in the voting period of migration polls, allowing less time for them to pass with a potential danger of a distributed poll deposit by the protocol.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Collateral oracles cong migration is not performed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "in The contracts/mirror_collateral_oracle/src/migration.rs:49 is unused. This implies that after the migration, the cong will not be decoded properly. migrate_config function",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Admin rights cannot be revoked when claimed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "of current implementation in contract The contracts/admin_manager/src/contract.rs allows an account to claim the contracts admin rights. Upon claiming the admin rights the account becomes the target contracts admin and has the right to perform contract migrations. There is no mechanism to revoke any claimed admin rights. If the third partys account is lost or compromised, there is no way for the protocol to recover, and all locked funds might be lost forever. manager admin the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Users can grief creation of admin polls",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "Creation of a new admin poll is not possible if the number of existing polls is greater or equal to MAX_POLLS_IN_PROGRESS in contracts/mirror_gov/src/contract.rs:335. The impact of which is prevention of new admin polls being created through continuous adding of new polls. We consider this issue to be minor since it is mitigated by the fact that deposits for failed polls are distributed to stakers. Despite this cost, there is still a possibility of attackers trying to grief admin actions.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Admin and migration poll conguration can be updated in a default poll",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "If the governance cong is updated through a poll, the default_poll_config will be used in contracts/mirror_gov/src/contract.rs:435. This could enable a whale or colluding token holders to alter the conguration of the admin and migration poll types through a default poll. Subsequently, such malicious actors could execute migration and admin actions with signicantly lower poll requirements to extract value from Mirror. We consider this issue minor since the community could observe such polls and intervene by rejecting them.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Admin manager can be updated in governance contract with default poll cong",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "all admin While contracts/mirror_gov/src/contract.rs:373, an update of the admin_manager dened in the contract with the default poll cong. through the current implementation allows or migration congs actions admin imply poll After updating the admin_manager to any other address, normal messages can be used for admin actions, including contract migrations. As in the last issue, we only consider this issue minor since the community could observe such polls and intervene by rejecting them.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Migrations that run out of gas remain executable and may be triggered in the far future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "The governance contract supports migrations to be run when a poll is executed through the ExecutePoll message. Such execution, which is triggered as a sub-message in contracts/mirror_gov/src/contract.rs:615, does not have a gas limit set. If the migration (or any other message) runs out of gas, the whole ExecutePoll message will revert. As a consequence, the poll will not be changed from PollStatus::Passed to PollStatus::Failed. This implies that polls will stay open for an unlimited time. the status of This can become problematic if Terra decides to increase the gas limit for messages in the future. In such a case outdated migration messages might be triggered, which could lead to an inconsistent state of the contracts. This issue also replies to any other poll running out gas, but is especially devastating with migrations that might change the storage layout.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Addresses for migration in migration polls are not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "When creating migration polls, addresses for the contracts to be migrated are currently not validated in contracts/mirror_gov/src/contract.rs:409. This could lead to failure of migration executions. message creation prior to",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Liquidity token price source does not work with Osmosis pools",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "In packages/abstract-os/src/objects/price_source.rs:222-226, the liquidity pool token asset must be a CW20 token, or else an error will occur. This is problematic because Osmosis uses native tokens as liquidity pool tokens (e.g., gamm/pool/1), preventing root users from conguring PriceSource::LiquidityToken asset value calculation for Osmosis-based pools.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. API contracts cannot use reply handlers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "In packages/abstract-api/src/endpoints.rs, is not registered for Abstract APIs. This means the API contracts reply entry point will not be executed even if dened, causing the transaction to revert. the reply entry point We classify this issue as major because it aects the correct functioning of the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Installed modules can execute arbitrary Cosmos messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The proxy contract allows whitelisted modules to execute arbitrary messages through the ExecuteMsg::ModuleAction entry-point handled by the execute_module_action function in contracts/core/proxy/src/commands.rs:19-33. As a result, any ill-intended module could perform high-impact actions on the proxy, such as stealing all funds. Similarly, the execute_ibc_action function in lines 37-63 allows arbitrary execution of Cosmos messages over IBC with a similar impact.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Root users updating module addresses might cause inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "update_module_addresses in function The contracts/core/manager/src/commands.rs:46 allows the caller to update the OS_MODULES map directly. This privileged function is intended for contract-to-contract interaction in which the caller likely performs lookups and validations on the message parameter. For example, the manager contract calls this function internally through the register_module and set_migrate_msgs_and_context functions. In contrast, the root user should not call this function to update the module addresses as it could introduce unintended consequences to their OS, for example, if:  The new address is not whitelisted in the proxy contract using the whitelist_dapp_on_proxy function.  The old address is not removed from the proxy contract using the remove_dapp_from_proxy_msg function.  New modules that require dependencies to work are directly set instead of using the intended install procedure via the install_module function.  Modules are removed without checking their dependents from the DEPENDENTS storage state.  The root user bypasses validation in contracts/core/manager/src/commands.rs:87-89 by directly calling the module factory contract. This can be achieved by updating any dummy name to the module factory contract address via the update_module_addresses function and the install_module functions using the ExecOnModule message to forward the message to the module factory contract to register the module.  Duplicate addresses are provided within the to_add vector which would only cause the last one to be stored. While most of these examples may not cause signicant issues, not automatically removing an old module from the proxy contract would allow it to execute commands via execute_module_action even though the OS_MODULES storage state is modied.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Migration to an older version is not prevented and may lead to state inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "an for multiple contracts in scope does not prevent a contract The migrate entry point migration and version. Currently, older to migrate_module_data functions are only executed when the contract is being migrated to a newer version. In the case that a migration is performed to an older version, no error would be raised, causing the new version of the contract to not be set, and the module data would be silently not migrated to the next version. set_contract_version the  contracts/core/manager/src/contract.rs:34  contracts/core/proxy/src/contract.rs:65  packages/abstract-app/src/endpoints/migrate.rs:41 In addition, the migrate function does not check if the contract name is indeed the same. In case of a mistake when selecting the code ID, the contract instance could be migrated to a dierent contract. We classify this issue as minor since only the root user can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Governance type lacking validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "When the os-factory contract instantiates the manager contract, the governance type is converted to a string. Then it is passed to the os_info as a string. This conversion is made, but the governance type should only support Monarchy and External, which are the two variants in by packages/abstract-os/src/objects/gov_type.rs:9. GovernanceDetails supported enum the set_root_and_gov_type in The contracts/core/manager/src/commands.rs:239 allows this value to be updated directly by the root user as a string. Hence, its value can diverge from the enum variants. function for Similarly, the instantiate function also takes this piece of data as a string instead of an enum without further validation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. subscriptor_address is not updatable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "contracts The manager contract implements the subscriptor_address role to suspend most of in function However, the contracts/core/manager/src/commands.rs:407-427 does not allow for this address to be updated. update_info functionality. the is best practice to allow updates of privileged addresses, which is useful It operational changes or if a privileged account is compromised. in case of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Queries might fail due to unbounded iterations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "In packages/abstract-api/src/endpoints/query.rs:48 and 60-64, all traders and dependencies are returned without pagination. If too many traders or dependencies are the BaseQueryMsg::Traders and BaseQueryMsg::Config registered/installed, queries might fail due to an out-of-gas error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Add action prevailing over remove action when updating oracles assets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "oracle package implements in The update_assets packages/abstract-os/src/objects/oracle.rs:47-72, which two vectors: One of the assets to be added to the oracle and one of the assets to be removed. The function rst removes any assets in the to_remove vector and then adds the ones in to_add vector. function accepts the This approach is not recommended since if the same asset is found in both vectors, it will neither be removed nor added, and no error is raised. This implies that in case of a mistake where the owner accidentally sends an asset in both vectors, they will be unaware of that mistake.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Lack of input validations when upgrading modules",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The manager contracts ExecuteMsg::Upgrade entry-point is handled by the in upgrade_modules function does not contracts/core/manager/src/commands.rs:255-277. This thoroughly validate the modules argument vector, which can lead to the following problems: function Firstly, in the case that duplicated modules are provided, two identical migration messages will be forwarded, causing the second migration attempt to fail if the migrate only if newer pattern is in place (as recommended by best practices), causing the whole call to fail. Secondly, the function does not check that the provided vector is empty, allowing for an inecient execution that will forward the Callback message without actual changes. if Thirdly, the whole execution would be short-circuited to the upgrade_self function if one of the modules to upgrade is abstract:manager. This is problematic if other modules need to be migrated along because they will be ignored and potentially cause a partial state mutation. For example, the last module to be migrated is the manager contract, the MIGRATE_CONTEXT storage state will store the previous module_id and old dependencies while the update_module_addresses function will overwrite the old module address to the new one in line 300. Since the migration is never executed for other modules, the root user can only call the ExecOnModule message to the invalid new app address (which should be the old one), and the handle_callback and assert_migrate_requirements functions will execute the same module ID more than once, consuming extra gas. Finally, as the provided modules are not checked to have a migrate function, the forwarded migrate message will fail when a non-migratable module is provided, causing the whole call to revert. We classify this issue as minor because it can only be caused by the root user.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Querying conguration does not return the subscriptors address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The manager contract implements an entry point to query its conguration. This call managed the contracts/core/manager/src/queries.rs:36-49. handle_config_query function by is in this However, details: subscriptor_address is not retrieved, even though it plays a central role as it is in charge of the contracts suspension. conguration function retrieve does not the full",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Remove duplicate permission check",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "the in In contracts/core/manager/src/commands.rs:233, there is a validation to assert that the caller is the root user. This is unnecessary as the execute_update_admin function performs this check already and is called later in the function. assert_admin function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Incorrect comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "exec_on_module in The contracts/core/manager/src/commands.rs:167 that seems to be copied from another function. comment incorrect contains function an similar A packages/abstract-os/src/objects/module_version.rs:48-50. set_module_data situation occurs also the in function in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Insucient validation to hinder o-chain attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The manager contract includes three pieces of information that could potentially be used as part of injection or phishing schemes: name, description, and link. These could: traditional web exploits such as script 1. Contain whitespace intended to trick users 2. Contain code that may be executed in a users browser 3. Contain links to external resources that may be malicious 4. Contain insecure links",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "None of the packages and contracts enabled overflow-checks for the release prole. While enabled implicitly through the workspace manifest, future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Misleading message names",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The SuspendOs and EnableIBC functions in the manager contract are both potentially misleading function names. Based on their names, the functions seem declarative of one specic action, but each of these functions actually supports enabling and disabling functionality. For example, a call to EnableIBC with a status of false actually disables the IBC functionality.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Sudo messages are not exported",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "and In packages/abstract-api/src/endpoints.rs packages/abstract-app/src/endpoints.rs, sudo messages are not exported as valid entry points. If governance decides to vote and execute arbitrary messages on the API or app contracts, they will fail.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Governance type implementation diverges from documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The governance documentation page lists three governance types: monarchy, multisig, and in token. packages/abstract-os/src/objects/gov_type.rs:9-22 only implements two governance types: monarchy and multisig. GovernanceDetails However, enum the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Stakers can steal funds by providing duplicate assets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eclipse Fi/2024-07-30 Audit Report - Eclipse Equinox Lockdrop Contract v1.0.pdf",
        "body": "In the contracts/lockdrop/src/entry/execute.rs:315-349, try_claim_rewards and try_claim_all_rewards functions implement the optional assets parameter if the staker wants to withdraw specic assets. The issue is that if duplicate assets are provided, stakers can withdraw more rewards than intended due to the loops in lines 1362, 1493, 1658, and 1810. Consequently, rewards from other stakers will be paid out, triggering an insucient balance error when other stakers unlock their staked eclipASTRO and liquidity pool tokens, causing a loss of funds.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Rewards are not recorded by the global index, causing a loss of rewards for stakers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eclipse Fi/2024-07-30 Audit Report - Eclipse Equinox Lockdrop Contract v1.0.pdf",
        "body": "contracts/lockdrop/src/entry/execute.rs:1593-1604, In the the _claim_all_single_sided_rewards SINGLE_STAKING_REWARD_WEIGHTS state if the reward duration does not match the specied durations. This is problematic because when the rewards are claimed from the index must be increased accordingly to staking contract in lines 1571-1582, the global distribute the rewards to the stakers. An example of a correct implementation can be found in contracts/lockdrop/src/entry/execute.rs:1345-1352. function update does not Consequently, the withdrawn rewards are not distributed to the stakers, causing a loss of rewards.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Incorrect penalty amount possible",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eclipse Fi/2024-07-30 Audit Report - Eclipse Equinox Lockdrop Contract v1.0.pdf",
        "body": "In contracts/lockdrop/src/entry/execute.rs:2046, the _unlock_lp_lockup function computes the penalty amount to be half of the withdrawn amount. This is incorrect because the penalty amount should be computed with the early_unlock_penalty_bps value dened in packages/equinox_msg/src/lockdrop.rs:231. the contract If instantiator congured a dierent Some(msg.lock_configs) value in contracts/lockdrop/src/entry/instantiate.rs:47, the penalty amount will be incorrect. We classify this issue as minor because it can only be caused by the contract instantiator, which is a privileged role.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Contract ownership cannot be transferred",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eclipse Fi/2024-07-30 Audit Report - Eclipse Equinox Lockdrop Contract v1.0.pdf",
        "body": "The contract within the scope of this audit does not expose any entry points for the owner to transfer ownership. This is problematic because if the contract owner is compromised, there is no way to recover.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing conguration validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eclipse Fi/2024-07-30 Audit Report - Eclipse Equinox Lockdrop Contract v1.0.pdf",
        "body": "The lockdrop contract does not perform validation on several of its conguration elds in the following locations:  instantiation contracts/lockdrop/src/entry/instantiate.rs:18-70  try_update_config contracts/lockdrop/src/entry/execute.rs:38-54  try_update_reward_distribution_config contracts/lockdrop/src/entry/execute.rs:56-78 in in in The aected elds are the following:  The addresses are not validated using addr_validate to ensure the addresses are in the correct format:  dao_treasury_address  eclipastro_token  converter  single_sided_staking  lp_staking  astro_staking  The eclip and bclip assets may be native or CW20 tokens from the AssetInfo enum:  If they are native assets, the denom should be validated with BankQuery::Supply to ensure the supply is larger than zero, meaning the denom exists.  If they are CW20 token addresses, addr_validate should be called on the address.  The lock_configs vector holds individual lock congurations that consist of duration, multiplier, and early_unlock_penalty elds:  The lock_configs vector should be validated to ensure no lock congurations use the same duration eld. Entries with repeated durations make elements dierent than the rst to be unreachable when performing value matching or duplicate entries in storage pieces to be modied several times when loading data based on the duration key by iterating through the congs.  The deposit_window and withdrawal_window elds should be validated to contain a minimum duration. For example, the protocol will not work properly if the elds are miscongured as zero. We classify this issue as minor because it can only be caused by the contract owner, who is a privileged entity.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Incorrect and misleading events emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eclipse Fi/2024-07-30 Audit Report - Eclipse Equinox Lockdrop Contract v1.0.pdf",
        "body": "The following instances illustrate incorrect or misleading events emitted:  The migrate function in contracts/lockdrop/src/contract.rs:132 emits the contract name as new_contract_name. This is misleading because the contract the migration due to the validation in name does not change throughout contracts/lockdrop/src/contract.rs:113-117. Consider modifying the attribute key to contract_name to prevent confusion.  In contracts/lockdrop/src/entry/execute.rs:1220, amount attribute is emitted incorrectly as eclipastro_amount_to_deposit. This is incorrect because the xASTRO amount value will be reected as the eclipASTRO deposit amount. the Consider modifying the Uint128::from(2u128) contracts/lockdrop/src/entry/execute.rs:1046. attribute value emit to xastro_amount / following  In contracts/lockdrop/src/entry/execute.rs:1230, amount attribute is emitted incorrectly as eclipastro_amount_to_deposit. This is incorrect because the xASTRO amount value will be reected as the eclipASTRO deposit amount. the Consider modifying the attribute value to emit xastro_amount_to_deposit.  In contracts/lockdrop/src/entry/execute.rs:261, the action emitted is to convert ASTRO to xASTRO. This is incorrect because the action is converting ASTRO to eclipASTRO. Consider modifying the attribute value to convert ASTRO to eclipASTRO.  In contracts/lockdrop/src/entry/execute.rs:50, new_timelock_staking. This the attribute key is incorrect because the updated is emitted as conguration is the DAO treasury address. Consider modifying the attribute key to new_dao_treasury_address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Attackers can cause a consensus failure by sending coins through IBC",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "in x/tariff/keeper/allocation.go:30 During the execution of the BeginBlocker, a panic occurs in the AllocateTokens the function SendCoinsFromModuleToAccount function returns an error. This error can be caused if a zero-amount coin is passed to the SendCoinsFromModuleToAccount function. Currently, there is no check in the AllocateTokens function that prevents a coin with a zero amount from being added to coins. if An unsuspecting user or an attacker could cause such a panic by sending a coin with an amount in the [10_000, 19_999] range through IBC. Since the scale factor is 10_000 and the result is truncated, this would cause the sending of coins with a zero amount using the SendCoinsFromModuleToAccount function, which would cause a panic as described above. Consequently, the chain will be permanently halted since the error is not recoverable without pruning the state. A test case able to reproduce this issue can be found in Appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Panic in SendCoinsFromModuleToAccount causes chain to halt",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "When the BeginBlocker is executed, AllocateTokens function dened in x/tariff/keeper/allocation.go:30. there is a possibility of a panic in the This panic occurs when the SendCoinsFromModuleToAccount method of bankKeeper encounters an error. One such error can arise if the recipient's address is listed in the Bank modules blacklist. The purpose of blacklisting is to prevent users from sending funds to module accounts or to proactively block specic malicious accounts as determined by the governance. An attacker could forge a message to send coins to these blacklisted accounts, causing a panic that halts the chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Fee will round to zero for small fees or amounts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "The SendPacket function in x/tariff/keeper/keeper.go:81-82 introduces a rounding issue that can occur when the bpsFee or the fullAmount take small values. The rounding will be in favor of the user and will round down to 0. using example, For in docs/modules/tariff.md, amounts under 10000uDenom will have a fee value that rounds down to 0. TransferFeeBps from the value docs the of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. A large number of DistributionEntities could slow down and even halt the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "The AllocateTokens function dened in x/tariff/keeper/allocation.go:7-33 is responsible for distributing fees to DistributionEntities during the BeginBlocker. Since it performs an unbounded loop through all the registered DistributionEntities, it could cause the BeginBlocker execution to take more time than expected. This could slow down the chain or, in the worst case, halt the node because Tendermints timeouts are hit. classify issue We DistributionEntities. this as informational since only governance can register",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Remove unused functions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "There are some instances of unused functions in the codebase:  The String function in x/tariff/types/params.go:139.  The GetAccount function in x/tariff/types/expected_keeper.go:11.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Use of magic numbers decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "In the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. In x/tariff/types/params.go:85, transferFeeBPS is greater than a hard-coded value of 10000. there is a validation check if the value of In x/tariff/keeper/keeper.go:81, the values 4 and 1 are hard-coded.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Missing transaction revert could lead to loss of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "In evm/src/dexspan/DexSpan.sol:421-437, the messageHandler function should transfer funds to the recipient and, if isInstruction is set to true, it initiates a call to the recipient. However, it does not check the execFlag and does not roll back the current state if the call fails. As a consequence, this could potentially result in the loss of funds within the recipient contract.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Contract upgradability is not properly implemented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "The DexSpan contract is Initializable and intended for upgrades, using an initializer function instead of a constructor. However, it implements a constructor. As highlighted in the Open Zeppelin documentation on Writing Upgradeable Contracts, this misuse of functions would make the contract not upgradeable.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. The UniswapV2s skim address is hardcoded which may lead to a loss of funds on other chains",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "The UniswapV2s skim contract address is hardcoded in the constant skimAddress in and evm/src/dexspan/DexSpan.sol:76 evm/src/dexspan/DexSpanView.sol:45. However, since the skim contract address may vary on dierent chains, the hardcoded address may result in a loss of funds on another chain where the address does not belong to Uniswap.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Maximum approval on third-party components may lead to drain of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "The _swapOnOneInch, _swapOnParaswap, and _swapOnUniswapV3 functions dened evm/src/dexspan/DexSpan.sol:593-615, respectively and evm/src/dexspan/DexSpan.sol:617-643, evm/src/dexspan/DexSpan.sol:564-591 allow swapping tokens on dierent DEXs. in However, they do not limit token approvals appropriately, by using a type(uint256).max approval to the addresses of those protocols each time they are invoked. As a result, this could lead to a drain of funds if there is a bug or malicious implementation in the allowed contracts.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. DEX swap functions enable users to perform arbitrary calls",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "The functions _swapOnOneInch, _swapOnParaswap and _swapOnUniswapV3 dened evm/src/dexspan/DexSpan.sol:593-615, in evm/src/dexspan/DexSpan.sol:617-643, and respectively, allow swapping tokens on evm/src/dexspan/DexSpan.sol:564-591, dierent DEXs. However, since these functions rely on unveried user input _data to call any given function of the address mapped at the input-provided flag, users can call arbitrary functions to let the transaction succeed even if no swap is performed. Moreover, in the case of a multihop swap, parameter calculations occur dynamically during the process, making it challenging for users to dene the correct parameters in the _data eld. This might lead to a loss of funds and leftover funds stuck in the contract. We classify this issue as major instead of critical since the frontend is assumed to correctly and safely construct messages.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Deposits in native currency always revert",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "The swapAndDeposit function allows users to deposit native currency or swap tokens to native currency and deposit them to the asset forwarder contract. Then it calls the _swapMultiInternal function. If there is a swap whose nal token is the native currency, the contract will withdraw the funds from the native wrapper contract. However, it does not transfer funds when calling the deposit function, as this function only approves normal ERC20 contracts. Consequently, since the asset forwarder checks the msg.value, such transaction always revert.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Balance retrieval logic enables attackers to drain contract funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "evm/src/dexspan/DexSpan.sol:352, In the universalBalanceOf(address(this)) function should fetch the balances used for computing transfers. 465, 452, and However, it does not return correct results when the contract holds assets. As a consequence, this can be exploited by attackers to steal the contracts balance by triggering swaps with the isWrapper parameter set to false. We classify this issue as major because the contract should not hold a balance, and this can only arise from incorrect usage, such as in the scenario mentioned where DEX swap functions enable users to perform arbitrary calls.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Missing emission of events for conguration changes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "The functions setAssetForwarder, setAssetBridge, setFlagToFactoryAdress, and setFactorySetter setWNativeAddresses in evm/src/dexspan/DexSpan.sol:242 should emit events to ensure proper tracking and integration with o-chain bridge components like the forwarder. evm/src/dexspan/DexSpan.sol:215-240 in However, they do not emit any events, leading to issues with o-chain bridge components. We classify this issue as minor since only admins can execute the aforementioned functions.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Missing addresses validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "In the following locations, addresses in function arguments are not validated:  In evm/src/dexspan/DexSpan.sol:204-214, assetForwarderAddress, native, and wrappedNative are not validated.  In evm/src/dexspan/DexSpan.sol:215-219, _forwarder is not validated.  In evm/src/dexspan/DexSpan.sol:221-225, _assetBridge is not validated.  In evm/src/dexspan/DexSpan.sol:227-234, _factoryAddress is not validated.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Lack of contract ownership transfer functionality",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "In evm/src/dexspan/DexSpan.sol, the contract should provide a mechanism to update its owner. Without such functionality, in case of issues with key management or a compromised owner, it is not possible to update the contract owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Anomalies in hexadecimal ags interval width can lead the transaction to revert",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "In evm/src/dexspan/DexSpan.sol:527-552, ags are dened as hexadecimal intervals. However, the width of the interval is inconsistent and does not include some values. Specically, the rst interval is [0x001, 0x03E9), the second is (0x03E9, 0x07D1), the third is (0x07D1, 0x0BB9), and the last one is [0x0BB9, 0x0FA1). Consequently, the second and third intervals are comparatively smaller, and render the ags 0x03E9 and 0x07D1 unusable. The global state variable mapping flagToAddress stores the address to swap with an external protocol related to the uint256 dened ag. The address is then retrieved in: 1. evm/src/dexspan/DexSpan.sol:573 _swapOnUniswapV3 2. evm/src/dexspan/DexSpan.sol:602 _swapOnOneInch 3. evm/src/dexspan/DexSpan.sol:626 _swapOnParaswap 4. evm/src/dexspan/DexSpan.sol:655 _swapOnExchangeInternal So it is possible to use a ag on a valid range that does not correspond to any real address, as the mapping only assigns one integer per address. This could lead to success on the range validation but reverts when trying to obtain the address. This code inconsistency would require assigning all individual integers ranges per corresponding address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. The swap function accepts ETH even if not dened in the token swap array leading to funds stuck in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "evm/src/dexspan/DexSpan.sol:439-449, In the _swapMultiInternal function, if the user-dened tokens array does not contain ETH in the rst position, and the transaction's msg.amount is greater than 0, the transaction should revert. execution during the of However, since there is no check in place, the transaction will not revert and excess ETH funds will be stuck in the contract. We classify this issue as minor since the frontend is assumed to correctly construct messages.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. The assetBridge and assetForwarder could drain funds from the contract by sending a faulty swap message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "In evm/src/dexspan/DexSpan.sol:404-420, both the assetForwarder and the assetBridge addresses have the potential to siphon funds from the contract by invoking the messageHandler function with a failing swap message. In fact, in the event of a swap failure, the _amount is transferred to the recipient without any validation or safeguards in place. We classify this issue as minor since it can only be executed from the assetBridge and assetForwarder trusted addresses.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Insecure non-production contracts in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-10 Audit Report - Router DexSpan v1.0.pdf",
        "body": "The evm/src/dexspan/DAI.sol and evm/src/dexspan/REP.sol contracts contain contracts for tokens with minimal specications and a permissionless mint functionality. We classify this issue as minor since these contracts are classied as testing/non-production code.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Lack of deadline parameter exposes user to risk of price volatility",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf",
        "body": "The deadline parameter for the ExactInputSingleParams call to the Uniswap router is set to block.timestamp. This means that no deadline is set, implying that depending on gas provided by the frontend and network congestion, a long time might pass before the swap is executed, exposing the user to the risk of price changes. This is mitigated by carefully choosing the amountOutMinimum. However, for the given use case of the contract acting as a simple wrapper for o-chain code, passing on a front-end dened deadline value can help to protect users from misconguring this value.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Version pragma allows for versions with security vulnerabilities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf",
        "body": "The codebase allows any Solidity compiler version from 0.8 to less than 0.9. A number of important compiler bugs have recently been xed. In particular, version 0.8.4 xed important security issues.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "3. Outdated comment",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf",
        "body": "The comment in line 26 and 27 does not correspond to the current implementation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Contract does not implement slippage control",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf",
        "body": "The contract is designed to accept an amountOutMin parameter that may be calculated o-chain and passed to the contract. While not a security concern, this architecture puts the responsibility of correct parameter choices on the frontend/user.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. The invariant checking the last stream ID will break over time, potentially causing the chain to halt",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "LastStreamIdInvariant The in dymension:x/streamer/keeper/invariants.go enforces the invariant that the ID of the last stream in the streams array must match the last used stream ID retrieved from the GetLastStreamID function. function However, the streams array retrieved via the GetStreams function is sorted by the storage key composed of either the upcoming, active, or nished prex and the stream ID, and not strictly by the stream ID itself. Specically, the order of streams in the KV storage is as follows: 1. Upcoming stream",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Finished streams Over time, as streams will be moved from their initial upcoming state into other states (i.e., active or nished), possibly out of order, depending on their start time, the last stream in the streams array will not be equal to the last added stream. Consequently, this invariant will error and cause the chain to halt. A test case reproducing the issue is provided in Appendix 1. We classify this issue as critical since it could cause a chain halt if validators have enabled invariant checks in production. Recommendation We recommend sorting the streams in ascending order by their Id. Status: Resolved 2. Unbounded loop in PowApprox can be exploited to halt the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Directly sending funds to the txfees module can result in a denial-of-service",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "The ModuleAccountAddrs function in dymension:app/app.go:936-946 returns a map of all module account addresses and a boolean indicating if the module account is allowed to receive funds through direct and explicit actions, such as MsgSend or SendCoinsFromModuleToAccount bank messages. However, in line 944, the txfees Cosmos SDK module is explicitly allowed to receive funds. This opens up a grieng possibility in the txfees module's AfterEpochEnd hook function in dymension-osmosis:x/txfees/keeper/hooks.go:34-82 that is executed after an epoch ends. Specically, the AfterEpochEnd function retrieves all its module account's coin balances in line 43 via the GetAllBalances function and subsequently iterates over them. By sending the a lot of dierent coin denoms via ICS-20 transfers to the txfees module, AfterEpochEnd function will consume a lot of computational resources, potentially resulting in a denial-of-service (DoS). As the Dymension chain does not have a tokenfactory module to create new tokens easily, the attacker would need to create numerous tokens on other IBC-connected chains and transfer them to the Dymension chain, which makes the attack more dicult to execute. Thus we classify this issue as major instead of critical.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. EVM contract addresses squatting via the vesting module resulting in non-functioning contracts and inaccessible funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "During the Dymension app's initialization in dymension:app/app.go:707, the vesting module MsgCreateVestingAccount, MsgCreatePermanentLockedAccount, or MsgCreatePeriodicVestingAccount messages, anyone can create a new vesting account for a specic account. enabled. using the By is However, as the address of an EVM contract deployed via the CREATE or CREATE2 opcodes is deterministic and predictable, an attacker can front-run the contract deployment and create a vesting account for this address. As a result, the account is internally not stored as an EthAccountI type but as a VestingAccount type, which prevents storing the contract's code, thus rendering the contract non-functioning and any funds sent to the contract address inaccessible. This issue has been independently reported by a third party during the audit.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. CreateStream does not prevent startTime in the past",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "The CreateStream function in dymension:x/streamer/keeper/keeper.go:76 does not validate that the startTime of the new stream being created is not in the past. Allowing for the creation of a stream that has a start time in the past will have unintended consequences on the streams distribution. While it is likely that this validation was not added since stream creation proposals may make it dicult estimating an appropriate stream start time, it is best practice to have the code enforce this validation to ensure that the streams function properly.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Non-sequential stream creation during InitGenesis will cause invariant failure",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "InitGenesis During dymension:x/streamer/keeper/genesis.go:19, genstate.Streams is not validated to be sequential. A non-sequential list will cause the LastStreamIdInvariant invariant to fail. in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Queries to disabled modules are not prevented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "The initial version of Dymension is intended to be released with the RollApp-associated modules and functionality disabled. While the modules prevent direct calls and message handling, they expose their querying endpoints. This may provide query responses that are misleading and impact the user experience.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Inadequate validation of weights in DistrInfo creation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "In dymension:x/streamer/types/distr_info.go:24, the Validate function does not check if weights are positive or the resulting total weight is zero. As a result, it may be the case that there are negative weights in DistrRecords or that no distribution records are specied, preventing reward distribution to gauges in the DistributeByWeights function in dymension:x/streamer/keeper/distribute.go:21.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. CLI commands for updating and replacing stream distributions are not registered",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "The getGovProposalHandlers function in dymension:app/app.go:181-197 returns a list of governance proposal handlers for registering as CLI child commands that are mounted under the governance CLI. the However, and ReplaceStreamDistributionProposal proposals are missing and thus not registered as CLI child commands, preventing users from submitting these proposals via the CLI. UpdateStreamDistributionProposal handlers the for",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Errors during stream distribution prevent the processing of other streams",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "DistributeByWeights in The dymension:x/streamer/keeper/distribute.go allocates and distributes funds to gauges based on the specied weights. In lines 16-18, it is checked that the coins to allocate are not empty. Otherwise, an error is returned. Similarly, the total weight of the distribution is checked in lines 20-22 to be non-zero. function However, such an error is propagated all the way up to the AfterEpochEnd hook in dymension:x/streamer/keeper/hooks.go:62 and thus prevents processing other streams.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. A stream is incorrectly considered active after it has nished",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "IsActiveStream in The dymension:x/streamer/types/stream.go:29-34 returns true if the stream is in an active state during the provided curTime. However, the condition in line 30 is incorrect and will always determine the stream to be active if curTime is after the stream's StartTime and not equal to the current block time. function This is due to the && operator having higher precedence than || and thus resulting in the condition that checks if the current time is equal to the stream StartTime and if all epochs are processed, evaluating to false in case the current block time does not match the start time of the stream. Consequently, a nished stream can be updated and replaced via a governance proposal which results in an incorrect state in InitGenesis. this issue function Similarly, dymension-osmosis:x/incentives/types/gauge.go:43. Please note that issue has been identied and xed upstream by the Osmosis team in PR-4306. IsActiveGauge observed also the in is in this",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Rewards can be added to a nished gauge resulting in inaccessible funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "The does dymension-osmosis:x/incentives/keeper/gauge.go:146-162 determine if the gauge is already nished and allows adding rewards without erroring. AddToGaugeRewards function in not this function As in the x/streamer/keeper/distribute.go:47 to distribute the stream's funds to gauges, funds may be added to a gauge that is already nished, rendering the funds inaccessible. DistributeByWeights used within function is Due to this issue being mainly caused by misconguration of the stream distribution, we classify it as minor. Please note that this issue has been identied and xed upstream by the Osmosis team in PR-6445.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Missing message registration for Amino codec",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "RegisterCodec The dymension-osmosis:x/lockup/types/codec.go are missing to register MsgExtendLockup and MsgForceUnlock messages for the Amino codec. RegisterInterfaces functions and in the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Errors during fee swaps may result in an erroneous state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "After an epoch ends, dymension-osmosis:x/txfees/keeper/hooks.go swaps all transaction fees to DYM and burns them. the AfterEpochEnd function of the txfees module in received non-DYM However, if the RouteExactAmountIn function called in line 67 internally errors, and due to using continue in this error case, the state machine is not reset, and the next fee coin is processed, resulting in a potentially erroneous state.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. CLI long descriptions are lacking detail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "The stream queries in dymension:x/streamer/client/cli/query.go do not provide detailed long descriptions. Long descriptions improve the user experience of the CLI and should contain all relevant details of the query command and its usage. Currently, most of the queries In the le only provide a short description.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Gauge sorting validation may lead to unnecessary errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "validateGauges in The dymension:x/streamer/keeper/distr_info.go:41 performs a validation to ensure the gauges are supplied in sorted order. This validation may be problematic as it may cause valid proposals to be rejected unnecessarily, as gauges could be sorted by the function. function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Potential key collision due to KeyIndexSeparator",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "The streamer module utilizes a specic encoding scheme for processing keys, as dened in use of dymension:x/streamer/types/keys.go. KeyIndexSeparator, KeyPrefixStreams, and various other key prexes. includes scheme This the for key a potential There is implementation of KeyIndexSeparator set to 0x07. This byte is added after each prex key. The dened key prexes include KeyPrefixStreams = 0x04, KeyPrefixUpcomingStreams = 0x0400, and KeyPrefixFinishedStreams = 0x0402. collision due to the current KeyPrefixActiveStreams 0x0401, = While this does not cause any issues in the current implementation, the existence of a new lead to a key collision because key prex KeyPrefixNewStreams set to 0x0407 will combineKeys(KeyPrefixStreams, and combineKeys(KeyPrefixNewStream, ID2) equal to 0x0407 and 0x040707 start with the same bytes. ID1)",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Add a new invariant to validate stream distribution records",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "In dymension:x/streamer/keeper/invariants, no invariant currently checks that the sum of records weights is equal to the total weight of distribution and all the weights are greater than 0.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "20. The correct content type is not set",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "In   dymension:app/healthcheck.go:47, application/json type is not set, so HTTP resources for error and normal responses will have dierent content types.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "21. Incentives module genesis state validation does not validate Params eld",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "in The dymension-osmosis:x/incentives/types/genesis.go:42-47, called during the Validate function genesis state validation, misses validation of the genesis state's Params, ensuring that the DistrEpochIdentifier is valid. Please note that this issue has been identied and xed upstream by the Osmosis team in PR-6529.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "22. General code improvements",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-03-08 Audit Report - Dymension Point 0D v1.0.pdf",
        "body": "In several instances of the codebase, the code quality and readability can be improved:  In dymension:x/streamer/keeper/genesis_test.go:30, there is an ineectual assignment to err that leads to ignoring the error.  In dymension:cmd/dymd/main.go:16-18, type switch on errors fails on wrapped errors.  Remove unused functions dymension:cmd/dymd/cmd/inspect_tendermint.go:19, dymension:x/streamer/types/keys.go:44).  Remove unused dymension:x/streamer/types/errors.go:9,11,15,16). errors  Remove unused and dymension:x/streamer/types/genesis.go:6, dymension:x/streamer/types/events.go:9, dymension:x/streamer/client/proposal_handler.go:11). constants variables (e.g., (e.g., (e.g.,  Mark unused parameters using _ or remove them (e.g., dymension:cmd/dymd/cmd/inspect.go:32, x/streamer/types/codec.go:18).  In dymension:app/healthcheck.go:66, the error is not checked and ignored.  dymension:proto/dymension/streamer/gov_distribution.proto contains useful comments, but they are hard to nd. Moving the comments to another place close to implementation would be helpful. of StreamsInvariant invariant name the in  The dymension:x/streamer/keeper/invariants.go:65 can be improved.  In dymension:app/ante/ante_options.go:30-47, there is no validation that IBCKeeper, FeegrantKeeper, and ExtensionOptionChecker are not nil.  dymension:x/streamer/types/distr_info.go uses a deprecated types/math.go package.  sdkerrors.Register deprecated, functionality cosmossdk.io/errors. used in x/streamer/types/errors.go:9-19 is to package moved been that has of  In x/streamer/client/cli/tx_create_stream.go:86-87 govcli.FlagTitle and govcli.FlagDescriptionis are deprecated. They are only used for v1beta1 legacy proposals.  Remove todos and dymension:x/streamer/client/cli/utils.go:12, dymension:app/params/config.go:62, dymension:x/streamer/keeper/keeper.go:60). create issues instead (e.g.,",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Events emitted from the EVM gateway and voyager contracts are potentially processed out of order, resulting in events being skipped and not sent to Router Chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Orchestrator v1.0.pdf",
        "body": "The respectively. Subsequently, events are sent Emitted events from the gateway and voyager contracts on supported EVM chains, such as iSend and iReceive, are listened to by the EvmGatewayEventProcessor, and to Router EvmVoyagerEventProcessor, in Chain. and listener/evm/gatewayeventprocessor/gatewayeventprocessor.go:52 listener/evm/voyagereventprocessor/voyagereventprocessor.go:52 queries the events emitted within the specied block range by the source chain and sends them to Router Chain. Router Chain expects the events to be submitted in sequence, i.e., the events must be ordered by the EventNonce. This monotonically increasing number is incremented for each event emitted from the gateway and voyager contracts. ProcessInboundEvents function the various events, split up in individual arrays per event by using Internally, sequentially SortAndTransformInboundEventsByEventNonce gatewayeventprocessor.go:228-337 SortAndTransformVoyagerEventsByEventNonce voyagereventprocessor.go:189-281. the merge sort algorithm, implemented function type, are sorted the in in and in function in sequence by comparing the EventNonce of Specically, a for loop is implemented, which iterates n times, where n is the number of events. In each iteration, the loop iterates over all individual event arrays to nd the next the current event with the event to is lastProcessedEventNonce lastProcessedEventNonce + 1, the event is included in the msgs array, containing the sorted events. Otherwise, the event is considered to have already been processed and the lastProcessedEventNonce variable is updated with the skipped. Afterward, EventNonce of the current event. EventNonce variable. equal the If To ensure the merge sort algorithm's correct the event arrays, e.g., iSendEvents or iReceiveEvents, must be sorted by the EventNonce. Otherwise, events will be incorrectly skipped and not processed. functioning, However, contrary to the event listeners for the NEAR and TRON chains, the EVM gateway and voyager listener do not explicitly sort the individual event arrays by the EventNonce. Instead, the events are queried from the source EVM chain by the underlying eth_getLogs RPC call, which does not guarantee that the events are returned in order. Consequently, the events are not sorted by the EventNonce, and the merge sort algorithm does not work as intended, resulting in events being skipped and not sent to Router Chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Inbound and outbound CROSSTALK requests originating from non-Cosmos chains are ignored and not able to be relayed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Orchestrator v1.0.pdf",
        "body": "function implemented Inbound and outbound requests are processed and conrmed by orchestrators within the and Start attester/outbound/outbound.go:43, respectively. The requests are queried in batches of 50 from Router Chain RPC until all available requests are retrieved. Subsequently, the requests are iterated and processed individually. Before conrming a request, i.e., signing the request data with the orchestrator's private key and sending it to Router Chain, the request is validated. attester/inbound/inbound.go:43 in Validation includes checking if the request requires relaying to a destination chain and if the request is ready for execution on the destination chain. Furthermore, special validation is in inbound.go:76 and outbound.go:77. performed for CROSSTALK requests Specically, if the request's workow type is of type CROSSTALK and the validation type is not IBC_VALIDATION, the request is ltered out and not processed. Consequently, only CROSSTALK requests originating from a Cosmos chain are processed, and requests from other chain types, e.g., EVM or NEAR, are ignored and not processed, resulting in the inability to relay such CROSSTALK requests to a destination chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Transaction origin is hardcoded as an empty string when transforming an iSend event",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Orchestrator v1.0.pdf",
        "body": "In listener/near/gatewayeventprocessor/tranformer.go:76, the transaction origin is hardcoded as an empty string when creating a cross-chain request. This is incorrect the transaction. because the transaction origin should record the original sender of Consequently, the orchestrator will submit an empty transaction origin when transforming an iSend event in the NEAR network via the gateway contract, causing Router Chain to be unable to parse it.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. A potential unconrmed block is processed in the NEAR event listener",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Orchestrator v1.0.pdf",
        "body": "listener/near/gatewayeventprocessor/querier.go:75 and In the listener/near/voyagereventprocessor/querier.go:75, and QueryEventsFromGatewayContract QueryEventsFromVoyagerContract function computes the number of blocks as (endBlock - startBlock + 1). This is problematic because one extra block will be processed after the end block, which is unconrmed. An unconrmed block can be replaced if block reorganization happens. If this happens, the orchestrator will process the unconrmed blocks event instead of the conrmed block, leading to incorrectly processed events.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Suboptimal processing of attestations leading to missing attestations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Orchestrator v1.0.pdf",
        "body": "In attester/inbound/inbound.go:49, attester/outbound/outbound.go:49, and attester/valset/valset.go:50, a loop is used to continuously poll for new CrosschainRequest, crosschainRequests, valsetRequests, and to provide attestations. The process involves querying all available requests until the pagination key, nextKey, becomes empty. Subsequently, requests are processed and queued for dispatching to Router Chain. After completion, the code enters a 10-second sleep period before resuming polling. CrosschainAckRequest, i.e., However, the nextKey variable is redeclared, leading to the following problems: 1. Increased load on Router Chain: The redeclaration of the nextKey variable (var nextKey []byte) causes unnecessary and repeated queries from the beginning each time polling resumes. This results in an increased load on Router Chain, which is suboptimal, particularly when all orchestrators run the same code. 2. Risk of missing attestations: The lack of persistence in the nextKey value between sleep cycles introduces the potential risk of missing attestations. This occurs because it takes time to query that the request has already been processed. 3. High memory usage for the orchestrator and potentially causing out-of-memory issues due to keeping a large number of requests in memory.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Risk of liveness slashing due to inconsistent chain congurations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Orchestrator v1.0.pdf",
        "body": "In config/config.go:163, the current conguration setup permits inconsistent chain congurations, which can potentially lead to slashing for liveness violations. This risk arises from the fact that local congurations can override the congurations fetched from Router Chain. Only congurations loaded from the JSON le are appended to ChainSpecs. Consider a scenario where the orchestrator listens and processes all currently enabled chains, and Router Chain adds a new chain. In this case, the orchestrator should update their local JSON conguration le to process the new chain. Otherwise, the validator can be slashed due to liveness slashing rules. The inconsistency in chain congurations, where the orchestrator's local conguration diers from that of Router Chain, introduces the risk of violating liveness slashing rules. To address it is essential to ensure that the orchestrator's this issue and mitigate the risk of slashing, conguration aligns with Router Chain's congurations, particularly in cases where attestation responsibilities are concerned. This alignment will help maintain the integrity and security of the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Unhandled errors in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Orchestrator v1.0.pdf",
        "body": "In several instances of the codebase, functions that return an error are not checked nor handled properly. For example, some errors are printed out but not propagated to the caller. The following instances of unhandled errors have been found:  attester/inbound/inbound.go:86  attester/outbound/outbound.go:164  attester/valset/valset.go:80  cmd/router-orchestrator/main.go:44, 77, 83, 102, 106, 299, 302  config/config.go:158, 217, 220  health/health.go:41, 47, 51  listener/evm/gatewayeventprocessor/tranformer.go:150, 154, 159  listener/evm/voyagereventprocessor/tranformer.go:19, 26, 60, 67, 101, 108, 138, 145, 175, 182  listener/gatewaylistener.go:44, 59, 76, 81, 83  listener/near/gatewayeventprocessor/querier.go:93, 104, 115, 126,  listener/near/gatewayeventprocessor/tranformer.go:26, 86, 90, 94  listener/near/voyagereventprocessor/querier.go:93, 104, 115, 126,  listener/near/voyagereventprocessor/tranformer.go:17, 18, 54, 55  listener/tron/gatewayeventprocessor/gatewayeventprocessor.go:  listener/tron/gatewayeventprocessor/querier.go:118  listener/tron/gatewayeventprocessor/tranformer.go:44, 57, 59, 60, 124, 134-137, 174, 187, 188, 190, 191, 243, 244, 265, 292  listener/tron/initializer/initializer.go:24  listener/tron/initializer/voyagerlistener.go:22  listener/tron/voyagereventprocessor/tranformer.go:17, 18, 23, 55, 56, 92, 147, 148  listener/voyagerlistener.go:43, 57, 75, 80, 82  store/store.go:32-35  types/mqsender.go:59, 70, 96, 106 Consequently, this would cause silent failures as errors are not raised to notify users.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Pending TODO comment indicates that a function is not needed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf",
        "body": "The decimal2decimal256 function was moved out of into packages/astroport/src/lib.rs:72-78, where a TODO comment was included the function was no longer necessary. Keeping unused code reduces stating that maintainability. the pair contract",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. Inconsistent usage of query_pools function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf",
        "body": "instances of the pair contract, the In several lines query_pools contracts/pair/src/contract.rs:334 and 633 use &env.contract.address, while lines 778, 940, and 989 use &config.pair_info.contract_addr. the contract_addr argument example, inconsistently. function used For for is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "3. Factory address cannot be queried",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf",
        "body": "the query_config function In contracts/pair/src/contract.rs:1064-1073, does not include config.factory_addr in the ConfigResponse struct. Consequently, users cannot query the factory address from the pair contracts queries.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Misleading owner during cong query",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf",
        "body": "The owner value is set to None in contracts/pair/src/contract.rs:1071. Users may interpret this as the contract not being subject to any updates, as no contract owner exists. call XYKPoolUpdateParams::EnableAssetBalancesTracking, which enables asset tracking in the pool. misleading though, factory owner This can the as is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Fees held by spot vault are locked forever",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "During the instantiation of a spot vault contract the fee_recipient is dened as the contract itself, see contracts/ninja-vault-spot/src/contract.rs:31. However, there is no function that allows the fees accrued to be withdrawn, eectively locking the funds forever.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Inventory imbalance under certain parameter constellations will disable the risk management framework",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "In order to conduct risk management, the team modeled a reservation price that is dierent from the current mid-market price to be the center of the orders. To account for changes in volatilities, the orders price is a function of the volatility. However, for every imbalance ratio there exists a parameter combination of reservation_price_sensitivity_ratio and reservation_spread_sensitivity_ratio such that the proposed head and tail can be set to market price, by supplying liquidity or withdrawing liquidity, irrespective of the state of volatility. Specically contracts/ninja-vault-spot/src/mm_bot/order_management.rs:17, variable proposed_buy_head can be equal to in the _  +     where  = __  ___     ___ can be zero if: ___    2  ___ (i.e. states of high volatility and trending price behavior) An attacker with access to signicant liquidity could leverage this property during market turmoil to disable the risk management framework, as described above, pushing the vault to an imbalance such that  = 0 .",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Price threshold for price invalidity is prone to manipulation and might lead to full loss of users funds in case of a breakdown of a market or an asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "In contracts/ninja-vault-derivatives/src/mm_bot/bot.rs:40 a 30% interval is used to render the mark price as invalid. If the new price is out of this interval, the logic in contracts/ninja-vault-derivatives/src/mm_bot/risk_management/oracl e.rs closes positions if protable, or leaves them open and stops all trading activities if not protable. Although this is meant to be a protection against erroneous or manipulated prices, its ecacy is low as an attacker that is capable of manipulating the price by 30%, will also be able to manipulate the price by 29% in one block and 2% in the next or simply manipulate the price by 29.99%. In case of a non-manipulated change by 30% and a continuing trend in the same direction, a losing position will never close  leading to a  full loss of funds for users. There is a way to recover if an admin updates the last_valid_mark_price in in this is an contracts/ninja-vault-derivatives/src/config.rs:91. However, inadequate risk management for an automated trading system with multiple vaults running simultaneously 24/7. In addition, it goes against best practices that admins can update prices as enabled. tool",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Updating Ninja token address may cause state conicts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "The owner of the master contract has the ability to update the address of the Ninja token stored in the contracts cong. Altering the Ninja token address could have the eect of causing a state conict in other contracts that use the address stored within the master contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Vault contract invocations should be prevented prior to registration with master contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "Vault contracts are designed to be deployed and instantiated from their owner and then successfully initialized from the ninja-master executing the RegisterForMaster transaction. This message execution sets the subaccount_id and instantiates the CW20 contract responsible for managing the vaults lp_tokens. Before this initialization, the vault is not ready to be used and user space transactions and queries should return a meaningful error message.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Large order_density could lead to the execution running out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "In contracts/ninja-master/src/contract.rs:111-136, the following functions  get_is_authorized_order_data,  get_is_authorized_spot_order, and  get_is_authorized_derivative_order perform an unbounded iteration through orders. Since the length of the vector is related to order_density and this parameter has not an upper bound, a large value assigned to it could lead the execution to run out of gas. analogous An contracts/ninja-master/src/contract.rs:336-375 synthetic_trade.user_trades. problem also occurs in with",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Separation of ash loan payback verication into separate contract could allow administrator to steal funds and introduces misconguration risks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "The stablecoin-vault relies on the amount being lent in a ash loan to be tracked in the separate profit-check contract, which then checks that the amount has been repaid in full. This means that the actual ashloan functionality and the repay check are implemented in two dierent admin-congured contracts. As a result, a compromised admin could congure the profit-check address in the stablecoin-vault contract to point to a custom version that does not require full ash loan repayment for its own loans and use the ashloan function to extract user funds from the vault. In addition, having two independent contracts in a 1-to-1 that have to be congured separately with the corresponding address pointers to each other is error-prone and could lead to accidental misconguration.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Systemic dependence on Anchor may impede the ability to stabilize the UST peg via arbitrage during bank run cycle",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "The litepaper explains how bank run cycles can be a threat to the UST peg. If systemic risks materialize in the form of an event that has an impact on the whole Terra ecosystem, this will likely impact Anchor as well. In addition, a malfunction of Anchor or a bank run on Anchor might trigger substantial corrections in the Terra ecosystem. The fact that only a xed amount of UST  i.e. the stable_cap  is meant to remain in the vault will decrease the ratio of UST/aUST in the vault with increasing liquidity in the vault. With a growing amount of liquidity in the vault, the ability to stabilize the UST peg via arbitrage will depend more and more on Anchor being seamlessly working, which is not guaranteed during a bank run cycle. there Moreover, setting contracts/stablecoin-vault/src/contract.rs:770 meaning that the value could be set unrealistic values accidentally. validation when no is the via stable in set_stable_cap, cap",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Fixed fee buer might lead to failure of large ash loans",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In contracts/stablecoin-vault/src/contract.rs:37, FEE_BUFFER is set to a constant value. The buer is used in line 268 to assure that the contract has enough liquidity to pay taxes and fees. The messages for the fees and taxes are then created in lines 295 and 299 as functions of the amount and fees/taxes. If fees and taxes exceed the buer, large ash loans might fail because they will not be protable.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Flash loan and treasury related messages could run out of gas due to too many whitelisted contracts, assets or dapps",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In contracts/stablecoin-vault/src/contract.rs:244 the handle_flashloan function might run out of gas if the number of whitelisted_contracts gets very large. As this is unlikely and can only happen through governance motions this is only a minor issue. Similarly, in contracts/treasury/treasury/src/contract.rs an unlimited number if the of assets might cause executions of dapp-messages to fail by running out of gas, transactins uses the query compute_total_value. Lastly, in contracts/treasury/treasury/src/contract.rs:160, the removal of a dapp might fail if there are too many dapps and the message runs out of gas. This might not be a big issue, since the hite Whale architecture gure indicates that dapps will be limited.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Unvalidated and too high fee parameters might cause errors in production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In contracts/stablecoin-vault/src/contract.rs:838-856 all fees in set_fee can be set to values equal to or larger than 1. These can cause errors, e.g. in line 428, where Decimal::from_ratio(amount - treasury_fee, total_share) causing the withdrawal functionality to fail. Similarly, we highlight for informational purposes, that the validation of new_fee.share > Decimal::one() in contracts/treasury/dapps/vault/src/commands.rs:293 allows for a fee equal to 1, which would trigger inecient messages.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Anchor exchange rate might be out of date and as a consequence transactions might fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In the contracts/stablecoin-vault/src/contract.rs:271 query_aust_exchange_rate functionality is used in the simplied form without the current block height as an input parameter. Anchor in this case uses stored values to calculate the exchange rate, which might be out of date. This implies that there may be imprecisions in the Anchor withdrawal message below in lines 451-454 and 655, which could lead to a failure in execution.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Denomination check is incomplete",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In packages/white_whale/src/denom.rs the length (size of the String) of a denomination is checked to be smaller than or equal to ve in order to determine whether a given token is a native token. This might fail because a coins Denom can have between 2 and 127 characters.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Zero amounts being sent in messages will fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In contracts/treasury/dapps/terraswap/src/commands.rs:133, 120 and 172, zero amounts might be sent. These messages will always fail since zero transfers revert.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Canonical address transformations are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "While previously recommended as a best practice, usage of canonical addresses is no longer encouraged. The background is that canonical addresses are no longer stored in a canonical format, so the transformation just adds overhead without much benet. Additionally, the codebase is more complicated with address transformations.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attackers can steal funds by being the rst depositor of the pool",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "In logics/impls/pool/mod.rs:824-827, the _mint function computes the mint amount to the caller by dividing the sent amount by the exchange rate. After listing a new token, the mint action is enabled, as seen in logics/impls/controller/mod.rs:707 and line 1091. This is problematic because if the attacker is the rst depositor, an attacker can manipulate the exchange rate by sending a large amount of funds to the contract. This allows the attacker to borrow a larger amount of funds without actually depositing the required collateral amount. Another attack scenario is that when a victim makes a deposit, the attacker can front-run the transaction and inate the exchange rate to be larger than the sent deposit amount, causing the nal mint amount to round down to zero. Consequently, the victims deposit will be stolen by the attacker. Please refer to the rst depositor attack and inate exchange rate test cases in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attackers can increase users' debt by repaying a loan on their behalf",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "in tokens The protocol allows users to repay loans on behalf of somebody else. A user can spend their debt own in order logics/impls/pool/mod.rs:1024-1028, the _repay_borrow function does not handle the logic responsible for the repaid amount correctly. Specically, if the user provides a repay_amount that is bigger than the debt but less than u128::MAX, the protocol will attempt to decrease the debt by the provided value and not by the total debt. user. However, another repay the to of Consequently, in logics/impls/pool/mod.rs:927-931 will cause the borrows_scaled variable to _increase_debt function the overow. Such an operation will result u128::MAX. in the victim's debt becoming a value close to Please refer to the repay on behalf overow test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Unauthorized pool liquidation threshold modication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "The set_liquidation_threshold function in logics/impls/pool/mod.rs:505 does not implement any sort of access control. This is problematic because it allows overwriting a pools liquidation threshold, which can determine whether a particular loan will be liquidated or not. Consequently, a malicious user can manipulate this value to trigger liquidations for other users (e.g., lower than the controller contracts collateral factor value) or to prevent their own loans from being liquidated by setting it over a 100% value. Please refer to the unprotected liquidation threshold setter test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Unauthorized price oracle congurations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "In logics/impls/price_oracle.rs:56, the _set_fixed_price function lacks authorization to ensure that the caller holds the appropriate role. Currently, this allows any to congure prices for a pools underlying assets. Such a conguration can be user manipulated to set an excessively high value, enabling the user to take out uncollateralized loans, which poses a signicant risk to the protocols solvency. Please refer to the Unauthorized oracle price manipulation test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Unnecessary underlying token conversion causes a loss of funds for the sender",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "In logics/impls/pool/mod.rs:771, the _transfer_tokens function converts the pool tokens into underlying tokens denominations before processing the transfer request. However, the implementation is awed. When the _transfer_from_to function is called in lines 781 and 792, it actually transfers the pool token denoms, not the underlying token denoms. The _transfer_from_to function is programmed to mutate the storage state and directly modify the sender and recipients balances. Since the pool contract does not have the privilege to modify balances in the underlying token contract, the funds transacted should remain as pool token denom. Consequently, the recipient will receive more pool tokens than intended due to the exchange rate multiplication, causing a potential loss of funds for the sender.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Incorrect token denominations result in inaccurate amounts transacted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "The codebase contains several instances where transactions are inaccurately processed due to incorrect denominations. In logics/impls/weth_gateway.rs:108, the withdraw_eth function of the WETH incorrectly uses the underlying token denomination when calling the gateway contract PoolRef::transfer_from function with the amount_to_withdraw parameter. This approach conicts with the expectation of the pool contract's transfer_from function at contracts/pool/lib.rs:286, which requires the value to be in the form of pool token denom, not underlying token denom. in logics/impls/controller/mod.rs:980, Similarly, the _transfer_allowed function in the controller contract incorrectly uses pool token denomination while calling the _redeem_allowed function. The _redeem_allowed function expects the amount in the the underlying This in ControllerRef::transfer_allowed logics/impls/pool/mod.rs:763 with the amount denominated in pool tokens instead of the underlying token denomination. misalignment function denomination. occurs called token when is",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Delegate allowance is not decreased after consumption",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "In logics/impls/pool/mod.rs:319-325, the delegated_allowed modier is used to verify that the user, who is granted an allowance by the owner, has sucient allowance when calling the borrow_for function on the owners behalf. However, the allowance is not decreased after consumption. Suppose the owner approves the user for an allowance of 100 pool tokens. In that case, the user can repeatedly call the borrow_for function with 100 pool tokens each time, allowing them to bypass the initial allowance amount granted by the owner.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Unauthorized delegate allowance modications",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "the increase_delegate_allowance In logics/impls/pool/mod.rs:513-539, and decrease_delegate_allowance functions lack authorization checks, allowing any user to modify the allowance amounts set between an owner and a delegatee. This is problematic because an attacker can exploit these functions to increase a victim's allowance in favor of themselves. Subsequently, the attacker invokes the borrow_for function to withdraw funds from the victims account and leave them responsible for the resulting loans. Please refer reproduce this issue. to the Unprotected allowance modication test case in the appendix to",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "9. Disabled collateral assets can be liquidated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "In logic/impls/pool/mod.rs:799, the _transfer_tokens function calls the _set_use_reserve_as_collateral function when transferring funds to the recipient. The _set_use_reserve_as_collateral function automatically enables the recipients assets as collateral, allowing the asset to be liquidated in case of extreme market conditions. This is problematic because if the recipient is both a lender and borrower who does not intend to use part of the assets as collateral, malicious users can bypass this restriction so the asset can be liquidated, potentially causing a loss of funds for the recipient.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "10. Native funds owned by the WETH gateway contract can be stolen",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "logics/impls/weth_gateway.rs:93 In the withdraw_eth and borrow_eth functions accept a pool parameter and an amount parameter. Both functions will interact with the specied pool contract to withdraw or borrow WETH, unwrap into native funds, and transfer them to the caller. and 141, However, if the provided pool address is not a legitimate pool supported by the controller contract, no actual WETH gets transferred to the WETH gateway contract, and the WETHRef::withdraw function would instead withdraw funds that belong to the WETH gateway contract and send them to the attacker. An attacker can achieve this by specifying the pool parameter to a fake contract, which is programmed to return Result<Ok()> when the and PoolRef::borrow_for functions call it. PoolRef::redeem_underlying, PoolRef::transfer_from, Consequently, attackers can steal WETH tokens owned by the WETH gateway contract, causing a loss of funds. Please refer to the Steal WETH test case in the appendix to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "11. Disabled collaterals can be seized during liquidation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "Borrowers in the protocol can enable or disable assets as collateral using the set_use_reserve_as_collateral function in logics/traits/pool.rs:168. When an asset is enabled as collateral, it contributes to the computation of account health and liquidation thresholds, as seen in logics/impls/pool/mod.rs:593. this setting In However, logics/impls/pool/mod.rs:1151, the _seize function responsible for transferring a borrower's collateral to a liquidator does not validate whether the seized asset is enabled as collateral. liquidations. respected during not is Consequently, a liquidator can liquidate assets the borrower has specically disabled as collateral, causing an unexpected loss of funds scenario.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "12. Accruing interest does not update total borrows and reserves",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "In logics/impls/pool/mod.rs:684, the _accrue_interest_at function calls the _get_interest_at function internally to calculate the latest interest output. However, only the accrual block timestamp and borrow index are updated in lines 692 and 693, while the total borrows (out.total_borrows) and reserves (out.total_reserves) are not, resulting in the total borrows and total reserves remain the same. Consequently, lenders will not be rewarded with accrued interest, and borrowers can borrow with base interest rates instead of dynamic interest that is calculated based on the total borrows and total reserves, which leads to a malfunction in the protocol.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "13. Interest not accrued before rate computations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "In logics/impls/flashloan_gateway.rs:79, the transfer_underlying function transfers underlying tokens during a ash loan initiation. However, the pool contracts interest was not accrued before this transfer, leading to incorrect interest computation with fewer underlying funds in lines 108 and 118. As a result, the total amounts used for computing borrow, supply, and exchange rates is inaccurately calculated. For example, the borrowing rate computed in logics/impls/interest_rate_model.rs:98 will have an articially high utilization rate, causing an excessive increase in the borrowing rate in line 113. the Moreover, get_account_snapshot function does not accrue the pool contracts interest before logics/impls/controller/mod.rs:1379, in retrieval of a users balance, borrowed amount, and exchange rate, resulting in the latest borrow index being unapplied and leading to incorrect account collateral data. Additionally, in logics/impls/pool/mod.rs:742, the function _transfer_tokens does not accrue interest before invoking the transfer_allowed function on the controller contract. This causes validations to be performed based on outdated interest rates, impacting the senders debt and exchange rate accuracy. The same issue aects the _validate_set_use_reserve_as_collateral function in the get_account_snapshot logics/impls/pool/mod.rs:1352, which function the outdated balance_decrease_allowed function in line 1381 operates with incorrect user debt and exchange rate data. uses interest Consequently, relies rate. that on an We classify this issue as major because the caller can manually update rates by calling the accrue_interest function in logics/traits/pool.rs:42 before executing the abovementioned functions.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "14. Flash loans can be initiated without paying fee premiums",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "The flashloan function from logics/impls/flashloan_gateway.rs:54 does not verify if the assets vector contains only unique values, allowing lending of the same asset multiple times in the same transaction call. Since the function calculates premium using integer division in line 76, the premium will be zero if the borrowed amount multiplied by flashloan_premium_total is less than 10000. This allows a ash loan to be executed without needing to pay the premium fees. An attacker can divide the amount they want to loan into smaller chunks in the assets vector so that the premium computed with each chunk is zero. Please refer to the free ashloans test case in the appendix to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "15. The manager contract does not implement required entry points to call the controller and pool contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "logics/impls/controller/mod.rs:551 In the set_seize_guardian_paused and set_transfer_guardian_paused functions can only be called by the manager contract. However, there are no entry points implemented in the contracts/manager/lib.rs:91 that allow privileged roles to call the functions. 558, and the and contracts Consequently, transfer_guardian_paused cannot be updated by the privileged roles, preventing them from blocking seize and transfer actions. seize_guardian_paused controller also issue in This set_incentives_controller function, which ensures the caller contract. However, there is no entry point in the manager contract to call this. logics/impls/pool/mod.rs:552 exists the in is the manager",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "16. Unimplemented functions in the pool contract cannot be called",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "pool contract in contracts/pool/lib.rs:154-167 is overriding the The set_controller, add_reserves, and set_interest_rate_model functions. All of them are set to return a NotImplemented error variant. all However, in have logics/impls/pool/mod.rs:459, 478 and 489. Consequently, they will fail although the underlying implementation is available. implementation functions default three a",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "17. Overow checks are disabled",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "In several instances of the codebase, overow checks are disabled:  contracts/controller/Cargo.toml:32  contracts/default_interest_rate_model/Cargo.toml:32  contracts/flashloan_gateway/Cargo.toml:32  contracts/lens/Cargo.toml:29  contracts/manager/Cargo.toml:31  contracts/pool/Cargo.toml:32  contracts/price_oracle/Cargo.toml:29  contracts/weth_gateway/Cargo.toml:32  logics/Cargo.toml:43 This allows an overow issue to occur during arithmetic operations. Overows are typically undesirable and can lead to signicant issues. Therefore, it is essential to prevent them by enabling compiler-level overow checks. For example, the root cause of Attackers can increase users' debt by repaying a loan on their behalf is an overow error that occurs when the repaid amount, which is larger, is subtracted from the lesser debt value, which can be prevented by enabling overow checks.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "18. Protocol reserves are incorrectly scaled with borrow index",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "In logics/impls/pool/mod.rs:1184, 1248, and 1277, total reserves are scaled and descaled with the borrowing index. When the debt interest is accrued, the protocol reserves also increase because the new index used to descale is larger than the previous one that scales it. The scaling approach is problematic because the reserves remain in the controller contract and are not lent to borrowers. Hence, the reserves should not be subject to interest gains associated with the borrowing index. Consequently, the _reduce_reserves function will unknowingly withdraw more funds than intended, aecting all pool token holders to receive fewer underlying tokens.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "19. Double deduction of protocol seized tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Starlay/2024-03-06 Audit Report - Starlay Protocol Wasm v1.0.pdf",
        "body": "In logics/impls/pool/mod.rs:1190, the _seize function deducts the total supply of pool tokens by the amount seized by the protocol. This is problematic because the pool token supply amount is eectively reduced twice: rst, by the manual reduction in line 1190, and second, by the _burn_from and _mint_to functions in lines 1191 and 1192 that adjust the supply. For example, consider a scenario where the borrowers 1000 seized tokens are divided as 972 tokens for the liquidator and 28 for the protocol. After reducing the borrowers balance and increasing the liquidators balance, the total supply should be 927 (1000-1000+972), which already covers the protocol-seized amount. However, due to line 1190, the total supply is reduced to 944 (1000-1000+972-28), which is incorrect. Consequently, a double deduction of protocol-seized tokens will occur, causing the last user to fail to redeem their pool tokens for underlying funds due to an overow error.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Excess bytes in the encoding of None do not trigger errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ssz-rs/2023-09-28 Audit Report - ssz-rs v1.0.pdf",
        "body": "The deserialize function, dened in ssz-rs/src/union.rs:45, deserialization of the inner value after determining the input as Some. invokes the process a lead This DeserializeError::AdditionalInput error if the encoding contains more bytes than required for deserializing the inner value. occurrence potentially can the to of However, the code does not inspect any bytes of the encoding beyond the initial byte when handling the None case. As a consequence, if an encoding of None includes redundant bytes, the code will not throw an error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. is_zero method from the SSZ specication is not implemented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ssz-rs/2023-09-28 Audit Report - ssz-rs v1.0.pdf",
        "body": "The SSZ specication denes an is_zero method that returns true if the argument is a default value. relevant The at https://github.com/ethereum/consensus-specs/blob/fa09d896484bbe240334fa21aa454bafe 5842e/ssz/simple-serialize.md#is_zero. specication found can be",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. debug_assert_eq! macro checks are not performed in production code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ssz-rs/2023-09-28 Audit Report - ssz-rs v1.0.pdf",
        "body": "the In ssz-rs/src/ser.rs, parameters are validated using the debug_assert_eq! macro. serialize_composite_from_components function, dened in This macro will be ignored by the compiler in release mode, i.e. after switching to production. This is because the compiler optimizes the code in release mode, which results for example in the omission of most of the debugging and error-logging functions.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ssz-rs/2023-09-28 Audit Report - ssz-rs v1.0.pdf",
        "body": "The ssz_rs and ssz_rs_derive crates do not enable overflow-checks in the Cargo.toml release prole. Consequently, the entire codebase does not have implemented protection against overow or underow.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Vectors and arrays of dierent lengths have the same root hash",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ssz-rs/2023-09-28 Audit Report - ssz-rs v1.0.pdf",
        "body": "The hash_tree_root method of the Merkleized trait, dened for vectors in vector.rs:264-264 and for arrays in array.rs:77-91, returns the same Merkle root for values of dierent sizes. It is important to note that, according to SSZ specication, those types are statically sized, meaning that vectors and arrays of dierent lengths represent dierent types. Therefore, it is possible for dierent types to have the same Merkle roots and encodings, as SSZ encodings are not self-contained and require a specic scheme for proper deserialization. However, it is crucial to emphasize this in the user documentation, as incorrect assumptions about Merkle roots could potentially be exploited by library consumers. A further observation regarding Merkle roots is that vectors clusterize by their Merkle roots. We n>::try_from(vec![0; n]).hash_tree_root() as M(n). In this context, the following equalities hold true: Vector::<u8, expression denote can the M(1) = M(2) =  = M(32), M(33) = M(34) =  = M(64),  The same observation applies to arrays where: M(1) = M(2) =  = M(32) A test case is provided in Appendix.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Redundant mutable reference in Merkleized interface",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ssz-rs/2023-09-28 Audit Report - ssz-rs v1.0.pdf",
        "body": "In the hash_tree_root function, dened in ssz-rs/src/merkleized/mod.rs, the only parameter, self, is declared as mutable reference. However, mutability is not utilized anywhere. Therefore, it is safe to remove the mutability from the parameter declaration.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Duplicate length validation of a xed serialized composite",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ssz-rs/2023-09-28 Audit Report - ssz-rs v1.0.pdf",
        "body": "length, When deserializing Array, List, and Vector objects, depending on whether they have a xed or within variable two either deserialize_homogeneous_composite or deserialize_variable_homogeneous_composite deserialize_fixed_homogeneous_composite. functions called one of is  deserialize_fixed_homogeneous_composite is called when the type is xed, and the corresponding deserialize functions have already validated the length of the object to be a multiple of the default value of that type obtained using T::size_hint. An example for the Array type is the validation performed in ssz-rs/src/array.rs:51-65. the deserialize_fixed_homogeneous_composite function in lines Nevertheless, 71-78 validates whether the modulo of the length of the deserialized object and the default size for its type is dierent from zero. Since in the previous step, this size was multiplied by N, there is no possibility that the modulo will be dierent from zero. This validation is therefore therefore redundant, and can be removed for eciency of the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Misleading error name",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ssz-rs/2023-09-28 Audit Report - ssz-rs v1.0.pdf",
        "body": "serialize_composite_from_components in The ssz-rs/src/ser.rs:58 veries that the sum of the lengths of variable and constant elements does not exceed the MAXIMUM_LENGTH value, which is dened as the maximum range of u32. A MaximumEncodedLengthExceeded error is returned when the sum is in the case of greater than or equal to MAXIMUM_LENGTH. This is misleading, because, equality, the value is not exceeded. function dened",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Duplicated code decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ssz-rs/2023-09-28 Audit Report - ssz-rs v1.0.pdf",
        "body": "Code duplicates make it more dicult to maintain, review, and reason about the code. The code in list.rs:210-214 and vector.rs:230-234 is duplicated.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Duplicated ValidationState validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ssz-rs/2023-09-28 Audit Report - ssz-rs v1.0.pdf",
        "body": "The SimpleSerialize trait implements the derive function, which performs actions on the passed input. One of these actions is the validation of input.data, carried out in ssz-rs-derive/src/lib.rs:548. This function returns ValidationState::Validated if the validation is successful and panics otherwise. Consequently, after this action, there is no technical possibility that the state of input.data will in that implies ssz-rs-derive/src/lib.rs:550-553 is redundant. Unvalidated. performed validation This still the be",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Use of magic numbers decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ssz-rs/2023-09-28 Audit Report - ssz-rs v1.0.pdf",
        "body": "In the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. Instances of magic numbers have been found in:  ssz-rs/src/uint.rs:18  ssz-rs/src/uint.rs:25  ssz-rs/src/uint.rs:31  ssz-rs/src/list.rs:219",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Removing merchant does not remove associated deposit addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "the In the contracts/wbtc-controller/src/auth/merchant.rs:45-66, remove_merchant function does not remove the merchants associated deposit addresses and from MERCHANT_DEPOSIT_ADDRESS storage. When a merchant is removed, they should no longer have the associated roles assigned. However, the GetCustodianDepositAddress and GetMerchantDepositAddress queries will show that the removed merchant still has a valid deposit address on the Bitcoin blockchain. CUSTODIAN_DEPOSIT_ADDRESS_PER_MERCHANT",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Approving mint requests does not ensure the requestor still holds the merchant role",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "In contracts/wbtc-controller/src/contract.rs:149-189, when approving a pending mint request, no validation ensures that the requester still holds the merchant role. For example, consider a scenario where the member manager revokes the merchant role post the issuance of a mint request. The mint requester, no longer holding the merchant role, should not be permitted to receive WBTC. However, due to a lack of validation when the custodian approves the mint request, the requester can still receive WBTC even though they no longer hold the merchant role. We classify this issue as minor because the custodian is considered a privileged and trusted role.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Incorrect governor attribute value emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "In contracts/wbtc-controller/src/contract.rs:58, the governor attribute value is emitted as info.sender. This is incorrect because the governor's address is set to msg.governor, causing o-chain event listeners and blockchain indexers to record incorrect data.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Merchant deposit addresses are not ensured to be unique",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "In contracts/wbtc-controller/src/tokenfactory/deposit_address.rs:67-9 1, the set_custodian_deposit_address function does not ensure that the provided deposit_address is unique across merchants. This could lead to a custodian mistakenly assigning the same deposit_address to multiple merchants. A malicious merchant could exploit this if the custodian unsuspectingly assigns an existing address to the malicious merchant. The malicious merchant could then issue duplicate mint requests with a transaction identier of the duplicate address. Assume the custodian sets the same deposit address for two merchants. The rst merchant sends BTC to the deposit address. The second merchant did not make a deposit, but they took the rst merchant's transaction identier and issued a mint request for themselves. Since the deposit address for the second merchant matches the transaction identiers receiver address, the custodian might approve this deceptive mint request. We classify this issue as minor because it requires a misconguration by the custodian, which is a privileged and trusted role.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Separation of privileged addresses is not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "While extensive eort has been made to dene privileged access roles within the protocol, privilege separation of these roles is not properly enforced. Currently, no validation exists to enforce that these privileges are designated to unique addresses. In the unlikely case of a compromised account, privilege sharing will have severe implications. While this measure cannot prevent account compromise, it can limit the impact and serve as an additional layer of security for the protocol. Another step that can be taken to reduce the impact of a compromised account is to implement timelocks to prevent frequent updates of addresses.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Attributes are not properly emitted during contract instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "instantiation process, During the contract the initialize_governor function in contracts/wbtc-controller/src/auth/governor.rs:16 returns attributes, but they in contracts/wbtc-controller/src/contract.rs:44. function calling used are not the by Consequently, the attributes will not be properly emitted during instantiation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. GetMintRequestsCount and GetBurnRequestsCount query fails when there are no mint or burn requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "In the contracts/wbtc-controller/src/tokenfactory/nonce.rs:30-33, custom get function returns the stored nonce value in the storage using the load function. the Since the load function fails when there is no previously stored value, GetMintRequestsCount and GetBurnRequestsCount queries will fail when no mint or burn requests are issued.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Typographical error aects codebase readability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "In contracts/wbtc-controller/src/tokenfactory/deposit_address.rs:12, be the DepositAddressManager. DepositAddressMananger wrongly occurs, should which typed While the typography error doesnt aect the code functionality, it increases the chances of introducing mistakes that can be easily avoided.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Storage entries spread across multiple les increase the chances of storage key collision",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "The contract contains multiple storage entries that are dened in separate les. While this does not aect increases the likelihood of accidental storage key collisions. One common pattern is consolidating all storage entries into a single le, increasing code readability and reducing the likelihood of storage key collisions. the code quality, it",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attackers can manipulate the proposal outcome by transferring voting powers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "When voting on proposals in gov:contracts/assembly/src/utils.rs:29-32, the calc_voting_power function queries the BuilderUnlockQueryMsg::Allocation message to compute the callers voting power. An issue occurs when voters transfer their allocations to other voters with the ProposeNewReceiver and ClaimReceiver messages after voting on a proposal, which also transfers the voting power. This is problematic because new voters can vote on the proposal with the transferred voting power, eectively allowing duplicate voting with the same voting power, inating total votes, and allowing manipulation of the outcome. For example, the attacker can submit a malicious proposal and vote with their rst address. After transferring the voting power to a second address, the attacker votes again. This step can be repeatedly executed with new addresses until the proposal passes. The impact can be signicant as the proposal may contain arbitrary messages, such as transferring all funds or contract migration admin privileges to the attackers address, potentially causing a loss of funds for other users or the protocol. Please refer to the test_manipulate_governance_proposal test case in the appendix to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attackers can bypass self-migration validation to control assembly contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "In gov:contracts/assembly/src/contract.rs:397-403, the check_messages function ensures the supplied Cosmos message does not perform a self-contract migration by validating that the migrated address is not equal to the assembly contracts address. This validation is crucial because unauthorized migrations enable attackers to manipulate the CheckMessagesPassed message to not return an error in line 129, forcing the transaction to succeed and allowing them to control the assembly contract and hence the rest of the protocol. We found three ways to bypass the validation, as illustrated below. Firstly, attackers can bypass the existing validation with an uppercase version of the assembly contracts address. Bech32 addresses are case-insensitive, so both uppercase and lowercase addresses resolve to the assembly contract, eectively rendering the validation useless. Secondly, attackers can use the WasmMsg::UpdateAdmin message to circumvent the validation. The UpdateAdmin message transfers the assembly contracts migration admin to the malicious contract, and the latter WasmMsg::Execute message calls the malicious contract to dispatch a WasmMsg::Migrate message to migrate the assembly contract into the attackers chosen code ID. Lastly, attackers can abuse the authz modules MsgGrant to grant the attackers contract migration permission. This attack can be achieved using CosmosMsg::Stargate to enable migration privilege on the attackers contract and dispatching MsgExec to trigger the migration, allowing the attacker to take complete control of the assembly contract.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. IBC transfers can be grieved, preventing old ASTRO tokens from being burned",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "In core1:contracts/periphery/astro_converter/src/contract.rs:152, the ibc_transfer_for_burning function allows anyone to dispatch an IBC message to transfer the old ASTRO tokens to the Terra chain. Ideally, the client will call the entry point with a rational timeout value so the tokens can be bridged without any issues. Since this message is permissionless, an attacker can grieve legitimate transactions by front-running the call with a low timeout value, causing the transaction to fail due to insucient funds in the contract. Eventually, the IBC transaction will fail because the timeout will exceed rst before sucient time has passed for the packet to be relayed. is issue This core1:contracts/periphery/astro_converter_neutron/src/contract.rs: 59. If the fees are sent to the contract before the TransferForBurning message call, the attacker can repeatedly call the function with a low timeout value to purposely cause the failure of the IBC transaction, forcing the contract to incur the timeout_fee charged by the Neutron chain. present also in Although there is no prot motive for the attacker, we classify this issue as major because it can cause a loss of fees and disrupt normal protocol operations.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Updating xASTRO denom prevents proposals from being ended",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "The assembly contract allows modifying the xastro_denom native token in gov:contracts/assembly/src/contract.rs:438. the native token is updated while there are ongoing proposals, the end_proposal function might fail in line 332, as the new denom will be used instead of the actual denom sent in line 166 and the contract may not hold sucient funds to execute the proposal. If We classify this issue as minor because the client can recover from it by sending funds of the new denom directly to the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Querying total supply for denom validation is inaccurate",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "In core2:contracts/tokenomics/staking/src/contract.rs:61, the total supply of msg.deposit_token_denom is queried as part of the native token denom validation. If the provided token is not a native token denom, the transaction should revert. However, this assumption is incorrect because if the token is not a valid denom, the query will not error and instead return a zero value. Consequently, the contract will fail to work as intended due to an invalid denom, which requires a new deployment from the contract instantiator. Please refer to the test_denom_validation test case in the appendix to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Tracked denom is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "In core2:contracts/periphery/tokenfactory_tracker/src/contract.rs:26, the tokenfactory_tracker contract does not validate tracked_denom (native token) upon instantiation. If the provided denom is invalid, the sudo messages will fail to work as intended, requiring a new contract deployment from the contract instantiator.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Dierent output when timestamp is provided as None and Some(env.block.time.seconds())",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "core2:contracts/tokenomics/staking/src/contract.rs:366-395, In the to specify an optional BalanceAt and TotalSupplyAt queries allow the caller timestamp parameter to query the balance. If the timestamp is provided as None, it calls query_balance and query_supply functions that retrieve the balance for the current timestamp. On the other hand, it queries the balance from the tracker contract instead. if the timestamp is provided as Some(_), However, an inconsistency occurs between the timestamp parameter being provided as None and Some(env.block.time.seconds()). Although both parameters resolve to the current timestamp, the output will be dierent because None queries the latest value from the bank module. In contrast, Some(env.block.time.seconds()) loads the last recorded value from the SnapshotMap storage, causing the results to dier even though the provided parameter represents the current timestamp. This may Some(env.block.time.seconds()) interchangeably. third-party confuse users or applications that use None and Please refer to the test_different_query_results test case in the appendix to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. old_astro_denom and outpost_burn_params validation logic can be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "upon instantiation. In core1:contracts/periphery/astro_converter/src/contract.rs:34, the astro_converter contract sets the old_astro_info and outpost_burn_params in parameters core1:packages/astroport/src/astro_converter.rs:17, the old_astro_denom is expected to be a native IBC-compatible token that uses outpost_burn_params, or a CW20 token that does not require outpost_burn_params to be set. This is crucial to ensure that the old_astro_denom can be burned or bridged correctly as part of the migration from Terra to the Neutron chain. According comment the to if However, this validation does not cover other conguration possibilities. For example, old_astro_denom is a CW20 token, the outpost_burn_params must be set to None. Additionally, the transaction should revert because the tokens cannot be burned or bridged, which likely means that a conguration mistake has occurred and may require a redeployment. the old_astro_info is a native denom but not IBC-compatible, if",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Lack of events emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "In gov:contracts/assembly/src/contract.rs:499, the update_config function does not emit information regarding which storage states were updated. It is best practice to emit events and attributes to improve the usability of the contracts and to support o-chain event listeners and blockchain indexers.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Unused error messages in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "In several instances across the codebase, multiple Errors are dened but not used. This reduces the code readability and maintainability in the codebase.  gov:contracts/assembly/src/error.rs  ProposalNotCompleted  ProposalNotInDelayPeriod  MigrationError  InvalidChannel  InvalidGeneratorController  InvalidHub  InvalidProposalMessages  InvalidVotingPower  core1:contracts/pair_astro_converter/src/error.rs  Unauthorized  InvalidCw20Token",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. CONFIG storage state is not exposed through smart queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "In core2:contracts/periphery/tokenfactory_tracker/src/query.rs:10, the query entry point does not expose the CONFIG storage state value through smart queries. This forces third-party contracts and nodes to perform a raw query to read the stored value, which is error-prone and decreases user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Inconsistency between comment and implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "the gov:packages/astroport-governance/src/assembly.rs:16-17, In comment mentions that the DELAY_INTERVAL constants range value is between 0.5 to 2 days. However, the implementation itself ranges from 0.5 to 1 days, which is inconsistent with the comment.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Expired proposals remain as Passed status",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "In the gov:contracts/assembly/src/contract.rs:354-356, execute_proposal function reverts with an ExecuteProposalExpired error if the current height exceeds the proposal expiration block. While the logic is correct, the expired proposal will always remain in Passed status, which is misleading because passed proposals should be executable.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. ExecuteFromMultisig authorization check can be bypassed if the satellites contract migration admin is the satellite contract itself",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "In contracts/satellite/src/contract.rs:169-178, the exec_from_multisig function checks that the caller is the satellite contract's migration admin before dispatching Cosmos messages. Suppose the contract migration admin is the satellite contract itself. In this case, an attacker can bypass the authorization check by dispatching a CheckMessages message (see line 157) to perform a self-call into the ExecuteFromMultisig entry point. This bypasses the validation because the caller will be the satellite contract, satisfying the requirement in line 174. Consequently, the attacker can migrate the contract into a malicious code ID to prevent erroring in the CheckMessagesPassed message, ultimately taking control of the satellite contract. We classify this issue as minor because it can only be caused if the satellite contracts migration admin is the contract itself (e.g., future development that changes the architecture design). According to the client, the migration admin is the builders 2 out of 3 multisig contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Centralization concerns from ExecuteFromMultisig",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-05-22 Audit Report - Astroport Hub Neutron Migration v1.0.pdf",
        "body": "assembly The in an contracts/assembly/src/contract.rs:578-594, which allows the admin address to execute arbitrary CosmosMsg messages through the contract. ExecuteFromMultisig endpoint includes contract This feature allows a centralized entity, or an attacker in case of a compromise, to interact with other contracts of the protocol that implement assembly-only access controls. This allows the entity, for instance, to move any funds held in the target contract. This issue has been classied as informational as the admin address is supposed to be a 2 out of 3 multisig controlled by the client, which is assumed to be trusted.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. UpdateExchangeRate message leads to delegation of incorrect amount of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The execute_update_exchange_rate function tries to delegate more than it should, as it doesnt take into account the protocol_fee that needs to be accrued in case it is not zero. This causes ExecuteMsg::UpdateExchangeRate to error if the contract balance is less than the amount to be delegated plus the protocol fee. variable claimed_rewards in The the contracts/prism_hub/src/autho_compounding.rs:87, in the protocol_fee the message contracts/prism_hub/src/autho_compounding.rs:66. Therefore, moving fee funds will be executed rst and then the delegation message will try to delegate an amount bigger than the actual balance, as protocol_fee has already been transferred. used includes fee_collector transferred incorrectly previously since it that to is is A proof of concept test case for this security issue can be found at Appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. State update not stored",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The execute_update_global function uses the incorrect instance of the loaded STATE to update the principle_balance_before_exchange_update element of the struct. it could Although at dramatically aect future features as an outdated value would result in incorrect results when used as part of calculations. the code base does not make use of this element, the moment of changing Instead in contracts/prism_hub/src/contract.rs:213, the code changes the value that is loaded Consequently, principle_balance_before_exchange_update will never be updated. last_state stored. never value initial state but the the of in Please note that we consider this issue to be a minor issue since the aected variable is not used. In a future release, this issue might have critical consequences.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Custom access control implementation is error-prone and decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract implements custom access controls, which introduce a few issues: The transfer of the creator role to a dierent account is implemented in a one-step fashion without conrmation from the receiving party. This could potentially cause a loss of access to the role in case a mistake is made during the role transfer. In addition, the Access Control logic that enforces these restrictions is duplicated across the handlers of each function, which negatively impacts the code's readability and maintainability, as it is error-prone.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Lack of conguration parameter validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract lacks validation steps on most conguration parameters upon instantiation or update. Although the values are supplied by the owner, the well-functioning of the protocol if an unexpected value were to be assigned by mistake or if a rate parameter were assigned a value outside of the 0 to 1 range. For example, a fee rate of 1 this could aect will not make the protocol usable, while a fee rate greater than 1 will lead to the protocol losing value. The following lines are aected:  contracts/prism_hub/src/config.rs:35-40  contracts/prism_hub/src/contract.rs:70-75",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. uluna coin denom is used instead of underlying_coin_denom",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract denes in the Parameters struct the underlying_coin_denom eld. This parameter represents the denom of the coin that is delegated by the contract to validators. However in lines:  contracts/prism_hub/src/autho_compounding.rs:68  contracts/prism_hub/src/autho_compounding.rs:89  contracts/prism_hub/src/contract.rs:44 instead of using the correct denom saved in the store, uluna is hardcoded. This implies that the contract will work on chains with a uluna denom, such as Terra.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Pseudorandom validator selection can be predicted and gamed by validators",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "In order to fairly select a validator during auto compounding, unbonding, and validator delisting, the protocol is using XorShiftRng with the current block height as a seed to generate a pseudo-random index. This calculation at a certain block height is easy to predict. Validators could use this information to try to execute a specic transaction at a specic block height in order to be selected, in case of auto compounding, or not be selected in case of unbonding and validator delisting.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. WithdrawUnbonded transaction requires the execution of multiple unbounded loops",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "In execute_withdraw_unbonded function running multiple unbounded loops. contracts/prism_hub/src/unbond.rs:146, the handles WithdrawUnbonded messages In line 168 the process_withdraw_rate function executes two unbounded loops over all not processed yet UnbondHistory. In line 170 the get_finished_amount function executes an unbounded loop over the user unbounding waitlist. In line 180 and 181 the get_unbond_batches and remove_unbond_wait_list functions execute an unbounded loop over the user unbonding waitlist. This implies that under specic conditions, for example if the user has a lot of pending batches to unbond in the whitelist or if the user is another contract that does a big number of operations, the execution can run out of gas and the user would not be able to withdraw their funds. We consider this issue to only be of minor severity since it is unlikely to occur in the short to mid-term.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Updating token_contract will aect previously bonded funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The contracts/prism_hub/src/config.rs:74. update admin can the token_contract parameter in As the entire protocol state relies on information that depends on that parameter or queries using that parameter, any update will aect users that have their funds previously bonded by not allowing them to unbond. We classify this issue as minor since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Outdated and unmaintained dependencies in use",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract uses outdated versions of multiple libraries, version that publicly known vulnerabilities CVE-2021-32810 and CVE-2020-35880. including a cosmwasm-vm In addition, two libraries were aected by lacks some important upgrades. Although bigint is not maintained and therefore there is no x available, crossbeam-deque aected by CVE-2021-32810 has an ocial patch ready. Further details can be found in Appendix 2.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Custom functionality for checking additional funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract makes use of custom functionality to check for additional funds being sent in and contracts/prism_hub/src/bond.rs:35-47 contracts/prism_hub/src/contract.rs:39-45. Although not a security issue, well-known community-driven libraries are recommended for this kind of feature.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Canonical address transformations are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "While previously recommended as a best practice, usage of canonical addresses for storage is no longer encouraged. The background is that canonical addresses are no longer stored in a canonical format, so the transformation just adds overhead without much benet. Additionally, the codebase is more complicated with address transformations.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Missing tax deductions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero tax rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See this discussion for more details about the tax rate changes on Terra.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Typographical errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "In contracts/prism_hub/src/contract.rs:51 and other places, the wrongly typed porotcol_fee_collector occurs, which should be protocol_fee_collector. The same misspelling will also introduce a cascading eect when other protocols query the config. In addition, in contracts/prism_hub/src/config.rs:139, the conguration is loaded for a function named token, which is potentially another typo.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Duplicated code can negatively impact maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "read_validators in The contracts/prism_hub/src/state.rs:176 and 20 are performing the same logic. Additionally, all validators are valid in the Prism Auto Compounding cAsset protocol. Code duplication increases code complexity and can negatively impact maintainability. read_valid_validators functions and",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Unused code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "Multiple instances of unused code exist in the codebase, including variables and functions that are only used within tests, but not in the actual contract. Unused code aects the overall code readability, and might confuse users since it is suggestive of any features that are currently not being implemented. The following list includes the aected lines:  contracts/prism_hub/src/state.rs:10, 53-63  contracts/prism_hub/src/contract.rs:36, 37, 58  contracts/prism_hub/src/hub.rs:160, 163  The UnbondHistory struct includes elements that are not in use. batch_id is not used as it is the actual key in the history storage instance. Similarly, applied_exchange_rate and withdraw_rate seem to reect the same value here, however, applied_exchange_rate is only used inside tests and not the actual contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Comment contradicts implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract includes comments describing the required privileges for each function for assigned execution message. comment handler The an as of a execute_register_validator in contracts/prism_hub/src/config.rs:96 states that the functionality is callable only by the creator. However, this diers from the implementation as the Hub contract itself is whitelisted too, given that this message is sent by the contract upon instantiation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Lack of address validation upon querying",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract doesnt validate the input address of the query_unbond_requests function. Although not being a security risk, it may lead to a lowered user experience if incomplete or invalid addresses are provided and no address validation error is returned.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Ineciency in querying a specic validator",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "In contract/prism_hub/src/config.rs:112, the execution is querying the list of all validators in order to check if the provided one is part of the list. Instead of executing query_all_validators and then iterating through the list in order to nd the required one, which has a O(n) complexity, query_validator could be used to directly query the required one.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Lack of pausing mechanism",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "Currently when the smart contract is deployed, if there is any catastrophic security loophole being discovered there is no quick way to limit its functionality and restrict the potential impact of the vulnerability while the team carries out an investigation/working on an upgrade.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attacker can extract all Sigma tokens from the factory contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "claim_deposit The in contracts/sigma_factory/src/contract.rs:363 allows an attacker to extract all Sigma tokens from the factory contract. Currently, any address with an unlocked deposit can perform this attack. There is no step in the function where entries are removed from CREATOR_TO_UNLOCK and the deposit redemption is not recorded anywhere. function The following is a potential attack scenario: 1. The attacker creates an option",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. The attacker can repeatedly call claim_deposit and will continue to receive config.deposit_amount each transaction until the factory contract has no Sigma tokens left. Recommendation We recommend removing the CREATOR_TO_UNLOCK map entries after they are utilized in claim_deposit. In addition, we recommend storing the amount the user deposited and only returning it rather than returning config.deposit_amount. This amount can be decremented or set to zero after the user has claimed their deposit. Status: Resolved 2. Logic error prevents the redemption of aUST",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Settlement of stage 4 might run out of gas if too many depositing addresses exist",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "In contracts/sigma_vault/src/contract.rs:996-1017, the deposits may run out of gas if the vector has many entries. Many entries might occur if an attacker would create many addresses to prevent the settlement of puts. This would result in the vault no longer being able to settle puts. There is currently no way to recover from this issue. iterations over",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Depositors may receive dierent amount than original deposit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "claim_deposit The in contracts/sigma_factory/src/contract.rs:383 allows the depositor to claim their deposit after it has reached its unlock_timestamp. The deposit is sent back in a CW20 transfer message in lines 379-386. This message amount sends the current config.deposit_amount (an updatable value) to the depositor. This is problematic if the deposit_amount at from the deposit_amount at the time of the claim. the option was created is dierent the time that function The value of deposit_amount is updatable in line 323 by the gov contract or the owner. If this value is changed in the period of time after the option has been created but before the deposit is claimed it will cause the user to receive a dierent amount than they originally deposited when they created the option.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Updatable option conguration parameters may impact the exercisability of options that are in the money",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "The update_config function in contracts/sigma_option/src/contract.rs:122 allows config.owner to update the options parameters. There is currently no safeguard to ensure that these parameters cannot be updated on live options. Allowing for these parameters to be updated is very problematic. For example, if the owner were to change config.call_or_put, it would aect the exercisability of previously minted shares. This could be done accidentally or intentionally. In a situation where the owner is compromised, the attacker could change parameters to ensure that no users can exercise their options. There does not appear to be a reason why the option parameters would need to be updated once they are initially set, and removing this functionality completely would eliminate this possibility completely. The following parameters should not be updatable after they have been originally set:  underlying_asset  denomination  call_or_put  american_or_european  strike_price  expiration_time  exercisable_token  obligation_token",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Excess funds sent while exercising via vault contract will be lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "In both contracts/sigma_vault/src/contract.rs:570 and 582, if the user sends more funds than the exercisable units balance of the vault then they will eectively remain in the contract and not be returned back to the sender. This may result in the caller receiving less value than they have sent to the vault contract. In lines 570 and 582 there are validations to ensure that the units_sent or funds_sent are less than exercisable_units, and it will return an error if the funds are insucient. This check does not account for a situation where the caller sends funds in excess of the amount of exercisable_units. After this step, the function uses exercisable_units directly in all of the remaining messages and calculations and disregards the actual amount sent by the caller. This will result in the excess funds remaining in the vault contract and the caller will receive less value than they sent.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Missing tax deductions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See https://agora.terra.money/t/proposal-to-reduce-the-terra-tax-rate-to-zero/3524 for more detail around the tax rate discussion.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. treasury_take, percent and fee should be validated to ensure they fall within an expected range of values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "In multiple occurrences values are set or updated without validations to ensure that they fall within an expected range. These are: 1. config.treasury_take in the update_config function and the instantiate function in contracts/sigma_collector/src/contract.rs:155. 2. percent in the ExecuteMsg::Convert handling in contracts/sigma_collector/src/contract.rs:84. 3. config.fee in the update_config function and the instantiate function in contracts/sigma_factory/src/contract.rs:338 and contracts/sigma_factory/src/contract.rs:49, a misconguration could cause an error in contracts/sigma_option/src/contract.rs:574.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Miscongured distribution schedule cong can cause panics in LP staking contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "a In contracts/sigma_lp_staking/src/contract.rs:35 distribution_schedule may be stored with a start time that is greater than the end time. This would cause contracts/sigma_lp_staking/src/contract.rs:331 to panic. For informational purposes, we also highlight that it is possible to supply a schedule with gaps and overlaps. Such gaps and overlaps do not cause errors, but might not be intended.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Subtraction may cause wrap around underow",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "are multiple There in instances contracts/sigma_xsig_reward/src/xsig.rs that may cause an underow if not handled properly. It is best practice to perform checked subtraction to return None or to use saturating subtraction to keep the result at the numeric bounds, rather than wrapping around during an underow. subtractions of This is important because Rust behaves dierently in debug mode and release mode. In debug mode, Rust adds built-in checks for overow/underow and panics when an overow/underow occurs at runtime. However, in release or optimization mode, Rust silently ignores this behavior by default and computes twos complement wrapping. The following are occurrences of unchecked subtraction:  contracts/sigma_xsig_reward/src/xsig.rs:30  contracts/sigma_xsig_reward/src/xsig.rs:31  contracts/sigma_xsig_reward/src/xsig.rs:32  contracts/sigma_xsig_reward/src/xsig.rs:68  contracts/sigma_xsig_reward/src/xsig.rs:69",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Extra funds sent may be lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "There are multiple instances in the contracts where native funds are improperly handled which may lead to a loss of funds. The current implementation does not account for a situation where the caller sends multiple funds. info.funds is a vector of Coin, but the current implementation only accounts for the specic denom used by the contract. It is best practice to provide an error if funds are sent that the contract does not handle. The following are instances of where funds are handled in this manner:  contracts/sigma_option/src/contract.rs:319  contracts/sigma_option/src/contract.rs:358  contracts/sigma_vault/src/contract.rs:563  contracts/sigma_vault/src/contract.rs:576  contracts/sigma_vault/src/contract.rs:1309  contracts/sigma_vault/src/contract.rs:1379  contracts/sigma_vault/src/contract.rs:1386",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. distribute function allows collector to send any asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "The distribute function in contracts/sigma_collector/src/contract.rs:205 allows the caller to specify any asset while this function appears to be intended to only handle Sig distributions. This can be problematic if the caller species an asset that is not Sig.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. CREATOR_TO_UNLOCK may cause an out of gas error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "The CREATOR_TO_UNLOCK maps elements are never removed in the factory contract. This may cause an out of gas error in query_deposits. It is best practice to delete map entries once they have been used and are no longer necessary and also to limit the maximum number of entries to a map.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Iterations over several maps may cause out of gas errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "Iterations over several maps that are used in the factory contract might run out of gas and cause errors. These are: 1. tickers_by_option_info in contracts/sigma_factory/src/contract.rs:447 2. expiries_by_option_info in contracts/sigma_factory/src/contract.rs:465 3. strikes_by_option_info in contracts/sigma_factory/src/contract.rs:484 Out of gas errors can happen because those maps are unbounded. Since the initial amount of options is limited by the maximum expiry of three years it will not happen at launch and therefore this is only a minor issue. However, as options accumulate over the years this might become a serious problem for the protocol.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Oracles for low liquidity assets might be prone to manipulation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "Traditional options with physical delivery do not require to be in the money to be exercised. In some cases, settling an option out of the money or near the money can be economically benecial  e.g. if an equivalent order would have a large price impact on the markets. The use of oracles makes sure that options are not executed at a loss. However, if the oracle price is manipulated the oracle can stop users from executing options in the money.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Canonical address transformations are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "Usage of canonical addresses for storage is no longer recommended as a best practice. The reason is that canonical addresses are no longer stored in a canonical format, so the transformation just adds overhead without much benet. Additionally, the codebase is more complicated with address transformations.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Unnecessary use of less than or equal to",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "receive_cw20 in The contracts/sigma_xsig_reward/src/contract.rs:126 checks if the amount sent is less than or equal to zero. This can be changed to check only if the amount is equal to zero before returning the error. function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Price timestamp scale discrepancies could disable market operations for assets using the Ojo oracle",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neptune/2024-01-09 Audit Report - Neptune Updates v1.0.pdf",
        "body": "In contracts/price-oracle/src/query.rs:129-136, when retrieving prices from Ojo oracles, the ReferenceData response returns last_updated_base and last_updated_quote timestamps in seconds, as specied in the documentation here. However, the query_ojo_price function utilizes Timestamp::from_nanos, causing timestamps to be incorrectly scaled and stored, as they have not been converted to nanoseconds when storing the values. the Consequently, in a contracts/market/src/utility.rs:420-444, MoneyMarketError::PriceTooOld error leading to the impossibility of querying prices for assets that are using Ojo. function will dened return query_prices This would make Market like ExecuteMsg::Borrow and ExecuteMsg::WithdrawCollateral revert when targeting assets with an Ojo price oracle, potentially locking user funds. contract messages",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Price oracle contract allows owner and bots to overwrite prices submitted in the same block leading to race conditions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neptune/2024-01-09 Audit Report - Neptune Updates v1.0.pdf",
        "body": "The price oracle contract allows Owner and Bots to publish asset prices using the in execute_update_prices contracts/price_oracle/src/contract.rs:56-77. function dened However, since multiple Bots can submit their price in the same block and the oracle contract stores only one price for each asset, race conditions are possible where the latest transaction overwrites all the other submitted data. Consequently, it might lead to users potentially fetching dierent prices within the same block, depending on the order of transactions which validators could manipulate to take prot.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. No asset removal possible",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neptune/2024-01-09 Audit Report - Neptune Updates v1.0.pdf",
        "body": "There is no functionality implemented to remove assets. If tokens turn malicious or regulators require the delisting of a certain asset, the lack of asset removal functionality might have a negative impact on the reputation of the protocol and aect uninformed users.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Missing address deduplication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neptune/2024-01-09 Audit Report - Neptune Updates v1.0.pdf",
        "body": "In packages/neptune-money-market/src/config.rs:121-137, the set_config function allows the Owner to update the contracts conguration. However, no deduplication is performed when storing addresses provided in msg.vecs. Consequently, the same address may be stored multiple times, leading to ineciencies when iterating the vector.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Oracle centralization issue",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neptune/2024-01-09 Audit Report - Neptune Updates v1.0.pdf",
        "body": "In contracts/price-oracle/src/contract.rs:114-121, when executing the executing_update_prices function, Owner and Bots are able to set arbitrary prices for OracleAssetDetails::Regular oracles. This introduces a centralization concern, as bots and owners can set prices without any validation, price aggregation or Time-Weighted Average Price (TWAP) mechanism. Malicious bots can hence easily manipulate prices to their advantage. Additionally, since there is no validation in place for the provided price_info, it allows setting a price of 0 or a confidence level of 0, leading to liquidations or undercollaterized loans. We classify this issue as minor since the owner and bots are trusted entities.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Asset update function can be used for price updates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neptune/2024-01-09 Audit Report - Neptune Updates v1.0.pdf",
        "body": "there is a dedicated function executing_update_prices in For updating prices, function contracts/price-oracle/src/contract.rs:114-121. However, execute_update_asset in line 142 can also be used to update the prices of existing assets. the future two roles where one is only Because of this, it will not be possible to completely separate these two tasks: If there are in the (via execute_update_asset) and the other role is only allowed to update the prices of existing assets, the one that is allowed to add new assets can also update prices. Therefore, a complete separation of concerns cannot be achieved, violating the principle of least privilege. allowed to add new assets",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Wrong reservation assignment could lead to incorrect receiver for NFT",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "In contracts/contracts/stardust-nft-distribution/src/contract.rs:222, the senders address is assigned to the reservation. Since the contract owner and operator are able to create reservations on behalf of users, this might lead to the contract owner or operator receiving the NFT, rather than the reservation owner, even though the reservation owner paid for the NFT. This could lead to lost NFTs, for example, if the owner or operator is a smart contract such as a governance contract that cannot transfer NFTs.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Missing check for makers ability to cover the maker fee leads to incorrect validation query result",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "query_validate in The not contracts/contracts/stardust-settlement/src/queries.rs:9 validate whether the maker has enough stardust balance to cover the maker fee charged in when contracts/contracts/stardust-settlement/src/order.rs:117 checking if an order is suciently capitalized. This will lead to undercapitalized orders being returned as valid, which is incorrect. function does",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. NFT ownership is not cleared when NFTs are withdrawn, which leads to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "The settlement contract does not clear the stored NFT_OWNER for an NFT when a user sends the Withdraw message. NFT ownership is only updated on deposit in the in deposit_balance contracts/contracts/stardust-settlement/src/state.rs:70, but not cleared in in leads to contracts/contracts/stardust-settlement/src/state.rs:80. That an inconsistent state. withdraw_balance function function the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Setting royalties in settlement contract fails for CW1155 tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "of the part settlement in As contracts/contracts/stardust-settlement/src/royalties.rs:22, the minter of the token is queried. That query uses the CW721 contracts Minter query, which does not exist for CW1155 tokens. Consequently, royalty fees can only be set for CW721 tokens, not for CW1155 tokens. set_royalty contracts function",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Submit execution plan will fail due to message sent to wrong contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "the In contracts/contracts/stardust-settlement/src/execution.rs:131, ValidateAndTransferExecutorBalance message is sent to the executor contract, but the executor contract does not accept that message.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Missing check for ability to execute an order leads to misleading validation query result",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "query_validate in The the contracts/contracts/stardust-settlement/src/queries.rs:10 validate_into_info function with None as the last argument. That leads to a skip of validation whether a particular account can actually execute the order. This implies a misleading query result since a successfully validated order might fail validation during execution. function calls",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Querier contracts order update returns a misleading taker asset lled value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "the querier In contracts/contracts/stardust-querier/src/contract.rs:132, taker_asset_filled is set to a value of 0 for orders   that are undercapitalized, lled or cancelled. A 0 ll value is inconsistent. OrderUpdate contracts logic in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Closing an English auction leaves the maker order open",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "the in In function contracts/contracts/stardust-auction/src/contract.rs:132, the maker order is not closed when closing the English auction. That leaves dangling maker orders, leading to an inconsistent state. close_english_auction",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Treating Luna as a special case for tax calculation may lead to problems with Terra protocol updates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "In contracts/packages/stardust_protocol/src/asset.rs:35 Luna is treated as a special case for tax calculations, with a hard-coded zero value. However, this might lead to inconsistencies if Terra changes Luna tax policy in a future protocol update. In such a case, the contract would pay the tax, leading to any user funds being spent.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Approve and transfer pattern implies a bad user experience and might introduce security issues",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "In several places in the codebase, the protocol relies on the approve and transfer pattern. It is generally better to use CW20 receive hooks, as they provide a better user experience (they do not require a separate approval and do not require revocation), are more gas ecient, and are usually more secure since approvals have often a disproportionate size and no expiry.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Relayer fees are skipped if either taker or maker fee is zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "in The contracts/contracts/stardust-settlement/src/order.rs:94 contains the logical or || operator instead of the logical and && operator. This leads to no fees are being charged if either the maker or the taker fee is zero statement if",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Missing input validation of order infos and ll amounts in order execution might confuse users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "execute_orders in The not contracts/contracts/stardust-settlement/src/order.rs:149 validate whether two arrays order_infos and fill_amounts are of equal length. If they are not, any excess elements will be ignored. That might be unexpected for users. function does",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Overow checks not enabled for release prole in all packages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "in the workspace level contracts/Cargo.toml, some packages do not While set explicitly enable overow checks. This is not a security concern in the current version of the contracts since the checks are enabled from the workspace to all packages, but future refactoring might leave some packages vulnerable to over- or underows. Packages that currently dont have overow checks enabled are:  contracts/contracts/stardust-settlement/Cargo.toml  contracts/contracts/stardust-auction/Cargo.toml  contracts/contracts/stardust-executor/Cargo.toml  contracts/contracts/stardust-nft-distribution/Cargo.toml  contracts/contracts/stardust-querier/Cargo.toml  contracts/contracts/stardust-registry/Cargo.toml",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Locked funds will be inaccessible if lockdrop incentives have not been set by the end of the withdrawal window",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "is and DelegateAstroToAuction that can be executed after During ClaimRewardsAndOptionallyUnlock message handlers the withdrawal window, a users in total_astro_rewards contracts/lockdrop/src/contract.rs:827 and 910. That calculation is done in the update_user_lockup_positions_and_calc_rewards function, which contains an assertion that config.lockdrop_incentives is set and will panic otherwise in 1735. Lockdrop incentives can only be set by sending the IncreaseAstroIncentives message, which will fail after the end of the withdrawal window though. By the time this panic occurs, there is no way to recover from it, which would render any locked funds inaccessible in the lockdrop contract. calculated The same issue exists in the query_lockup_info function in line 1592. in been minted contracts/auction/src/contract.rs:618. Likewise, the auction contract contains the same mechanism  during the ClaimRewards message handler, a users auction_incentive_amount is calculated after LP shares The have update_user_incentives_and_lp_share function that performs the calculation contains an assertion that the astro_incentive_amount is set and will return an error otherwise the by fail after the LP shares have been IncreaseAstroIncentives message, which will minted. By the time this panic occurs, there is no way to recover from it, which implies that any contributed Astro and UST tokens are locked inaccessible in the contract. incentives sending These 717. only can set be in We only classify this issue as major since it can only be caused by oversight of the contract owner.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Unlocking funds may fail if a user has too many lockup positions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "all over lockup iterations update_user_lockup_positions_and_calc_rewards contains The unbounded in contracts/lockdrop/src/contract.rs:1703 and 1707. These iterations could run out of gas if a user submits many lockups for dierent pools and durations. Since the update_user_lockup_positions_and_calc_rewards function will be called when a user sends a DelegateAstroToAuction or ClaimRewardsAndOptionallyUnlock message, the user will be unable to unlock funds. There is currently no way to recover from this issue. function a positions user by The same issue exists in the query_user_info handler in lines 1453 and 1457. We only classify this issue as major since it is unlikely that users submit enough lockup positions to cause out of gas issues.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. In the event of a compromised or lost owner key funds will be locked in the contracts forever",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "The only way to retrieve delegated funds from the auction contract after the withdrawal window is closed is through an InitPool message sent from the contract owner. In the event that the owner key is compromised or control over it is lost, delegated funds will be stuck in the auction contract forever. If an attacker gains access to the key, they could extort compensation for releasing the funds. the auction contracts InitPool message also sends the EnableClaims Likewise, in message to the lockdrop contract. That message enables claims by users contracts/lockdrop/src/contract.rs:436-442. As before, a compromised or lost owner key implies that funds will be locked in the lockdrop contract forever. same mechanism in claims The contracts/airdrop/src/contract.rs:197. The issue is less problematic here, since only airdropped funds are in the contract, but still, claims will be impossible if the owner key is compromised or lost contract, enables airdrop the in Even though a compromised owner account could have other severe consequences, this issue has been added due to the high value that will probably be locked in these contracts. We still classify this issue only as minor since proper management of the owner account is assumed. The operational security of Astroport, which includes proper key management, has not been in scope of this audit though.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Liquidity migration might be prevented by target contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "The MigrateLiquidity message of the lockdrop contract triggers a withdrawal of funds from TerraSwap in contracts/lockdrop/src/contract.rs:505. In theory, the target contracts message handler could be upgraded such that the call would always revert. In that case, funds would be stuck in the lockdrop contract, with no way for liquidity migration and no way for users to withdraw their funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Issues in generator or downstream reward contracts may lead to users being unable to unlock LP tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "In the lockdrop contracts ClaimRewardsAndOptionallyUnlock message handler in contracts/lockdrop/src/contract.rs:948-954 the generator contract is queried to check pending token/reward balances. Any misconguration/issue with the generator or proxy rewards contracts (which could be caused by a downstream issue in another protocol such as Anchor or Mirror) might make this query fail, which would prevent a user from ever unlocking their LP tokens. We classify this issue as minor since a misconguration is unlikely.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Auction contract may enable claims while withdrawal window of lockdrop contract is still open which could lead to an incorrect state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "The auction contract can enable claims by sending the EnableClaims message at any time, is still open, a user calling the even before the withdrawal window is closed. to will handle_claim_rewards_and_unlock_for_lockup total_astro_rewards being set at contracts/lockdrop/src/contract.rs:910, which might not use nal values. The owner could still update a pool, which might impact the state.total_incentives_share total_astro_rewards calculation. function change would result lead and the of If it",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Staked Astroport LP will become unclaimable if generator contract is updated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "lockdrop contracts The in contracts/lockdrop/src/contract.rs:270-273, currently enables the generator contract address to be updated. Changing the generator contract address would make any staked Astroport LP at the time unclaimable after the change. This would eectively reduce all users balances. handle_update_config function The same issue exists in the auction contracts handle_update_config function in contracts/auction/src/contract.rs:200-204.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of validation on incentives share value can lead to locked funds becoming inaccessible",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "are rewards When users try to delegate Astro rewards or claim rewards and optionally unlock funds, their Astro the calculated function update_user_lockup_positions_and_calc_rewards internally calls calculate_astro_incentives_for_lockup, which will panic in contracts/lockdrop/src/contract.rs:1666 if total_incentives_share is zero. This cannot be recovered from, since pools can neither be added nor updated after the withdrawal window is closed. Consequently, any funds in the lockdrop contract will become inaccessible. function. That in We only classify this issue as minor since it is caused by a misconguration by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Updating the Astro token address may lead to an inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "The lockdrops handle_update_config function currently enables the Astro token address in to contracts/lockdrop/src/contract.rs:253-256. Changing the Astro token address after users have called DelegateAstroToAuction may lead to an inconsistent astro_token updated be state between the stored values in the lockdrop contract and the balances in the Astro token contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Access nodes are not ltered when approving or setting default node",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/DelegatorManager.cdc:957 and 984, the admin can initialize an approved list of node operators or set a default node to stake using the initApprovedNodeIDList and setDefaultNodeIDToStake functions. However, no validation ensures the initialized or selected nodes are not access nodes. nodes access be Since cadence/contracts/standard/emulator/FlowIDTableStaking.cdc:1183-11 86, misconguring an access node as the default staking node prevents users from staking FLOW tokens and redeeming FLOW tokens instantly from the liquid staking contract. delegated cannot seen as to in This could happen when the admin calls setDefaultNodeIDToStake with an access node as the nodeID argument or during the advancing epoch phase in the filterApprovedNodeListOnEpochStart function at line 633. We consider this a minor issue since only the admin can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Migrate function does not enforce minimum staking amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/LiquidStaking.cdc:185, the migrate function does not check whether the delegated tokens are greater than or equal to the minimum staking amount. Unlike the stake functions precondition check in line 60, the validation is not enforced in the migrate function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Minimum staking amount and staking cap are not validated against each other",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/LiquidStakingConfig.cdc:100-108, the admin can set the minimum staking amount and staking cap for the liquid staking protocol. Since the minimum staking amount is expected to be lower than the staking cap and vice versa, misconguring the values would prevent users from staking their FLOW tokens due to cadence/contracts/LiquidStaking.cdc:60 and 62. there should be a precondition check to ensure the updated values are higher/lower than the other. Ideally, We consider this a minor issue since only the admin can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Trust dependency on admin keys",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/stFlowToken.cdc:121, the mintTokens functions access modier is set to access(account). Theoretically, the account owner can mint as many stFlow tokens as required by deploying a new contract that calls the mintTokens function or performing a contract upgrade that modies the access modier access(all) keywords. into pub or The possibility of the admin is malicious or the private key is compromised. With that said, both deploy and update contract actions will emit events that o-chain listeners can fetch, which are easily trackable and monitorable with tools. this happening is that",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Incorrect event emitted when admin modies isMigratingPaused conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "the cadence/contracts/LiquidStakingConfig.cdc:137, In the emitted ConfigStakingPause isMigratingPaused conguration. This is incorrect, as the ConfigMigratingPause event should be emitted instead. updates admin event when the is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Supply start index higher than the end index causes collectDelegatorsOnEpochStart to perform empty execution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/DelegatorManager.cdc:503, the while loop attempts to collect all delegators to the next epoch based on the provided start and end index. If the start indexs value is supplied higher than the end index, the loop will not execute, causing the collectDelegatorsOnEpochStart function to collect zero delegators.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. initApprovedNodeIDList gas consumption can be reduced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/DelegatorManager.cdc:962-964, the for loop attempts to insert the approvedNodeIDList dictionary with the nodeIDs argument key and value. This causes unnecessary gas consumption as the values can be set directly.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Distributing tokens to the same node operator yield no dierence",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In the cadence/contracts/DelegatorManager.cdc:826, transferCommittedTokens function allows a strategy bot to transfer committed tokens from one delegator to another. Since no validation ensures that fromNodeID and toNodeID are not the same node operator, the result of the execution would yield no dierence.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Typographic errors and duplicate comments found in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In several instances of the codebase, typographical errors were found along with duplicate code comments.  cadence/contracts/DelegatorManager.cdc:125 contains an additional protocol word at the end of the sentence  cadence/contracts/LiquidStakingConfig.cdc:13 contains a typographical error of minimum This aects the readability of the contracts.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. WithdrawLiquidity assets parameter is always expected to be empty",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-07-02 Audit Report - Astroport Tokenfactory LP Tokens v1.0.pdf",
        "body": "The WithdrawLiquidity message has been newly added to each pair. Previously, it was part of the periphery/liquidity_manager contract, which has been removed from the source code. For each pairs WithdrawLiquidity message, the assets parameter is expected, which is a vector of Asset objects. This parameter is mandatory. However, for example in contracts/pair/src/contract.rs:545 it is checked whether assets are empty. If so, the logic continues to execute the function. Otherwise, an error is returned. This is unintuitive because the user must send an empty vector each time to withdraw his liquidity, which is not a good practice and may lead to incorrect calls of the WithdrawLiquidity message.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Missing principal token maximum supply validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-22 Audit Report - Zodiac Protocol Core Extension v1.0.pdf",
        "body": "The osmo_bal_lockup_vault contract does not perform validation before storing input data in the principal_token_max_supply conguration eld. If a privileged user would by mistake or intentionally provide a very small or zero number, the contract would become unusable in practice. lack The contracts/osmosis/zodiac_osmo_bal_vault/src/contract.rs:97 conguration update in lines 647-649. validation during exists both of instantiation in and",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Unimplemented state migration for GENESIS_POOL_STATE and principal_token_max_supply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-22 Audit Report - Zodiac Protocol Core Extension v1.0.pdf",
        "body": "In contracts/osmosis/zodiac_osmo_bal_vault/src/state.rs:17 and 41, the GENESIS_POOL_STATE and principal_token_max_supply states are introduced to support deposit limit and pool state snapshot. However, in contracts/osmosis/zodiac_osmo_bal_vault/src/contract.rs:50 does not perform any state migration to support them. migration handler the Consequently, migrating the old zodiac_osmo_bal_vault contract to the current version will cause the contract to fail to work correctly due to serialization and deserialization storage errors. We classify this as a minor issue since it could impact existing deployments of previous versions of this contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Incoherence in TrackBeforeSend and BlockBeforeSend response attributes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-22 Audit Report - Zodiac Protocol Core Extension v1.0.pdf",
        "body": "In the contracts/osmosis/zodiac_osmo_bal_vault/src/contract.rs:195, Response generated for the TrackBeforeSend hook should be consistent with the one generated in the BlockBeforeSend hook. However, \"no-op\") attribute. the one returned in the TrackBeforeSend is missing the (\"action\",",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Usage of deprecated to_binary function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-22 Audit Report - Zodiac Protocol Core Extension v1.0.pdf",
        "body": "In contracts/osmosis/zodiac_osmo_factory/src/testing/integration.rs:1 4, packages/zodiac/src/utils.rs:170 and 176, the to_binary function is used to serialize data structures to JSON bytes. As the function is currently deprecated, its usage is not encouraged.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Usage of magic numbers decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-22 Audit Report - Zodiac Protocol Core Extension v1.0.pdf",
        "body": "Throughout the codebase, hard-coded number literals are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. A comprehensive list of hard-coded number literals has not been included in this report as many instances of 10000u32, 2, and 1 can be found in the contracts within scope.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Missing tax deduction in collectors swap, LLI farmings mint and the treasurys spend function will drain contracts funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-01-13 Audit Report - Levana Stage 1 - v1.0.pdf",
        "body": "The collector contracts swap function can deal with native and cw20 tokens. However, in the case of in take contracts/levana-collector/src/contract.rs:285. into account code does token, native taxes not the a Similarly, contracts/levana-lli-farming/src/contract.rs:353. farming contracts mint_lli function does not deduct the LLI taxes in Likewise, contracts/levana-treasury/src/contract.rs:62. taxes are not accounted for in the treasury contracts spend function in Failure to deduct taxes will mean that the contracts funds are slowly drained.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. A website viewed with the wallets' web browser can place arbitrary information in browser and wallet activity history",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The in-app browser allows a web page to send messages back to the application. A web-page can set any host, title url, and origin values which are later displayed in the browser and wallet activities histories. Moreover, a web page can set any arbitrary URL for its own entry in the browser history. This functionality opens possibilities for phishing attacks  a user might unknowingly navigate to a malicious URL by clicking on entries in the browser history. Additionally, the arbitrary URL set by a web page will be displayed in the wallet activities history if the web page has initiated web3 wallet transactions.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. The browser shows secure green lock icon next to URL even when the actual protocol is clear-text HTTP",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The in-app Browser always shows a green lock icon next to the URL being visited even if the is insecure HTTP. This can mislead users into thinking that a connection is used protocol encrypted, although it this issue for example through man-in-the-middle attacks or redirects to unencrypted versions of the site without the user noticing. is not. Attackers can exploit",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. It is possible to delete the wallet without providing a correct PIN",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "If an incorrect PIN is entered ten times, the application provides an option to delete the old wallet and create a new one. Since the wallet application does not require that access to a mobile device is secured by a PIN or biometric measures, a malicious actor can simply delete the wallet on a device.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Sensitive data may be logged",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The app uses Sentry for error tracking without any ltering of sensitive information. Because of that, sensitive data may be sent to external servers. If an attacker manages to get access to such a server (e.g., by compromising team members or vulnerabilities in the server), they may be able to access this data. Such attacks have happened in the past. In Cypher Wallets codebase, this could for instance happen to API tokens (in src/core/card.ts:15) or keystore information (in src/core/Keychain.tsx:107) which is included in a captured exception.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Insucient ENS name validation enables social engineering attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "Generally, it is a good idea to only allow ASCII-characters for ENS names because the same human-readable name may have multiple valid UTF-8 encodings. Attackers can abuse this to trick users into sending funds to unintended ENS names that they have registered. The following regex pattern is used in src/core/util.tsx to validate ENS names: /[-a-zA-Z0-9@:%._\\+~#=]{1,256 }\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)?/ig This pattern matches on partial strings in the middle and does not require that the whole checked string adheres to it. isValidEns will therefore return true if the string contains some non-ASCII characters in the beginning, as long as there is at least one ASCII character before the dot.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Sign-in requires signing an arbitrary message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "When using the Cypher Wallet the rst time, a sign-in to the CypherD API server is performed in the background. This sign-in requires signing a message fetched from the CypherD API server in src/core/globalContext.tsx:153. This is a security measure to ensure that the current user controls the wallet's public address. However, signing arbitrary messages can be harmful. For example, they can be used to steal funds from the user or perform malicious actions in the event of a compromised server. This issue is also observed in the following locations: - - src/containers/DebitCard/aptoCard.tsx:59 src/containers/InfoScreen/legalAgreement.tsx:44",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Outdated use of Facebook Conceal as the default secure storage option on Android",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The _setInternetCredentialsOptions function in src/core/Keychain.tsx:92 uses Facebook Conceal as the storage for the cipher. However, for Android API level 23+, the Android Keystore is the recommended storage option. Moreover, Shared Preferences together with the plain-text decryption key. in the case of Android before API level 23, an encrypted ciphertext is stored in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Injected JavaScript is not veried",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The WebView that is used in src/components/WebScreen.tsx injects the content of a JavaScript le that is loaded from the server public.cypherd.io before loading the content. However, this code is not veried in any way. An attacker that manages to control the server that is responsible for public.cypherd.io can therefore distribute malicious JavaScript that is executed before every page load.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Known vulnerabilities in dependencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "There are NPM packages with known vulnerabilities (which are shown when running npm audit). The output of npm audit indicates that 56 vulnerabilities were found in the audited packages. Of these vulnerabilities, 1 is rated as low, 14 are rated as moderate, 33 are rated as high, and 8 are rated as critical.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. The browser leaks wallet addresses to visited websites",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The in-app browser allows a web page to send messages back to the application. A web page can request user wallet addresses and this information will be provided to the web page automatically without user consent.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Users cannot set a PIN if biometrics are enabled",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The app only requires a PIN if logging in with biometric data is not activated on the device. This may be insucient for some use cases. For instance, a user that regularly shares their device may still want to set a PIN, even if they authenticate with their ngerprint or face scan.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. The Ethereum address of a user is sent to external platforms",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The Ethereum address of a user is passed as the user ID to Intercom through the Intercom.registerIdentifiedUser function. While this may make the handling of support requests easier, a user might not want to be associated with their Ethereum address, as this can result in a loss of anonymity.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Hard-coded Cosmos gas prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "the gas price for every supported chain is In src/constants/cosmosConfig.ts, hard-coded. This can lead to too high or too low gas prices. In the rst case, a user unnecessarily pays too much for a transaction. With too low gas prices, the transaction can be delayed and may fail.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. No pagination is used when querying APIs with a limit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "a of limit with The conguration in the le src/core/globalContext.tsx contains multiple API endpoints is initialGlobalState.rpcEndpoints.COSMOS.otherUrls.balance. Besides the balances key, this endpoint contains a key pagination that contains the next URL to query if the result is larger than the limit. However, this key is ignored and only the key balances is used in src/core/cosmosStaking.tsx. In rare edge cases where the queried address has a non-zero balance for over 1,000 coins, it can happen that the desired balance is not found because only the rst 1,000 results are considered. endpoint 1,000. such One",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. The seed phrase is shared insecurely between view navigations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "src/containers/Options/SecurityPrivacy.tsx:58 and In src/containers/OnBoarding/confirmSeedPhrase.tsx:16, the loaded recovery seed phrase is passed as a navigation parameter to the next screen view via the navigate function. This imposes a potential security issue, as the seed phrase is passed unencrypted to the next screen view and could be logged by an integrated tracking plugin (e.g., Sentry or Intercom).",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. PIN code length is limited to 4 digits",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "A PIN code is used to protect the wallet from unauthorized access on Android devices and as a fallback on iOS devices in case biometric authentication is unavailable. Setting a PIN code is implemented in src/containers/PinAuthetication/setPin.tsx:34. However, the PIN code length is limited to four digits, which is considered weak.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Small entered token fractions are incorrectly parsed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "Entering token fractions with a very small USD value leads to displaying an inated USD value due to the internal representation in scientic notation. For example, entering 0.00000001 MATIC tokens with a USD value of 1.2313863e-7 USD in the send token view incorrectly shows a USD value of 1.23 USD.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Number formatting is not using the users locale",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The Cypher Wallet does not use the decimal separator of the users current locale when entering numbers. This currently prevents entering numbers with a decimal separator other than a dot (e.g., German users may enter 1,5 instead of 1.5) and may lead to confusion. Besides misleading display issues, mobile device keyboards may have a xed decimal separator, and users might not be able to type the required decimal separator.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Static retry delay of 100ms for failed API HTTP requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "In src/core/Http.tsx, the axios library is congured with the axios-retry plugin to retry failed HTTP requests with a static delay of 100 milliseconds and a maximum of 5 retries. If the request fails, this could lead to a large number of requests in a short period of time, as well as insucient time for the server to recover.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Lack of stream status validation can be exploited to drain contract funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contracts finalize_stream function does not validate that the current streams status is not Status::Finalized. An attacker could exploit this by repeatedly calling the finalize_stream function to trigger Bankmsg::Send messages using the streams treasury as the beneciary. This results in transfers of both the creation denom and creators_revenue, drainting the contracts funds. A proof of concept test case can be found in the test case Faulty stream state validation lead to draining of funds in the appendix.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Stream status not saved after update allows contract funds being drained",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contracts finalize_stream function does save the new stream status after updating it in src/contract.rs:618-620. Consequently, the status will remain the same when calling the finalize_stream function again. Similarly to the issue Lack of stream state validation lead to draining of funds, this can be exploited by repeatedly calling finalize_stream to trigger Bankmsg::Send messages, which drains the contracts funds. The same proof of concept test case Faulty stream state validation lead to draining of funds in the appendix applies here.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Updating stream_creation_fee or stream_creation_denom will cause ongoing streams to error when nalized or canceled",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "constructed In the execute_finalize_stream and sudo_cancel_stream functions, the BankMsg is and config.stream_creation_denom. Both config values are only checked during stream creation, and any changes to these values after creation will impact streams that have not been nalized. This can cause inconsistent states and errors if the contract does not hold a sucient balance or the right denom to pay the fees. config.stream_creation_fee with suppose there are two non-nalized streams and the value of For example, config.stream_creation_fee is increased. Now the rst stream to nalize would spend a larger amount on fees than was contributed during the stream creation. This will result in the rst streams balance being too low to nalize the second stream. The functions in src/contract.rs:645 and src/killswitch.rs:272 send a and BankMsg config.stream_creation_denom. config.stream_creation_fee using",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Lack of conguration parameter validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract does not validate several conguration parameters upon instantiation in src/contract.rs:32-45 and in the sudo_update_config function in lines 794-803. The following parameters should be carefully reviewed:  stream_creation_denom: creation as it will fail to match. Incorrect casing of the denom could block stream  stream_creation_fee: If set to zero, it will render the mechanism ineective and may allow spamming/grieng.  exit_fee_percent: If set to a value greater than one, line 630 will underow and streams can never be nalized.  accepted_in_denom: Incorrect casing of the denom could block stream creation as it will fail to match. In addition, operational issues if the account gets compromised or the organization requires a change. it should be noted that protocol_admin is not updatable. This could cause Although some of the consequences outlined above could have a major impact on users, privileged functions are operated by informed users which are less prone to errors. Therefore, we classify this issue as minor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Exit fee percent validation diers from documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "included the following comment about exit_fee_percent The streamwap contract validation in src/contract.rs:31: exit fee percent can not be higher than 1 and must be greater than 0. Instead, the implementation allows the value to be less than one and greater than or equal to zero.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Stream creation parameters lack validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The creation of a stream in src/contract.rs:188 is lacking validation, which may lead to unintended consequences for stream creators. Firstly, there should be a validation to ensure that out_denom is not the same as in_denom. Secondly, out_supply should be validated to ensure it is not 0. While fund amount cannot be 0 in Cosmos SDK messages, if out_denom == config.stream_creation_denom the amount of out_supply specied in line 164 could be 0 and still pass the validation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Stream actions performed at streams end time may introduce unintended consequences",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract allows for the following messages to be executed at the streams end_time:  ExecuteMsg::Subscribe,  ExecuteMsg::Withdraw,  ExecuteMsg::ExitStream, and  ExecuteMsg::PauseStream. This is problematic since it can lead to inconsistent states. in the current For example, the end_time blocktime. This could introduce a scenario similar to the one described in the Unspent tokens could be locked in the contract upon exit nding. implementation, a caller can subscribe at Although no clear exploitation path have been identied, the current implementation is error-prone.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of best-eort validation on stream name and URL",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract does not perform any validation on the name and url elds of newly created streams in src/contract.rs:189 and 190. Although this does not have direct security related implications, these elds could be used to orchestrate phishing campaigns against unsuspecting users. Also, the name eld could be deliberately set by an attacker to confuse users, for example by setting it as an empty or very lengthy string.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Unspent tokens could be locked in the contract upon exit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The documentation on the execute_exit_stream function reads that it should withdraw purchased tokens to his account, and claim unspent tokens. However, the implementation only withdraws the users purchased tokens but does not check for and claim any unspent tokens. The potential impact could be considered to be major or even critical, given that a users tokens could get locked forever in the contract, but no scenario was found where the in_token amount could be greater than zero when exiting a stream. We have raised this issue as informational as, although not having found a clear exploitation path, potential edge cases may arise with future updates to the contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Lack of action along executed messages event attributes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract is lacking additional event attributes labeled as action on some of its entry points responses. The functions in the following lines were aected:  src/contract.rs:59  src/killswitch.rs:167, 201, 235, and 278 Although not a security issue, some o-chain components may rely on this kind of information being broadcasted upon successful execution of a contracts message handler.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Optimization possible on multiple code paths",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract currently contains minor ineciencies. While none of these issues pose a security concern, they should be addressed to further optimize the codebase. For example, when a user attempts to withdraw an amount of zero. The following functionalities can be reviewed for inecient code paths:  In src/contract.rs:266-273, updates on out_remaining and dist_index could be included in the if statement inline 276, as both will be left unchanged when the new_distribute_balance is zero. the  In src/contract.rs:295, it is inecient to include the case where the numerator is zero.  In src/contract.rs:499-501, the code never executes, as line 497 already uses info.sender to load the position. Therefore, position.owner will always be equal to info.sender.  In src/contract.rs:554, it is inecient to raise an error if withdraw_amount is equal to zero.  In src/killswitch.rs:46, it is inecient to raise an error if withdraw_amount is equal to zero.  In src/killswitch.rs:256, the assignment is redundant as the variable was already updated and saved to storage in lines 256-254.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Custom access controls implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract implements custom access controls. Although no instances of broken controls or bypasses have been found, using a single assert function to validate readability and controls maintainability. risks while improving the codebases reduces potential",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Misleading error messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract includes several custom errors in src/error.rs:38, 44, 77, and 104 that raise misleading or non-meaningful information to the user. In addition, descriptive of the actual situation. the NoFundsSent custom error raised in src/contract.rs:184 is not",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "contracts/pf-dca/Cargo.toml does not enable overflow-checks for the release prole. While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Additional funds sent to the contract are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "the transaction includes In src/contract.rs:160-187, during stream creation, checks are performed that ensure two Coins with the expected out_denom and that stream_creation_denom eld (one Coin with stream_creation_denom eld if both out_denom and stream_creation_denom are the same). This validation does not ensure that no other native tokens are sent though, and any additional native tokens are not returned to the user, so they will be stuck in the contract forever. While blockchains generally do not protect users from sending funds to wrong accounts, reverting extra funds increases the user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Pools with big but dierent token amounts allow attackers to extract free value with minimal cost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "For big amounts of tokens in the oer and ask pools with dierent token values, the calc_out_given_in function in contracts/terraswap_pair/src/math.rs:11 applies rounding, which opens a way for an attacker to extract value from a pool with a very small cost. imagine a pool with 5_000_000_000_000 A tokens, and a pool with As an example, 1_000_000_000 B tokens, with both weights set to 1 for simplicity. If a user now sends 1 B token, we expect the user to get 5_000 A tokens back. When a user sends 1 A token, we expect the user to get 0 B tokens back (actually 0.0002, but since we are dealing with integers here, the remainder will be dropped). The current implementation incorrectly returns 1 B token though. Imagine further that the value of 1 B token is 5_000 USD, and the value of 1 A token is 1 USD, an attacker can now get a risk free return of around 4_999 USD (minus transaction fees) per transaction. If the attacker repeats this attack, they will be able to drain the pool. Even worse, whenever the attacker shifts the balance enough, other arbitrageurs will be able to extract value by bringing the pool back to the 5_000 to 1 ratio, allowing the attacker to repeat the attack from where they started. Here is a failing test case demonstrating the example: #[test] fn compute_swap_rounding() { let offer_pool = Uint128::from(5_000_000_000_000_u128); let offer_weight = FixedFloat::from_num(1); let ask_pool = Uint128::from( ); let ask_weight = FixedFloat::from_num(1); let offer_amount = Uint128::from(1_u128); let return_amount = Uint128::from(0_u128); let spread_amount = Uint128::from(0_u128); let commission_amount = Uint128::from(0_u128); assert_eq!( compute_swap(offer_pool, offer_weight, ask_pool, ask_weight, offer_amount), Ok((return_amount, spread_amount, commission_amount)) ); }",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Duplicate storage in two contracts could lead to inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "i. e. asset_infos, Both factory and pair contracts store the information about pairs, in contract_addr, and in contracts/terraswap_factory/src/state.rs:19 contracts/terraswap_pair/src/state.rs:4. This duplicate storage might lead to inconsistencies between the two contract states. liquidity_token, start_time end_time, and",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Migration of the pair contract is disabled",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "In the Instantiate message for the pair contract, the admin eld is set to None in contracts/terraswap_factory/src/contract.rs:149. This that pair contracts cannot be migrated. implies",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. A pairs asset infos are no longer stored sorted which might break other contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "of the In the last version of TerraSwap LBP, the asset_infos stored in the FactoryPairInfo struct in is no contracts/terraswap_factory/src/contract.rs:139 were sorted. That longer the case. That change is not a problem for the audited contracts, since they use a pair_key helper function that generates a key based on the sorted asset_infos. This change, however, might break other contracts that depend on the previous design of stored sorted asset_infos. contract factory",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Unnecessary sub-messages introduce complexity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "Most contract interactions in the codebase are utilizing sub-messages, which have been introduced to Terra with the Columbus-5 upgrade. Sub-messages have been added to allow processing of the result of a call, for example, to handle errors. If the result of a call is not processed, regular messages should be used. There is no security concern in the usage of sub-messages, since they currently use the ReplyOn::Never value which causes a failure to propagate to the caller. Unnecessary usage of sub-messages can be found in:  contracts/terraswap_factory/src/contract.rs:33, 145 and 172  contracts/terraswap_pair/src/contract.rs:73, 101, 259, 307, 360, 370, 381 and 492  contracts/terraswap_router/src/contract.rs:117 and 141  contracts/terraswap_router/src/operations.rs:45, 59 and 97",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Contract name is not unique",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "In contracts/terraswap_token/src/contract.rs:16, the contract name from the CW20 base contract is used in the following string declaration: const CONTRACT_NAME: &str = \"crates.io:cw20-base\";",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Pair contract registration message in factory can be replaced with sub-message reply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "In contracts/terraswap_factory/src/contract.rs:156, a hook pattern is used to register the newly created pairs contract address in the factory. That pattern requires an exposed Register message type in the factory contract. Sub-messages have been introduced with the Columbus 5 upgrade of Terra to allow the processing of a reply without the need to expose a public message handler.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Post initialize message in pair contract can be replaced with sub-message reply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "In contracts/terraswap_pair/src/contract.rs:86, a hook pattern is used to set the newly created liquidity token contract address in the pair contracts cong. That pattern requires an exposed PostInitialize message type in the pair contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. The moving average time limit can be incorrectly set to zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "In contracts/pair_concentrated/src/const.rs:49, the boundaries of the moving average time limit are dened as an including range between zero seconds and a week. since is However, contracts/pair_concentrated/src/state.rs:304 and it can be set to zero, could cause a division by zero error. ma_half_time denominator used the as in it",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Factory contracts ownership transfer freezes pair contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "During the handling of ExecuteMsg, the migration_check function dened in contracts/pair_concentrated/src/contract.rs:215-218 ensures that there is no pending ownership transfer in the factory contract. When the factorys new owner accepts their role by executing the ClaimOwnership message, all registered pairs are added to the PAIRS_TO_MIGRATE vector. When a pair is in this vector, the migration_check function returns an error and all the pair operations are disabled. The factorys new owner can then reactivate pairs by executing the MarkAsMigrated message. This implies that all pair operations will fail while even just one pair is not yet migrated. Such a situation may be caused by a migration issue or a compromise of the factory contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Unnecessary nested loops when initializing cumulative prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "When instantiating the contract, the cumulative price vector is initialized with default values in contracts/pair_concentrated/src/contract.rs:80-84. Within two nested loops, it is then veried that assets are not duplicated before pushing them to the relevant vector. As there can only be two assets, the usage of nested loops is unnecessary, increases code complexity, and reduces readability.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Incorrect error message for CW20 token swap",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "a Swap in operation When contracts/pair_concentrated/src/contract.rs:243-245, offer_asset is validated to not be a CW20 token. If it is, an incorrect ContractError::Unauthorized error is returned. performed is This provides a poor user experience as it may be dicult for users to identify the source of the error when executing a swap transaction with a non-native asset.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Unsafe math usage could lead to division by zero error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "The query_compute_d function is used to compute the current pool D value by invoking Calc_d and newton_d functions. However, if the pool has no liquidity yet (i. e. before the rst use of provide_liquidity), a division in contracts/pair_concentrated/math/math-decimal.rs:65. occur error zero can by A test case showcasing this issue is provided in the Appendix.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Unclear error message for a single-sided initial deposit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "The contract does not allow the rst deposit to be a single-sided one by returning an in only InvalidZeroAmount contracts/pair_concentrated/src/contract.rs:414-415. provided asset error one is if However, understanding why their liquidity provision is not successful. this error message is not self explanatory and may prevent a user from",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Unnecessary tax deductions are performed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "performing When packages/astroport/src/asset.rs:92. tokens native transfers tax deductions are performed in However, calculations. the function to compute tax always returns zero instead of performing actual",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Validation can be performed earlier",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "there is a check that In contracts/pair_concentrated/src/contract.rs:59, prevents the code from running if the amount of assets provided in msg.msg_info is dierent waom two. Since this information is always available, check_asset_infos and potentially abort the execution early to save resources. this check can be done before calling in contracts/pair_concentrated/src/contract.rs:377, the check for Similarly, invalid number of assets can be done before querying the pools and running check_assets.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Mismatch between comments and code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "In contracts/pair_concentrated/src/state.rs:261, the get_amp_gamma function state that the parameters stored in the future parameters will be returned in case the block time is greater than the value in self.future_time. the comments for However, parameters are also returned if the block time is equal to the self.future_time. contracts/pair_concentrated/src/state.rs:264, in the future",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Arithmetic operations can be optimized",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "In contracts/pair_concentrated/src/utils.rs:291, in order to get the index of ask_ind, a subtraction is performed. Given that ask_ind can be either 0 or 1, this is not the most ecient way to compute a bit ip. In contracts/pair_concentrated/src/utils.rs:415, a sum of two dierences is calculated to get to the the deviation, which is dened as the sum of the distances between the value of two deposits and the average deposit value. Given that there are only two elements, this computation is not ecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Duplicated fee address checks during Swap",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "During the handling of Swap messages, fee_address is provided. there are multiple checks to ensure that the In contracts/pair_concentrated/src/contract.rs:747, an explicit check is made but it is not required since the check in line 748 depends on the logic in line 702 that already validated the existence of the fee address.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. addr with a length that is not a multiple of 0x20 may lead to incorrect results",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "contracts/v0.8/PrecompilesAPI.sol:33, In the resolveAddress function, the provided addr length should be a multiple of 0x20, but a user can provide any arbitrary length of bytes as input and there is a possibility that the user will receive incorrect output because the current code does not validate the length of the provided addr param. execution of during the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Address lookup via PrecompilesAPI.lookupAddress fails due to incorrect memory access",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "PrecompilesAPI.lookupAddress The in contracts/v0.8/PrecompilesAPI.sol uses Yul to call the lookup_address FEVM precompile. However, accessed by using mload(actor_id) instead of using a xed length of 32 bytes. mload loads a word from memory at the given address. actor_id is a static variable of the type uint64, not a memory pointer. This leads to incorrect memory access. the actor_id length is incorrectly function library The same issue is present in the PrecompilesAPI.getActorType function in line 73.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Hardcoded outputSize results in data loss during a delegatecall",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "contracts/v0.8/utils/Actor.sol:87, In MAX_RAW_RESPONSE_SIZE parameter is used to restrict the outputSize of the delegatecall Yul instruction, while FVM actors can return data sizes greater than 0x300. Due to the hardcoded output length, the return data is truncated, resulting in unexpected behavior of the call function. the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Hardcoded GAS_LIMIT used to call precompiles may lead to gas exhaustion",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "The library uses a GAS_LIMIT constant to specify the maximum amount of gas a precompile can consume. The actual gas consumption depends on the actual FEVM implementation, which may change over time. This makes it impossible to predict the Actor.call precompile execution gas cost, and hence with a hardcoded GAS_LIMIT, the precompile call could run out of gas.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing sanity check for codec value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "According to the comment in contracts/v0.8/utils/Actor.sol:49, codec should always be cbor. However, the user can provide any codec, while the Solidity code assumes it to be cbor. Without validation of the codec parameter, there is potential for incorrect results if the FEVM returns a response that is encoded with a dierent codec than cbor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Calling the actor precompile conceals the revert reason",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "The Actor library in contracts/v0.8/utils/Actor.sol performs a delegatecall to the actor precompile. However, in the event of a revert, the revert reason is suppressed and not returned. This could negatively impact the developer and user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Meta transactions can be replayed across contracts and networks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "Currently, the implementation of meta transactions does not verify the contract and network of the transaction. As a result of this, it is possible to replay a meta transaction in dierent contracts such as Alice Terra tokens for UST and EUT and networks such as testnet or mainnet. That could lead to double-spending.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Execute deposit stable function uses relayers funds instead of users funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "When a user attempts to deposit funds into Anchor protocol, the request originates from execute_relay into execute_deposit_stable due to meta transactions. In relay.rs:63-65, the relayer attempts to execute the request as the user via mutating info.sender which then executes the message in line 81. as When the operation continues to execute_deposit_stable, the request will see Since funds. info.funds info.sender execute_deposit_stable determines the fund amount via checking info.funds (execute.rs:94-99), this would cause the relayers funds to be deposited into Anchor instead of the users funds. user while relayers are the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Anchor exchange rate used might be out of date due to missing block height argument",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "The Anchor exchange rate is queried from the Anchor contracts, through the utility function in compute_exchange_rate contracts/alice_terra_token/src/utils.rs. However, no block height argument is supplied. Without the block height argument, Anchor returns a raw exchange rate from stored values without accruing interest since the last update, which means an outdated exchange rate is returned. Using this value could lead to slightly incorrect calculations. dened",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Missing validation during instantiate phase allows fee_ratio to be over 100%",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "fee_ratio is the percentage of fees Alice protocol would receive from user yields. During the instantiation phase (alice_terra_token/src/contract.rs:50) and migration phase (contract.rs:141) ,  there is no validation to ensure the ratio should be 0-100%.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Sent tokens other than in stable denom are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "During execute_deposit_stable and execute_deposit_stable_authorized, the users uusd funds are processed and deposited to Anchor protocol. If the user deposited additional tokens (other than uusd), the funds would get stuck in the contract after the operation succeeds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Querying registered contracts in Overseer is unbounded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "RegisteredContracts in The alice_overseer/src/contract.rs, which could cause calling transactions to run out of gas. Even if it is unlikely that there would be enough registered contracts to make the query out of gas, since registered contracts cannot be removed an out-of-gas situation could be irreversible. unbounded message query is",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. execute_redeem_stable returned amount might be dierent from actual amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "The execute_redeem_stable function requests a stable denom amount and then returns a calculated amount to the user. The returned value may be dierent from the actual returned amount due to possible slashing penalties, fees, taxes etc.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. aTerra exchange rate is queried twice during execute_redeem_stable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "functions The and query_aterra_exchange_rate both query aTerra exchange rate individually. During execute_redeem_stable, both functions are used to retrieve the aTerra exchange rate in alice_terra_token/src/execute.rs:163 and 165 which is inecient. compute_and_update_exchange_rate",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Vault deposits are not aected by delisted coins",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "In contracts/credit-manager/src/health.rs:160, when a coin is delisted, the LTV is set to zero. However, vault deposits of the delisted coin are not aected, as seen in lines 100-128. Consequently, users can maintain the collateral value of coins deposited prior to delisting. They could even time an attack based on the previous LTV by frontrunning the delist transaction or entering a vault when an announcement to delist a specic coin is published. For example, suppose ATOM is to be delisted by the Mars team. A borrower notices it and enters a locked vault that accepts ATOM as a base deposit. Despite ATOM being delisted, the borrowers collateral in the form of vault tokens still contributes to the overall LTV. The borrower can execute the RequestVaultUnlock message to convert the vault tokens back to ATOM, contributing to the total collateral value using the red banks LTV. Additionally, the client also identied that delisted vaults still contribute to the total collateral value. We classify this issue as major because this aects the correct functioning of the overall system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. account-nfts contract UpdateConfig message cannot be executed after the minter role is transferred to credit-manager",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "The comment in contracts/account-nft/src/msg/instantiate.rs:22-24 states that the minter role will be transferred to the credit-manager contract. However, the the account-nfts credit-manager contract has no message dened to call UpdateConfig, and that implies proposed_new_minter conguration values can no longer be updated once the ownership has been transferred. max_value_for_burn which the We classify this issue as major because this aects the correct functioning of the overall system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Allowing deposit or duplicate vault tokens may cause unexpected outcomes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "In the contracts/credit-manager/src/vault/utils.rs:92-101, rover_vault_balance_value function queries the balance of vault tokens to calculate the tokens value. However, there is no validation to ensure the contract owner does not congure the vault token as allowed coins or that the congured vaults do not contain duplicate token denoms. This is problematic because either of the above would cause the queried balance to include user deposits or other vault balances, causing the following functions to return a greater amount than expected:  vault_utilization_in_deposit_cap_denom  query_all_total_vault_coin_balances  query_total_vault_coin_balance  assert_deposit_is_under_cap As a result, the rst three functions would return incorrect information to users, while the last function would potentially cause a denial of service due to an AboveVaultDepositCap error when users try to deposit into vaults. Please see the test_duplicate_vault_tokens test case to reproduce this issue. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Transactions including ProvideLiquidity or WithdrawLiquidity actions may run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "In contracts/credit-manager/src/zap.rs:16 and 55, the provide_liquidity and withdraw_liquidity functions could trigger a large number of sub-messages that may consume the transactions entire gas. Those actions send a message to the zapper contract in order to execute a trade on osmosis and then return liquidity pool tokens and remainder coins to the recipient. To achieve this, they have to send a sub-message to osmosis for the trade and (n+1) ReturnCoin sub-messages - where n is the number of coins. Additionally, for each of the sub-messages, a Bank message is created. Since ProvideLiquidity and WithdrawLiquidity actions are only a part of the transaction, the transaction will also include AssertOneVaultPositionOnly and AssertBelowMaxLTV callbacks, which may consume an excessive amount of gas.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Coin whitelist update may run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "the UpdateConfig In contracts/credit-manager/src/update_config.rs:45, message handler clears all the ALLOWED_COINS map entries and then inserts all new coins provided in the message into the map. Since this operation requires iterating on both the stored and the proposed whitelists in order to perform the update, the execution may run out of gas if the number of elements in the whitelist is signicant.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Use of magic numbers decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "Throughout the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. Instances of magic numbers are listed below:  contracts/zapper/base/src/contract.rs:113  contracts/zapper/base/src/contract.rs:159  contracts/account-nft/src/contract.rs:36",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Dependency on unreleased node version",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "The current codebase includes a x for spot price queries from Osmosis GAMMs in packages/chains/src/helpers.rs:73-76. However, at the time of writing, the x made in the node client is still unreleased. We classify this issue as informational as it is not expected that these contracts will be deployed prior to the x being released.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Proposed new minter cannot be removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "there are no handlers In contracts/account-nft/src/contract.rs:67-77, exposed to remove the proposed_new_minter from the contract storage. This is problematic because if the pending minter does not intend to accept the role, the current minter cannot set the value back to None. We classify this issue as informational because the contract minter can still overwrite the minter back to the current contract addresses, which is equivalent to an empty proposed new minter.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Withdrawing liquidity requires the coin to be whitelisted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "In contracts/credit-manager/src/zap.rs:61 and 79, the liquidity pool token and withdrawn liquidity are validated to be whitelisted. In the delisting logic pull request, one of the changes allows the withdrawal of assets that are not included in the whitelisted assets. However, this is not applied when withdrawing liquidity tokens.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Signatures can be replayed across dierent chains, networks, and contract addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/contract.rs:247-254, the weighted_batch_vote function constructs the message for signature verication without including the chain ID and the contract address. This is problematic because signatures that are intended for dierent chains or contracts can be replayed, potentially bypassing the backend servers signature validation. The impact of the issue depends on what signatures can be replayed. Fundamentally, the following bypasses can happen:  A user can vote and donate to round IDs they are not allowed to.  A user can vote and donate to projects they are not allowed to.  A user can donate a dierent amount to projects they are not allowed to.  A user can vote with a larger vcDORA amount they should not because they did not stake the required amount of DORA tokens. To x this issue, the chain ID and the contract address need to be included to ensure signatures cannot be replayed across dierent blockchains and deployments. Adding the chain ID to the signed message prevents replaying across dierent blockchains, as well as across testnets and mainnet. During the development phase, test messages may be created for the testnet to verify the signature validation works as expected. Without a chain ID added to the message, these messages can be replayed on the mainnet. For example, a signed message with a large vcDORA value used on the testnet can be replayed to the mainnet to manipulate voting results. Additionally, the missing chain ID from signed messages could also cause issues when dierent chains use the same Bech32 prex, such as Terra and Terra Classic. Since both chains use the same prex, a signature that is intended for the former chain can be replayed on the latter chain. This can also aect future chains that go through a hard fork and end up with the same Bech32 prex. Including the contract address as part of the signed message prevents replaying across dierent contracts. If two or more versions of the contracts are deployed, a signature over a message without the contract address can be replayed on another contract.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Signatures can be replayed within one hour before expiration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/contract.rs:257, the weighted_batch_vote function validates the signature is not expired as long the timestamp has not exceeded an hour. This is problematic because the signature can be replayed multiple times within the one-hour period. Consequently, voters can repeatedly donate the same amount of funds to their projects after the backend server signs the message, manipulating the voting results. We classify this issue as major because replaying a signature requires voters to donate funds to the protocol.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Quadratic funding taxation is not incentive-compatible",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In mechanism design and game theory, the incentive-compatible (IC) mechanism is one that guarantees every participant can achieve the best outcome for themselves by acting according to their true preferences, such as voting for their preferred projects However, the documented Grant Funding Distribution Algorithm (Progressive Tax V2) is not incentive-compatible. This becomes evident by studying two exemplary scenarios involving four projects with distinct values, all of which are far from the mean:  Project #1: the top project.  Project #2: above average.  Project #3: below average.  Project #4: least number of votes. In the rst scenario, no redistribution occurs because the gap is exactly the desired gap. Based on the documentation, if s is greater than 1, then V_max / V_min is already smaller than R, meaning the results will not change. In the second scenario, let's assume it continues from the rst scenario, and the top project receives a marginally small contribution. As documented, this can cause a signicant shift of all projects, including the middle ones, towards the mean/average. Consequently, voters who favor the third or fourth projects will be better o voting for the rst project to trigger a redistribution, thereby manipulating the results instead of voting for their real preferences. Conversely, voters who favor the top and second projects can vote for the project with the least votes to prevent redistribution from taxation. Both cases demonstrate that the voters are not voting for their actual preferred projects. the redistribution is computed o-chain after the admin withdraws the Furthermore, donations. This means voters are incentivized to wait until the last seconds before admin withdrawal because the optimal strategy depends on the votes of all other voters.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Incorrect voting calculation due to hardcoded decimals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/contract.rs:278, the weighted_batch_vote function declares a hardcoded DECIMALS value of 18, representing the decimals of INJ token and later divided in line 281 as part of the vote calculation. This is problematic because the decimal values will be incorrect for other tokens, such as IBC tokens and token factory denoms. if one of these tokens is selected for the round (see line 149), the vote Consequently, calculation will be incorrect. Moreover, due to the nature of integer division, the votes can round to zero. We classify this issue as minor because it can only be caused by the admins, which is a privileged role.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Rounds can be arbitrarily ended by the admins",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "The end_round function in src/contract.rs:371-397 allows admins to update a round to the RoundStatus::Finished status. However, no conditions are being enforced before ending the round. Consequently, admins can maliciously close a round when the votes are in favor of their preferred option or accidentally end a round earlier than intended. We classify this issue as minor because it can only be caused by an admin, which is a privileged role.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Lack of input validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In several instances of the codebase, validations are not performed suciently:  In src/contract.rs:45, the admins vector is not validated to have at least one entry. If the vector is empty, there will be no admins controlling the contract, locking the main functionalities of the protocol and rendering it unusable. Consider returning an error if the vector is empty.  In src/contract.rs:149, the donation_denom string is not validated as an existing native token. This would cause the weighted_batch_vote function to fail in line 325, preventing users from voting on projects. Consider querying the total supply of the denom to ensure it exists.  In src/contract.rs:150, misconguring a voting_unit of zero causes all votes computed to become zero regardless of the donation amount, as seen in line 281. Consider returning an error if the value is zero.  In src/contract.rs:156 and 415, the public key is not validated to have a length of 65, which causes the public key comparison validation to fail in line 262. Consider validating pubkey.len() to be 65.  In src/contract.rs:270, no validation ensures the project_ids and amounts vectors have equal lengths and are not empty, which causes an out-of-bounds and InvalidAmount error, respectively. Consider returning an error early if this is the case.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Empty public keys congured allow users to inate the vcDORA amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/contract.rs:243, the weighted_batch_vote function validates the vcDORA amount signed by the backend server if the round.pubkey length is not zero. This validation is important because the vcDORA amount represents the governance credit issued to DORA token stakers, which is computed and veried as part of the message signature in line 261. In this case, the signature The issue occurs when the round.pubkey is set to zero. validation will not be performed, allowing voters to specify a large value of vcDORA to inate the area_diff calculation in line 312, ultimately aecting the quadratic funding result computed o-chain. Consequently, voters can manipulate voting results. This can happen due to a misconguration or ill-intended admin that sets the public key to an empty value because there is no proper validation in place, as detailed in the Lack of input validation issue. We classify this issue as minor because it can only be caused by an admin, which is a privileged role.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Updating the public key for completed voting rounds causes incorrect state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/contract.rs:415, the set_pubkey function updates the public key for a voting round. However, no validation ensures the voting round is RoundStatus::Voting. If the admin updates the public key to a dierent value for RoundStatus::Finished and RoundStatus::Withdrawn, users who query the voting rounds (see line 72) will be misled that the new public key is used during the actual voting period, which is incorrect. We classify this issue as minor because it can only be caused by an admin, which is a privileged role.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Contracts should implement dierent admin roles and admin removals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "The contracts within the scope of this audit allow multiple admins that can add more admins, and all admins have the same privileges. It is best practice to separate admin functionality into dierent roles with limited privileges. Additionally, there is no entry point to remove admins. Consequently, there is a risk that old admin accounts get compromised when an admin is no longer on duty for the protocol, potentially leading to a loss of funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. No entry point for banning projects",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "the   ProjectStatus enum implements the OK and Banned In src/state.rs:15, variants. However, there is no entry point for the admins to update the project status to Banned. The weighted_batch_vote function also does not ensure the project is not banned when voting. Consequently, projects that are found malicious cannot be banned and can still be voted on as well as donated to.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Zero votes round cannot be marked as withdrawn",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/contract.rs:450, the withdraw function tries to distribute all donation funds to the admin for a specic round. An edge case is that the round.total_amounts variable will be zero, causing the transaction to fail because Cosmos SDK does not allow zero-amount native token transfers. there are no donations, if Consequently, the voting round cannot be updated to RoundStatus::Withdrawn status, causing it to always remain at RoundStatus::Finished status.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Centralization risk when withdrawing project donations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/contract.rs:449, the withdraw function distributes the donations of funded projects to the admin. This is a centralization risk, particularly because there can be multiple admins that cannot be removed. It is best practice to send funds either to a custodian contract or to the project owner's address directly.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Usage of magic numbers decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "Throughout the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers cannot understand their use easily and may make inconsistent changes across the codebase. Instances of magic numbers are listed below:  src/contract.rs:257, 266, 308-309, 312  src/helper.rs:14, 20",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Overpaying funds will cause donations to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/contract.rs:325-333, the weighted_batch_vote function ensures the voters supply the exact amount of funds according to their votes. Otherwise, the transaction will revert with an error. This may decrease the user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Authorization check can be modularized into a function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "contracts within as The src/contract.rs:106-110. Although no issues with access control have been found, using a single assert function to validate authorization reduces potential risks while improving the codebases readability and maintainability. custom access implement controls, scope such",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Limitations on base two logarithm implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/helper.rs:2-25, the log2_u64_with_decimal function implements a custom version of a base two logarithm. However, there are issues with its current implementation:  The function returns 0 for the base 0 logarithm, which is incorrect because the result run reproduce please value. this, To should an log2_u64_with_decimal(0). undened be  The function does not correctly handle all values of u64. An overow error will trigger during multiplication if a large value is provided. To reproduce this error, please run log2_u64_with_decimal(7259549383510990226).",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Small donations will not increase user votes due to rounding",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "the weighted_batch_vote function computes votes by In src/contract.rs:281, multiplying the donation amount by the voting unit and dividing the result by the decimal values. The voting unit is used to limit the minimum unit allowed for voting. However, if the user donates less than the minimum voting amount, the votes computed will be zero due to rounding, causing a zero increase in the project and user votes.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Setting total supply incorrectly when registering a beta invitation will lead to failures when claiming and distributing tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:203-209 of the beta-game-launcher repository, the total supply value is not validated to be higher than the total required amount as seen in lines 398-407 and lines 526-535. If the total supply value is set to be lower than required, it would cause claim, token_distribute, or both to fail due to minting capacity reaching the maximum. This will cause users to be unable to claim their shares of game and fan tokens. Likewise, the admin would be unable to distribute main and game tokens to recipients, causing a loss of funds for the users and recipients.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Updating main token address may cause state inconsistency",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:146-148 of the beta-game-launcher repository, the address of the main token can be updated to a dierent value. If the main token address is updated while the contract has an existing config.main_token value, it would cause an inconsistency between the contracts state and the actual token balance held in the contract. As a result, this would cause a series of problems such as users being unable to withdraw their tokens due to insucient contract balance.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Decimals are not accounted for in calculation of main_token_amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "the beta-game-launcher repository, In contract/src/execute.rs:300 of the buy_amount is multiplied by the invitation_price to ensure that sucient main_token and main_token is invitation_price can have dierent numbers of decimal places, the calculation may be performed incorrectly. This could lead to a user being able to purchase at a lower price than expected. supplied. However, the game_token, as",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Equal value of sold amount and soft cap causes inconsistent evaluation of condition",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:371-373 of the beta-game-launcher repository, the claim function would evaluate passed as true only if the sold amount is higher than the soft cap value. This is inconsistent with the token_distribute functionality as seen in lines 508-510 since the execution would continue if the sold amount is equal to or greater than the soft cap value. In an edge case where both the sold amount and the soft cap value are equal, the claim function would determine the invitation as a failure but the token_distribute function would determine the invitation as a success. In a worst-case scenario, the users funds would be incorrectly distributed to the recipients which might cause slow users unable to have their funds refunded back due to insucient balance held in the contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Missing validation on main_token_distributions during update cong",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:154-156 of the beta-game-launcher repository, the distribution values in main_token_distributions are not validated as seen in lines 27-36. This means that theres a possibility that the sum of the distribution rate can be over 100%, potentially causing the token_distribute function in lines 515-524 to either distribute more funds than intended or fail due to insucient funds. We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Duplicate accounts creation would inate token total supply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In src/contract.rs:63-71 of the cw20 repository, duplicate accounts are not veried when creating initial accounts during the contract instantiation phase. If the same account address is passed twice in create_accounts, the accounts balance would be overwritten via BALANCES.save but total_supply would still record the balance amount of both. As a result, the tokens total supply would be inated. We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Owner and main_token addresses are not validated during instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:20 of the beta-game-launcher repository, during the handling of the Instantiate message, owner and main_token addresses are not validated. This may cause the contract to be initialized with invalid values. This issue is also present during the cong update phase in lines 146-152.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. cw20 is based on a legacy version of the CW20 standard",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In the cw20 repository there is a legacy implementation of cw20 token. As stated in that implementation repository :1 This contract is modied for the purpose of migration from a Columbus-4 cw20 token contract to Columbus-5. Using the ocial version of cw20 is strongly recommended for other usages Unlike the latest version, the legacy version does not support the marketing eld which is required in contract/src/execute.rs in lines 254-277. As a result, using the legacy version of CW20 token code id would cause register_beta_invitation functionality to fail due to the dierences between the latest CW20 contract token interface and the one used in this contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Incorrect contract name in cw20",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In src/contract.rs:21 of the cw20 contract, the CONTRACT_NAME is set equal to crates.io:cw20-base. This is the template contract name of the CW20 contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Centralization of NFT unlocking",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:95-98 of the lock-nft repository, only the owner of the contract can unlock users NFTs and return them back to them. If the owner key is compromised, the remaining locked NFTs in the contract will be inaccessible.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Admin operations implement custom logic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In all contracts there is the concept of Admin, which is an account that has exclusive permissions to execute some messages. As there is already a battle-tested implementation of this that takes care of validation and its ready out of the box, it should be better to use that one instead of using custom logic.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. No error message for query of non-existent token",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/query.rs:28-35 of the lock-nft repository, users can query the owner of a token using an nft_address and token_id as the key. In the case that there is no token with such a key an empty string is returned as the owner. This leads to a worsened user experience as incorrect queries cannot be easily diagnosed.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  lock-nft/contract/cargo.toml  beta-game-launcher/contract/cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Canonical address transformations are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "While previously recommended as a best practice, usage of canonical addresses for storage is no longer encouraged. The background is that canonical addresses are no longer stored in a canonical Additionally, the codebase is more complicated with address transformations. format, so the transformation just adds overhead without much benet.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Typographical errors found in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs of the beta-game-launcher repository, there were several typographical errors found in lines 35-301. Specically, the word queal should be replaced with equal while the word worng should be replaced with wrong.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Excess liquidity pool tokens are never refunded to the user",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/vault/src/contract.rs:1084, excess liquidity pool tokens are refunded to the caller. However, the recipient should be cw20_msg.sender instead of info.sender, which represents the liquidity pool token itself instead of the original sender. Consequently, excess tokens will be transferred to the liquidity token itself, causing a loss of funds for the sender.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Malicious users can prevent stakers from withdrawing LP tokens and rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "add_reward_schedule The in contracts/multi_staking/src/contract.rs:183 allows any user to add a rewards schedule with any asset. This is problematic because a user may add a malicious token contract that returns an error when its Transfer message is invoked, eectively blocking users from being able to withdraw their funds. function In addition, this function also presents the opportunity for anyone to increase the size of LP_GLOBAL_STATE and REWARD_SCHEDULES to the point where they will return out-of-gas errors. For example, an attacker can create many CW20 tokens and send them as reward assets, causing iterations to fail due to the execution limit. Iterations that will fail can be found in the following locations:  contracts/multi_staking/src/contract.rs:295  contracts/multi_staking/src/contract.rs:357  contracts/multi_staking/src/contract.rs:403  contracts/multi_staking/src/contract.rs:570  contracts/multi_staking/src/contract.rs:615 We classify this issue as critical because both attacks would prevent users from withdrawing their liquidity pool tokens and rewards.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Numerical non-convergence might lead to erroneous computations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "the non-convergence in of The contracts/stable_5pool/src/math.rs:45-70 is not handled. A loop carries out up to 32 iterations over an approximating function, and after the iterations, the computations are carried out with the last approximating value. Consequently, the value might not be at the desired precision, which might cause erroneous computations. Furthermore, this computation is a sub-computation of another solver (calc_y in line 83), which might also lead to a situation where two approximated values of a proposed d lead to the same value in y and an erroneous convergence of calc_y. solver",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. AfterJoinResponse does not return fee value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "The in contracts/vault/src/contract.rs:749-775 includes logic to handle a fee returned execute_join_pool function in the AfterJoinResponse. Each of the current pools returns None for this value during OnJoinPool, so currently, the logic is unused. This will result in the collected fees not being sent to the protocol fee collector or the developer fee collector.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Funds in the keeper contract cannot be withdrawn",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/keeper/src/contract.rs:70-81, there is no functionality for the vault owner to withdraw funds from the keeper contract. Funds will be sent to the keeper contract as part of the protocol fees. This means that the vault owner cannot withdraw collected protocol fees.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Owner address is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/keeper/src/contract.rs:45, msg.owner is not validated before it is saved. If the address is incorrectly set and that goes unnoticed, it could result in a loss of funds once the keeper contract begins to receive funds.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Duplicate scaling factors cause ineective updates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/pools/stable_pool/src/contract.rs:74-88, the provided scaling factors are validated to ensure the asset information exists in the pool. However, no validation is performed to ensure duplicate assets are not provided. This is problematic because the update_scaling_factor function can only update the rst index, as seen in line 287. In contrast, the scaling_factors function returns the last value (see a is the old scaling contracts/pools/stable_pool/src/state.rs:57). As a result, factor the used StablePoolUpdateParams::UpdateScalingFactor message. duplicated updated despite being asset there still will via be if Please see the test_ineffective_scaling_factor_update test case to reproduce the issue. We classify this issue as major since it prevents the scaling factor manager from updating the congurations correctly.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Consider validating burn shares are greater than zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/stable_5pool/src/contract.rs:603-621, errors that occur inside the imbalanced_withdraw function are silenced, causing the shares to burn to become the a message zero. imbalanced_withdraw functionality to withdraw funds from the pool without burning the required tokens. attacker causes inside errors send that can An Due to the fact that no validation exists to ensure that the burn amount is not zero, attackers cannot exploit this like the previous issue due to the inability to burn 0 liquidity pool tokens in contracts/vault/src/contract.rs:1073. However, a code refactor might change this, such as adding an if statement only to burn shares if its higher than zero. Please see the burn_funds_free_asset test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Users may receive unexpected mint amounts because the lp_to_mint parameter is unused",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "The execute_join_pool function in contracts/vault/src/contract.rs:694 provides the optional parameter of lp_to_mint, which allows the caller to specify the amount of LP tokens they want to get against their provided assets. This value is silently the weighted pool's ignored types. for in query_on_join_pool contracts/weighted_pool/src/contract.rs:381 ignores the _mint_amount parameter entirely and performs no checks to validate that it is met. existing pool example, function For the all This issue is found in all of the following pool types:  stable5 - query_on_join_pool - contracts/stable_5pool/src/contract.rs:392  weighted - query_on_join_pool - contracts/weighted_pool/src/contract.rs:381 The lp_to_mint is currently an unused parameter that should either be removed or enforced. The current implementation can result in the user receiving an amount of LP tokens that were not expected.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Consider verifying the developers address to be valid",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/vault/src/contract.rs:81-82, the developers address inside the fee info is not checked to be a valid address. This is problematic because the developers address is used to update the pools conguration in line 329. Other than that, executions that send the fee to the developer would fail due to an invalid address specied. We classify this issue as minor since only the admin can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Users can send more liquidity pool tokens than specied",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/vault/src:228, the second condition veries that the specied burn amount must be higher than the actual amount transferred. This is problematic because if a user sent extra liquidity pool tokens, the tokens would be stuck in the contract. For example, Alice can send 500 tokens but may only specify the burn amount as 300. As a result, 200 tokens are not refunded back to Alice due to the refund amount being determined by the burn_amount. We classify this as a minor issue since it can only be caused by user misconguration.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Users can miscongure weighted pool conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "During the contract initialization process for the weighted pool, no validation ensures the provided WeightedParams in contracts/weighted_pool/src/contract.rs:66 is valid with the asset information. The current implementation allows users to congure duplicate weighted assets, which causes incorrect nal weights. Other than that, the contract accepts a zero weight amount, causing a division by zero panic in contracts/weighted_pool/src/utils.rs:196.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Excess native funds sent are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "The execute_join_pool function in contracts/vault/src/contract.rs:820 calls the find_sent_native_token_balance function to get the amount of a specied denom if the pool being joined includes native funds. This check ensures that info.funds contains the specied denom, but the execute_join_pool function should also ensure that info.funds does not contain any unexpected denoms. Otherwise those excess funds would be lost.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Owner address validation is not performed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "The instantiate function in contracts/multi_staking/src/contract.rs:43 does not validate msg.owner. An address validation should occur before an address value is stored in the contracts cong. If this eld were improperly set to an invalid address, then the contract would lose all of its owner functionality. Similarly, in is contracts/multi_staking/src/contract.rs:255 before the value is passed to the bond function. beneficiary validated not",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Multihop swap lacking multiswap_request validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "execute_multihop_swap in The contracts/router/src/contract.rs:117 does not perform any validation or pre-processing on the user-supplied vector of HopSwapRequest. The user-supplied least minimal validation before the swapping callback multiswap routes should have at sequence is initiated. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Ended reward schedules consume unnecessary computation power",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/multi_staking/src/contract.rs:295-301, the compute_reward function takes all reward schedules and skips the ones that have ended. This causes unnecessary gas consumption as ended reward schedules do not need to be processed. Suppose a scenario where the number of nished reward schedules grows too large such that an out-of-gas error would occur in the compute_reward function, preventing users from withdrawing liquidity pool tokens and rewards.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. UnclaimedRewards query returns incorrect value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "the last_distributed In contracts/multi_staking/src/contract.rs:628, value defaults to the supplied block_time value if the ASSET_LP_REWARD_STATE does not exist. This is incorrect because the update_staking_rewards function defaults the value to zero, as seen in contracts/multi_staking/src/contract.rs:467. Consequently, the UnclaimedRewards query will return a lower unclaimed rewards value than it should. Please see the test_incorrect_query_unclaimed_rewards test case in the appendix to reproduce this issue. We classify this issue as minor since it only aects the UnclaimedRewards query return value.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Removing and adding LP tokens might run out of gas if too many tokens are registered",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/multi_staking/src/contract.rs:144-180, the allow_lp_token and remove_lp_token_from_allowed_list functions might run out of gas if too many LP tokens are registered. As a consequence, removing and adding LP tokens will become impossible. Only a migration of the contract allows recovery from this issue. We classify this issue as minor since it can only be caused by an admin.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Unlocking liquidity pool tokens too frequently will prevent users from claiming them",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/multi_staking/src/contract.rs:499-515, the unlock function iterates over all users unlocking positions and lters them. If a user requests to unbond their liquidity pool tokens too many times, the USER_LP_TOKEN_LOCKS for the specic user will grow too large to be processed, causing an out-of-gas error eventually. We classify this issue as minor because it is unlikely that users will unbond their liquidity pool tokens to an amount high enough to cause computation limit issues.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Sequence is not reset when establishing a new channel",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "packages/polytone/src/callback.rs:90-117, In request_callback function reads the latest value stored in the SEQ storage and saves it as the callback for the incoming packet sequence. However, the SEQ storage does not reset the sequence back to 1 when the old channel is closed via ibc_channel_close. the Suppose the old channel is closed and a new channel is established. The packet sequence will start as 1. Since the SEQ storage records the old channel's sequence value, the CALLBACKS storage will save the pending callback with an incorrect seq value. As a result, pending callbacks will never be executed properly by the intended receiver, causing CALLBACKS not to be handled and LOCAL_TO_REMOTE_ACCOUNT not to save the request initializer's remote proxy contract address.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Controllers could instantiate proxies and execute messages on the receiver chain on behalf of other users without their consent",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "on_behalf_of The contracts/note/src/msg.rs:61 allows messages on the receiver chain on behalf of other users. attribute the of Execute struct controlled note contracts dened in to execute However, this is possible without the targeted user's consent allowing the controller account to impersonate unaware users on the controlled chains. While this cannot directly aect targeted users and their funds, controller compromise their reputation. it could allow a malicious to perform phishing and fraud campaigns or impersonate users in order to",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Encoding extensions are not enforced during handshake",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "The Polytone protocol denes encoding extensions in order to ensure that connected chains exchange data with an agreed format. To do so, in packages/polytone/src/handshake/note.rs:35, the protocol requires that the voice contracts extensions are a subset of the note contracts. However, encodings, contracts/note/src/ibc.rs:26 and 41. the implementation, the exchanges instead of exchanging the underlying chain-supported in hardcoded JSON-CosmosMsg dened string This would cause the mentioned validation check during the handshake to succeed without actually enforcing the extensions subset requirement.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. The proxy contract does not return the correct index of an errored message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "In contracts/proxy/src/contract.rs:78, returns an error containing the index of the errored message. the proxy contracts reply handler However, it returns the cardinality of submitted messages instead of the actual index. This would cause the propagation of an error with incorrect information leading to potentially wrong actions in the callback.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. PROXY_CODE_ID and BLOCK_MAX_GAS are not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "When instantiating the note and voice contracts, no validations are performed to validate the PROXY_CODE_ID and BLOCK_MAX_GAS values. This is problematic because misconguring the PROXY_CODE_ID to zero would cause the proxy instantiation to fail in contracts/voice/src/contract.rs:93. As for BLOCK_MAX_GAS value, it should be validated to be higher than ACK_GAS_NEEDED and ERR_GAS_NEEDED to prevent underows in contracts/voice/src/ibc.rs:102 and contracts/note/src/ibc.rs:102 and 123. classify We MigrateMsg::WithUpdate message to recover from these situations. as minor because the contract issue this admin can use the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. The note contract cannot handle more than 2^64-1 messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "In packages/polytone/src/callback.rs:97, incremented and saved. the message sequence SEQ is However, since it is stored as a u64, the increment will overow, and panic because of the overflow-check in place in the Cargo.toml, after the execution of 2^64-1 messages. This would prevent users from interacting with the contract and consequently lose access to their proxy accounts in the controlled chain.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Tight coupling of the Mint and Burn MsgServer and Keeper functions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2024-01-17 Audit Report - Noble tokenfactory Changes and fiattokenfactory v1.0.pdf",
        "body": "and Mint Burn The and in keeper/msg_server_burn.go in both the tokenfactory and fiattokenfactory modules were refactored by extracting the logic from the MsgServer functions to separate Keeper functions to expose them to other Cosmos SDK modules within the same chain. keeper/msg_server_mint.go functions The original MsgServer function signatures have been reused. Specically, the MsgMint and MsgBurn message types are used as parameters. Moreover, the keeper functions return the same response types as the MsgServer functions. it is considered best practice to keep the MsgServer and Keeper functions However, decoupled by using explicit function parameters and appropriate return types. This allows for more exibility in the future, for example, if the MsgMint message or MsgMintResponse return type needs to be refactored.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. Misleading simulation package import identier for the fiattokenfactory module",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2024-01-17 Audit Report - Noble tokenfactory Changes and fiattokenfactory v1.0.pdf",
        "body": "In x/fiattokenfactory/module_simulation.go:15, the simulation package is imported from the fiattokenfactory module with the tokenfactorysimulation identier. However, this identier is misleading, as the simulation package is not part of the tokenfactory module but rather the fiattokenfactory module.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Decimal places inconsistency between deposit and withdrawals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "Amounts are interpreted dierently in deposit and withdrawal operations. The underlying token contract uses 18 decimal places. However, deposit and withdrawal requests use 0 and 18 decimal places for the amounts specied. This may lead to confusion for integrators which may cause bugs. In addition, the total amount is limited to 50 digits, whilst the underlying token contract technically allows for 78 digit numbers (in decimal representation). This is unlikely to cause any issue in practice since such large numbers will not occur.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Number of blocks required for deposits to be conrmed is relatively small",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "The smart contract integration conrms events through event ltering transfer events. The constant REQUIRED_NUMBER_OF_BLOCK_CONFIRMATIONS is used to congure a limit of block conrmations that need to have occurred before such a deposit is considered conrmed. By default this is set to 6 block conrmations, This number is relatively small and corresponds to the number of conrmations usually used in Bitcoin. In Ethereum higher numbers are usually recommended, due to the lower block time. Major exchanges require 20 or even 50 blocks.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Ethereum address elds can be longer than required",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "The character limit specied for Ethereum addresses in ethereum/models is 200 characters. However, an Ethereum address expressed as a string in its standard format is 42 characters long (including leading 0x). Whilst this is not a security list, allowing the API to store and receive longer addresses could cause confusion or make the system more error-prone by allowing extra data to be received.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Leaked API keys in source code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "Several les are found to contain API keys and secrets, namely: - - - - .gitlab/gitlab_runner/runner1-cong/cong-template.toml avbox/app/routes.py backend/cong/settings/common.py backend/cong/settings/dev.py Depending on the API key usage and validity, a malicious user can abuse a leaked API key to cause damage to the overall project.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Websocket connection can be initiated by anyone",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "When initiating a WebSocket connection, there is no CSRF protection implemented. A malicious user can start a WebSocket connection and send arbitrary WebSocket messages as the victim. The impact of this issue depends on the implementation of the WebSocket itself. This is unlikely to be exploited since the SameSite Cookies which are set to Lax are preventing it. However, theres still a risk for users that use outdated browsers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. backend/apps/common/zoom/client.py: Meeting duration always calculated as zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "In line 61 the following expression is used to calculate a meeting duration: duration = event.time_slot.end_time - event.time_slot.end_time This will always result in zero.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. backend/apps/pages/views.py: context key INVOICE_STATUS set twice",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "The eld is set twice (line 157 and line 188).",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Gas is not consumed if the transaction returns an error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The ConsumeGas function is used in the lend module to increase the GasMeters consumed gas by a set amount. Within the Comdex appchain, these amounts are pre-dened based on anticipated values. This method is problematic because gas is only consumed after successful execution and not in the event of an error. Even if the function returns an error, computation still occurs and gas should be consumed. The ConsumeGas function is called in lines:  x/lend/keeper/msg_server.go:30  x/lend/keeper/msg_server.go:44  x/lend/keeper/msg_server.go:58  x/lend/keeper/msg_server.go:72  x/lend/keeper/msg_server.go:84  x/lend/keeper/msg_server.go:96  x/lend/keeper/msg_server.go:108  x/lend/keeper/msg_server.go:121  x/lend/keeper/msg_server.go:135  x/lend/keeper/msg_server.go:147  x/lend/keeper/msg_server.go:176  x/lend/keeper/msg_server.go:190 In these occurrences, the predened gas amount is not consumed in the event of an error because the ConsumeGas invocations are located at the end of the transaction execution. Consequently, a malicious actor is able to spam transactions that trigger errors in the middle of the execution without being charged the dened gas fees.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Input-dependent iteration in Lend modules BeginBlocker may slow down or stop block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "BeginBlocker is a function that is executed at the beginning of every block, even if there are no transactions. It should have a light and constant computational footprint to avoid any negative impacts on block production. Too much computational weight at the beginning of each block may cause block production to slow down, or even surpass Tendermints propose timeout, which results in a halt of the blockchain. Consequently, it is best practice to make the BeginBlocker execution independent, or at least sub-linearly dependent, from the amount of data stored on-chain. In the Lend module in x/lend/abci.go:13-23, the execution loops through all stored borrows in order to balance stable rates. Since borrows cardinality will grow with chain adoption or due to a spam attack, the issue described above will occur.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Batch mechanism in Liquidation modules BeginBlocker may allow malicious manipulations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "the Liquidation In x/liquidation/keeper/liquidate_borrow.go:11-113 x/liquidation/keeper/liquidate_vaults.go:12-93, through all the borrow positions in order to check the collateral ratio health. BeginBlocker, modules specically in and the execution loops Since positions cardinality will grow with chain adoption or due to a spam attack, in order to defend against issues like Input dependent iteration in Lend modules BeginBlocker may slow down or stop block production, functions implement a batching mechanism. It splits borrowing positions slice into dierent partitions of params.LiquidationBatchSize size. This implies that it could happen that positions that are not healthy in a block interval but are not included in a batch of that interval are not liquidated. This implementation also exposes a vulnerability where a malicious actor could manipulate the mentioned slice in order to create positions that will not be liquidated in a dened interval.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Error raised in BeginBlocker could lead to state corruption",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "In x/liquidation/abci.go:13-27 and x/lend/abci.go:13-23 both Lend and Liquidation modules wrap an ApplyFuncIfNoError function in order to gracefully handle errors. BeginBlockers execution logic their in This function logs errors but has no control over the state and no mechanism to revert partial updates. This implies that if an error is raised in the middle of an execution ow, the execution will stop and log the error, but no action will be taken in order to revert state updates that have been done leading to state corruption.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Incorrect conditions when rebalancing stable rates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "In x/lend/keeper/iter.go:203-209, the RebalanceStableRates function checks conditions to see if rebalancing must be triggered. The Commodo documentation states that stable rates should be decreased if    + 20% and increased if  + 20%         90% . However, the actual implementation is using dierent conditions. Stable rates are decreased if    + 20% and increased if,  + 20%      >  90% . This leads to a malfunctioning stable interest rate model. An attacker may create multiple accounts with borrowing positions with a stable interest rate for an asset and ensure that the borrowing rate is slightly less than 20% so that the increase condition will never be triggered to rebalance the stable rate even though the utilization ratio hits more than 90%. When the utilization ratio hits 100%, it impacts lenders unable to withdraw their stable assets.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. FundModAcc allows funds to be sent to any module which may result in permanently lost funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The FundModAcc function in x/lend/keeper/keeper.go:1388 allows for the caller to specify any module name for funding. This is problematic because funds could be sent to a module that is not designed to handle them making them stuck in the module. The BankKeeper will return an error if the module name is invalid, but as long as the module name specied is valid, this function will allow for funds to be sent. While any address may call this function, we do not classify it as critical since users would not normally be sending funds directly to a module.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Borrow positions InterestAccumulated is not updated before liquidation, leading to an incorrect interest calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "in The x/liquidation/keeper/liquidate_borrow.go:11 does not update the borrow positions InterestAccumulated before performing the liquidation operations. LiquidateBorrows function As a result, a stale value of borrowPos.InterestAccumulated is being used in x/liquidation/keeper/liquidate_borrow.go:60, 76, and 94 to calculate the currentCollateralizationRatio, which leads to an incorrect value. a when addition, in In x/liquidation/keeper/liquidate_borrow.go:115, the stale value is used to set LockedVault.UpdatedAmountOut. This can become especially problematic when the borrow position is large and the interest has not been updated for a long time period, in which case the LockedVault.UpdatedAmountOut will be incorrect by a considerable amount. created borrow locked being is",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. BeginBlocker allows for errors to silently pass without being logged",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The functions called during BeginBlocker do not properly propagate error information. Instead, they continue execution and silently pass on the condition that caused the error. This results in suboptimal visibility of the conditions that are causing errors. example, For in x/liquidation/keeper/liquidate_vaults.go:12 simply executes continue when errors are encountered. LiquidateVaults function the While we acknowledge that an error or panic should not necessarily halt the BeginBlocker, it is best practice to log the conditions that are causing errors. In this example, a liquidatable vault could be silently passed because there is no visibility into which errors are being encountered or even which vaults caused the errors.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Missing validation checks in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "There are some missing validation checks in the following transaction message types as well as the Lend modules governance handler messages:  In x/lend/types/pair.go:18, validation is done only on CPoolName eld.  In x/lend/types/pair.go:25, validation on AssetToPairMapping is not implemented.  In x/lend/types/pair.go:29, validation on AssetRatesParams is not implemented.  In x/lend/types/gov.go:195, validation on AuctionParams is not implemented.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Vault collateralitzationRatio does not account for newly accumulated interest",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "LiquidateVaults The in x/liquidation/keeper/liquidate_vaults.go:12 uses an outdated value of because totalOut vault.InterestAccumulated is not updated. collateralitzationRatio calculate function to In fact, the vault interest is updated in line 71 when the CalculateVaultInterest function is called. This results in collateralitzationRatio not reecting the current accumulated interest. We report this as minor because unlike the issue Borrow positions InterestAccumulated is not updated before liquidation, in this case, LiquidateVaults updates the position so the LockedVault.UpdatedAmountOut is correctly evaluated.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Incorrect value provided to VerifyCollateralizationRatio function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The VerifyCollateralizationRatio function takes liquidationThreshold as the last parameter and uses it the collateralization ratio is greater than the liquidation threshold. to perform validation for whether or not in order In four dierent instances, the function is incorrectly called with the LTV instead of the liquidationThreshold:  x/lend/keeper/keeper.go:541  x/lend/keeper/keeper.go:662  x/lend/keeper/keeper.go:720  x/lend/keeper/keeper.go:1159 This implies that depending on the value of LTV set by governance, the function either always returns ErrorCollateralizationRatio or bypasses the validation which could lead to unexpected results.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. UpdateLendPairsRecords allows governance to update lend pairs even if they have liquidity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The UpdateLendPairsRecords function in x/lend/keeper/pair.go:39 allows governance to update either AssetIn or AssetOut for an existing lend pair. If that existing lend pair is currently being utilized, this could have unintended consequences. Based on the documentation it does not seem that there is any specic reason for allowing updates of lend pairs.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. AddAuctionParamsData does not prevent existing data from being overwritten",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The AddAuctionParamsData function in x/lend/keeper/pair.go:227 does not ensure that existing data with the same key does not exist before saving the provided AuctionParams. This allows governance to overwrite existing data. We classify this as a minor issue because only governance can call this function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. AddAssetRatesParams returns incorrect error message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The AddAssetRatesParams function in x/lend/keeper/pair.go:200 returns the incorrect error \"Asset Rates Params not found\" when the record already exists.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. CLI uses ags instead of arguments to parse proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "In  x/lend/client/cli/tx.go:437,  x/lend/client/cli/tx.go:523,  x/lend/client/cli/tx.go:778, and  x/lend/client/cli/tx.go:901, for the commands the CmdAddNewLendPairsProposal, CmdAddPoolProposal, and CmdAddNewAssetRatesParamsProposal, CmdAddNewAuctionParamsProposal governance proposals currently receive a proposal le as a ag.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Unneeded positivity validation for unsigned integers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "the ValidateBasic functions in x/lend/types/tx.go validate that the ID All parameter is a positive number. As unsigned integer type can never be negative, those checks are redundant. Therefore, they can be removed.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Unnecessary aliases pattern increase technical debt",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "are there Currently, in x/lend/types/expected_keepers.go, while the keeper uses the functions from alias.go that reference expected/keeper.go. Having an alias.go le dening all functions of external modules is not necessary and decreases maintainability. external modules functions dened some for",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Duplicated ValidateBasic invocation in CLI",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "Some CLI commands dened in  x/lend/client/cli/tx.go:426,  x/lend/client/cli/tx.go:517,  x/lend/client/cli/tx.go:615,  x/lend/client/cli/tx.go:693,  x/lend/client/cli/tx.go:761,  x/lend/client/cli/tx.go:894, and  x/lend/client/cli/tx.go:986, call the msg.ValidateBasic function before calling GenerateOrBroadcastTxCLI or GenerateOrBroadcastTxWithFactory. As msg.ValidateBasic is already called inside GenerateOrBroadcastTxWithFactory, this is an unnecessary and duplicated invocation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Blacklist policy is not enforced for other chain addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/blockibc_middleware.go:111-115, the sender address is checked to not be blacklisted when performing an IBC token transfer. Since ICS-20 token transfers involve escrowing USDC to other chains, the blacklist policy should ensure that other blacklisted chain addresses cannot redeem the locked USDC with their IBC vouchers. However, this is not possible due to the AccAddressFromBech32 validation in x/tokenfactory/types/message_blacklist.go:45-48, which can only validate native Bech32 prex addresses. This implies that addresses on other chains can redeem USDC independent of a blacklist, since they cannot be blocked by the blacklist. For example, the following command fails when trying to blacklist a Juno address: nobled --home $CHAINDIR/$CHAINID tx tokenfactory blacklist juno1t8ehvswxjfn3ejzkjtntcyrqwvmvuknzy3ajxy --from $(nobled keys show blacklister -a) -y Error: invalid blacklist address (invalid Bech32 prefix; expected noble, got juno): invalid address This issue also aects the receiver blacklist policy in app/ante.go:89-93 when initiating an ICS-20 token transfer. Consequently, the blacklister will not be able to prevent users from transferring USDC to malicious addresses on other chains. We classify this issue as major because the blacklist policy is considered an important security feature in Nobles architecture.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Minting denom can be transacted through IBC during a paused state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "x/tokenfactory/blockibc_middleware.go:92-114, In OnRecvPacket handler does not validate the keepers paused state when receiving ICS-20 fungible token transfer packets. When the keepers paused state is true, all internal and external transfers are disallowed, as seen in app/ante.go:39-43. However, other chains can still transact USDC tokens to the native chain, eectively bypassing the paused state. the We classify this issue as major because the paused state is considered an important security feature in Nobles architecture.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. IBC middleware does not parse denoms trace when receiving ICS-20 packet data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/blockibc_middleware.go:101-103, security measure will be skipped if the packets denom is not the congured minting denom. As mentioned in lines 83-85, this is to ensure that the sender and receiver are not blacklisted if they were to transact an IBC voucher representation of USDC. the blacklist However, this approach will never work because the receiving packets denomination is constructed with a record of channels for which they have been transferred across chains, such as transfer/channel-40/uusdc. Consequently, the condition in line 101 will always evaluate as true, eectively bypassing the blacklist policy in lines 105-115.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Incorrect minterController genesis state validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/types/genesis.go:54, the MinterControllerKey function is used to derive the minter controller key from a minter controller address. However, the minter controller address is passed as an elem.Minter in the current implementation. This sets an incorrect minter controller key to validate a duplicated index. Therefore, as the specied key does not contain any data, accessing data onchain would not be possible.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Deviation from specication: A controller can set up any number of minters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "to the the specication, ConfigureMinter According in x/tokenfactory/keeper/msg_server_configure_minter.go:12 should only be called by the minterController and set its corresponding minter. However, the current implementation of ConfigureMinter does not validate that the minter address being congured matches the specied address that the MinterController controls. The same in issue x/tokenfactory/keeper/msg_server_remove_minter.go:12. Because of that, the relationship between MultiController and minter becomes one-to-many instead of one-to-one. This deviates from the specication. RemoveMinter function function exists the in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Separation of privileged addresses is not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "While there has been an extensive eort made to develop privileged accessed roles within the Noble chain, privilege separation of these roles is not properly enforced. Currently, there is no validation to ensure that these privileges cannot be shared by a single address. In the unlikely case of a compromised account, account sharing may have severe implications. For example, the Owner can assign the Blacklister, Master Minter, and Pauser roles to itself. While new addresses can easily be generated and all roles can technically be owned by the same entity using dierent addresses, it is best practice to restrict address reuse. Another step that can be taken to reduce the impact of a compromised account is to implement timelocks to prevent frequent updates of addresses.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Modifying minting denom allows blacklisted users to transact the old denom",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/genesis.go:45-47, supplying a dierent MintingDenom will cause the SetMintingDenom function to modify the mint denom. This is problematic since the blacklist functionality only works based on the current minting denom, as the decorator in app/ante.go:67-98 only validates that the addresses are not blacklisted if the transacted denom is the congured minting denom. Consequently, blacklisted users who were previously unable to transact the old minting denom can now transact that denom like other users. Additionally, all minters would need to update their old allowances denom to continue minting new tokens. We classify this issue as minor because only the governance can cause it, which requires cooperation among impacted parties.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Minters can be added during a paused state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/keeper/msg_server_configure_minter_controller.go:12 the x/tokenfactory/keeper/msg_server_configure_minter.go:12, and functions can be ConfigureMinterController and ConfigureMinter keeper executed even if the keepers paused state is set to true. This is inconsistent with the pausing section of the token design specication. As mentioned in that specication, adding minters should be prevented while the contract is paused.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Amino codec must be registered to support end users with hardware devices like Ledger",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/types/codec.go:77, Amino should be used to register all interfaces and concrete types for the tokenfactory module. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Incomplete genesis validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/types/genesis.go:29-63, validating all the provided GenesisState attributes. the Validate function is not There is no logic in place that validates Pauser, Owner and Blacklister addresses and that enforces Denom to be a non-empty string.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Missing validation for existing blacklisted address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/keeper/msg_server_blacklist.go, the Blacklist function is used for adding new addresses, however in its current implementation, it is not veried whether a new address is already on a blacklist or not. As a result, the operation succeeds without an error, which may give indexers or other o-chain services the misleading impression that a specic address has not yet been blacklisted.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Missing blacklist validation during minter conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In the x/tokenfactory/keeper/msg_server_configure_minter.go, ConfigureMinter method is used to add a minter. However, its current implementation does not check if the provided msg.Address is on a blacklist. This allows adding a blacklisted address as a minter.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Tokenfactory does not perform two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "in The x/tokenfactory/keeper/msg_server_update_owner.go:12 does not perform a UpdateOwner function two-step ownership transfer. In the unlikely event that the new owner is set to an incorrect address, then the owner will not be able to be reset, and the owner functionality will be lost.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Succinct event emission restricts information available to indexers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "All dened messages emit TypedEvent events containing the submitted message. However, those events contain only limited detail and may not represent enough information for indexers and other o-chain services.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Amount and Allowance message attributes are not validated to be greater than zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In the ValidateBasic functions in  x/tokenfactory/types/message_burn.go:45,  x/tokenfactory/types/message_configure_minter.go:41, and  x/tokenfactory/types/message_mint.go:41, the Amount and Allowance attributes are not validated to be greater than zero. This implies that messages that contain invalid values can pass the ValidateBasic validation without triggering an error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Incorrect eld numbers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "The GenesisState message in proto/tokenfactory/genesis.proto uses an incorrect eld number starting from 9. The minterControllerList should have 9, and mintingDenom should have 10 eld numbers.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. InitChainer and BeginBlocker are set twice",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In app/app.go:571-572 and app/app.go:593-594, SetBeginBlocker methods are called twice, which is inecient. the SetInitChainer and",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Unnecessary validation of From address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "Additional validation for the From address in ValidateBasic functions in the lines below are not necessary since that address belongs to the transaction sender address and is already validated:  x/tokenfactory/types/message_blacklist.go:41  x/tokenfactory/types/message_burn.go:41  x/tokenfactory/types/message_configure_minter_controller.go:4  x/tokenfactory/types/message_configure_minter.go:42  x/tokenfactory/types/message_mint.go:42  x/tokenfactory/types/message_pause.go:40  x/tokenfactory/types/message_remove_minter_controller.go:41  x/tokenfactory/types/message_remove_minter.go:41  x/tokenfactory/types/message_unblacklist.go:41  x/tokenfactory/types/message_unpause.go:40  x/tokenfactory/types/message_update_blacklister.go:41  x/tokenfactory/types/message_update_master_minter.go:41  x/tokenfactory/types/message_update_owner.go:41  x/tokenfactory/types/message_update_pauser.go:41",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Duplicated ValidateBasic invocation in CLI",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "CLI commands transaction All in registered x/tokenfactory/client/cli/tx.go call the msg.ValidateBasic function before calling GenerateOrBroadcastTxCLI. As msg.ValidateBasic is already called inside the GenerateOrBroadcastTxCLI, this is an unnecessary and duplicated invocation. GetTxCmd function the in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. No matter whether the user supplies one or more entries with the duplicated denom in the asset_amounts array of either the try_mint or the try_receive_burn function, only the rst entry will be used, all others will be ignored. In the case of a duplicate native token, a user could send just one entry in the asset_amounts argument to the try_mint function, but there will be a duplicate in subtraction contracts/nebula-cluster/src/contract/handle.rs:478. When that calculated happens, in contract from contracts/nebula-penalty/src/contract.rs:134 will stay the same (since the imbalance just shifts to the right). The denominator in line 137 will get smaller though, which will lead to a higher minted token amount for the attacker. If the attacker immediately burns the cluster tokens, they can drain assets from the cluster. inventory amount penalty reward token from the the the the of assert_sent_native_token_balance in The not contracts/nebula-cluster/src/contract/handle.rs:464 prevent this issue since it checks the amount in every iteration, and not the sum of the amounts across all tokens with the same denom. does We classify this issue as minor since it is caused by a wrong parameterization which can only be changed during initialization, by governance or the composition oracle. Recommendation We recommend checking the assets argument in the init and try_reset_target functions for duplicates and returning an error if any duplicates are found. Status: Resolved 5. No validation of initial cluster target weight sum to equal 100",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nebula/Nebula - Audit Report.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Attacker can bypass self-call validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf",
        "body": "validate_msg_calculate_usage The in contracts/croncat-tasks/src/helpers.rs:88 does not properly validate the value of contract_addr for the WasmMsg::Execute message type. This value is partially the task cannot call any of the validated in check_for_self_calls, associated CronCat addresses, but it does not account for the edge case that one of these addresses can be provided as all uppercase letters. This is possible for WasmMsg::Execute task actions that don't include queries. to check that function For example an attacker can specify an all uppercase version of the manager contract address, and then pass an address to update the owner and take control of the manager contract. These messages will also not cause errors during the address validation by the underlying Cosmos SDK, which is triggered from the wasm modules MsgExecuteContract message validation. The WasmMsg will be routed by the wasm module and will undergo stateless function will check validation in the message's ValidateBasic function. This msg.Contract with the sdk.AccAddressFromBech32, which returns the type AccAddress []byte. It does not dierentiate if the supplied address is in uppercase or lowercase. They will both normalize to the same byte slice, as long as the chain prex has the same case. See Appendex A: Test 1 Case 2 for more detail. The following shows two Bech32 addresses that both evaluate to the same account address: 395441E922FCBDC6BEC9B76EAC2C7D647B50D66F cosmos1892yr6fzlj7ud0kfkah2ctrav3a4p4n060ze8f 395441E922FCBDC6BEC9B76EAC2C7D647B50D66F COSMOS1892YR6FZLJ7UD0KFKAH2CTRAV3A4P4N060ZE8F",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Task contracts execute_update_config is permissionless",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf",
        "body": "execute_update_config in The contracts/croncat-tasks/src/contract.rs:96 allows any caller to execute a cong update for the Tasks contract. This will allow an attacker to gain complete control over the Tasks contract by updating critical parameters, for example, setting themselves as the contract owner. function",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Agents can bypass task delegation mechanism",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf",
        "body": "execute_proxy_call in The contracts/croncat-manager/src/contract.rs:188-208 incorrectly assumes that when a calling agent supplies a task hash the task is event based. This will allow agents to bypass the task delegation logic and directly execute tasks on a rst come rst serve basis. function This is based on the assumption that agents are all behaving according to the client software. But an agent owner could modify the client software to game this system and prot from receiving a disproportionate amount of tasks. For example, a malicious agent client could query to nd out which slot tasks are executable, and then simply call execute_proxy_call with the task_hash to avoid the agent_task checks in line 217. On chains that support Skip, this could even become a MEV opportunity where agents would compete to get their bundle accepted and frontrun the normal task delegation logic. This would completely exclude other agents that are acting normally. A proof of concept for this attack is available i",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Unbounded iteration in the tax modules AnteHandler could be used by an attacker to slow down or halt the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "In x/tax/keeper/taxdecorator.go:76-81, the ApplyTax function called from the tax modules AnteHandler is performing an unbounded iteration over the feeCoins provided by users. An attacker could craft a message with a signicant number of Coins with the intention of slowing down the block production, which in extreme cases may lead to Tendermints propose timeout to be surpassed. This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of peers hit the timeout and halt simultaneously, block production may stop. A test case is provided in Appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. ValidateMinter does not guarantee that provided parameters are adherent to the dened minting schedule",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "In x/mint/types/minter.go:43, the ValidateMinter function does not verify that the parameters passed on genesis are conformant with the equation that denes the minting schedule. There is a risk that one or more of them are not correct, which would lead to a awed minting schedule. Once this happens, there is no straightforward way to return to the intended trajectory. It is important to note, nevertheless, that there are checks to ensure that the total minted amount does not exceed a predened threshold.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Silently handled broken invariant could lead to inconsistent chain state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "In x/mint/abci.go:41-44, during the calculation of the time interval between two subsequent blocks, the guard that checks that the timestamp of the current block is greater than the previous one does not panic or return an error. Instead, it assigns blocks with the same timestamp, letting the execution ow continue. Since the code should always enforce the invariant   >  0 incorrect subsequent block order or simultaneous blocks should result in an error and eventually halt the chain. We classify this as a minor issue since Tendermint is already enforcing this invariant.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. The feeCaps parameter is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "In x/tax/types/params.go:103-113, the validateFeeCaps function that is invoked by ValidateBasic is not validating the feeCaps parameter. Instead, a TODO comment is present as a reminder to implement the validation logic. Consequently, every string value could be provided as feeCaps parameter.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Minting cap is not enforced during genesis",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "the In x/mint/types/minter.go:48, TotalMinted parameter is positive, but it does not validate that the value is less than the MintingCap. the ValidateMinter function ensures that This implies that during genesis, a TotalMinted parameter value that exceeds the MintingCap amount is accepted and stored.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. The FixedMintedAmount parameter value is incoherent with the documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "In x/mint/types/minter.go:11, FixedMintedAmount is set implies that 0.0825% of the total amount of tokens is minted per year. to 103125 which However, implementation and could lead to an unintended minting schedule. the docs dene this number to be 0.08% which is incoherent with the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Royalty contract owners can steal royalty funds by changing the funds recipient address.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/royalty/src/contract.rs:126 i.e recipient The update_royalty() function allows updating address and royalty rate a NFT minter wishes to charge, However, this function can also called by the royalty contract owner who can provide recipient address of its convenience in the used calculating the recipient value at contracts/royalty/src/contract.rs:126. This would allow the contract owner to rug pull all the royalty funds of the NFT minters. royalty parameters, arguments function that can",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Bidding contract owners can abuse their authority to front-run threshold values leading to unfair auctions.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/bidding/src/contract.rs:82, 151 In English auctions, bid acceptance is directly proportional to the bid amount. By changing the threshold value during the auction phase using the update_config() function, the owner can decrease the threshold value such that his bid becomes the highest and overwrites the current highest bid using the place_bid() function. Even if the owner changes the threshold value during the auction without having any intention to gain an advantage, this still leads to unfair auctions as other participants may try to outbid the current highest bid compared to the previous threshold value.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Contract owner could steal funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-contract-queuing At - src/execute.rs:249 The refund() function can only be called by the queuing contract owner and that will allow them to remove all the CW20 tokens it holds without sending the NFT to the appropriate owner who puts their order in the queue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Whitelisting in queuing contract can be bypassed by directly queuering the storage contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-contract-queuing At - src/execute.rs:114 The queue() function checks for the whitelisted address at each stage, and allows only the whitelisted addresses to claim tokens in claim(). The logic that checks the whitelisting queries the info.sender contract directly. The contract can respond to the query with any whitelisted address.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Change of storage contract address may lead to loss of funds.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/storage.rs:80 execute_change_storage()changes the storage address. This may lead to loss of funds if the storage address for the given maker address already exists and the new code_id doesnt have the appropriate functions to claim assets out of it.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Cyclic dependencies are present in auction_house and royalty contracts that would break the initialization of the respective contracts.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/contract.rs:37, contracts/royalty/src/contract.rs:28 Instationation of the auction_house contract requires the address of the royalty contract whilst instantiation of the royalty contract requires the address of the auction_house contract. Because of this cyclic interdependency, it would not be possible to deploy both of the contracts with valid params.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. The non-atomic nature of the place_bid function may lead to locked funds.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/storage/src/order.rs:208,209 contracts/bidding/src/contract.rs:99 To place a bid, a user needs to send funds to the storage contract rst and then call the place_bid() function of the bidding contract , which triggers the bidding_lock() function in the storage contract to lock funds. This is a 2-step process which may lead to locking of funds if the second transaction fails. To retrieve those funds users have to explicitly call the claim_assets()funciton. This process may introduce some inconsistencies and non-atomic behaviour may cause more gas consumption.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Incorrect nonce management",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/contract.rs:194 Nonces can be passed as a parameter when calling the approve_order()function that makes no usage no nonce as it is controlled by the user itself. This will allow the replication of order and restrict adding as new order if the same nonce gets used.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Setup function can be used by anyone to take control of the gateway contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the Solidity contract contracts/src/AxelarGatewayMultisig.sol the setup function can be called multiple times by anyone, allowing an adversary to take over control of the key privileged roles. This is due to the function being externally callable and not protected by any pre-condition other than not being callable on the implementation contract directly. However, since the storage contract the proxy this guard does not prevent unauthorized invocations. is that of This issue also applies to contracts/src/AxelarGatewaySinglesig.sol (out of scope).",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Non-unique key for identifying voting topics implementations may lead to lost proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the Solidity contract contracts/src/AdminMultisigBase.sol function the hash of msg.data is used to identify proposal topics. This value is used as a key to store the topic in the eternal storage contract (key-value store). However, msg.data simply encodes functions and parameters, meaning that repeated proposal of the same operation will result in the key being calculated with the same result. In this case, the previous proposal would be overwritten in storage and lost. msg.data can also be malleable due to dierent libraries or wallets adding trailing zeros which could lead to key mismatch (see issue Manual storage management in upgradability pattern used is error-prone and may lead to storage key conicts).",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Gateway contract address depend on token symbol only and might clash",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "Token contracts and burner contracts are deployed using the create2 opcode, in order to deterministically calculate the addresses on both sides. Since the initialization code remains constant for all tokens the only distinguishing factor for dierent deployments is the salt used in the address calculation. To this end, the codebase uses the hash of the token symbol. Since the token symbol becomes the only identier of an asset, tokens with the same symbol will clash, resulting in the same contract address. Eectively, only 3 bytes of input are used to produce a 32-byte hash value. This may lead to accidental overwriting of assets.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Expired polls can be voted on",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the x/vote/types/types.go module, the Vote method lacks a check whether the poll has been expired, allowing expired polls to be voted on.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Manual storage management in upgradability pattern used is error-prone and may lead to storage key conicts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "The Solidity smart contracts use an eternal storage pattern using a hash of an identier key as a manual storage pointer.. This introduces a source of potential errors since keys with the same name result in the same hash causing storage to be overwritten. The reverse can also occur if the source of the key calculation may be encoded slightly dierently by o-chain libraries. An example of this occurring is the msg.data eld used as a key in contracts/src/AdminMultisigBase.sol. This eld may have trailing zeros, depending on the wallet implementation used to interact with the smart contract, resulting in dierent key calculations and failure to look up the correct entry.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. ExportGenesis should return the genesis state instead of nil",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the x/axelarnet module, the genesis export returns nil.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Panic used for non-eligible validators in ination calculation breaks iteration for the other eligible bonded validator",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "Function handleTssInflation in x/reward/abci.go uses panic during the bonded validator iteration when a validator is found to be not eligible. This will skip the other eligible bonded validators.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Single invalid key causes subsequent valid keys to be skipped when batch-registering external keys",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the RegisterExternalKeys function in x/tss/keeper/msg_server.go, the iteration skips valid keys when an invalid key is present in the slice by returning from the method when it nds any validation error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. RouteIBCTransfer is not considering all the valid chain entries in case of error during iteration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the x/axelarnet module message server function, the RouteIBCTransfers returns on encountering an error during iterations. This will cause the method to skip all other entries in the slice over which the iteration is performed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Permissionless trade execution allows for price manipulation and arbitrage opportunities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "In contracts/pf-dca/src/execute.rs:66-81, the try_perform_dca function is permissionless, introducing a number of risks. While the execution of a single transaction might pose a small risk, i.e. a loss of funds for users due to arbitrage opportunities for another users, a coordinated attack that uses a larger amount of scheduled transactions might have a severe impact by extending (or even creating) such arbitrage opportunities to a degree that they could become market manipulations and enable the attacker to buy/sell funds at large discounts/premia. First, an attacker could use a set of scheduled transactions to manipulate oracle spot prices or TWAPs by triggering them simultaneously in a low liquidity environment. Second, an attacker can always arbitrage the slippage of the scheduled transactions by placing an order in front and behind the target transaction  a so-called sandwich attack. As the attacker can send the PerformDca message themself, this gives them the ability to write scripts that optimize for such an attack, for example reverting in the case of an unforeseen event. Third, an attacker can combine the rst two attacks for an inverted sandwich attack: The attacker could use one set of transactions to manipulate some oracle price to sell their own asset at a higher price and use a second set of transactions to provide enough liquidity to sell at the manipulated price, irrespective of the slippage limit. In addition to arbitrage, the owner might be forced to execute additional DCAs that are ready for execution when planning to cash out by having their CancelDca transaction front-run. However, this scenario will cause a minor inconvenience to the user compared to the above. The potential impact of this issue could be considered critical. We classify it as major though since the likelihood of exploitation is low as it requires a subset of the following market conditions: High slippage tolerances or large amounts of scheduled transactions within a short period of time and/or an oracle to be manipulated.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Lack of validation of conguration parameters upon instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "The pf-dca contract does not perform any validation on the conguration parameters set upon potentially causing issues that could render the contract unusable. in contracts/pf-dca/src/contract.rs:53-64, instantiation  destination_wallet address is not validated. An invalid address could cause any swap to fail as the message in line 138 will have an invalid recipient. In addition, the current implementation does not follow the documentation that states the destination wallet should default to the senders address.  source_denom is not validated. A wrong letter case of a denom or a denom that does in contracts/pf-dca/src/execute.rs:104-108 to fail, potentially leaving the amount to be swapped sitting idle in the contract. swap message exist will dened related cause not the  The destinations vector can be empty or the denoms not sanitized. This will lead to either no swaps happening at all or swaps failing.  max_slippage can be any Decimal number, even outside of the 0-100 range leading to potential inconsistencies. In addition, a high slippage is not recommended as it will allow for arbitrage opportunities as the ones described at Permissionless trade execution allows for price manipulation and arbitrage opportunities.  router_contract address is not validated, which would cause all swaps to fail if an invalid address is provided.  swap_interval can be set to zero, eectively allowing users to trigger all the swaps at once. We classify this issue as major given that none of the above parameters can be updated once the contract is deployed, which means that any of these errors require a new deployment.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. DCA end not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "The pf-dca contract does not enforce the congurations num_trades limit on the number of trades performed in contracts/pf-dca/src/execute.rs:66-121. This allows users to keep using the PerformDca message for as long as the contract has enough funds to perform additional swaps. Although not implying a security risk per se, the actual implementation diers from the implied behavior and STATE.num_trades_executed, which are not used otherwise. DcaConfig.num_trades existence the by of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. DCA execution might run out of gas if too many destinations are congured",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "the iterations performed over In contracts/pf-dca/src/execute.rs:83-86, destinations might run out of gas if too many destinations are congured. As a consequence, trade execution might fail permanently. In that case, the only way to recover the assets in the contract is the cancellation of the whole DCA.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Rounding issues on swap message creation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "The pf-dca contract allows swapping into multiple destination denoms, distributing the total amount using their assigned weight. The calculation of the nal amount to be traded to each denom is done in contracts/pf-dca/src/execute.rs:92-100. The division by total_weight is an integer division, leaving any remainder to stay idle in the contract until the user decides to cancel the DCA. This corresponds to rounding down/using the oor function. A proof of concept unit test can be found in the Appendix: Rounding issues on swap message creation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Users assets can get stuck in the DCA contract until cancelation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "pf-dca are The contracts/pf-dca/src/contract.rs:45 to satisfy that all trades contract enough checks assets only if sent   in along can be funded with the correct amount should satisfy   =   *   per trade. The documentation states that the total amount     such that it is required that the user submits the correct amount of funds. However, the code allows initializing contract with      *  , creating a possibility for  users to lock up excessive amounts of funds accidentally. The only way for the user to receive those funds back is to cancel the whole strategy, which would then require them to re-instantiate to resume the strategy with the correct amount of assets. In addition, when the swaps for a given asset fail, the remaining not swapped assets are left in the contract with no way for the user to either claim them or retry the swap. This may lead to frozen funds accumulating in the contract, unusable by the user until cancellation of the strategy.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Coarse-grained authorization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "pf-dca in The contracts/pf-dca/src/helpers.rs:7 does not follow best practices for authorization since it combines two separate entities into one layer of privileges by giving access to privileged functionality to both owner and destination_wallet. verify_sender contracts function For example, if the owner tries to pause the contract in order to stop the money ow into the destination_wallet, the destination_wallet can revert this action by unpausing the contract. The only way for the owner to prevent this is to cancel the DCA. In the future, when further functionality is added, this may lead to an overly privileged party with unintended consequences.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Commented code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "The contracts within the scope of this audit include commented code. Although not a security issue, commented code indicates that the codebase may not yet be ready for release and may negatively aect readability and maintainability. The following instances were found:  contracts/pf-dca/src/state.rs:5-29  packages/phase-finance/src/msg.rs:45-50 In addition, language potentially harmful contracts/pf-dca/src/tests.rs:135 packages/phase-finance/src/constant.rs:1. to the clients reputation was found in and",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Ineective resume and pause operations allowed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "pf-dca in The contracts/pf-dca/src/execute.rs:34 and 46 do not check if the contract is actually paused or not. resume_dca pause_dca contracts functions and Although not a security issue, pausing or unpausing a contract that is not already in that state will just spend gas without actually changing the contracts state.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "The following contract and package do not enable overflow-checks for the release prole:  contracts/pf-dca/Cargo.toml  packages/phase-finance/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Unnecessary panics negatively aect usability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "In contracts/pf-dca/src/helpers.rs, the conversion from string to Uint128 is assuming valid data due to the ltering of anything dierent than numbers. There are two cases that are unhandled though:  Empty strings (when token_string is not starting with number)  Numbers that are too big to parse Those cases cause the function to panic, negatively aecting the user experience compared to error messages.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attackers can drain relayer funds and hence DoS the bridge by spamming create_agent transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "parachain/pallets/control/src/lib.rs:128-161, In create_agent extrinsic creates a CreateAgent message and adds it to a queue for eventual commitment. This allows it to be selected and sent by a relayer to the Ethereum Gateway contract. the For each such message, the relayer is expected to execute the submit function of the in order to process the CreateAgent Command. This requires the Gateway contract relayer to pay the gas to instantiate a new Agent contract. Since the create_agent extrinsic can be sent permissionlessly by anyone, a potential vulnerability arises where an attacker could create a large number of accounts and spam the network with create_agent messages while only bearing the relatively low fees of the create_agent extrinsic dened by its weights. This would cause the queue to be loaded with CreateAgent messages and, since their execution could be relatively expensive for the relayer, relayers may run out of funds or cease operations in anticipation of high costs. This results in a denial-of-service (DoS) of the channel due to its ordered nature. In order to execute any message, all the other messages before it need to be executed. If the cost of executing all the previous messages is not economically feasible for relayers, the channel is stuck and messages are not relayed anymore.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attackers can drain sovereign funds and hence DoS the bridge by spamming registerToken transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In contracts/src/Gateway.sol:418-424, users to register a new asset on Asset Hub. the registerToken function enables However, the Asset Hub create extrinsic mandates a deposit of 10 DOT when creating a new at documentation https://wiki.polkadot.network/docs/learn-assets#creation-and-management. detailed asset, found the as in Consequently, every execution of contract necessitates the sovereign account to perform a 10 DOT deposit to the Asset Hub. the registerToken function within the Gateway Given that the origin is not covering this fee, there exists the potential for malicious actors to exploit this process. Attackers could spam the network with registerToken messages to exhaust sovereign account's funds, eectively implying a denial-of-service (DoS) attack of the channel. In fact, since channels are ordered by the nonce, to execute any message, all the other messages before it need to be executed. If the cost of executing all the previous messages is not economically viable, the channel could be stuck and messages will not be relayed anymore.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. submit extrinsic always returns Ok, causing stuck funds in the Agent contract in case of errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "parachain/pallets/inbound-queue/src/lib.rs:206-241, In function returns Ok regardless of whether errors occur during its execution. the submit This potential oversight poses the risk of funds becoming stuck on the Ethereum Agent contract in case an error emerges during the SendToken Command process on the Polkadot side. transfers tokens from Ethereum, the If a user corresponding Agent contract. Retrieving these funds requires the user to possess the bridged tokens on a Polkadot chain and bridge them through the Bridge Hub and the outbound-queue pallet. If an error occurs during the submit function, no bridged tokens will be minted on the Polkadot side. Without those bridged tokens, the locked funds will be unrecoverably stuck in the Ethereum Agent contract, resulting in a loss for the user. they are transferred to the escrow of",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Administrative Commands are not implemented on Polkadot side",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "After analyzing the code included in the scope of the audit, it was found that in the case of the outbound-queue palette, core Commands were not implemented, making it impossible to actively manage the bridge. This includes Commands such as:  CreateChannel  UpdateChannel  SetOperatingMode  TransferNativeFromAgent It is worth noting that the codebase submitted for this audit contains implementations for these commands on the Ethereum side. We report this issue as major instead of critical since none of the missing Commands present an immediate security threat. However, the repercussions could be signicant, leading to the inability to manage the bridge and limiting its functionality.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Throttling mechanism could delay critical governance operations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "parachain/pallets/outbound-queue/src/lib.rs:351-375, a the queue is implemented in order to bound the execution of throttling the In mechanism for on_finalize function. This throttling mechanism limits the number of messages retrieved per block from the outbound-queue pallet to a maximum of MaxMessagesPerBlock messages. Consequently, the processing of messages could be delayed depending on the number of messages in the queue of the outbound-queue pallet, but also depending on the number of other pallets interacting with their queues since the message-queue pallet selects autonomously each block which client pallet to serve and there is no guarantee that the outbound-queue is selected. This could potentially cause delays in the execution of important commands like SetOperatingMode or Upgrade that should be dispatched in a timely manner in order to address malfunctioning or exploits of the bridge. For instance, an attacker could exploit CreateAgent commands to saturate the queue. this by enqueuing a substantial number of",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Unrestricted Agent funds transfer via transferNativeFromAgent command",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In contracts/src/Gateway.sol:400-412, function enables agents to transfer any number of restriction on the originating channel. the transferNativeFromAgent funds from any agent, without any This implies that a user creating an agent could potentially exploit this message to steal all funds within the channel. While there is currently no way to call transferNativeFromAgent, we report this issue with major severity since it could have critical consequences if not addressed properly.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Multiple attempts of random value draw through replicated ticket submissions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In contracts/src/BeefyClient.sol:231-290, attackers could exploit the light client by initiating multiple ticket submissions to obtain a favorable random value from prevRandao. This could be accomplished through the replication of actions such as submitInitial or submitInitialWithHandover and commitPrevRandao. ticket, Although a safeguard in line 272 disallows the invocation of commitPrevRandao for the or same submitInitialWithHandover to generate a new ticket to attempt to draw a favorable ticket. submitInitial attackers remains feasible use for to it",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Corrupted messages in the queue are skipped, leading to stuck funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In parachain/pallets/outbound-queue/src/lib.rs:270-274, the execution of do_process_message is initiated by the message-queue pallet to handle messages. In line 272, the message is parsed, and if it fails, the ProcessMessageError::Corrupt error to permanently discard the message. This outcome can lead to a situation where tokens have already been burned in Asset Hub, and the discarded message results in the corresponding tokens on Ethereum being indenitely stuck in the Agent contract. is returned. This error subsequently prompts the message-queue pallet Moreover, having corrupted messages in the queue means that the state is corrupted and actions should be taken in order to protect user funds, for example pausing pallet operations.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. The outbound queue continues processing messages even if PalletOperatingMode is Halted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In the parachain/pallets/outbound-queue/src/lib.rs:351-374, process_message function lacks a validation step for the PalletOperatingMode status. While it is not possible to submit new messages while PalletOperatingMode is Halted, existing messages already in the queue (which could hold a signicant number of messages) can be further processed. In the event of an emergency situation this would result in messages continuing to be relayed even after governance halts operations.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Implementation of the generalized_index_bit function diers from the specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "the parachain/primitives/beacon/src/merkle_proof.rs:44, In generalized_index_bit function implementation diers from the specication given in https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#get_generaliz ed_index_bit. Because of this, the generated merkle_root is not compliant with the specication.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "11. Partial update may temporarily stall the bridge",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "During the execution of the submit extrinsic of the ethereum-beacon-client pallet, the in verify_update parachain/pallets/ethereum-beacon-client/src/lib.rs:362-482 is invoked to validate the provided update. function dened However, next_sync_committee_update, no error is raised, where the light client reference period is not updated. if the update includes a header from the next period but does not provide the leading to a partial state update it becomes impossible to update the light client state due to the period Consequently, mismatch, causing all the subsequent calls to the submit extrinsic to return an error and halting bridge operations until governance forces a new checkpoint. This issue has been found by the client after the audit report has been published, but has been reviewed by our team and added to this report for completeness.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "12. Risk of token loss and channel immobilization after Gateway contract upgrade",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In contracts/src/Gateway.sol:367-373, during the course of upgrade function execution, governance has the capability to execute the initialize function providing a new set of initParams as input. However, since the initialize function creates two new agents for Bridge Hub and Asset Hub that will overwrite the addresses of existing ones, this process inadvertently results in the inaccessibility of tokens bridged by these agents, leading to an irreversible loss. Moreover, channels, as the initialization process also resets the nonce to zero. it has the unintended consequence of indenitely immobilizing the associated We classify this issue as minor since it can only be caused through governance.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Malicious ERC-20 contracts could be used to mislead users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "Due to the ability to permissionlessly bridge arbitrary tokens from Ethereum to Polkadot, attackers could create malicious ERC-20 token contracts that do not actually put tokens into escrow on Ethereum and use this mechanism to mislead users. This can be achieved through the logic in contracts/src/utils/SafeTransfer.sol:13-21. An attacker could implement a contract featuring a TransferFrom function that consistently yields true results. Using this contract, they could execute the registerToken function and subsequently invoke sendTokens to facilitate a successful execution. This process would lead to event emission, command relay, and token creation on the bridge without the necessity of holding funds in the Ethereum agent's escrow. Attackers could use this behavior to pursue phishing campaigns or otherwise mislead users by using tokens not redeemable on Ethereum.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Updates of the Gateway address in the inbound-queue pallet would result in a stuck bridge",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In parachain/pallets/inbound-queue/src/lib.rs:243-249, the set_gateway extrinsic enables governance to update the Gateway Ethereum contract address. since the However, GlobalConsensusEthereumAccountConvertsFor, updating it would cause the pallet to not be able to control funds on Asset Hub anymore. Gateway compute address used the to is Furthermore, messages already in the queue would retain data tied to the old gateway address, rendering their processing impossible. Consequently, advancing the nonce becomes unachievable, eectively causing the bridge to become non-operational. We classify this issue as minor since it can only be caused through governance.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Missing mechanism for excessive fee reimbursement",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In contracts/src/Gateway.sol:466-485, while executing the _submitOutbound function, verication is conducted in line 474 to ensure that the user has sent an adequate amount of ETH to cover the required fees. However, the current implementation lacks a mechanism for reimbursing users who have sent an excessive amount of fees. Consequently, any surplus funds sent to this contract will be stuck in the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Misleading query output for non-existent channels",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "in the event of a non-existent channel In contracts/src/Gateway.sol:196-204, provided as input, the channelNoncesOf and channelFeeRewardOf functions will always return a misleading (0,0) tuple, which does not accurately represent store values due to the channel's absence.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Missing validations in Gateway contracts constructor",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In contracts/src/Gateway.sol:74-93, while executing the Gateway constructor, there is no validation to ensure that ASSET_HUB_AGENT_ID and BRIDGE_HUB_AGENT_ID are distinct. Similarly, ASSET_HUB_PARA_ID and BRIDGE_HUB_PARA_ID are not validated to not be equal. This validation is essential instantiate, wherein the bridge hub data could overwrite the asset hub data. to prevent potential conicts during the execution of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. XCM transfers are subject to limitations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In parachain/primitives/router/src/outbound/mod.rs:38 the validate function is employed to check XCM messages originating from the Asset Hub parachain. translates XCM instructions to AgentExecuteCommand and, It generates a new ticket for the OutboundQueue. if validation passes, However, not all valid XCM scripts pass this validation due to their fee execution handling. In 215-228, the fee_info function identies expected fees from XCM instructions. Specically:  A combination of WithdrawAsset and BuyExecution indicates the message's origin intends to pay the fees.  The UnpaidExecution instruction signies the origin anticipates zero-cost execution. lines 111-114 reject XCM messages from origins willing to pay the fee. This is Yet, inconsistent since both fee payment scenarios should be viable, especially given the assumption that Asset Hub transfers utilize the bridge-transfer pallet.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Message replay attack possible after u64::MAX messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In parachain/pallets/inbound-queue/src/lib.rs:192-200, increment overows after u64::MAX messages. the nonce value Consequently, after u64::MAX messages, previous messages. it will be possible to replay in sequence all We classify this issue as minor since it is very costly to execute u64::MAX messages.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "20. Hard-coded gas usage can make the Ethereum side of the bridge unusable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In contracts/src/Gateway:29, a static value known as DISPATCH_GAS is employed for executing smart contract calls within the Gateway contract. However, it is possible that introduction of Ethereum Ethereums gas model changes over time due to the continual Improvement Proposals (EIPs) that alter the gas consumption of opcodes. This introduces a risk wherein certain function call executions within the Gateway contract may become infeasible if the gas required surpasses the sum of DISPATCH_GAS and BUFFER_GAS. In such cases, transactions would revert, thereby rendering core operations like upgrades or the creation of agents impossible. the upgrade function call, since the logic contract's This is most problematic for initialize function denition, which plays a pivotal role in the upgrade process, is not predetermined. This lack of predictability can lead to a situation where the upgrade function reverts if an insucient gas value is provided. Consequently, determining the precise value for DISPATCH_GAS becomes an exceedingly challenging endeavor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "21. Excessive gas usage in corner cases",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "Within contracts/src/Gateway.sol:99-181, the submitInbound Solidity function behaves as follows: 1. Validate the channel from the originating parachain. 2. Verify the message proof. 3. Conrm the header commitment. 4. Validate the nonce and increment it. 5. Reward the relayer. 6. Check the remaining gas. 7. Dispatch the message. 8. Emit an event for completion. Steps 2 and 3 are resource-intensive, consuming signicant gas. Meanwhile, steps 4 and 5 are signicantly less resource demanding. If an erroneous nonce is submitted by a relayer, or the agent lacks sucient funds for rewarding the relayer, the function reverts, wasting the computation from steps 2 and 3.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "22. Change in function order or indexes during parachain upgrades could lead to execution of wrong functions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-05-24 Audit Report - Snowbridge v1.1.pdf",
        "body": "In contracts/src/Assets.sol:108, the param createTokenCallID is designated as the reference for the execution of a specic function on the parachain side. However, it is the indices associated with functions may change during the course of possible that parachain pallet upgrades. This can occur when developers of the pallets fail to employ the call_index attribute for dispatchables or neglect to maintain consistent call indices across various upgrades. As a consequence, the Snowbridge implementation might inadvertently trigger a dissimilar dispatchable function on the predened index if it does not adapt its bridge settings to align with the evolving codebase of the parachain.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. payout function may panic due to lack of fee and royalty validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "The payout function in contracts/marketplace/src/execute.rs:890-946 handles the distribution of funds when a sale is being nalized. There are a number of parties that may be paid during the sale of an NFT, such as the seller, nder, artist, and the network. Each of these parties has a dened percentage they receive which is dened in various conguration parameters. The payout function does properly validate that the sum of each of these payment parameters is not greater than 100%. finders_fee, network_fee, and royalty.share should be validated to ensure that their sum is not greater than the payment. The amounts of seller_share_msg, royalty, finders_fee, and network_fee are all independently calculated o of the original payment value with no respect to their sum. An example of a situation that would cause a panic is if a certain collection had an abnormally high royalty.share. For example, let's say the royalty.share is 95%. The subtraction of   royalty.share, network_fee, and finders_fee in line 931 would be greater than the original payment and cause a panic due to an underow (the workspace has overflow-checks enabled, which causes underows to panic).",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Misconguring stale bid duration causes operators to be unable to remove stale bids",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "the contract instantiation During in contracts/marketplace/src/execute.rs:49, msg.stale_bid_duration is not validated to have the input cast as Duration::Time, which is inconsistent with updating of parameters in contracts/marketplace/src/sudo.rs:96-98. As a result, a misconguration of initializing the stale bid duration as Duration::Height would cause the execution to fail in lines 745 and 796 because the Duration enum does not allow addition of time and height. execution message process during sudo",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Bidder can specify unchecked nders fee",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "and execute_accept_collection_bid lines execute_accept_bid the contracts/marketplace/src/execute.rs:513 bid.finders_fee_bps if there is no existing ask when a seller accepts a bid. This is problematic because nothing stops a bidder from specifying a very high value. While the nder's fee would still go to the sellers specied nder, it may be a proportion that is higher than the seller expected. in use and When creating an ask, params.max_finders_fee_percent, but mentioned above. the nders fee is validated to ensure that this check doesnt occur it is less than in the cases Example: 1. A user creates a bid with a very high nders fee of 90% (high but not enough to error). They would need to create a bid on an NFT that doesnt currently have an ask. 2. Owner would accept the bid 3. 4. The sellers specied nder would get nearly all of the value from the NFT sale, and If there is no ask, then bid.finders_fee_bps is used the seller would not. It is important to note that the caller still species the nder's address when accepting a bid. If this nder value was also pulled from the bid, this would be a critical issue allowing bidders to pay virtually nothing for NFTs.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Percentage and basis point values lack maximum value validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "contracts/marketplace/src/execute.rs:47 of In max_finders_fee_percent and bid_removal_reward_percent are converted to Decimal::percent values but are not checked to ensure that they do not exceed 100%. If it would be harmful to the either of these values were to be set to greater than 100%, protocol. It is best practice to enforce a hard limit on percent values. values and 50, the During the payout calculation, the nders fee could be greater than 100% which will cause the calculations to underow, but this would panic because of enable overflow-checks. Additionally, in execute_remove_stale_bid, a bid_removal_reward_percent greater than 100% would result in a reward greater than the value of the original bid. is situation in This also contracts/marketplace/src/sudo.rs:58. trading_fee_percent, max_finders_fee_percent, and bid_removal_reward_bps should all be validated to ensure that they are not greater than 100%. sudo_update_params function present the in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Sellers can update the price for inactive ask requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "execute_update_ask_price in The contracts/marketplace/src/execute.rs:306 allows the seller to update their NFT asking price without validating whether the associated ask request is expired or inactive. This might cause a misconception to the seller that their ask request is still valid and available for bidders to bid, which may not be true. functionality",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Bidders may set themselves as nder and receive nders fee",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "the execute_set_bid in In contracts/marketplace/src/execute.rs:334, when a bid is placed on an NFT with a FixedPrice auction, the nder is specied by the set_bid caller. That nder is then passed to the finalize_sale function and in the payout function, the address is then paid the nders fee. This function does contain any logic to verify that the nder address specied is not info.sender. This means that the function does not prevent bidders from specifying themselves as the nder and receiving the illegitimate nder fee. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Existing operators will be overwritten",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "sudo_update_params The in contracts/marketplace/src/sudo.rs:86-88 does not incrementally add operators, instead, it will overwrite the existing vector with the new operators. This may become problematic as the number of operators grows. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. A large number of hooks may cause out of gas errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "The sudo_add_sale_hook, sudo_add_ask_hook, and sudo_add_bid_hook functions in contracts/marketplace/src/sudo.rs do not impose a maximum number of hooks that may be added. As the marketplace scales, the number of hooks may begin to grow and cause out-of-gas errors. Note that this is recoverable because the contract contains hook removal functionality. It is best practice to impose a maximum number of hooks as they increase the gas cost of the call.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Release candidate dependencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "contract/marketplace/Cargo.toml:36-37, In cosmwasm-storage crates are specied at a release candidate version. the cosmwasm-std and As rc software is by convention still in development we suggest not using it in production.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. reserved_for should only be used when the sale type is not an auction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "When bidders attempt to bid on an existing ask request via   execute_set_bid functionality, the reserved_for value would be validated to ensure only the seller specied bidder can seen bid in asked contracts/marketplace/src/execute.rs:378-382. While this functionality is intended for sellers to reserve the sales for a specic bidder, it would defeat the purpose of the auction if the sales type is not xed price. request the on as",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. map_validate does not ensure the address vector is deduplicated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "The map_validate function in contracts/marketplace/src/helpers.rs:28-33 does not ensure that the provided vector of addresses is deduplicated, which is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "there While level, checks contracts/marketplace/Cargo.toml does not explicitly enable overflow-checks for the release prole. workspace overow are the at While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Potentially unexpected hook behavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "There are several scenarios throughout the marketplace contract where actions may be performed without triggering the expected hooks. While this is not inherently a vulnerability, it may lead to unintended consequences if these scenarios are not explicitly considered when implementing hooks. For example, a seller can call SetAsk multiple times to eectively update/overwrite their current ask. This will trigger the HookAction::Create hook multiple times, but not the HookAction::Delete hook, which may be unexpected. The same issue is also found when setting bids.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attackers can perform an inexpensive DoS attack by spamming Deposit transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf",
        "body": "In x/gov/keeper/deposit.go:166-180, the functions RefundAndDeleteDeposits and DeleteAndBurnDeposits are invoked within the EndBlocker function of the gov module. However, since these functions perform unbounded loops through all Deposits associated with proposals that have expired, an attacker could create a large number of accounts and send from each of them a Deposit transaction to attack the mentioned unbounded iteration and perform a DoS attack on the chain. Even worse, an attacker could send Deposit transactions containing more than one Coin. In such cases, the SendCoinsFromModuleToAccount function would be triggered to iterate through all the Coins for each Deposit item retrieved from storage. Note that the gas cost associated with a Deposit transaction can be as low as the minimum gas price a validator congures multiplied by the provided gas. In the case of the Cosmos Hub the recommended gas price is 0.0025 uATOM and the associated transaction gas cost is 0.00039705 ATOM. Attackers might opt for depositing 0uatom or utilize worthless coins generated through a tokenfactory module, while paying only 397.05 ATOM on the Cosmos Hub for gas to execute 1,000,000 transactions and generate an equivalent number of Deposit records. This is exacerbated by the fact that the deposit functionality does not prevent deposit amounts of 0uatom. This attack might be even cheaper on other Cosmos SDK chains, depending on the congured minimum gas price and the value of the native coin. Consequently, the execution of the EndBlocker will take more time and resources than expected causing the chain to slow down or, in the worst case, even halt. A test case showcasing this issue is provided in the Appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attackers can steal funds using the tip postHandler",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf",
        "body": "In x/auth/posthandler/tips.go:39-58, specify a tipper account that pays a tip to the feePayer. the tip Posthandler allows users to However, since there is no validation on who can charge the tipper, an attacker could specify any tipper account to the feePayer. funds from them that are sent in order to steal",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Attackers can perform an inexpensive DoS attack by spamming Grant transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf",
        "body": "In x/authz/keeper/keeper.go:378-403, the DequeueAndDeleteExpiredGrants function is executed during the authz module's EndBlocker function to remove all expired grants from the store. However, to do so, an iteration occurs over all the expired grants in the GrantQueue, and for each of the retrieved GrantQueueItems, another iteration takes place over all the items in the associated MsgTypeUrls slice. Note that the gas cost associated with a Grant transaction can be as low as the minimum gas price a validator congures multiplied by the provided gas. In the case of the Cosmos Hub the recommended gas price is 0.0025 uATOM and the associated transaction gas cost is 0.00017513 ATOM. Attackers might pay only 175.13 ATOM on the Cosmos Hub for gas to execute 1,000,000 transactions and generate an equivalent number of Grant records. This is exacerbated by the fact that attackers can target a specic block to execute all the iterations by specifying the expiration parameter in the Grant. This attack might be even cheaper on other Cosmos SDK chains, depending on the congured minimum gas price and the value of the native coin. If such an attack is executed, the EndBlocker function can consume a signicant time and resources causing the chain to slow down or, in the worst case, even halt.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. The postHandler is called with a context that does not embed transaction updates and the current mode",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf",
        "body": "In baseapp/baseapp.go:735-760, within the runTx function, the postHandler is invoked following the execution of messages performed by the runMsgCtx. if However, the provided mode does not align with either runTxModeDeliver or runTxModeSimulate, the postHandler is executed solely with the updates from the the scenario introduces a potential error anteHandler. This postHandler contains logic that relies on the updated state, which is its intended purpose. risk, especially if For instance, the tip postHandler may encounter diculties in verifying whether the in coins tipper from x/auth/posthandler/tips.go:39-58 runTxModeDeliver. facilitate mode possesses sucient dierent transfer the is the to if",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. The PrepareProposal function could silently fail due to deferred panic handling",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf",
        "body": "In baseapp/abci.go:275-286, the PrepareProposal function includes a deferred function returning handle abci.ResponsePrepareProposal{Txs: req.Txs}. designed panics and to This mechanism leads to the execution of transactions even if the PrepareProposal function panics. If a panic occurs within the prepareProposal handler, it typically indicates a broken invariant, and allowing the proposer to proceed with sending transactions in the order specied by the CometBFTs mempool could be problematic. for Consider, instance, a blockchain where security relies on the execution order of transactions or on Blockbusters lanes to prioritize specic types of messages. In such a scenario, the presence of this deferred function could potentially compromise the security and integrity of the protocol.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. PrepareProposalHandler does not adhere to ABCI++ interface specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos SDK/2024-01-23 Audit Report - Cosmos SDK v1.0.pdf",
        "body": "In the PrepareProposalHandler function in baseapp/baseapp.go:957, if there is no mempool set for the DefaultProposalHandler, then the function will simply return the req.Txs specied in the request. This is problematic as it may potentially return a list of transactions that exceeds RequestPrepareProposal.max_tx_bytes. Additionally, the function will also return an unchecked list of transactions if the defer function is triggered by a panic in the PrepareProposal function. In both cases, it will directly return the req.Txs without checking that the list does not exceed the maximum bytes limit. This does not adhere to the CometBFT specication: CometBFT MAY include a list of transactions in RequestPrepareProposal.txs whose total size the size of in bytes exceeds RequestPrepareProposal.max_tx_bytes. Therefore, the RequestPrepareProposal.txs is greater the MUST Application RequestPrepareProposal.max_tx_bytes limit is respected by those transactions returned in ResponsePrepareProposal.txs . than RequestPrepareProposal.max_tx_bytes, transactions remove ensure that to if",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. The new owner account claims ownership, which applies the conguration changes. Status: Acknowledged 16. Lack of role-based access controls for the pausing mechanism",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Ninja Blaze/2024-05-06 Audit Report - Ninja Blaze Double v1.0.pdf",
        "body": "The codebase implements a pausing mechanism, which is in line with best practices. However, all of the contract's administrative functions are centralized in the admin role, which goes against the principle of least privilege. Segregating the pauser role has the additional benet of swifter reactions in case of need when assigned to an EOA compared to the admin that might be managed by a multisig or a governance contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. The staking contract is not able to mint or burn coins",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "BlockBeforeSend in The message, contracts/periphery/staking/src/contract.rs:229, the Osmosis chain when sending tokens through the Bank module, and it is used by the protocol to execute custom logic to map tokens to the recipient during a send operation. executed by dened Sudo is This hook is implemented under the assumption that it is not executed when minting or burning tokens. assumption does not hold, however, This the SendCoinsFromModuleToAccount function here which calls SendCoins here, which implies that the BlockBeforeSend hook is executed even during mint and burn operations. since the mint operation calls Since from is the address of the tokenfactory module, an error will occur in line 243 when trying to decrease its zero balance. This makes the contract unusable. Please see the test_mint test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Total voting power does not account for the changes in the builder unlock contract and funds in the IBC outbound contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "calc_total_voting_power_at The contracts/periphery/gov/src/contract.rs:1059 calculates power at a certain height. function dened in the total voting To do so, it fetches the total supply from the staking contract, the number of coins locked in the builders unlock schedule, and the voting power at the proposals submission. This leads to an incorrect voting power because the tokens returned by the builder unlock contracts BuilderUnlockQueryMsg::State query can be inuenced by new allocations and user withdrawals. Additionally, it does not account for funds in the IBC outbound contract, leading to a wrong total voting power calculation. Consequently, the proposals' quorum and results are not correctly computed.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Proposal voting results can be manipulated through ash loans and builder unlock allocations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "The governance contract accounts for multiple voting sources to determine the outcome of a proposal. However, some of these sources allow attackers to inate their voting power by taking a ash loan, allowing them to execute governance attacks. be can inated The voting power calculated from the tokens staked in the voting-power-outbound contract in contracts/periphery/gov/src/contract.rs:1041-1046 reects the amount on the same block instead of a previous block. An attacker could request a ash loan, Lock a large number of tokens in the voting-power-outbound contract, CastVote in the governance contract, Unlock the tokens from voting-power-outbound, and nally repay the ash loan. Following these steps, they could manipulate the result of any proposal in their favor by paying only the ash loan fee. queried data the as the builders unlock contract determines the users voting power using the Additionally, BuilderUnlockQueryMsg::Allocation query in line 1029. This is problematic because a user can vote on the proposal, call ProposeNewReceiver to transfer the receivers address to another controlled address, call ClaimReceiver, and nally vote on the same proposal again to manipulate the outcome of the poll.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. First depositor can be front-run for unfair prot causing direct losses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "The staking contract does not prevent the rst depositor from being front-run to eectively get fewer shares than planned, from which the attacker will prot. a user the number of In contracts/periphery/staking/src/contract.rs:112-118, shares and received_tokens. However, if a malicious depositor makes a large enough donation to the vault at the right time, increasing total_deposit, the next depositor will not receive their expected amount of shares. on total_shares, total_deposit, depends receives The below describes a potential exploit scenario that could be followed by an attacker Mallory to take advantage of a victim Alice: 1. Upon identifying that Alice is trying to make the rst deposit of x tokens into the staking contract, Mallory front-runs their transaction with two calls: a. Making a minimal initial deposit, let's say 1 token, to obtain one unit of shares and setting total_shares to one. b. Donating x/2 tokens to the contract, increasing the total_deposit value without increasing total_shares. 2. Alices transaction gets executed containing the ExecuteMsg::Enter message, expecting to receive x amount of shares. As their deposit is just 1 token below the amount required to get 2 shares, only 1 share will be rewarded. 3. As a result, total_deposit would be equal to 1 + 3x/2, and total_shares would be 2. Making each share worth 1/2 + 3x/4 tokens. 4. Mallory will then be able to return the share to get 1/2 + 3x/4 tokens after having spent just 1 + x/2 tokens, eectively proting x/4 - 1/2 tokens. Note that this issue is only exploitable at the beginning of the contracts lifecycle and only aects the rst user making the deposit. However, as the potential loss of funds can be substantial, we classify it as critical.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Incorrect total shares determination",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "In contracts/periphery/staking/src/contract.rs:104, the total shares of xtoken are determined via the contract balance. This is problematic because it should be determined by the total supply using the Supply bank query instead of the Balance query. Consequently, if the total supply is dierent from the contract balance, the minted amount will be incorrectly larger than intended, allowing users to withdraw more funds from the protocol and ultimately causing a loss of funds for legitimate stakers.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Replaying Proliferate message inates total voting power",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "users voting In contracts/periphery/voting_power_inbound/src/contract.rs:307-311, the the FOREIGN_VOTING_POWER_TOTALS storage state is increased. However, here is no mechanism in place that prevents voters from replaying the Proliferate message to increase the total voting power. voting power updated, power total and the in is Consequently, malicious users can inate the total voting power such that it is impossible to reach the quorum during a governance proposal.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Removal of channels automatically removes the associating port and connection identier",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "a channel When contracts/periphery/voting_power_inbound/src/contract.rs:122-140 and contracts/periphery/voting_power_outbound/src/contract.rs:226-244, it simultaneously removes the associated port ID and connection ID from their allow lists. removed from ID is Since one connection can have multiple channels, a malicious channel that got removed will automatically remove the associated connection ID, causing future channels to fail to establish a connection. Additionally, most of the time, port identiers are common across multiple chains due to the module name (e.g., transfer). If a malicious channel uses a common port name and is removed, any future channels that intend to use the same port identier will fail to be established. To recover from this situation, a governance proposal needs to be passed to congure and add new connections and port identiers, which is time-consuming and requires governance participation. We classify this issue as major because it aects the correct functioning of the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. On-going proposals are rejected after removal of IBC channel",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "The governance contracts end_proposal function checks that the current power sources include the set of started in contracts/periphery/gov/src/contract.rs:530-536. that were present when the proposal sources is to purge potentially malicious channels from aecting Although this features goal governance, it has the consequence that the proposal is automatically rejected if any of the initial power sources have been removed, even if no votes from the removed channel have been submitted to the proposal.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Emergency governance proposal passes as long as quorum is reached",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "contracts/periphery/gov/src/contract.rs:436-439, In emergency governance proposal is counted as passed if the quorum is reached, irrespective of whether the votes are in favor of or against the proposal. the For example, assume a malicious voter submits a proposal that attempts to remove a legitimate IBC channel. The majority of voters disagree and submit against votes so the channel would not be removed. However, since the emergency proposal will pass, as long the quorum is reached, the legitimate IBC channel will be removed eventually.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Updating the last update timestamp when creating schedules might cause unissued rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "In contracts/periphery/vault_incentives_v1/src/contract.rs:170, last_update_timestamp is updated when the owner updates the schedule. This is problematic because the rewards distribution depends on the elapsed staking time, causing a loss of rewards for stakers. To illustrate, assume the start time is before the current timestamp when the owner creates the schedule. In line 377, the elapsed time will deduct the current timestamp with the last updated timestamp, not the schedules start time. Since the rewards are calculated in line 402 with the denominator as the whole schedules duration, the stakers will lose a portion of the rewards because the duration from the start date to the last updated timestamp is not included.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "11. remove_completed_proposal function incorrectly uses current conguration values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "In the contracts/periphery/gov/src/contract.rs:650-654, remove_completed_proposal function mutates the proposal status to expired if the proposal.end_block, current the config.proposal_effective_delay, and config.proposal_expiration_period. This implies that current conguration values are used, not the ones at the creation of the proposal. exceeds height block sum of Consequently, the proposal will expire earlier or later than intended depending on the proposal_effective_delay and proposal_expiration_period values updated in update_config through a successful governance proposal. The expiration block at proposal creation is stored in proposal.expiration_block, as seen in line 308.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "12. Possible division by zero error when no liquidity token is deposited",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "In contracts/periphery/vault_incentives_v1/src/contract.rs:449-451, the pt_lp_holders_index is increased for all staked liquidity token holders if the total it does not account for the scenario where the total yield token supply is zero. However, staked liquidity token in the contract is also zero. Consequently, the update_state function might fail due to a division by zero error when updating indexes.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "13. Users voting power remains after removing channels",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "In contracts/periphery/voting_power_inbound/src/contract.rs:122-143, the RemoveChannel message resets the FOREIGN_VOTING_POWER_TOTALS storage to zero to indicate there will be no voting power in this channel. However, individual voters still have their voting power stored in the VOTERS storage state. Consequently, both Voter and Voters query messages will still reect that voters still have outstanding voting power in the removed channel, which is incorrect. Additionally, if the channel is subsequently readded, Voters regain the voting power stored with the old channel since it has not been reset.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "14. StakePtLp message does not remove users deposit when updating the global index",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "In contracts/periphery/vault_incentives_v1/src/contract.rs:121-127, the StakePtLp message requires the caller to send config.pt_lp_token native denom, which will then call the update_state function. This function then queries the total tokens in the contract in line 425 without deducting the users deposit. This is problematic because the distributed rewards amount is for the stakers who staked during the elapsed time duration. Since the provided tokens were not staked before, they should not be entitled to a portion of the incentives earned. Consequently, denominator increase. the overall",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "15. Insucient input validations across contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "The smart contracts within scope lack sucient validation before saving conguration values. This could lead to issues that disrupt the correct behavior of the protocol and lead to failing transactions.  In contracts/periphery/builder_unlock/src/contract.rs:50:  token parameter not validated to be correct before saving upon instantiation.  proposed_receiver parameter should be None for new allocations.  In contracts/periphery/gov/src/contract.rs:74-88 and 679-764, the following parameters lack enough validation both upon instantiation and update:  xtoken may render the contract inoperable if set to an incorrect denom.  emergency_proposal_required_denom: to zero, emergency proposals could be auto-approved. If set to more than 1, it will never be met, and the proposal cannot pass. if set  In contracts/periphery/staking/src/contract.rs:53:  Lack of denom validation in the token parameter upon instantiation.  contracts/periphery/voting_power_inbound/src/contract.rs:50-5 lack of 8 and 102-120, upon instantiation and AllowVotingPowerSource, validation of the following parameters could lead to IBC features not working:  compatible_vp_outbound_versions  allowed_connection_ids  allowed_port_ids  contracts/periphery/voting_power_outbound/src/contract.rs:54- 63, 192-194, and 205-223, upon instantiation, AllowVotingPowerSource and UpdateConfig, lack of validation of the following parameters could lead to IBC features not working:  compatible_vp_outbound_versions  allowed_connection_ids  allowed_port_ids  contracts/periphery/vault_incentives_v1/src/contract.rs:33-57 and 469-538 lack validation upon instantiation and UpdateConfig could lead to protocol inoperability:  Missing denom validation of lp_token, yield_token, principal_token, and pt_lp_token.  pt_lp_pool_id pool is not validated.  yield_token_allocation_min yield_token_allocation_max.  yield_token_allocation_min, refracted_lp_ratio_delta_lower_bound, pt_lp_ratio_delta_lower_bound, should be validated to be less than 1. should be less than yield_token_allocation_max, and yield_token_allocation  yield_token_allocation should be validated to be less than than than the validation should be yield_token_allocation_max yield_token_allocation_min. Additionally, performed similarly to how the conguration update works. greater and",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Owner is allowed to execute arbitrary CosmosMsgs",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "The staking contract allows the owner to execute arbitrary CosmosMsgs through the ExecuteMsg::OwnerAction entry point. Among others, this message can be used to move contract funds to an arbitrary address through a BankMsg. In the event of compromised access keys or a malicious insider, this would allow the sweeping of all the contract funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Executed proposals can be removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "In the contracts/periphery/gov/src/contract.rs:641-660, remove_completed_proposal function allows removing an expired or rejected proposal from the general proposal list. This implies that it is also possible to remove an Executed proposal once it has expired, as seen in line 653.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Coin denomination updates lead to locked tokens stuck in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "voting-power-outbound The voting_power_denom contracts/periphery/voting_power_outbound/src/contract.rs:196-198. conguration UpdateConfig updated contract through allows the eld in be to If it gets updated, users who have locked tokens will receive, upon Unlock, tokens with the new denom instead of the ones they locked. This may lead to failures of the unlock operation or to other users tokens being spent, depending on the balance of the contract. The originally locked tokens will be stuck in the contract. the vault_incentives_v1 Similarly, incentive_denom contracts/periphery/vault_incentives_v1/src/contract.rs:493-495. this case, the update of the token denom causes the inability for users to get incentives. conguration UpdateConfig allows through updated contract the be to eld in In We classify this issue as minor since it can only be caused by the owner of the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Excessive control over funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "The builder-unlock contract allows the owner unallocated arbitrary execute_transfer_unallocated contracts/periphery/builder_unlock/src/contract.rs:517-562. to directly transfer any amount of the in address function through tokens an to This mechanism bypasses the expected behavior of the contract where the allocations are In case of a malicious insider or a expected to be made available depending on time. the compromised owner key, remaining funds by reducing allocations and then transferring the funds out. the attacker would be able to immediately cash out all",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "20. Single-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "21. Unused reply ID",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-03-18 Audit Report - Zodiac Protocol Periphery v1.0.pdf",
        "body": "The staking contract denes an INSTANTIATE_TOKEN_REPLY_ID constant. However, the reply function in contracts/periphery/staking/src/contract.rs:268 does not check the ID. Although not a security issue, an unchecked reply ID may be error-prone if additional reply handling becomes necessary in a future implementation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Unbounded loops in the nitro package can lead to a DoS",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/nitro/keeper/msg_server.go:75 and x/nitro/keeper/prover.go:24, the user-provided elds msg.EndSlot and proof.Hash may lead to an unbounded loop or an arbitrarily computationally expensive transaction which can lead to a DoS. This is problematic since the Validate function in x/nitro/keeper/prover.go:24 does not charge gas to the sender of the transaction, making the attack free of charge. It is important to note that both these code paths are called by the SubmitFraudChallenge method in x/nitro/keeper/msg_server.go:56, which is currently not registered on the Router in x/nitro/module.go:107.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Not registered message types prevent users from sending transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "MsgContractDepositRent and MsgUnregisterContract are not registered in RegisterInterfaces and RegisterCodec in x/dex/types/codec.go. Hence, the module will not route the messages to an appropriate message server. Thus, users will not be able to send transactions with the aforementioned message types.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. MsgContractDepositRent should set a minimum amount to avoid potential spamming",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/dex/keeper/msgserver/msg_server_contract_deposit_rent.go:12, there is no minimum limit to the amount that can be sent, and there is no gas charged for the operation, by default. This can be a cost-eective attack vector for the protocol, in which multiple transactions are sent with negligible amounts to consume CPU cycles with minimal cost. This may be used to slow down block production or even halt the chain.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Tick sizes are wrongly updated when a newly registered pair already exists",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/dex/keeper/msgserver/msg_server_register_pairs.go:36, any errors returned from the k.AddRegisteredPair function are silently ignored. This implies that the execution will continue even if the creator of a contract is trying to register a pair that already exists. This unhandled error has the unintended consequence that SetPriceTickSizeForPair and SetQuantityTickSizeForPair are called in lines 37-38, updating the current tick sizes of an already existing pair. Since events for that pair are not emitted, this could break any integrations with o-chain components and third-party applications relying on those events.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Processing of MsgPlaceOrders and MsgSend messages in EndBlocker may be exploited to halt the chain if mispriced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "Due to the processing of MsgPlaceOrders and MsgSend messages in the EndBlocker, a user can send transactions with multiple MsgPlaceOrders and MsgSend messages that are successfully included in a block, but then fail during the EndBlocker execution. An attacker may exploit this feature if the computation needed in the EndBlocker is not properly priced in the transaction. If a network has zero or low fees, an attacker could send hundreds of thousands of MsgPlaceOrders and MsgSend messages at comparatively low cost for the computation required which can slow down block production up to the point where the blockchain halts.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Contract claiming is not possible due to a logic error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "if In the ContractDepositRent function, a new owner can claim a contract 0. However, contract.RentBalance x/dex/keeper/msgserver/ msg_server_contract_deposit_rent.go:28, the SendCoins operation is executed from the old creatorAddr, not from msg.Sender. Thus, this function will always fail when called by any address which is not the current owner, rendering the claim functionality unusable. == in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Past minting emissions would never happen if the chain is down on the required release date",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In validates if x/mint/types/minter.go:56, function the date of the block is equal to the scheduledReleaseDate, and gets GetScheduledTokenRelease the executed in the BeginBlock of the epoch module. If the date matches, new mint emissions of the chain token will be performed. However, the function does not consider if the date scheduledReleaseDate is in the past, but the emission of the given epoch has not happened yet. Therefore, in case the Sei chain is down for more than 24 hours, the release of tokens is skipped, altering the emission plan.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Amino codec must be registered to support end users with hardware devices like Ledger",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/dex/types/codec.go:50, Amino should be used to register all interfaces and concrete types for the dex module. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Insucient validation of addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "The address of the creator, as well as the address of the contract in validateCancels the function in x/dex/keeper/msgserver/msg_server_cancel_orders.go are only checked against zero-length and not for validity of the address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. GetContract parse error not handled explicitly",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/dex/keeper/contract.go:37, the method GetContract returns an error either when the contract is not present in the storage, or when the contract is found but cannot be parsed in x/dex/keeper/msgserver/msg_server_register_contract.go:95, 107, and 193 assume that the contract does not exist upon either error and does not handle parsing errors. However, properly. contexts calling the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Fund transfer in EndBlocker goes against best practices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "function sends a transaction using the MsgPlaceOrders message, the When a user in transferFunds x/dex/keeper/msgserver/msg_server_place_orders.go:15 is called to create a DepositInfoEntry with the users fund amount in MemState. The amount is not actually moved from the senders account until the GetDepositSudoMsg function is called in the If a user EndBlock function in x/dex/keeper/abci/end_block_deposit.go:33. sends a transaction with multiple messages of MsgPlaceOrders and MsgSend, the transaction would be successfully included in a block but the deposit might fail during the EndBlocker execution since insucient time. Such asynchronously failing messages can negatively impact the user experience. It is best practice to fail fast by directly transferring funds from a senders account during message execution. After that, the deposit can still be handled in the EndBlock function. funds may be available at that",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Events are not emitted consistently across the application, which may impact the ability of third-party applications to be integrated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "Cosmos events are emitted by applications to notify third-party applications such as block explorers about events that occur on the chain. Not emitting events consistently across the application may impact the ability of these applications to parse the activity that happens in Sei, impacting user and developer experience. The following instances of messages and functionality lack emission of events:  x/epoch/module.go:188  x/dex/keeper/msgserver/msg_server_unregister_contract.go:12",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. ChangeAdmin does not validate that the new admin is dierent from the current one, which may cause errors in contracts and applications relying on this logic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "function ChangeAdmin The in x/tokenfactory/keeper/ msg_server.go:135 permits the admin of a token denom to change its address to a new one. However, there is no check that NewAdmin is dierent from the current one. An event of a change of admin is emitted nonetheless, which may cause unexpected behavior in applications relying on this information. tokenfactory module the in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Ination rate is set to 0%, while the documentation indicates an intended default ination rate of 13%",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/mint/types/minter.go:26, it is stated that the intended default initial ination rate should be 13%. However, in line 21, the initial ination rate is set to sdk.NewDec(0).",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. UnregisterContract should remove associated pairs after the contract is removed to avoid consuming unnecessary disk space on validators",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "is the contract removed in Once in x/dex/keeper/msgserver/msg_server_unregister_contract.go:12, its associated states are not deleted. An attacker can exploit storage by registering contracts, and then unregistering them multiple times. The cost of such an attack is comparatively low as rent is refunded to the contract owner after unregistration. UnregisterContract function the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Inecient implementation of UpdateQuantityTickSize and UpdatePriceTickSize",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "implementation The x/dex/keeper/msgserver/msg_server_update_quantity_tick_size.go:11 iterates through the tick size list, performing validation and then iteration through the same list happens again in SetQuantityTickSizeForPair. A similar implementation is performed to update price tick size. UpdateQuantityTickSize of in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Strict parsing of boolean CLI arguments may degrade user experience",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/dex/client/cli/tx/tx_register_contract.go, the arguments [need the string true, which hook] and [need order matching] only check against degrades the user experience. For example, if a user capitalizes the word, the ag is going to be set to false.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Inecient implementation of CancelOrders",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "The implementation of CancelOrders in x/dex/exchange/cancel_order.go iterates through orderbook.Longs) and cancelOrder(cancel, cancelOrder(cancel, orderbook.Shorts) for each one. This is inecient, since an order is always just in either the long or short orderbook. orders, calling all",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Inecient implementation of PlaceOrders",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "The implementation of transferFunds within the PlaceOrders function is inecient. In x/dex/keeper/msgserver/msg_server_place_orders.go:25-29, there is a loop validating that the fund amounts are dierent from Nil. However, this iteration is redundant as the same validation is performed in line 38.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Lack of token whitelist validation when swapping and creating a position or executing a strategy may lead to loss of user funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "In ethereum_hardhat/contracts/EthereumManager.sol:412 and 478, the swapTokenAndCreatePosition and swapTokenAndExecuteStrategy functions allow users to swap tokens and create or execute a strategy based on the provided strategy and chain identier. However, there is no validation that makes sure the swapped token toToken is whitelisted for that strategy identier strategyId and chain identier strategyChainId. and the createPosition function in line 391 veries that the assetInfos, In contrast, the strategyId, isTokenWhitelistedForStrategy mapping in line 277 to ensure the assets are whitelisted the and strategy validateAndTransferAssetFromSender function. strategyChainId arguments specied identier using chain valid are the via for The impact of this issue depends on how the contract on the other chain handles the non-whitelisted token. A possibility that might happen is that the recipient contract will reject the sent VAA message because the strategy does not support the asset token, causing a loss of funds for the sender.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Contracts are not compliant with CW2 Migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "The smart contracts do not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Inability to update the admin address of the terra_manager prevents incidence response",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "In contracts/terra_manager/src/contract.rs, the admin address is saved in the storage in the instantiate message. After that, the admin cant change its address. This may lead to severe implications if the private keys controlling the admin account are ever compromised, in which case an update of the admin address would help to prevent exploits.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Missing allowance check when executing a strategy with CW20 token causes meaningless error message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "In packages/aperture_common/src/token_utils.rs:47, when creating the message to move assets from the sender to the current contract, the execution uses a cw20::Cw20ExecuteMsg::TransferFrom. This type of message requires that the sender provided an allowance for the spender contract. If no allowance is granted, message execution will fail without a meaningful error message.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing tax deductions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero tax rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See this discussion for more details about the tax rate changes on Terra.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Cross-chain fee BPS value may be set to be larger than MAX_CROSS_CHAIN_FEE_BPS",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "the ethereum_hardhat/contracts/EthereumManager.sol:119, In the not _crossChainFeeBPS MAX_CROSS_CHAIN_FEE_BPS value as seen in line 131. As a result, an admin setting a _crossChainFeeBPS higher than MAX_CROSS_CHAIN_FEE_BPS will cause the calculated cross-chain fee in line 328 to be larger than intended. validated below value be to is",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Usage of deprecated safeApprove function opens up front-running possibilities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "In ethereum_hardhat/contracts/EthereumManager.sol:187 and 338, the safeApprove function is used to give approvals for other contracts to use the current contracts token balance. However, the safeApprove functionality is deprecated as it opens up possibilities for sandwich attacks similar to the classic ERC20 approve() function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Custom implementation of admin role increases code complexity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "In contracts/terra_manager/src/contract.rs a custom implementation of an admin role is used. Using a battle-tested reference implementation reduces the complexity of the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Removing a strategy from terra_manager may lead to unlinked data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "contracts/terra_manager/src/contract.rs:63, executing the selected strategy metadata is removed from when In ExecuteMsg::RemoveStrategy, STRATEGY_ID_TO_METADATA_MAP. As positions in POSITION_TO_STRATEGY_LOCATION_MAP are potentially pointing to a deleted strategy, this may lead to partial/unlinked data in the storage.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "contracts/terra_manager/Cargo.toml The overflow-checks for the release prole. package does not enable While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Re-entrancy guard TODO comment in Solidity codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "ethereum_hardhat/contracts/EthereumManager.sol:290, an In outstanding TODO comment indicating whether or not to implement a reentrancy guard in recordNewPositionInfo functionality. If the reentrancy guard is not applied, an attacker can keep reentering recordNewPositionInfo functionality, allowing the attacker to create fake positions under them. That said, there arent direct security risks since the rest of the code execution validates the attacker sent assets as specied in the assetInfos and fromToken argument. theres",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. The protocol can get permanently stuck in the StakingRewards state due to unhandled errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf",
        "body": "In the contracts/core/src/contract.rs:838-861, execute_tick_staking_rewards function within the core contract acts as the designated handler when the ContractState transitions to StakingRewards during routine procedures. However, if during this process the puppeteer contract callback to the PuppeteerHook stores a ResponseHookMsg::Error because of a timeout or an error in the ICA transaction, the execute_tick_staking_rewards function consistently returns a PreviousStakingWasFailed error in line 846. Consequently, lacking an alternative handler to progress the ContractState, the routine procedure becomes unable to proceed, resulting in the protocol becoming permanently stuck.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Accumulation of non-staked funds in the ICA account poses depegging risks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf",
        "body": "If the staking operations of the staker contract fail, user funds accumulate in the interchain account. This accumulation continues indenitely, regardless of the total balance or the frequency of failed staking operations. However, extended periods of failed operations could lead to the depegging of the liquid staking token, as non-bonded tokens would become unrecoverable or redeemable much later than the conventional bonding period suggests. This delay is due to the extended non-bonding time. Signicant accumulation of non-staked tokens or consecutively failing staking operations might be interpreted as a selling signal by users of liquid staking derivatives, potentially causing a depeg.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Missing validation in staker contract instantiation and update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf",
        "body": "In contracts/staker/src/contract.rs, during the execution of the instantiate and execute_update_config functions of the staker contract, data provided by the owner is stored in the contract without any validation. However, it should be validated to not allow for incorrect congurations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Neutron governance updating IBC fees could temporarily hinder interchain transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf",
        "body": "The staker contract constructs the fee object required by the Neutrons feeRefunder and interchaintxs Cosmos SDK modules with fees dened by the owner. However, since Neutrons governance can update the required IBC fees, static fees could render contracts unable to execute transfers or interchain transactions if fees change. Consequently, interchain transactions. the aforementioned contracts may become stuck and unable to execute",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Additional funds sent for ICA registration are stuck in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf",
        "body": "contracts/staker/src/contract.rs:179-198, In function execute_register_ica is utilized to register a new ICA account on a remote chain. This process mandates that the sender pays the registration_fee by transferring a dened amount of coins in the LOCAL_DENOM denomination. the However, additional funds sent by the user are not returned or processed further, eectively becoming stuck within the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Unbondings could fail due to asynchronous behavior of the staker contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Extension v1.0.pdf",
        "body": "The asynchronous nature of the staker contract can lead to situations where assets are requested for undelegation before they are fully staked. these scenarios, in In contracts/core/src/contract.rs:11291183 should ignore the undelegation request and continue processing, such that once the assets are staked, the undelegation request can be successfully processed at a later time. get_unbonding_msg function dened the This issue has been independently reported by a third party. Status: Externally Reported 7. Migrate only if newer pattern is not followed Severity: Informational The contract is currently migrated without regard to their version. This can be improved by adding validation to ensure that the migration is only performed if the supplied version is newer.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. First depositor can be front-run for unfair prot causing direct losses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The hub contract does not prevent the rst depositor from being front-run to eectively get fewer shares than planned from which the attacker will prot. In contracts/hub/src/math.rs:36-38, the number of shares that a user receives depends on ustake_supply, uluna_to_bond, and uluna_bonded. However, if a malicious depositor makes a large enough donation to the vault at the right time, increasing uluna_bonded, the next depositor will not receive their expected amount of shares. The below describes a potential exploit scenario that could be followed by an attacker Mallory to take advantage of a victim Alice: 1. Upon identifying that Alice is trying to make the rst deposit of X uluna into the hub contract, Malloryfront-runs their transaction with two calls: a. Making a minimal initial deposit, let's say 1 uluna, to obtain one unit of shares and setting ustake_supply to one. b. Donating a number of tokens to the contract equal to X/2 uluna, increasing the bonded_luna value without increasing ustake_supply",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Mallory will then be able to return the share to get 1/2 + 3x/4 uluna after having spent just 1 + X/2 uluna, eectively proting X/4 uluna. Note that this issue is only exploitable at the beginning of the contracts lifecycle and does only aect the rst user making the deposit. However, as the potential loss of funds can be substantial we classify it as critical. Recommendation We recommend performing the rst deposit atomically upon contract deployment. Their rst deposit should be large enough to limit the impact of the described exploit. Status: Resolved 2. Underow upon slope calculation may lead to unreliable voting power",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Unharvested rewards not accounted for in compute_mint_amount function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "compute_mint_amount at the The contracts/hub/src/execute.rs:144, does not take into account unharvested rewards when calculating the mint amount for a new user. As the protocol reinvests rewards, these belong to previous users, and new users are also given a share of these new rewards. contract, function located hub of Protocol users have a natural the harvest function to minimize any unharvested rewards getting distributed to other users. We classify this issue as minor, since the client states it is expected behaviour and that they will explain this in the user interface. incentive to call",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Period rounding can lead to undesired results",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The function create_lock converts a timestamp into a number of periods to get the current blocks period (variable block_period) and to calculate the number of periods for the lock rounding occurs which can lead to (variable periods). unexpected and potentially undesired results. these operations, In both of The rounding down of block_period means that the start of the lock could be set to the current period. Because of that, the minimum number of periods will not be strictly enforced. For instance, if a user creates a lock just before a period ends, the capital is locked up for one week less than if he creates a lock just after a period starts. On the other hand, the rounding down of periods may confuse a user. If a user species a time that corresponds to 3.99 weeks, the lock will only be created for three periods (three weeks).",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Lack of validation of embedded logos",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The voting-escrow contract does not validate_marketing_info contracts/amp-governance/voting_escrow/src/marketing_validation.rs :52-69. validate embedded logos during its in function If an embedded logo is submitted on instantiation it will be saved without any further check. This is not the case for the execute_upload_logo function of CW20, which successfully validates all cases through validate_logo.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of validation upon instantiation of the Hub contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The hub contracts instantiation function in contracts/hub/src/execute.rs:33 lacks some validation steps of epoch_period and unbond_period. In addition, the list of validators stored in line 49 is checked for duplicates but it does not actually validate addresses to be those of active validators. The same situation is found in the add_validator function in lines 666-682. We classify this issue as minor since instantiation parameters are usually reviewed with care by a privileged user or development team before deployment.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Insucient validation in address blacklisting function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The voting-escrow contracts update_blacklist function checks that the two vectors provided as arguments, append_addrs and remove_addrs, do not clash with the current contents in the contracts/amp-governance/voting_escrow/src/contract.rs:707-714. However, it does not check if addresses are duplicated within each vector or if an address is part of both at the same time. blacklist of Duplicated addresses in append_addrs cause minor ineciencies as those will be saved into the storage, unnecessarily growing it with no purpose and opening a window for future inconsistencies. This limited impact in line 744, as processing the rst instance of any address causes the cur_power of duplicated iterations to be zero. is mitigated by the if statement On the other hand, duplicates in remove_addrs have a real impact as there are no checks in place to avoid repeated calls to the checkpoint function in line 778. This leads to additional accounting in voting power in line 347 linked to the blacklisting of the same address,  compromising the integrity of the scheduled slope changes and the stored Point. For addresses that are present in both vectors, the function rst appends addresses and then removes them. If, by mistake, the same address is part of both, that address will not be contained in the nal blacklist without the owner or guardian being aware of this situation. Although the impact of this issue can be considered major, the function is restricted to privileged addresses which are less prone to error in general. Therefore, this issue has been raised as minor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Coecient calc implementation diers from documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "calc_coefficient The in packages/eris/src/helpers/slope.rs:6-10 is documented with the following line: Coefficient to 1 and [`MAX_LOCK_TIME`] is 9. However, the actual implementation does not adhere to this comment as when the interval is zero weeks, the returned value will be zero instead of one. calculation [`WEEK`] function equal where found is This issue has been raised as informational as every instance that calls the aected function checks the supplied interval to not be zero before or cant be zero given the contracs logic.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Widespread usage of generic errors in the Hub contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The error handling in the hub contract is based on StdError::generic_err instead of declaring custom errors, as opposed to the voting-escrow contract which mostly relies on custom errors. Although not a security issue, dening individual generic error messages decreases maintainability.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Lack of drop proposal function on owner transfer mechanism",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The hub contract implements a two-step transfer mechanism for updating the owner in order to remove a new_owner address address, submitted by mistake, the current owner would have to call transfer_ownership again and overwrite the address. following best practices. However, Although eective in practice, purpose of clearing this value.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Hardcoded denom and EPOCH_START",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The hub contract makes use of the CONTRACT_DENOM constant to set the denom in multiple instances, following best practices. However, the following instances have been found to use a hardcoded uluna string instead of the CONTRACT_DENOM constant:  contracts/hub/src/types/staking.rs:44, 67, 93  contracts/hub/src/queries.rs:80 Although not a security issue, it impacts maintainability and may lead to errors in the future, such as a partial change of denoms throughout the codebase. In addition, the code in packages/eris/src/governance_helper.rs:16 denes a variable EPOCH_START with a specic value assigned to it. It is important to make sure that this value is correct and intended for the specic use case before deploying the code to production, as it may need to be adjusted or replaced with a dynamic value that can change over time.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Optimization in compute_undelegations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "iterates over merge_with_validators in The hub contract uses a loop that if the variable uluna_to_undelegate contracts/hub/src/math.rs:86. However, is set to zero, the subsequent computations on lines 91 and beyond will have no eect, wasting computational resources.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Outdated documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "README type The ExecuteMsg::SubmitUnbond, which does not exist and was, presumably, replaced by ExecuteMsg::SubmitBatch. mentions message folder hub the le in a",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Unnecessary conversion to lowercase in addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The contracts within scope used the addr_validate_to_lower helper function to sanitize addresses, found at packages/eris/src/helper.rs:25-31. Since CosmWasm 1.0.0, the addr_validate utility also validates address capitalization, hence making it redundant to perform this check manually.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Incorrect comments and typographical errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The following incorrect comments and typographical errors were found in the audited codebase. Although not security related, they decrease documentation quality and readability of the codebase:  contracts/amp-governance/voting_escrow/src/contract.rs:724 accumulator for old slopes instead of accumulator for old amount.  contracts/amp-governance/voting_escrow/src/state.rs:17 list of whitelisted logo urls prexes instead of list of contracts to receive updates on user's lock info, or something similar.  contracts/amp-governance/voting_escrow/src/state.rs:44 the timestamp when the lock position starts instead of the period when the lock position starts  contracts/hub/src/contract.rs:141 must be 1-2 instead of must be 1  contracts/hub/src/execute.rs:305 and 309 validatiors instead of validators",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Commented code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "A commented function was found in packages/eris/src/helpers/slope.rs:20-24. Although not a security issue, commented code decreases readability and may cause issues if re-introduced in the future without being properly re-architected.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Undelegations will fail when redelegating to a new validator",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "contracts/external/cw-vesting/src/stake_tracker.rs:71-74, In cardinality is not undelegations will fail in line 100 as the cardinality tries to decrement a zero-value. the increased when redelegating to a new validator. Consequently, Although the vesting recipient can prevent this issue by redelegating back to the source validator, it is irrecoverable if the vesting is canceled. In that case, the owner can no longer withdraw the delegated funds. Please see the test_redelegate_should_increase_cardinality test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Misconguring the total vested amount to be lower than the sent CW20 amount would cause a loss of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "In contracts/external/cw-vesting/src/contract.rs:38, the total amount of tokens to be vested depends on the PayrollInstantiateMsg.total amount (see the total contracts/external/cw-payroll-factory/src/contract.rs:87). amount to vest is lower than the sent CW20 amount, the excess tokens will be left in the cw-payroll-factory contract. If can Suppose a scenario where the cw-payroll-factory does not have any owner. An calling attacker higher ReceiveMsg::InstantiatePayrollContract PayrollInstantiateMsg.total amount, causing the cw-payroll-factory contract to send the excess funds to the newly instantiated cw-vesting contract. tokens with by a excess steal the Please see the test_inconsistent_cw20_amount test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Misconguring start time to be in the past might cause undesired payouts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "In contracts/external/cw-vesting/src/contract.rs:34, the start_time of the vesting can be set to a past value, which might lead to undesired payouts. We classify this issue as minor since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Vesting duration parameter is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "In cw-vesting/src/contract.rs:41, the duration_seconds parameter is initialized with a non-validated value. This results in the possibility of instant vesting, releasing funds immediately upon reaching start_time, which may not be intended. The value of duration_seconds is handled using the SaturatingLinear variant of the Schedule type. Using it with a start_time in the future and duration_seconds equal to 0 renders it equivalent to the PiecewiseLinear schedule consisting of a single step releasing the whole amount. We classify this issue as minor since only the contract instantiator can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Undelegation does not emit custom events",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "undelegation in During contracts/external/cw-vesting/src/contract.rs:366, no events or attributes are emitted upon successful execution. This is inconsistent with execute_delegate and execute_redelegate, where attributes are emitted in lines 259 and 324, respectively. execute_undelegate function the in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Values held in StakeTracker cannot be queried",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "There is a certain amount of code implementing tracking of delegations in the cw-vesting smart contract. The structure StakeTracker, dened in stake_tracker.rs, contains the elds total_staked, validators, and cardinality. They all reect the chronology of staked funds by the validator and account unbonding times. However, call graph analysis reveals that only total_staked aects the outcome of transaction processing. In contrast, validators and cardinality are never read outside tests in stake_tracker_tests.rs. StakeTracker does, however, update them, e.g. in the on_bonded_slash function in stake_tracker.rs:113 with a clever technique of reconstructing proper delegated amounts after slashing events. The concern is that elds validators and cardinality require computation and on-chain space while not being utilized in any way except testing.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Potential misleading error in ReceiveMsg::Fund",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "In cw-vesting/src/contract.rs:153, the error ContractError::Funded is thrown if the status of the vesting is not Unfunded. However, the contract also can be in the Canceled state.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Schedule cli shifts the unlock start date rather than leads to unlocked tokens that cannot be claimed yet",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "a and When dening an allocation of ASTRO for a user, the contract owner species a start date, a calculating the unlocked_amount in cli, duration. However, when time and cli are contracts/builder_unlock/src/contract.rs:939, the added, eectively just shifting the start date. The consequence of unlock_amount does not increase linearly from the start time, but from the sum of start date and cli instead. this is that the start contradicts in This packages/astroport-governance/src/builder_unlock.rs:35 which states Time after the cliff during which the remaining tokens linearly unlock. comment the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Recipient transfer does not transfer unlocked amount checkpoint",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "the in During execute_claim_receiver contracts/builder_unlock/src/contract.rs:650, only the astro_withdrawn eld of the allocation status STATUS is transferred to the new receiver, but not any amount that was previously unlocked in unlocked_amount_checkpoint. function This implies that the new receiver may have to wait longer for funds to unlock in the case where the previous recipient had an allocation decrease and the unlocked funds were stored in unlocked_amount_checkpoint.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Increasing the cli may result in unlocked tokens becoming locked again",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "In the increase_cliffs function, the contract owner can set a new cli for an allocation in in already contracts/builder_unlock/src/contract.rs:721. This may result unlocked tokens no longer being unlocked. Apart from this, an increasing cli in the current implementation may lead to an underow causing a panic in line 970 if a user already withdrew a bigger amount than the new unlocked amount. Note that this has no security implication, but a panic leads to a bad user experience.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Inconsistency in validation during recipient transfer may lead to a loss of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "the execute_propose_new_receiver returned in In contracts/builder_unlock/src/contract.rs:389 if the receiver has allocation parameters PARAMS with a non-zero amount. In the execute_claim_receiver function, however, an error is returned in contracts/builder_unlock/src/contract.rs:630 if a PARAMS entry exists for the receiver, even if the amount is zero. function, error an is This inconsistency allows a recipient with PARAMS but a zero amount to be proposed as the receiver, but that new recipient can never claim that allocation. This might lead to a loss of funds for the new receiver if the previous receiver of the allocation does not cooperate to resolve the issue. We classify this issue as minor since rstly, the creation of PARAMS allocations with a zero amount does not make much sense and may never exist, and secondly, the previous and new recipients are likely controlled by the same entity, in which case they can resolve the issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Maximum allocation amount can be set lower than total deposits",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "the update_config a In in new_max_allocations_amount contract/builder_unlock/src/contract.rs:689. There is currently no validation, however, that the new value is bigger than total_astro_deposited. contract function owner able the set to is This max_allocations_amount and implies that no new allocations can be created. total_astro_deposited assumption breaks that the <= We classify this issue as minor since only the owner can cause it, and since it can be resolved by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Transfer of unallocated tokens leads to wrong token accounting",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "During the execute_transfer_unallocated function, the total_astro_deposited the state the execute_increase_allocation in total_astro_deposited is which inconsistent decreased. increases function, variable amount This with not is contracts/builder_unlock/src/contract.rs:519. total_astro_deposited amount hence includes unallocated tokens. The Consequently, the total_astro_deposited state variable will be bigger than actual deposits after a transfer of unallocated funds. This implies that the condition checking total_astro_deposited against max_allocations_amount in line 523 will lead to an surpass the max_allocations_amount. deposited amount actual does even error not if We classify this issue as minor since it can be worked around by the owner by increasing max_allocations_amount.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Lack of validation when creating an allocation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "In the execute_create_allocations function, the passed AllocationParams are stored in contracts/builder_unlock/src/contract.rs:295. This implies that allocations can be created with a start_time in the past, a zero duration, zero amount or an invalid proposed_receiver address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Unnecessary lowercasing of addresses is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "the both codebase, Throughout custom addr_validate_to_lower function are used to convert String to Addr types and validate their correctness. As the version of cosmwasm-std dened in the Cargo.toml is it is no longer necessary to convert strings to lowercase. Using a custom function is 1.1, inecient and unnecessarily increases the codebase. deps.api.validate and the the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Unnecessary load of PARAMS during creation of an allocation is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "During the creation of an allocation, the contract veries that a user does not have an existing in allocation contracts/builder_unlock/src/contract.rs:287. Loading the value is inecient though, since it is not used. PARAMS loading value from the by",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Unnecessary validation of STATUS during creation of an allocation is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "by During the creation of an allocation, the contract veries that a user does not have an existing allocation in contracts/builder_unlock/src/contract.rs:299. However, there is already a check for PARAMS in line 287. Since both STATUS and PARAMS are created for new allocations, non-existence of an entry in PARAMS implies non-existence of that entry in STATUS, which makes the STATUS check unnecessary. checking STATUS the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Unnecessary loading of STATUS during claim of new receiver is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "In the execute_claim_receiver function, the STATUS of the new receiver is loaded in contracts/builder_unlock/src/contract.rs:649. However, an error is returned before in line 630 if that new receiver has stored PARAMS. Since PARAMS and STATUS for a receiver always exist both or neither, the code block in lines 649-653 has no eect.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Misleading function name compute_withdraw_amount may negatively impact maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "The compute_withdraw_amount function calculates the amount of Astro a user may withdraw in contracts/builder_unlock/src/contract.rs:956. the function also updates the users STATUS, which contradicts the function name, which only indicates a computation. This might mislead In addition,",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Inecient validation of prev_receiver",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "When a user accepts a claim of a token allocation, the function loads the PARAMS and in STATUS contracts/builder_unlock/src/contract.rs:625 and subsequently removes both the PARAMS and STATUS of said previous receiver. previous receiver the of During each of these four interactions, the function validates the prev_receiver address. This is unnecessary and wastes computational resources.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Lack of error message for query of non-existent allocation may confuse users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "When an allocation does not exist for a queried user through the QueryMsg::Allocation the query_allocation function returns an allocation with empty values in query, contracts/builder_unlock/src/contract.rs:760 and 763, rather than an error message that the allocation does not exist. This may be confusing to users.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. The exchange rate between milkTIA and osmoTIA cannot be adjusted in the event of a slashing incident",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf",
        "body": "The liquid staking token milkTIA is supposed to be collateralized by at least 100% of staked TIA, specically, osmoTIA tokens. In the event of a slashing incident, the staked TIA tokens will be slashed, and thus, the amount of tokens collateralizing milkTIA will be reduced. Consequently, the exchange rate between milkTIA and osmoTIA must be adjusted to reect the new, lower collateralization ratio. However, contrary to the outlined procedure for the slashing incidence process in the MilkyWay architecture design documentation, there is currently no mechanism in place to adjust the exchange rate, only functionality to pause the contract via the circuit breaker. Moreover, a stale exchange rate may be problematic to external protocols that integrate milkTIA. As the slashing incidence process involves communication between two separate blockchains, Osmosis and Celestia, the introduced time delay allows malicious actors to exploit the outdated exchange rate in the meantime. However, due to the ability of an operator to pause the contract via the circuit breaker, we classify this issue as major.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Repeatedly failed ICS-20 token transfers cannot be recovered",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf",
        "body": "The osmoTIA tokens are transferred from the staking contract on Osmosis to Celestia via ICS-20 token transfers. The in-ight packets are stored in INFLIGHT_PACKETS when implemented in handling the submessage reply in the handle_ibc_reply function, failed contracts/staking/src/execute.rs:818-855. This allows timed-out or transfers the ExecuteMsg::RecoverPendingIbcTransfers message. recovered retried and via be to However, if a recovered transfer fails again, the transfer cannot be recovered again. This is due to the MsgTransfer message not being added as a submessage and, thus, the handle_ibc_reply reply handler not being called. Consequently, the in-ight packet is not stored, and repeated attempts to recover the transfer will not work as the packet is not found in the INFLIGHT_PACKETS storage map. is issue same in in The contracts/staking/src/execute.rs:718, where the ibc_transfer_msg is not added as a submessage with the appropriate reply handler. As an actor can not purposefully force the IBC packet to fail, we classify this issue as major. receive_rewards function found also the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Users potentially withdraw incorrect token amounts if the received unstaked tokens are accounted for in the wrong batch",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf",
        "body": "receive_unstaked_tokens in The contracts/staking/src/execute.rs:721-790 is called as part of the IBC hooks, made possible through the memo eld included in every ICS-20 token transfer packet. The MilkyWay o-chain coordinator initiates such a token transfer once the unbonding period of 21 days on Celestia has passed and the unstaked TIA tokens are ready to be transferred to the staking contract on Osmosis and received as osmoTIA tokens. function The corresponding batch, i.e., the oldest submitted batch, is determined in lines 757-760 by iterating over all batches stored in BATCHES and taking the rst batch that matches the status BatchStatus::Submitted. The batch's received_native_unstaked value is then set to the received amount of unstaked tokens in line 782. This value is expected to include the accumulated staking rewards or, tokens. if a slashing event occurred, the slashed amount of Subsequently, received_native_unstaked is used in the execute_withdraw function in lines 382-385 to calculate the amount of underlying osmoTIA tokens to withdraw. However, as ICS-20 token transfers use an unordered IBC channel, the order in which the unstaked osmoTIA tokens are received by the staking contract is not guaranteed. if the o-chain coordinator sends multiple unstaked token transfers to the Consequently, staking contract, batches could receive the incorrect token amount, resulting in users withdrawing incorrect amounts of osmoTIA tokens.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Collected protocol fees cannot be withdrawn",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf",
        "body": "and processed Staking rewards are collected on Celestia, transferred to the MilkyWay staking contract on Osmosis, in contracts/staking/src/execute.rs:652-719. Protocol fees are calculated and deducted from the received staking rewards and accounted for in the total_fees storage variable in line 706. The remaining staking rewards are then transferred back to Celestia to be staked again. receive_rewards function within the However, due to missing functionality, the collected protocol fees cannot be claimed by the protocol and remain locked in the staking contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Inecient batch retrieval leads to increased gas costs and potential out-of-gas errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf",
        "body": "The receive_unstaked_tokens function determines the oldest submitted batch in contracts/staking/src/execute.rs:757-760 by iterating over all batches stored in the BATCHES storage map until the rst batch with the status BatchStatus::Submitted is found. Over time, as more and more batches are added, the number of batches to iterate over will increase, potentially leading to increased gas costs and, in the worst case, to an out-of-gas error. However, new batches are only created after some pre-congured time, initially set by the MilkyWay team to three days, has elapsed. Consequently, we classify this issue as minor as creation of new batches is limited. in Similarly, in contracts/staking/src/execute.rs:175-180, the pending batch can be retrieved from PENDING_BATCH_ID instead of iterating the BATCHES storage map. execute_liquid_unstake function the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Recovering a large number of timed-out or failed ICS-20 token transfers might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/MilkyWay/2023-12-12 Audit Report - MilkyWay Staking v1.0.pdf",
        "body": "The recover function in contracts/staking/src/execute.rs:543-586 retrieves all timed-out and failed ICS-20 token transfer packets from the INFLIGHT_PACKETS storage map without the use of pagination. Consequently, if the number of in-ight packets grows very large, the function might run out of gas, and token transfers cannot be recovered anymore.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Proxy rewards not included in active pools will be lost upon claiming",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-10 Audit Report - Astroport Core Updates v1.0.pdf",
        "body": "In the contracts/tokenomics/generator/src/contract.rs:231, ClaimRewards message fetches accrued proxy rewards from all active pools instead of the specied liquidity pools (see lines 748-754). When the claim_rewards function in line 982 is executed during the callback, only the specied liquidity pools will have their proxy reward index updated. This is problematic because if the provided liquidity pools do not contain all the active pools, the proxy reward index for left-out pools will not be updated, causing a loss of rewards for depositors. This issue was discovered by the client independently during the audit, but it is still present in the commit hash used for the audit.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Protocol mint fees locked in factory contract for perpetuity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Edge/2022-04-23 Audit Report - Edge Protocol v1.0.pdf",
        "body": "The Edge pool contract mints eTokens to the factory contract when computing the interest accrued in contracts/edge-pool/src/borrow.rs:532. However, there is no function in the factory contract that allows the factory owner to redeem these eToken funds. The eTokens accrued during interest computations are thus locked in perpetuity.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Vault safeness incorrectly calculated due to the usage of wrong decimals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "The power contract checks if each user vault is solvent as a pre-condition to perform the mint, burn, deposit, withdraw, and liquidate operations. However, the calculations done in the get_status function in contracts/margined-power/src/vault.rs:319 could yield incorrect results. is turned into decimal type in line 344, power_decimals is used When the collateral instead of base_decimals, which represents the amount of decimals from the Power denomination instead of the one from the collateral. This error could cause insolvent vaults to be wrongly deemed safe, allowing further operations or safe vaults to be considered unsafe and liquidatable.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. The power contract no longer works if apply_funding_rate is not called for 48 hours",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "contracts/margined-power/src/handle.rs, In apply_funding_rate function calls calculate_normalisation_factor, which checks if the last funding update state.last_funding_update has occurred in the last MAX_TWAP_PERIOD, which is set to 48 hours. If not, it returns an error. the While it is assumed that the apply_funding_rate function is regularly called by the foundation or community, a potential exists that it is not called for extended periods, for example due to network outages. If it is not called for 48 hours, most core functions, such as handle_mint_power_perp, handle_burn_power_perp, handle_liquidation, handle_deposit, and handle_withdrawal will be unusable given the fact that they all invoke apply_funding_rate.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. User funds are lost when using Burn to withdraw collateral",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "The power contracts handle_burn_power_perp function requires the user to send both the power tokens to be withdrawn in contracts/margined-power/src/handle.rs:263 and 264. However, the additional collateral sent this way is never accounted for. tokens to be burned and the collateral Both amount_to_burn and amount_to_withdraw are supplied as arguments to VAULTS.burn, which deducts each amount from the corresponding eld in the storage. Finally, amount_to_withdraw is transferred to the user. The whole operation results in the user sending the requested amount of collateral tokens, getting that amount deducted from the vault but only receiving the amount reimbursed once instead of twice. This leads to lost the user losing funds.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Power contract can be used if not yet opened or if paused",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "For the power contract to be usable, it must be opened explicitly by executing SetOpen message. It can also be paused and unpaused by executing Pause and UnPause messages. These actions modify the variable state.is_open. However, the code does not contain a check if the value of this variable is true before user actions are performed. Hence it is possible to interact with the contract, even when it has not been opened yet or is paused.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. The staking contract does not handle transfers of staked coins properly",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "function The in decrements contracts/margined-staking/src/handle.rs:209 staked_amounts of a user whenever they unstake. Since staked_amounts is not updated when the staked coin (staked_denom) is transferred, this calculation can underow when transferred coins are later unstaked. For instance, when Alice transfers her staked coins to Bob (who does not have a staked position) and Bob tries to unstake, he will not be able to. handle_unstake",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Normalization factor could be manipulated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "the The power contracts apply_funding_rate function calculates the normalization factor in contracts/margined-power/src/funding.rs:20 only if it has not been already calculated at timestamp (and hence in the current block). The calculation_normalisation_factor function queries the oracle in TWAP mode using the dierence from the last update of normalisation_factor and the current timestamp as its period. This is the rst step in the ve major external functionalities: mint, burn, liquidate, deposit, and withdraw. current Given the mentioned restriction, performing consecutive calls in dierent blocks with just one second of dierence between their timestamps could be possible, forcing the oracle to return information of just a one-second period. This mostly defeats the benets of using the TWAP mechanism, as it is possible to briey manipulate the Oracle in favor of the user before interacting with the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Unpause delay too small to react",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "The power contracts pause mechanism allows anonymous users to unpause the contract 24 hours after it has been paused. Although this feature follows best practices to reduce centralization concerns, the period of one day may be too small in case of an incident response situation or after the discovery of a critical vulnerability in the code.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Missing fee_rate validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "contracts/margined-power/src/contract.rs:60, In is missing validation for the value to be between 0 to 1. Without validation, misconguration may go unnoticed and will eventually be dicult to correct. config.fee_rate Similarly, in contracts/margined-power/src/handle.rs:49 should have the same validation for the config.fee_rate. handle_update_config the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Lack of denomination and pool validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "In several validation: instances in the staking and power contracts, denomination and pools lack  deposit_denom and contracts/margined-staking/src/contract.rs:59 and 61 reward_denom  power_denom, base_denom, power_pool, and base_pool contracts/margined-power/src/state.rs:59-69  token in contracts/margined-collector/src/state.rs:8 in in For example, for the last instance, if an invalid denom is added to the list of allowed tokens, it will not be usable within the collector contract. Further, if a typo is made when removing a token the same token not added error will be raised as when a valid but non-existent token is to be removed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update. In addition, the staking contract does not have a mechanism to transfer ownership at all. This is problematic as in case of a suspected compromise, no action could be taken.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. get_index does not return a scaled index",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "The get_index function in contracts/margined-power/src/query.rs:78-95 does not scale the calculated index, as the naming suggests. Also, it does the same as the get_unscaled_index function, making one of these functions redundant. We classify this issue as minor given that the get_index function is used as part of a query entry point that third-party contracts may rely on.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Events/attributes are not always emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "Multiple functions within the scope of this audit do not emit event attributes. It is best practice to emit attributes to improve the contracts' usability and support o-chain event listeners and blockchain indexers. The following functions do not emit events or attributes:  In contracts/margined-collector/src/handle.rs:56, the send_token function is lacking attributes, such as amount and to_address.  In contracts/margined-staking/src/handle.rs:89, the handle_claim function is lacking attributes, such as amount.  In contracts/margined-staking/src/handle.rs:152, the handle_stake function is lacking attributes, such as staked_amounts.  In contracts/margined-staking/src/handle.rs:209, the handle_unstake function is lacking attributes, such as sent_funds.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Inecient execution could be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "function update_rewards in The contracts/margined-staking/src/distributor.rs:36 lacks optimization of the execution path when block_rewards is zero: Although the result could be short-circuited if there are no block_rewards, the whole function is executed, consuming unnecessary resources and gas. staking contract the of",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. The power contract can be opened multiple times",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "contracts/margined-power/src/handle.rs:41 the In handle_open_contract function, it is not checked if the contract was already opened. An administrator can therefore open it multiple times successfully. While this has no negative security impact, it can confuse consumers because the event open_contract is emitted every time the function is executed. within",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Lack of role-based access controls for the pausing mechanism",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "The contracts within scope implement pausing mechanisms, which is in line with best practices. However, all of the administrative functions of the contract are centralized in the owner role, which goes against the principle of least privilege. Segregating the pauser role has the additional benet of swifter reactions in case of need when assigned to an EOA compared to the admin that may be a multi-sig or managed by a governance contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Widespread usage of generic errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "The contracts within scope of this audit make widespread use of generic errors. Although not a security issue, generic errors are discouraged as they may decrease the maintainability of the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Token authority check can be bypassed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "The power contract implements the SetOpen entry point to unpause the contract for the rst time after checking that the contract is the authority of the power token. However, there is no mechanism to ensure that this entry point is used the rst time  the authority check can be bypassed by directly calling UnPause.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Unused code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2023-10-25 Audit Report - Margined Power v1.0.pdf",
        "body": "Across the codebase, instances of unused errors, constants, elds within structs and functions exist in the following locations. Unused code should be removed as it can decrease the readability and maintainability of the codebase.  InsufficientFunds in contracts/margined-power/src/errors.rs:19.  UserStakeNotFound in contracts/margined-staking/src/errors.rs:13.  InvalidLiquidation in contracts/margined-staking/src/errors.rs:19.  InsufficientFunds in contracts/margined-staking/src/errors.rs:22.  VaultDoesNotExist in contracts/margined-staking/src/errors.rs:25.  Stakers constant in contracts/margined-staking/src/state.rs:9.  average_staked_amounts eld within the UserStake struct is never read and only assigned once in contracts/margined-staking/src/distributor.rs:85.  DECIMALS, DECIMAL_PLACES, and SCALE_FACTOR constants in contracts/margined-staking/src/contract.rs:25-28.  quote_decimals eld in the Config struct in contracts/margined-power/src/state.rs:31.  DECIMAL_TWO constant in contracts/margined-power/src/helpers.rs:15.  execute_transfer function in contracts/margined-collector/src/messages.rs:3-8.  update and mint functions in contracts/margined-power/src/vault.rs:122 and 149 are redundant and one of them is unused.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Missing denom validation when adding incentives could lead to insucient funds error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "contracts/incentives/src/helpers.rs:95-100, In validate_incentive_schedule function lacks validation to ensure that denomination matches the incentive denomination. the the sent This is problematic because it allows potential attackers to create an incentive schedule with a dierent denomination as long as the amount sent is correct. Consequently, due to an insucient funds error. legitimate users may encounter diculties in claiming their rightful rewards A test is reproducing test_incorrect_denom_deposit test case. issue case this provided in the Appendix in the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Incorrect calculation when simulating with multiple routes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In contracts/oracle/wasm/src/helpers.rs:145-160, the add_route_prices function loads the price source for the denom and multiplies it with the current price. This is incorrect because the third route assets currency is not considered. To illustrate, assume a price source is created with three route assets (e. g. ATOM => MARS => OSMO) while the base denom is congured as USDC. The rst route asset will be simulated in Astroport, making the price currency MARS. After that, the function loads the MARS price from storage and multiplies it, resulting in the price currency becoming USDC. The problem arises when multiplying with the third route assets price, OSMO. When the price source is retrieved, the price currency is expected to be OSMO, not USDC. The function will calculate the price as follows:   =               This is incorrect, because the price currency after the second route asset multiplication (MARS) is not denominated as the third route assets currency (OSMO). Consequently, introduces a aw in the calculation process. this discrepancy in the expected currency versus the actual currency",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Utilization rate can be exploited to surpass 100% for new markets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In contracts/red-bank/src/interest_rates.rs:290-294, the utilization rate of a market is determined by the ratio of total debt divided by total collateral. If a new market is instantiated with zero deposits, an attacker can inate the utilization rate to steal funds from the contract. An exemplary step-by-step attack follows: 1. ATOM market is instantiated. 2. The attacker becomes the rst depositor and deposits 1 uatom, increasing the markets total collateral. 3. The attacker donates 1000 ATOM to the contract directly",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. The attacker receives around 84000 ATOM after 10 seconds due to the inated utilization rate. For more information on this type of attack, please refer to the Silo Finance Vulnerability Disclosure. A test case reproducing this issue is provided in the Appendix in the zero_deposit_poc test case. Recommendation We recommend limiting the utilization rate to a maximum value of 100%. Status: Resolved 4. Removing whitelisted denoms causes leftover rewards to get stuck",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Duplicated denoms might cause incorrect whitelist counts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "contracts/incentives/src/contract.rs:173 In the execute_update_whitelist function does not dedupe denoms in the add_denoms and remove_denoms vectors. 187, and This is problematic because providing duplicate denoms to be added or removed would inate the whitelist_count variable, causing an incorrect state stored in the contract. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Oracle centralization risks with Fixed price sources",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In the current design, the owner can post arbitrary prices to the oracle using a Fixed price and source contracts/oracle/osmosis/src/price_source.rs381-392. not validated, and every value is accepted. contracts/oracle/wasm/src/price_source.rs:184-195 Prices are in This can be problematic since an attacker that gets access to the private key of the owner can arbitrarily manipulate prices without any restrictions. For example, the attacker could set the price of all assets to 0, which would allow the attacker to liquidate all users at their loss. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Misconguring tolerance value to be higher than window size causes incorrect price reported",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "the contracts/oracle/wasm/src/price_source.rs:316-321, In query_astroport_twap_price function iterates over all snapshots to nd those whose period falls within a specied tolerable window. This window is dened as the period ranging from the window size minus tolerance to window size plus tolerance. This calculation implies that the window size exceeds the tolerance period. Suppose the owner miscongures either the tolerance to be higher than the window size or the window size to be lower than the tolerance. In such situations, the above assumption will not hold, and the tolerable window period will not be eectively enforced. Consequently, the valid tolerable window period could be a value smaller than window size minus tolerance or higher than window size plus tolerance, aecting the nal price reported. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Removing price sources in the oracle could stop reward collector operations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In contracts/oracle/base/contract.rs:106, RemovePriceSource messages in order to remove price sources from the oracle. the contract owner can execute However, the removal of asset prices could have a detrimental impact on the operations of the swapper and reward collector contracts. Specically, in contracts/swapper/astroport/src/route.rs:91-92, the swapper retrieves oracle prices during a swap process. If the owner proceeds to remove the price source associated with the fee_collector_denom or the safety_fund_denom, the swap operation will encounter an error. This would render it impossible to carry out asset swaps within the reward collector.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Missing prerequisites check when adding a Pyth price source",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In and contracts/oracle/wasm/src/price_source.rs:184 contracts/oracle/osmosis/src/price_source.rs:381, when validating a Pyth price source, no validation is performed to enforce prerequisites. In fact, since Pyth prices are denominated in USD, a price source from USD to base_denom is needed in order to compute prices correctly. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/address-provider/Cargo.toml  contracts/incentives/Cargo.toml  contracts/oracle/base/Cargo.toml  contracts/oracle/osmosis/Cargo.toml  contracts/oracle/wasm/Cargo.toml  contracts/red-bank/Cargo.toml  contracts/rewards-collector/Cargo.toml  contracts/swapper/base/Cargo.toml  contracts/swapper/astroport/Cargo.toml  contracts/swapper/osmosis/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Funds in the swapper contract can be stolen",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In contracts/swapper/base/src/contract.rs:155-182, the swap_exact_in function swaps Coins dened in coin_in input parameter without checking that they are provided by the user in info.funds. This vulnerability enables potential attackers to seize all the coins within the contract by sending swap messages with specically chosen coin_in parameters. We classify this issue as informational because the swapper contract is not intended to hold any funds, as the TransferResult message will distribute all the funds out.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Unvalidated veto time lock duration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-01-10 Audit Report - DAO DAO Veto v1.0.pdf",
        "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:67 and 634, the timelock_duration is not validated to be an actionable duration for humans, i.e., very short and even zero durations are allowed. Consequently, this could lead to falsely executed proposals because the veto time lock duration is so short that it is de facto skipped even if it was congured. We classify this issue as minor because only the DAO, which is a privileged address, can congure the veto timelock duration. to also This contracts/proposal/dao-proposal-single/src/contract.rs:68, 653, and 967. applies issue",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. State migration is not implemented in the dao-proposal-multiple contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-01-10 Audit Report - DAO DAO Veto v1.0.pdf",
        "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:1030, the migrate entry point does not implement any state migration to update existing proposals to in is support contracts/proposal/dao-proposal-multiple/src/msg.rs:235-239. conguration. comment indicated veto This the in Consequently, migrating old dao-proposal-multiple contracts to use the latest version will cause proposals to fail to serialize and deserialize properly, causing the contract to fail to work as expected. We classify this issue as minor because the contract migration admin can recover this by implementing the state migration and migrating the contract into a new code ID.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Vetoer can execute only_members_execute proposals even if they are not part of the DAO",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-01-10 Audit Report - DAO DAO Veto v1.0.pdf",
        "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:466-473, the execute_execute function allows to execute proposals when config.only_members_execute is enabled. This allows the vetoer to execute the proposal early if veto_config.early_execute is true, as seen in lines 492-504. the vetoer However, if veto_config.early_execute is false and the proposal passes, the vetoer can execute it even if they are not one of the DAO members. We classify this issue as informational because the vetoer can only be congured by the DAO, which is a privileged address. Please see the test_veto_execute_only_members_execute_proposal test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Potential inability to veto proposals if chain halts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-01-10 Audit Report - DAO DAO Veto v1.0.pdf",
        "body": "the In contracts/proposal/dao-proposal-single/src/proposal.rs:82-88, current_status function determines the proposal status by checking whether the current timestamp exceeds the proposal expiration and veto timelock duration. If it exceeds, the proposal is evaluated as Status::Passed. This is problematic because if a chain halt occurs and the chain is restarted, the current timestamp might already exceed the proposal expiration and veto timelock duration. In that case, the vetoer would not have time to react (e.g., to veto and cancel the proposal), allowing the proposal to be executed even if rejecting the proposal was the intended decision. This contracts/proposal/dao-proposal-multiple/src/proposal.rs:82. exists issue also in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Manually unpausing the hub contract after migration might lead to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2021-11-23 Audit Report - Lido Finance stLuna v1.2.pdf",
        "body": "The migration process described below has been implemented after the frozen commit for this audit. A change to the migration logic of the hub contract was necessary since a migration within one transaction ran out of gas. An audit of the updated migration logic has been performed on commit e04eb1313c481bdeae084a1dab064afdab5ddbae. the hub contract, During migration of to true in contracts/anchor_basset_hub/src/contract.rs:755, which leads to a rejection of all messages except updates of params and the migration of old unbond waitlist entries in line 137. a paused param is set In the current implementation, the contract must be explicitly unpaused by the owner when the migration is done. There is no validation that the migration has actually been fully performed though. If unpaused before the migration has been nished, partially migrated unbonding waitlist entries might be processed, which could cause missed waitlist entries without a way to recover. Additionally, the paused ag can be used at any time by the owner to pause/unpause the hub contract. If the owner key is ever compromised, ownership could be transferred and the contract paused, leaving any funds inaccessible. We classify this issue as minor since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Total liquidity tokens are incorrectly increased, causing lower rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "In the contracts/incentives/src/astro_incentives.rs:241-247, decrement_staked_lp function increases the ASTRO_TOTAL_LP_DEPOSITS state amount instead of decreasing it. This is incorrect because this function is called when users withdraw in contracts/incentives/src/astro_incentives.rs:91. liquidity tokens their Consequently, the computed rewards will be less than intended due to the inated number of liquidity tokens (see contracts/incentives/src/helpers.rs:226-243), causing a loss of rewards for stakers.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attackers can bind vault account ID to forcefully cause a loss for users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "the bind_credit_manager_account In contracts/vault/src/execute.rs:22, function can only be called by the credit manager contract to bind the vault account ID. After binding it, users can interact with the vault to deposit and redeem their tokens with the accrued reward. vault address The issue is that anyone can call the CreateCreditAccountV2 message while specifying the (see contracts/credit-manager/src/execute.rs:69-87), allowing them to manage the funds deposited in the vault. Suppose an attacker gets control of the vaults account ID, and users start depositing funds. In that case, attackers can steal funds by purposely borrowing a huge amount of tokens and using another address to liquidate the vault for prot. bind to to it",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Liquidatees staking rewards are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "In the contracts/credit-manager/src/liquidate_astro_lp.rs:47, liquidate_astro_lp function sends the UnstakeAstroLp message to liquidate the borrowers collateral from the incentives contract. The incentives contract will compute the rewards in contracts/incentives/src/astro_incentives.rs:346-353. credit manager them to contract, transfer seen and the as The issue is that the credit manager contract ignores the accrued rewards, causing a loss of rewards for the borrower. Instead, the borrower should receive the accrued rewards for the staked period even though they are liquidated. For comparison, the stake_lp function in querying after accrues contracts/credit-manager/src/stake_astro_lp.rs:17-36. incentives contract rewards user the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Users cannot stake new liquidity tokens on Astroport",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "In the contracts/incentives/src/query.rs:95, query_unclaimed_astro_lp_rewards function dispatches a PendingRewards query message to Astroport to retrieve the number of rewards accrued by the incentives contract. This function is called to accrue user rewards before increasing their liquidity token balance, which inuences the reward amount. The issue is that the PendingRewards query assumes the incentives contract has staked liquidity tokens previously before calling the function. Otherwise, an error will occur when retrieving the position (see the query_pending_rewards and load_position functions). This means that the StakeAstroLp message will always fail for new liquidity tokens as Astroport assumes the incentives contract to have an existing balance, which is not the case. Consequently, users cannot stake their liquidity tokens on Astroport, breaking the protocols intended functionality.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Potentially outdated congurations stored in the vault",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "In contracts/vault/src/instantiate.rs:37-46, the vault contracts init function sets the ORACLE, HEALTH, and ACCOUNT_NFT addresses to the query response of the credit manager contract. This is problematic because if the credit managers contract owner updates in these contracts/credit-manager/src/update_config.rs:31-91, they will not be reected in the vault contract. addresses values new to For example, if the oracle contract is unmaintained and updated to a new address, the vault contract could potentially be exposed to stale and incorrect prices, causing incorrect accounting.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Incorrect liquidity tokens unstaked for ActionAmount::Exact",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "In the contracts/credit-manager/src/unstake_astro_lp.rs:32-41, unstake_lp function computes the amount of liquidity tokens to unstake by deducting the the amount from ActionAmount::Exact from the users balance. This is incorrect because when the user species ActionAmount::Exact, the user wants to withdraw the exact amount of liquidity tokens. indicates that it For example, if the users balance is 1000 tokens and ActionAmount::Exact is specied as 100, the unstaked amount is incorrectly 900 instead of 100 tokens.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Using AstroportSpot can introduce price manipulation risk",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "contracts/oracle/wasm/src/price_source.rs:401, option In query_price function using price to WasmPriceSource::AstroportSpot. However, consuming spot prices into Mars protocol can introduce price manipulation risk and should therefore be avoided. includes fetch spot the an a",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Vault unlock may revert because of cooldown end timing of a position",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "In contracts/vault/src/execute.rs:209, it is required that the user-provided vault tokens are equal to the sum of the unlocked vault tokens. This sum is calculated by iterating over all positions where the eld cooldown_end is less than or equal to the current block timestamp. This logic can make it very dicult for a user to send the correct amount of tokens when the transaction is initiated at a time close to the cooldown_end value of a position. Then, the sum will vary depending on whether the transaction was included in a block that was produced slightly earlier or slightly later than this timestamp. If the amounts do not match, the user has wasted gas and needs to try unlocking again.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Duplicate code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "In contracts/oracle/wasm/src/lp_pricing.rs:26-42 the code to fetch the price of coin0 and coin1 is duplicated in lines 157-173. Duplicate code can negatively aect the maintainability of the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Inconsistent use of u32::from and as u32 for type conversion",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "contracts/oracle/wasm/src/lp_pricing.rs:118, is In coin0_decimals converted to a u32 type using u32::from(coin0_decimals), however, in contracts/oracle/wasm/src/lp_pricing.rs:218 the coin0_decimals is cast to a u32 type using coin0_decimals as u32.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Redundant check for !rewards.is_empty() in claim_lp_rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "In the contracts/credit-manager/src/claim_astro_lp_rewards.rs:33, claim_lp_rewards function includes a redundant check !rewards.is_empty() since that check was already performed in line 19 of the same function.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Incorrect token referenced in comment",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "In contracts/vault/src/execute.rs:182, there is a comment stating \"// check that only the expected base token was sent\". However, it is the vault token that is being passed to the cw_utils::must_pay function below the comment.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Unnecessary address lookup",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "In contracts/incentives/src/astro_incentives.rs:290, the ensure_eq! macro checks that the sender is the credit manager. However, the credit manager is passed in the as credit_manager_addr variable could be used since that has been set earlier in line 284. This unnecessary address lookup is inecient. &addresses[&MarsAddressType::CreditManager] when, fact, in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Missing validations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "There are several instances where validation is missing:  In contracts/oracle/wasm/src/price_source.rs:219, the validate function returns the price variable for WasmPriceSource::Fixed option without validating that the price is greater than zero.  In contracts/credit-manager/src/stake_astro_lp.rs:26, if the variable amt is greater than a users LP coin balance, there will be an underow error in decrement_coin_balance.  In contracts/credit-manager/src/stake_astro_lp.rs:27, zero, coin_balance decrement_coin_balance. is there will be an underow error if in  In contracts/vault/src/instantiate.rs:64, the cooldown_period is not validated to be greater than zero.  In contracts/vault/src/instantiate.rs:75, the base_token address is not checked to be a valid address.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Redundant code setting accumulated_pnl and accumulated_fee to zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2024-07-15 Audit Report - Mars v2 on Neutron v1.0.pdf",
        "body": "In contracts/vault/src/performance_fee.rs:72, the accumulated_pnl and accumulated_fee are set to Uint128::zero(). However, this is redundant since these values will already be set to Uint128::zero() in the default function.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Disabled collateral can be re-enabled by depositing on behalf of the user",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/red-bank/src/execute.rs:471, the users collateral to market bit is automatically set if the user deposits a collateral asset. An attacker can re-enable a disabled asset as collateral by depositing a small number of funds on behalf of a victim. As a result, the re-enabled collateral will get liquidated if the borrower does not maintain the sucient liquidation threshold ratio. This might cause an unexpected loss to the victim since they disabled the asset as collateral. Please see the test_enable_asset_as_collateral_for_other_users test case in the appendix to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Swapping assets in the reward collector contract are vulnerable to sandwich attack",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/rewards-collector/osmosis/src/route.rs:121, the minimum amount of swap output is hardcoded to zero. Due to no slippage protection, an attacker can the normal price, calling the perform a sandwich attack by purchasing the asset at SwapAsset operation to buy the asset at an increased price, then immediately selling it for a prot. The attacker can repeatedly perform this attack to force the contract into buying assets at a higher price, resulting in a loss of funds.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Red banks markets with an id greater than 128 cannot be used",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "The red bank contract can handle an indenite amount of Markets that are created by the contract owner and stored in the MARKETS mapping. Each Market struct has a unique index attribute that is responsible for indicating its bit position in borrowed_assets and collateral_assets bitmaps dened in the User struct. Since those bitmaps are Uint128, they can handle a maximum of 128 Markets. This implies that any Market with an index greater than 128 cannot be used because of an overow in contracts/red-bank/src/helpers.rs:29.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Incorrect refund address during debt repayment",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "the caller The repay function allows repayment of a loan on behalf of other accounts. In a scenario where in account contracts/red-bank/src/execute.rs:843, refund the excess amount to the target address passed in the on_behalf_of parameter and not the caller. This implies that the party repaying the loan will lose funds to the debtor. behalf the function will overpays another debt on of",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Computationally heavy unbounded loop during user position health calculation can lead to out-of-gas execution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "contracts/red-bank/src/health.rs:121, In get_user_positions functionality attempts to loop over all markets initialized in the red bank contract. Since the is unbounded and markets cannot be removed, the execution gets more market count expensive with the number of markets and might eventually run out of gas if there are too many markets initialized. the This issue is also present in the UserDebts and UserCollaterals query messages in contracts/red-bank/src/query.rs:123-149 and 164-180. The queries attempt to loop through all markets without any pagination limit.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Address provider contract does not validate the newly set owner as valid address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/address-provider/src/contract.rs:77, the contract owner is set to the new_owner string provided by the caller. If the new owner is not a valid address, it will cause the address provider contract to have an invalid owner. As a result, it would prevent the SetAddress and TransferOwnership functionality from working correctly. We consider misconguration. this a minor",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Users will be unable to claim rewards if too many asset incentives are added",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In the incentives contract, users can call ClaimReward to retrieve their accrued Mars rewards. The message is handled by the compute_user_unclaimed_rewards function in line contracts/incentives/src/helpers.rs:84 which loops through all the asset incentives. On a long enough timeframe, if many assets get added to the protocol, this gets more expensive and could eventually run out of gas and hence block claiming of rewards for a given user.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Addresses are not validated if a wrong prefix is set in the address-provider contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "contracts/address-provider/src/helpers.rs:11, the In assert_valid_addr function is executed, all addresses that start with a prefix dierent from the stored one are assumed to be valid without executing api.addr_validate. when This implies that invalid addresses can be stored in the contract mapping and that the check on the given prefix can be bypassed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Setting price source for liquidity token aects Prices query message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/oracle/osmosis/src/price_source.rs:125-127, the liquidity token price source cannot be queried as it will return an Unimplemented error. However, the contract owner can add a liquidity token price source in lines 97-99. This means that the Prices query message would be aected since it includes the liquidity token price source when querying. Note that users can manually avoid querying the LiquidityToken price source by ltering out the aected entry with the start_after and limit arguments. Please see the  test_query_liquidity_token_prices test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Markets reserve_factor attribute is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In packages/outpost/src/red_bank/market.rs:79, the validate method for the Market struct is not checking reserve_factor. Since this attribute represents the percentile of the borrow rate that is kept as protocol rewards, a value greater than one could cause the execution to distribute an incorrect amount of funds. We consider this issue to be minor since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Contracts are not compliant with CW2 Migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "The following contracts do not adhere to the CW2 Migration specication standard:  address-provider  oracle  incentives  red-bank  rewards-collector This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Unversioned dependencies could lead to supply chain attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "oracle The contracts/oracle/osmosis/Cargo.toml:37. requires contract osmo-bindings as a dependency in Since it is fetching it directly from the GitHub repository without specifying the wanted commit hash or tag, any changes to that repositorys main branch may accidentally be included in the contract. This could lead to bugs as well as supply chain attacks.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. optimal_utilization_ratio value could cause a division by zero panic if not correctly validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In the packages/outposts/src/red_bank/interest_rate_model.rs:35, divide_decimal_by_decimal is dividing the current_utilization_rate by optimal_utilization_rate. Since optimal_utilization_rate is not validated to be greater than zero, this division could cause a panic.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Zero Mars token code identier will lead to InitAsset failures",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/red-bank/src/execute.rs:60, when conguring the Mars token code identier, it is not validated to not be zero. If the code identier is congured as zero, it will cause the InitAsset functionality to fail. This issue is also present in line 103 when updating the conguration.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Liquidator is unable to specify the receiver address which negatively impacts integrations and exibility",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/red-bank/src/contract.rs:72, there is no way for the liquidator to specify the recipient address for receiving underlying collateral. This will add overhead for periphery contracts to specify the logic for redirecting the liquidated assets transfers to rightful liquidators.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Avoid meaningless conguration update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/oracle/base/src/contract.rs:113, the contract owner can update the execution will be the conguration with the owner value as None. As a result, to the meaningless because the option_string_to_addr functionality will default original conguration owner. This would cause no changes to be modied in the end.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. InvalidDepositAmount validation during red bank deposit can be removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/red-bank/src/execute.rs:459-464, the check ensures the deposit amount is not zero when depositing in the red bank. This check is unnecessary as the one_coin functionality from cw_utils already prevents zero amounts, as seen in contracts/red-bank/src/contract.rs:53.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/address-provider/Cargo.toml  contracts/oracle/base/Cargo.toml  contracts/oracle/osmosis/Cargo.toml  contracts/incentives/Cargo.toml  contracts/red-bank/Cargo.toml  contracts/rewards-collector/base/Cargo.toml  contracts/rewards-collector/osmosis/Cargo.toml While enabled implicitly through the workspace manifest, future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Contracts should implement a two step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "20. TWAPs are more sensitive to manipulation than median prices in \"one-block\" attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In a \"one-block\" attack, an attacker manipulates the price of an asset and then arbitrages it back in the next block. This type of attack is possible when the attacker knows in advance to be the creator for the next block (e.g. the attacker is a validator in PoS blockchains with deterministic slots) since the validators can order transactions to minimize the risk of the attack. Because TWAPs are calculated using the time-weighted average of prices, a \"one-block\" attack will have a greater impact on the TWAP calculation than on the median price. This is because the manipulated price will be included in the TWAP calculation, whereas it will not aect the median price. Therefore, TWAPs are more sensitive to manipulation than median prices in \"one-block\" attacks.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "21. Custom access control implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "Contracts implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Bad debt state is not recorded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "In contracts/margined_engine/src/messages:185, the withdraw function called when executing the WithdrawMargin message is updating the bad_debt attribute of the state. As state is passed as a &mut, the withdraw function caller has in the state variable the updated bad_debt value. The state is not stored though, hence the new value is available only in the current execution scope and cannot be retrieved in a subsequent execution. Consequently, the bad_debt information is never saved in the contract store, and the information is lost. This implies that the margined_engine could be insolvent or with an insolvency risk without being aware. Additionally, the State query, which will be used to track the margined_engine status, would always report the bad_debt metric to be lower than the real accrued debt. See Appendix-1 for a test case that shows this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Incorrect accounting during liquidation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "The margined engine contract incorrectly keeps track of the funds that should be requested or sent to the insurance funds contract upon liquidation. of the case liquidation_fee In in contracts/margined_engine/src/reply.rs:458, remain_margin.margin is not set to zero at the end of the if block, eectively being used rst in the calculation of bad_debt and later on the transfer of remaining margin at line 474. This results in the engine contract unexpectedly moving additional funds to the insurance fund contract. remain_margin.margin > if there is no previously recorded state.bad_debt and the engine contract In addition, doesnt have enough funds to pay a liquidator, the missing amount would be withdrawn twice from the insurance fund contract: The rst during realize_bad_debt in line 468 and a second time during withdraw in line 479. Given the Bad debt state is not recorded issue, this could cause the Insurance Fund contract to be drained faster than expected, potentially causing insolvency issues if not watched carefully. Additionally, these extra transfers incremented gas costs on every transaction related to the aected feature. See Appendix-3 for a test case that shows this issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Bad debt is wrongly reset upon realization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "the in When realize_bad_debt non-zero is contracts/margined_engine/src/utils.rs:81 state.bad_debt value, instead of updating it with any additional bad_debt and withdrawing funds from the insurance fund contract, it is reset to zero and no transfer from the insurance fund is requested. This implies losing track of any previous debt and not covering the new one given the lack of withdrawal from the insurance fund. function called with a Consequently, the contract could be at an insolvency risk without the team being aware as the bad_debt value being reported would be lower than the real accrued debt.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Possible inconsistencies when conguring decimal values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "values decimal In both margined engine and virtual AMM contracts, contract instantiators are required to in specify and contracts/margined_engine/src/contract.rs:62-66 contracts/margined_vamm/src/contract.rs:40. There is no validation that ensures both values are same and consistent with each other when conguring and updating the decimal values via contracts/margined_engine/src/handle.rs:83. If both it will yield incorrect results when executing contracts assume dierent decimal values, SwapInput and SwapOutput, potentially returning a higher or lower output amount than intended that directly aects trader's position size. seen as the MAX_ORACLE_SPREAD_RATIO in Moreover, contracts/margined_vamm/src/contract.rs:26 is represented as 10% with 8 decimal values, meaning that the intended decimal values should be 9 (100_000_000 / 0.1 = 1_000_000_000). Since the constant value cannot be modied, a misconguration of decimals in contracts/margined_vamm/src/query.rs:230 to return an incorrect spread limit exceeded result. query_is_over_spread_limit constant would cause being not that, native token decimals Besides seen in packages/margined_common/src/asset.rs:191. This collides with the virtual AMM satisfy intends decimals MAX_ORACLE_SPREAD_RATIO constant value. are assumed as 6 as requirement decimals accept values since to to it",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Margined engine cannot support native tokens as collateral during mainnet production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "In the packages/margined_common/src/validate.rs:28-33, validate_eligible_collateral functionality only recognizes ujunox and uwasm as supported native tokens when conguring and updating eligible collateral assets. Since ujunox prex only exists in Juno Testnet and uwasm prex originates from wasmd, the hardcoded native tokens will not be usable during production as they dont exist in the Juno mainnet. Also, as not all native tokens follow the utoken convention and could have a custom decimal digits in packages/margined_common/src/asset.rs:191 could lead to possible wrong calculations. representation, hardcoded value 6u8 the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Emergency ShutdownVamms messages are not able to execute SetOpen transactions due to lack of permissions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "In contracts/margined_insurance_fund/src/handle.rs:78, when handling ShutdownVamms messages, the execution is iterating through all the VAMMs registered in the insurance_fund in order to send VammExecuteMessage::SetOpen { open: false } messages to them. Those messages are wrapped in a SubMsg and have the purpose of pausing that specic VAMM. the SetOpen However line contracts/margined_vamm/src/handle.rs:98 that is only accepting transactions intended to be the insurance_fund contract. from its registered Owner that Consequently all the SetOpen SubMsg will fail due missing Owner role permissions. message handler is not guard has at a",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Updating eligible collateral causes state inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "the contract owner can In contracts/margined_engine/src/handle.rs:73-84, update the eligible collateral, which also updates the decimal values accordingly. This is problematic for the following reasons: Firstly, it would cause a state inconsistency issue. The actual balance held in the contract for the newly congured eligible collateral might be dierent than the recorded state. As a result, traders might be unable to withdraw excess margin due to insucient balance. Secondly, it causes a decimal collision issue as the virtual AMM that the margined engine contract interacts directly with is unable to have the decimal values updated. This causes inconsistencies between the two contracts and will be further elaborated on in the next section. is the than previous it would cause incorrect ratios and liquidation fees if the newly congured decimal Lastly, initial_margin_ratio, value. lower value maintenance_margin_ratio, and liquidation_fee values use decimal value as limit (i.e. 0% to 100%), a lower decimal congured will cause ratios and liquidation fees to exceed the 100% limit. For example, if the previous decimal value is 9 and the new eligible collateral uses 6 decimals, a congured 10% ratio or liquidation fee would become 10000%, which will likely cause all positions to be undercollateralized due to contracts/margined_engine/src/handle.rs:284. partial_liquidation_margin_ratio Since We classify this issue as minor, since only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Insurance fund beneciary can be updated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "The insurance fund contract allowed its owner to update the beneciary at any time as seen in contracts/margined_insurance_fund/src/handle.rs:36. A malicious insider or an attacker that compromised the keys of the legitimate administrator would be able to set themselves as the beneciary and then withdraw the contracts funds. We classify this issue as minor since only the owner can update the insurance fund beneciary and it is assumed that the owner is a trusted party.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. The new owner account claims ownership, which applies the conguration changes. Status: Acknowledged 56. Hardcoded packet version for cross-chain requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Voyager Forwarder and CW Gateway v1.2.pdf",
        "body": "In asset-forwarder-middleware:contracts/asset-forwarder/src/execution .rs:198, 303, and 697, a hardcoded version is used when constructing the cross-chain call packet for dierent withdrawal scenarios, such as withdrawing blocked funds or refund requests. This may cause inconsistency and potential issues in the future when it is processed by the counterparty chain. For example, the counterparty chain might reject the request due to version mismatches if a dierent packet version is accepted instead.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Deactivated market assets would cause forced liquidation on borrowers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "In mars-red-bank/src/account.rs:61, the function get_user_position is used internally to calculate the borrowers debt, average liquidation threshold and most importantly the health factor which determines whether the borrower can be liquidated. The function iterates over all assets in that the borrower has a position, without accounting in the markets active state. If a market is deactivated, borrowers will be unable to perform any actions on it including repaying their loans. the market asset This would cause problems if the borrower is borrowing had been deactivated by the contract owner. The debt of the inactive market would still be included when calculating the overall health factor for the borrower. Although the deactivated market asset prevents liquidation attempts, a liquidator can still bypass it by liquidating other active collateral assets. Hence, the borrower would be subjected to forced liquidation due to the inability to repay their loans.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Staking xMars rewards can be sandwiched by an attacker, skimming its value before accruing to stakers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "Protocol rewards can be swapped and transferred by anyone to the Staking contract. A combination of public messages executed in one transaction can be leveraged by an attacker to skim the rewards of xMars stakers as shown below: 1. Withdraw Mars rewards (or ma_mars) using mars-protocol-rewards-collector/src/contract.rs:187. execute_withdraw_from_red_bank from the Red Bank to the Protocol Collector in 2. Sell assets if you have Mars/maMars inventory",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Sell MARS bought in step 4. This can be also exploited with rewards denominated in assets other than Mars, but the severity of this performed on Mars rewards is greater due to steps 6 and 7. Recommendation We recommend either rate-limiting/restricting the access of these public functions, or allowing the Protocol Rewards Collector to send rewards directly in the denomination they are withdrawn from the Red Bank, and swapping them back to Mars on the Staking contract without the intermediate swap to UST. Status: Acknowledged The Mars team is working on ideas to solve this on future versions of the protocol that the community could adopt. In the meantime, the community would have to evaluate the risk of adding Mars as a borrowable asset to the money market. At rst most fees will be collected in uusd which would only be swapped to Mars in the case of staking which would make the window for this attack small. 3. Malicious smart contracts can avoid liquidation attempts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Initializing vesting contract wrongly would cause inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "In the Vesting contract, congurations such as unlock_start_time, unlock_cliff and unlock_duration are congured during contract initialization. There are no validations in place to verify submitted values are correct, eg. unlock_start_time must be a timestamp in the future instead of the past.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Duplicate accounts creation would cause inconsistent total supply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "In the xMars token contract, accounts are created via create_accounts during contract initialization. As shown in contracts/mars-xmars-token/src/contract.rs:53-62, the function loops through a set of accounts without verifying possible duplications. If the accounts contain any repeated address, the previous balance would be overwritten but the total_supply would increase, creating a discrepancy between the two.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Sent tokens other than denoms are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "are then In the Red Bank contract, users can deposit native assets via DepositNative message. The coins called get_denom_amount_from_coins. The function does not limit user sent funds to exactly one type of funds. If the user sent two types of funds (eg. LUNA and UST), the other assets which are not denom would be lost in the contract. function internal parsed which from an is",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Expiration can be set to past timestamp and block height",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "In the Ma-token contract, IncreaseAllowance and DecreaseAllowance allow specifying an Expiration via block height or block timestamp. The specication does not verify whether the supplied Expiration value is higher than the current timestamp or block height. Users may set the expiration value to a past timestamp or block height, which causes the approval to fail.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Overow checks are not enabled for the release prole, which can lead to a loss of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "In contracts/cw20-blocklist/Cargo.toml, overflow-checks are not enabled for the release prole. Since there are arithmetic calculations that do not use checked increasing an calculations to prevent overow issues in the cw20-base contract accounts balance), an overow in production would be silently ignored. (e.g.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Users can evade having blocked funds destroyed by using uppercase addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "The cw20-blocklist contract does maintain the blocklist with lowercase addresses, and it performs lowercasing of an address before checking whether it is on the blocklist. The underlying cw20-base contract, on the other hand, does not lowercase addresses. This discrepancy allows users to evade having blocked funds destroyed, by having their balance sent to an uppercase address, rather than a lowercase one. If a user sends the the Transfer message to a previously unused and not blocked uppercase address, execute_transfer function of the cw20-base contract will update BALANCES with the uppercase address as the key. Blocklisting that address works as expected, since all blocklist see checks If the minter contracts/cw20-blocklist/src/contract.rs:195, 211, and 254. now wants the address DestroyBlockedFunds message, the destroy_blocked_funds function is trying to reduce BALANCES using the lowercased address as a key in lines 160-168. This will fail, since the balance was stored under an uppercase address as the key. associated with transforming lowercase, performed address funds using burn after that are the the to to",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Missing validations during contract instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "In contracts/cw20-blocklist/src/contract.rs:36-38, msg.name, msg.symbol, and msg.decimals are not validated. the passed arguments Without validation of name and symbol, the minter is able to pass invalid or non-printable characters that could aect front-end rendering, allow script injection, or passing strings very long strings which may inhibit usability of the token. Without validation of decimals, the minter is able to pass any supported u8 value (from 0 to 255). An uncommonly large decimal point might cause issues for protocols that build on top of this contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. One-step minter update increase risk of lost minter permissions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "The cw20-blocklist contract allows the current minter to update the minter address in one single step. While this is common practice, it presents a risk for the minting permission to become lost if the new address is incorrect. A two-step minter update will allow the current minter to propose a new minter address, and then the account that is proposed as the new minter may call a separate function that will allow them to claim the minting permission and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Consider using time locks to automatically unblock addresses in the event of a lost/compromised minter private key",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "Throughout the codebase, the minter can perform various privileged actions such as adding and removing addresses to/from the blocklist. A blocked address will remain blacklisted until the minter decides to unblock them. In the event that the private key is lost or compromised and the minter updated, the blacklisted address may never be unblocked.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Blocked addresses can receive tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "In the codebase, there are no restrictions that prevent blocked addresses from receiving tokens. Since the minter can destroy funds held by a blocked address using the DestroyBlockedFunds message, we recommend disallowing funds to be sent to a blocked address.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Removal of Burn and BurnFrom may impact contract composability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "The cw20-blocklist contract does not include the Burn and BurnFrom messages that the cw20-base contract provides. This may impact composability of the cw20-blocklist contract with other smart contracts, In the current implementation, a Redeem message exists, that only allows the minter to burn tokens. that may rely on burning of funds.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Duplicate code impacts maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "Throughout the codebase, privileged execution messages such as AddToBlockedList, RemoveFromBlockedList, UpdateMinter, Redeem, and DestroyBlockedFunds messages are all restricted to minter access. The logic that veries whether info.sender is the minter is duplicated across the handlers for these functions, which negatively impacts the code's maintainability and readability and may lead to future errors.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. cw20-blocklist modies cw20-base interface, which negatively impacts composability and is not documented correctly",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "Compared with the cw20-base contract, following modications: the cw20-blocklist contract exhibits the Initial balances cannot be provided during instantiation 1. Minter is always set to the instantiator 2. Minting cap cannot be set 3. 4. Marketing info cannot be set or queried 5. Burn and BurnFrom messages have been removed 6. Minter, AllAllowances, AllAccounts, MarketingInfo, and DownloadLogo queries have been removed This reduces the composability of the cw20-blocklist contract, since it may not be possible for some projects to swap a cw20-base contract with a cw20-blocklist It also aects frontends and implementation without aggregation layers that may rely on some of the removed queries. Lastly, the documentation in contracts/cw20-blocklist/README.md:3 describes that the cw20-blocklist further modication of their code. contract extends the cw20-base to add blocklist functionality, which is misleading.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Testing wallet seed phrase and private keys are exposed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "In keys.terrain.js, the testing wallets mnemonic and private keys are hardcoded and visible to the public. Although these secrets are intended to be used purely for testing purposes, it is a violation of best practice to commit wallet seed phrases or private keys into a repository. These accounts may accidentally be used by developers on mainnet, in which case funds may be lost or permissions be exploited.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Outdated dependencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "The cw20-blocklist contract contains outdated dependencies, see Appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. Inconsistency between evidence and staking parameters allows malicious validators to escape penalties",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-06-13 Audit Report - Dora Vota v1.0.pdf",
        "body": "In the staking module conguration of the mainnet genesis le, the unbonding_time is set to 1,814,400 seconds (21 days). in config/mainnet/genesis.json:12 the max_age_duration within the However, evidence module parameters is set to 172,800,000,000,000 nanoseconds (2 days), which is a magnitude shorter. in config/mainnet/genesis.json:11, the max_age_num_blocks is Additionally, congured to 100,000, which translates to 600,000 seconds (approximately 6.94 days), assuming a 6-second block time. This duration also falls short of the specied unbonding_time. These discrepancies mean evidence can only be reported during a fraction of the unbonding period, allowing validators who have committed oenses to escape penalties if the evidence expires before the end of the unbonding period.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Unhandled zero-amount transfers in marketplace contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "In several occurrences when performing BankMsg::Send, there is no validation to ensure the amount to transact is greater than zero. Consequently, the transaction will fail and revert. 1. 2. 3. 4. contracts/marketplace/src/execute.rs:1209-1216 the contracts/reserve-auction/src/helpers.rs:143-146, In settle_auction function will fail if the remaining amount is zero after deducting the protocol and royalty fees. In packages/common/src/lib.rs:78-82, the royalty_payout function will fail if the royaltys share is zero. In 1223-1230, deducting the royalty, network, and nder fees. lines In and 1074-1081, the value of execute_remove_stale_collection_bid functions will params.bid_removal_reward_percent is set to zero or to the maximum bps value. lines if the remaining amount is zero after execute_remove_stale_bid if contracts/marketplace/src/execute.rs:1023-1030 the payout function will fail and and the fail",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Validate that the amount is not zero before sending funds to the bidder and operator. Status: Resolved 2. Protocol does not enforce minimum reserve price to be in STARS denom",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "In contracts/reserve-auction/src/helpers.rs:131, the fair_burn function is called to burn a portion of the bid amounts, expecting the bid denom to be STARS. This is problematic because there is no validation ensuring that config.min_reserve_price is in the STARS denom. Additionally, when settling the auction in lines 143-146, the settle_auction function distributes the config.min_reserve_price is denominated in a dierent denom, incorrect funds will be distributed instead. Consequently, denom. STARS funds with the if",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. MAX_FIXED_PRICE_ASK_AMOUNT is not enforced during ask price update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "In the contracts/marketplace/src/execute.rs:412, execute_update_ask_price function does not validate the price.amount does not exceed MAX_FIXED_PRICE_ASK_AMOUNT. This invariant is enforced in line 308 during the execute_set_ask function, but it is not enforced when updating the asking price.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. TODO comment in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "In packages/common/src/lib.rs:65, a TODO comment is in the codebase. TODOs in production code are a deviation from best practices.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Duplicate nder fee validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "contracts/marketplace/src/execute.rs:474-478 In duplicate validations of finders_fee_bps are performed. and 484-488, In fact, the only dierence lines between these two checks are variable names (fee vs finders_fee_bps), but validations are identical. the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Reserve prices can be updated for expired auctions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "the contracts/reserve-auction/src/execute.rs:158, In execute_update_reserve_price function does not validate whether the auction is expired. An expired auction should not be modiable.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Static calculation of weights for the claim_reward extrinsic enables DoS attack vector",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "claim_reward The in pallets/lend-market/src/lib.rs:782-800, iterates over all the existing markets to collect rewards from each of them. function, dened However, since the number of registered markets is not bounded, the execution could exceed the computation limit if too many markets are registered. Since the calculation of the extrinsic weights does not take into account the cardinality of the markets, the fee charged to the origin will be uncorrelated with the actual computational resource usage. This leads to a situation where the execution of multiple claims within the claim_reward extrinsic will cost the same as a single claim done with the claim_reward_for_market extrinsic. Consequently, attackers could leverage this behavior to overload chain nodes by executing claim_reward on multiple markets paying a smaller fee, potentially allowing a denial-of-service attack.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Price feeder centralization risks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "In the prices pallet, the FeederOrigin can set arbitrary emergency prices by executing the in reset_price pallets/prices/src/lib.rs:120-143. set_price extrinsics dened and However, prices are not validated before being stored and every value is accepted. As a consequence, this could lead to the following scenarios: 1. Privilege abuse: An attacker may get access to the private key of the FeederOrigin. He can then use the account to manipulate prices, for example by setting the price for all assets to a small value, which would allow the attacker to liquidate all users at their loss. 2. Input error: Since the provided Price is not validated, provided as input and stored in the contract. Even a Price equal to zero is allowed. incorrect values could be We classify this issue as minor since only a privileged account can perform the aforementioned operations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Multiple foreign_asset_id can be mapped to the same asset_id",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "the set_foreign_asset extrinsic In pallets/prices/src/lib.rs:149-157, permits the UpdateOrigin origin to establish a mapping within the pallet, associating a foreign_asset_id with an asset_id. However, it lacks a verication mechanism to ensure that the given asset_id is not already linked to a dierent foreign_asset_id. As a result, an asset_id can be associated with multiple foreign assets which would lead to market miscongurations. We classify this issue with minor severity since only a privileged account can perform the aforementioned operation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Missing check that foreign_asset_id is specically of the ForeignAsset type",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "In pallets/prices/src/lib.rs:149-157, the set_foreign_asset extrinsic enables the UpdateOrigin origin to establish a mapping within the pallet that associates a foreign_asset_id with an asset_id. However, ForeignAsset type; it is only identied as a CurrencyId. it does not verify that the provided foreign_asset_id is specically of the As a result, the UpdateOrigin can map any asset type, not just foreign assets. We classify this issue with minor severity since only a privileged account can perform the aforementioned operation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Default mantissa precision can lead to an incorrect price",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "In pallets/prices/src/lib.rs:179-186, the get_asset_mantissa function is designed to calculate the mantissa for a given asset by attempting to retrieve the asset's decimal precision from multiple sources. However, if it fails to nd any decimal information for the specied asset_id, it automatically assumes a default precision of 12 decimals. As a result, this approach poses a risk, as the function plays a crucial role in asset valuation, and an incorrect mantissa calculation would lead to the determination of an erroneous price.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Missing validation for the lend_token_id",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "pallets/lend-market/src/lib.rs:656-680, In the force_update_market function enables the UpdateOrigin to assign a new lend_token_id to a specied market. However, it fails to verify whether the lend_token_id is not already a market, a validation that is performed in the ensure_lend_token method in line 1843. As a consequence, this oversight could lead to inconsistencies in market conguration since the lend token is not designed to be used in a market. We classify this issue with minor severity since only a privileged account can perform the aforementioned operation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. The force_update_market extrinsic could break existing markets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "In pallets/lend-market/src/lib.rs:659, the force_update_market function permits the UpdateOrigin to forcibly replace an existing market with another, without ensuring the coherence of the provided data. This poses a risk since UpdateOrigin is allowed to modify markets with any data, including malicious ones that could break invariants. As a consequence, the current approach could result in the acceptance of markets with a collateral_factor or liquidation_threshold outside of the [0,1] range, which could break market operations and potentially cause a loss of funds. We classify this issue as minor since only a privileged account can perform the aforementioned operation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Static calculation of weights for the update_liquidation_fee_collateral extrinsic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "the pallets/lend-market/src/interest.rs:1123-1130, In update_liquidation_fee_collateral extrinsic takes a collaterals vector as a parameter. However, the calculation of the extrinsic weights does not take into account the length of the collaterals vector. As a result, the update_liquidation_fee_collateral extrinsic will charge the same fee for vectors of dierent sizes leading to an uncorrelated relation between fees and computational resource usage. We classify this issue as minor since only a privileged account can perform the aforementioned operation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Missing validation of liquidate_incentive_reserved_factor during market update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "In pallets/lend-market/src/lib.rs:381 the add_market function checks the correct including liquidate_incentive_reserved_factor. This value is forced to be in the (0,1) range. provided market parameters, allowed ranges the for However, pallets/lend-market/src/lib.rs:610, this validation is not performed. update_market function the in in a consequence, when As the updating the market, liquidate_incentive_reserved_factor value outside the (0,1) range, which will have implications in the form of incorrect calculations of incentives when liquidating positions in within liquidated_transfer pallets/lend-market/src/lib.rs:1757. is possible function to set the it We classify this as minor since only a privileged account can perform the aforementioned operation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Incorrect interest is calculated if requested before market initialization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "In pallets/lend-market/src/interest.rs:58, the get_market_status function calculates and returns information about the queried market. However, in case the market has not been used yet, the last_accrued_interest_time variable, when retrieved in line 75 from the LastAccruedInterestTime on-chain storage, would default to zero. Consequently, when get_market_status is called without the market being previously initialized, the interest accrual period is inaccurately computed from January 1, 1970, despite the asset not being used yet leading to a wrong calculation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Inecient active markets search",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "ensure_active_market The in pallets/lend-market/src/lib.rs:1801-1806, searches for a market by comparing identiers one by one in a loop through all markets with an asymptotic complexity of O(n). function, dened However, the same operation could be performed in constant time by using the market method, dened in pallets/lend-market/src/lib.rs:1946. Consequently, this would cause the execution to incur higher costs due to unnecessary iteration.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Inecient market data aggregation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "get_lf_base_position The in pallets/lend-market/src/lib.rs:1145-1151 iterates through all active markets, aggregating collateral for underlying assets. function, dened However, current_collateral_balance function in line 1407. the markets queried are not retained, despite being re-queried later by the Consequently, this would cause the execution to incur higher costs due to unnecessary calculations.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Redundant storage queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "The pallets/lend-market/src/lib.rs le exhibits redundant uses of on-chain storage. For instance, the AccountDeposits storage, introduced at line 315, undergoes redundant queries in lines 945-946, 1280-1283, 1312-1315, and 2105-2106. In each case, the storage is rst checked for the key's presence, followed by a separate query to fetch the key's value. Another example of redundant queries can be seen in line 1146, where the storage query the loop Self::liquidation_free_collaterals is called on every iteration of despite having the same value on each iteration. Minimizing the number of storage queries would enhance both performance and code clarity.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Code duplication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "The pallets/lend-market/src/lib.rs le contains multiple code duplicates: 1. The code fragments in lines 1144-1152 and 1158-1166 are nearly identical, with the only distinction being the function called on the iterated values: and collateral_asset_value liquidation_threshold_asset_value (line 1163) in the other. instance 1149) (line one in 2. The code fragments in lines 1312-1325 and 1280-1293 are nearly identical, with the only distinction being the type parameter: BalanceOf in one instance and FixedU128 in the other. Code duplication undermines maintainability, thereby expanding the potential for security vulnerabilities.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. The get_special_asset_price function consistently returns None",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "In pallets/prices/src/lib.rs:188, the get_special_asset_price function is designed to return a TimeStampedPrice value, but it consistently returns None instead. As a consequence, this behavior is misleading and renders the function ineective.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Inecient reduce_reserves extrinsic execution in case of reduce_reserves parameter equal to zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "In pallets/lend-market/src/lib.rs:1045, the reduce_reserves extrinsic takes reduce_amount as a parameter. However, if this amount is zero, the function will perform all operations unnecessarily, which is inecient and may be misleading to the function caller.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Use of magic numbers decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "Throughout the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. Instances of magic numbers are listed below:  pallets/lend-market/src/farming.rs:28  pallets/lend-market/src/rate_model.rs:173",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. State change events are emitted even if no change has occurred",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "In and pallets/lend-market/src/lib.rs:778 pallets/lend-market/src/lib.rs:678, when updating market parameters, the event about success is emitted regardless of whether anything has been changed. If none of the optional values are specied, then the function will end without changing the state, but the MarketRewardSpeedUpdated or UpdatedMarket event will be emitted, which is inconsistent with the function's logic.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Miscellaneous comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Bifrost/2024-03-11 Audit Report - Bifrost Finance Leveraged Staking v1.0.pdf",
        "body": "Miscellaneous recommendations can be found below:  In pallets/lend-market/src/lib.rs:1894 there should be an Overflow error, not an Underflow one, causing exchange_rate to be between (0.02, 1) range, so the division of amount value and exchange_rate could cause overow only.  In pallets/lend-market/src/lib.rs:959, it should be used asset, instead of assert.  In pallets/leverage-staking/src/lib.rs:129, NotSupportTokenType should be reworded to NotSupportedTokenType.  In pallets/lend-market/src/interest.rs:141, the inequality should be greater than or equal to 0.02, not only greater, based on code implementation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Wallet fees can be circumvented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "function The contracts/core/factory/src/service/create.rs:26 user-provided proxy_initial_funds as an argument. create_wallet calls ensure_enough_native_funds by passing in the Subsequently, the ensure_enough_native_funds function iterates through these funds and adds the wallet fee to the entry in proxy_initial_funds which has the same denom as the wallet fee. However, the code does not check that proxy_initial_funds contains such an entry. If it does not, the wallet fee is not added to the vector required_funds and no check is in place whether the user has sent the expected funds. logic This proxy_initial_funds that does not contain an entry with the fee denom. fee by dening a allows users the wallet to bypass vector of",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Full-featured wallet creation may run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "create_wallet The in factory/src/service/contract.rs:22-30 within the factory contract has the potential to execute a substantial number of operations in case of full-featured walled creation, posing a risk of running out of gas during execution. function dened The following steps are executed within the create_wallet function: 1. Two messages are dispatched: One for instantiating the proxy contract and another one for sending the fee to the deployer. 2. The instantiate function of the proxy contract stores each element from the initial_data vector",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. For each element in plugins, a message is executed to the plugin registry contract and the plugin contract is created and instantiated. As a result, execution could potentially run out of gas not allowing users to create the wallet. if there are a sucient number of elements in the mentioned vectors, the Recommendation We recommend breaking down wallet creation into multiple transactions to allow users to create a basic wallet and then perform other transactions to add features. Status: Acknowledged 3. Malfunctioning or malicious plugins could make the proxy contract unusable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Wallet nonce can be reset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "In proxy/src/wallet/exec.rs:62-77, substitute the controller. the rotation function allows the user to A check is in place to not allow the user to substitute a controller with the same one in order to reset the nonce. However, by using a third controller, the user can perform a double rotation and still reset the nonce, allowing message replay. We classify this issue as minor since only the user itself can perform this operation to reset their nonce.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Code IDs unregistered before whitelisting could allow attackers to instantiate whitelisted malicious contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "and In factory/src/contract.rs:80-81 factory/src/management/contract.rs:47-53, before storing the provided proxy contract code ID, the execution does not check whether it has already been registered. Consequently, an attacker could attempt to upload a malicious service, whitelist, using the aforementioned code ID. included in the We classify this issue with minor severity because this misconguration is only possible from the admin during the instantiation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Providing multiple instances of the same AuthenticatorInstInfo type does not raise an error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "In factory/src/contract.rs:100-103, if the user supplies multiple instances of the same AuthenticatorInstInfo type during the execution of the instantiate function, the process does not produce an error, but it proceeds with a continue instruction. As a result, the execution will store only the rst AuthenticatorInstInfo encountered and no error will be raised. It is best practice to inform the user in case the provided input is ignored or an error occurs.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. The ensure_enough_native_funds function fails if coins are not provided in the expected order",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "the factory/src/service/create.rs:105-137, In ensure_enough_native_funds function veries that the funds sent by the user cover both the fee and the proxy_initial_fund. However, if the order of the coins in the sent_fund and proxy_initial_fund vectors is not the same, the function will fail since there is a check that uses the equality operator.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. It is possible to create wallets with not whitelisted proxies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "In factory/src/service/create.rs:35-37, the proxy_code_id provided by the user in create_wallet should be validated to exist within the whitelist of supported_proxies. Failure to enforce this check could allow the user to designate any contract as a proxy, including potentially malicious ones. We classify this issue as minor since this misconguration is only possible from the admin.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Missing address validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "In proxy/src/contract.rs:111, during the execution of the instantiate function of the proxy contract, the controller address is stored in the contract. contain However, AuthenticatorProvider::Custom, it should be validated before being stored. address since can the an in it case of in plugin_registry/src/management/plugin_mgmt.rs:60, Similarly, the metadata_data.creator address should be validated before instantiating the Plugin struct.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. The update of the deployer address in the factory contract could disrupt the operations of the proxy contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "In proxy/src/contract.rs:115-119, during the proxy contract deployer address is fetched from the factory contract and stored. instantiation, the However, since the deployer address can be updated in the factory contract, its update will not be reected in any previously instantiated proxy that will continue querying the old one. Consequently, it is advisable to not fetch the deployer address during the execution of the proxy contracts instantiate function, as any changes will not be reected here.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. It is possible to overwrite existing registered plugin contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "In plugin_registry/src/management/plugin_mgmt.rs:68-70, the register function does not ensure that the provided plugin code_id is already registered in the plugin_code_ids map. Similarly, new_plugin_version function allows the deployer to store existing code_ids. in plugin_registry/src/management/plugin_mgmt.rs:160-161 the Consequently, it is possible to overwrite an existing plugin and assign to it a new code_id. We classify this issue as minor since it can be caused only by the reviewer, which is a privileged account.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Subscription tiers are not updatable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "the plugin_registry/src/management/config.rs:5-22, In add_subscription_tiers function does not allow the modication of existing subscription tiers. Attempting to update an existing tier in the add_subscription_tiers function will result in an error in line 12. it Consequently, subscription fee. is not possible for the deployer to modify elements such as the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Missing pagination for the plugin query",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "In proxy/src/plugin/contract.rs, the plugins query returns a combined list of exec_plugins, pre_tx_plugins, and post_tx_hooks_plugins. However, since there is no pagination in place, performance issues might occur as the number of plugins grows, up to the point where the query could run out of gas.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Missing subscriber contract validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "In plugin_registry/src/service.rs:120-166, plugin_registry contract enables proxy contracts to subscribe to the requested tier. the subscribe function in the However, since there is no check in place to conrm that the sender is a proxy contract, any address can subscribe and pay the subscription fee.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Lack of input vector deduplication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "In the following locations, vectors provided as input to the contract are not deduplicated:  In factory/src/contract.rs:82-86, during the instantiate function, Additionally, the vector should include, at a minimum, the default one. the supported_proxies vector execution the lacks deduplication. of  In factory/src/contract.rs:89-95, the supported_chains vector is not deduplicated.  In plugin_registry/src/contract.rs:87-91, the subscription_tiers vector lacks deduplication.  In factory/src/service/create.rs:105-137, the proxy_initial_fund vector is not deduplicated.  In proxy/src/contract.rs:129, the relayers vector lacks deduplication allowing the execution of duplicated MsgGrantAllowance messages.  In proxy/src/contract.rs:158-182, the required_chains vector deduplication allowing MsgRegisterInterchainAccount messages. the execution of lacks duplicated Consequently, the contract could store duplicated elements or in the case of mappings only the last duplicated element of the vector.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Missing input validation for wallet fees",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Vectis/2024-03-14 Audit Report - Vectis v1.0.pdf",
        "body": "When the factory is instantiated in contracts/core/factory/src/contract.rs:81, the wallet fee is not validated. The specied denom may therefore be invalid. In such a scenario, creating wallets will not be possible and a redeployment of the factory will be necessary.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attacker can drain funds by refusing completed oers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "In contracts/nft-loans-non-custodial/src/execute.rs:336, a borrower can refuse an oer even if the oer had been accepted. Suppose a borrower calls RefuseOffer for an accepted loan  that allows the lender to call WithdrawRefusedOffer in order to withdraw the deposited funds. This is problematic because the lender already had their principal in back interest contracts/nft-loans-non-custodial/src/execute.rs:546-549, resulting in the contract losing funds. repaid and An attacker can exploit this issue by completing and refusing a loan to withdraw excess funds as the lender. This can be exploited repeatedly to drain all funds from the contract. Please see the test_steal_funds test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Borrowers are forced to default on loans with zero fees or interest",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "In the contracts/nft-loans-non-custodial/src/execute.rs:557-567, contract tries to send fees to the treasury without validating that the amount is greater than zero. Suppose a lender accepted a loan with the loan terms interest as 0. The calculated fee amount would be zero (see line 531), causing the contract to send 0 funds to the fee contract. Since Cosmos SDK does not allow 0 amount transfers, borrowers would not be able to repay in time, causing their loans to default. A lender can exploit this issue by providing zero-interest loans, forcing the borrower to default on their loans so the lender can have the NFT in return. Additionally, this issue will also occur if the admin sets the fee rate to the maximum value, preventing all borrowers from repaying their loans successfully.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Attackers can steal NFTs with approvals on contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "and In contracts/nft-loans-non-custodial/src/execute.rs:433-440 contracts/raffles/src/execute.rs:64-71, the CW721 NFT is transferred to the contract using the TransferNft message without verifying the caller is the owner of the NFT. Since the transferred NFT is stored under the callers rae or loan, the caller can withdraw the NFT after it ends, causing the real owner to lose their NFT. The possibility of this could happen when the user approves their NFT in the rst transaction but fails to create a successful rae or loan in the second transaction (e. g. due to invalid arguments). An attacker can then exploit the vulnerability If the approval is not revoked and does not expire in the next block. We classify this as a major issue because the attack requires pre-approval on the contract for successful exploitation.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Malicious rae owner can replay CancelRaffle message to steal NFTs in contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "In contracts/raffles/src/execute.rs:172, the get_raffle_owner_messages function is called to refund the owner their NFT when the owner cancels a rae. The execute_cancel_raffle function does not prevent replay attacks, allowing the owner to cancel a rae as long as there are no tickets bought. An attacker can exploit this issue by creating a rae and immediately canceling it, resulting in the contract storing a valid RAFFLE_INFO for the specic rae identier value. After that, the attacker sells the NFT in a marketplace to a victim. Once the victim creates a rae and deposits the NFT into the contract, the attacker executes CancelRaffle and steals the NFT. We classify this as a major issue due to the high exploit diculty.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Incorrect implementation of CW20 Receive message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "In contracts/raffles/src/contract.rs:113, users can deposit CW20 tokens into the contract through a receive callback function. However, the callback message does not follow the CW20 specication. Consequently, users are unable to deposit CW20 into the rae contract directly. We consider this a minor issue as users can still deposit CW20 tokens using the allowance functionality.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Consider validating fee distribution address and fee rate",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "contracts/nft-loans-non-custodial/src/contract.rs:45 and In contracts/nft-loans-non-custodial/src/admin.rs:40, the contract owner instantiates and updates the fee distributor address. However, in each case, the address is not validated, which could lead to the contract being unable to execute as transfers may be made to an invalid address. the owner contract in Similarly, and contracts/nft-loans-non-custodial/src/contract.rs:46 contracts/nft-loans-non-custodial/src/admin.rs:61. A miscongured fee rate would prevent users from repaying borrowed funds due to overows occurring in contracts/nft-loans-non-custodial/src/execute.rs:527. instantiates updates rate and the fee We classify this as a minor issue since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Withdrawal of IDO pre-fund contributions will fail in most cases due to funds being deposited in Anchor",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The function withdraw_prefund in contracts/ido-prefund/src/execute.rs will revert in most cases since most of the funds are not actually stored in the contract itself but are deposited into Anchor as soon as a certain threshold is reached. This means that withdrawal requests by end-users will fail until the funds are redeemed from Anchor into the contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Missing input validation on staking cong update might lead to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The function update_config in contracts/staking/src/contract.rs fails to validate the unbonding conguration provided as an argument by not calling the available assert_unbond_config function, which ensures that unbonding periods are specied in the right order to be processable by the unbonding logic. This could lead to inconsistent contract state and errors during unbonding attempts.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. The staking contract owner can withdraw all reward tokens from the contract but users can not unbond without penalty",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The staking contract owner can use the function emergency_withdraw to remove all funds from the smart contract. This seems to be intended for emergency use in case of a vulnerability being detected. However, this does leave the user in a position in which they cannot use unbond to get their own funds back without a penalty.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Staking contract can run out of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The staking contract relies on being funded since rewards are transferred from the contracts balance to the user. In the case of the contract running out of funds, users are left without rewards.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Multisig implementation does not follow CW3 specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The implementation of (https://github.com/CosmWasm/cw-plus/blob/main/packages/cw3/README.md). However, does not follow the naming convention for the interface, which might lead to confusion. the multisig contract is relatively close to the CW3 specication it In addition, the code implements basic functionality that is already implemented by the CW3 reference implementation (https://github.com/CosmWasm/cw-plus/tree/main/contracts/cw3-ex-multisig).",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Multisig proposals do not expire and cannot be closed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "Proposals submitted to the multisig remain in an executable state forever. This could lead to old proposals being executed by a signer after circumstances have changed, for example, when a transaction is not relevant anymore. Additionally, the lack of support for cancelling proposals means that a proposer cannot withdraw a past proposal even if the set of signers changes through a cong change. An example of this being a problem could be a proposal having been replaced by a newer version and then accidentally being executed when the signing threshold is lowered.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Staking contract sends UST fees to arbitrary burn address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The staking contract charges a UST fee on all operations. Collected fees can be withdrawn from the contract by sending them to a burn address that can be set by the owner to any address. This is inconsistent with the burn terminology.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Reward withdrawals in staking contract charge fees even if no rewards are distributable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The withdraw function in contracts/staking/src/contract.rs does not fail when no rewards are distributable. This means that the user spends gas and fees without receiving any reward in return. Whilst this may be intentional, it is not what a user would expect as normal behaviour.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Missing tax deductions on UST transfers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "In contracts/ido-prefund/src/execute.rs UST is sent out from the contract in the functions withdraw_prefund and withdraw_ido_funds. In both cases the code fails to account for Terra taxes on native tokens, meaning that these taxes are taken from the contracts balance. In addition, functions deposit_prefund and deposit_anchor_by_admin send UST to Anchor. However, the bookkeeping of user funds takes into account taxes on UST transfers. This is unlikely to lead to the contract ever running out of funds due to fees. However, operator benets may be slightly lower than expected in certain cases.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Potential locked funds in case the user-dened destinationFee does not cover the actual fee",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "In contracts/src/Gateway.sol, the sendToken function accepts destinationFee as an input, allowing users to set any arbitrary fee value. This allows users to send a message with a destinationFee set to zero for executing the transaction as cheaply as possible, which does not cause errors on the Ethereum side. On the Polkadot side though, this may lead to errors: When receiving the message, the in the inbound-queue convert_send_token parachain/primitives/router/src/inbound/mod.rs:124-290. this the dest_para_fee is included in a conversion, DepositReserveAsset XCM instruction. in case dest_para_id is dened, function During executes pallet if dest_para_fee is zero or a value less than the required fee, the XCM However, instruction will fail because of the missing funds for the execution leading to funds being stuck in the agent.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Unveried registerToken function execution outcome could lead to funds being stuck in the agent contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "In contracts/src/Assets.sol:154-172, isRegistered ag to indicate the token registration status on the Asset Hub. the registerToken function sets the this ag is set regardless of However, the success or failure of the token registration command, which could fail for instance if the token is already registered and the Asset Hubs create extrinsic fails in https://crates.parity.io/src/pallet_assets/lib.rs.html#385. Consequently, if the token registration fails or is delayed, every subsequent sendToken function invocation will fail as well on the Polkadot side, leading to user tokens being stuck in the agent contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Inconsistent state in case agent contract instantiation fails on Ethereum",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "In parachain/pallets/system/src/lib.rs:373-394, the create_agent extrinsic updates the Agents map and then sends a message to Ethereum. However, since the message dispatch and execution is async, but the Agents map is already updated, the pallet will act as if the agent contract is instantiated already, even if the instantiation message has not yet been processed. in case the message fails in the Ethereum Gateway contract, the state on the Additionally, Polkadot side will not be reverted, leading to an inconsistent state between the two sides of the bridge.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Lack of cross-chain error handling could lead to inconsistent states, loss of funds, and frozen channels",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "In parachain/pallets/inbound-queue/src/lib.rs, potential errors may arise during the processing of inbound messages, specically on lines 262-263, 268, and 278. These errors can be related to issues in the inbound message structure, XCM conversion, insucient balance to cover processing fees, or problems with XCM delivery. Consequently, in case an error is raised on the Polkadot side, the Ethereum contract's state is already mutated. Failure to handle the error and rollback changes on the Ethereum side for a valid inbound message on the Polkadot side may lead to inconsistent states between the two sides of the bridges. Furthermore, since channels are ordered, a failure in message handling will revert the transaction and will not update the next nonce. As a result, only the erroring message can be proposed, the channel will be stuck and no other message will be able to be executed through it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. The throttling mechanism could delay critical governance operations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "In parachain/pallets/system/src/lib.rs, a throttling mechanism for the queue is implemented to limit the execution complexity of the on_finalize function. This throttling mechanism limits the number of messages retrieved per block from the outbound-queue pallet to a maximum of MaxMessagesPerBlock messages. Consequently, the processing of messages could be delayed depending on the number of messages in the queue of the outbound-queue pallet, but also depending on the number of other pallets interacting with their queues since the message-queue pallet selects autonomously each block which client pallet is served and there is no guarantee that the outbound-queue is selected. This could potentially cause delays in the execution of important commands like SetOperatingMode or Upgrade that should be dispatched promptly to address malfunctioning or exploits of the bridge. For instance, an attacker could exploit this by enqueuing a substantial number of commands to saturate the queue. The implemented segregation of governance channels does not prevent this issue since all the channels rely on the same queue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. The current DOT/ETH exchange rate implementation is not optimal in the context of price volatility",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "The current Snowbridge implementation introduces a parameter responsible for storing the exchange rate of the DOT/ETH pair to calculate a fair transaction fee. Its value is updated manually via set_pricing_parameters extrinsic. This is suboptimal and susceptible to irregularities in the form of large deviations from the actual ETH or DOT price and the stored exchange rate. comment in According parachain/pallets/outbound-queue/src/lib.rs:53, this rate will be updated once every few weeks. Given historical price uctuations in short periods of time between the to DOT and ETH, it is possible that forwarding transactions will be unprotable for relayers or for the protocol itself. Additionally, since the fees are collected but not directly swapped using the provided exchange rate, the value of fee reserves deposited by users is susceptible to market volatility.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. State updates for the primary governance channel are transmitted through the slower channel",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "the Primary Governance In parachain/pallets/system/src/lib.rs:489-490, the update of pricing parameters, contract upgrades, and the Channel handles pausing/resuming of is responsible for creating agents, creating channels, native forced transfers from agents, and forced pausing/resuming of the channel. the Gateway. The Secondary Governance Channel, instead, Forceful channel updates, which include actions such as pausing or resuming a channel and adjusting usage fees, should be directed to the Primary Governance Channel, but are currently managed through the Secondary Governance Channel. As a result, if the Secondary Governance Channel becomes more crowded, the governance's response to any issues could become slower.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Channel-specic outbound_fee is not fully implemented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "parachain/pallets/system/src/lib.rs:441-465 In the update_channel and force_update_channel extrinsics permit to modify channels by specifying the mode and the outbound_fee. 479-495, and However, the outbound_fee is currently disregarded and not processed either in the pallet or within the Gateway contract  it is solely emitted in the event. Despite being dened in the comment as the Fee charged to users for sending outbound messages to Polkadot, this specic fee per channel is not currently implemented.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. The agent may not be able to reimburse the relayers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "In contracts/src/Gateway.sol:217-222, a mechanism is implemented to incentivize relayers to forward messages and receive a reward from the agent in return. However, since there is no automated mechanism to fund agents, such as an explicit requirement for agent creators to fund the agent contract or an enforced fee ratio favorable for is possible that due to market conditions, bridge usage, or after bootstrapping the contract, there are no funds left to reward relayers. the protocol, it Consequently, there would be no incentive for relayers to forward messages, which could cause delays and disruptions in the bridge operations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Inecient overow protection for the nonce",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "In parachain/pallets/outbound-queue/src/lib.rs:313, the nonce is correctly incremented using saturated addition, safeguarding against overow. However, when the nonce reaches its maximum value, messages with that one can still be sent across the bridge. Only the initial message with the maximum nonce will succeed; subsequent ones will be rejected. The contract contracts/src/Gateway.sol:142-500 increments a channel's nonce without protection against overow. This results in sending a message which will be rejected on the Polkadot side. While there is no security implication, redundant message transmissions lead to ineciencies that could be avoided.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Events do not contain information about the channel in use",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "In parachain/pallets/system/src/lib.rs, control commands are dispatched over channels to Ethereum using the send function, with corresponding events emitted through deposit_event. For example, channel, and the corresponding event is emitted in line 647. in line 645, the TransferNativeFromAgent command is sent over a However, events do not provide information about the specic channel used for each command even if some commands, for instance, the TransferNativeFromAgent, could be sent via either a parachain channel or a governance one leading to possible issues in o-chain indexers that listen to those events.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Comments do not reect the implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Snowbridge/2024-02-12 Audit Report - Snowbridge Extension v1.1.pdf",
        "body": "It has been noticed that in some places comments do not match the implementation. This may lead to problems with understanding the logic by developers and negatively impact maintainability. Noticed irregularities:  In the system pallet, in parachain/pallets/outbound-queue/src/lib.rs:54 the exchange rate between DOT and ETH can be changed via In  The comment states that set_fee_parameters extrinsic. However, such a function does not exist. practice, the set_pricing_parameters extrinsic is responsible for this. requirements and information about fees are specied in the comments for most extrinsics while no fees are charged for governance and transfer_native_from_agent administrative functions, the so-called Partial fee is charged. However, the comments describing them indicate that no fee is included, which diers from the implementation. update_channel functional ones. For the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Unauthorized swap adjustments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "update_swap_adjustment_handler in The allows contracts/dca/src/handlers/update_swap_adjustment_handler.rs updating the swap adjustments for a specic strategy, eectively increasing or decreasing the number of tokens swapped. However, this function, which is supposed to be callable only by the contract admin, lacks authorization checks. An attacker can save arbitrary swap adjustments for any strategy, potentially grieng the protocol  for example, by setting it to a value of 0. function We would like to point out the described vulnerability was also detected by the Calculated Finance team during the audit. A x was prepared, which was then reviewed by the Oak Security team. that",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Destination address set to the DCA contract address allows disbursement of escrowed funds at any time",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "the DCA contracts In in contracts/dca/src/helpers/disbursement.rs, swapped and escrowed funds are disbursed to the provided destination addresses of a vault. Destination addresses can be used as arbitrary callbacks by specifying a custom message. get_disbursement_messages function However, the destination address is not checked to ensure it is not the DCA contract itself. This allows for the execution of messages in the context of the DCA contract as the caller of the message. For example, providing the DisburseEscrow message would lead to the disbursement of escrowed funds whenever funds are distributed, contradicting the intended behavior of disbursing escrowed funds only in specic situations, e.g., upon vault cancellation.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. PerformanceAssessmentStrategy::CompareToStandardD ca is incorrectly used for a vaults performance_assessment_strategy when choosing SwapAdjustmentStrategyParams::WeightedScale",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "a the with new vault create_vault_handler in Creating contracts/dca/src/handlers/create_vault.rs allows specifying a performance assessment and swap adjustment strategy. The swap adjustment strategy can be either set to or SwapAdjustmentStrategyParams::RiskWeightedAverage SwapAdjustmentStrategyParams::WeightedScale. The performance assessment strategy determines if a vault should continue to swap tokens based on the performance of the for SwapAdjustmentStrategyParams::RiskWeightedAverage. supposed function used vault only and be to is the However, to performance_assessment_strategy PerformanceAssessmentStrategy::CompareToStandardDca in line 120 for both swap adjustment strategies, regardless of the chosen strategy. set is As a result, the vault's escrow_level, supposed to be set to 0, is set to the escrow level in line 127. Additionally, cong value (risk_weighted_average_escrow_level) Instead of imposing swap and automation fees in the incorrect swap fees are charged. in disburse_funds_handler contracts/dca/src/handlers/disburse_funds.rs:43 and 48, performance fees are applied. As the performance fees are calculated based on the protability delta between the standard DCA and the DCA+ strategy and the vault not using the DCA+ strategy, performance fees will be inaccurately calculated. function",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Spot price usage may be exploited through oracle manipulation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "During trigger execution, the belief price is determined using the query_belief_price function in contracts/dca/src/helpers/price.rs:8-48. In line 38, the pools are queried for their spot price, which could be manipulated on low liquidity pools. This issue is exacerbated due to the lax limits on slippage described below in the issue Default slippage_tollerance is set to the maximum value and because ExecuteTrigger is permissionless. An attacker could monitor existing vaults to compile a list of targets and exploit them by executing triggers at the correct time after manipulating the oracles spot price.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. due_date of the disburse escrow task is not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "Canceling a vault through the cancel_vault_handler function stores a task in storage to disburse escrowed funds. The due_date is designed to limit the execution of the task to a specic time in contracts/dca/src/handlers/cancel_vault.rs:35. calculated based on the current block frame and is time However, when disbursing escrowed funds via the disburse_escrow_handler function in contracts/dca/src/handlers/disburse_escrow.rs, the previously stored task is not loaded, and its due_date is not checked. This means that escrowed funds can be disbursed at any time by the contract admin, even when the due_date has been surpassed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Default slippage_tollerance is set to the maximum value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "Slippage tolerance determines the maximum allowable deviation between the anticipated number of tokens a user expects to receive, such as in a token swap, and the actual number tokens received. A higher value implies a smaller amount of tokens being received, of increasing the loss of value for the user. Within the audited contracts, slippage tolerance is used in two functionalities:  Calling the trigger through the ExecuteTrigger message, which swaps tokens in accordingly the contracts/dca/src/handlers/execute_trigger.rs:207. selected strategy to  Providing the contracts/dca/src/handlers/z_provide_liquidity.rs:37. ZProvideLiquidity liquidity using message in In both instances, the user can optionally dene a custom slippage value. If none is provided, the default value will be used. the default value for slippage_tolerance (for ExecuteTrigger) and However, slippage_tollerance (for ZProvideLiquidity, please note the spelling mistake in the variable name) is Uint128::one(). Consequently, users may experience signicant losses when using these functionalities without dening a custom slippage tolerance value. In the case of pairs with low liquidity, such token swaps may be detected by MEV bots, which could sandwich the messages and thereby extract maximum value from the user. In addition, note that in both of the above-mentioned cases, the functions do not validate the optional user-provided slippage parameters. Consequently, if their value is greater than 1, there will be an underow in contracts/dca/src/helpers/swap.rs:23 and contracts/dca/src/handlers/z_provide_liquidity.rs:49, which will result in a panic.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Vault deposits can trigger recursive trigger executions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "a in via can vault deposit in Anyone deposit_handler contracts/dca/src/handlers/deposit.rs. the vault was inactive prior to the deposit, a new trigger is saved in line 96 with the target time set to the current block time, prompting an immediate execution. If the vault has destination addresses congured to deposit distributed funds directly into other vaults, this can possibly lead to recursive trigger executions. the If function the described vulnerability was also detected by the We would like to point out Calculated Finance team during the audit. A x was prepared, which was then reviewed by the Oak Security team. that",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of conguration parameter validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "Most of the conguration parameters are properly validated before saving them to storage. However, the following parameters are missing validation steps both upon instantiation in contracts/dca/src/handlers/instantiate.rs:23-33 and upon update in contracts/dca/src/handlers/update_config.rs:24-34 :  A maximum size is not enforced for the fee_collectors vector. This could lead to out-of-gas errors during iteration if a big enough list of collectors is supplied.  Empty allocations in the fee_collectors vector are not rejected.  A page_limit of zero is not rejected, even though it would render some of the contracts queries ineective, as no elements would be returned. In addition, the assert_page_limit_is_valid function implements a default value of 30, therefore if the limit is below that number, any query that makes use of the default value will return an error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Inconsistent pair identication in storage",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "When saving new pairs in contracts/dca/src/state/pairs.rs:7-9, the storage key is determined as format!(\"{}-{}\", denoms[0], denoms[1]). Therefore, both pairs A-B and B-A are saved as dierent pairs with potentially dierent routes. The find_pair function in lines 15-23 checks the existence of both options, however, it will always return the rst that matches the submitted ordering. Returning dierent unexpected inconsistencies in gas costs and swap fees. routes depending on the order of the assets in a pair will cause",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. minimum_received_amount not applied to swaps might give a false sense of security",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "through the execute_trigger_handler function in When executing a trigger contracts/dca/src/handlers/execute_trigger.rs, vault.minimum_received_amount is checked against belief_price. However, it is not instead, vault.slippage_tolerance is supplied. swap message 207-215, provided actual lines the to in Since no verication exists to guarantee that vault.slippage_tolerance aligns with the same the minimum_received_amount creates a false sense of security for users, as it is not eectively used in the nal swapping process. minimum_received_amount, usage level risk as of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Lack of validation upon swap adjustment",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "The update_swap_adjustment_handle function allows for arbitrary values to be submitted as the swap adjustment, aecting the number of tokens to be swapped by this factor. If a large value is assigned, the swap will fail, as the resulting amount designated for swapping will exceed the available funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Lack of validation in liquidity provision cache",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "z_provide_liquidity_handler in The function not contracts/dca/src/handlers/z_provide_liquidity.rs:28-35 validate the saving provider_address PROVIDE_LIQUIDITY_CACHE storage. Providing an incorrect address will cause the subsequent reply handlers to fail, wasting computational resources, or rendering the locking useless if a duration of zero is provided. does to it user-submitted before the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Lack of validation of custom swap fee denom",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "create_custom_swap_fee_handler The function in not contracts/dca/src/handlers/create_custom_swap_fee.rs:9-23 validate that the supplied denom actually exists. In case of a typo, the admin might not be aware of the error, and since the expected denom will not be found, no fee will be applied to the desired operations. does",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Misleading lack of feedback upon fee removal",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "remove_custom_swap_fee_handler in function The not contracts/dca/src/handlers/remove_custom_swap_fee.rs:7-19 validate that the supplied denom is part of the current custom fees. Since no feedback is returned when removing a non-existing element from the storage, the admin would not be aware of the error, for example, in case of a typo. Therefore undesired fees will still be charged afterward. does",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. New vaults may be inactivated right after creation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "create_vault_handler in The contracts/dca/src/handlers/create_vault.rs does not assert the initial token deposit info.funds[0].amount is sucient to guarantee a successful swap of the desired number of tokens, i.e. swap_amount. As a consequence, such a vault would be inactive and unable to perform token swaps due to insucient funds. function that",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Lack of role-based access controls for the pausing mechanism",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "The codebase implements a pausing mechanism, which is in line with best practices. However, all of the administrative functions of the contract are centralized in the admin role, which goes against the principle of least privilege. Segregating the pauser role has the additional benet of swifter reactions in case of need when assigned to an EOA compared to the admin that might be managed by a multisig or a governance contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Swap pair route can have duplicate entries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "create_pair_handler The in contracts/dca/src/handlers/create_pair.rs allows the contract admin to create and update swap pairs. The pair.route eld is used to specify the route (i.e., pool ids) that should be used for swapping tokens. While there are various checks in place to ensure that the route is not empty and the route matches the base_denom and quote_denom, there is no check to ensure that the route does not contain duplicate entries. function A swap pair with duplicate route entries will increase the total swap fees and gas costs when swapping tokens.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Vault label length is not validated to be less than 100 characters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "Users can specify a label when creating a new vault via the create_vault_handler function in contracts/dca/src/handlers/create_vault.rs. The label is stored in the vault.label eld and is solely used for o-chain display purposes. While updating a vaults in contracts/dca/src/handlers/update_vault.rs is restricted to 100 characters, there is no such restriction when creating a new vault. update_vault_label_handler function label the via In addition, empty labels are allowed which do not serve the intended asset identication purpose.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Inability to update important vault conguration parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "A vault owner can currently update the vault label via the update_vault function in other contracts/dca/src/handlers/update_vault.rs. However, important vault conguration parameters that cannot be updated once the vault is created. This includes the swap slippage tolerance (slippage_tolerance), the minimum receive amount (minimum_receive_amount), and the destination addresses (destinations) for fund disbursement. there are The inability to update these parameters can be problematic in certain situations. For instance, if the vault owner wants to increase the slippage tolerance to ensure that the vault is able to swap tokens even when the market is volatile or liquidity is low, or if the initially provided slippage value was too conservative. In such cases, they would have to cancel the vault and create a new one.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Peer nodes could receive blocks that are not applied by the sequencer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "The produceBlock function, dened in block/produce.go:75-161, is responsible for producing and distributing new blocks to peers. However, since in block/produce.go:148, the gossipBlock function is optimistically invoked before the block is actually applied via the applyBlock function, there is a risk of gossiping blocks to peers even if applying the block errors or if the process stops for any reason after the execution of gossipBlock but before the execution of applyBlock. Such an error will lead to peers storing and applying a block that the proposer will not apply, leading to an inconsistent block and transaction execution.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. HTTP server misconguration allows Slowloris DoS attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "The serve function in rpc/server.go:177-184 instantiates an HTTP server and enables listening for incoming requests on the listener address. However, since there is no ReadHeaderTimeout to handle idle connections, the server is vulnerable to Slowloris Denial-of-Service (DoS) attacks. This attack method operates by transmitting large amounts of data slowly, which succeeds in keeping the connection alive in the event of a timeout, ultimately resulting in a DoS of the node.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. CONTINUATION frames ood vulnerability in x/net allows attackers to DoS the node",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "The golang.org/x/net package used in Dymint is vulnerable to CONTINUATION frames ood, as reported in https://pkg.go.dev/vuln/GO-2024-2687. An attacker may cause an HTTP/2 endpoint to read arbitrary amounts of header data by sending an excessive number of CONTINUATION frames. Maintaining HPACK state requires parsing and processing all HEADERS and CONTINUATION frames on a connection. When a request's headers exceed MaxHeaderBytes, no memory is allocated to store the excess headers, but they are still parsed. This permits an attacker to cause an HTTP/2 endpoint to read arbitrary amounts of header data, all associated with a request which is going to be rejected. These headers can include Human-encoded data which is signicantly more expensive for the receiver to decode than for an attacker to send. Consequently, attackers can leverage this vulnerability to perform a DoS attack against the RPC server.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Incorrect mempool initialization height leads to discarded transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In node/node.go:177, during the execution of the NewNode function, the NewTxMempool function is called to instantiate a new mempool. However, since the mempool height is set to zero, incoming transactions would get incorrectly assigned a height of zero. As a consequence, the mempool would incorrectly and prematurely purge valid transactions in the purgeExpiredTxs function dened in mempool/v1/mempool.go:762.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Submitting blocks to the data availability and settlement layer can result in a deadlock",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In block/submit.go:13-57, the SubmitLoop function, running in a goroutine, submits blocks (SL). A mutex, batchInProcess, is used to ensure that only a single batch is processed at a time. to the data availability (DA) and settlement layer layer However, preventing the next batch from being processed and resulting in a deadlock. if the submitNextBatch function in line 46 errors, the mutex is not released,",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Invalid blocks can be received via p2p gossip, potentially preventing block syncing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In block/manager.go:256-278, the applyBlockCallback callback function is called whenever a new block is received via libp2p gossip. If the received block height is equal to the next expected height, the block is applied via the applyBlock function in line 269. Otherwise, if the block height is for a future height, the block and the corresponding commit are stored in prevBlock and prevCommit, respectively. However, at this point, the block is not yet validated by verifying the signature to ensure the sequencer has produced it. This stateful check is only performed later in the executeBlock function in block/block.go:180-182 via the Validate function. As a result, issues such as: invalid blocks can be received and processed by nodes, leading to potential 1. 2. If the block height is equal to the next expected height, it is attempted to be applied. Before any stateful validations, the block is saved via the SaveBlock function in block/block.go:38. While the block is ultimately dismissed and not applied due to not passing the signature verication check, it remains stored, wasting disk space of the node. An attacker could exploit this behavior by spamming invalid blocks to nodes. If the received block is for a future height, the block and commit are stored in prevBlock and prevCommit, potentially overwriting a valid block and commit. As a result, nodes can be prevented from syncing via this mechanism. Please note that nodes also synchronize via the settlement layer (Dymension Hub), which mitigates this issue to some extent. Additionally, it should be noted that the sequencer does not receive blocks via libp2p gossip, only regular nodes do.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Non-atomic batch submission to data availability and settlement layers causes repayment for the same data and potential indenite failure",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In block/submit.go:89-103, in the submitNextBatch function, a batch is submitted to the data availability (DA) layer by calling SubmitBatch, followed by an attempt to submit the same batch to the settlement layer (SL) using m.settlementclient.submitbatch. the SL submission fails due to reasons such as insucient gas or censorship at the If settlement layer, the transaction remains in the mempool awaiting inclusion. The system then the same batch to both layers after the waiting period ends. Since retries to submit leading to syncTarget remains unchanged, the DA layer accepts the redundant batch, unnecessary payments for already existing data. If the original transaction eventually gets included in the SL before the new transaction, the SL rejects the resubmitted transaction due to a height check requirement. Consequently, this cycle of failing settlement attempts and redundant payments perpetuates indenitely and incurs unnecessary costs for the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Applying blocks concurrently can lead to unexpected errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "The applyBlock function executes the current block by calling the executeBlock function in block/block.go:44. As part of the execution, the application's BeginBlock, EndBlock, and DeliverTx are called for every included transaction. However, applying the block to the store and the ABCI application is not atomic, shared state is not locked between processes, such as the goroutine that processes libp2p gossiped blocks and the sync goroutine that syncs the node with blocks from the settlement layer. In the rare case that a block for the same height is simultaneously processed by both goroutines, both processes will attempt to execute the block, leading to unexpected errors such as a panic in the ABCI application when checking the header's validity.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Stopped block production is immediately resumed after receiving a health status event from the data availability or settlement layer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In block/produce.go:17-73, the ProduceBlockLoop function produces new blocks unless the shouldProduceBlocksCh channel receives a false value. In this case, block production is stopped, and the channel waits for a true value again. There are three causes that may stop the block production: the data availability (DA) layer is unhealthy, the settlement layer (SL) is unhealthy, or 1. 2. 3. block production encounters an error. SL's current The DA and the in healthStatusEventCallback block/manager.go:250-254. This function sends the received health boolean value into the shouldProduceBlocksCh channel. is listener continuously reported function, dened health health status to However, if block production was previously stopped due to erroneous block production, the health listener will enable block production again as soon as the DA or SL health status is reported as true, even if the error that caused the block production to stop has not been resolved.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Pending blocks are repeatedly gossiped",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In block/produce.go:148, the produceBlock function gossips a newly produced block to its peers. However, if the sequencer picks up a pending block that has already been gossiped, it will be gossiped again, which is unnecessary. We classify this issue as minor, as repeatedly gossiped blocks do not harm the network besides causing networking ineciencies.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Validating gossiped transactions may block the libp2p validator queue",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In p2p/validator.go:43-69, the TxValidator libp2p validator function calls the mempool's CheckTx function to validate the gossiped transaction prior to adding it to the mempool. However, if the CheckTx function returns an error that does not match any of the switch cases, i.e., the default case, the function will attempt to read from the checkTxResCh channel to receive the ABCI response. As CheckTx may have errored before initiating an ABCI CheckTx request, the channel will not receive any response, causing the goroutine to block and clog the libp2p validator queue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Mempool is initialized at genesis without the preCheck and postCheck functions, leading to not validating the transactions size and wanted gas until the rst block is committed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In state/executor.go:301, the commit function calls the mempool's Update function to update the preCheck and postCheck functions with the new maxBytes and maxGas consensus parameters received from the underlying application. Those functions are used to additionally validate that the transactions size (in bytes) is less than the maximum and that the transactions wanted gas does not exceed the block gas limit. This validation occurs before and after a transaction is added to the mempool. However, at genesis, the mempool is not initialized with those preCheck and postCheck functions, even though both consensus parameters, maxBytes, and maxGas, are made available after executing InitChain in block/initchain.go:45. As a result, transactions will not be validated until the rst block is committed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Maximum number of peer IDs can potentially be reached, preventing gossiped transactions from being added to the mempool",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "the nextPeerID function returns the next In node/mempool/mempool.go:35-48, unused peer ID to use and panic if the number of active IDs exceeds the maximum threshold, maxActiveIDs = math.MaxUint16. However, over time, as more and more peer IDs are utilized, and unused IDs are not reclaimed via the Reclaim function, the maximum threshold can potentially be reached at some point. As a result, the libp2p transaction validator function, TxValidator, will be unable to claim an ID for a new peer and panics, preventing incoming transactions from being added to the mempool. We classify this issue as minor as it requires a total number of 65,535 unique peers to have been connected to the node at some point.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Incomplete validation of conguration parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In config/config.go:137-144, GetViperConfig function execution to validate the NodeConfig. the Validate function is executed by the However, SettlementLayer are currently checked. the validation process is incomplete, as only BlockManagerConfig and Consequently, the node may use an invalid conguration, possibly leading to unintended behaviors and node halt.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Node can be started without providing the genesis",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In cmd/dymint/commands/start.go:128-135, the checkGenesisHash function is executed during the node initialization to verify that the provided genesisHash and the SHA-256 hash of the genesis le are equal. However, if the Genesis le or the genesisHash is not provided, it does not generate an error, thus permitting the node to start even without providing the genesis.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Suboptimal data retrieval due to static congurations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "The fetchBatch function in block/retriever.go:106 retrieves data batches using a retriever instance (m.retriever) initialized at node startup. However, this approach leads to if sequencer 1 uses suboptimal data retrieval due to static congurations. For instance, Celestia as the DA layer and sequencer 2 uses Avail, parsing data would fail for one another. This static conguration presents a signicant issue, as nodes submitting to Celestia or Avail may face diculties syncing data. Since m.retriever is statically congured based on the daregsitry settings, the syncing node might encounter situations where it's unable to parse both sets of data. When data is submitted to the settlement layer, it includes a DASubmitMetaData.client eld to validate the data availability from the client. Retrievers are congured to use only one DA client. If the settlement has data from mixed clients, the retriever can only parse data for its congured client. If the data is only on another client, this static conguration would prevent processing the data. We classify this issue as minor because, at the time of the audit, only one sequencer node is used. Once further sequencer nodes are introduced, it becomes a serious issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Occurrence of \"Tendermint\" instead of \"Dymint\"",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In rpc/client/client.go:168, the BroadcastTxCommit function uses the error reason \"Tendermint exited\". This error message might be misleading as the client is called \"Dymint\".",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Non-sequencer nodes unnecessarily register health status event listener",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "to the In block/manager.go:243, corresponding EventQueryHealthStatus healthStatusEventCallback callback function. Whenever this event is emitted, the event's Healthy value is sent to the shouldProduceBlocksCh channel, potentially enabling or disabling block production. the EventListener function subscribes event registers and the However, this mechanism is only relevant for the sequencer node, as it is currently the only node that is producing blocks. For other regular nodes, the shouldProduceBlocksCh channel is not relevant, rendering the event listener and callback function unnecessary.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Use of magic numbers decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-07-09 Audit Report - Dymension Point 1D Stream 3_ Dymint v1.1.pdf",
        "body": "In rpc/json/service.go:107-108 and rpc/client/client.go:315, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to understand their use easily and may make inconsistent changes across the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. MsgInstantiateOracle is not registered",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/types/codec.go:18, MsgInstantiateOracle is not registered as a concrete implementation of the sdk.Msg interface. While there are no issues when executing a MsgInstantiate transaction message without the registration, an error will occur if a transaction message contains code that involves marshaling or unmarshalling an unregistered message.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Amino codec must be registered to support end users with hardware devices like Ledger",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/types/codec.go:33, Amino should be used to register all interfaces and concrete types for the icaoracle module. This is necessary for legacy binary and JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Missing GenesisState validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/keeper/genesis.go:11, InitGenesis is missing genesis state validation. Without validation, miscongurations may go unnoticed and might eventually be dicult to correct.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Governance can activate invalid oracles",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/keeper/gov/gov.go:11-13, the ToggleOracle function can be called by governance to enable or disable any oracles. However, no validation ensures that the oracle already has a contract instantiated on the host chain and the channel is still active. Enabling such invalid oracles is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Removing oracles does not remove associated metrics",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/keeper/gov/gov.go:16-24, the RemoveOracle function can be called by governance to remove any oracle as long as it exists in the storage. However, no validation ensures that the metrics associated with the oracles are removed too. If a channel times out and governance removes the oracle, the pending metrics will remain forever in the storage in an IN_PROGRESS state.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Oracles cannot be added again if they have an active channel and are removed through governance",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/keeper/gov/gov.go:16-24, the RemoveOracle function can be called by governance to remove any oracle as long as it exists in storage. However, if governance removed OracleChainId while the channel is still active, the chain identier cannot be added back through the AddOracle function. This is due the error occurring in stride:x/icaoracle/keeper/msg_server.go:85 because the channel would still be active. Since interchain account channels cannot be closed manually by users, the oracle for the specic chain id cannot be added back anymore.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. RestoreOracleICA does not ensure that channel is closed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "RestoreOracleICA The in stride:x/icaoracle/keeper/msg_server.go:150 does not explicitly check to ensure that the channel for the requested oracle is closed. If the channel is closed an error should be returned. this function is called for an open channel RegisterInterchainAccount will fail later in the functions execution, but will not return an error that clearly communicates its cause. In the case that function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Duplicated ValidateBasic invocation in CLI",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "CLI commands transaction All stride:x/icaoracle/client/cli/tx.go:19 stride:x/icaoracle/client/cli/gov.go:55 function before calling GenerateOrBroadcastTxCLI. registered in the GetTxCmd function in and msg.ValidateBasic call the As msg.ValidateBasic is already called inside the GenerateOrBroadcastTxCLI function this is a duplicated invocation, which is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Incorrect usage message for GetCmdQueryOracle command",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "usage message in The stride:x/icaoracle/client/cli/query.go:47 is incorrect. The command expects to receive exactly one argument holding the chain id, but the usage message is not describing this. GetCmdQueryOracle command for",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Unused code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "Across the codebase, locations. Unused code decreases the maintainability of the codebase. instances of unused errors and functions exist in the following  ErrMarshalFailure in stride:x/icaoracle/types/error.rs:18  ErrUnmarshalFailure in stride:x/icaoracle/types/error.rs:19  CWTemplateContract in cw-ica-oracle:src/helpers.rs:10-27",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Events are not always emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "There are multiple functions within the scope of this audit that do not emit events or attributes. It is best practice to emit events and attributes to improve the usability of the contracts and to support o-chain event listeners and blockchain indexers. The following functions do not emit events or attributes:  In cw-ica-oracle:src/contract.rs:15, the instantiate function should emit an event containing the admin_address value.  In cw-ica-oracle:src/execute.rs:19, the post_metric function should emit events containing the new_metric and new_price values.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Misleading comments in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In cw-ica-oracle:src/state.rs:127, the add function for the History storage state mentions that Old items are removed from the back of the deque when capacity is reached. However, this is incorrect because the old items are actually removed from the front of the deque when the capability is reached, as seen in line 137. in cw-ica-oracle:src/execute.rs:46, Additionally, the comment species that duplicated metrics will not be added to the store while in the current implementation duplicate new metrics silently overwrite existing metrics.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. Inconsistent admin duplicate validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-07-13 Audit Report - Astroport Concentrated Liquidity Pool with Injective Orderbook Integration v1.0.pdf",
        "body": "The free-granter contract performs validation of the submitted admin addresses in contracts/periphery/fee_granter/src/state.rs:15-23. However, no checks on address duplication are performed in this function. While the update function performs its own separated checks, this is not the case with the instantiation function. As there is a maximum of two admins, duplicate addresses would limit operations. tWe classify this issue as minor since admin addresses can be updated to remove duplicated addresses.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. try_list poses centralization risk",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "in function try_list sellable/src/execute.rs:212 the The ownable.owner to list any token. While this is a privileged account, it allows anyone controlling this account to list tokens that belong to other accounts. If the ownable.owner account is compromised, it can create a situation where a users tokens may be listed without the owners consent at lower than market value prices, eectively allowing them to be stolen. This also introduces a discrepancy where the ownable.owner can list tokens, but the listed_token.owner is the only address that can delist tokens. allows",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. MaxCoins function could potentially return an unexpected set of fees",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "The globalfee module implements a combination of global and local minimum gas prices, similar to Gaias implementation. The list of localFees is expected to initiate and enforce a higher transaction fee requirement, if the amounts are all greater than the globalFees amounts, as a spam prevention measure. The function GetTxFeeRequired in xion:x/globalfee/ante/fee.go:70 retrieves the global and local fees and returns the combined fee requirement using the MaxCoins function in line 88. However, the function implementation can return unexpected results in the following scenarios:  If the local fees include denoms not present in the global fees, the transaction fee fees, potentially including unwanted fee to the local requirement will be set denominations.  If the local fees include denoms not present in the global fees, the transaction fee requirement will be set to the local fees, potentially including lower fee amounts for denominations present in the global fees.  If the local fees include at least one fee amount that is equal to or greater than the equivalent global fee, the transaction fee requirement will be set to the local fees, potentially including lower fee amounts for other denominations present in the global fees.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. buy_item does not properly validate sent funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "The buy_item function in cw-std:sales/src/execute.rs:136 contains a logic error that does not properly validate that the funds provided in the message are greater than or equal to the price of the item being bought. While this issue has the potential to have a severe impact on the balance of the contract, it is not directly exploitable under normal conditions due to the fact that the contract is not intended to hold a balance. Since the contract does not hold a balance, the bank message that performs the funds transfer to the item owner will error due to insucient funds. If the contract was extended in the future though to hold funds, or if funds are accidentally sent to the contract, an attacker could use the buy_item function to steal these funds by listing their own item for a large sum and supplying a very small amount of funds so that they will receive the excess balance.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Incorrect gas limit used in PostHandle function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "the in In abstract-account:x/abstractaccount/ante.go:180, the sudoWithGasLimit function is called with params.MaxGasBefore as the maximum gas parameter. Instead, the in the after_tx maximum amount of gas that can be consumed by the contract call decorator should be set to MaxGasAfter. PostHandle function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing Genesis validation in the InitGenesis function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "In abstract-account:x/abstractaccount/module.go:98-103, the genesis state is created from the supplied input data during genesis initialization. However, the Validate function is not called for the created type. Consequently, the message is not validated, potentially leading to an invalid genesis state.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Unused code relating to the Redeemable functionality",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "While the Redeemable functionality has been removed, messages relating to the in the codebase in instantiation and querying of and redeemable::InstantiateMsg redeemable::QueryMsg in cw-hubs:seat/src/msg.rs:41. cw-hubs:seat/src/msg.rs:14 redemption of in tokens still exist",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Missing check for sig_bytes length in verify function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "In account-contract:account/src/eth_crypto.rs:37, there is no validation that the length of sig_bytes equals 65 bytes. If the verify function is called with sig_bytes having a length of less than 65 bytes, it will cause the function to panic. Panics go against best practices since they do not provide error messages to the caller which can help to understand and resolve the cause of the error.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Improve credentials processing in before_tx",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "In account-contract:account/src/execute.rs:38-54, the credential processing is implemented as follows: Check the length of the credential bytes, if the length is less than 1, return an error. The implementation then checks the cred_byte (the rst byte) and derives the signature algorithm. All other bytes form sig_bytes and are interpreted as signature bytes. As a result, the current implementation accepts cred_bytes of arbitrary length. It is a widespread implementation practice to read the exact number of signature bytes because the length of the signature is known prior.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Duplicate validations are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "Across the codebase, instances of duplicate validation have been found, which decrease the eciency of the code.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Usage of the deprecated function EmitEvents",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "deprecated in The used abstract-account:x/abstractaccount/keeper/msg_server.go:102. Using deprecated functions is generally discouraged as they may be removed in future versions of the library, leading to potential compatibility issues. EmitEvents function is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Missing validation of parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "Validate The in abstract-account:x/abstractaccount/types/params.go:22 validates only the maxGasBefore and maxGasAfter parameters, but no validation is performed for allowAllCodeIDs and allowedCodeIDs parameters. This can allow for a situation where these parameters introduce potential miscongurations. function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Missing params validation in SetParams",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "SetParams The in not abstract-account:x/abstractaccount/keeper/keeper.go:67-78 implement validation of the params input. SetParams is used in the UpdateParams function in abstract-account:x/abstractaccount/keeper/msg_server.go:36 function does and abstract-account:x/abstractaccount/keeper/genesis.go:12. InitGenesis the function in in While the UpdateParams function validates input params before passing it to the SetParams function, the InitGenesis function does not do that. By validating params in the SetParams function it will improve the overall consistency of input validation and help with future maintainability.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Outdated dependencies in abstractaccount module",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "Many packages (e.g., cometbft, cosmos-sdk, net, runtime) are outdated and have known vulnerabilities xed in the newest versions. Examples of known vulnerabilities: 1. GO-2023-1861. Cosmos \"Barberry\" vulnerability in github.com/cosmos/cosmos-sdk. Found in: github.com/cosmos/cosmos-sdk@v0.47.2. Fixed in: github.com/cosmos/cosmos-sdk@v0.47.3. 2. GO-2023-1883. Denial of service via OOM in github.com/cometbft/cometbft. Found in: github.com/cometbft/cometbft@v0.37.1. Fixed in: github.com/cometbft/cometbft@v0.37.2. 3. GO-2023-1878. Insucient sanitization of Host header in net/http. Found in: net/http@go1.19.7. Fixed in: net/http@go1.20.6. 4. GO-2023-1840. Unsafe behavior in setuid/setgid binaries in runtime. Found in: runtime@go1.19.7. Fixed in: runtime@go1.20.5. 5. GO-2023-1705. Excessive resource consumption in net/http, net/textproto, and mime/multipart. Found in: net/textproto@go1.19.7. Fixed in: net/textproto@go1.20.3.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Misspelled error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "abstract-account:x/abstractaccount/types/errors.go:8, In ErrNotSingleSignautre is misspelled. the error",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Unused errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "The codebase contains several errors that are unused. These errors should be removed if they are not intended to be used.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Unused functions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "The codebase contains several removed if they are not intended to be used. functions that are unused. These functions should be",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Execute messages of allowable contract do not emit any attributes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "The allowable contracts execute messages in cw-std:allowable/src/lib.rs:95 do not emit any attributes. It is best practice to emit attributes whenever execute messages are handled to allow o-chain listeners such as indexing service observe state changes.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Outstanding TODO comments in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contract Updates and Account Abstraction v1.1.pdf",
        "body": "Across the codebase, instances of TODO comments have been found. These markers often signal areas where additional work or improvements are needed:  xion:x/globalfee/queirer.go:34  abstract-account:x/abstractaccount/ante.go:77",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Gzipped wasm binaries with invalid CRC could be used to DOS the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "In the create function in x/wasm/keeper/keeper.go:181, the passed wasmCode is uncompressed. Gas is not charged during uncompression, but rather further down in line 185 after the error check in line 183. Consequently, if an error occurs during uncompression, the function returns an error without charging gas for uncompressing the code. An attacker can consume a high amount of computation and I/O operations without paying for that resource usage by sending a big le to uncompress and causing an error at the last moment. This can be achieved by triggering the uncompression of a valid gzipped le but with an invalid CRC, so the function will read the entire buer before failing during the CRC check, which happens after uncompressing the whole le. For the attack, it is important to create a valid gzipped le with a maximum size of 800 kB. An invalid/bigger le would fail due to the byte prex check and the LimitReader in place. Since the gasMeter charges gas proportional to the transaction message size, it is desirable to use a very small gzipped le with an uncompressed size of 800 kB. A test case demonstrating the above scenario can be found in appendix 1. The cost of this attack could further be decreased by sending a MsgStoreCode with the code constructed as described above from within a CosmWasm smart contract. Even though MsgStoreCode is not directly supported by the default Wasm message encoder EncodeWasmMsg, it can be sent using a StargateMsg.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Contract admins can bypass code ID instantiation permission when migrating contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "The migrate functionality in x/wasm/keeper/keeper.go:380 does not check whether the caller is authorized to perform a contract migration towards the specied code ID. As a result, contract admins can bypass any code ID instantiate permission by specifying the restricted code ID when migrating their contract. A test case demonstrating the above scenario can be found in appendix 2.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. IBC Querier plugins unbounded loop could lead to DoS",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "The IBC Query plugin is dened in x/wasm/keeper/query_plugins.go:200, allowing queries of smart contracts IBC metadata. In line 209, while executing the ListChannels query, specic logic is executed to search open channels associated with a given PortID. This is achieved by iterating through existing channels using the IterateChannels function from channelKeeper. Notably, if PortID remains unspecied, all open channels are retrieved. Consequently, attacker could exploit this unbounded iteration, leading to a chain-wide DoS. in scenarios where a substantial number of channels are registered, an",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Governance permissioned chains are not supporting CosmWasm contracts that dynamically instantiate other contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "The authz implementation in x/wasm/keeper/authz_policy.go does not propagate i. e. a message sent from a CosmWasm smart contract will be governance permissions, executed in the runtime with an authz object of type DefaultAuthorizationPolicy and not GovAuthorizationPolicy. This implies, for example, that contracts cannot instantiate other contracts, which is a common pattern used by teams building CosmWasm smart contracts. Scenario:  Governance permissioned chain that allows only governance to load code and instantiate a contract: code_upload_access = ACCESS_TYPE_NOBODY instantiate_default_permission = ACCESS_TYPE_NOBODY  Code is uploaded and a contract is instantiated through governance.  The contract itself cannot dynamically instantiate other contract instances.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. When updating a contracts AccessConfig subset conditions are not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "In the setAccessConfig function in x/wasm/keeper/keeper.go:882, when updating the AccessConfig for a specic contract code, no check is performed on whether the new cong is a subset of the global access cong as is done in other parts of the codebase. This could lead to inconsistency of the local AccessConfig with the global one,",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Attribute keys starting with underscores lead to errors, causing smart contract runtime errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "The contractSDKEventAttributes function in x/wasm/keeper/events.go:62, returns an error if an attribute key starts with an underscore _. This will lead to runtime errors for smart contracts that have code paths that were not extensively tested. An example could be a DeFi protocol that adds an attribute with an underscore under certain conditions, for example, an emergency withdrawal. The runtime error would prevent the emergency withdrawal, putting user funds at risk.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Updating access congurations can render existing contracts non-compliant",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "During instantiation, the access cong specic to the contract is veried, but the global one is not considered. In fact, the contracts access cong is only validated as a subset of the global one during the code creation process in x/wasm/keeper/keeper.go:176. Consequently, existing contracts may no longer comply with the updated congurations. if either the upload access cong or instantiate access cong are modied, For instance, changing the instantiation access cong from AccessTypeEverybody to AccessTypeOnlyAddress will not impact previously created codes, which anyone can still instantiate.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Possible key collision in appendToContractHistory function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "x/wasm/keeper/keeper.go:565, the In appendToContractHistory function may cause a key collision when contract addresses end with zeroes. If contract addresses are not guaranteed to have the same length, the prex of a zero-ending address may collide with a contact that has a non-zero-ending address. iteration reverse the in Additionally, since the store code for ContractHistory does not prevent an address collusion in a mixed 20/32 byte address chain, it might cause the transaction to fail when the position counter is not initialized correctly or overows for a 20-byte address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. autoIncrementID is a misleading variable name that may impact future maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "The autoIncrementID function in x/wasm/keeper/keeper.go:956 contains a misleading variable name called lastIDKey that may impact future maintainability. The variable name does not accurately reect its usage  rather than storing the last identier key, and it is actually used as the next identier key.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Input label validation can be bypassed using white space, label supports non-printable characters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "In x/wasm/types/validation.go:26-28, the validateLabel function veries the label is not an empty string without trimming white space from user input. As a result, one can simply provide white space as the contract label, which the validation function does not reject. Additionally, control characters and non-printable characters can be used in the label. This defeats the purpose of the validation and may confuse users.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Proposal validations can be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "x/wasm/types/proposal.go:485-487, In for PinCodesProposal only checks that the provided CodeIDs slice is not empty. Ideally, it should also check that it does not contain duplicated code IDs and that the provided code IDs are not 0. There is also currently no upper bound on the number of CodeIDs in the validation. ValidateBasic function the This issue is also present in the ValidateBasic functions for UnpinCodesProposal and UpdateInstantiateConfigProposal.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. handleMigrateProposal contains unreachable error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "In x/wasm/keeper/proposal_handler.go:107-112, there are two if statements that return an error if the err value is not nil. The second if statement in line 110 cannot be executed because the rst one would always return before it.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Typographic and grammar errors found in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "During the audit, several typographical and grammar errors were found that negatively impact readability:  proto/cosmwasm/wasm/v1/tx.proto:30: \"Sender is the actor that signed the messages\".  x/wasm/keeper/api.go:10, 12: \"much\"  x/wasm/keeper/gas_register.go:59: \"create\"  x/wasm/keeper/keeper.go:266: \"contract\"  x/wasm/types/wasmer_engine.go:214: \"probably\"  x/wasm/types/wasmer_engine.go:143, 157: \"phase\"",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Lack of event emission when storing code, updating, or clearing an admin through a proposal",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "In the following cases, events are emitted when actions are performed through messages, but not when they are performed through proposals. This inconsistency might be confusing for users and may lead to issues for o-chain services such as block explorers.  When storing in x/wasm/keeper/proposal_handler.go:58, no event is emitted. This diers from the handler for StoreCode messages, which emits an event. proposal through code a  When updating in x/wasm/keeper/proposal_handler.go:172, no event is emitted. This diers from the handler for UpdateAdmin messages, which emits an event. proposal through admin an a  When clearing in x/wasm/keeper/proposal_handler.go:188, no event is emitted. This diers from the handler for ClearAdmin messages, which emits an event. proposal through admin an a",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Sudo contract interactions do not consume gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-10-17 Audit Report - wasmd v1.0.pdf",
        "body": "The sudo contract interactions do not consume gas throughout the codebase. Although gas is charged through the tx.GasMeter().ConsumeGas(sudoSetupCosts, \"Loading CosmWasm module: sudo\") call in x/wasm/keeper/keeper.go:461, sudo proposals eventually go into the BeginBlocker or Endblocker, where gas is not actually accounted for. We classify this issue as informational since sudo calls are trusted.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Saving an invalid LastResultsHash and AppHash when performing a hard rollback",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "Hard rollback deletes the block and the app states to recover an incorrect application state In internal/state/rollback.go:117, when removeBlock is true, the transition. in the block latest internal/state/rollback.go:110-111, latestBlock is used to store both LastResultsHash and AppHash in rolledBackState where it should use rollbackBlock when performing a hard rollback. However, removed store. block from is",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Missing error handling for setProposal might cause unwanted state to be ushed to disk and invalid proposals to be included in a block",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "In internal/consensus/state.go:1037.go, there is a call to method setProposal which returns an error. However, this error is not immediately handled, which might cause the proposal to be ushed to disk and created even when an error occurred. One of the reasons why setProposal may return a non-nil error upon an invalid proposal signature as depicted in internal/consensus/state.go:2333. In that case, a proposal that has been signed by a wrong signature gets added to a block, even though it should have been discarded.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Remove unused les and code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "Across the codebase, various instances of unused les and code have been found.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Use of deprecated function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "The abci/client/grpc_client.go:60. deprecated function grpc.WithInsecure is used in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Redundant use of span closing statements is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "In the finalizeCommit method in internal/consensus/state.go:2148, the storeBlockSpan is closed. However, this operation is redundant as in line 2141 there is a deferred statement already closing the same span. Redundant code can make the code more complex or inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Missing validation might lead to dangling pointer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "In the OnStart method in internal/mempool/reactor.go:98, the channel eld from the Reactor type is not checked against the nil value. This can cause a dangling pointer, and the main thread to crash. This is not a security concern in the current implementation, since upon node creation in node/node.go:274 the mempool reactor is initialized and the channel is created by passing a callback SetChannel to method AddChDescToBeAdded. Nevertheless, the fact that the mempool constructor initializes the channel as nil, and there is no further validation could potentially cause an issue in the future.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Delays in the execution of UpdateExecutor transactions could temporarily inhibit the capability of the protocol to execute requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "the The guard in contracts/registry-stake/src/contract.rs:338 checks if current epochs executor is set or not, ensuring that update_executor is called before execute_request for the new epoch. Since transaction order from the mempool is not deterministic, the capability of the protocol to execute requests will be temporarily inhibited until an UpdateExecutor transaction is executed.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. stakes vector could exceed the CosmWasm VM memory limit when loaded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "In contracts/registry-stake/src/state.rs:68, the stakes attribute is dened in the State struct as a vector of strings. This implies that every time the read_state function is invoked, all the State data, including the stakes vector, is loaded into memory. Since the stakes vector has no maximum length, the CosmWasm VM memory could not have enough space available to load it resulting in an execution panic. A bad actor could intentionally use this issue to cause any interaction with the protocol to be very gas intensive, up to the point where any interaction will run out of gas. With current parameters on Osmosis, the cost of this attack would be in the millions of US dollars. While this might still be economically viable, we classify this issue as major, since it can be resolved with a contract upgrade.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Unstake transactions are likely to fail if more than one of them is processed in the same block",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "Unstake in The contracts/registry-stake/src/contract.rs:635-698, takes as input parameter a vector of numeric indexes that represent the users stake slots in the stakes vector. transaction handler, dened In order to process the deletion of the vector data at the provided indexes within an O(1) asymptotic cost, the swap_remove function is used. This method performs a delete substituting data in the selected index slot with the data stored in the latest element of the vector. Consequently, a removal of one element aects also the ordering of the elements stored in the latest positions of the vector. If we have more than one Unstake transaction in the same block, the indexes for any subsequent positions might be wrong, leading to an error, or, if the same sender controls the position, to the deletion of the wrong position. This implies that the likelihood of an Unstake transaction to succeed depends on dierent unpredictable factors like:  The order of transactions in a block  The cardinality of Unstake transactions in a block  The distance of the index to the end of the stakes vector The likelihood of having a transaction error increases drastically on particular events, for example a market crash where users may want to exit funds from the protocol quickly. Additionally, bad actors can grieve users by staking many small amounts, and then front-running others to cause unstake failures. This could be used together with a short of the tokens to attack the whole protocol and prot from a panic in users.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Protocol is prone to censorship",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "The guard dened in contracts/registry-stake/src/contract.rs:342-347 ensures that only the currently elected executor can submit the ExecuteRequest message. This implies that the currently elected executor is not participating, the protocol will be stuck for the entire epoch with no executed requests. responsive and actively if Since every AUTO token holder can stake its tokens and participate in the election, there is a possibility that the executor could be an inactive protocol participant. Also, a malicious actor could stake a large amount of tokens in order to intentionally stop the requests execution, causing all or targeted executions to get delayed. This is particularly impactful for users and attractive for attackers if requests contain trading transactions that require to be executed in a timely manner. Usually, in proof of stake (PoS) systems, such actors would bear an economic cost such as infrastructure maintenance, cost of staked capital, and third-party delegation loss. Also, in this case, it is required to deposit the stake in the contract only for one block since there is no unbonding period, reducing the attackers capital cost and making the attack cheaper with respect to other PoS systems. In fact, in contracts/registry-stake/src/contract.rs:635-698, the Unstake message handler allows the currently elected executor to unstake all of its stake slots without losing its role. Consequently the executor can be in charge of its role without having its stake deposited in the protocol. This would allow an attacker to get an AUTO loan, stake and be elected, unstake, repay the loan and act as an inactive executor in order to stop requests execution without having to hold or loan tokens for long. Also, it is worth to note that in contracts/registry-stake/src/contract.rs:645, during the handling of the Unstake transaction, the executor election is done before removing the unstaking users address from the stakes vector. This implies that an unstaking user could be elected as the current epoch executor without having capital at risk stored in protocol. We classify this issue as minor since the client intends to set the epoch length to 100 blocks, which corresponds to 10 minutes on Osmosis and is low enough to reduce the impact of an attack. Still, market manipulation even over a short time window may be exploited.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Partially implemented tax deductions may lead to failures if tax rates are updated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "In packages/autonomy/src/asset.rs:44-46, used to calculate taxes to be paid when transferring native coins, always returns zero. the compute_tax function that is Consequently it is not eective and future changes in the Osmosis (or another) chain could inhibit the execution of requests submitted in the registry.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Contracts are not compliant with CW2 Migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "The following contracts do not adhere to the CW2 Migration specication standard: a) registry-stake b) wrapper-osmosis This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. AssetInfo struct is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "In contracts/registry-stake/src/contract.rs:61, representing the AUTO token provided during the instantiation is stored without validation. the AssetInfo struct Since this struct contains an address, it should be checked to ensure that it is a valid one.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Pools allow attackers to extract free value with minimal cost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "The compute_swap function in contracts/pair/src/contract.rs:733 uses unsigned integers for its calculations without rounding, which opens up a way for an attacker to extract value from a pool with a very small cost. As an example, imagine a pool with 5_000_000_000_000 A tokens, and a pool with 1_000_000_000 B tokens. If a user now sends 1 B token, we expect the user to get 5_000 A tokens back. When a user sends 1 A token, we expect the user to get 0 B tokens back (actually 0.0002, but since we are dealing with integers here, the remainder will be dropped). The current implementation incorrectly returns 1 B token though. Imagine further that the value of 1 B token is 5_000 USD, and the value of 1 A token is 1 USD, an attacker can now get a risk free return of around 4_999 USD (minus transaction fees) per transaction. If the attacker repeats this attack, they will be able to drain the pool. Even worse, whenever the attacker shifts the balance enough, other arbitrageurs will be able to extract value by bringing the pool back to the 5_000 to 1 ratio, allowing the attacker to repeat the attack from where they started. Here is a failing test case demonstrating the example: #[test] fn compute_swap_rounding() { let offer_pool = Uint128::from(5_000_000_000_000_u128); let ask_pool = Uint128::from(1_000_000_000_u128); let offer_amount = Uint128::from(1_u128); let commission_rate = Decimal::from_ratio(0_u128, 1_u128); let return_amount = Uint128::from(0_u128); let spread_amount = Uint128::from(0_u128); let commission_amount = Uint128::from(0_u128); assert_eq!( compute_swap(offer_pool, ask_pool, offer_amount, commission_rate), Ok((return_amount, spread_amount, commission_amount)) ); }",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attacker can cause the generators send orphan proxy rewards function to run out of gas, locking orphan rewards in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "the send_orphan_proxy_rewards in In contracts/tokenomics/generator/src/contract.rs:721, USER_INFO storage map is iterated over with the LP token prex. That iteration is unbounded. An attacker can deposit many the send_orphan_proxy_rewards function to run out of gas. There is currently no way to recover from such an attack, any orphan rewards would be locked forever in the contract. to make the iteration long enough for function the small amounts The query_orphan_proxy_rewards query handler exhibits the same issue in line 880, which could potentially cause calling contracts to run out of gas.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Lack of access control on maker contracts set cong function allows anyone to set themselves as the fund receiver",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "is no access in There contracts/tokenomics/maker/src/contract.rs:225, implying that anyone can change the maker contracts cong. An attacker can for example set themselves as the fund receiver, or change the percentage of funds that goes to governance. set_config restriction function the on",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Lack of access control on generator contracts set tokens per block function allows anyone to set number of tokens per block and extract value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "is no access restriction on the set_tokens_per_block function in There contracts/tokenomics/generator/src/contract.rs:756, implying that anyone can change the tokens_per_block. An attacker can for example set a high number of tokens per block and extract value.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Lack of mass updating pools before changing alloc points leads to incorrect allocation of pending rewards and causes orphan rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "In the add function in contracts/tokenomics/generator/src/contract.rs:154, total_alloc_point gets updated, which implicitly changes the allocation for all other pools. Currently, no mass update is performed before that change. That implies that any pending rewards will be distributed according to the updated allocation, causing some rewards to stay unclaimed in the contracts. imagine there is only one pool A, which has 100 alloc_point out of a For example, total_alloc_point of also 100. Also suppose that a total of 10 tokens have been accrued so far in rewards, but they have not yet been assigned to pool A. According to these numbers, the LP holders of pool A are entitled to a total of 10 reward tokens. Imagine now that pool B gets added with an alloc_point of 300, and immediately afterwards, the rewards for pool A are calculated and allocated. At that point, pool A will only have 100 alloc_point out of 400 total_alloc_point, and LP holders will now only receive 2.5 of the reward tokens. The remaining 7.5 rewards will stay unallocated in the contract. Those tokens may be withdrawn using the SendOrphanProxyReward message. The same issue exists in the set function in 197.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Vested but not yet claimed tokens will be lost when replacing a vesting schedule for an account",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "from When updating a vesting account in the register_vesting_accounts function, previous vesting schedules may be replaced with updated ones. During that logic, any unclaimed amounts in contracts/tokenomics/vesting/src/contract.rs:136. to_receive is then used to reduce the amount that will be transferred from the owner in line 155 (or is refunded to the owner in line 168). Any vested, but not yet claimed amounts are also part of to_receive, and will hence be lost from a users point of view. to_receive schedule vesting added are the to",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Missing spread calculation of stable pair contract is misleading to users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "is not In the pair stable contracts compute_swap and compute_offer_amount functions, the spread in contracts/pair_stable/src/contract.rs:832 and 872. Without the actual spread, the max spread assertion, as well as the returned spread amount, are useless, which is misleading to users. hardcoded computed, rather but yet to A TODO exists in the code that mentions the need for spread calculation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of access control on the generator contracts set allowed reward proxies function allows anyone to set proxies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "There is no access restriction on the set_allowed_reward_proxies function in contracts/tokenomics/generator/src/contract.rs:655, implying that anyone can set proxies that can be used when adding an LP token to the pool. We consider this only a minor issue since only an owner can add LP tokens to a pool. Still, an attacker can grief the owner by removing reward proxies from the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Duplicate storage in two contracts could lead to inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "i. e. asset_infos, contract_addr, liquidity_token, and pair_type, Both factory and pair contracts store the PairInfo struct which contains information about in pairs, in contracts/factory/src/state.rs:19 and contracts/pair/src/state.rs:16 contracts/pair_stable/src/state.rs:17. This duplicate storage might lead to inconsistencies between the two contract states. and",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Borrowers can prevent liquidation leading to bad debt accumulating",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "liquidating When in contracts/credit-manager/src/vault/liquidate_vault.rs:154-166, all the borrowers unlocking positions are processed in a loop. A borrower can create many tiny unlocking positions using the RequestVaultUnlock message, causing the total unlocking positions cardinality to grow to the point where the liquidate_unlocking function runs out of gas. collateral This is highly problematic, since borrowers can prevent being liquidated, which can result in bad debt accumulating.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Liquidators can extract a higher value by looping small amounts of liquidations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "In the contracts/credit-manager/src/liquidate_coin.rs:119-127, request_amount is rounded up using the ceil function. This allows a liquidator to extract a higher value by liquidating small amounts of collateral within a loop. Additionally, the maximum close factor can be bypassed as long as a single liquidation message does not exceed the limit, allowing the total liquidated amount to be higher than the congured limit. We consider liquidations consumes a lot of gas, which decreases the protability of the attack. instead of critical this a major issue because performing multiple small Please see the test_repeated_single_liquidation test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Contract version and name are overwritten during instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "the In contracts/account-nft/src/contract.rs:23-36, during instantiation of account-nft contract, in contract/account-nft/src/contract.rs:29-33 and then again during the call of the parent contract instantiation in contract/account-nft/src/contract.rs:35. the version and name of the contract are set twice. First This implies that the stored CW2 metadata would be the one from the cw721-base contract and not the intended one, potentially causing problems in future migrations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Duplicate keys should be removed to prevent miscongurations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "contracts/credit-manager/src/instantiate.rs:19-25 and In contracts/oracle-adapter/src/contract.rs:47-49, the msg.allowed_vaults, msg.vault_pricing and msg.allowed_coins are not deduplicated before storing them. If any allowed vault addresses or coin denominations are duplicates, earlier congurations would be overwritten, and only the last key would be saved successfully. We classify this issue as minor since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Update of the account-nft address can lead to state inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "In contracts/credit-manager/src/execute.rs:65-80, the contract owner is able to update the address of the account-nft contract. This can cause state inconsistencies as account ids associated with the previous NFT contract are removed. Also, owners of NFTs from the old contract will lose access to their funds managed in the credit-manager that will be virtually transferred to the owners of the NFTs from the new contract. We classify this issue as minor since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Funds held by swapper contract may be unintendedly withdrawn",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "When performing a swap in the swapper contract, the output is transferred to the recipient using in message contract/swapper/base/src/contract.rs:187-194. TransferResult created a Then any amount of contract/swapper/base/src/contract.rs:234. the denom_in and denom_out is transferred to the recipient in However, in the case that the swapper contract holds additional funds of either denomination those would be automatically sent to the recipient in addition to the input and output amounts. We classify this issue as minor despite the fact that no funds should be present in the swapper contract there may be situations where funds are sent to the contract, e.g. an airdrop or inadvertent usage.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Update of the red bank address in the credit-manager could lead to state inconsistency",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "In contracts/credit-manager/src/execute.rs:65-80, the contract owner is able to update the address of the red bank in the credit-manager. This would cause state inconsistencies since all the data stored in TOTAL_DEBT_SHARES and DEBT_SHARES will not be updated accordingly.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. The execution of the AssertBelowMaxLTV callback at the end of the UpdateCreditAccount transaction could run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "In the contracts/credit-manager/src/execute.rs:285-288, AssertBelowMaxLTV is always added to the list of callbacks to execute after the other Actions provided as an input in the UpdateCreditAccount message. This callback is executing two times an unbounded loop through the COIN_BALANCES, DEBT_SHARES and VAULT_POSITIONS vectors that have not a capped length. Also, it is executed after all the other Actions and Callbacks so it has only a fraction of the initially provided gas. This implies that if the cardinality of the vectors is signicant, the remaining gas could not be enough to pay the computation leading to out of gas errors. While this scenario is not likely to happen at the launch of the protocol, the risk of running out of gas will increase with more assets supported and wider adoption.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. MAX_CLOSE_FACTOR is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "the contract owner In contracts/credit-manager/src/instantiate.rs:15, denes the MAX_CLOSE_FACTOR of liquidations which determines the maximum amount of a position that can be liquidated. However, ineectual and not providing a limit to the value that can be liquidated in a single transaction. the value provided has no validation which could lead to the variable being",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Query silently returns input when no pricing method is found.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "function The in contracts/oracle-adapter/src/contract.rs nds the pricing methodology of the coin denom and queries the relevant vault to calculate the value of redemption. query_priceable_underlying If the submitted coin denom does not have a vault price then the input is simply returned to the user. This could lead to wrong assumptions and may negatively impact the usability of the query.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Redundant checks on received funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "the try_from function attempts to In packages/rover/src/coins.rs:136-158, verify that no zero amount denom and no duplicate denoms are provided. This check is unnecessary because Cosmos SDK will prevent zero amounts from being sent (an error will occur) and will automatically combine duplicate denoms into one single denom (eg. [200 ATOM, 100 ATOM] will become [300 ATOM] ).",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Contracts should implement a two step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Custom access controls implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "The contracts within the scope of this audit implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/account-nft/Cargo.toml  contracts/credit-manager/Cargo.toml  contracts/oracle-adapter/Cargo.toml  contracts/swapper/Cargo.toml  packages/rover/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Unbounded number of steps during route registration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "In contracts/swapper/base/src/contract.rs:246-274, is able to dene custom swap routes between token pairs in order to facilitate the exchange of tokens that do not have a shared pool. However, the number of steps a route is able to host is unbounded which could lead to inecient routes being dened. the owner",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Unused callback should be removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "ForceExitVault The packages/rover/src/msg/execute.rs:147-151, protocol and should be removed from the codebase to increase its maintainability. in dened is not used anywhere in the callback",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "3. The function validate in packages/covenant-utils/src/split.rs:46-63 is used only once in the specic context of two-party-pol-holder contract. In this context, its eect is equivalent the function validate_shares dened in packages/covenant-utils/src/split.rs:66-80. It is preferable to just call the latter function with prior verication that self.receivers value contains only the two parties. to the eect of dened Code duplication decreases readability and maintainability, thereby expanding the potential for security vulnerabilities. Recommendation We recommend refactoring the codebase to avoid code duplications. Shared modules with common code as well as generic type parameters and function-type parameters could be used to streamline the data ow. Status: Resolved 43. Remove commented code blocks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-05-02 Audit Report - Timewave Covenants v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Users that unbond from yAsset contract in XPrism mode receive twice their bonded amount minus the fees, and fees are not collected",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "StakingMode::XPrism, In contracts/prism-yasset-staking/src/staking.rs:96-108 and 116 if mode user == - withdrawal_fee. At the same time, the fees are not sent to any other contract. This leads to draining funds from other users and fees not being distributed to stakers, compromising incentives to stake. 2*unbonded_amount receives the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Lack of tax deduction in limit order contract leads to other users funds being spent",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "In contracts/prism-limit-order/src/order.rs:319 and 322 no taxes are deducted during the execution of the swap. Without deducting taxes, the contract will pay taxes for the swap from its own balance, which will consume the oered amounts of other limit orders, leading to a failure to execute those other limit orders in the future. This would aect a wide range of users of the protocol, who would permanently lose their funds.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Missing total bond amount decrease during unbonding from launch pool contract leaves rewards stuck in contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "the in In contracts/prism-launch-pool/src/contract.rs:206-215, the total_bond_amount is not decreased by the unbonded amount. This implies that for any further rewards, the denominator in line 277 will be too big, leading to any bonded users proportionally losing out on further rewards. unbond function",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Users might lose their bonds if unbonding periods of vault contract and Terra protocol are not the same duration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "If no batch is released in contracts/prism-vault/src/unbond.rs:255, the actual unbonded amount is still set to zero in line 317. Moreover, the prev_vault_balance is updated in the calling function execute_withdraw_unbonded in line 191. This might cause lost funds because the vault unbonding period can be freely set, while the Terra unbonding period is xed to 21 days. Two cases are possible. On the one hand, if the unbonding period used in the contract is longer than the actual unbonding period of the Terra protocol, this might lead to lost funds. On the other hand, if the unbonding period is set to less than the actual unbonding period, slashing of validators might lead to a situation where users can avoid being aected by slashing at the cost of other users because the slashing is not executed. Despite the severe implications of a mismatch of the unbonding periods, we classify this issue as minor, since governance can ensure equality of the periods by carefully making required changes.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Exchange rate peg mechanism allows users to prot from slashes and inhibits liquidity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "peg rate exchange in The and contracts/prism-vault/src/bond.rs:119-129 contracts/prism-vault/src/unbond.rs:41-51 might compromise the incentives of users and validators, depending on the parameter values of the threshold and the recovery_fee. There might be a free lunch for any user that bonds directly after a possible slashing event. implemented mechanism this First, compromises contracts/prism-yasset-staking/src/rewards.rs:28-35 stakers_portion could become larger than one. computations made where in the Second, in the worst case, if a potential prot from a free lunch is large enough, validators might be incentivised to trigger slashing in order to realize these prot opportunities. This might compromise the protocol. Third, users that wish to unbond after slashing have to pay up to the maximal peg recovery fee peg_fee in order to restore the peg. This leads to a rst-mover disadvantage in the sense that one single user might need to pay for the whole slashing. This in turn disincentivizes unbonding and reduces the liquidity of all derivative tokens. These issues are caused by the peg recovery mechanism. In contrast to the Anchor protocol, which uses a similar mechanism, Prism does not have a natural peg recovery by accruing rewards on cLUNA.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Withdrawal of funds may fail if a user unbonds many times without withdrawing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "In contracts/prism-vault/src/state.rs:60, 76, 89 and 114, iterations over the UNBOND_WAITLIST may run out of gas, if the list has many entries. Many entries might occur if a user unbonds regularly, but does not withdraw. That could happen for example if the user is a bot that automatically bonds daily. As a consequence, withdrawing funds may fail. There is currently no way to recover from this issue. Similarly the query in line 139 can run out of gas and fail.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Protection against mass withdrawals is weak and can be bypassed with multiple accounts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "In contracts/prism-fair-launch/src/contract.rs:185-187 in order to prevent massive withdraw on phase 2 (as stated in the comment), a fee is charged if withdraw_amount is greater than cfg.withdraw_threshold. This mechanism can easily be avoided by withdrawing multiple times with amounts less than or equal to cfg.withdraw_threshold. Elaborate exploiters can also bypass it easily by using multiple accounts to execute greater withdrawals.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of conguration validation in vault and yAsset staking contracts can cause errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "The conguration of peg_recovery_fee and er_threshold can be set to values larger than one in contracts/prism-vault/src/contract.rs:78-79 as well as in in contracts/prism-vault/src/config.rs:38-39. This might and contracts/prism-vault/src/bond.rs:124-126 contracts/prism-vault/src/unbond.rs:45-47. cause errors An equivalent problem occurs in prism-yasset-staking/src/contract.rs:37 and 42 where protocol_fee and withdraw_fee can be set to values larger than one, which might cause errors in contracts/prism-yasset-staking/src/rewards.rs:70 and prism-yasset-staking/src/contract.rs:116, respectively. We consider this a minor issue, since it can only be caused by oversight of the contract owner. However, errors in production can lead to downtime of the protocol.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Conguration updates in gov contract might aect votes in progress",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "be In contracts/prism-gov/src/contract.rs:205-210, quorum and threshold in aects can contracts/prism-gov/src/polls.rs:141-146, which could aect the outcome of a vote. In addition, proposers might lose their deposit on existing polls after a change of the quorum. updated. progress votes This in As the values can only be updated by the contract owner or through governance, we consider this a minor issue. An update coming through governance would be visible by any proposer at the time of poll creation. Since the outcome of a poll that updates quorum or threshold values might not be certain, proposers could be disincentivized to create new polls during such a period.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Lendings in the red bank cannot be liquidated when ActionKind::Default circuit breakers trigger",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "In the rover:contracts/credit-manager/src/liquidate_lend.rs:43-45, liquidate_lend function withdraws the liquidatees asset lent in the red bank as part of the liquidation process. When a liquidation occurs, price queries are dispatched as ActionKind::Liquidation to ensure liquidations can still be executed during extreme the market design the max_confidence and max_deviation circuit breakers will transaction, possibly hindering the liquidation process. as trigger and revert from ActionKind::Default, conditions. diers This In red-bank:contracts/red-bank/src/withdraw.rs:77-86, However, the red bank contract performs an ActionKind::Default price query during the withdrawals. calls assert_below_liq_threshold_after_withdraw get_user_positions_map with is_liquidation parameter as false, resulting in the of as asset ActionKind::Liquidation. ActionKind::Default executed internally function instead query being price liquidating lent positions in the red bank contract will fail when one of the Consequently, max_confidence or max_deviation circuit breakers is triggered, potentially causing bad debt to accrue and risking the protocols solvency.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Incorrect protocol fee calculation during liquidation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "In the red-bank:packages/liquidation/src/liquidation.rs:100, calculate_liquidation_amounts function computes the liquidation bonus amount by multiplying the collateral_amount_to_liquidate value with the liquidation bonus percentage. This is incorrect because the collateral_amount_to_liquidate value had already the liquidation bonus applied in line 84. Consequently, the protocol fee amount computed in line 103 will be inaccurate because it uses an incorrect liquidation bonus value, causing the protocol to receive erroneous fee amounts. The client has independently detected this issue during this audit.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Incorrect contract name assertion prevents successful migration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "In rover:contracts/account-nft/src/contract.rs:94, the migrate function does not prepend the crates.io: identier to the CONTRACT_NAME when performing a contract migration. This is problematic because the previously deployed version and the contract instantiation process prepends that identier to the contract name. Consequently, migrations will fail because they expects the contract name to not include that identier. This issue is also present in the following contracts:  rover:contracts/credit-manager/src/migrations/helpers.rs:13  red-bank:contracts/oracle/osmosis/src/migrations.rs:13",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Incomplete state migration in account-nft contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "the CONFIG state uses In rover:contracts/account-nft/src/state.rs:5, Item<NftConfig> for version 2.0.0. As version 1.0.0 uses Item<Config>, a state migration is required in order to support the new health_contract_addr eld in the in NftConfig rover:contracts/account-nft/src/contract.rs:88. struct. However, handler does the migrate handle this not Consequently, the burn and update_config functions will fail to load the CONFIG state successfully, preventing the contract from working as intended.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Circuit breakers may block liquidations, risking the protocols solvency",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "In rover:contracts/credit-manager/src/execute.rs:77, the accounts health state is queried with ActionKind::Default before dispatching any actions. The and ActionKind::Default in max_deviation red-bank:contracts/oracle/base/src/pyth.rs:80-81. If one of the validations fails, the circuit breakers will be triggered, preventing the account from dispatching actions during cases of extreme volatility. subjected validations, max_confidence query price seen the as to is However, the circuit breakers might unintentionally block liquidation attempts. This behavior is inconsistent with the documentation, as one of the objectives is to let the protocol always be open for liquidation. To illustrate the scenario, assume a liquidator deposits ATOM as the debt asset to their account in preparation for liquidation attempts while also borrowing other assets. When the ATOMs price experiences high volatility, the max_confidence or max_deviation circuit breakers can trigger, causing the ActionKind::Default health state query to fail. If the liquidator wants to liquidate an undercollateralized positions debt with ATOM, the Liquidate action cannot be dispatched due to the previous health state query. Consequently, the liquidator cannot liquidate unhealthy positions using their accounts debt assets, ultimately risking the protocols solvency. Additionally, borrowers cannot improve the health of their positions during extreme market circumstances, exposing them to liquidation risks.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Inaccurate health computation due to default collateral limit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "When computing an account's health, the user's lending positions are queried using None as the limit parameter in rover:contracts/credit-manager/src/query.rs:69. In contract red-bank:contracts/red-bank/src/query.rs:185, interprets requesting a maximum of ve collaterals by default (DEFAULT_LIMIT) when the limit parameter is unwrapped. request as bank this red the Consequently, the health computation will be unable to include the excess assets if the account lent more than ve assets in the red bank contract, causing incorrect health LTV computation.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Credit manager migration requires the reward collector account-id",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "the rover:contracts/credit-manager/src/migrations/v2_0_0.rs:42, In migrate handler requires the caller to provide the reward collectors address and account id and store it in the REWARDS_COLLECTOR storage. This requirement is invalid because there is no entry point for the rewards collector contract to mint an account id for themselves before If the owner miscongures the account id to another users the version 2.0.0 update. account, the protocol fee will be distributed to them incorrectly.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Contract version is not updated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "The incentive contract inherits the version of the workspace in red-bank:Cargo.toml. During initialization, this version is set correctly. However, during migration, the contract version in updated not red-bank:contracts/incentives/src/contract.rs:767-769. is This could lead to confusion during future migrations as it is not clear which version of the contract is deployed in production.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Users cannot exit vaults for assets that are no longer whitelisted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "In the rover credit manager contract, assets sent are veried to ensure that they are whitelisted. in rover:contracts/credit-manager/src/vault/enter.rs:41. subscription performed during vault This also to is a Should an asset be removed from the whitelist, then users would be unable to exit from both locked and unlocked vaults, causing their funds to be locked.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Credit manager contract is not dened when instantiating the health contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "The credit manager contract address is not stored upon instantiation of the health contract. As soon as the health contract is deployed, the health state and values of a users position can be queried by the credit manager. the new However, should this occur, each query would fail during the creation of rover:contracts/health/src/querier.rs:20. HealthQuerier Consequently, this would cause the failure of any calculation of position health in the credit manager. object in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Insucient validation of the interest rate module",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "In the red-bank:packages/types/src/red_bank/interest_rate_model.rs, interest rate model of the red bank is dened, which uses two constant slope variables to dene the interest rate on either side of the optimal utilization rate. However, during the creation of a new market, it is not validated that slope_1 is less than slope_2, prior to the optimal utilization rate. Were this to be the case, then the economic model of the red bank would be undermined, which could cause signicant losses. We classify this issue as minor since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Insucient price source validation for liquidity token pricing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "In red-bank:contracts/oracle/osmosis/src/price_source.rs:617-623, the current liquidity pool pricing implementation queries an underlying asset's price without proper validation against price_sources. This is problematic because it is crucial to ensure that the price source for denom is not set to an AMM spot price. the example, in For price red-bank:integration-tests/tests/test_oracles.rs:163 source as the Osmosis pools spot price. If the price sources are not validated explicitly, an oversight by admins can potentially open up a price manipulation attack. querying_xyk_lp_price_success case the sets test We classify this issue as minor because it can only happen due to a misconguration by the contract owner. From a secure coding point-of-view, it is recommended that proper validation checks are performed in the code rather to prevent miscongurations. than relying on the owner",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Potential failure of incentives contract migration due to unbounded iteration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "In incentive-migration:contracts/incentives/src/migrations/v2_0_0.rs: the migrate_indices_and_unclaimed_rewards function performs an 198-283, unbounded iteration over all keys in ASSET_INCENTIVES, USER_ASSET_INDICES, and USER_UNCLAIMED_REWARDS storages. This is required because the latest version of the incentives contract implements a new storage design that diers from the old one. If there are too many asset incentives, users, or unclaimed rewards to iterate over though, the transaction will fail due to an out-of-gas error, preventing the migration from working correctly. We classify this issue as informational because a failed migration attempt does not inherently compromise the protocols security. If the migration fails, the contract admin can upload a xed contract with an updated migration function.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Conict between documentation and implementation of the borrow rate calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "In red-bank:packages/types/src/red_bank/interest_rate_model.rs:27, the get_borrow_rate function uses slope_1 when the current utilization rate is less than or equal to the optimal utilization rate. However, in line 14, the documentation states that the utilization rate should use slope_1 when the current utilization rate is less than the optimal utilization rate, not mentioning the case of equality. We classify this issue as informational as the dierence between documentation and implementation does not impact the functionality, but might mislead developers or cause problems in the future.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Use of hardcoded versions during migration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "migrating in credit When rover:contracts/credit-manager/src/contract.rs:132, the values of the old and new versions are hardcoded. manager contract the However, the previous and new contract versions are available as constants and from the lines environment and rover:contracts/credit-manager/src/migrations/v2_0_0.rs:11 rover:contracts/credit-manager/Cargo.toml respectively. in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Inecient execution of messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "For each dispatch action for a particular account, the contract always performs a number of callback messages to ensure that certain conditions are met. the callback message AssertAccountReqs in However, during the execution of rover:contracts/credit-manager/src/execute.rs:255, conditions are only checked if the account is of type high-leverage strategy. This causes the creation of a redundant message, increasing the code's complexity and computational resources required.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Use of custom logic instead of standard libraries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "Throughout the codebase, there are a number of custom conditions that could be simplied by using the cosmwasm_std library functions ensure!, ensure_eq!, and ensure_ne!. example, For rover:contracts/credit-manager/src/utils.rs:36, condition if user != owner {  } is used to return an error if the condition is met. in the The following provides a list of non-exhaustive examples:  rover:contracts/account-nft/src/contract.rs:94, 100  rover:contracts/account-nft/src/execute.rs:80  rover:contracts/credit-manager/src/execute.rs:36  rover:contracts/credit-manager/src/utils.rs:36  rover:contracts/swapper/src/contract.rs:81",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. update_nft_config emits the same attribute value as update_config",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "In the rover:contracts/credit-manager/src/update_config.rs:141, update_nft_config function emits the action key attribute as update_config. This is misleading because the update_config function in line 27 emits the same value, potentially confusing event indexers and o-chain listeners.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. get_route function can be used to reduce code complexity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-09-14 Audit Report - Mars Rover v2 v1.0.pdf",
        "body": "In the rover:contracts/swapper/base/src/contract.rs:164-170, swap_exact_in function attempts to load a swap route and errors if there is no route for the coin_in.denom and denom_out combination. As the get_route function in lines 248-255 performs the same functionality, the code complexity can be reduced by using that function.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. A validator updating its ConsumerKey to the same key causes a panic in the related consumer chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "In x/ccv/provider/keeper/key_assignment.go:505-523, during the processing the execution appends two abci.ValidatorUpdate of ConsumerKey assignments, elements to the newUpdates slice for each consumer key to replace. The rst abci.ValidatorUpdate is constructed with the old key and Power equal to zero and the second one contains the new key with the validators current Power. If a validator updates its key to the same one, the newUpdates slice will contain two elements with the same key and dierent Power, respectively zero and the current one. This would cause the related consumer chain to panic when trying to update the validator set due to the duplicated ConsumerKey in the validator set.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attackers can DOS attack consumer chains by sending multiple coins to the provider chains reward address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "the the During execution in SendRewardsToProvider x/ccv/consumer/keeper/distribution.go:103, gets the balance of all the coins in the tstProviderAddr and sends them to the provider chain. EndBlocker, consumer function, dened chains the of In order to do so, it has to iterate through all the coins found in the reward address and send them one by one through IBC to the provider chain. Since anyone is allowed to send coins to the reward address, an attacker could create and send a large number of coins with dierent denoms to it, for example using a chain with the token factory module, in order to attack the mentioned unbounded iteration and DOS attack the chain. Consequently, the execution of the EndBlocker will take more time and resources than expected causing the consumer chain to slow down or in the worst case even halt.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Validators can slow down the provider chain by submitting multiple AssignConsumerKey messages in the same block",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "AssignConsumerKey The in x/ccv/provider/keeper/key_assignment.go:378, enables validators to assign themselves a dierent consumerKey for approved consumer chains. function, dened In order to perform this action the consumerAddrsToPrune AddressList grows by one element in line 428. this AddressList Since in x/ccv/provider/keeper/relay.go:95, it could be utilized by attackers to slow down the provider chain. EndBlocker iterated over the in is To execute such an attack, malicious actors could craft transactions with multiple AssignConsumerKey messages and spam the provider chain with those transactions. The consumerAddrsToPrune AddressList will grow of the same cardinality as the AssignConsumerKey sent messages. Consequently, the execution of the EndBlocker will take more time and resources than expected causing the provider chain to slow down or in the worst case even halt. We classify this issue as major instead of critical since the number of iterations is bounded by the maximum number of messages in a block.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. The provider chain halts on failure to send packets to a single consumer chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "the execution During SendVSCPacketsToChain x/ccv/provider/keeper/relay.go:182, panics if consumer chain. function, provider the of chains EndBlock function, dened it fails to send a packet the in to a This implies that an issue relevant only to a consumer chain will make the provider chain panic. Likewise, consumers will also panic in x/ccv/consumer/keeper/relay.go:180 because they will not be able to send packets to the provider. This evidences a single point of failure  an error occurring on a single packet for a single consumer can halt the entire ICS network. We classify this issue as major instead of critical because in the current version consumer chains, relayers, and light clients are assumed to be non-malicious.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Potential loss of rewards during consumer chain removal",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "In x/ccv/consumer/keeper/distribution.go, the reward distribution process takes place at the end of each block on the consumer chain. When the number of blocks for transmission is exceeded, the accumulated rewards are sent to the provider. If a proposal to remove or stop a consumer chain is successfully executed, the code at x/ccv/provider/keeper/proposal.go:155-232 automatically handles the removal process. This includes tasks such as cleaning up the state, closing the channel, releasing unbonding operations, and deleting all related data. However, it does not explicitly check whether the rewards associated with the consumer chain have been distributed before removing the chain. This may lead to a loss of rewards that have not been sent to the provider.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Consumer chains can DOS the provider chain by sending slash packets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "In x/ccv/provider/keeper/throttle.go:274-276, a panic occurs if the cardinality of the queue of throttled packets is bigger than the dened MaxThrottledPackets hard cap. This behavior can be exploited by a malicious consumer chain, making the provider unable to process any further packets from other consumers. To execute such an attack, the malicious consumer chain can spam the provider chain with slash packets in order to ll the queue and cause a panic. Since the validation of slash packets in x/ccv/provider/keeper/relay.go does not disregard duplicate or other invalid slash packets, the attack can be performed for example by simply sending a valid slash packet multiple times. This could cause other consumer chains to be removed from the ICS because the provider will not receive relevant maturity notications before the timeout. We classify this issue as minor instead of major because in the current version consumer chains, relayers, and light clients are assumed to be non-malicious.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Validators can evade slashing if an equivocation proposal is submitted seven days or later after the infraction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "When a validator performs a double-signing infraction on a consumer chain, equivocation slashing should be proposed and voted upon. Since the voting period lasts two weeks and the unbonding period is currently set to three weeks, an equivocation slashing proposal submitted seven days or later after the infraction takes place allows the validator to unbond and evade slashing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Consumer chains can expand provider chain unbonding period",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "The default unbonding period for consumer chains DefaultConsumerUnbondingPeriod is set in x/ccv/consumer/types/params.go:37 to one day less than the default unbonding period, which is currently three weeks. Since a validators unbonding matures only after all consumer chains unbondings mature, the DefaultConsumerUnbondingPeriod is chosen to ensure that the validators can unbond without any delays. However, since the consumer unbonding period is not enforced in the code to be less than the providers, consumer chains congured with a bigger unbonding period will delay the providers unbonding period.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Unbounded loop over proposals in BeginBlock could slow down block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "In x/ccv/provider/keeper/proposal.go:370 and 504, an unbounded loop is used to iterate over the ConsumerAdditionProposals and ConsumerRemovalProcess list. This loop has no set limit for the number of times it can run. Since there are no restrictions on the number of consumer chains that can be supported by the provider chain, a large number of proposals could slow down or halt the chain. We are reporting this with Minor severity since proposals go through governance voting and the likelihood of having multiple proposals with the same SpawnTime or StopTime is low.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Unbounded loops over consumer chains in EndBlock could slow down block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "When the EndBlock function is executed on the provider chain, there are several instances where the GetAllConsumerChains function is called to retrieve a list of all consumer chains. As there are no restrictions on the number of consumer chains that a provider can support, this slice can potentially be very large. The GetAllConsumerChains function is called in:  x/ccv/provider/keeper/proposal.go:60,  x/ccv/provider/keeper/proposal.go:173, and  x/ccv/provider/keeper/proposal.go:224. These unbounded lists are then iterated over to perform various operations for all active there are iterations over leadingVSCMaturedData, consumer chains. Specically, pendingPackets, and MustApplyKeyAssignmentToValUpdates. If the cardinality of these lists increases, block production may slow down, possibly even halting the chain. Operations on time-critical applications running on the network such as auctions or governance proposal execution may be delayed when a consumer chain oods the EndBlocker with fraudulent VSC matured packets, leading to a delay in block production. We are reporting this issue as Minor since consumer chains can only be added through governance.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. LastTransmissionBlockHeight is wrongly updated if the IBC token transfer fails",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "the execution During in the x/ccv/consumer/keeper/distribution.go:21, LastTransmissionBlockHeight is updated with the current timestamp even if the IBC token transfer fails. EndBlockRD function, dened the of This implies that rewards are not re-sent in the next block but in the next epoch, leading to lower rewards for unstaking validators. Also, a misleading value is stored.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Inecient removal of executed proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "The BeginBlock function, which is called at the beginning of every block, calls BeginBlockInit in x/ccv/provider/keeper/proposal.go:367 to get the pending consumer addition proposals and then deletes executed proposals in line 391. even the However, DeletePendingAdditionProps function is called to fetch a KVStore from the MultiStore every block, which is inecient. proposal execute, pending there no to is if This ineciency can be removed by changing the function to delete a single executed proposal and moving it inside the for loop. The same issue applies to the DeletePendingRemovalProps function called from BeginBlockCCR in x/ccv/provider/keeper/proposal.go:501.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Emitting incorrect events is misleading",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "In case of unmarshalling packet data failure in the OnRecvPacket function, the ack value will contain an error acknowledgment which is used to emit an event with AttributeKeyAckSuccess in both x/ccv/consumer/ibc_module.go:237 and x/ccv/provider/ibc_module.go:205. This is misleading for client applications and users, since a success ag can be returned along with an error. the DistributeRewardsInternally rewards distributes ConsumerRedistributeName to Similarly, in the x/ccv/consumer/keeper/distribution.go and feeCollector the ConsumerToSendToProviderName DefaultConsumerRedistributeFrac. By the time the sendRewardsToProvider function is called, feeCollector has a zero balance. Thus, in x/ccv/consumer/keeper/distribution.go:138 will always contain 0 emitted fpTokens, which again is misleading for client applications and users the emitted event according function from to",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Redundant checks are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "The codebase contains redundant checks:  The version check in x/ccv/consumer/ibc_module.go:95 is unnecessary as it is already invoked in line 42.  The ValidateBasic function in x/ccv/provider/client/cli/tx.go:56 is the unnecessary GenerateOrBroadcastTxWithFactory function in line 60. invoked already as in is it",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Outstanding TODOs",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "There are multiple TODOs in the codebase that development: imply that the codebase is still in  x/ccv/types/expected_keepers.go:82,  x/ccv/provider/ibc_module.go:185, and  x/ccv/consumer/keeper/genesis.go:21.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Miscellaneous comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "Across the codebase, instances of unused/commented code and inaccurate comments have been found. This can negatively impact the maintainability of the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Excessive transaction fees are incurred",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf",
        "body": "In x/smart-account/ante/ante.go:175-181, transaction fees are deducted if the message signer matches the fee payer address. This logic becomes problematic when the transaction contains multiple messages, and the messages signer is the fee payer. The fee would be incorrectly deducted multiple times, causing the fee payer to incur excessive transaction fees. comparison, in For classicSignatureVerificationDecorator only charges a one-time fee for all the messages in a transaction. deductFeeDecorator the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Inconsistencies in the AnyOf authenticator may lead to errors and incorrect authenticated requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf",
        "body": "in x/smart-account/authenticator/any_of.go:85 The AnyOf authenticator iterates over all congured authenticators in the Authenticate function until any sub-authenticator succeeds when its Authenticate function is called. It does the same in the ConfirmExecution function, which calls ConfirmExecution on all congured authenticators until there is one without an error. This means there can be the following situations: authenticatorA returns success when Authenticate is called but returns an error on the ConfirmExecution function. Another authenticator, authenticatorB, returns an error on Authenticate but succeeds for the ConfirmExecution function. Although no authenticator returned success for both Authenticate and ConfirmExecution functions (which is the requirement for requests to authenticate normally), the AnyOf authenticator will authenticate such a request successfully. inconsistencies can also arise because of this logic, especially for stateful Other authenticators. Consider an example conguration [A, B]. If Authenticate fails on A and succeeds on B, whereas ConfirmExecution succeeds on A, there will never be a call to ConfirmExecution on B. This can be problematic because authenticators may be written under the assumption that there will always be a ConfirmExecution call for every successful Authenticate call, leading to unintended states if this is not the case. Similarly, the logic for AnyOf authenticators Track function can also lead to undesired states. This function requires that all congured authenticators do not return an error, even if they were not involved in the authentication at all. This violates the following excerpt from the documentation: The Call Track() on all messages step is executed, notifying the authenticators involved.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Unimplemented GetAuthenticator query",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf",
        "body": "GetAuthenticator The in x/smart-account/keeper/query.go:37-57, that returns the selected authenticator data is not exposed in queries, as seen in x/smart-account/client/cli/query.go. function, dened",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Composite authenticators can be initialized with a single sub-authenticator",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf",
        "body": "Composite authenticators, such as AnyOf and AllOf can be initialized with a single sub-authenticator and x/smart-account/authenticator/any_of.go:60. Although this does not pose any security threats, it is unnecessary if composite authenticators are initialized with a single sub-authenticator. x/smart-account/authenticator/all_of.go:50 in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Open TODOs",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf",
        "body": "The codebase contains several open TODOs and further comments which may indicate that the codebase is not ready for release in the following locations:  app/ante.go:86  x/smart-account/ante/pubkey.go:49  x/smart-account/ante/pubkey.go:59  x/smart-account/authenticator/authentication_request.go:227  x/smart-account/authenticator/message_filter.go:183  x/smart-account/post/post.go:92  x/smart-account/types/msgs.go:40",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Misleading documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-07-03 Audit Report - Osmosis Smart Accounts v1.0.pdf",
        "body": "There are instances across the codebase of misleading documentation:  In x/smart-account/authenticator/signature_authenticator.go:90-9 7, in contrast to the documentation, the onAuthenticatorAdded function does not allow for an empty config.  In x/smart-account/keeper/keeper.go:111-154, GetInitializedAuthenticatorForAccount inaccurate. functions documentation the is Inaccurate documentation may mislead developers and decrease the maintainability of the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Vesting contract allows unlimited allocation by malicious CW20 contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-02 Audit Report - Levana Stage 2 v1.0.pdf",
        "body": "The CW20 receive hook of the vesting contract currently accepts any CW20 token. Therefore, through contracts/levana-vesting/src/contract.rs:74-95, it is possible for an attacker to create unlimited allocations using a malicious CW20 token contract that sets cw20_msg.sender to the protocols admin address. The attacker could subsequently withdraw Levana tokens once the vesting period has expired.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "1. Missing access control of strategy contract conguration updates allows attackers to DoS attack the protocol and redirect queries to malicious contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf",
        "body": "the exec_config_update In contracts/strategy/src/contract.rs:187-226, function of the strategy contract allows updating the contract congurations such as the core, puppeteer, validator-set and distribution contract addresses, as well as the reference denom. However, since there is no access control for the function, anyone can update the contracts cong to arbitrary values. Consequently, attackers can consistently spam UpdateConfig messages to store invalid addresses for contract dependencies causing the strategy contracts queries to fail and disrupting protocol operations. Additionally, attackers could update contract dependencies to malicious contracts that return malicious data.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Incorrect fee accounting leads to loss of funds and DoS",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf",
        "body": "get_stake_msg The in contracts/core/src/contract.rs:1063-1127, processes delegation messages, updating the COLLECTED_FEES with the amount to the respective fee_address. to be sent function, dened Those fees are then transferred from the ICA account to the fee collectors during the the get_non_native_rewards_and_fee_transfer_msg function execution of dened in lines 1301-1314. However, after the fees are transferred by the puppeteer contract to fee collectors, the COLLECTED_FEES map is not reset. Consequently, as the FSM continues normal operation, more fees are added and all the fees, including the ones that have been already sent, are transferred again. This leads to a loss of funds for the users and eventually causes a denial of service, due to the impossibility of transferring an amount larger than the balance of the ICA account.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. The protocol can get permanently stuck in the Staking state due to unhandled errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf",
        "body": "the execute_tick_staking In contracts/core/src/contract.rs:693-696, function within the core contract acts as the designated handler when the ContractState transitions to Staking during routine procedures. However, if during this process the puppeteer contract callback to the PuppeteerHook stores a ResponseHookMsg::Error because of a timeout or an error in the ICA transaction, the execute_tick_staking function consistently returns an error in line 695. Consequently, lacking an alternative handler to progress the ContractState, the routine becomes unable to proceed, resulting in the protocol becoming permanently stuck.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. First bonding results in a division by zero error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf",
        "body": "contracts/core/src/contract.rs:173-179, In function calculates the actual exchange_rate with the following formula: the query_exchange_rate _ = _ + _ + __  _  __ __ in a zero exchange_rate since However, during the rst bonding, delegations_amount, total_lsm_shares and unprocessed_unbonded_amount are zero while core_balance and current_stake would be the same amount. results it this Consequently, contracts/core/src/contract.rs:788, causing the protocol process bonding. division would result by in a in zero to not be able to error",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Attackers can spam Unbond messages to cause DoS of the protocol",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf",
        "body": "In contracts/core/src/contract.rs:952-959, the execute_unbond function of the core contract allows users to unbond their tokens. By doing so, the execution appends an UnbondItem to the unbond_items vector of the current unbond_batch and then stores it in the contract. However, since there is no maximum cardinality of items that can be appended in the unbond_items vector and no minimum unbounding amount requirement, attackers could spam a large amount of Unbond messages with a small unbounding amount to grow the vector size. This would result in increasing the costs for encoding and storing the unbond_items vector to the point of the execution running out of gas and hindering users to unbond.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Incorrect mint calculation during DenomType::LsmShare bonding",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts v1.0.pdf",
        "body": "In contracts/core/src/contract.rs:1005-1064, enables users to bond their tokens and mint derivatives. the execute_bond function However, if the denom_type is equal to DenomType::LsmShare, the amount is directly used without calculating the underlying amount. Consequently, an incorrect number of tokens is computed and minted, resulting in inaccurate accounting and potential nancial losses for users. This issue has been independently reported by a third party. Status: Externally Reported 7. Invalid nite state machine transitions prevent expected ow execution Severity: Major There are multiple instances of state transitions that are not considered valid in the context of the nite state machine (FSM). in the example, For in contracts/core/src/contract.rs:562, the FSM state is set to Claiming, even if there are no validators_to_claim. Since the state transition from Claiming to Unbonding is not valid this would prevent the branch from being executed in lines 574-579. execute_tick_idle, function However, even if the state of the FSM remained in the Idle state, the only valid transition to Unbonding is from Staking. This would prevent any unbondings in any other tick except execute_tick_staking. In particular, in execute_tick_claiming the branch cannot be executed in lines 651-654. Similarly, in execute_tick_transferring the branch in lines 676-679 would be an invalid state transition from Transferring to Unbonding.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "1. Users will not get native assets back when borrowing them from borrowed farm",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "In the callback_unbond_hook function, stakers that borrow native assets should receive the swapped amount since the pairs swap_msg functionss to parameter to see Some(staker_addr.to_string()), contracts/borrowed-farm/src/bond.rs:407. For native assets though, there is a bug in packages/alpha-homora-v2/src/adapters/pair.rs:206. Consequently, a swap of native assets would be called with None set as the to parameter, which would lead to the swapped funds being stuck in the borrowed farm contract. swap_msg functions is set apply value does that not the the to in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Attackers may delay price update transactions by feeders to manipulate oracle prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "the When feeders feed prices to the oracle contract, PriceInfo is set to the current block timestamp. When querying prices from the oracle, that last_update_time value is used in contracts/oracle/src/contract.rs:265 to check whether the last updated price is too old. An attacker (or colluding validators) may exploit this by delaying transactions to shift price updates. the last_update_time of Suppose that a feeder sends a price update transaction in block 12345. An attacker may execute a DOS attack on the target node or the feeders infrastructure to prevent the inclusion of the transaction until some point in the future (e.g. block 13000). In that later block 13000, the price will be accepted and will be considered up to date. That allows an attacker to shift prices around to their benet.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. New borrowers using Homora Bank will pay fees for older borrowers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "During borrows and repays in the Homora Bank contract, the current debt state is updated in In that function, the interest accrued within the Red the update_debt_state function. Bank is calculated, and a proportional Homera fee is stored in state.homora_fee. When a user now repays their loan, they will have to pay that homora_fee proportionally to the in amount contracts/homora-bank/src/contract.rs:462-464 does not account the duration a user has been borrowing though, which implies that new users pay the fees for previous users. current mechanism implemented for repay. debt they The of As an example, suppose there is a current debt of 100 in the Homora Bank and a homora_fee of 10. Now a user is borrowing 100 tokens and immediately repays these 100 tokens in the same block. The current logic will charge that user a proportional fee of 10 * 100 / 200 = 5 tokens.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Tokens with low price may have wrong price quoted by oracle due to loss of precision and price impact of probe amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "calculating in When contracts/oracle/src/contract.rs:297, the price_multiplier, which eectively truncates any decimals beyond 6 decimal places. This is a major issue for tokens that have very low prices and many decimal places. For is multiplied price the in price median oracle the the by example, a token with 18 decimal places and a current price of 0.0000018 would be wrongly represented within the Alpha protocol with a price of 0.000001. Additionally, the probe amount may lead to too much of a price impact for tokens with a low token price.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Wrong interest rate is used when withdrawing from lending bank, leading to small losses for other users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "to interest rates are During the execute_withdraw function of the lending bank contract, updated in withdrawal contracts/lending-bank/src/contract.rs:701. With the linear interest model, a withdrawal implies that utilization goes up, which means that both the borrow rate and the liquidity increase. balance reect after new the in line 707, the balance after withdrawal is calculated. Within that calculation in the Then, get_updated_liquidity_index function, the new liquidity rate is used to update the liquidity index. Since the liquidity rate went up, the liquidity index is higher than it should be. This implies that the user will have fewer IB tokens burned than they should have. The protocol and hence other users will take the dierence. The impact of this issue depends on the activity of the protocol with high amounts locked, small burned amounts and frequent interactions that update interest rates, the impact of a wrong index is rather minor. If there are big withdrawals and less frequent interactions though, there can be material losses for other users.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Adjusting positions up will fail if borrow asset is native but provide asset is CW20 or vice versa",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "the In method contracts/borrowed-farm/src/adapters/leveraged_farm.rs:73, wrong borrow_asset_info is sent in line 75. increase_position_msgs provide_asset_info whether native check is a in there is a while asset, This is no issue if both tokens are either native or both are CW20 tokens. If they are of dierent asset types though, no funds of borrow_asset_info will be sent or no allowance will be increased, which will lead to a failure of the execute_adjust_position function when positions are increased in contracts/borrowed-farm/src/bond.rs:557.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Oracle uses median of recent (spot) prices, may be subject to spot price manipulation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "Dierent functions in the protocol query the oracle contract for asset prices. Each asset has those prices in the dierent price sources, and the oracle returns the median of query_asset_price function in contracts/oracle/src/contract.rs:297. All of the price sources use a single stored or queried price. Some of those price sources use spot prices. Spot prices can be manipulated, for example by swapping large amounts of tokens before using the Alpha contracts. Depending on the conguration of an asset, this may allow manipulation of the median price, and hence may be exploited by an attacker. We classify this issue as minor since spot prices are only supposed to be used for testing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Swap amount calculation does not account for taxes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "function get_swap_amount in The contracts/leveraged-farm/src/deposit.rs:81 and 102 on the amounts prior to deducting tax, which happens in lines 84 and 104, respectively. That implies that the swap calculation will be slightly o, and the small dierence will be arbitrated away by external actors. While the impact of this dierence is small, it will take away from a users yield and is easily prevented. called is We consider this issue to be minor since the impact is relatively small.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Repayment may fail if amounts are small",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "During repayment, in the callback_repay function, a swap happens between asset A and asset B to settle outstanding debt from bank A and bank B. Those swaps have a condition to tokens swap in contracts/leveraged-farm/src/withdraw.rs:181 and 197. If that minimum is swapped, the remaining amount of the bid asset might not suce though to repay the other loan. minimum of a",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Swap calculation in leveraged farm uses hardcoded fee and will be wrong if the underlying fee is changed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "get_swap_amount The in contracts/leveraged-farm/src/deposit.rs:43 assumes that the underlying pool swap fee is 0.3%. That value is hardcoded in the formula and hence calculated swap amounts will be wrong if the underlying swapping protocol changes their fee. function same exists The contracts/borrowed-farm/src/bond.rs:527. issue the in execute_adjust_position function in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Lack of price validation in oracle might cause issues",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "Prices from feeders are currently not validated. Feeders could (accidentally) set a price to zero in contracts/oracle/src/contract.rs:133. That causes inconsistencies in the protocol, for example in health checks of a position.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Cong parameter validation missing in Homora Banks init asset cong",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "the Homora Bank, conguration In the execute_init_asset_config function of parameters in are contracts/homora-bank/src/contract.rs:175-180. If those parameters are set to invalid values, the collateral_factor is set to zero. the protocol might not work as expected  for example if validated not neither Additionally, execute_update_asset_config function currently validate the fee_rate or liquidation_bonus. execute_init_asset_config nor the the the We consider this to be a minor issue since it can only be caused by the owner and is recoverable.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Treating Luna as a special case for tax calculation may lead to problems with Terra protocol updates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "In packages/alpha-homora-v2/src/adapters/asset.rs:318, Luna is treated as a special case for tax calculations, with a hard-coded zero tax value. However, this might lead to inconsistencies if Terra changes the Luna tax policy in a future protocol update. In such a case, the contract would pay the tax, misusing funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Reliance on assumed received amounts might cause issues in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "In several places in the codebase, the implicit assumption is made that another contract is sending a requested amount. Even if correct today, that assumption might be wrong in a future update of a dependent contract, for example, if fees are introduced that reduce the sent amount. An example of this can be found in the Homora Bank contract, where an asset is borrowed from the bank in contracts/homora-bank/src/contract.rs:387. Then the asset is sent to the borrower in line 389, without verifying that the requested amount has actually been received.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Failing swap simulation in leveraged farm may lead to high arbitrage losses when providing liquidity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "If the swap simulation in contracts/leveraged-farm/src/deposit.rs:89 or 109 fails, a zero value is used. Swapping is then skipped in lines 91 or 111, but the liquidity is still provided and the position increased. This may cause liquidity provision with a ratio that is far away from actual pools of the AMM, and the dierence will likely be arbitraged away by external parties, leading to a loss of value.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Spot price queries from oracle may return wrong prices if neither asset is UST",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "the function, query_spot_price In in contracts/oracle/src/contract.rs:331-335 that one of the two assets of the pair the price will always be quoted in assets[1]. This is is UST. problematic, since a misconguration of the pair would lead to the protocol executing with wrong prices, rather than returning errors. assumption is made thats not the case, implicit the If",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Interest rate calculation does not account for leap years/seconds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "SECONDS_PER_YEAR in The contracts/lending-bank/src/interest_rates.rs:20 has a value of 31536000 seconds, which corresponds to 365 days (a non-leap year). This implies that in leap years and when leap seconds are used, the interest rate will be slightly higher than expected. constant",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Querying the lending banks market list, user debt and user positiont may run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "The query_markets_list, query_user_debt, and get_user_asset_positions in functions unbounded and contracts/lending-bank/src/contract.rs:1079, contracts/lending-bank/src/accounts.rs:73. That may run out of gas. iterations markets contain stored 1104, over all",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Max di value validation in borrowed farm is executed on previous value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "the execute_update_position_parameters In in contracts/borrowed-farm/src/contract.rs:297, validate_percentage is called with the previous max_diff value, not the newly set one. That allows a max_diff value that is bigger than 1. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. NOIZDStaking.sol: Instant withdrawal signatures can be replayed to bypass freeze time in some cases",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf",
        "body": "Nonces are used as a type of withdrawal id to make instant withdrawal permissions unique, which is veried in function _withdrawInstant. However, nonces are kept on a per-user basis, meaning that a user could re-use an admin generated signature intended for another user currently on the same nonce.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. NOIZDStaking.sol: Refund could be blocked by a malicious or faulty receiver",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf",
        "body": "The transaction reverts if a single Ether transfer fails (line 388), allowing a malicious or faulty receiver to block the refund operation. This is mitigated by the fact that the built-in pagination allows the admin caller to avoid such malicious or faulty receivers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. NOIZDNFT.sol: Unreachable conditional statement",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf",
        "body": "The following code in function tokenURI in line 63 will always result in the execution of the rst branch: return string(abi.encodePacked(baseURI, _tokenURIs[tokenId])) : \"\"; bytes(baseURI).length > ? The reason for this is that baseURI is read from the hardcoded value \"ipfs://\".",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Outdated OpenZeppelin release used",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf",
        "body": "The codebase imports a relatively recent version of the OpenZeppelin smart contract library. However, there have been recent security releases that x issues, some of which are related to ECSDA signing. These issues seem not to apply in the present use case of the contracts. However, we recommend using the latest security release, particularly, since the draft EIP-712 implementation used is updated frequently.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Randomness precompile does not charge gas for external call processing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "get_randomness The in builtin_actors/actors/evm/src/interpreter/precompiles.rs:346, which is callable from the FEVM, does not account for gas for the entire process. precompile dened In ref_fvm/fvm/src/gas/price_list.rs:684, gas is only charged for hashing and the precompile call but not for the random value generation process. Since this function can be invoked by any contract in FEVM, an attacker is able to create a contract that intensively calls this precompile in order to use computational resources without being charged appropriate gas. This could lead to overloading nodes in the network, up to the point where block production slows down or even stops due to timeouts being reached.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Actor installation is not charging gas on wasm preload error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "In ref-fvm/fvm/src/kernel/default.rs:906, charging gas after the engine preload operations. the install_actor function is This implies that if the engine fails to set up the wasm engine and bytecode, it will return an error interrupting the execution without calling the on_install_actor function, which is responsible for charging gas. An attacker could take advantage of this by loading an invalid serialized wasm le that consumes computational resources and then returns an error in the preload operations paying no additional gas.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. No gas is charged for event emission and storage",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "In fvm/src/gas/price_list.rs:274-281, the gas cost for event-related operations is zero. This implies that no additional gas cost is charged to actors that emit events, including FEVM. Additionally, during the execute_message function, the commit_events function, dened in fvm/src/machine/default.rs, performs an unbounded loop through all the provided StampedEvents in order to store them one by one in an Array Mapped Trie without accounting for gas. Since no gas is charged for event emission and storage, an attacker could leverage this behavior in order to consume computational resources without paying additional gas. This can be exploited to slow down block production or even halt the chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. difficulty opcode is not following the EVM specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "As per the legacy EVM specication, the DIFFICULTY opcode returns the current block diculty. After the introduction of EIP-4399, this opcode behavior changed slightly in order to return an RNG beacon following the RANDAO specication. The current FEVM implementation of the DIFFICULTY opcode always returns zero. This implies that smart contracts using this functionality could suer unexpected behaviors.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Storage opcodes do not follow EIP-2929",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "In the EVM Berlin fork, EIP-2929 got introduced, which is not implemented in current storage opcodes in the FEVM. Because of that, the FEVM implementation diverts from the gas handling of the EVM.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Maximum stack size can be exceeded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "Prior to executing an opcode, the stack size is checked by calling the Stack::ensure function in builtin-actors/actors/evm/src/interpreter/stack.rs. the current stack size is insucient, the stack size is doubled, possibly increasing the stack size beyond STACK_SIZE. If If the Stack::ensure function is called again as part of executing the next opcode, and the required size is less or equal to the current stack size, it will consider the stack size sucient without checking the size limit. This leads to the stack size being increased beyond the intended limit of 1024 to a maximum stack size of 2048.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Deviating from the EVM, retrieving the code for non-existing accounts reverts the transaction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "the The opcodes EXTCODESIZE, EXTCODECOPY, and EXTCODEHASH retrieve the bytecode by calling in get_evm_bytecode_cid builtin-actors/actors/evm/src/interpreter/instructions/ext.rs. However, non-existent account, leading to the transaction being reverted. this function returns an unhandled error in case the address belongs to a function On the contrary, the EVM returns 0 for EXTCODESIZE, and the keccak256 hash of empty data (0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470) for EXTCODEHASH if the target address is a non-existent account.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Opcode gas accounting deviating from the Ethereum EVM specication could lead to unexpected behavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "Due to the dierent gas accounting, contracts developed for the EVM might experience compatibility and portability issues when deployed to the FEVM. Commonly, code is optimized regarding gas cost, but since the FEVMs gas accounting is dierent, the same contract executing on the EVM might run out of gas on FEVM or vice versa. Please nd below a few concrete examples of issues caused by the diverging gas accounting: 1. In the following example, the store function is executable on Ethereum and Binance Smart Chain with num = 50_000, while not executable on the FEVM. It runs out of gas if num >= 45_000. uint256 number; function store(uint256 num) public { for(uint256 i = 0; i<num; i++){ number = i; } } 2. If a contract contains a call instruction with an explicitly provided gas limit via {gas:value}, it may not be portable from the EVM to the FEVM. The optionally dened gas limit for the call instruction has to account for all the internal FVM operations (e.g., system.send handling), making it complex for developers to guess the correct amount of gas limit to provide. An example is provided in Appendix 1. 3. Ethereum smart contract developers usually optimize the code and the build process to minimize gas costs for the user. enables that solc https://docs.soliditylang.org/en/v0.8.17/internals/optimizer.html. optimizations dierent types of rely on opcodes Using the --optimize-runs compiler ag optimizes the gas cost of contracts designed to be deployed once and executed multiple times or if they are children of a factory contract. Also, some common patterns exist to optimize the code to use cheaper opcodes. For example, using SSTORE to store zeros in the EVM is cheaper than other numbers. All of these types of optimizations are not eective in the FEVM and could lead to portability issues. An example of how optimizations aect gas usage in FEVM is provided in Appendix 2.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. assert instruction does not consume all the remaining gas as dened in the EVM specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "As per the EVM specication, the assert instruction should consume all the remaining available gas by executing the 0xFE INVALID opcode. However, the FEVM implementation returns error code 33 without charging the remaining gas.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. The bitwise SAR opcode returns 1 instead of 0 if shift is greater than or equal to 256",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "to 256 for The EVM specication states that the SAR opcode should return 0 if shift is greater than or the FEVM implementation in equal builtin-actors/actors/evm/src/interpreter/instructions/bitwise.rs: 43 for the SAR opcode returns U256::ONE (i.e. 1) instead of 0 in this case. This can lead to incorrect results for the SAR opcode. 0. However, a value >=",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "11. LOG opcodes do not revert in case of a STATICCALL",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "According to the EVM specication, executing LOG opcodes is not allowed in a read-only STATICCALL and should revert in this case. However, the FEVM log function implementing the in does builtin-actors/actors/evm/src/interpreter/instructions/log.rs not check if the current call is a staticcall. opcodes LOG",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "12. block.coinbase is not following the EVM specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "According to the EVM specication, the block.coinbase instruction should return the miner of the current block. In contrast, in the FEVM, a zero value is returned. This implies that all the smart contracts that use this information, for example, as a source of entropy, will not work as intended. Examples of usages of this instruction on open source projects can be found with this GitHub query, resulting in around 24K results.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "13. FEVM gas consumption could saturate the available gas in a block and slow down the processing of core Filecoin operations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "The FEVM gas consumption is generally higher than that of other core Filecoin network transactions. For example, a FIL transfer performed through FEVM costs 1.651.058 gas, while the same operation costs 489.268 with a base Send transaction. Since FEVM-related gas fees are on a dierent numeric magnitude than base operations, this could lead to a situation where FEVM transactions could saturate the block, leaving little room for core Filecoin operations.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "14. The CREATE2 opcode smart contract generation is not supported by FEVM",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "The FEVM does not support smart contract creation using the CREATE2 opcode, while the EVM does. This behavior breaks the compatibility of smart contracts expected to work in the FEVM. A sample smart contract used for testing is available in Appendix 3. The functions create2NewToken and deploy in the provided smart contract revert when executed with the following error: { \"code\": 1, \"message\": \"message execution failed: exit 33, reason: message failed   with backtrace:\\n00: f01306 (method 2) -- contract reverted (33)\\n01: f010 (method 3) -- Serialization error for Cbor protocol: Mismatch { expect_major: 2, byte: 152 } (21)\\n (RetCode=33)\" } As a reference, the same smart contract can be successfully deployed with the CREATE2 opcode on the Goerli network: https://goerli.etherscan.io/tx/0x60150e92677fc2738571222de5a0c107780c131a38f87a493f2 58a56444f93",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "15. FEVM allows funds to be sent to a contract without the need for a receive or fallback method",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "Using the send and transfer functions on the FEVM, a contract can receive funds even without having a fallback or receive function. In contrast, the EVM specication requires that a smart contract cannot receive payments if it lacks a receive or fallback function. Breaking this assumption may result in unexpected behavior, including potentially lost funds. A sample smart contract used for testing is available in Appendix 4.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "16. After SELFDESTRUCT, FEVM does not follow the EVM specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "In the EVM, when a smart contract executes the SELFDESTRUCT opcode, it thereafter operates as an EOA, which means that its code is erased while it continues to receive payments. However, the funds are no longer available since smart contracts do not have explicit private keys. the FEVM, after executing SELFDESTRUCT on a smart contract, payments can no longer be received, and the error actor doesn't exist is returned. implementation of In the present This behavior of FEVM deviates from the EVM, which may cause problems when migrating EVM-based smart contracts directly to FEVM. A sample smart contract used for testing is available in Appendix 5.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "17. DELEGATECALL does not propagate msg.value to the implementation contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "As per the specication of the DELEGATECALL opcode, the execution context should be the same as the caller contract, which implies that the msg.value and msg.sender values should be the same in the implementation contract, and the implementation contract can utilize those values during execution. However, the FEVM implementation of DELEGATECALL does not propagate the msg.value of the caller context during the delegatecall, since in msg.value builtin-actors/actors/evm/src/interpreter/instructions/call.rs:148. This reduces the portability of EVM contracts to the FEVM and may even lead to unexpected these behavior with potentially catastrophic consequences if divergences in behavior. teams are unaware of U256::zero() passed as is A sample smart contract used for testing is available in Appendix 6.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "18. Diverging behavior of gas refunds during SELFDESTRUCT between EVM and FEVM",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "According to the EVM specication, the SELFDESTRUCT opcode refunds 24000 gas units. The accumulated refund can not exceed half of the gas used for the current context, while a gas refund is provided only once at the end of the transaction's execution. In contrast, the FEVM refunds gas upon SELFDESTRUCT during the the transaction in ref-fvm/fvm/src/kernel/default.rs:180. That implies that the execution can use refunded gas, which may lead to unexpected behavior when porting smart contracts from the EVM to the FEVM. execution of",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "19. Retrieving the code of precompile addresses reverts, which diverges from the EVM specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "In the FEVM, the opcodes EXTCODESIZE, EXTCODECOPY, and EXTCODEHASH revert if the target address is a precompile. Given that the FEVM considers all addresses in the range between 0x0 and 0xffff as precompiles, the aforementioned opcodes revert for those addresses See builtin-actors/actors/evm/src/interpreter/instructions/ext.rs:59. precompiles. even they are not if On the contrary, the EVM returns 0 for EXTCODESIZE and the keccak256 hash of empty data (0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470) for EXTCODEHASH if the target address is a precompile.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Users can incentivize pools without supplying native funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "The in incentivize the contracts/tokenomics/incentives/src/utils.rs:285 assert_coins_properly_sent function to determine that the funds sent with the the message However, assert_coins_properly_sent function does not perform the fund assertion if the supplied funds are empty, as seen in packages/astroport/src/asset.rs:254. specied function tokens. reward match calls the Consequently, users can incentivize native reward tokens without supplying them inside info.funds. Please refer to the test_incentive_without_funds test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Users can claim excess rewards by specifying duplicate liquidity tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "In contracts/tokenomics/incentives/src/execute.rs:37, the lp_tokens vector specied by the user will be used to claim rewards from the pool. However, specifying duplicate liquidity tokens allows the user to claim more rewards as the existing pool and user positions are collected in a batch, causing the claim_rewards function to compute eligible rewards from an outdated state. Consequently, users can claim excess rewards from the pool, causing a loss of funds for the protocol. Please refer to the test_claim_excess_rewards test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Possibly incorrect reward calculations for new reward schedules",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "In the contracts/tokenomics/incentives/src/state.rs:59-61, calculate_reward function computes the user rewards by multiplying the global index and the user-bonded liquidity token amount if the user index is larger than the global index. This happens because if a new reward schedule is added after the old reward schedule is completed, full rewards are accrued to the user as their liquidity token staking spans across both reward periods. However, suppose the new reward schedules global index is larger than the user index (e.g., due to a large reward amount or a smaller number of stakers). In that case, the rewards will be computed incorrectly in line 63. Specically, the reward is calculated by deducting the global and user indexes and multiplying them with the user-bonded liquidity token amount. Consequently, users will not receive the total rewards they have staked across both periods, causing a loss of rewards for them. Please refer to the test_user_claim_less test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Malicious CW20 tokens can prevent legitimate rewards from being incentivized",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "the contracts/tokenomics/incentives/src/utils.rs:325-329, In remove_reward_from_pool function calls into_msg to transfer the remaining CW20 token the Internally, Cw20ExecuteMsg::Transfer message on the CW20 token contract to complete the fund transfer. the into_msg function calls recipient. rewards to the The issue is that malicious CW20 tokens can revert on purpose when the Transfer message is called, causing the transaction to fail and preventing the owner from removing them. As (see contracts/tokenomics/incentives/src/state.rs:267), legitimate reward tokens might not be possible to be added. Stakers would receive worthless tokens as rewards and would be disincentivized from providing liquidity to the pair contract. the maximum number allowed is external rewards ve of",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. External reward incentivization can be maliciously blocked",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "in Reward incentivization is controlled through multiple factors, such as ensuring the reward is the not BLOCKED_TOKENS in incentivization_fee_info contracts/tokenomics/incentives/src/utils.rs:248. requiring caller and pay the fee to In contracts/tokenomics/incentives/src/state.rs:267, MAX_REWARD_TOKENS denes a maximum number of external reward token denoms that can be incentivized for a pair, which is a constant dened as ve. Once this limit is reached, a pool can no longer be further incentivized through external tokens. This presents an opportunity for an attacker to incentivize a pool with multiple worthless non-blacklisted denoms in order to reach the limit and block legitimate external rewards incentivization. Although the incentivization_fee_info fee is implemented, a motivated attacker could block external rewards to a pool relatively inexpensively. Additionally, the BLOCKED_TOKENS is congured as a vector that will increase in size for every blocked token. If the owner keeps adding the attackers tokens to the list with the UpdateBlockedTokenslist message, an out-of-gas error might occur when blocked_tokens.contains is called, as the contains function operates with O(n) complexity. We classify this issue as minor due to the mitigating eect of the incentivization fee.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Native token factory liquidity tokens cannot be supported",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "In the contracts/tokenomics/incentives/src/utils.rs:346-349, query_pair_info function calls the pair_info_by_pool function after parsing the lp_minter address from the native token factory denom. The parsed address will be the pair contract address because the second substring in token factory denoms represents the creators address, which is authorized to mint and burn tokens. occurs problem in The packages/astroport/src/asset.rs:656 attempts to retrieve the pair contract address by sending a Cw20QueryMsg::Minter query message on the lp_minter address. pair_info_by_pool function when the This implies that calling the pair_info_by_pool function for token factory denoms will fail because the Minter query is unavailable in a pair contract. We classify this issue as minor because the support for pair contracts to use token factory denoms is not implemented yet at the audited commit.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Updating blocked tokens does not aect existing reward tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "The contracts/tokenomics/incentives/src/execute.rs:428-503 update_blocked_pool_tokens function in automatically removes active pools BLOCKED_TOKENS. However, this is not enforced for existing reward tokens. that are part of contain assets that the newly added Specically, the incentivize function does not allow blocked tokens to be added as an external reward in contracts/tokenomics/incentives/src/utils.rs:221. As this is only validated when incentivizing new reward tokens, existing reward schedules that contain blocked tokens are not removed. Therefore, although a blocked token will no longer be eligible for new rewards, any pool that already includes it will keep distributing the token.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. The factory contract cannot deregister pairs not stored in the incentives contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "the contracts/tokenomics/incentives/src/utils.rs:110, In deactivate_pool function calls PoolInfo::load when the factory contract deregisters a pair contract address. Such transactions will fail and revert if the liquidity token is not stored in the incentives contract though. This could happen if no users stake the liquidity token in the incentives contract or the liquidity token is not incentivized internally or externally. Please refer to the test_cannot_deactivate_pool test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. The remaining reward funds could be stuck after the owner deregisters them",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "and optionally The RemoveRewardFromPool message allows the owner to remove an external reward token in rewards the owner does not contracts/tokenomics/incentives/src/state.rs:380. choose to remove upcoming rewards from the EXTERNAL_REWARD_SCHEDULES storage, the funds will remain in the contract and will only be distributed if someone incentivizes it for the liquidity pool. scheduled upcoming remove If However, if the reward schedule period has ended and the reward is not incentivized, the funds will be stuck in the contract because there is no entry point for the owner to withdraw them. We classify this issue as minor because it can only be caused by the owner passing a true value for the bypass_upcoming_schedules argument.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Orphaned rewards will be stuck in the contract after the schedule nishes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "In contracts/tokenomics/incentives/src/state.rs:158, the rewards are added to the orphaned rewards if there are no liquidity token stakers. An edge case scenario is that if there are no liquidity tokens staked after the reward ends, the global index will remain zero when added into FINISHED_REWARD_INDEXES, and the orphaned rewards will be stuck in the contract. We classify this issue as minor because users are expected to be incentivized to stake their liquidity tokens for rewards.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Malicious liquidity tokens can bypass factory contract registration validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "In the contracts/tokenomics/incentives/src/utils.rs:379, is_pool_registered function compares the pair contract address queried from the factory contract (factory::QueryMsg::Pair) to match the pair contract address queried from the liquidity token (PairQueryMsg::Pair). This is used to ensure the liquidity token is not forged and originates from a pair contract instantiated by Astroports factory contract. However, this validation can be bypassed by creating a malicious CW20 token that returns PairInfo.contract_addr as a legitimate pair contract address registered in the factory contract. This is because the validation relies on a response returned by the untrusted contract, which can be manipulated. Consequently, the liquidity token validation in deposit, setup_pools, and incentivize functions can be bypassed, allowing untrusted liquidity tokens to receive reward distributions.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Typographic error in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "spelling error. In packages/astroport/src/incentives.rs:27, insentivization_fee_info should be spelled as incentivization_fee_info. It is there is a best practice to resolve variable name spelling errors to improve the readability of the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Lack of duplicate validation when updating blocked pool tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "update_blocked_pool_tokens in The packages/astroport/src/execute.rs:398 does not validate if there are duplicates between the add and the remove input vectors. Given that the remove operation is done rst in lines 414-425 followed by the add operation, in case an asset is present in both, it will end up being added to BLOCKED_TOKENS without further warning. function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Error message diers from implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "In packages/astroport/src/incentives.rs:52-55, the number of periods of a schedule is validated. The if statement allows that input.duration_periods == MAX_PERIODS; however, the error message states, Duration must be more 0 and less than {MAX_PERIODS}, which diers from the implementation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. New pools can have zero allocation points",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-01-11 Audit Report - Astroport Incentives v1.0.pdf",
        "body": "The in contracts/tokenomics/incentives/src/execute.rs:241 allows allocating zero setup_pools function alloc_points to any given pool. This will result in the pool not receiving any ASTRO rewards.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Anyone can whitelist a new vAMM or overwrite an existing one",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "contracts/factory/src/contract.rs:45, In executing ExecuteMsg::Whitelist message, there is no check on the senders address of the transaction to ensure that it is contained in the admins list. when This may lead to three malicious behaviors:  Anyone can instantiate and whitelist a new vAMM on behalf of admins passing arbitrary parameters.  As vAMMs are indexed in the VAMM_ADDRS Map with the stringication of currency_pair as the key, anyone can overwrite an existing vAMM address mapping with a new one with arbitrary parameters.  Using the DelTranche in contracts/risk-fund/src/contract.rs:86, maliciously registered vAMMs can drain the risk fund completely.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Risk fund is not able to partially disburse creditors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/risk-fund/src/state/tranche.rs:366, when disbursing from the risk fund, the execution tries to take all possible funds from tranches in order to pay the creditor. If there aren't enough funds, it will return an error causing creditors to not get funds, not even partially based on the availability.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. saveSwapInstruction can be executed by anyone with arbitrary values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/risk-fund/src/contract.rs:73, there isnt any check on the message sender role when executing a saveSwapInstruction message. As this message is used to save and update the Astroport swap pair contract address for a specic pair, the execution of it should be restricted to admins only. In fact, a malicious actor could overwrite a legit Astroport swap pair address to a malicious one. Such a malicious pair could receive UST, emit appropriate events, but not actually return another asset. This is also possible because ReplyKind::AstroportSwapUst parses the asset information from the returned event.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. assert_admin might run out of gas and contract-specic admins might lead to inconsistency and misconguration risks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/factory/src/state/admin.rs:13, iterations over ADMIN_ADDRS may run out of gas if the vector has too many entries. Because admins cannot be removed there is currently no way to recover from this issue (see issue 11). Additionally, dierent contracts, e.g. the vAMMs, and the vault, might all contain distinct lists of admins, which the factory, introduces the risk of misconguration.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Risk fund is not aware of the fees sent from the vault",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/vamm/src/contract.rs:98, contracts/vamm/src/state/liquidation.rs:309 and 314, the vAMM is sending a message to the vault VammMsg::SendFunds. in order to send collected fees to the risk fund using The execution of this message is sending funds to the risk fund through a BankMsg::Send but its not directly triggering a mechanism to collect fees. This may lead to the contract not being aware of the collected fees and to capital ineciency of fees that are already in the risk fund but are not in tranches.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. is_vamm_addr might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/factory/src/state/address.rs, the is_vamm_addr function has an asymptotic cost of O(n) and can make the message run out of gas depending on the length of VAMM_ADDRS and the to_check parameter position in the array. This can happen when calling QueryMsg::IsVamm from the risk funds can_disburse function. Since any user can add vAMMs (see issue 1), an attacker can exploit this vulnerability to deny the expected functionality.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Prices collected from oracle are inverted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "During liquidation, the current price is calculated as UST/asset, in the same way as it is calculated in or contracts/vamm/src/state/market.rs:112-119. spot_price mark_price for As prices returned from Chainlink are represented as asset/UST and they use a dierent method respecting mark_price,  calculations between those two values are inconsistent.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. CollectFee message execution might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/risk-fund/src/contract.rs:62, under certain circumstances, the execution of the CollectFee message can consume a big amount of gas and in the worst case can run out of gas. Consider as an example the scenario that the UST tranche is almost full. 1. Alice sends a CollectFee message. 2. The execution will call the collect_fee function and will ll the UST vault with UST in the msg funds. 3. Now, assume that this will not consume all the funds in the msg. The execution will call recursively collect_fee in order to ll the second tranche. 4. This will cause an interaction with Astroport, we need 2 queries to correctly create the message and then send it. 5. Astroport contract execution returns a reply. 6. Contract uses the reply to update the tranche state. 7. If there still are some funds in the msg, the execution will call another time the collect_fee function. 8. Here we can potentially loop several times until the execution will ll all the tranches or user funds sent in the message will be depleted. This issue is not unlikely to happen if the UST tranche is almost full.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Risk fund can be drained completely due to unpriced vega risk, if highly volatile assets are listed or volatility conditions change",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "Suppose that an asset faces above normal volatility conditions and suppose that an attacker creates two large and maximum leveraged positions with two distinct wallets one short (A) one long (B) such that the expected sum of the payout of the two positions is A+B-fees, and the expected value of A+B is E(A+B) = 0. If the market volatility is large enough to assure that the collateral of one position will not be enough to cover its losses, an exploiter can create a series of payments to drain all funds from the risk fund. In layman's terms this is because the losses of the losing position are limited (since bad debt doesnt exist) and the earnings of the winning position are not capped but are paid out entirely until the risk fund is empty. Because such an attack requires sound nancial engineering and is only possible during adverse market conditions of a given asset, we do not consider this to be a major issue. However, this attack vector also highlights another important vulnerability of the protocol. Because very risky/volatile assets are covered by the same tranches of the risk fund as less risky assets, less risky positions might lose their risk fund coverage from adverse events in the more risky segment. Especially for risk averse users that use the protocol for hedging purposes, this might be an undesired property.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Extensive admin permissions go against best practice",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "It is best practice to restrict admin permissions to actions that do not directly allow access to or could create a loss of user funds. Under the current architecture, admins have several such permissions: 1. 2. contracts/vamm/src/contract.rs:224, using In ExecuteAdminMsg::ForceMarketPrice, the market price can be set to arbitrary values putting users' funds at risk of liquidation. In contracts/vault/src/contract.rs:67, any address can be added as a new vAMMs address using ExecuteMsg::InsertVamm, which then can drain funds from the vault completely via VammMsg::SendFunds. 3. In contracts/vamm/src/state/config.rs:69-111, updated such that: the config can be a. Only full liquidations take place, via updates of config.liquidation_total_ratio. b. The likelihood of liquidations increases drastically, via updates of config.mark_price_divergence. c. Liquidation rewards are sent fully to the liquidating address, via updates of config.liquidation_reward_split. 4. 5. In contracts/risk-fund/src/contract.rs:86, DelTranche can be called by admins and vAMMs. It sends the funds to the sender. In contracts/risk-fund/src/contract.rs:35, it is possible to add a new admin but not possibility to remove an admin. This makes it impossible to stop malicious admins. This issue is especially problematic due to the smart contracts support of multiple admin accounts  administering these requires o-chain maintenance, which is prone to human error.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "11. bigint crate is aected by CVE-2020-35880",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "a In rust/utils/Cargo.toml:17 of the levana-common repository, bigint is specied in as https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35880 and https://rustsec.org/advisories/RUSTSEC-2020-0025.html that crate is aected by a Critical CVE with a score of 9.8. dependency. reported As The crate is not maintained anymore and contains several known bugs (including a soundness bug).",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Address provider does not validate addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/address-provider/src/contract.rs:44, ExecuteMsg::Change function handler execute_change takes a to parameter of type Addr. This may cause an unvalidated address to be stored.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. vAMMs conguration parameters are not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/vamm/src/state/config.rs:69, the update_config function which is called when initializing and updating config lacks validation on conguration parameters before saving them. As some of them are intended to be in a specic range and used in math operations, this may lead to inconsistency and execution errors caused by division by zero or assigning negative values to unsigned integers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Admins can insert unvalidated vAMM addresses in the vault",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/vault/src/contract.rs:70, insert_vamms allows adding a new vAMM address in the VAMM_ADDRS array without validation. This may cause inconsistencies in VAMM_ADDRS.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Some possible values of vbase_liquidity can make vAMM unusable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "contracts/vamm/src/state/markets.rs:158, In using vbase_liquidity taken from the InstantiateMsg to initialize quote, base and k of the curve. init_curve is As there is no validation for vbase_liquidity, a value of this parameter equals to or less than 0 can make the vAMM unusable as this will cause:  Case vbase_liquidity == 0: quote, base and k all with zero value  Case vbase_liquidity < 0: quote and base with a negative value",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Its not possible to change the admin of the address provider contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/address-provider/src/contract.rs, the admin cw_controller is registering the contract admin address in the instantiate message. After that, its not possible for the admin to change its address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Its not possible to add or remove admins in Factory, Spot Price, vAMM and Risk Fund contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In Factory, Spot Price, vAMM and Risk Fund contracts instantiate function, the list of admins is taken from the InstantiateMsg message. the instantiation, After its not possible for admins to be added or removed. This is problematic since a compromised admin address cannot be removed or replaced with a new one.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Lack of validation of AddTranche cong values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/risk-fund/src/contract.rs:80 when executing the AddTranche message, values in the cong object are not validated. This can lead to a not working tranche registered in the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Iterations over tranches might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "the In contracts/risk-fund/src/state/tranche.rs:59-73, tranches might run out of gas, if too many tranches exist. As this can happen only through admin error and is recoverable, we classify this as a minor issue. iterations over",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Proposals tally returns wrong vote results",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In neutron:x/gov/keeper/tally.go:79-81, when calculating the result of a governance proposal, the execution is not accounting for NoWithVeto votes. The current implementation returns a failed proposal result if the following inequation is true:     .   It is evident that NoWithVeto votes are not counted and treated as Yes votes in the example in Appendix 1. This implies that proposals that should fail will be unintendedly successful.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. An error triggered during the handling of an Ack IBC message will make the channel unusable and spam the network",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "Neutron uses ORDERED channels, which means that there is a sequencer that keeps track of the currently waiting Ack message. is in handled in This message https://github.com/cosmos/ibc-go/blob/77c10be63204a52ec53b1e8ef91a76bae140d5ed/mod ules/core/keeper/msg_server.go#L588-L647 that incrementing the responsible for the IBCModules HandleAcknowledgement method NextSequenceAck and call dened in neutron:x/interchaintxs/keeper/ibc_handlers.go:16-47. Acknowledgement function dened the is it returns an error, If incremented. This could happen for various reasons: the execution will revert and NextSequenceAck will not be  Sudo handlers in the smart contract return an error because of a bug or an invalid input data  Sudo handlers are not dened in the smart contract This implies that the channel will be unusable and that the relayer will continue sending the same failing Ack message. Also, an attacker could use a signicant amount of deployed smart contracts and transactions with failing Sudo handlers in order to let relayers spam the network with Ack messages and trigger the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. This can prevent that node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. IBC events loop in Sudo handler could drain relayers funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "A malicious hacker could develop a CosmWasm smart contract that implements an IBC events loop in the Sudo handler. For example a contract that in the Response Sudo handler, executes another transaction that will trigger the same Response handler and so on. Since there is not an aggregate gas counter for all the dierent transactions of the IBC events ow that could break the loop with an out of gas error, the execution can run until all the relayers funds are drained. Also, this behavior could be used to congest and slow down the chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Attackers are able to spam the network with IBC messages using the ibc-transfer module",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In  neutron:internal/sudo/sudo.go:100-103,  neutron:internal/sudo/sudo.go:132-135, and  neutron:internal/sudo/sudo.go:166-169, the execution is checking that the received Acknowledgement or Timeout Packet is related to an IBC transaction originated from an existing CosmWasm smart contract address and returning an error otherwise. Since it is possible to send an ibc-transfer modules transfer transaction also from a non contract address, for example using the neutrond CLI, with the following command: neutrond tx ibc-transfer transfer an attacker could send a big number of small value transfer messages in order to spam the network with Acknowledgement packets and let them fail in the guard implemented in the mentioned lines. A huge number of such messages could congest nodes and make them unable to process blocks before the BroadcastTxCommit timeout. Also, the NewTxTimeoutHeightDecorator will discard all messages with an elapsed heightTimeout, which could be used in a particular event in order to manipulate it. This can prevent that node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Unbounded iteration in ValidateBasic may cause node timeout",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "ValidateBasic The in x/interchainqueries/types/tx.go:73-100 includes an unbounded iteration that may be exploited to cause a node timeout. MsgRegisterInterchainQuery function for The function loops over TransactionsFilter, a caller-supplied slice that is not checked for duplicate entries and does not have a dened size upper-bound. It is best practice to keep ValidateBasic logic simple as gas is not charged when it is executed. It should only perform all necessary stateless checks to enable middleware operations (for example, parsing the required signer accounts to validate a signature by a middleware) without impacting performance in the CheckTx phase. Other validation operations must be performed when handling a message in a modules MsgServer.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Unbounded iteration in PerformSubmitTx could be used by an attacker to slow down or halt the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In neutron:wasmbinding/message_plugin.go:204, SubmitTx is performing an unbounded iteration over submitTx.Msgs. An attacker could craft a message with a signicant number of Msgs with the intention of spamming the the block production time triggering the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. and impact network This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Unbounded iteration in EndBlocker when calculating vote power could be used by an attacker to slow down or halt the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In neutron:x/gov/keeper/voting.go:40-51, in order to calculate voting powers, the EndBlocker is running an unbounded iteration over a slice containing all voting user votes. An attacker could use a signicant number of addresses with a small amount of tokens in order to grow the slice length and impact the block production time, eventually triggering the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Attackers could steal funds from the ibc-transfer contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "neutron-contracts:contracts/ibc_transfer/src/contract.rs:43, In execute_send is called in order to complete an IBC-20 transaction from source chain to sink chain, but this function does not verify that there are sucient funds in the contract to support an IBC transfer. Because the execute_send function lacks an authorization check, an attacker can frontrun the legit user and steal funds by sending them from the contract to its own address on the sink chain. We classify this issue as major instead of critical since the ibc-transfer contract is meant to be an example.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Fee struct could be simplied to avoid manipulations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In neutron:proto/feerefunder/fee.proto:17, Fees denition includes Coins as an attribute in order to track users and relayers payments. The checkFees function dened in neutron:x/feerefunder/keeper/keeper.go:169 ensures that the user pays the right amount, checking that coins are over a threshold. However, theres no validation for the denom. This can be abused, and only one coin with almost no value could be used to pass the validation checks.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Unbounded messages loop could run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In neutron-contracts:contracts/neutron_interchain_queries/src/contrac t.rs:312, tx_body.messages to lter out the required transaction. the recipient_deposits_from_tx_body function iterates over the However, because the number of messages is unknown, this could lead to an unbounded loop execution, which could cause an out-of-gas error. This implies that the smart contract may never be able to consume the supplied dataset corresponding to the query. Even though this is a major issue, we classify it as minor since the aected contract is only an example contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Contracts are not compliant with CW2 migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "The following contracts do not adhere to the CW2 migration specication:  neutron-contracts:contracts/reflect,  neutron-contracts:contracts/neutron_interchain_txs,  neutron-contracts:contracts/neutron_interchain_queries, and  neutron-contracts:contracts/ibc-transfer. This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. The new owner account claims ownership, which applies the conguration changes. Status: Resolved 35. Misleading error message while trying to send and repay at the same time",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Membrane/2023-06-15 Audit Report - Membrane v1.0.pdf",
        "body": "The mint_revenue function in contracts/cdp/src/position.rs:1639 performs a check to prevent the two optional variables send_to and repay_for being specied simultaneously or not specied at all. if True, However, \"Destination address is required\". specied, the error message is wrong. the error message informs about the second scenario only, that is, If both send_to and repay_for are",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Duplicate member addresses inate the total weight value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "the contract instantiation in phase During contracts/cw4-voting/src/contract.rs:32-37, the msg.initial_members vector that contains the Member struct address and weight is not validated to make sure the If a duplicate member address is member address is unique across the whole contract. provided, the associated address and weight would be overwritten by the USER_WEIGHTS storage state, as seen in line 35. However, the total weight value in line 36 would still include the nonexisting member weight. This would impact voting outcomes. A test case demonstrating the above scenario can be found in appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Duplicate item name causes ghost contracts to be instantiated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "In contracts/cw-core/src/contract.rs:83, the msg.initial_items parameter that contains the InitialItem vector is not validated to have unique item names. Having two or more items with the same name would cause them to be instantiated as ghost contracts because eventually, the item name with the highest reply id would be used, as seen in line 746. As a result, this causes ineciencies in the contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Lack of delay when executing proposals makes contracts prone to governance attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "In contracts/cw-proposal-single/src/contract.rs:217, there are no time delays when executing passed proposals. An attacker with enough capital can potentially stake many tokens to gain high voting power, create a malicious proposal and then vote for it. Since proposals can pass early as long as the voting threshold is reached (see contracts/cw-proposal-single/src/proposal.rs:112-114) a passed malicious proposal without giving the community enough time to discuss and block the governance attack. As a result, the attacker's governance attack would succeed, causing potentially catastrophic damage to the protocol. This is especially problematic if the contracts hold non-native tokens, which may have a higher value than the cost of the attack. execute to",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Consider checking whether the item key exists before removing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "In contracts/cw-core/src/contract.rs:420-434, any provided key as an argument will be removed from the ITEMS storage state as seen in line 430. Since the remove storage function will not dierentiate whether the key exists or not, it is possible to remove a key that never existed in the storage.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Admin withdrawals will aect the reward distribution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "execute_withdraw The in contracts/stake-cw20-reward-distributor/src/contract.rs:185 allows the the contract without an option for a partial admin to withdraw the entire balance of withdrawal. function After the admin withdraws funds using a Withdraw message, the contract will have empty funds, which causes the minimum comparison in line 156 to result in a zero amount. This implies that the Distribute message would pay zero rewards to the staking address for the whole staked duration. The staking address would need to wait some time for the pending rewards to recover to the intended value to receive another set of staking rewards. We consider this to be a minor issue since only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Reward duration should be validated as non-zero value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "contracts/stake-cw20-external-rewards/src/contract.rs:65, In msg.reward_duration represents the reward duration value which is used to calculate the reward rate. If the reward duration value provided is 0, it would cause a division by zero error in line 174 during the execute_fund functionality, causing the contract to be unable to be funded. We consider this to be a minor issue since only the contract owner can cause it. Even if it happens, the problem can be resolved by updating the reward duration to a non-zero value via the UpdateRewardDuration message.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Maximum number of items is not sucient to prevent out of gas error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "MAX_ITEM_INSTANTIATIONS_ON_INSTANTIATE The in contracts/cw-core/src/contract.rs:84 is not sucient as it will allow for such a large number of items that the proceeding instantiation loop will run out of gas well before the limit is met. The maximum should be set to a more conservative value rather than u64::MAX - 100. validation",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. execute_pause does not enforce maximum pause duration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "The execute_pause function in contracts/cw-core/src/contract.rs:173 does not enforce a maximum pause duration. The value of pause_duration is added to the current block time and then saved to PAUSED with no checks or validation. This is problematic because if the value is accidentally set to a very high value, it will eectively render the contract useless, without a way to recover. Another potential scenario is that the duration is sent as a Height rather than a Time, which may result in the contract being paused for longer than anticipated.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Incomplete threshold validation in staked balance voting contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "In contracts/cw20-staked-balance-voting/src/contract.rs:84, ActiveThreshold::Percentage is only validated to be smaller than 100%, but not validated to be larger than 0%. Zero values may cause undesired voting outcomes.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Admin rights go against best practices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "It is best practice to restrict admin permissions to actions that do not directly allow access to or could create a loss of user funds. In contracts/cw-core/src/contract.rs:194, the contract admin can run any message, introducing a centralization risk and a single point of failure if the admin keys are lost or compromised. In other reports, centralization risks have been agged with higher severity. In this case, we interpret the admin as a parent DAO which mitigates the centralization risk.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Voting module design is prone to conguration risk",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "The core contract and the voting module are closely interlinked. Because the voting module has only one interface (i.e. to the core contract), updating the voting module introduces an additional point of failure and a conguration risk (e.g. that a proposal module is congured as the voting module) without many benets that come from the modular design. Because this issue is based on a design choice the severity is informational.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Additional funds sent to the contract are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "In contracts/stake-cw20-external-rewards/src/contract.rs:143-153, a check is performed that ensures that in the transaction there is a Coin with the expected denom eld. This validation does not ensure that no other native tokens are sent though, and any additional native tokens are not returned to the user, so they will be stuck in the contract forever.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Voting thresholds can be set to unusual values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "packages/voting/src/threshold.rs:73-80, In set PercentageThreshold such that a majority can be achieved under very unusual conditions (e.g. if 1% are in favor and 99% percent are against a proposal). While this allows possible to is it for innovative forms of governance, it is prone to user error which may lead to devastating consequences.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. check_ownable is incorrectly implemented which allows attackers to list any tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf",
        "body": "In cw-std:sellable/src/execute.rs:40 and 263, the check_ownable validation function returns Ok in all conditions, even if the caller is not the owner of the NFT token. This means that a malicious actor is able to bypass validation measures, allowing them to list any NFT tokens at an extremely low price and subsequently purchase them.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Anyone can lock any token_id",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf",
        "body": "The redeem_item function in cw-std:redeemable/src/execute.rs:11 lacks an authorization check to validate whether the sender is the token_id owner or the contract owner. This allows anyone to lock any token_id in self.locked_items.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Anyone can halt any ongoing sale",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf",
        "body": "The halt_sale function in cw-std:sales/src/execute.rs:59 is permissionless. This means that any user can halt any ongoing sale. Attackers can take advantage of this to strategically halt sales or to grief users.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. buy_item will error when users supply the correct amount and denom",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf",
        "body": "The buy_item function in cw-std:sales/src/execute.rs:91 contains a condition that will cause the function to error when the correct denom and amount are sent. There are a number of issues with the funds validation in this function. First, the condition in line 91 is actually inverted, it will currently return a WrongFundError when the correct funds are sent. This will eectively prevent any user who is correctly supplying funds from buying the item. Next, the sale.price.contains validation is incorrectly used. The contains method on a vector of coins will actually only return true for a complete match of funds. This means that it will only return true if both the denom and amount are equal. these issues will The combination of in a situation where users will receive a WrongFundError when they are correctly passing a valid BuyItem message. Additionally, in the current implementation, transactions that supply the wrong denom will actually pass the validation and cause a panic in line 98. result",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Owner can be set to an invalid address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf",
        "body": "The ownable contracts SetOwner message in cw-std:ownable/src/lib.rs:106 does not validate that msg.owner is a valid address. This is problematic because the Addr type always must contain valid addresses. Addr is intended to only be used in code after it has undergone validation. In this instance, if the address is ever set to an invalid address, the owner value of the contract will no longer be updatable as there is an authorization check where the caller is checked and info.sender will never match the invalid address.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Primary sales can be incorrectly congured",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2023-09-22 Audit Report - XION and Burnt Contracts v1.1.pdf",
        "body": "msg.start_time, The add_primary_sales function in cw-std:sales/src/execute.rs:47 will allow for overlapping primary sales to be introduced during the instantiation. While the function validates The add_primary_sales function operates with the assumption that sales are non-overlapping and have valid durations with regard to their start and end times. If the contract is improperly instantiated, then the function would also fail to prevent additional overlapping sales from being introduced when the PrimarySale message is received. msg.end_time. validate does not it",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Users will receive incorrect amount of LP tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "execute_balancing_provide_liquidity The in osmosis-liquidity-helper/src/contract.rs:78 allows users to provide either a single asset or a pair of assets to a pool. In the case that a user provides multiple assets, the contract rst performs a double-sided liquidity provision followed by a single-sided provision for any left over assets. function the LP tokens minted during the double sided liquidity provision are never However, transferred to the recipient. The LP tokens received from the initial liquidity provision that will be returned in response to the message in line 122 will never get recorded because the ReturnLpTokens callback was not called with the contracts initial lp_token_balance. The result will be that the caller will only receive LP tokens for the second liquidity provision.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Balanced liquidity provision into constant product pool will fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "When a user performs a balanced liquidity provision into a constant product pool in astroport-liquidity-helper/src/contract.rs:90, the contract rst swaps any tokens to ensure the ratio remains constant and then supplies the tokens into the pool. Subsequently, the contract returns the received LP tokens to the recipient using the callback function ReturnLpTokens. During execution of each message the contract will transfer the recently minted LP tokens from itself in astroport-liquidity-helper/src/contract.rs:185-190 and then again in 250-255. the callback function is called twice, rst to the recipient. However, The ReturnLpTokens callback that is dened in lines 185-190 will be executed before the liquidity is provisioned and the contract's balance changes. This will cause return_amount in line 274 to be 0. When the function attempts to transfer a zero amount the CW20 transfer return an error and revert function will execute_balancing_provide_liquidity function. the transaction. This will eectively block the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. No validation of min_out for double sided liquidity provision",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "When providing liquidity in the execute_balancing_provide_liquidity function in osmosis-liquidity-helper/src/contract.rs:78, users are able to specify the min_out value which denes the minimum amount of LP tokens they want to receive when providing liquidity. In the case that a user provides multiple assets to a pool, the amount of LP tokens minted is never checked to ensure it is greater than the value min_out. This means users may in fact receive fewer LP tokens than expected.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Insucient validation of swap paths",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "In function update_path in cw-dex-router/src/contract.rs:231-249, the contract admin is able to add swap paths to enable the liquidation of tokens that both do and do not share a direct pool. Currently, the contract validates that the rst and last assets match the oer and ask assets. In the case that there are swap operations performed there may be a situation where intermediary assets do not match. This would cause the failure of any execution of the function basket_liquidate. We consider this a minor issue as the admin controls the addition of swap paths.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Insucient validation of vault conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "When instantiating and updating the cong of a vault, the function check is called in which apollo-vaults/packages/apollo-vault/src/state.rs87-110 than it insuciently Decimal::one(). the performance_fee to ensure that validates less is Specifying a performance fee of greater than Decimal::one() would cause an overow in apollo-vaults/packages/apollo-vault/src/state.rs:94. Additionally, reward_liquidation_target is not enforced to be one of the assets in the pool as specied in lines 32-34, which could potentially cause inconsistencies in the overall behavior of the vault.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Basket liquidation fails if no path is found for oer asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "the basket_liquidate function In cw-dex-router/src/contract.rs:251-305, swaps all oer assets into a single receive asset. The swap paths that are used to exchange the oer for the receive asset are dened by the contract admin. In the case that one of the oer assets does not have a path set to the receive asset the throw an error in cw-dex-router/src/contract.rs:276. This would contract will prevent liquidation and the original calling function, execute_compound found in apollo-vault/src/execute_compound.rs, but also the primary function of the relevant vault. the execution of both the basket We consider this only a minor issue as the swap paths are dened by the contract admin.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Lack of Osmosis Vault parameter validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "The osmosis-vault contract from Apollo vaults instantiate function does not validate the submitted msg.pool_id before storing it. This might cause two dierent vaults to coexist with the same ID but dierent base and vault tokens, potentially confusing users. it In addition, is recommended to validate msg.lockup_duration to be within the expected range to avoid creating either a zero or an arbitrarily large lockup duration by mistake.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Use of magic numbers throughout the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "Throughout the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. Instances of magic numbers are listed below:  astroport-liquidity-helper/src/contract.rs:62  astroport-liquidity-helper/src/contract.rs:95  cw-dex/src/implementations/astroport/helpers:185-186",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Additional funds sent to the contract are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "In apollo-vaults/packages/apollo-vault/src/execute_staking.rs:46, a check is performed that ensures that in the transaction the desired native assets have been received. This validation does not ensure that no other native tokens are sent though, and any additional native tokens are not returned to the user, so they will be stuck in the contract forever.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. The on-chain entropy is generated by querying Terra for the swap result between LUNA and TerraUSD for the amount of block height plus the block time in seconds. Since the swap amount will increase monotonically by a relatively xed amount, and the exchange rate between LUNA and TerraUSD is expected to uctuate by a few percentage points only per block, the resulting value will have little entropy. Recommendation We recommend relying on a more robust source of randomness. Status: Acknowledged The Ink team states in their documentation that it plans to move to an Oracles VRF as the source of randomness in a future version. 10. Updating Anchor aUST and market contract addresses in Anchor strategy could lead to incorrect states",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Ink Protocol/2021-09-15 Ink - Audit Report.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Lack of denom validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "Upon instantiation, the transmuter contract creates a pool with multiple denoms through the TransmuterPool::new function. However, the supplied denoms are not eectively validated in contracts/transmuter/src/transmuter_pool/mod.rs:16-24. Incorrect denominations or an input typo would render some of the contracts features unusable, requiring a new instantiation and for the users to withdraw current deposits.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Missing validation steps when registering limiters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "The transmuter contract lacks validation on some of the functions related to limiters. Neither upper_limit nor boundary_offset undergo any validation when newly created in contracts/transmuter/src/limiter/limiters.rs:63-64 and 207-209 or when updated in lines 314 and 348. If a value of zero is provided, most trades will fail to satisfy the limiters restrictions, making some features unusable. On the other hand, if a large number is set, the contract could become rapidly imbalanced as described in the issue Lack of limiters could result in uncontrolled pool imbalance in The label eld is allowed to be empty upon registration of a new limiter contracts/transmuter/src/limiter/limiters.rs:287. Although not a security risk, it can be misleading and aect the user experience. Finally, when registering a new limiter the target denomination is not checked to be part of the current pool in contracts/transmuter/src/limiter/limiters.rs:286-288. This will render the limiter ineective in case of a mistake or a typo, leaving the intended denomination without any control against imbalance.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Unbounded loops could render main features unusable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "contract includes transmuter in The loop contracts/transmuter/src/limiter/limiters.rs:391-394. The outer initialization while the inner loop iterates through all denominations specied during pool iterates through all limiters registered by the admin. The size of both vectors can be arbitrarily decided by the admin. structure nested loop for a If any of these vectors is excessively large, it can signicantly inate the gas cost for swap operations, pool joins, or exits, potentially causing operations to revert. The risk escalates when both arrays are overly extended, due to the quadratic computational complexity. Although the comments in lines 365 and 378 state that the number of limiters is expected to be small, no actual mechanism is found to prevent the described scenario.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Zero-value swaps are allowed and introduce ineciencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "the SwapExactAmountIn and contracts/transmuter/src/sudo.rs SwapExactAmountOut messages which are used by the Pool Manager module of Osmosis to automatically execute swaps, including multi-hop swaps. denes These messages contain the token_in and token_out Coin elds. If any of the Coin elds have an amount eld set to zero, unnecessary swaps are performed. Unnecessary steps in a multi-hop swap could cause excessive gas costs for a user who might not be aware of the transmuter pool being used. For example, the SudoMsg::SwapExactAmountIn message triggers such a redundant swap when token_in is \"ABC\".to_string()) and to Coin::new(0, token_out_min_amount is set to Uint128::from(0). set Similarly, the SudoMsg::SwapExactAmountOut message will cause redundant swaps for any valid token_in_max_amount if token_out is set to a value such as Coin::new(0, \"XYZ\".to_string()). These messages can be sent from the Pool Manager module automatically as part of a bigger swap route. For example, redundant parameter combinations from the out-of-scope cosmwasmpool implementation could cause this issue.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Unoptimized zero amount burning or minting",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "swap_tokens_for_alloyed_asset and functions The swap_alloyed_asset_for_tokens, in contracts/transmuter/src/contract.rs:299 and 370, allow minting or burning of zero alloyed tokens. These scenarios arise from join_pool and exit_pool entry points when a user passes a Coin structure with an amount set to zero. dened Although the resulting submessage to x/bank module will fail, unnecessary computation and hence gas will be spent as both functions call check_limits_and_update which can be computationally intensive due to nested iterations inside.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Deregistering of non-existing limiters silently fails",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "In contracts/transmuter/src/contract.rs:187, during limiter deregistration, the in deregister contracts/transmuter/src/limiter/limiters.rs:290 is called. It performs removal operations over the vector without any prior validation, taking denom and label as parameters. The returned value of this operation is the same when an element is removed from the vector and when there is no match. declared function As a consequence, users will receive identical output for existing and non-existing (denom, label) pairs. This could lead to situations where limiters intended to be removed but containing a typo may still be in place after the admin tries to remove them.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Missing Division invariant check",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "In contracts/transmuter/src/division.rs, the Division structure is declared to carry two timestamps: started_at denoting the beginning of the span, and updated_at denoting the last modication time of the division's value. Line 49 enforces that updated_at is not before started_at. However, it does not enforce that updated_at is not after the division's end which is dened as started_at + division_size. This missing invariant check makes reasoning about divisions more dicult.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Admin transfer procedure can be enhanced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "contracts/transmuter/src/admin.rs implements a two-step admin transfer pattern following best practices, requiring the receiving side to accept ownership via the claim function. However, there is no dedicated API to cancel a proposed transfer. At present, the current contract admin can only cancel an unclaimed admin transfer by directing the privileges back to their own address, followed by claiming this mock transfer, which is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Redundant query function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "The transmuter contract in get_share_denom get_alloyed_denom in line 510. includes two queriable functions that are eectively identical: and contracts/transmuter/src/contract.rs:499 Although not a security issue, having redundant code is unnecessary and can decrease maintainability.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Lack of limiters could result in uncontrolled pool imbalance",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "The transmuter contract enforces a 1-1 relation between its pool assets. The limiter feature is in place to avoid swift liquidity imbalances happening when specic market conditions open arbitrage opportunities. However, there is no minimum amount of limiters required. Upon instantiation, no limiter is created, which could be intended to facilitate a fast initial liquidity provision. From that on, the lack of a limiter, or a malicious admin removing all the in limiters deregister_limiter function through the contracts/transmuter/src/contract.rs:120-190, open up unlimited arbitrage opportunities that may imbalance the pools to an undesirable level.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Lack of role-based access controls for the pausing mechanism",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "The codebase implements a pausing mechanism, which is in line with best practices. However, all of the administrative functions of the contract are centralized in the admin role, which goes against the principle of least privilege. Segregating the pauser role has the additional benet of swifter reactions in case of need when assigned to an EOA compared to the admin that might be managed by a multisig or a governance contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Default value conceals unexpected state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "In the contracts/transmuter/src/limiter/division.rs:310-316, compressed_moving_average function manages cases where result computation is infeasible. This arises when the time span in focus has a length of zero, occurring when block time matches the start time of the earliest division remaining post-pruning. However, such a division must not exist since the average is computed prior to the division set update. The function currently defaults to returning zero, masking a potential issue with division updates. While this is not a security concern, maintaining an accurate state aids in the early identication and resolution of any unexpected states.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Incorrect error message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "The transmuter contracts exit_pool function checks if the provided token_out coins are part of the pool. it raises an incorrect If one of the assets is not part of the pool, InsufficientPoolAsset error instead of InvalidPoolAssetDenom. Although not a security risk, incorrect or non-descriptive errors may mislead users.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Typographical error in attribute naming",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "The response for the transfer_admin entry point response carries attributes \"method\" and \"andidate\", dened in contracts/transmuter/src/contract.rs:777-779. Presumably, \"candidate\" was the intended name. logging, auditability, and Within CosmWasm, attributes play important interoperability. A typographical mistake might lead o-chain components or other modules to miss events. roles in event",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Unused error messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "In contracts/transmuter/src/error.rs, several error messages are dened but remain unused, specically:  InvalidPoolAssetDenom (see Incorrect error message)  FundsMismatchTokenIn",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Usage of panics for error handling",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "has been macro It contracts/transmuted/src/limiter/limiters.rs:154 for mechanism. expect noticed that the is used in the error handling The usage of expect is generally discouraged because it leads to panics without a developer-friendly error message. expect also causes the wasm execution to abort, which does not allow handling of the error from calling functions.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Usage of vulnerable dependencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-10-09 Audit Report - Osmosis Transmuter v1.0.pdf",
        "body": "It was found that vulnerabilities. As https://rustsec.org/advisories/RUSTSEC-2023-0052, crates are aected by issues of high impact. the codebase uses dependencies utilizing packages with known reported in https://rustsec.org/advisories/RUSTSEC-2022-0093 and the ed25519-dalek and webpki These vulnerabilities are not directly exploitable in a CosmWasm smart contract and do not aect any of the current code fragments. Therefore this issue has been raised with informational severity for completeness.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Corrupted assets may not be removed when liquidity reaches zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "The transmuter contracts specication states that corrupted assets should be removed from the contract when liquidity is zero. This is done when all the corrupted assets are redeemed at the same time in contracts/transmuter/src/swap.rs:267-276, but not in any other cases such as pool exits and transmutes during unchecked_exit_pool in and contracts/transmuter/src/transmuter_pool/exit_pool.rs:12-43 in update_pool_assets contracts/transmuter/src/transmuter_pool/transmute.rs:38-75. Note that the current implementation does not have any other way of removing corrupted assets from the pool.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Resetting change limiters creates an opportunity window for economic attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "In contracts/transmuter/src/contract.rs:225-228, the states of all change limiters are reset. This is done when new assets are added because weights are no longer correct and should be recalculated. However, change limiters implement protection from rapid market changes and pool imbalances. Removing them, even temporarily, creates an opportunity window for economic attacks. A malicious party capable of joining the pool with a large position can simply listen to the contracts on-chain events and deploy the attack as soon as new assets are added.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Incorrect spot price calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "spot_price in a The contracts/transmuter/src/contract.rs:673. This is incorrect as the assets in the pool can have dierent normalization factors, resulting in prices other than 1. Decimal:one() function returns value xed of We classify this issue as minor because the aected function does not impact the logic of the contract, as it is exclusively used in a query. However, note that it could have a severe impact on external contracts relying on this information. This issue was independently reported by the Osmosis team during the audit.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Outdated libraries with known vulnerabilities in use",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "The transmuter contract makes use of outdated libraries that contain known vulnerabilities. Although we did not nd these vulnerabilities to be exploitable in the current codebase, updates to the codebase may lead to security risks in the future. The following libraries are aected:  sylvia 0.7.0  Aected by RUSTSEC-2024-0012  cosmwasm-std 1.3.1  Aected by CWA-2024-002",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Alloyed asset normalization factor lacks validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "in The contracts/transmuter/src/alloyed_asset.rs:67-73 saves the normalization set_normalizaton_factor function factor for the alloyed asset. However, this value does not undergo any validation as opposed to the normalization factor of the pool assets. If, by mistake, a value of zero is assigned to the normalization factor of the alloyed asset the features that operate with the alloyed asset will error, making them unusable.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. ChangeLimiter missing validation upon update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "set_change_limiter_boundary_offset The in contracts/transmuter/src/limiter/limiters.rs:416-447 does not validate the boundary_offset value through ensure_boundary_offset_constrain before saving it. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Migration lacks validation steps",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "add_normalization_factor_to_pool_assets in The the contracts/transmuter/src/migrations/v3_0_0.rs:67-73 set_alloyed_asset_normalization_factor function in lines 113-121 save the normalization factor for the alloyed asset and the pool assets upon migration. However, these values do not undergo any validation. function and If a value of zero is mistakenly assigned to the assets' normalization factor, most of the main features would become unusable.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Adminship can be renounced, leading to inability to maintain the protocol",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "The transmuter contract in contracts/transmuter/src/contract.rs:776-785, which leaves the contract without any address holding admin privileges. implements a renounce_adminship entry point Given that several functions needed for the correct long-term operation of the contract are restricted to the admin address only, it will not be possible to maintain the protocol if the adminship is dropped at any point. We classify this issue as minor since it can only be caused by the admin, who is a trusted entity.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Outdated documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "The transmuter contract restricts access to its set_active_status function to moderator users only, following security best practices. However, the access control table in the repositorys README.md le incorrectly states that this function should be restricted to admin users only.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Instantiation without a moderator is allowed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "contracts/transmuter/src/contract.rs:81, In instantiation is parameterized by an optional address for the moderator. the transmuter contract The moderator role is responsible for pausing the contract if any security issue arises and marking assets as corrupt. There are other ways to pause the contract, either by governance or by the admin, but they are less straightforward and potentially slower to react. Specically, governance would need to pass the proposal, which takes time. On the other hand, the admin would need to grant itself moderator privileges rst, and this is one more step that can count in critical scenarios. As a consequence, the contract would ideally not allow a conguration with the moderator set to None.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Miscellaneous performance optimizations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "The codebase contains minor ineciencies that aect performance and hence gas costs:  In contracts/transmuter/src/transmuter_pool/add_new_assets.rs:9- 10, the assets vector is checked for duplicates rst, and then its length is checked for being below the limit. However, duplicate search is a more computationally intensive operation and should be performed after the more ecient length check.  In contracts/transmuter/src/transmuter_pool/corrupted_assets.rs: 91, the pool_assets vector is iterated to discover any corrupted assets. If such has not been found, the control ow prematurely returns. Then, in lines 97-101, the same vector is iterated again to lter corrupted assets and construct a HashMap. Redundant iteration could be avoided by performing the check between the ltering and creating the HashMap.  In contracts/transmuter/src/swap.rs:431, the code responsible for checking if token_out.denom diers from token_in.denom is not necessary as two lines later, during the execution of the swap_variant function, the same check is performed as well.  In contracts/transmuter/src/swap.rs:498, the code responsible for checking if token_out.denom diers from token_in.denom is not necessary, as two lines later, during the execution of the swap_variant function, the same check is performed as well.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Missing current status validation during updates may mislead users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "contracts/transmuter/src/contract.rs:456, the set_active_status In function, in sudo contracts/transmuter/src/sudo.rs:48, no validation ensures that the current and updated statuses are not equal. SetActive message well as as information will be emitted stating that the Consequently, even if these values are equal, status has been changed. This might be misleading and may even have a security impact on contract management during an incident.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Unused code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2024-05-15 Audit Report - Osmosis Transmuter v3 v1.0.pdf",
        "body": "The codebase contains unused code, which may indicate that the logic has changed or that assumptions do not match the current implementation. Instances of unused code have been found as follows:  SingleTokenExpected error in contracts/transmuter/src/error.rs:24  InvalidTokenInAmount in error contracts/transmuter/src/error.rs:80  UnexpectedDenom error in contracts/transmuter/src/error.rs:100",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Using non-prexed addresses in storage keys can lead to key collisions, allowing exploits to overwrite data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The key returned by the GetTokenizeShareRecordIdByOwnerAndIdKey function in x/staking/types/keys.go contains an address that length prexed. Since addresses could have variable lengths, key collisions are possible if the storage key contains a non-prexed address followed by another component. This could lead to accidental collisions and could be exploited by an attacker to deliberately overwrite existing data at a target storage location. is not",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Tokenization of a delegation and selling the shares allows evasion of slashes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "a is the in no delegation in When tokenized x/staking/keeper/msg_server.go, or Redelegation entry is created, but the current delegation is immediately unbonded and a new delegation the from the module TokenizeShareRecord. This implies that the previous delegator will not be subject to slashing for infractions that happened before the tokenization. Instead, slashes are now applied to the module address associated with the TokenizeShareRecord. UnbondingDelegationEntry TokenizeShares associated with function address created is Since Cosmos SDK applies slashes for past infractions to all currently bonded tokens, this is not an issue, as long as the previous delegator owns the created share tokens. The previous delegator might have an incentive though to sell share tokens quickly if they are aware of a pending slashing event. If there is information asymmetry between the share token holder and a potential buyer, a delegator can use this mechanism to evade slashing. An example of this could be a validator that equivocated but has not published the double-signed block. Rational buyers would therefore not buy any token shares before the UnbondingTime passed but not all buyers can be assumed to be rational. We consider this issue to be major, because it can be used to circumvent one of the fundamental features of proof of stake blockchains.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Withdrawal of tokenized share record rewards is unbounded, owner can be grieved by an attacker",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "WithdrawTokenizeShareRecordReward The in x/distribution/keeper/keeper.go contains an unbounded iteration over all TokenizeShareRecord of an owner, which may run out of gas if too many entries exist. This may happen unintentionally. function Even worse, since it is possible to transfer ownership of a record to any other address, an attacker can create many low-value TokenizeShareRecords and transfer ownership of them to relevant the TokenizeShareRecords to another account to resolve this issue, it allows the attacker to grieve the owner. owner. While transfer owner target target can a The same issue exists in the TokenizeShareRecordReward query function in x/distribution/keeper/grpc_query.go.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Several errors are not checked",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "In several places in the codebase, errors are not checked, and execution continues even if operations failed. This may cause an inconsistent state  a message handler may succeed and write changes to storage even though some operations failed. Instances of not checked errors are in: a) x/distribution/module.go:73: Error return value types.RegisterQueryHandlerClient is not checked b) x/distribution/module.go:146: Error return value cfg.RegisterMigration is not checked c) x/distribution/types/msg.go:183: sdk.AccAddressFromBech32 is not checked Error return value d) x/staking/genesis.go:43: Error return value keeper.SetValidatorByConsAddr is not checked e) x/staking/module.go:79: return types.RegisterQueryHandlerClient is not checked Error value of of of of of f) x/staking/module.go:143: Error return value of cfg.RegisterMigration is not checked g) x/distribution/types/msg.go:183: Error return value sdk.AccAddressFromBech32 is not checked h) x/staking/keeper/msg_server.go:100: k.SetValidatorByConsAddr is not checked i) x/staking/keeper/msg_server.go:457: k.ValidateUnbondAmount is not checked j) x/staking/keeper/msg_server.go:477: k.AddTokenizeShareRecord is not checked k) x/staking/keeper/msg_server.go:550: k.DeleteTokenizeShareRecord is not checked m) x/staking/types/msg.go:380: l) x/staking/keeper/msg_server.go:598: sdk.AccAddressFromBech32 is not checked Error sdk.AccAddressFromBech32 is not checked Error sdk.AccAddressFromBech32 is not checked n) x/staking/types/msg.go:414: Error return value Error return value Error return value Error return value Error return value return value return value of of of of of of of of o) x/staking/types/msg.go:442: Error sdk.AccAddressFromBech32 is not checked return value of p) x/slashing/genesis.go:19: Error return value of keeper.AddPubkey is not checked q) x/slashing/module.go:81: Error return value of types.RegisterQueryHandlerClient is not checked r) x/slashing/module.go:144: Error return value of cfg.RegisterMigration is not checked s) x/slashing/keeper/hooks.go:35: Error return value of k.AddPubkey is not checked t) x/slashing/keeper/hooks.go:69: Error return value of h.k.AfterValidatorCreated is not checked",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Tokenize share record reward query does not include automatically withdrawn rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "TokenizeShareRecordReward The x/distribution/keeper/grpc_query.go does withdrawn rewards that have been sent to the TokenizeShareRecords module account. in automatically query not function account for",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Share token denoms may be all lower- or all upper-cased, depending on user input",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The getShareTokenDenom function in x/staking/keeper/msg_server.go creates the denom for new share tokens through concatenation of the user-supplied validator address and a unique ID. The validator address is taken without transformations from the users input. Since Bech32 addresses are valid in either all upper or all lower case, there can be two valid denoms for the same share tokens. While this has not been found to cause any security issues in the current implementation, it may create problems for applications integrating with this module or lead to issues when further logic is added in the future.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Usage of panics for control ow is bad practice",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "In several places in the codebase, panics are used for control ow. While this is no security issue since transactions recover from panics in Cosmos SDK, this may lead to problems in the future. For example, a caller of keeper functions may try to handle errors, while the function panics instead. Instances of panic usage for control ow can be found in: a) x/distribution/keeper/allocation.go:33 b) x/distribution/keeper/delegation.go:35, 40, 48 and 127 c) x/distribution/keeper/hooks.go:50 and 97 d) x/distribution/keeper/invariants.go:87 e) x/distribution/keeper/keeper.go:38 f) x/distribution/keeper/store.go:51 and 70 g) x/distribution/keeper/validator.go:70, 80 and 92 h) x/distribution/types/keys.go:65, 79, 94, 108, 122 and 136 i) x/distribution/types/msg.go:35, 72, 107 and 146 j) x/slashing/keeper/infractions.go:19 and 25 k) x/slashing/keeper/signing_info.go:109, 121 and 125 l) x/slashing/types/msg.go:28 m) x/staking/keeper/alias_functions.go:68 n) x/staking/keeper/delegation.go:96, 108, 202, 208, 219, 225, 400, 407, 411, 459, 464, 468, 574, 582, 593, 614 and 717 o) x/staking/keeper/invariants.go:63 and 106 p) x/staking/keeper/keeper.go:42, 46 and 67 q) x/staking/keeper/pool.go:23 and 31 r) x/staking/keeper/querier.go:493, 497 and 502 s) x/staking/keeper/query_utils.go:26, 47, 112 and 116 t) x/staking/keeper/slash.go:29, 54, 70, 128, 132, 135, 208, 251, 256, 259, 271, 276, 287, 292 and 296 u) x/staking/keeper/val_state_change.go:30, 41, 45, 67, 71, 75, 139, 165, 233, 241, 249, 258, 267, 278 and 319 v) x/staking/keeper/validator.go:29, 50, 158, 162, 167, 316, 414, 427, 431 and 435 w) x/staking/types/authz.go:44 x) x/staking/types/delegation.go:51, 66, 73, 151 and 246 y) x/staking/types/historical_info.go:33 z) x/staking/types/keys.go:96 aa) x/staking/types/msg.go:75, 80, 179, 236, 290 and 345 bb) cc) x/staking/types/validator.go:154, 262, 276, 381, 396, 400, 426 and 466 x/staking/types/params.go:94",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Addresses are not properly validated, which may cause panics and unexpected behavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "This validation. The ValidateBasic method, in x/distribution/types/msg.go:47, includes basic address the DelegatorAddress or the WithdrawAddress provided is empty, but does not validate whether if msg.DelegatorAddress=' ', this check would not return an error, producing further panics and expected behavior. is a correctly formatted Bech32 string. As an example, validation only and raises the input checks error an if",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Dierent tokens for share records of the same validator can have dierent exchange rates after slashing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The staking module creates distinct TokenizeShareRecords whenever a user tokenizes a delegation. These share records have all unique denoms, and their tokens are not fungible with each other, even if the validator is the same. While this simplies the architecture of the module, it implies that the exchange rate between such records starts to diverge over time, specically when tokens are minted after slashing occured. The reason for this is that during the TokenizeShares function in x/staking/keeper/msg_server.go:454, shares are minted without considering the current exchange rate of previous share records. As an example, suppose 1000 ATOM are delegated, of which 500 ATOM are tokenized in record 1. There exist now 500 val...1 tokens. Now suppose a 10% slash happens, such that there are only 900 ATOM in the delegation, and the 500 val...1 tokens are only worth 450 ATOM. If now another 200 ATOM of the same delegation are tokenized in record 2, there will be 200 val...2 tokens. As a result: - - val...1 tokens have an exchange rate of 0.9 ATOM/val...1, while val...2 tokens have an exchange rate of 1 ATOM/val...2. This is not a direct security concern, but may confuse users and lead to problems if protocols built on top of the Liquidity Staking Cosmos SDK module do not consider these dierences properly.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Staking rewards are decoupled from share token holders",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The current architecture separates holders of a tokenized delegation and the recipient of rewards for that delegation. A holder of share record tokens is not eligible for any rewards, instead these rewards accumulate in one single account per tokenized share record. The reward recipient is specied as the TokenizedShareOwner in the TokenizeShares function. It can be transferred using the TransferTokenizeShareRecord function. While this is not a security concern, it may be unexpected that share record tokens do not contain eligibility for rewards.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Lack of event emission is bad practice",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "TokenizeShares, The TransferTokenizeShareRecord message handlers in x/staking/keeper/msg_server.go do currently not emit any events. The Unjail message handler in x/slashing/keeper/msg_server.go does emit an event, but does not include information about the action (unjailing). RedeemTokens and Emitting events is a best practice, since it allows o-chain subscribers/indexers to track events.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Tokenized share record related transactions and queries are only available via CLI, not REST",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "Transaction and query functionality for tokenized share records have been added to the CLI in x/distribution/client/cli/tx.go, x/distribution/client/cli/query.go, x/staking/client/cli/tx.go and x/staking/client/cli/query.go, but not to the x/distribution/client/rest/tx.go, x/distribution/client/rest/query.go, x/staking/client/rest/tx.go and x/staking/client/rest/query.go. interfaces REST in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Storing the Id in TokenizeShareRecord is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The TokenizeShareRecord contains the Id of the record. That is unnecessary since every lookup of the record implies that the ID is known, since its part of the key.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Storing the ShareTokenDenom in TokenizeShareRecord is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The TokenizeShareRecord contains the ShareTokenDenom of is unnecessary, since the ShareTokenDenom can be derived from the stored Validator and Id. the record. That",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Specication is outdated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The specication is outdated in several ways: a) x/staking/spec/01_state.md is missing an entry for 0x64 for LastTokenizeShareRecordIdKey. b) x/staking/spec/* still describes queues, which have been removeg from the module.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Unused code negatively impacts maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The code base contains unused code. Unused code increases the code size and hence inhibits maintainability. Instances of unused code are: a) The NewStakeAuthorization function in x/staking/types/authz.go. b) The AllInvariants function in x/distribution/keeper/invariants.go. c) The AllInvariants function in x/staking/keeper/invariants.go. d) The ValidatePowerReduction function in x/staking/types/params.go.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Users are unable to withdraw funds once admin deposited all funds in the Red Bank",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "on In the Lockdrop contract, users are able to withdraw funds as long as it's under the congured withdrawal timeline. The withdrawal function will decrease the contracts total locked UST amount based (contracts/lockdrop/src/contract.rs:395). Once the admin deposits all funds to the Red Bank via DepositUstInRedBank, the contracts total locked UST will be set to 0 (L791). Since it only accounts for the deposit timeline instead of the withdrawal timeline (L465-472), users will be unable to withdraw their locked funds even if the withdrawal window is still open. withdrawal user's the We set the severity to Major since the users funds are still recoverable after a certain timeline.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Malicious users can cheat lockup rewards without locking their funds if claim is enabled before withdrawal timeline",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "condition In the Lockdrop contract, users can execute ClaimRewardsAndUnlock to claim rewards in the enabled (contracts/lockdrop/src/contract.rs:686-688). Claims can only be enabled from the Auction contract via AddLiquidityToAstroportPool which accounts in deposit and itself the windows (contracts/auction/src/contract.rs:440-445). withdrawal contract Auction claims only that are for Since both Auction and Lockdrop contracts are independently initialized, theres a possibility that admin might enable claims during the deposit or withdrawal phase of Lockdrop contract. If this happens, a malicious user can potentially cheat the lockup rewards via an attack scenario below: 1. Execute DepositUst to deposit a large amount of funds into any lockup position 2. Claim ClaimRewardsAndUnlock executing rewards via with lockup_to_unlock_duration_option as None 3. contracts/lockdrop/src/contract.rs:703-715, enter In calculate_mars_incentives_for_lockup internal function. Notice that lockup_info.ust_locked variable will be used to calculate users position rewards via calculate_weight. code will 4. Due to the code logic that only updates users MARS rewards when its 0, user_info.total_mars_incentives will not be updated in the future (contracts/lockdrop/src/contract.rs:704). The malicious user will have a denite reward. 5. Execute WithdrawUst to remove all funds locked under that lockup position (funds that can be removed highly depends on window timeline). In L382, the corresponding locked UST amount will decrease, however, the users MARS rewards will still remain the same. We set the severity to minor since this will only be exploitable if the timeline is congured incorrectly/far between Lockdrop and Auction contract which will inuence the execution of EnableClaims.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Users that claimed airdrops will miss out on additional airdrops",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The current implementation of airdrop claims allows only one claim per user due to the the condition in contracts/airdrop/src/contract.rs:326. At contract owner has the ability to update Merkle roots in L198-200. Taken together, if a user was assigned additional airdrops, they would not be able to claim those additional airdrops. Even without an update, the current design does not allow a user to claim multiple airdrop leaves from the same Merkle tree. the same time,",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Missing validation on Cong parameters can lead to human errors and unexpected behavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The Auction, Lockdrop, and LP Staking contracts are missing validation checks in some of its Cong numerical values. For example, in contracts/auction/src/contract.rs:61, there is no check that msg.init_timestamp corresponds to a future value (i.e. msg.init_timestamp>= env.block.time). in lockdrop/src/contract.rs:45. validation Lockdrop contract present This the in is example An contracts/lp_staking/src/contract.rs:37-39, init_timestamp + cycle_duration <= till_timestamp. Staking the LP in contract in there is no validation that that is Examples of missing validation checks in the Lockdrop contract are:  No validation that there are repeated values in msg.lockup_durations in line 67  No check that msg.seconds_per_duration_unit is non-zero. Examples of missing validation checks in the Auction contract are:  No check that config.mars_vesting_duration is non-zero, which would cause division by zero error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing MARS rewards validation may cause auction participants to lose their deserved rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In the Auction contract, anyone can deposit MARS to increase the overall reward for users via If no one deposited any MARS token rewards before the IncreaseMarsIncentives. is not possible to continue admin executed AddLiquidityToAstroportPool, depositing minted tokens (contracts/auction/src/contract.rs:199-L203). This would cause auction participants to receive zero Mars token rewards in return for their MARS token delegation. it token already shares MARS due LP to",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Querying the state of the contract may return false information",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In the LP staking contract, in lines lp_staking/src/contracts.rs:315-352, there is a max function that takes the timestamp provided by the user and the current timestamp. Therefore, if the user-provided timestamp is in the past, the returned information will be false, as it will correspond to the current timestamp. If the user, which can be a 3rd party protocol, relies on this query to do further calculations, this might cause unintended consequences.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Typo in variable names might cause errors in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In the Lockdrop contract, contracts/lockdrop/src/contract.rs:832, there is a typo in the variable xmars_accured, which may cause development errors in the future.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Overow checks not set for most packages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The following Cargo.toml les do not enable overow-checks for the release prole:  packages/mars-periphery/Cargo.toml  contracts/airdrop/Cargo.toml  contracts/auction/Cargo.toml  contracts/lockdrop/Cargo.toml  contracts/lockdrop/Cargo.toml",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. getAllPrivate function incorrectly returns public capabilities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/CapabilityProxy.cdc:62-64, the getAllPrivate function returns all capabilities stored in the self.publicCapabilities dictionary. This is incorrect because the function should return all private capabilities instead of public ones. Consequently, the function will always return incorrect types of capabilities. We classify this issue as major because it aects the correct functioning of the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Deny list lter allows retrieving invalid capabilities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/CapabilityFilter.cdc:44, the allowed function returns true when the capability cannot be borrowed. This is problematic because a malicious parent account can store invalid capabilities and use them once the underlying resource becomes borrowable. Consequently, this allows the parent account to bypass the lter restrictions created by the child account. to the appendix to reproduce the issue. While the provided test case Please refer demonstrates a situation in which the parent account can bypass the manager capability lter, this issue can similarly lead to bypassing the capability lter in the proxy account.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Capabilities are not checked to be valid",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In several instances of the codebase, capabilities are not validated to be borrowable before storing them. The following code locations should have the capability validated:  addCapability function in contracts/CapabilityProxy.cdc:87-94.  Initialization phase in contracts/HybridCustody.cdc:354 where the filter is not nil.  setManagerCapabilityFilter contracts/HybridCustody.cdc:418 managerCapabilityFilter is not nil. function where in the Consequently, the capabilities might fail to borrow the underlying resource reference when used, which is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Replaying publishToParent causes the ProxyAccount resource to be overwritten",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/HybridCustody.cdc:593, no validation ensures the publishToParent function is not called towards the same parent address more than once. If the function was called twice for the same parent address, the old ProxyAccount resource will be removed, the as seen in line 621. This is inecient because the child account should call removeParent function to overwrite an existing parent.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Potential incorrect owner query before ownership acceptance",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "the giveOwnership function sets the In contracts/HybridCustody.cdc:707, acctOwner to the recipient to indicate they own this child account. However, there is a possibility that the recipient does not claim the published capability from the child's account. Consequently, the getOwner function in line 690 would still show the account owner is the recipient, which is incorrect.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Removing nonexistent capabilities emits events",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "the removeType In contracts/CapabilityFilter.cdc:34-37 and lines 72-75, function removes the capability from the dictionary without checking its existence. This is problematic because the FilterUpdated event would be emitted accordingly to indicate the capability is inactive, which is incorrect. After all, the capability was never added before.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Transferring ownership does not emit an AccountUpdated event",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/HybridCustody.cdc:327-333, the giveOwnerShip function calls the child account to transfer ownership to another user. However, the AccountUpdated event is not emitted to notify event listeners that there is a change in the owned account.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Unlinking the public proxy account resource path is unnecessary",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/HybridCustody.cdc:672, the removeParent function unlinks the public path for the proxy account identier. This is unnecessary because public paths are not linked during the creation of the proxy account resource.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Named parameters are not used for known functionalities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/HybridCustody.cdc:801, the display metadata view is stored in a dictionary with a hardcoded key display. Since the eld and the functionality is already known, hardcoding the parameter can be avoided.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Duplicate function can be removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "the getAddresses function performs the In contracts/HybridCustody.cdc:279, same action as getChildAddresses. This is inecient because calling both functions returns the same functionality and result.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Default manager capability lter cannot be updated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/HybridCustody.cdc:223, the filter variable acts as a default lter value passed to any newly added child account. Since the manager resource owner cannot modify calling the setManagerCapabilityFilter again. This can easily get complicated when the number of child accounts increases. this, any new lter to add requires the manager intends",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Codebase readability can be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "The readability of contracts/HybridCustody.cdc: the project can be further improved in the following contexts in 1. The variable and function names used to denote the type of account are inconsistent across the contract. Some of them can be useful when referenced within the context it is dened but results in reduced readability in general. Consider explicitly naming the account types and identiers and keeping them consistent across the contract. For example, lines 211 and 363 use both childAccount and account to specify a child account. In this case, explicitly calling out the child's account can improve readability. 2. The seal and removeOwned functions do not sound as cautious as they need to be, possibly causing their impact to be undermined. Consider making their importance more explicit in addition to the comments already given in the contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. addFactory function overwrites existing types",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/CapabilityFactory.cdc:17, the function addFactory doesnt check if the type that is being added already exists or not. If the type to be added already exists, it may be overwritten by mistake.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Outstanding TODO comments in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In several TODO. This decreases the readability of the codebase. instances of the codebase, many unimplemented functionalities are marked as",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Users existing balance will be inaccessible if UpdateAccounts is called with a new denom",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs:694-703, a users existing balance will be overwritten when the denom in the BatchUpdateRequest is not found in previously stored balances. This is caused by not including the existing balance when adding a new balance in line 721. Consequently, balances with denoms that were sent previously will be stuck in the contract. A test case demonstrating the above scenario can be found in appendix 2.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Fee denom deposited by user will be inaccessible if excluded from conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs:332-347, platform funds sent by the user will not be included as deposited funds. This is problematic since there is no validation that platform funds must be included in the allowed funds vector. As a result, users that deposit platform funds would not have their account balance updated, leading to a loss of funds. A test case demonstrating the above scenario can be found in appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Migration might fail due to out of gas error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/contract.rs:183-187, the for loop tries to process all launchers stored inside the contract. Since launchers are unbounded and cannot be removed, sooner or later the launchers' storage might grow too big to process. Consequently, this might cause the migration transaction to fail due to an out of gas error. We classify this issue as minor since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Incorrect deposit history will be logged when users deposit into a prefund",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs:364-373, the deposit history of users that deposited into a prefund will be incorrect. Firstly, the launcher_id value is hardcoded to None in the FundingHistory although the user deposits to a prefund in line 246. Secondly, history will be empty because it is ignored, see lines 332 to 347. if config.fee_denom is not included in config.denoms vector, the deposit Thirdly, the deposit history will record the user's deposit to be lower than intended due to double platform fee deduction if the config.fee_denom is included in config.denoms vector (see lines 295-300 and 332-336). In result, deposit_history value as seen in contracts/account/src/queries.rs:72. this would cause the Investor query message to return an incorrect The above scenarios can be demonstrated with test cases which can be found in appendix 3.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Guaranteed allocation size might be incorrectly overwritten when updating congurations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "to the contracts/prefund/src/commands.rs:80-94, In of state.guaranteed_allocation_size is forcefully updated even if there's no valid update If guaranteed_allocation_size is instantiated to contain a valid Some value and one of the admins decides to update congurations that aren't related to it (e.g. the name or description), the value of guaranteed_allocation_size will be overwritten to None in line 93. As a result, return an incorrect value in contracts/prefund/src/queries.rs:46. the State query message will max_participants corresponding value. value the A test case demonstrating the above scenario can be found in appendix 4. that leads possible scenario the Another when guaranteed_allocation_size the updated_config.total_tokens_for_sale case, has updated_config.max_particpants state.guranteed_allocation_size is set to None whilst its value should get updated to the new value of total_tokens_for_sale. is a None value while has a incorrect value. Some value that an to of In",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Missing logical validations might cause unexpected outcomes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In the prefund contract, there are several cong values that are currently not validated. For example, the value of msg.end_date should be greater than msg.start_date and the value of msg.max_prefund should be greater than msg.min_prefund. If any of these values are congured incorrectly, it would cause the contract to be unusable. For example, try_allocate in function the contracts/prefund/src/commands.rs:123-129 if msg.start_date is greater than msg.end_date. would fail",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Missing address validations might lead to failures of execution handlers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In the prefund contract, there are addresses in cong values that are not validated before storing. Incorrect addresses would lead to issues when executing functions such as the prefund whitelist_contract. This issue exists during both the instantiation of contract in contracts/prefund/src/contract.rs:46-69 and updates to the cong in contracts/prefund/src/commands.rs:43-78.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Missing tax deductions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero tax rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See this discussion for more details about the tax rate changes on Terra.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. try_update_accounts allows arbitrary balance updates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs:666, the admins are able to increase any existing investors balance without any restriction limit. The team states that the amount of allocation is determined by their own Atlo rating which is calculated via an o-chain script. Since theres no validation in place (e.g. verifying the investor did invest into the prefund or making sure the refund amount lower than the deposited amount), a miscalculation in the script might cause the investor to get more/less tokens than intended. is equal to or",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Lowercasing denoms will cause issues with IBC tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs, there are several instances where token denoms are converted to lowercase via to_lowercase. Since token denoms are case sensitive, the contract will be unable to support IBC tokens.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Prefund deposit amount needs to be greater than intended",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs:333-316, users deposited funds are deducted twice even though they have already been deducted in lines 295 to 300. This causes an unnecessary requirement that the prefund deposit amount must be greater by twice the value of platform fees. There might be a possibility that the users deposit is rejected due to insucient funds.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Possibility of duplicate denoms in conguration is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/contract.rs:43, denoms are added into the cong during contract instantiation phase. If the admin decides to add custom denoms via passing a valid msg.denoms vector, the corresponding denoms function will not remove duplicate denominations from the vector. Consequently, there is a possibility that the same denom is added twice to the config.denoms vector, which is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Users can deposit into inactive/ended launchers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In the accounts contract, a value is stored to keep track in which state the launcher is. However, the launchers state does not get automatically updated nor does it get used to validate whether the given launcher id should receive investments or not. Hence, an investor may invest in a launcher that has ended, which would lead to a failure when allocating the funds, because the prefund contract checks for the end_date. To resolve this issue, the admin would need to withdraw funds from the prefund contracts individually.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. PeriodicVesting is unintendedly releasing tokens to users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf",
        "body": "In vesting:src/msg.rs:117-138, the vested amount of tokens that is ready to be redeemed by the user is calculated using a PeriodicVesting schedule. It is supposed to calculate the current number of elapsed intervals since start_time in order to compute the total amount of vested tokens. As demonstrated in the test case in Appendix 1, the code is not calculating the correct vested tokens though, which leads to the following problems:  At start_time, the user can already redeem the rst tranche of tokens, even if no interval has elapsed.  The user gets a token tranche more than expected at the end of the vesting period.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. LOCKINGADDRESS is never populated which will block rebasing functionality",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf",
        "body": "The handle_lock_nft function in locking:src/contract.rs:256-266 does not store the locking address to LOCKINGADDRESS. The function creates a mutable vector of addresses from LOCKINGADDRESS where it pushes the senders address but the address is never saved to LOCKINGADDRESS. This results in the map never being populated, which will highly impact other functionality in the contract such as the calculate_rebase_reward function that performs a rebase.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Multiple rounding issues may cause zero rewards being distributed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf",
        "body": "functions of Several the locking contract are aected by rounding issues since their mathematical operations use U128 integers for divisions where the numerator is smaller than the denominator. This causes the result to be truncated to zero instead of the desired ratio before it is multiplied, causing the whole operation to be zero. Therefore, reward distribution will result in a zero tokens distribution. In particular in the The aected operations can be found on rewards related features. calculate_bribe_reward, and calculate_surplus_reward functions. The aected instances can be found at and locking:src/contract.rs:770, locking:src/query.rs:322. calculate_rebase_reward 870, 888, 904, 919,",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Unbounded iterations may cause calculate_rebase_reward to run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf",
        "body": "The calculate_rebase_reward function in locking:src/contract.rs:798 performs an unbounded iteration over all entries in LOCKINGADDRESS, and then for each address in LOCKINGADDRESS it will iterate through all vtokens for the gov_token_denom. Both VTOKENS and LOCKINGADDRESS are unbounded and have the potential to grow large with time and normal use. In addition, as mentioned in the nding LOCKINGADDRESS entries are never removed which may introduce state bloat, LOCKINGADDRESS can never be reduced, exacerbating this issue. The impact of this issue is that the rebasing functionality of the contract could become blocked for a specic app_id.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Lack of pool status validation in claim function leads to a race between underwriters to withdraw and insurees to claim funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The claim function in src/contract.rs:251 does not perform a check to ensure that the pool is not in a closed state. If the pool status is closed and a hack/default event occurs, swaps can still be performed. Insurees will only claim if the payout amount is bigger than the value of the covered token. Rational underwriters will anticipate that, and rush to withdraw liquidity to maximize their return. Rational insurees will anticipate that rush, and try to claim as fast as possible. This race can lower trust in the protocol, but will eventually put users to a disadvantage that act slower than others.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Wrong payout calculation may lead to last claiming insurees not being able to claim",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The calculation of payout in the claim function in src/contract.rs:302 uses the default_ratio rather than the payout_ratio. This is dierent from the calculation of the capacity in line 476 and may result in the last insuree trying to swap running into out-of-funds errors.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Owner may update default ratio to prevent claims from being made",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "default_ratio, payout_ratio, and expiration are updatable variables that are used to determine whether or not the default event occurred in src/contract.rs:288, how much to pay out in 288, and whether the pool is closed in line 512-514. If the owner account was compromised or the owner simply wanted to control whether claims should be possible and what height they should have, they could update these values, aecting any users that have not claimed yet.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Lack of validation of state parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The instantiate and update_config functions in src/contract.rs:28 and 408 lack validation of the following parameters:  expiration: If set to a time in the past, this will cause the next invocation of check_if_at_status to transition the pool status to closed.  payout_ratio: If set to zero, the next invocation of the purchase would attempt to divide by zero in line 476 while attempting to calculate the total_capicity, which would cause a panic.  price (validated in the instantiate, but not in the update_config function): If set to zero, the purchase function would panic in line 220. A price of more than one would economically not make much sense.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Pool may be congured with an incorrect credit token",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The InstantiateMsg struct in src/msg.rs:11 denes credit_token with a type of Addr, which is then stored without validation in src/contract.rs:70. This allows instantiation of a pool with an invalid credit token address, which may only be detected when claims happen after a hack/default.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Owner may update parameters that can negatively impact users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The update_config function in src/contract.rs:408-439 allows the owner to update the following values:  price  expiration  default_ratio  payout_ratio Any underwriters that provide liquidity to the pool at the time of such a change would be subject to these changes, but they have no way to withdraw the pool if the values change to their disadvantage. This disincentivizes underwriters from entering the pool in the rst place, and also adds to centralization of the protocol. We classify this nding as minor because only the owner can make these changes.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Claim payout attribute value is missing tax deduction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The payout attribute in the claim function in src/msg.rs:324 contains the pre-tax payout value. This value will be dierent from the amount that is actually sent after deducting the tax.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of validation of Cw20ReceiveMsg msg can surprise users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The claim function in src/contract.rs:255 receives a Cw20ReceiveMsg but does not match/use the contained msg. This means that the contract will execute a claim regardless of the received message. This goes against user expectations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Default state assessment of protocols added in the future may be subject to manipulation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The audited smart contract only supports protection against drops in the Anchor exchange rate. That exchange rate can only be manipulated by an attacker that is a validator and deliberately gets slashed. Future extensions of the protocol might support insurance of tokens from other protocols though, with default conditions that may be subject to manipulation. In the past, many exploits of protocols were based on manipulation of spot prices, which is a concern for the Risk Harbor protocol. Even though this issue does not aect the current iteration of Risk Harbor, we still classify it as minor since it poses a potential risk of a future iteration.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Hard-coded Anchor market address decreases exibility",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The calculation of the redemption_ratio in src/contract.rs:285 uses a hard-coded (currently placeholder) address for the Anchor market contract. This decreases the exibility of the contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Selective usage of CW20 features may lead to wrong user expectations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The contract selectively imports and uses code from the CW20 reference implementation. At the same time, the contract does not expose all of the CW20 execution and query message entry points. Depending on the frontend users are using, bought coverage might show up as a CW20 token to the user, but functionality such as transferring, sending, or burning those this selective usage of CW20 code increases the tokens is not available. Moreover, complexity of the contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Lack of validation of pool name length may have adverse consequences",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "the stores contract The in src/contract.rs:38-49. The CW20_base crate performs a validation check to ensure that the token name adheres to the expected format and returns an error if this condition is not met. the CW20 format token using base info Using too long names might have adverse consequences, for example for user interfaces that expect limited token names.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Front-running audience creation opens phishing and other risks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf",
        "body": "The aud eld, typically representing the URL of the resource server, is a unique index in the front-runs a legitimate audience creation transaction at system. x/jwk/keeper/msg_server_audience.go:19-25, they can eectively block the legitimate user from creating their intended audience. This can lead to several issues: an attacker If  Resource Allocation Disruption: The legitimate user may need to reset their server resource allocator or make other adjustments to their system to work around the blocked audience.  Phishing Risks: an attacker could use the front-run audience to set up a phishing site. Since the audience eld is typically a URL, users might be misled into interacting with the attacker's site.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Exposing shared keys during audience creation with HS256 signing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf",
        "body": "When creating an audience at x/jwk/keeper/msg_server_audience.go:15-40, it is possible to use shared/symmetric keys (HS256) for signing and verifying tokens. However, this approach would result in exposing the shared keys as the key is stored on a chain.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Genesis does not validate audience admin addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf",
        "body": "The Validate function in x/jwk/types/genesis.go:21 does not properly validate the audience admin addresses. This may create a situation where an invalid admin is added, resulting in the inability to administrate the audience in the future.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Update audience command does not support updating the admin",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf",
        "body": "The CmdUpdateAudience function within x/jwk/client/cli/tx_audience.go allows updating the administrator and key associated with a specic audience index. While it accepts arguments for updating the key, for specifying a new it administrator through the CLI command. Consequently, the update process assigns the current administrator (obtained from the source address) as the new administrator. This restricts the ability to change the administrator via the CLI command, which poses a signicant security risk, particularly in scenarios where the current administrator's credentials are compromised. lacks a parameter",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Incomplete validation in update audience function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf",
        "body": "The ValidateBasic function in x/jwk/types/message_audience.go:53 serves the purpose of validating the MsgUpdateAudience message. However, it fails to incorporate validation checks for the new_admin parameter within the message. This omission exposes the system to the risk of accepting messages containing invalid administrator data for audiences. The inclusion of such invalid data could hinder the future utilization of the audiences.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Expired tokens cannot be removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Burnt (XION)/2024-05-25 Audit Report - XION and Account Abstraction Updates 2 v1.0.pdf",
        "body": "the current implementation In in x/jwk/keeper/msg_server_audience.go:72, expired tokens are not deleted automatically and hence remain stored indenitely. Moreover, audience admins have to pay gas for transactions to delete audiences. This can lead to unnecessary consumption of storage space over time, as the number of expired tokens can potentially grow large. DeleteAudience function the of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Debit transfers always fail for tokens that return no value on success",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf",
        "body": "The debit function allows transferring tokens from a users account to a beneciary. The transferFrom function is being called inside the following require statement: require(token.transferFrom(userAddress, amount), \"Token transfer failed\"); beneficiaryAddress, This would lead to failing transfers for tokens that return no value on success and revert or throw on failure, like USDT.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Withdrawal limit can be easily circumvented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf",
        "body": "Whenever the function debit is called, the modier checkWithdrawalLimit checks that the requested amount is below the global withdrawal limit. However, this check is only applied per call and can be easily circumvented by splitting larger withdrawals into multiple transactions where each one is below the withdrawal limit.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. The executioner can debit any approved tokens from the users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf",
        "body": "According to the client's comment, the main motive of this contract is to auto-top-up users' cards from their approved list of tokens. However, the current implementation has no checks against any approved lists. This allows the executioner to debit any tokens from the users that have approved spending.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Missing event for critical parameter change",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf",
        "body": "limit, which is a critical The setMaxWithdrawalLimit function sets a new withdrawal change. However, it does not emit an event. Events help o-chain tools to track changes, and hence increase usability.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Redundant input validations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf",
        "body": "In a couple of instances, redundant validations are present: - - checks modier checkBeneficiaryRole the The beneficiaryAddress is not address(0) which can only happen if a privileged admin has granted BENEFICIARY_ROLE to address(0). Because this is highly unlikely and a mistake by the admin, the abovementioned check can be removed to save gas. The checkWithdrawalLimit modier checks whether the tokenAddress argument is not address(0). However, because any ERC20 call to address(0) would revert anyway, this check can be removed to save gas. whether",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Redundant checks during token transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf",
        "body": "to a beneciary. The debit function allows transferring tokens from a users account However, before the token transfer, the function performs allowance and balance checks which are then checked again by the tokens contracts. This leads to unnecessary gas spending and reduces overall readability.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Global withdrawal limit does not allow granular control",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf",
        "body": "The contract has one global limit _maxWithdrawalLimit that can be updated by an admin. Within checkWithdrawalLimit, this value is scaled by the tokens decimals and compared with the requested amount. This approach has multiple downsides: - - An admin can only set one value, which will have very dierent monetary values for dierent tokens. For instance, a value of 10,000 results in a limit of 10,000 USD for USDC, more than 3 million USD for ETH and more than 60 million USD for WBTC. Because the value is scaled by the decimals, the smallest possible value is 1 whole unit for every token. For some tokens like WBTC, 1 WBTC may already be too large. Allowing fractional values may be desirable.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. The withdrawal limit can be used to implicitly pause the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf",
        "body": "setMaxWithdrawalLimit to any the The to the _maxWithdrawalLimit checkWithdrawalLimit modier, setting the withdrawal limit to zero would not allow the users to debit tokens and would lead to the same outcome as pausing the contract via the pause function. This may mislead users. including zero. However, due function value allows admin set an to",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Miscellaneous",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2024-08-08 Audit Report - Cypher Autoload Simple v1.0.pdf",
        "body": "- Use != 0 instead of > 0 for unsigned integer comparison to save gas. The modier name anyPrivilagedUser contains a typo, - anyPrivilegedUser. replace it with",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Blocked cross-chain requests are indenitely retried and could be exploited for denial-of-service attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "In the HandleFees function in x/crosschain/abci.go:18, cross-chain requests are put in a blocked state (CROSSCHAIN_TX_BLOCKED) if fees cannot be deducted from the fee payer with the DeductFeeInboundRequest, DeductFeeOutboundRequest or DeductFeeCrosstalkRequest functions due to either not having a fee payer congured, insucient fee payer balance, or the fee payer address not being approved yet. Such blocked cross-chain requests are then retried in the EndBlocker function in line 38 after every other block, specically after every params.BlockedRetryInterval block interval. However, if deducting fees from the fee payer continues to fail, the cross-chain request will be retried indenitely. Consequently, this can potentially be exploited to cause denial-of-service attacks on Router Chain by submitting a large number of cross-chain requests that are blocked and retried indenitely. Similarly, the same issue persists for blocked ack requests if deducting fees fails in the DeductFeeInboundAckRequest and DeductFeeCrosstalkAckRequest functions the when ProcessBlockedCrosschainAckRequests function in lines 551-592. processing requests blocked the in",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Non-deterministic iteration in ClaimEventSlashing can cause consensus failure",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "In x/attestation/abci.go:32121, attestations are processed by iterating over the attmap map. In Go, iterating over a map does not guarantee a consistent order of iteration, leading to non-deterministic behavior. For instance, if the UnpackAttestationClaim function in line 78 errors, a panic will occur in line 80. This could cause the resulting app hash computed by one validator to dier from others. Consequently, the validators cannot reach a consensus within Tendermint's timeouts, causing a consensus failure and halting the chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Unapproved fee payers can block legitimate requests which can be exploited for denial-of-service attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "In x/crosschain/abci.go:254 and 259, any errors within the fee payer will cause the Execute function to return the execution early. This is problematic because other cross-chain requests ready to be executed will not be processed. Consequently, an attacker can submit a cross-chain request without approving the fee payer for the pending requests to to block other legitimate requests. The attacker can wait accumulate to a large number and approve the fee payer to cause all pending requests to be processed at once. Since this function is executed in the EndBlocker, block production will be slowed, potentially halting the chain. This can be exploited for a denial of service attack.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Anyone can submit forged cross-chain requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "Cross-chain requests are submitted to Router Chain via the MsgCrosschainRequest in message, x/crosschain/keeper/msg_server_crosschain_request.go:10. Requests are processed dierently based on the workow type determined by calling the WorkflowType function in line 18, which can INBOUND, OUTBOUND, or CROSSTALK. handled The INBOUND workow type is used for requests originating from a source chain and relayed to a CosmWasm contract deployed on Router Chain. The OUTBOUND workow type is used requests originating from CosmWasm contracts on Router Chain and relayed to a for destination chain. In any other case, the CROSSTALK workow type is used for requests originating from a source chain and relayed to a destination chain. INBOUND requests, constituting emitted events on a source chain, are submitted by the orchestrators of Router Chain and require a supermajority of orchestrators to attest to the request before it is considered valid. However, as there is currently no access control or in-depth validation of the submitted MsgCrosschainRequest message, anyone can send such a message, potentially with a malicious payload. For instance, setting SrcChainType to MultichainTypes.CHAIN_TYPE_ROUTER to forge an OUTBOUND request does not require attestations as it is assumed that the request originates from Router Chain itself. This results in burning Router tokens from an arbitrary address specied in RequestSender, causing a loss of funds. it is also possible for an attacker to mint unlimited native Router tokens by Additionally, forging an INBOUND request with an IBC_VALIDATION validation type. Such a validation type typically assumes that the request was received via IBC and thus is valid. In the case of a is considered valid and processed in the forged cross-chain request, HandleNativeTransfer function in x/crosschain/abci.go:81. Subsequently, the HandleInboundNativeTokenFlow function called in line 92 mints an arbitrary number of Router tokens to the attacker-controlled RouteRecipient. the request The two depicted scenarios are just examples of how an attacker can exploit the lack of access control and validation of cross-chain requests. The ability to maliciously craft a MsgCrosschainRequest message leads to serious security implications for Router Chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Anyone can submit forged cross-chain ack requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "via the MsgCrosschainAckRequest As part of the acknowledgment workow, cross-chain ack requests are submitted to Router in Chain Ack x/crosschain/keeper/msg_server_crosschain_ack_request.go:10. requests are processed dierently based on the workow type determined by calling the WorkflowType function in line 17 and can be INBOUND_ACK, OUTBOUND_ACK, or CROSSTALK_ACK. message, handled The INBOUND_ACK workow type is used to send acknowledgments to a CosmWasm contract on Router Chain. The OUTBOUND_ACK workow type is used for ack requests originating from Router Chain and relayed to a destination chain. In any other case, the CROSSTALK_ACK workow type is used. INBOUND_ACK requests, constituting emitted ack events, i.e., iReceive on a source chain, are submitted by the orchestrators to Router Chain and require a supermajority of orchestrators to attest to the ack request before it is considered valid and executed. However, as the submitted MsgCrosschainAckRequest message, anyone can send such a message, potentially with a malicious payload. there is currently no access control or in-depth validation of For instance, by sending a forged MsgCrosschainAckRequest message with an INBOUND_ACK workow type and the validation type IBC_VALIDATION, the last observed event nonce will be updated by the SetLastObservedEventNonce function in x/crosschain/keeper/ack_validation_handler.go:71. This results in potentially grieng new legitimate cross-chain requests as they will be considered as already validated in x/crosschain/keeper/validation_handler.go:45 due to the last observed event nonce being greater or equal to the submitted event nonce and thus not storing the request. Subsequently, as soon as the supermajority of orchestrators attests and observes the event, it will not get further processed by the handlers in x/crosschain/keeper/hooks.go as there is no such request stored in the database. The ability to maliciously craft a MsgCrosschainAckRequest message leads to serious security implications for Router Chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Unbonding validators can circumvent slashing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "the ClaimEventSlashing function, During the EndBlocker slashing process, implemented in x/attestation/abci.go:27-122, is called in line 22. However, only bonded validators are considered for slashing if they submit conicting attestations or miss attesting an observed claim. This is problematic because unbonding validators are not exposed to the slashing penalty. Consequently, reports such a slashable behavior, validator can unbond from the validator set to avoid the slashing penalty. if an orchestrator the corresponding",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Deactivated price feeders are not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "price conguring When x/pricefeed/proposal_handler.go:34, governance can set the Active boolean to indicate whether the price feeder is activated or deactivated (see x/pricefeed/types/price_feeder_info.pb.go:28). However, this is not enforced through the codebase. feeders in the Specically, in TokenPrices and x/pricefeed/keeper/msg_server_token_prices.go:11 x/pricefeed/keeper/msg_server_gas_prices.go:11 do not validate whether the price feeders Active status is true before allowing them to update the prices. Consequently, governance cannot remove or disable malicious price feeders after adding them. GasPrices functions and",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Failed requests will not be reected for ErrorGasOverflow panics",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "In the following code locations, the recover function does not modify the exec data and exec ag when the default statement is entered:  x/crosschain/keeper/inbound_ack_execution.go:66-69  x/crosschain/keeper/inbound_execution.go:65-68  x/voyager/keeper/fund_deposit_execution.go:60-63  x/voyager/keeper/fund_paid_execution.go:52-55  x/voyager/keeper/update_deposit_info_execution.go:54-57 In comparison, the function handles the ErrorOutOfGas panic case when executing the ConsumeGas function. If that happens, the exec ag will be set to false, and the exec data will be updated with the error. However, this is not performed when the default statement is entered. This will happen if the ErrorGasOverflow panic occurs for overows when computing the gas consumption amount. Consequently, the exec ag and exec data will not be updated to indicate the failed request, causing incorrect events to be emitted.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Failed cross-chain ack requests are incorrectly stored as successful",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "In x/crosschain/keeper/ack_workflow.go:93-100, no return statement is implemented to exit the HandleOutboundAck function early after the cross-chain request has failed. if an error occurs during SendIBCPayload in line 86, Specically, the cross-chain acknowledgment request status is stored as CROSSCHAIN_ACK_TX_EXECUTION_FAILED. lines 99-100 will Since no return statement is implemented after updating the status, continue as updated CROSSCHAIN_ACK_IBC_TRANSFERRED. Consequently, a cross-chain request that fails will be incorrectly stored as a success. incorrectly execute, causing status the be to to issue This x/crosschain/keeper/workflow.go:124-131. present also the in is HandleOutbound function in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Executing crosstalk requests with a missing IBC relayer cong results in indenite retries and liveness issues",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "The Execute function in x/crosschain/abci.go:321-361 iterates and processes all stored cross-chain requests with the CROSSCHAIN_TX_READY_TO_EXECUTE status in the EndBlocker function at the end of every block. In the case of a CROSSTALK request, a cross-chain request originates from a source chain and is intended to get relayed to a destination chain. If the destination chain is a Cosmos chain, the relayer cong is retrieved by the CrosschainRequest.DestChainId function to determine the IBC channel, RelayerConfig.Channel. Subsequently, this IBC channel is used to send the cross-chain request from Router Chain to the destination Cosmos chain via IBC. if no for yet such exists relayer stored, conguration cong is not However, provided CrosschainRequest.DestChainId, for instance, because the chain ID is invalid or the i.e., relayer CROSSCHAIN_TX_READY_TO_EXECUTE. This results in the cross-chain request execution to be retried by the Execute function in the next block, potentially indenitely. As there is currently no validation of CrosschainRequest.DestChainId, allowing anyone to dene an arbitrary destination chain ID, this behavior can be exploited to spam Router Chain nodes with cross-chain requests that are repeatedly processed and retried, allowing a denial-of-service attack. remains unchanged, the request status the Similarly, ExecuteAck function in x/crosschain/abci.go:443-478. the same issue persists for CROSSTALK_ACK requests processed by the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "11. Anyone can create a new relayer conguration with a potentially invalid IBC channel, resulting in failed cross-chain requests via IBC",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "Cross-chain requests are sent to a Cosmos destination chain via IBC. The IBC channel used for sending the request is congured in the relayer conguration. Relayer congurations are created and managed via the MsgCreateRelayerConfig, MsgUpdateRelayerConfig, and x/crosschain/keeper/msg_server_relayer_config.go:11-91. MsgDeleteRelayerConfig messages handled in However, anyone can create a new relayer conguration (before the Router team is able to the legitimate relayer cong), as the CreateRelayerConfig function does not set implement any access control mechanism. Consequently, malicious users can create a new relayer cong for a specic Cosmos destination chain with an invalid IBC channel. This will result in cross-chain requests failing when attempting to send them via IBC to the destination chain with the invalid IBC channel. Once a relayer cong is created, it can only be updated and deleted by the creator of said relayer cong. An invalid relayer cong will thus prevent a correctly congured relayer cong from being created for the same Cosmos destination chain.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "12. Symbol prices requested by the BandChain oracle are not namespaced by the price feeder name, resulting in the inability to retrieve prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "StoreOracleResponsePacket The in x/pricefeed/keeper/keeper.go:210 receives an OracleResponsePacketData packet containing the requested symbol prices from the BandChain oracle. The contained prices are looped over, and the UpdatePrice function in line 220 updates the stored symbol prices. Symbol prices are namespaced by a price feeder name, PriceFeeder, which is or BAND_PRICE_FEEDER = \"band_feeder\". \"router_price_feeder\" ROUTER_PRICE_FEEDER function usually either = Retrieving the price of a specic symbol with the GetPriceBySymbol function in x/pricefeed/keeper/price.go:80 rst attempts to return the price with the the BAND_PRICE_FEEDER ROUTER_PRICE_FEEDER price feeder name. feeder found, name price with not or, if However, the StoreOracleResponsePacket function does not set the PriceFeeder eld of the Price struct when updating the symbol prices. This leads to the symbol price being incorrectly stored without a prex, resulting in the GetPriceBySymbol function not being able to retrieve the price by the symbol name. the ConvertNativeTokenFeeToRouter function, used within the Consequently, crosschain module, is unable to retrieve the price of the chain's native token and returns the error \"Token price not found\" when processing cross-chain requests.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "13. Custom application panics in EndBlocker can halt the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "Within the x/attestation and x/crosschain modules, custom panics are implemented in the EndBlocker if application-specic errors are encountered, which leads the chain to halt. intentionally utilize panics as preventive measures against While the SDK itself might unintended bugs, custom panics within the application's logic in ABCI methods can accidentally introduce vulnerabilities. For example, a malicious actor can halt the chain if they trigger an application-specic logic error, causing a denial of service attack. That said, it is important to note that panicking within ABCI methods can be appropriate under specic circumstances. For instance, if an error in the application-specic logic indicates a critical aw in the protocol, halting the chain and alerting stakeholders might be benecial to prevent the issue from causing further damage.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "14. Unhandled errors in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "In several would cause silent failures as errors are not raised to notify users. instances of the codebase, functions that return an error are not checked. This  x/attestation/keeper/attestation.go:220, 329  x/attestation/keeper/msg_server_set_orchestrator_address.go:5  x/attestation/keeper/msg_server_valset_confirm.go:53  x/attestation/keeper/msg_server_valset_updated_claim.go:44  x/attestation/keeper/valset.go:42  x/attestation/module.go:80  x/crosschain/keeper/ack_fee_handler.go:186, 194  x/crosschain/keeper/ack_workflow.go:17, 19, 110, 113, 120  x/crosschain/keeper/event_handler.go:16, 36, 47, 56, 64, 77, 85, 93, 103, 117, 135, 146, 154, 167, 175, 183, 192, 204, 216  x/crosschain/keeper/fee_handler.go:194, 200  x/crosschain/keeper/gov/gov.go:37, 72  x/crosschain/keeper/native_token_flow.go:52  x/crosschain/keeper/workflow.go:153  x/crosschain/module.go:74  x/crosschain/types/metadata.go:61  x/pricefeed/module.go:76  x/multichain/keeper/gov/gov.go:40, 86, 125, 168, 220, 259  x/multichain/module.go:80  x/rwasm/module.go:73  x/voyager/keeper/event_handler.go:16, 38, 45, 53, 63, 81, 88, 96, 106, 123, 130, 138  x/voyager/module.go:74  x/metastore/abci.go:33  x/metastore/keeper/msg_server_approve_feepayer_request.go:30  x/metastore/keeper/msg_server_set_metadata_request.go:24, 51  x/metastore/module.go:82",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "15. Incomplete genesis handling causes loss of storage values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "In several instances of the codebase, the genesis state does not handle the storage values properly in either the initialization or export functions. Firstly, the InitGenesis function in x/attestation/genesis.go:45-50 does not call SetValsetUpdatedClaim for the provided genState.ValsetUpdatedClaimList. This means that although it is exported in line 64, it cannot be added back when initializing the genesis state, causing all existing ValsetUpdatedClaimList storage values to be lost. Secondly, the InitGenesis function in x/voyager/genesis.go:30-33 does not call provided SetDepositUpdateInfoRequest genState.DepositUpdateInfoRequestList. This means that although it is exported in line 46, it cannot be added back when initializing the genesis state, causing all existing DepositUpdateInfoRequestList storage values to be lost. the for the and InitGenesis in Lastly, handle x/crosschain/genesis.go:10-84 BlockedCrosschainRequestList and BlockedCrosschainAckRequestList. This if the genesis state was exported and the chain is reinitialized, all existing means that BlockedCrosschainAckRequestList BlockedCrosschainRequestList storage values will be lost. ExportGenesis functions and not do",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "16. GetLastUnBondingBlockHeight will always return zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "the last unbonding block height In x/attestation/abci.go:135, is retrieved with GetLastUnBondingBlockHeight and compared in line 162 to determine whether SetValsetRequest needs to be called. However, there is no function that sets the storage value of types.LastUnBondingBlockHeight. Consequently, the last unbonding block height will always return zero in x/attestation/keeper/valset.go:259, rendering it useless because the value will never equal the current block height.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "17. Slashing risk due to sequential attestation processing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "In x/attestation/keeper/attestation.go:192, the Attest function ensures the claim event nonce equals the incremented last claim event nonce to process attestations sequentially. This can become problematic when a validator unbonds and later re-bonds, for example, months or even a year later. In such cases, the validator is obligated to attest to all claims that occurred during their absence. Processing this backlog of in-between claims can be time-consuming, and there's a risk that the re-bonded validator might miss attesting to some claims, leading to slashing risks.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "18. Zero values initialization aects gas handling and fee refunds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "In the following instances of the codebase, the variables are set to zero instead of the intended values. Firstly, the DestGasLimit and DestGasPrice in x/crosschain/abci.go:230-231 are set to zero instead of gasLimit and gasPrice. This is also the same for the AckGasLimit and AckGasPrice functions in x/crosschain/abci.go:584-585, as their value is also set to zero instead of ackGasLimit and ackGasPrice. This would cause the sudo message to fail due to an out-of-gas error because the computed gas fee limit will be zero. the in Besides that, of x/crosschain/abci.go:313 feeConsumedInRoute. This would cause the relayer to be refunded with all the fees even though the sudo message did consume gas. CreateCrosschainAckRequest to feeConsumed function instead zero sets the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "19. HandleAckDefaultValidation does not update the event block height, causing incorrect query responses to be returned",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Chain 2 v1.0.pdf",
        "body": "In the x/crosschain/keeper/ack_validation_handler.go:71, HandleAckDefaultValidation function does not update the last observed event height with SetLastObservedEventBlockHeight after updating the last observed event nonce with SetLastObservedEventNonce. This is inconsistent with others as the last observed x/attestation/keeper/attestation.go:324, event updated height in is x/crosschain/keeper/ack_workflow.go:37, x/crosschain/keeper/workflow.go:67. and the Consequently, in x/attestation/keeper/attestation.go:244 and used in line 261 will be an outdated value, causing the LastEventNonce query to return incorrect event height in x/attestation/keeper/grpc_query_last_event_nonce.go:25. observed retrieved lowest height",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Expensive RPC methods are allowed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-08-13 Audit Report - Dymension Point 1D Stream 6_ RollApp White-box Pentest v1.1.pdf",
        "body": "The analyzed RPC endpoints support all methods that are exposed by EVMOS. Among those, some methods may be problematic in terms of resource usage, for example:  debug_traceTransaction: This method can be used to rerun and trace a prior transaction. Moreover, a trace conguration can be provided where memory capture can be enabled and a custom JavaScript expression can be supplied as the tracer.  debug_traceBlockByNumber: Similar to debug_traceTransaction, but for a whole block.  txpool_content: Lists all transactions that are currently pending.  txpool_inspect: Similarly to txpool_content, but in text format. The invocation of these methods can consume a lot of resources on the RPC server. An attacker might abuse this to overload the servers and perform (D)DoS attacks.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Tendermint RPC API exposes private IP address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-08-13 Audit Report - Dymension Point 1D Stream 6_ RollApp White-box Pentest v1.1.pdf",
        "body": "The Tendermint RPC API can be used to get the private IP of a node via the moniker eld: curl http://52.29.63.91:26657/status {\"jsonrpc\":\"2.0\",\"result\":{\"node_info\":{\"protocol_version\":{\"p2p\": \"8\",\"block\":\"11\",\"app\":\"0\"},\"id\":\"002408011220944cd0e92a4060e0e79b 9a0ad58b3fd7a1e92c22db5b1623b7647754f23e3d92\",\"listen_addr\":\"/ip4/ 0.0.0.0/tcp/26656\",\"network\":\"vaptra_2145170-1\",\"version\":\"\\u003cv ersion\\u003e\",\"channels\":\"01\",\"moniker\":\"ip-10-201-0-197\",\"other\":{ \"tx_index\":\"on\",\"rpc_address\":\"tcp://127.0.0.1:26657\"}},\"sync_info \":{\"latest_block_hash\":\"E3B0C44298FC1C149AFBF4C8996FB92427AE41E464 9B934CA495991B7852B855\",\"latest_app_hash\":\"E03886591492A5D62CD1164 2A294D9F08A82F0ADBA39EC0A057E9D0AA028E871\",\"latest_block_height\":\" 34852\",\"latest_block_time\":\"2024-03-16T19:45:02.643255719Z\",\"earli est_block_hash\":\"\",\"earliest_app_hash\":\"\",\"earliest_block_height\": \"0\",\"earliest_block_time\":\"0001-01-01T00:00:00Z\",\"catching_up\":fal se},\"validator_info\":{\"address\":\"25E427B4DE03FEBFAEEEB73EB7942FAE5 ABC3E03\",\"pub_key\":{\"type\":\"tendermint/PubKeyEd25519\",\"value\":\"yc/ TFWU3L8xfmxqVJvpoJfGQYOR7uG9Aqj3DSKBWTNo=\"},\"voting_power\":\"1\"}},\" id\":-1} The same information is also exposed via the net_info endpoint. While this cannot be exploited, it is generally recommended to expose as little information as possible about the internal network structure.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "3. Broken links in the Dymension EVM RollApp documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-08-13 Audit Report - Dymension Point 1D Stream 6_ RollApp White-box Pentest v1.1.pdf",
        "body": "It has been noticed that the documentation describing the Dymension EVM RollApp contains references to links that lead to non-existent pages. This may be problematic for new users using the platform. These are:  Link in Quick guide section,  Link in Run local dymension hub node section.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Usage of deprecated functionality",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-08-13 Audit Report - Dymension Point 1D Stream 6_ RollApp White-box Pentest v1.1.pdf",
        "body": "It has been observed that the codebase contains calls to the deprecated functions. Namely, the rand.Seed function from the math module is used to set up the RNG. The rand.Seed has been deemed deprecated. The code that is using such functionalities can be found in the and roller/cmd/config/init/flags.go roller/data_layer/celestia/generate_namespace_id.go les.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Multiple subprocesses launched directly on the OS",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-08-13 Audit Report - Dymension Point 1D Stream 6_ RollApp White-box Pentest v1.1.pdf",
        "body": "It was observed that the codebase utilizes an os/exec module to run commands directly within the OS command line interface. Such calls could be susceptible to a Command Injection attack. Although, currently, the commands executed do not seem to take the input from users directly, it is still a best practice to avoid such an approach to multithreading. Furthermore, should an administrator responsible for conguring the system make a mistake, it increases the attack surface of the whole project.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Balance updates performed from precompiles are overwritten if the precompile is executed in a transaction with other state change logic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "Delegate in The precompiles/staking/tx.go:59 and precompiles/distribution/tx.go:67 are not correctly committing balance changes if the caller function performs state changes. WithdrawDelegatorRewards precompiles dened and Consequently, attackers could craft a contract where it is possible to delegate to a validator without having the delegated amount deducted from their balance. users the Additionally, WithdrawDelegatorRewards precompile could lose their rewards, depending on the contract implementation. leveraging contract interact with that a A test case reproducing the issue is provided in Appendix 1. This issue as well as the test case in Appendix 1 has been disclosed by the Evmos team to Oak Security during the audit.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. User distribution authorizations can be misused by malicious contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "The state transition functions of the distribution module require the user to authorize the to execute the SetWithdrawAddress, WithdrawDelegatorRewards, and caller WithdrawValidatorCommision functions. Failure to do so would result in the transaction's inability to interact with the distribution precompile. However, the distribution precompile lacks the functionality to revoke authorization once granted, resulting in smart contracts having access granted until the authorizations expiry. Although a user can revoke the authorization directly through the Cosmos SDKs authz module, this defeats the purpose of having the precompile in the rst place.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. The bech32 precompiler is not loaded in the EVM",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "The x/evm/keeper/precompiles.go:20-41, initializes the list of available precompiles. AvailablePrecompiles function, dened in However, the bech32 precompile is not added to the list, which renders the precompile inaccessible in the EVM. Additionally, return a valid precompile address. in precompiles/bech32/bech32.go:63, the Address function does not Consequently, the bech32 precompile cannot be executed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Validators and Redelegations queries are not callable from EVM precompiles",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "The validators and redelegations functions are available in the staking precompile at precompiles/staking/Staking.sol:201 and 227. However, the implementation of both functions in precompiles/staking/tx.go is missing, rendering the functions uncallable from EVM-based smart contracts.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Queries do not support pagination, enabling attackers to DOS the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "The query implementations do not support result pagination. This could be problematic since some of the implemented Cosmos SDK queries could return a large number of items. Some examples are the ValidatorSlashes and DelegationRewards queries dened in precompiles/distribution/distribution.go:160. Additionally, gas is not charged depending on the size of the query result size, but rather on the query input size. This could allow malicious actors to execute computationally and memory-heavy queries with a disproportionate gas cost, which could slow down block production up to the point where the chain halts.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. The Approve function does not allow ne-grained Coin allowances, allowing more Coins than intended in case of multiple messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "The Approve function dened in precompiles/staking/approve.go:32 iterates through a list of user-provided Cosmos SDK message types to allow a grantee to execute them on behalf of the user with the amount of user-specied Coins. However, because of the chosen input data structure, an encoded (Address, Coin, []string) tuple, it is not possible to specify how many Coins are to be used for each individual message. This results in allowing each message type with the Coin dened in the input parameter. Consequently, the total allowance will be dierent from the specied input since it will be equal to the cardinality of messages multiplied by the provided Coin. For example, a message with an allowance of 1ucoin and four message types will result in a total allowance of 4ucoin.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Truncated CW20 token transfer amount for CW20 tokens with more than 8 decimals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "The Wormhole token bridge contract truncates CW20 token amounts to 8 decimals. implies that a small amount of tokens (the so-called dust) stays in the This token-translator contract and is not transferred to the Wormhole token bridge. The user will hence receive fewer bridged CW20 tokens than initially transferred tokenfactory tokens.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Lack of conguration parameter validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "instantiation, During contract are WORMHOLE_CONTRACT token_bridge_contract InstantiateMsg message. the storage variables TOKEN_BRIDGE_CONTRACT and the initialized the src/contract.rs:33-39 with in values wormhole_contract supplied in and However, the provided values are missing address validation. Invalid strings would lead to a non-functioning contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Contracts are not compliant with the CW2 Migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "The token-translator contract does not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Redundant check on the submessage reply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "the submessage has been successful by The token-translator validates whether checking the replys result this check is unnecessary as the submessage is declared as SubMsg::reply_on_success. For SubMsg::reply_on_success submessages, the reply handler is only called upon the success of the submessage, making it impossible that the result is an Err variant. in src/contract.rs:94-97. However, Although not a security issue, unnecessary code can negatively impact maintainability and slightly increase gas consumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Unused WORMHOLE_CONTRACT storage variable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "During contract instantiation, the WORMHOLE_CONTRACT storage variable is initialized with the wormhole_contract value in src/contract.rs:37-39, which is supplied within the InstantiateMsg message. However, the value of WORMHOLE_CONTRACT is never read from storage or used in any other way.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Missing attributes on some message handlers responses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "informative attributes when The token-translator contract does not make use of returning a response in the convert_and_transfer, convert_bank_to_cw20, and convert_cw20_to_bank message handlers. This could negatively impact o-chain services that try to monitor the state of the protocol. In addition, although the contract does not save any owner eld in the storage. the instantiation function response includes a misleading owner attribute,",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Unhandled zero-amount transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "Using the ConvertAndTransfer and ConvertBankToCw20 messages, a user can send tokens to the contract. They are later validated in the context of whether more than one type of coin has been sent, but there is no validation enforcing that the transferred amount is greater than zero. As a consequence, the functions may unnecessarily perform operations, ending up with a panic, and Cw20ExecuteMsg::Transfer do not support transferring zero-amounts. TokenBridgeExecuteMsg::InitiateTransfer because both This leads to unnecessary gas consumption. Also, panics degrade the user experience since they do not provide any context why an error has occurred and how it can be resolved.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Autocompounder is vulnerable to share ination attack",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "compute_mint_amount The in contracts/autocompounder/src/handlers/reply.rs:130 is vulnerable to a share ination attack. A share ination attack represents a scenario where a malicious actor articially inates the supply of tokens, potentially manipulating the token's value and diluting other holders' shares. function Currently, the function computes the mint amount by using integer division. Due to the nature of integer division, results are always oored. This allows an attacker to inate their current shares while stealing funds from unsuspecting users. The compute_mint_amount is susceptible to this attack because the denominator of the integer division staked_lp can be manipulated for Astroport, representing the total staked amount of the proxy address. An example attack scenario: 1. The attacker makes the rst deposit of 1 token and thus receives one share",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Finally, the computed lp_tokens_withdraw_amount value will be evaluated to 7501 ((1/2) * 15002), earning the attacker an extra 2499 (7501-5002) liquidity pool tokens. redeems attacker shares. their The Recommendation We recommend enforcing a minimum amount that needs to be met in the rst deposit. This will greatly increase the cost of orchestrating a share ination attack. Note that it is common practice to mint dead shares to the protocol to increase the cost of the attack further. For more details, please see Astroports implementation. Status: Resolved 2. Attackers can cause batch unbondings to fail, preventing users from unstaking liquidity pool tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Unbonding cooldowns are not respected",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In the contracts/autocompounder/src/handlers/execute.rs:471-488, check_unbonding_cooldown function attempts to verify the last unbonding time has the LATEST_UNBONDING exceeded the minimum unbonding cooldown time. However, storage state is never stored anywhere in the codebase. Consequently, batch unbondings can be repeatedly performed without respecting the congured cooldown period. This issue also causes the query_latest_unbonding function to fail when loading LATEST_UNBONDING from the storage. We classify this issue as major because it aects the correct functioning of the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Compounding will fail for zero performance fees",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In contracts/autocompounder/src/handlers/reply.rs:190-200, the fees are deducted from rewards and sent to the commission address. However, the swap will fail if the performance fee is zero, preventing the auto-compounding from working successfully. Please see the test_zero_performance_fees test case to reproduce the issue. We classify this issue as minor because the manager contract can recover to a correct state by updating the performance fees.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Hard-coded slippage value makes deposits susceptible to sandwich attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "deposit in The a contracts/autocompounder/src/handlers/execute.rs:143 hard-coded max spread value of 5%. Depending on the pair that liquidity is being provided for, this may be a too large value, making the deposit functionality vulnerable to a sandwich attack. species function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Non-updatable conguration can not reect changes in staking contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "the In contracts/autocompounder/src/handlers/instantiate.rs:139-148, conguration and unbonding_period directly from the staking contract. However, there is no entry point to update this data. min_unbonding_cooldown dened taking both as is In case the aected parameters are modied in the staking contract, this will cause inconsistencies in the unbonding mechanism. The underlying messages directed to the staking contract could fail without the users being able to understand why, as the reported information will not reect the new limits.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Minting of zero vault tokens possible",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The autocompounder contract allows for the minting of zero shares upon depositing in some edge cases. This is possible as CW20 tokens now allow the minting of zero tokens, and the compute_mint_amount function does not perform further validation on the returned in amount contracts/autocompounder/src/handlers/reply.rs:135-143. minted shares be to of Users depositing small amounts of funds could receive zero shares in exchange, eectively losing access to those funds. In addition, this issue causes the Autocompounder is vulnerable to share ination attack to be even more lucrative for an attacker.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Unused variable in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In contracts/autocompounder/src/handlers/execute.rs:98, _staking_address variable is declared, but is not used. deposit the function in the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Lack of validation upon deposit lead to ineciencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The deposit function performs insucient validation on funds to be forwarded for liquidity provision in contracts/autocompounder/src/handlers/execute.rs:111-121. As the funds variable is not explicitly checked to contain pool assets only, the contract would try to provide liquidity with potentially erroneous assets in lines 140-144. This will cause the execution of all the code in the function to end up erroring, consuming an unnecessary amount of gas.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Remove TODO comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The codebase includes multiple TODO comments. It is best practice to remove all pending TODO items before releasing code to production.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Unused commented code in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In contracts/autocompounder/src/handlers/instantiate.rs:78-82, there is unused commented code. It is best practice to remove all unused commented code blocks before code is released toproduction.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Misleading variable name when withdrawing liquidity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In contracts/autocompounder/src/handlers/execute.rs:267 and 382, the swap_msg variable is set when calling withdraw_liquidity on the specic DEX. The swap_msg variable name is misleading, swaps are performed later on the DEX.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. calculate_withdrawals sets expiration to current block height which may become problematic if the function is exposed in a future upgrade",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "the contracts/autocompounder/src/handlers/execute.rs:411-414, In unbonding timestamp defaults to the current block height if config.unbonding_period is None. This is not a security concern in the current implementation, since the calculate_withdrawals function can only be called from the batch_unbond function, which ensures the unbonding period is Some(_), as seen in lines 161-163. If future code was introduced though that allows calling the calculate_withdrawals function without going through the batch_unbond functions, it might cause withdrawals to be unlocked immediately in the next block.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Users cannot query fees through smart queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In contracts/autocompounder/src/handlers/query.rs:16-42, no exposed queries return the fee congurations. Consequently, users cannot query the protocol's congured performance, deposit, and withdrawal fees.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Panicking macros and debugging code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The autocompounder contract uses Rust panicking macros to handle undesired situations in contracts/autocompounder/src/handlers/instantiate.rs:96 and 130. Panicking macros do not report meaningful error messages for users to understand what went wrong. In addition, an eprintln! statement which is typically used for debugging purposes can be found in contracts/autocompounder/src/handlers/execute.rs:357-360.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "20. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/autocompounder/Cargo.toml  packages/forty-two/Cargo.toml  packages/forty-two-boot/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "21. Additional funds sent to the contract are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The deposit function does not check whether additional native tokens are sent along the in contracts/autocompounder/src/handlers/execute.rs:89-157. message Any additional native tokens are not returned to the user, so they will be stuck in the contract forever. While blockchains generally do not protect users from sending funds to the wrong accounts, reverting extra funds increases the user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attackers can register unbonded validators in the keyshare module to submit malicious key shares, censor, or DoS the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "MsgRegisterValidator The in x/keyshare/keeper/msg_server_register_validator.go:12-38 enables the registration of a new validator in the keyshare module without conducting a validation check to verify if the provided validator is bonded. handler This allows an attacker to create and register a signicant number of unbonded validators within the keyshare module. Consequently, this vulnerability enables the attacker to potentially DoS the chain, engage in chain censorship, or submit malicious key shares. To execute chain censorship, attackers can register an extensive quantity of unbonded validators. Since the creation of an aggregate key necessitates reaching a threshold that depends on the number of validators, a substantial increase in the number of validators can it unfeasible for legitimate elevate the threshold. This elevated threshold can render validators to create the aggregated key. Another possible attack scenario involves the submission of malicious key shares, where a single entity possesses all of them, front-running legitimate validators. In this scenario, the attacker can generate the aggregated key and decrypt transactions. transaction Furthermore, validators registered in the keyshare module are iterated over during the in SendKeyshare x/keyshare/keeper/msg_server_send_keyshare.go:81-87, 133-148, and 151. Consequently, this message can place excessive strain on the node's resources, potentially resulting in a slowdown of the chain or, in more severe circumstances, a complete halt. handling without the execution of limitations any gas imposing",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attackers can register validators in the staking module to DoS the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "the execution During in x/keyshare/module.go:162, an iteration is performed over all the validators registered in the staking module, regardless of their bonded status. BeginBlock specically function, the of Since the staking module allows anyone to register a validator, an attacker could register a substantial number of them, resulting in the BeginBlock function iterating through all of these validators. As a consequence, the execution of the BeginBlock function will consume more time and resources than anticipated, potentially leading to a slowdown of the chain or, in severe cases, a complete halt. Furthermore, it is important to note that a signicant quantity of validators within the staking module can contribute to increased resource demands during the execution of the RegisterValidator message handler. iterates through all Specically, in x/keyshare/keeper/msg_server_register_validator.go:25, the handler imposing any gas limitations. registered validators without Consequently, this message can place excessive strain on the node's resources, potentially resulting in a slowdown of the chain or, in more severe circumstances, a complete halt. the execution of",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Validators can censor the execution of encrypted transactions at a particular block height without being punished",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "Validators can censor encrypted transactions at a particular block height by not submitting their key shares. There is no mechanism in place to punish idle validators who do not submit key shares. This would aect the reliability of the transaction execution since there is no guarantee for users that their transaction will be executed. Additionally, transactions that are not executed at the target height are discarded and there is no fallback mechanism in place to try to execute them in the next block.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Encrypted transaction execution does not charge gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "The execution of submitted encrypted transactions occurs within the BeginBlock function at the designated target height, as dened in x/pep/module.go:513. However, due to the nature of these transactions being executed directly in the BeginBlock there is currently no mechanism in place to invoke the function without user initiation, AnteHandler and charge the user for gas consumption. This vulnerability can potentially be exploited by attackers to carry out a variety of attacks. For instance, attackers could attempt to launch a Denial-of-Service (DoS) attack on the chain, saturate the block space by ooding it with transactions, or execute IBC transactions with the intent of targeting the funds of relayers.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Attackers can overwrite legitimate AggregateKeyShares making the chain unable to execute transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "CreateAggregatedKeyShare The in x/pep/keeper/msg_server_aggregated_key_share.go:10 enables anyone to submit the AggregatedKeyShare to for a particular block height. function, dened Since the validation of the submitted key is executed only in the BeginBlock function, attackers could be able to overwrite the legit key submitted by FairyPort with an invalid one. The only condition needed is that their transaction is executed after the legitimate one. Consequently, the chain will not be able to decrypt and process transactions for that block height.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Attackers can submit a large number of MsgSubmitEncryptedTx targeting the same block height to DoS the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "SubmitEncryptedTx The in x/pep/keeper/msg_server_submit_encrypted_tx.go:12 enables users to submit encrypted transactions that will be executed at the dened TargetBlockHeight. function, dened Those transactions are then iterated over, and each one is decrypted and executed at the target block height in the BeginBlock function in line x/pep/module.go:223. Since there is no limit to the number of transactions that could be registered to be executed at a certain block height, attackers could submit a large amount of such transactions in order to spam the network. It is worth noting that a transaction can contain multiple messages and that the attacker will only pay for the byte length of the encrypted transaction. If the PEP module is deployed on chains that support CosmWasm, it opens up the possibility of deploying ad-hoc contracts, dispatching a large number of messages with a lightweight transaction, and executing computationally intensive operations with minimal cost. the iteration, decoding, and execution of Consequently, those transactions can place excessive strain on the node's resources, potentially resulting in a slowdown of the chain or, in more severe circumstances, a complete halt.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Attackers can submit a transaction with a large number of MsgCreateAggregatedKeyShare messages to DoS the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "ProcessUnconfirmedTxs The in x/pep/keeper/unconfirmed_txs.go:21 is executed during the BeginBlock function and iterates over a set of unconrmed transactions and their inner messages in order to nd MsgCreateAggregatedKeyShare messages and process them. function dened Since there is no limit to the number of MsgCreateAggregatedKeyShare messages in the mempool, except the mempool size, and no gas for adding them is charged to the sender because the transactions are not directly executed, an attacker could craft and send a large number of transactions containing a large amount of MsgCreateAggregatedKeyShare messages in order to DoS attack the chain. Consequently, the iteration and execution of those transactions can place excessive strain on the node's resources, potentially resulting in a slowdown of the chain or, in more severe circumstances, a complete halt.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Logged/emitted keys combined with ability to aggregate keys for future block heights allows decryption of transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "In x/keyshare/keeper/msg_server_send_keyshare.go:165-174, after successful creation of the aggregated key, the key is stored, emitted in an event, and logged in the console. Since it is possible for validators to submit key shares and create the aggregated key for every height, including for blocks in the future, such keys may be unintentionally exposed, allowing anyone to decrypt transactions and predict future chain states. Users can simply monitor the chain state, listen for emitted events, or check the console of a node they run to retrieve the key.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "9. If MsgCreateAggregatedKeyShare is not in the rst 30 transactions in the mempool, blocks are executed without the decryption key",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "During the pep modules BeginBlock function, MsgCreateAggregatedKeyShare messages are retrieved from the mempool in order to execute them before other transactions in line x/pep/module.go:188. This is needed in order to have the current block decryption key in the store. However, since the tmcore.UnconfirmedTxs function returns only the rst 30 transactions in the mempool, there is no guarantee that MsgCreateAggregatedKeyShare messages are retrieved and executed before other transactions. Consequently, the decryption key of the current block may not be processed and all the encrypted transactions with target execution at the current height might be skipped.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "10. Insucient validation of PepNonce can lead to transaction replay attack",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "In x/pep/module.go:457-460, during the processing of encrypted transactions, the PepNonce is utilized to prevent replay attacks. In the current depends on a comparison between a user's nonce and a stored nonce. implementation, whether a transaction is accepted or rejected primarily Specically, if the user's nonce is lower than the stored nonce, the transaction is denied. The system operates by pulling the current stored nonce, increasing it by 1, and then setting this incremented nonce minus 1 as the anticipated nonce. Afterward, the system checks whether the user's nonce is less than this anticipated nonce. If it is, the transaction is disallowed. This mechanism can be exploited as it allows a replay of the rst transaction with nonce 1. Consider this scenario: The initial value of the stored nonce is 0, and a user starts o with a nonce of 1. This transaction is validated. As per a code condition, if the user's nonce is greater than the anticipated nonce, the current nonce is updated to match the user's nonce. Consequently, the stored nonce becomes 1. Herein lies the possibility of a replay attack due to incorrect calculations. When the user attempts to execute the same transaction for a second time, using a nonce of 1, the anticipated nonce is also 1. According to the system's acceptance criteria, a transaction fails if the user's nonce is less than the anticipated nonce. However, since 1 isn't less than 1, this condition fails, resulting in the wrongful acceptance of the replayed transaction. Please refer to Appendix 1 for a detailed dry run of the code, including ow diagrams, to illustrate the scenario where transactions can be replayed.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "11. Attackers could overwrite the active public key via IBC, leading to the inability of executing encrypted transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "In x/pep/keeper/current_keys.go:19, during the EndBlock function, the PEP module queries the active public key using the Inter-Blockchain Communication (IBC) protocol. To construct the IBC packet, it retrieves the source channel by calling the k.getChannel function, which retrieves the value stored with a prex key determined through is KeyPrefix(\"pep-channel-\"). the set OnChanOpenConfirm method of in x/pep/module_ibc.go:115. the IBC protocol However, it is important to note that this value can be overwritten whenever a new channel connects. initially during value This to manipulate This presents a potential vulnerability, as a malicious actor can create a fraudulent IBC in channel A OnAcknowledgementPacket manipulated active public key leads to the inability to decrypt and execute encrypted transactions. key x/pep/keeper/current_keys.go:147. stored in public active value the the of",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "12. Insucient verication of submitted key shares could lead to the inability to aggregate the key",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "the parseKeyShareCommitment In in x/keyshare/keeper/msg_server_send_keyshare.go:35, all inputs to this method, including msg.Message, msg.Commitment, msg.KeyShareIndex, and ibeID, are provided by the user. function, dened The concern is that a malicious validator can generate their own local key share and commitments within send_key_share does not raise any errors to detect potential manipulations. parseKeyShareCommitment method since used the Consequently, if a manipulated message is included, and the key share stored, it could lead to the failure of the aggregated key share generation process.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "13. TrustedAddresses are a single point of failure",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "The protocol depends on the participation of TrustedAddresses and stored in Params, to regularly update the public key. third-party actors, denoted as However, this process lacks an incentivization mechanism and relies on a closed set of o-chain actors. Consequently, continual availability of these actors and the accuracy of the information they provide. the operational eectiveness of the chain is entirely dependent on the This poses a centralization issue which leads to a single point of failure for the chain operation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Missing validation in keyshare modules Params",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "During the validation process of the Params within the keyshare module, specically in the code the the input slice is a string. validateTrustedAddresses function solely veries that Address validation is currently not performed. x/keyshare/types/params.go:84-91, segment located in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Missing MsgSendKeyshare input elds validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "the validation process During x/keyshare/types/message_send_keyshare.go:44-50, function solely veries that the sender address is valid. the of MsgSendKeyshare, the specically in ValidateBasic Since the message contains other blockHeight, they should also be validated before handling the message. input data like message, commitment, and",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Missing validations of GenesisState",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "During the validation process of x/pep/types/genesis.go:20-54, PepNonces keys are valid addresses. the pep modules GenesisState, specically in the Validate function does not check that Similarly, during the validation of the keyshare modules GenesisState in x/keyshare/types/genesis.go, the Validate function does not check if there is a duplicate Validator or ConsAddr in lines 27-33.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Amino codec must be registered to support users with hardware devices like Ledger",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "In x/keyshare/types/codec.go:33 and x/pep/types/codec.go:29, Amino should be used to register all interfaces and concrete types for the keyshare and pep modules. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Parsing query command ags are ignored",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "CLI query in registered Most use and x/keyshare/client/cli/query.go GetClientContextFromCmd to get Context, which does not read query command ags. in GetQueryCmd x/pep/client/cli/query.go commands function the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. MsgSendKeyshare transaction silently fails",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "SendKeyshare The in x/keyshare/keeper/msg_server_send_keyshare.go:20, silently fails if the sent key share is not valid. function, dened Consequently, a third party that executes this transaction cannot correctly handle a failure, and users are not getting feedback on the execution status.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "20. Use of magic numbers decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "In x/keyshare/keeper/msg_server_send_keyshare.go:51 a hard-coded number literal without context or a description is used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "21. Inecient execution of GetAllValidators",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "In x/keyshare/keeper/msg_server_register_validator.go:24, GetAllValidators is called in the native staking module to obtain all validators. The purpose of obtaining all validators is to verify if any of the validator addresses match the address of the transaction sender. Querying all validators is inecient though, since there is a GetValidator function available in the staking module that returns a particular validator. Replacing the GetAllValidators function with the GetValidator function will clean up the code and reduce resource as well as gas consumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "22. Open issues in a dependency",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "An open issue has been identied by Trail of Bits in the Kilic/bls12-381 library, regarding zero value deserialization due to internal modulo operations. The mentioned library is utilized in the code and it is crucial to verify that the deserialization issue does not have any adverse eects on the code's functionality and security.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "23. Missing usage description for transaction and query CLI commands",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "The transaction and query CLI commands of the keyshare and pep modules are missing a long message to describe their usage, which could be helpful for users and developers.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "24. Duplicated ValidateBasic invocation in CLI",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "transaction All commands x/keyshare/client/cli/tx.go msg.ValidateBasic function before calling GenerateOrBroadcastTxCLI. x/pep/client/cli/tx.go registered and GetTxCmd CLI the in function call in the As msg.ValidateBasic is already called inside the GenerateOrBroadcastTxCLI, this is an unnecessary and duplicated invocation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "25. Non-standard management of external functions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "to the ocial According in https://docs.cosmos.network/main/building-modules/keeper, external keepers are listed in the internal keepers type denition as interfaces. In the audited codebase, however, the keepers type denition of both the keyshare and pep modules directly depend on external keepers. This goes against loose-coupling best practices. documentation Cosmos SDK",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "26. Miscellaneous code quality comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fairblock/2023-10-02 Audit Report - FairBlock fairyring v1.0.pdf",
        "body": "Throughout the codebase, instances of unused imports and code have been found.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Subwallet factory updates could lead to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "During the creation of a subwallet, the addresses of the Anchor Money Market and Terra token contracts are passed from the subwallet factory cong to the newly instantiated wallet - see contracts/subwallet-factory/src/contract.rs:107. These addresses are then stored in the cong of the new subwallet. The subwallet factory contract owner is able to update the addresses of the Anchor Money Market and Terra token. These changes would not be reected in the existing subwallets. This could lead the subwallets to use incorrect addresses for the Anchor market and Terra token.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Product factory updates could lead to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "During the creation of a xed recurring subscription contract the address of the job registry contract see contracts/sub1-fixed-recurring-subscriptions/src/contract.rs:74. This address is then stored in the cong of the subscription contract. specied is - The product factory contract is able to update the address of the job registry contract. This change would not be reected in the existing recurring subscription contract  unlike the protocol fee and other conguration parameters dened in the product factory, which are queried prior to use rather than stored. This could lead the subscriptions to use an incorrect address for the job registry contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Protocol fee decimal places incorrectly specied",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "The protocol fee is dened in basis points during instantiation of the product-factory contract cong. During both, the instantiation and update of the cong, the protocol fee is veried to ensure that is less than the maximum of 5%. As the fee is represented in basis points 5% is dened as 500, which implies that in xed-point arithmetic 4 decimal places are being used - i.e. 500 / 10,000 = 0.05. On lines sub1-fixed-recurring-subscriptions/src/contract.rs:346 and 697, decimal places are applied incorrectly when calculating the ratio of the protocol fee. In each case, the protocol fee could be greater than 100%. Which could lead to users being charged excessive amounts for using the protocol.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Owner cannot freeze admins",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "the function executing When in contracts/admin-core/src/contract.rs:84, the contract veries that the sender is a whitelisted admin. Once this function is executed the contract owner will be unable to append new admins or otherwise unfreeze the admin list. This is contrary to the documentation denition of the owner being the highest-privilege access. execute_freeze, found as Further access verication to the execute_freeze function uses the can_modify function which checks that the sender is on the admin list. However, in the case that the owners address is not on said list this check would fail. Preventing the owner from successfully calling the execute_freeze function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Owner cannot execute set permissions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "le contracts/subwallet/src/contract.rs:389 In function execute_set_permissions veries that the message sender is an admin whitelisted for the wallet. However, if the sender is the owner and not present on the admin whitelist then the execution will fail. As the owner has the highest-privilege access to a wallet this is contrary to the documentation. the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Admin whitelist cannot be unfrozen",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "le contracts/admin-core/src/contract.rs:54 In function execute_freeze freezes the list of whitelisted admins for a suberra wallet. Once frozen there is no way to reverse this decision, even for the wallet owner. It may be necessary to remove, or add, an admin due to scenarios such as the case of a leaked private key. the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Protocol fee decimal places should be dened as constants",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "The protocol fee is dened in basis points during instantiation of the product-factory contract cong. During both, the instantiation and update of the cong, the protocol fee is veried to ensure that is less than the maximum of 5%. As the fee is represented in basis points 5% is dened as 500, which implies that in xed-point arithmetic 4 decimal places are being used - i.e. 500 / 10,000 = 0.05. However, throughout the code base, there is no constant variable dened to use in protocol fee calculations. Rather values are used on an ad-hoc basis, including:  sub1-fixed-recurring-subscriptions/src/contract.rs:271  sub1-fixed-recurring-subscriptions/src/contract.rs:346  sub1-fixed-recurring-subscriptions/src/contract.rs:697  sub2-p2p-recurring-transfers/src/contract.rs:451",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Unbounded number of contract admins",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "There is no limit dened in contracts/admin-core/src/state.rs:10 to the number of addresses that can be whitelisted as Suberra wallet admins. Should the number of admins be excessively large this could make execution functions costly and query functions unperformant. In extreme cases, this could cause the querier to run out of gas.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Total number of subscriptions increments on cancellation undo",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "When a cancelled subscription is undone through the execute_subscribe function, contracts/sub1-fixed-recurring-subscriptions/src/contract.rs:389, the function create_subscription is called. This function increments the total number of In the case of an undone cancellation, this leads to the number of subscriptions by 1. subscriptions being incremented unnecessarily.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Excessive grant duration, lack of revocation mechanism, and multiple delegate grantees",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf",
        "body": "the In contracts/puppeteer/src/contract.rs:567, during the execution of execute_setup_protocol function, a GenericAuthorization grant is created and executed on the ICA to allow the delegate_grantee to send MsgDelegate messages. However, there are several issues with the current implementation:  The grant is constructed with an expiration of 120 years and one month, an excessively long duration.  There is no mechanism to revoke the grant, which could cause issues if the delegate_grantee account needs to be changed.  It allows multiple delegate_grantee accounts to hold the grant simultaneously, which could lead to mismanagement and unauthorized actions.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Iterations over the receivers might run out of gas, failing all distributions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf",
        "body": "In contracts/splitter/src/contract.rs:80-89, function iterates over all congured receivers. the execute_distribute If the number of receivers is too large, the operation may consume excessive gas, potentially making the execute_distribute functionality unusable due to gas exhaustion. We are reporting this issue with minor severity since the cardinality of receivers is expected to be limited and only the contract owner has the ability to set them.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Missing validation in the splitter contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf",
        "body": "In contracts/splitter/src/contract.rs:21, during the execution of the instantiate function, the splitter contract stores the Config without performing any validation. in Similarly, the ExecuteMsg::UpdateConfig allows the owner to update the splitter contract Config without performing any validation. contracts/splitter/src/contract.rs:53, Specically, the receivers vector should be checked to ensure it does not contain duplicates and only includes valid addresses. Additionally, the amount dened for the fees should be veried to be less than 10000u128.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Centralization and misconguration risks in splitter contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf",
        "body": "the splitter conguration is highly In contracts/splitter/src/contract.rs, versatile, allowing arbitrary conguration to route funds and set fee shares as they are collected. This exibility introduces a centralization concern, for example, if administrative errors occur. Consequently, funds could be redistributed incorrectly since distributions are permissionless.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing validation for the timeout parameter in the puppeteer contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf",
        "body": "In contracts/puppeteer/src/contract.rs:90, the instantiate function stores the timeout value without performing any validation. This lack of validation can lead to issues if the timeout is set to zero or a relatively small value. Specically, transactions to fail and Interchain Account (ICA) channels to close prematurely. if the timeout is too short, it can cause Inter-Blockchain Communication (IBC)",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Vulnerability in curve25519-dalek package",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf",
        "body": "The curve25519-dalek package version in use is vulnerable to timing variability, as reported in RUSTSEC-2024-0344. Timing variability of any kind is problematic when working with potentially secret values such as elliptic curve scalars, and such issues can potentially leak private keys and other secrets. Such a problem was recently discovered in curve25519-dalek. The Scalar29::sub (32-bit) and Scalar52::sub (64-bit) functions contained usage of a mask value inside a loop where LLVM saw an opportunity to insert a branch instruction ( jns on x86) to conditionally bypass this code section when the mask value is set to zero",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Partial support to CW2 contract versioning standard",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf",
        "body": "In contracts/splitter/src/contract.rs, the instantiate function is responsible for initializing the contract. However, stores the actual CONTRACT_VERSION. it currently lacks a call to the cw2::set_contract_version function, which This omission can result in diculties with contract version tracking and management.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Use of magic numbers decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-12 Audit Report - Drop Contracts Updates v1.0.pdf",
        "body": "In contracts/factory/src/contract.rs:634, a hard-coded number literal is used without context or a description. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attackers can trigger a share ination attack to steal user funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf",
        "body": "In ixo-swap/src/contract.rs:265, the get_lp_token_amount_to_mint function mints the LP token amount based on the sent amount if the total supply is zero. This is problematic because attackers can execute a share ination attack to steal funds provided by the user, resulting in a loss of funds scenario. An attack scenario is illustrated below: 1. The contract is newly instantiated",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. The attacker redeems their LP tokens for the underlying liquidity, which includes the users funds. Consequently, the funds provided by the user are stolen by the attacker. Since the LP tokens total supply reverts back to zero after exploitation, the attacker can repeatedly execute this attack to steal funds from subsequent users who provide liquidity to the pool. Please refer reproduce this issue. to the test_share_inflation_attack test case in the appendix to Recommendation We recommend burning a small number of dead shares to the pool contract when providing initial liquidity. Status: Resolved 2. Attackers can swap lower-value tokens for valuable assets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Lack of attributes emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf",
        "body": "In several instances of the codebase, the emitted attributes do not include information about the entry points and values in ixo-swap/src/contract.rs:  The execute_add_liquidity, execute_remove_liquidity, and execute_swap, execute_update_config functions does not emit the action attribute to be the called function. Consider adding the attribute in the response eld, similar to line 241.  The execute_freeze_deposits function should include the freeze value in line execute_pass_through_swap, 241.  The execute_swap function should include the recipient address in line 1117.  The reply entry point should include the LP token address in line 1400. It is best practice to emit events and attributes to improve the usability of the contracts and to support o-chain event listeners and blockchain indexers.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. execute_freeze_deposits can be called with the same status",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf",
        "body": "In ixo-swap/src/contract.rs:227, the execute_freeze_deposits function does not validate that the freeze status is not equal to the FROZEN state status. For example, if the FROZEN state is true, calling the function with freeze value as true will not trigger any actual changes to the contract as the results are the same. Consequently, this may mislead o-chain listeners and indexers since no actual changes are made to the contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. FROZEN storage state is not exposed through smart queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf",
        "body": "the query entry point does not expose the In ixo-swap/src/contract.rs:1281, FROZEN storage state value through smart queries. This forces third-party contracts to perform a raw query to read the stored value, which is error-prone and decreases user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Unused error message in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf",
        "body": "In ixo-swap/src/error.rs:13, the NoneError is dened but not implemented across the codebase. Unused code reduces the code readability and maintainability in the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Panic usage should be avoided",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf",
        "body": "ixo-swap/src/token_amount.rs:20 In and get_single functions panic with a plain error message if the provided TokenAmount is incorrect. This decreases user experience as users will not be able to interpret the actual error that occurred. get_multiple and 29, the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Outstanding TODO comment in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf",
        "body": "In ixo-swap/src/contract.rs:1323, the query_info function contains a TODO comment to retrieve the total supply. However, the query for the LP tokens total supply has already been implemented in line 1329.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. In-house implementation of well-known features is discouraged",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-03-15 Audit Report - IxoSwap v1.0.pdf",
        "body": "In ixo-swap/src/contract.rs:493-505, the validate_input_amount function validates the user sent the actual funds as specied based on the given_amount and given_denom parameters. Although no vulnerability was found aecting the function, well-known libraries that are continuously reviewed by the community. it is still best practice to use",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Liquidation penalty is not validated during struct initialization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "In cadence/contracts/LendingComptroller.cdc:125-127 of the MoneyMarket repository, the liquidation penalty is not validated to be below 1.0 (ie. 100%) during the Market struct initialization. As a result, misconguring the liquidation penalty value might cause a liquidator to receive more funds than intended, causing a loss of funds for the borrower. We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Interest rate model capability is not validated during update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "In cadence/contracts/LendingPool.cdc:959-970 of the MoneyMarket repository, the newly set interest rate model capability is not validated to exist and can be borrowed. As a result, setting a non-existing capability for the interest rate model would cause several accrueInterestReadonly, functions getPoolBorrowRateScaled, and getPoolSupplyAprScaled. getPoolBorrowAprScaled contract notably fail, the to in We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Local resource reference can be used for eciency",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "In cadence/contracts/PriceOracle.cdc:128-130 of the Oracle repository, the certificate argument is passed as an OracleCertificate resource reference which is implemented by the OracleInterface contract interface. The certificate is then veried by checking its type against the local OracleCertificate resource to make sure the caller can only be the current contract. This validation can be removed to introduce eciency by only accepting the local OracleCertificate resource reference as an argument.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Feeders can set non expirable prices by changing the expired duration to arbitrary high value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "In cadence/contracts/PriceOracle.cdc:122-124 of the Oracle repository, feeders can set an arbitrary high expired duration which makes their prices non-expirable. With that said, this doesnt directly aect the prices of assets until more than half of the feeders act maliciously and set the expired duration to an arbitrarily high value. We consider this to be a minor issue since this requires more than half of the feeders to be malicious.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Sorting algorithm can be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "the current In cadence/contracts/PriceOracle.cdc:222 of the Oracle repository, sorting algorithm is inecient due to time complexity. Since takeMedianPrice functionality will be called many times, this causes every other operation that is dependent on it to become gas inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Typographical errors found in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "there were In cadence/contracts/PriceOracle.cdc of several typographical errors found in lines 104 and 383. Specically, the word oralce_public should be replaced with oracle_public while the word _ExpriedDuration should be replaced with _ExpiredDuration. the Oracle repository,",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Possible chances of path collisions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "In the MoneyMarket repository, the following storage and public paths are very generic:  cadence/contracts/LendingPool:1086  cadence/contracts/LendingPool:1088  cadence/contracts/LendingPool:1089 This might lead to path collisions, potentially incorrect data access or resources overwriting.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Undelivered transfers require fee to be refunded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf",
        "body": "In packages/xtoken-contract/contracts/base/XTokenBacking.sol:121 and packages/xtoken-contract/contracts/base/XTokenIssuing.sol:82 transfers could fail due to the daily limit set by the DAO. This is not in control of the sender because the limit could be set or consumed after the transfer has been initiated but before it is executed. is free user The a xRollbackBurnAndXUnlock or xRollbackLockAndXIssue. However, covering the protocolFee. the transfer using the function this requires to request refund of It also requires having an account on the target chain, namely _rollbackAccount, to submit the transaction. This condition should be documented properly and made clear to the users of the bridge.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Centralization risks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf",
        "body": "The contracts contain a few centralization concerns that users should be aware of:  The xToken contracts implement the guard role. While it might be intended as a safety measure to stop an attack after it is deployed and before it is executed, applying it during a real incident creates a lot of post-incident remediation work. This is caused by ultimately replacing all receivers, both on backing and issuing chains, by the guard. After a potential incident all the transfers would require manual completion or manual refund.  The operator role, which is currently an externally owned account set by the DAO, has the privilege to call the pause, unpause, and setProtocolFee functions at any time. This includes disabling slashing, liquidity withdrawals, and setting protocol fees to any amount at any time.  The function updateXToken could be used to make issued tokens non-redeemable.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Daily limits are not communicated across the bridge, leading to ineciencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf",
        "body": "In packages/xtoken-contract/contracts/base/XTokenBridgeBase.sol:163, the setDailyLimit function is dened and can be used to limit the amount of tokens In particular, this limit is checked via calls to function issued or unlocked during a day. in expendDailyLimit and packages/xtoken-contract/contracts/base/XTokenBacking.sol:121 packages/xtoken-contract/contracts/base/XTokenIssuing.sol:82. When this limit is reached, the transfer can be refunded on the other side of the bridge. However, this introduces several ineciencies, since the following steps are or need to be unnecessarily executed:  the tokens have been locked or burned on the remote chain  the underlying messaging channel has been used to pass the transfer request  the user has spent fees which will not be refunded  one more message passing back across the bridge is needed to refund the tokens  the user needs either to request the refund and cover the protocol fee, or submit a proposal to the DAO which would take time to be processed",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Input validation could be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf",
        "body": "In several of functions, the input is not properly validated:  In lockAndXIssue le packages/xtoken-contract/contracts/base/XTokenBacking.sol, is not validated that the amount is greater than zero. A value of zero will revert on the target chain, resulting in wasted gas/transfer costs. within the it  The validation that _amount is greater than zero packages/xtoken-contract/contracts/base/XTokenIssuing.sol:81 should the lockAndXIssue packages/xtoken-contract/contracts/base/XTokenBacking.sol order to avoid the redundant lock. function moved be to in in in  In other functions of the xToken contracts, it is not checked whether the submitted addresses and/or amounts are not equal to zero. This can lead to unintended behavior in out of scope contracts.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. The contract locks up ETH received",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf",
        "body": "The XTokenBridgeBase contract is able to receive ETH. However, there is currently no way to retrieve ETH from the contract. The funds will be locked up.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Redundant logic in the updateXToken function when approving xToken",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf",
        "body": "The updateXToken function of the XTokenIssuing contract contains the following check: require(IXToken(_xToken).approve(address(this), type(uint256).max) == true, \"approve xtoken failed\"); This check contains a redundant condition which reduces readability and increases the gas fees. There is no need to check whether approve returns true or false, as the require itself already does this.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Excessive storage usage in XTokenBacking contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf",
        "body": "In packages/xtoken-contract/contracts/base/XTokenBacking.sol:15 the mapping originalToken2xTokens from type bytes to type address is dened. This mapping is used to store addresses of the mapped tokens. However, the only reading of this mapping in XTokenBacking.sol:63 discards the actual value and only checks that it is not zero. This validation could be done during the address storage.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Transfer state mappings could be streamlined",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf",
        "body": "In packages/xtoken-contract/contracts/base/XTokenBridgeBase.sol:39 the mapping requestInfos is dened. This mapping is used to track if a transfer was requested or refunded. Further, in the same le, in line 44 the mapping filledTransfers is dened, which is used to track the delivered and refunded states of a transfer. These two mappings are used intricately to check all possible cases in the transfer ow. However, all possible states of a transfer could be easily enumerated as REQUESTED, DELIVERED, REFUND_REQUESTED, and REFUNDED.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Miscellaneous",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix xToken v1.0.pdf",
        "body": " The parameter name originalSender is misleadingly used in several occurrences, where it is not related to the original token: - - It can mean the party redeemed the xToken in XTokenBacking.sol:114 and XTokenIssuing.sol:134 It can mean a sender on either chain in XTokenBridgeBase.sol:150  There are various typos and grammatical errors in the contracts. We recommend to: - - - - - Replace request exist with this request already exists. Replace request not exist with this request does not exist. Replace request has been refund with this request has already been refunded. Replace issuxToken with issueXToken. Replace not enough fee with not enough fees.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Bridge operator has full control over funds and relies on backend service controlling a hot wallet",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The centralized design of the bridge allows the bridge operator full access to the users funds. This means the operating entity has to be fully trusted since it can withdraw users funds and censor transactions. The design comes with additional security risks in the form of a backend process (MONITOR) that manages the bridge through a single private key, which is used as a hot wallet. In case of the server being compromised and an attacker gaining access to the key, all funds are at risk, and transactions can be censored or executed at will. Furthermore, a potential DoS attack on the MONITOR could block the entire bridge functionality.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Addresses are encoded as string and not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The function receiveTokens takes a string parameter as the destination address. The reasoning behind this seems to be that some receiver blockchains use dierent address encoding. However, this means that addresses are not validated and tokens might be sent to an invalid address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Adding of new blockchains can be front-run to avoid paying the minimal fee",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "Adding and conguring the support for a new blockchain requires multiple transactions: - addBlockchain - setMinorTokenAmount - setMinGasPrice The function receiveTokens can be called immediately after the rst addBlockchain transaction. Such a call would allow the usage of the bridge with a zero minBRZFee. This attack might be worthwhile for an attacker if a user wants to use the bridge with a high fee.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Unused sender parameter in accept transfer function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "In the acceptTransfer function, the sender parameter is passed but not included in the transaction id calculation. Whilst the sender information does not add security, it might add value to the calculation of the transaction id for o-chain purposes.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Outdated dependencies in build- and deployment system",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The build- and deployment system has several outdated dependencies with known security vulnerabilities. Some of these relate to cryptographic primitives used for deployment.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Inecient array data structure for tracking supported blockchains",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The dierent blockchains supported are stored in an array of strings. This requires an iteration of the entire list in functions like existsBlockchain.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Potential data structure optimization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "mapping(string => uint256) private minBRZFee; mapping(string => uint256) private minGasPrice; mapping(string => uint256) private minTokenAmount;",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Oracle functionality mixed with bridge logic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The minBRZFee variable is required to calculate fees in the receiveTokens function. The calculation happens on-chain based on quoteETH_BRZ, gasAcceptTransfer and minGasPrice in the _updateMinBRZFee function. Currently, these variables are set by admin calls. In future versions, the quoteETH_BRZ will be provided by oracles, according to the code comments. The contract is already laid out to include oracle support in a future version. However, is not considered best practice due to poor separation of concerns. integrating oracle functionality into the bridge module itself",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Admin role also controls oracle",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The information required to calculate minBRZFee is currently provided by the admin role. This concentrates a lot of functionality in a single private key managed by the admin server (MONITOR).",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Slightly outdated OpenZeppelin release used",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The codebase imports a relatively recent version of the OpenZeppelin smart contract library. However, there have been recent security releases that x vulnerabilities. These issues seem not to apply in the present use case of the contracts. However, we recommend using the latest security release.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Unnecessary use of modier for authorization on private method",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The private _processTransaction method is covered by access control modiers. Authorization modiers like onlyMonitor or whenNotPaused are only required for external or public methods but not for private ones. In this particular case, they are already covered in the caller function.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Unnecessary long digit constant",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "A constant is dened to represent 10^18 for token decimal conversion: uint256 public constant ETH_IN_WEI = 1000000000000000000;",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Gas Optimizations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The contracts can be optimized for more ecient gas usage in multiple places.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Querying all strategies or user strategies of the factory might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2021-08-18 Audit Report - Apollo.pdf",
        "body": "The factorys GetStrategies and GetUserStrategies queries are using unbounded storage iterators in contracts/apollo-factory/src/state.rs:91 and 132. As more strategies are added to the factory, the gas cost of running those queries does increase. This is not a security concern for Apollo, since those queries are not used anywhere within the current codebase. Other projects could rely on the queries though. If they do, a high amount of strategies could lead to the queries running out of gas.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Failure in the Sudo handler causes funds to be left in the ibc-transfer contract, allowing attackers to steal them",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf",
        "body": "Both the Osmosis and Neutron ibc-transfer contracts do not validate the caller of the IbcTransfer message to be the entry-point contract. This is problematic because the entry-point contract is responsible for ensuring the funds are sent according to the specied amount, as seen in contracts/entry-point/src/execute.rs:312-316. Specically, the current ibc-transfer implementation allows the caller to send zero funds while specifying a valid coin amount that exists in the contract. Normally, this should not be a problem since the contract is not intended to hold any funds, as the funds are either sent to refunded back to the recovery address in case of an other chains through IBC or acknowledgment error or timeout. The issue arises when there is an error when refunding the funds to the recovery address. In this case, the funds will be left in the contract and not refunded to the recovery address. This allows an attacker to execute the IbcTransfer message while specifying the coin parameter as the leftover funds and steal them by specifying the receiver as their address on another chain. This is possible because the ibc-transfer contract does not check that the coin parameter is what is provided in the info.funds of the message, as this check is performed by the entry-point contract. The above situation would likely happen when there is an error when refunding the recovery address using the bank message. For example, suppose Neutron governance updates the timeout fee to 0 funds. This would cause the bank message to fail as Cosmos SDK disallows (see amount sending contracts/networks/neutron/ibc-transfer/src/contract.rs:182). funds zero of a Additionally, this might happen when a user calls the ibc-transfer contract directly without going through the entry-point contract. Since the contract assumes the recover_address is validated by the caller in line 84, an error will occur in line 211 if the provided address is invalid. This will create a situation where the ibc-transfer contract is holding funds. Consequently, an attacker can steal funds from the contract by specifying the amount of coin held and sending them over to an address they control on another chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Swap contracts do not perform sender validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf",
        "body": "Both the Osmosis and Neutron swap contracts do not validate that the execute_swap function is the entry-point contract. The entry-point contract performs essential validations and properly constructs the Swap message. the caller of is that directly One example of a potential misconguration that could be introduced by calling the swap function in contract create_astroport_swap_msg not does contracts/networks/neutron/swap/src/contract.rs:121-123 enforce a max_spread or minimum_receive value. the entry-point contracts execute_post_swap_action function will eectively enforce a slippage check. If a user calls the swap contract directly, there is no guarantee of the amounts to be received. In contrast, the This in also contracts/networks/osmosis/swap/src/contract.rs:115, as the osmosis swap is not constructed with a token_out_min_amount. exists issue Consequently, users will be exposed to sandwich attacks if they call the swap contracts without going through the entry-point contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Leftovers in contracts allow other users to retrieve them",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf",
        "body": "In the entry-point contract, there is validation to ensure all funds are sent over to other chains or contracts. It is important to ensure no leftover funds remain in the contract because anyone can retrieve them. Below we demonstrate several scenarios that will cause funds to remain in the entry-point contract. The contracts/entry-point/src/execute.rs:366-368 ensures verify_and_create_user_swap_msg function that in the required coin_in amount is not greater than the received coin amount. This presents a case where if the coin_in amount is less than the received coin amount, the dierence between them will remain in the contract. The verify_and_create_fee_swap_msg function in lines 415-417 performs a swap for the required fees (presumably for the Neutron chain). Since there is no validation that all swapped fees will be fully used, leftovers might remain in the contract. The verify_and_create_ibc_transfer_adapter_msg function in line 315 will distribute the IBC funds and the post-swapped amount. At the time of writing, Osmosis does not charge fees to perform IBC fund transfers. If the user provided IBC fees, the funds would remain in the contracts/networks/osmosis/ibc-transfer contract. Consequently, excess funds will not be refunded to the user, allowing other users to receive them by performing another swap. We classify this as a major issue because it would only happen due to user miscongurations.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. verify_and_create_contract_call_msg does not prevent self-calls",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf",
        "body": "verify_and_create_contract_call_msg in The a contracts/entry-point/src/execute.rs:333 contract_call_msg from being constructed that calls the entry-point contract itself or any of the related ibc-transfer or swap contracts for various networks. function prevent does not a While very little can be done with this from an attackers perspective, it is best practice to create the verify_and_create_contract_call_msg function. This might become important as new functionality or new networks are added. As the protocol becomes more complex, this attack vector may be leveraged with other components to create an attack path. addresses blocked that set fail of in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Permissionless TransferFundsBack message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf",
        "body": "The contracts/networks/neutron/swap/src/contract.rs:57 contracts/networks/osmosis/swap/src/contract.rs:47 are permissionless. TransferFundsBack messages in and We classify this issue as minor because the swap contracts only hold funds for the span of one transaction, so even though this message is callable by anyone, there won't be any funds It would still be best practice to in the contract to receive under normal circumstances. validate that the only caller of this message should be the contract itself.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. query_simulate_swap_exact_coin_out might return incorrect results if incorrect pair address is provided",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf",
        "body": "In the contracts/networks/neutron/swap/src/contract.rs:226-247, query_simulate_swap_exact_coin_out function relies on the provided pool address to reverse-simulate the denom_in amount needed from the denom_out amount. In the current validation, no validation ensures that the pool address holds both denom_in and denom_out assets. If a user provides a pair address that holds the denom_out but not the denom_in, the simulation succeeds with an incorrect denom returned. This is problematic because the coin will return as the operations denom_in amount, not the other pools asset. For example, assume the denom_in is USDC while the denom_out is USDT. Naturally, the provided pool address should point to the USDC-USDT pair. If the user instead provided the OSMO-USDT pair, the simulation would return the amount denominated in OSMO. This is incorrect because the returned coin will be denominated in USDC, misleading users.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. The entry point contracts instantiate function does not check for duplicate swap venues",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf",
        "body": "In the instantiate function in contracts/entry-point/src/contract.rs:17, msg.swap_venues should be checked for duplicates. Otherwise, when the values are stored in a map, the last duplicated element would overwrite the contract address of the rst. It is best practice to check for duplicates and return errors if they exist such that the caller can revisit the instantiation message to ensure no incorrect state is introduced. We classify this issue as minor because it can only be caused by the contract instantiator.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Unused error in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-08-20 Audit Report - Skip Protocol Swap Contracts v1.0.pdf",
        "body": "In contracts/networks/osmosis/swap/src/error.rs, an Overflow error dened, but it is not used. Unused code decreases the readability of the codebase. is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "3. Market timestamp checks market prices Since the Recommendation We recommend performing validation on the posted prices. For instance, there could be a maximum allowed delta per time unit, such that a price of 0 would not be accepted. While this does not fully resolve the centralization issue, privilege abuse would be more involved (and require multiple transactions over a longer timespan). This would allow operators and users to react. Furthermore, bugs in the o-chain bots that result in clearly wrong prices would no longer break the whole system. Alternatively, prices could be aggregated, for example by calculating a time-weighted median price to minimize the impact of a single buggy or compromised bot. Status: Acknowledged 11. PID parameter centralization risk",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neptune/2023-04-09 Audit Report - Neptune Protocol v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Lack of propagation of slashes to user deposits may lead to users rushing to unbond since last unbonding users may not be able to receive their stake back",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "The current architecture does not propagate slashes to user deposits, but rather relies on a slashing fund reserve to replenish slashes. That slashing fund is managed by the contract manager. There is currently no logic that reduces any users funds to account for slashes. That makes the whole protocol inherently unstable  any slashing compensation fund will eventually run out of tokens, at which point the last users to undelegate their funds will lose those funds. Rational users will anticipate that loss, which might trigger them to rush to unbond as quickly as possible. The only way to prevent this from happening is a sucient slashing fund reserve, but a rational manager would anticipate that rush and not be incentivized to replenish the reserves. The current slashing compensation is implemented as follows: The validator contracts manager can add or remove slashing funds at any time through the add_slashing_funds and remove_slashing_funds functions. Those funds are tracked in the contracts state in the slashing_funds eld. Whenever rewards are redeemed through the pools contract, the delegations of all validators are queried and a check for slashed validators is performed. If a validator got slashed, the contract uses those slashing_funds to delegate the slashed in contracts/validator/src/contract.rs:309. amount back to the validator their full deposited stake back on undelegation in Independent of slashing, users get contracts/delegator/src/contract.rs:297. As described above, this process makes the Stader protocol unstable. Apart from that, there is another issue: Slashed validators are jailed on Terra, so compensating the slashed amount will not be productive.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Validator removal happens without updating the pools contract, which leads to inconsistent state and implies that removed validators will still receive delegations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "Currently, the only way to remove validators is through the remove_validator function in the validator contract in contracts/validator/src/contract.rs:164. That implies that the validator storage of pools contract will not be updated: Validators are neither removed from the validators vector of PoolRegistryInfo, nor are they removed from the VALIDATOR_REGISTRY. Since removing a validator also leads to a re-delegation of the bonded tokens, these stake changes are not reected in the VALIDATOR_REGISTRY of the pools contract. This has several critical implications: The validator state will be inconsistent between contracts, unbonding through the pools contract will try to unbond from an already unbonded validator, and new deposits through the pools contract will be delegated to a previously removed validator through contracts/pools/src/contract.rs:231.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Rewards are double counted, leading to slashing funds being distributed as rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "In the validator contract, each validator is stored in the VALIDATOR_REGISTRY with their current stake and their accrued rewards. That accrued_rewards eld is incremented in dierent places in the contract, leading to double-counting of rewards instances are contracts/validator/src/contract.rs:238, 321, 394, 410, 490, 691, and 962. Consequently, the total calculated in contracts/validator/src/contract.rs:605 the will swap_and_transfer function transfers too many rewards, distributing funds as rewards that It will also lead to the transfer_reconciled_funds function not returning the error in line 770 even if it is expected to. should be reserved for slashing compensation. collected rewards. actually implies bigger That than that the be",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. First user to deposit rewards into an empty strategy that contains remainder tokens will lose these rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "the contracts/scc/src/helpers.rs:79, In get_strategy_shares_per_token_ratio function returns the default_s_t_ratio in the case where the total tokens in the SIC are zero. It returns zero though in the case where the token balance of the SIC is positive, but the total shares are zero in line 84. That could happen if all deposits have been redeemed, but the SIC still owns a remainder, e. g. from integer division or unclaimed rewards. In such a case, the next user to deposit tokens will not get any shares assigned in contracts/scc/src/contract.rs:1162, and hence lose their deposit.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Multiple reward coins sent to SIC auto-compound and base contracts or coins sent in wrong denom will be locked inaccessibly in contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "check The for in and contracts/sic-auto-compound/src/contract.rs:510 packages/sic-base/src/contract.rs:126 as well as the check for the wrong coin denom in lines 516 and 132 of those respective contracts do not return an Err, but rather Ok, which means that the transactions will not be reverted. Consequently, multiple coins sent multiple coins sent or coins sent in the wrong denom will not be returned, but rather locked inaccessibly in the contract.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Undelegating from a strategy with not sucient funds will lead to users losing (part of) their rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "in contracts/scc/src/contract.rs:487. In the undelegate_from_strategies function in the SCC contract, an iteration over all strategies is performed, sending the UndelegateRewards message for each strategy to its SIC contract. That message species the amount to be unbounded in the next undelegation batch that UndelegateRewards message in the SIC auto-compound contract checks whether enough suce in funds are available and returns an Ok message if contracts/sic-auto-compound/src/contract.rs:571. Since an Ok return value does not revert the transaction, no rewards will be undelegated from the SIC, but the SCC will be updated that the undelegation batch was processed, including updated shares and a new release time for the unbonding. No unbonding happened though, and thus users will not get the funds they should have gotten, with no way to recover. funds do not handler The for",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Replacing a validator that is receiving a redelegation will lead to loss of delegation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "When replacing a validator in the SIC auto-compound contract, only the funds in the in will can_redelegate contracts/sic-auto-compound/src/contract.rs:310. The can_redelegate eld will be zero if the outgoing validator is currently receiving a redelegation, and contain the full delegation amount otherwise. In the case where the outgoing validator receives a redelegation, no funds will be redelegated, but the validator will still be removed from the redelegated eld be validator_pool list in line 337. The delegation amount and the received redelegation will be locked in the pool due to the condition in line 268.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Usage of stored rather than queried delegation amounts may lead to an inconsistent state when unbonding",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "The current logic that processes undelegation batches in the pool contract iterates over a pools validators in contracts/pools/src/contract.rs:413 to undelegate enough stake to satisfy the amount requested from users. That logic uses the stored stake of validators, rather than querying the currently delegated funds. This is problematic, since validators might have been slashed/jailed or decided to unbond since the storage was last updated. In those cases, the actual undelegated amount would be smaller than the amount requested by users, since Cosmos SDK caps the undelegated amount to the available amount, rather than returning an error. The pools contract would not be aware of the discrepancy, and the stored stake would be inconsistent with actual delegations.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Util functions iterating over unordered hash maps may lead to Terra node consensus failures",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "The map_to_coin_vec and map_to_deccoin_vec functions iterate over the keys of a HashMap in packages/stader-utils/src/coin_utils.rs:111, 121 as well as in packages/sic-base/src/helpers.rs:184. Since HashMap keys are returned in an arbitrary order, the resulting vector has an arbitrary order of its entries. That could lead to dierent stored data in the contract storage between Terra nodes, which might cause consensus failures.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Conict of permissioning prevents feeder from submitting prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "When feeding prices into a price feed the contract checks that the owner is the sender of the message in contracts/oracle-proxy-feed/src/contract.rs:125. Subsequently when pushing prices to the relevant asset feeds the contract checks whether the message sender is a registered feeder in line 143. This means that only the contract owner who also is the feeder can submit prices to the feeder contracts.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Incorrect price list query in oracle hub",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "hub oracle in The the query_proxy_list contracts/oracle-hub/src/contract.rs:70 function. This incorrectly returns a list of the registered proxies for a specic asset token and not the latest prices. message calls PriceList query",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Unbounded number of oracle proxies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "The number of proxies that can be registered to the oracle hub is unbounded in contracts/oracle-hub/src/state.rs:39. Having a potentially large number of proxies would make execution functions costly and query functions unperformant. In extreme cases, this could cause the querier to run out of gas.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Oracle query functions contain unbounded loops",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "and Band Chainlink The contracts/oracle-proxy-band/src/contract.rs:172 contracts/oracle-proxy-chainlink/src/contract.rs:164. signicant computational resources leading to issues in the calling contracts. functions contain query unbounded loops in and They may use",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Sorting proxy list on every query is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "Every call to query_price in contracts/oracle-hub/src/query.rs:54, 84 and 118 sorts the proxy list. Doing so on every call is computationally inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Legacy price response returns last updated value for quote price in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "The LegacyPriceResponse contains u64::MAX for the last_updated_quote in contracts/oracle-hub/src/query.rs:126. A last updated quote value in the future may be unexpected to callers of the query and may cause errors in calling contract if that edge case is not handled.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "Packages contracts/oracle-proxy-band/Cargo.toml, contracts/oracle-proxy-chainlink/Cargo.toml, contracts/oracle-proxy-feed/Cargo.toml packages/tefi-oracle/Cargo.toml do not enable overflow-checks for release prole. contracts/oracle-hub/Cargo.toml, and the While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Oracle price query variable naming may be confusing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "The oracle hub price query in contracts/oracle-hub/src/query.rs:38 exposes a eld named timeframe, which does not clearly communicate the intent of the eld. Moreover, it is not obvious whether timeframe should be provided in seconds, blocks or the API should be as another unit. Since the oracle may be used by many projects, self-explanatory as possible.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Legacy price query does not support dierent bases",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "The oracle hub price query in contracts/oracle-hub/src/query.rs:102 takes both a base and quote asset as an argument. However, if the quote asset is not base_denom the contract throws an error in line 108. This makes the API less user-friendly as requests for prices the oracle has access to would be rejected unexpectedly.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. The unused the PromiseResult::Failed case when minting ROUTE tokens fails leads to skipping event_nonce incremented previously but in event nonces and results in attestation issues within Router Chain as the nonce is supposed to be sequential without gaps. 2. If decoding the result in the handle_execute_handler_calls_callback in function gateway-contracts:near/gateway-upgradeable/src/lib.rs:925 fails, the previously incremented event_nonce remains unused and leads to gaps in the emitted event nonces and thus attestation issues. Status: Resolved 3. ROUTE tokens are not minted for invalid requests, causing a loss of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-29 Audit Report - Router EVM and NEAR Gateway Contracts and WASM Bindings v1.0.pdf",
        "body": "In gateway-contracts:near/gateway-upgradeable/src/lib.rs:689-714, an IReceiveEvent event will be emitted as a failure when the ASM contract returns the request as invalid. In this case, the ROUTE tokens are not minted to the user. This is incorrect because the ROUTE tokens should be minted even if the is_valid_request value is false. Consequently, the route recipient will not receive the expected route amount, causing a loss of funds.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "1. Voting and unlocking tokens may fail due to an out-of-gas error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf",
        "body": "unlock_tokens in The contracts/atom_wars/src/contract.rs:495-512 and 284-293, respectively, iterate over all entries in the LOCKS_MAP state for the caller. This is problematic because if the user locks too many tokens in contracts/atom_wars/src/contract.rs:159, an out-of-gas error will occur when iterating the locks. functions vote and This may happen when users try to smoothen their power multiplier or if other contracts implement proxy voting. Consequently, users cannot vote on proposals and unlock their tokens, causing a loss of funds.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Unnished development",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf",
        "body": "In a few instances of the codebase, there seems to be unnished development accompanied by TODO comments. there is no entry point to execute a proposal as it Firstly, in contracts/atom_wars/src/contract.rs:116-118. This causes the executed eld to become false, as seen in contracts/atom_wars/src/state.rs:40. There may be future logic that needs to be implemented, such as quorum participation validation that inuences the proposal outcome. is commented out in contracts/atom_wars/src/contract.rs:338-341, the Secondly, validate_covenant_params function does not perform any validation although the function name indicates that validation will be performed. This is problematic because if a user votes on a proposal with non-whitelisted CovenantParams, they will not be able to claim their tribute allocation in contracts/tribute/src/contract.rs:180-187. The TopNProposals query will exclude it seen in contracts/atom_wars/src/contract.rs:787-796. from the top proposals, as",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Missing lock_epoch_length and round_length validations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf",
        "body": "In contracts/atom_wars/src/contract.rs:46, msg.lock_epoch_length and msg.round_length are not validated to be within a reasonable range. Misconguring these values may cause users to have little time to vote on proposals, aecting the protocols intended functionality.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. RoundProposals query may fail due to running out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf",
        "body": "contracts/atom_wars/src/contract.rs:756-757, In tranche_proposals function does not queries PROPOSAL_MAP for the current round/tranche combination. query_round_ implement a pagination mechanism when it the Since anyone can create proposals, a malicious user can intentionally create many proposals, causing this query to fail due to an out-of-gas error and aecting third-party protocols that integrate with it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. ProposalTributes query will not return legitimate tributes if the total tributes are larger than DEFAULT_MAX_ENTRIES",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf",
        "body": "the query_proposal_tributes In contracts/tribute/src/contract.rs:320, function returns an array of tributes stored in the contract. However, if the total number of tributes is larger than DEFAULT_MAX_ENTRIES, any tributes added after that will not be returned to the caller. This issue can be exploited by a malicious user who submits DEFAULT_MAX_ENTRIES + 1 fake tributes to the contract to prevent external services from retrieving any legitimate tributes added after that. A similar issue exists in contracts/atom_wars/src/contract.rs:846, aecting the query_user_lockups function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Vulnerable dependency",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hydro/2024-07-30 Audit Report - Hydro v1.0.pdf",
        "body": "One of the dependencies of the audited code is aected by a publicly known security vulnerability:  RUSTSEC-2024-0344 We classify this issue as minor as we did not nd exploitable instances in the audited codebase. Further details on the outdated libraries can be found i",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. app.dart: Logging of sensitive information possible",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "In initCrashlytics, the following error handler is congured to record utter errors in Firebase: FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterError; This conguration applies to the whole app and therefore also the wallet part. There, it is possible that sensitive information (mnemonic, private key) are included in a stack trace and sent to rebase. When an account that has access to these information is breached, an attacker can steal all coins that belong to these wallets, which happened in the past.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. No limit for unsuccessful PIN entries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "The wallet is protected by a 6-digit PIN, meaning there are 1,000,000 possible combinations (and roughly 3,000 of them are invalid because of the complexity requirements). Therefore, it will take on average 498,500 tries to nd the correct PIN, meaning a brute force attack is feasible. The wallet currently does not enforce an upper limit on the number of tries and also does not implement a measure like an exponential backo to protect users against such attacks.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Disconnecting the wallet does not require the PIN",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "When a user wants to disconnect his current wallet, he is not asked for the PIN. While this may be desirable from a UX perspective, disconnecting a wallet is a sensitive operation with potential nancial eects. For instance, when the user did not backup the wallet previously, he will lose access to the coins in the wallet.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. security_manager.dart: Initialization vector reuse in AES CBC mode",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "In onPinCodeChanged, the old key is decrypted with the old PIN and the resulting plain text then encrypted again with the new PIN. Because SecretKeyEncryptor._getInitVector returns the current initialization vector (if one exists), the same IV is used for both operations, which should not be done in AES CBC mode.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. wallet_address.dart: Insecure mnemonic generation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "To generate a mnemonic, the function generateMnemonic of the package bip39 is used. This library does not generate the mnemonic in a cryptographically secure way because of an o-by-one error: It calls _randomBytes within generateMnemonic. The _randomBytes function calls nextInt(_SIZE_BYTE) on the Random.secure() PRNG to get a random byte. This function generates random integers from 0, inclusive, to the provided maximum, exclusive. Because _SIZE_BYTE is set to 255, there is therefore no way that _randomBytes returns the value 255, meaning non-uniform randomness is used to generate the mnemonic.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. wallet_transaction_bloc.dart: Unnecessary gas estimation for FCD transfers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "In _transferFromConnectedToExternal, the gas limit for FCD transfers is estimated. This value is then passed to fcdWallet.transfer, which further passes it to _contractService.send. However, because ContractService.send has a hard-coded limit of 62,000 for FCD transfers, the whole estimation is unnecessary and never used.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. Instantiator may introduce misconguration by providing non-compliant proxy code_id",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Public Awesome/2023-01-27 Audit Report - ICS721 v1.0.pdf",
        "body": "function instantiate in The contracts/cw-ics721-bridge/src/contract.rs:26 does not check to ensure that the proxy code_id specied is a compliant cw721-proxy contract. The functionality for the INSTANTIATE_PROXY_REPLY_ID reply is generic contract instantiation logic which does not conrm that the contract is compliant. While it is unlikely that the instantiator of the contract would unknowingly introduce a misconguration by providing an invalid proxy, the impact of this would be that NFTs could be sent from other chains to this bridge and debt vouchers could be minted, but they would be unredeemable if the proxy contract did not support the correct interface to allow for NFTs to be sent back to their origin chain. This could be corrected by a migration to a compliant proxy contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Missing restriction on direct deposits to VirtualFrontierBankContract contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-04-30 Audit Report - Dymension Point 1D Stream 2_ Virtual Frontier Contract v1.1.pdf",
        "body": "In the ethermint:app/ante/eth.go:392-433, NewVirtualFrontierContractDecorator AnteHandler decorator denies users from depositing coins into VirtualFrontierBankContract contracts by rejecting Ethereum transactions with a non-zero value. However, it is still possible to send funds to VirtualFrontierBankContract contracts through the Bank module. As a consequence, while direct deposits are prevented, alternative methods for transferring funds remain accessible.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Attackers can DoS the chain by sending multiple IBC coins",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-04-30 Audit Report - Dymension Point 1D Stream 2_ Virtual Frontier Contract v1.1.pdf",
        "body": "if the current chain id is prexed with i.e., denoting that the chain is some sort of testnet, the BeginBlocker the In ethermint:x/evm/keeper/abci.go:30-34, ethermint_, executes DeployVirtualFrontierBankContractForAllBankDenomMetadataRecords function. This function iterates through all the DenomMetaData retrieved from the Bank module, new marked identifying VirtualFrontierBankContract for each of them. deploying denoms, those /ibc with and a As a consequence, attackers could exploit this process by initiating a large volume of ICS-20 transfers, causing the chain to store a substantial amount of DenomMetaData items during packet processing in ibc-go. This could lead to a slowdown of nodes, consensus timeouts, and, potentially, halts of the chain. We classify this issue as minor because this feature is only activated on the Ethermint dev chain.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Long-term DenomMetaData accumulation can DoS the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-04-30 Audit Report - Dymension Point 1D Stream 2_ Virtual Frontier Contract v1.1.pdf",
        "body": "ethermint:x/evm/keeper/virtual_frontier_contract.go:128-158, In DeployVirtualFrontierBankContractForAllBankDenomMetadataRecords function is called in the BeginBlocker, iterating through all DenomMetaData in the Bank module using IterateAllDenomMetaData. the However, as the quantity of DenomMetaData grows over time, this process increasingly slows down the blockchain, potentially leading to consensus timeouts and chain halts in the long run. We classify this issue as minor because this feature is only activated on the Ethermint dev chain.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Faulty DenomMetadata halts VirtualFrontierContracts deployment",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dymension/2024-04-30 Audit Report - Dymension Point 1D Stream 2_ Virtual Frontier Contract v1.1.pdf",
        "body": "ethermint:x/evm/keeper/virtual_frontier_contract.go:177-192, In function DeployVirtualFrontierBankContractForAllBankDenomMetadataRecords iterates through all the new DenomMetadata and deploys a VirtualFrontierContract for each one using the DeployNewVirtualFrontierBankContract function. the These actions are rst applied to a new temporary context, cachedCtx, before the state changes are committed all at once in the defer function. However, if a single deployment errors, all subsequent deployments will not be committed in the context. As a result, the presence of faulty DenomMetadata can halt the entire module from further deploying any VirtualFrontierContract contracts. We classify this issue as minor because this feature is only activated on the Ethermint dev chain.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Attackers can front-run transactions to steal user funds after approving allowances",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In evm/contracts/AssetBridge.sol:602, the stake function allows the owner to specify the from parameter, representing which users allowance will be consumed, as seen in line 614. This is problematic because users typically approve the contract to use their allowance before calling the contract. this issue by front-running the victim after they approve the An attacker can exploit transaction but before they call the AssetBridge contract. The attacker will call the stake function by specifying the from parameter as the victim's address, the to parameter as the attackers address, and the approved token address and amount. This will consume the victims allowance and consume their funds, but the liquidity token is minted to the attacker. This issue is also present in the unstake function in lines 625 and 629. If the approved token is the liquidity token, the attacker can front-run and call the unstake function to consume the victims liquidity token allowance and receive the underlying tokens in return, causing a loss of funds scenario.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attackers can prot by depositing dierent tokens and withdrawing as native tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In evm/contracts/AssetBridge.sol:624-627, the unstake function allows the caller to withdraw native tokens by specifying the isSourceNative parameter as true. This is problematic because attackers can provide non-ETH tokens and withdraw them as native tokens and prot from price dierences. For example, assume the attacker staked 10 TRX and received 10 TRX liquidity tokens. The price of TRX is $0.094, so the attackers cost would be $0.94. The TRX token uses decimal values of 6. then calls the unstake function with all 10 TRX and species the The attacker isSourceNative parameter as true. In decimal terms, the attacker sends 10*10^6 TRX and receives 10*10^6 wei in return, which translates to $197. After deducting the attackers cost, the attacker gains a prot of $196.06 per transaction. This prot can be leveraged to a higher value by using tokens with lower prices and higher decimal values and repeatedly performing the attack until all wrapped native tokens are stolen in the contract. Consequently, all wrapped native tokens in the contract can be stolen, causing a loss of funds scenario.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Attackers can register and deregister their accounts for prot",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In near/contracts/token/src/lib.rs:109, the register function registers the account in the fungible token contract after the caller paid 1 yoctoNEAR. This is problematic because with storage_balance_bounds().min.0, yoctoNEAR. unregistering account storage refunds which caller the the is Consequently, an attacker can steal the funds by repeatedly calling register and storage_unregister functions to prot from the account storage refunds, causing a loss of funds for the account owner. This issue also exists in near/contracts/lp-token/src/lib.rs:193, with the dierence that the user does not need to pay any funds to register their account.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Inability to decode request packet payload due to incorrect indexes results in failed cross-chain requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In decode_ireceive_deposit, near/contracts/asset-bridge/src/utils.rs, decode_ireceive_execute_with_message, the and decode_stake_payload utility functions decode the received cross-chain request packet payload and return the decoded values. However, in the following instances, incorrect indexes are used to access the decoded values, resulting in a panic since the expected and actual types do not match:  Line 250 should parse decoded_data[2] for the tuple.  Line 476 should parse decoded_data[3] for the instruction bytes.  Line 618 should parse decoded_data[3] for the recipient. Additionally, line 215 decodes the tuple as destTokenAmount, destTokenAddress, isDestNative, depositNonce, and recipient. However, in lines 258-305, the tuple is accessed as sender, src_token, src_amount, and deposit_nonce. This is incorrect because the tuples length and variable types are incorrectly used, causing the decoding to fail.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Refunding fails due to set_execute_revert_record function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "near/contracts/asset-bridge/src/setters.rs:34-40, the In the set_execute_revert_record execution_revert_completed map and validates that it equals the provided status parameter in line 32. This is problematic because a panic will occur for new key entries, and the assertion will fail if the status is updated to a dierent value for existing entries. function unwrap value tries the to in the i_receive in Firstly, near/contracts/asset-bridge/src/execution.rs:312 will fail because the destination chain ID and deposit nonce key entry are never stored before in the execution_revert_completed map. This will cause the insert function to return None in near/contracts/asset-bridge/src/setters.rs:37 and panic when the unwrap function is called. Consequently, the refund mechanism will fail to work properly. function the unlock_ireceive_fn in Secondly, calls near/contracts/asset-bridge/src/execution.rs:146 set_execute_revert_record to revert the execute record to false in case promises fail so the action can be retried later. As the key entrys value was previously set to true, the insert function will return Some(true) and unwrap it. Consequently, the assertion will fail in near/contracts/asset-bridge/src/setters.rs:39 because it expects the status to be false, which is incorrect. function",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. NEAR tokens are incorrectly transferred to the gateway contract instead of being escrowed in the AssetBridge contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "near/contracts/asset-bridge/src/call_gateway.rs:71, In i_send function sends all the attached NEAR tokens to the gateway contract. This is incorrect because only i_send_default_fee should be sent to the gateway contract to cover the fees, while the remaining funds should remain in the contract. the Consequently, the asset-bridge contract will have insucient liquidity for user token redemption, forcing users to wait for the contract owner to withdraw the funds from the gateway contract in order to unstake their LP tokens.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Fungible token refunds will fail, causing a loss of funds for users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In the near/contracts/asset-bridge/src/call_gateway.rs:164, i_send_callback function calls ft_transfer to refund tokens to the sender if the gateway contracts i_send call fails. This is problematic because no deposits are attached, causing the transaction to fail because the NEAR SDK requires one yoctoNEAR to be sent. Consequently, the fungible token refund fails, causing a loss of funds for the sender.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Payable keyword is not specied on functions that expect funds to be sent",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In evm/contracts/AssetBridge.sol:194-196, the setDappMetadata function allows the resource owner to call the setDappMetadata function in the gateway contract. Since no native funds are included, the transaction will fail if the iSendDefaultFee fee amount in the gateway contract is greater than zero. this that, issue also exists Besides in near/contracts/asset-bridge/src/call_gateway.rs:21. Since the payable keyword is not implemented, the set_dapp_metadata function cannot receive funds, causing the transaction to fail if the i_send_default_fee fee amount is greater than zero. in the NEAR asset-bridge contract the Lastly, in unstake near/contracts/asset-bridge/src/execution.rs:703 expects the caller to send three yoctoNEAR. This condition cannot be satised because the payable keyword is not implemented, causing the unstake function always to fail. function",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Native funds cannot be attached on ft_on_transfer calls",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In the near/contracts/asset-bridge/src/execution.rs:26-28, ft_on_transfer function implements the payable annotation because it expects native funds to be attached. This is problematic because when a user calls ft_transfer_call from a fungible token contract, native funds cannot be attached, preventing the asset-bridge contract from working properly. the function i_send in Firstly, near/contracts/asset-bridge/src/call_gateway.rs:71 in order to pay the i_send_default_fee fees in the gateway contract. Since native funds cannot be attached, the actual fees sent will be zero, causing token transfers to fail if the fee amount is larger than zero. attached deposits includes all in Secondly, near/contracts/asset-bridge/src/execution.rs:669 expects the user to send stake_token function the three yoctoNEAR. As fungible tokens cannot include any deposits, the transaction will fail in line 109, preventing users from staking the fungible token for liquidity tokens.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Unstaking liquidity token fails due to incorrect token parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In evm/contracts/AssetBridge.sol:625, 629, and 630, the unstake function uses incorrect tokens to call the burnFrom and safeTransferFrom functions. This function is called when users want to burn their liquidity token to redeem the underlying token. Firstly, in lines 625 and 629, the _contractToLP mapping is called on the tokenAddress parameter. Since the mapping is used to retrieve the underlying tokens liquidity token, the transaction will fail because the provided tokenAddress is already the liquidity token. Hence, it is unnecessary to use the mapping. Secondly, in line 630, the safeTransferFrom function transfers the tokenAddress to the user after burning the liquidity tokens. This is incorrect because the liquidity tokens are instead of the underlying token, which can be retrieved via the _lpToContract sent mapping. Consequently, the transaction will fail because the contract holds no liquidity tokens after burning them.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "11. Failed cross-chain requests cannot be retried",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "execute_failed_request in The middleware/contracts/asset-bridge/src/execution.rs:493-510 handles the ExecuteMsg::ExecuteFailedReq message, which allows the owner of the CosmWasm asset-bridge middleware contract to retry and execute a previously failed cross-chain request. function To ensure that only failed requests can be retried, the status of the received acknowledgment is retrieved from the ACK_STATUS storage map. If the status is false, signaling a failed cross-chain request, the request is supposed to be retried. However, this check is incorrectly performed in line 501 as the assert_ne! macro asserts that the status is not equal to false, which is the opposite of the intended behavior. As a result, failed cross-chain requests can not be retried and remain stuck.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "12. Unsafe conversion from uint256 to uint128 in asset-bridge middleware",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In the middleware/contracts/asset-bridge/src/handle_inbound.rs:129, handle_evm_inbound_request function decodes the widget_id from the received the Solidity payload and attempts to convert AssetBridge contract denes the widget ID parameter as uint256. This results in a panic if the provided value is larger than uint128 and halts the execution of the inbound request, causing the locked funds on the source chain to be unrecoverable by the user. the uint value to uint128. However, As this widget ID is provided by the user or by a widget integration, the ID may be incorrectly or maliciously set to a large value, causing the request to fail in the middleware contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "13. The same gas limit is used for all destination chains, resulting in out-of-gas errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In the following instances, the asset-bridge middleware contract determines the required gas limit for a cross-chain request by calling the fetch_st_gas_limit function:  middleware/contracts/asset-bridge/src/execution.rs:478  middleware/contracts/asset-bridge/src/handle_inbound.rs:139  middleware/contracts/asset-bridge/src/handle_inbound.rs:305 However, the gas limit is not congured on a per-chain basis. Instead, the same gas limit is used for all chains. Consequently, cross-chain requests may fail on the destination chain due to an out-of-gas error. Similarly, in middleware/contracts/asset-bridge/src/handle_revert.rs:64 is hardcoded to 150000. limit gas the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "14. Unable to process refund requests on the source chain due to missing parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "If processing the inbound request in the asset-bridge middleware results in an error, the in revert_inbound_to_src_chain middleware/contracts/asset-bridge/src/handle_revert.rs:16-96 initiates a refund request to the source chain. function However, the constructed request packet payload in lines 36-40 is missing important parameters that are required by the AssetBridge Solidity and NEAR contracts. Specically, the sender address, source token address, and source token amount, specied in the in DepositData and evm/contracts/interfaces/IAssetBridge.sol:63-68 near/contracts/asset-bridge/src/types.rs:56-61 are not included in the payload. As a result, the refund request packet can not be decoded on the source chain, and the refund can not be processed, thus locking the user's funds on the source chain. ExecuteInfoArgs structs and",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "15. The reentrancy lock mechanism in the NEAR AssetBridge contract can be abused to grief the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "The ft_on_transfer function in the NEAR AssetBridge contract employs a reentrancy lock mechanism to prevent calling the same function in between callbacks, which are not executed immediately but rather after 1 or 2 blocks. This is achieved using a mutex, which is set to true at the beginning of the function and false at the very end once all callbacks have been executed. If this mutex is set to true at the start of the function execution, the call panics. Specically, in near/contracts/asset-bridge/src/execution.rs:50-51 and 74-75, the lock variables are set to true, preventing the function from being repeatedly called. Once the last callback function is executed, the locks are released. However, this lock mechanism opens up a potential Denial-of-Service (DoS) vector, as it eectively rate-limits the contract on a per-function basis. For example, an attacker can spam with many consecutive function calls every 1-2 blocks, using as little funds as possible and thus preventing any other legitimate contract calls. While it is evident that the use of such a lock mechanism is intended to prevent reentrancy attacks, broadly applying this mechanism to all functions and blocking the functionality for a few blocks is not a suitable solution.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "16. Native token transfers always fail due to improper balance check query",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "evm/contracts/AssetBridge.sol:582, In the executeProposalForReserveToken function for native tokens will fail. This is because before initiating the token transfer, the contract checks its balance by calling the balanceOf function on the token's address. calling The issue here is that the contract employs the 0xEeee address to represent native tokens. However, 0xEee... is not associated with an existing contract on the Ethereum network. Consequently, this balance check operation reverts, causing native token transfers to fail.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "17. Lowercasing case-sensitive addresses causes unexpected behavior and incorrect outbound calls",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In the CosmWasm middleware contract, a critical problem exists related to address-casing sensitivity. This issue leads to unexpected and incorrect behavior, particularly when dealing with addresses from chains that employ case-sensitive address formats, such as TRON, Solana, and Polkadot. The middleware contract keeps track of asset-bridge contracts for various chains, which may use dierent address formats. For instance, when calling the WhiteListAddresses message, the supplied contract address in converted Subsequently, middleware/contracts/asset-bridge/src/execution.rs:101. the whitelisted contract is incorrect because it belongs to a dierent TRON contract address. lowercase to is",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "18. Unintended refund due to TEMP_REVERT_STATE not being cleared and incorrectly calling of revert_inbound_to_src_chain on minting gas tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "In middleware/contracts/asset-bridge/src/handle_inbound.rs:138, 209, 304, and 373, the TEMP_REVERT_STATE storage is used to store temporary information for reverting or refunding tokens to the sender in case an outbound request on the destination chain fails. The issue is that the TEMP_REVERT_STATE storage is never appropriately cleared after the transaction is completed, causing incorrect refunds when the owner calls in mint_gas_tokens middleware/contracts/asset-bridge/src/execution.rs:480. If the send_reserve_outbound_request function (called inside mint_gas_tokens) enters middleware/contracts/asset-bridge/src/submit_outbound.rs:36, it will the revert_inbound_to_src_chain function to issue a refund in middleware/contracts/asset-bridge/src/handle_revert.rs:30, which uses the uncleared TEMP_REVERT_STATE storage state that hold previous values. call Consequently, an outbound request will be created using the previous data stored in TEMP_REVERT_STATE, causing the tokens to be incorrectly refunded and a loss of funds scenario for the contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "19. Callback functions may run out of gas, resulting in inconsistent states of the NEAR asset-bridge contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-30 Audit Report - Router Asset Bridge v1.2.pdf",
        "body": "instances of the NEAR codebase in near/contracts/asset-bridge, In several callbacks are implemented to handle promise results. As no validation ensures the supplied prepaid gas is sucient for executing all promises, some callbacks might fail to execute due to an out-of-gas error. the Firstly, in i_send_callback near/contracts/asset-bridge/src/call_gateway.rs:81 is allocated with 5 * TGAS. This is problematic because line 159 tries to allocate the exact amount of gas if the promise fails to refund the tokens to the user. Consequently, the refund will fail, and the function reentrancy lock in line 168 cannot be unlocked, causing a loss of funds and future token transfers to fail. the handle_itransfer_burn_callback Secondly, in near/contracts/asset-bridge/src/execution.rs:183 does not enforce any static gas limit before initiating the callback. Ideally, there should be at least 15 * TGAS reserved because the i_send and i_send_callback functions allocate gas in near/contracts/asset-bridge/src/call_gateway.rs:72, lines 81, and 159. function the Thirdly, in handle_ireceive_callback near/contracts/asset-bridge/src/execution.rs:342, lines 462 and 525 does not enforce sucient gas limit. The former does not enforce any gas limit, while the latter only allocates 5 * TGAS. This is insucient because a total of 10 * TGAS needs to be allocated in lines 568 and 576, causing the transaction to fail due to an out-of-gas error and not reverting the reentrancy lock. function Fourthly, the handle_ireceive_ft_get_balance_callback function in line 364 does not enforce any static gas limit. Ideally, there should be at least 15 * TGAS allocated due to lines 504, 568, and 576. This might cause the reentrancy lock to fail to revert, or cause the event to fail to emit by the handle_event_by_tx_type function. Lastly, the handle_unstake_callback function in line 718 also does not enforce any static gas limit. This might cause the liquidity token redemption or refund to fail, but the users liquidity tokens are already burned, causing a loss of funds scenario.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Harvest message can be sandwiched to skim rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "The Harvest operation in contracts/martian-field/src/contract.rs:23-26 claims rewards from the Astroport generator and then, after treasury fees have been applied, sells ASTRO to rebalance between the primary and secondary assets (in two steps). Since the Harvest message is permissionless and can be called by anyone, there is an opportunity in contracts/martian-field/src/execute.rs:210. skim the operation, reducing bonded amount total the to An example of the arbitrage attack to skim rewards would be the following, executed as a single transaction: 1. User swaps ASTRO for the primary asset",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Go to step 1 when ASTRO rewards have accrued. Bots could perpetually exploit this arbitrage if it were economically viable, hindering the overall nancial performance of the Field of Mars protocol. Recommendation We recommend making the Harvest operation permissioned, to reduce the opportunity for arbitrage. Alternatively, the team/community could aim to call the Harvest function with enough frequency so the arbitrage attack is not economically feasible due to transaction fees, but this is also dependent on the ASTRO rewards claimed. Status: Resolved 2. High spread might cause swapped primary asset not enough to cover users debt",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Tax deduction logic is not implemented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "The Field of Mars contract uses the cw-asset library as a dependency, to facilitate the handling of both CW20 and native assets. The cw-asset library does not account for Terra taxes logic, which may cause forward-compatibility issues in the future. Even though the tax rate is currently set to zero, the tax mechanism itself has not been removed. Whilst unlikely, a future governance vote might decide to make use of the mechanism again and augment the tax as provide_liquidity() in martian-field/src/execute_callbacks.rs:18, potentially causing the loss of native contract funds due to accounting errors, and/or panics. rate, which would functions aect such",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Typos in response attributes may degrade the user experience",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "In the UpdatePosition msg, in contracts/martian-field/src/execute.rs:109, the response \"martian_field :: excute :: there is a typo in the attribute of update_position\". This may degrade the user or development experience when using this contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Remove unused code in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "The Snapshot feature in the codebase is not used anywhere in the codebase. Theres no entry point for users or contract admin to execute that function. Additionally, theres a TODO the code in contracts/martian-field/src/state.rs:12 hinting that comment should be deleted.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Outstanding TODOS are present in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "During the audit engagement, several TODO comments were found in the following code lines:  contracts/martian-field/src/execute.rs:186-187  contracts/martian-field/src/execute.rs:266  contracts/martian-field/src/execute_callbacks.rs:517  contracts/martian-field/src/state.rs:12 This implies that the contract might still be under development and not yet ready for mainnet deployment.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Transfers can still be initiated when a token is removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix Bridge v1.0.pdf",
        "body": "the can use DAO function deleteTokenInfo The within helix-contract/contracts/ln/lnv3/base/LnBridgeSourceV3.sol to disallow the usage of a token. However, under some circumstances, users can still initiate transfers. This can happen because lockAndRemoteRelease does not check if a token is still registered. It only validates if the LnProvider was registered for this token (which checks that the token was not removed). But if the token is removed after the registration, the LnProvider will still be registered and users will still be able to initiate transfers for the provider.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Centralization risks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix Bridge v1.0.pdf",
        "body": "The contracts contain a few centralization concerns that users should be aware of:  In helix-contracts/contracts/ln/lnv3/base/LnBridgeSourceV3.sol, the function deleteTokenInfo could be used to delete tokens that are in use, in which case funds would be stuck, as withdrawLiquidity would fail.  The current LnBridgeSourceV3 contract logic allows setting the token penalty to zero. This would enable an LnProvider to operate without depositing any penalty reserves. We classify this issue as minor since only admins can trigger the modications listed above.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Irrecoverable Blast points",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix Bridge v1.0.pdf",
        "body": "a helix-contracts/contracts/ln/lnv3/HelixLnBridgeV3ForBlast.sol version of the bridge with some modications for deploying on Blast. In line 18, the points operator is set to the DAO address. However, as can be seen in the Blast FAQs, having a smart contract address as the points operator is not supported because this address needs to sign data when claiming. While the DAO was out of scope for this audit, it will presumably be a smart contract, leading to lost points. is We classify this issue as minor since Blast points are an optional feature of Blast and there is no loss for the protocol user if they are not recoverable.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Anybody can request to withdraw providers liquidity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix Bridge v1.0.pdf",
        "body": "requestWithdrawLiquidity the The contract helix-contract/contracts/ln/lnv3/base/LnBridgeTargetV3.sol allows any EOA account with the correct parameters to withdraw the liquidity to its providers. While we did not identify a direct security risk of this implementation, it should be explicitly stated whether this is intentional. function of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Input validation could be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Helix Bridge/2024-07-04 Audit Report - Helix Bridge v1.0.pdf",
        "body": "In a couple of functions, the input is not properly validated:  In helix-contract/contracts/ln/lnv3/base/LnBridgeTargetV3.sol, it passed to this is not is mentioned requestWithdrawLiquidity should not be too large. However, validated, which could lead to out of gas errors on the source chain. _transferIds size that that the of is  The LnBridgeSourceV3 contract allows setting token penalty to zero. This would allow an LnProvider to operate without depositing any penalty reserves.  The withdrawProtocolFee function allows sending all protocol fees to address(0), which equals burning the protocol fees.  In other functions of the Helix Bridge contracts, it submitted addresses and/or amounts are not equal unintended behavior in out of scope contracts. is not checked whether the to zero. This can lead to",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. The new owner account claims ownership, which applies the conguration changes. Status: Acknowledged The client states that the second owner is the governance module address, hence the admin address can always be re-stated via governance. 30. Incorrect existing_delegation attribute emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Persistence/2024-01-26 Audit Report - pSTAKE Native Auto-Compounding and Rebalancing v1.0.pdf",
        "body": "In x/liquidstakeibc/keeper/icq.go:117, the DelegationCallback function emits the existing_delegation attributes as validator.DelegatedAmount. This is incorrect because the existing delegation represents the previously delegated amount. Consequently, the validator.DelegatedAmount has been updated to the latest delegated amount in line 109. incorrect emitted value since the will be",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Ante Handler panics if the highest bid denom is not the same as minBidIncrement",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-07-29 Audit Report - Skip Protocol Owned Builder v1.0.pdf",
        "body": "In x/builder/keeper/auction.go:72, the highest bid is added with the minimum bid increment without checking if both denoms are identical. This could happen because there are no validations that ensure the submitted bid denom is the same as the congured minimum bid increment denom. Consequently, the Ante Handler will panic without returning an error. Please see the TestTwoAuctionsWithDifferentDenom test case in the Appendix to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Zero MinBidIncrement undermines fee market",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-07-29 Audit Report - Skip Protocol Owned Builder v1.0.pdf",
        "body": "The Params Validate function in x/builder/types/params.go:50 does not enforce the MinBidIncrement value to be greater than zero. This means that governance or genesis may introduce a value of zero which will undermine the fee market of the builder module. Consequently, this would create a situation where the modules bid execution may dier from the documentation and confuse searchers. This is because the validateFee function performs a basic Cosmos SDK coin validation which allows coins to have a zero amount. While this may slightly modify the behavior of the auction, it ultimately is up to the market actors to place auction bids to ensure their bundle is executed so we only classify this issue as minor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Parsing query command ags are ignored",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-07-29 Audit Report - Skip Protocol Owned Builder v1.0.pdf",
        "body": "The CmdQueryParams CLI command in x/builder/client/cli/query.go:31 uses GetClientContextFromCmd to get Context, yet it does not read query command ags.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Unhandled errors in Cobra command",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-07-29 Audit Report - Skip Protocol Owned Builder v1.0.pdf",
        "body": "In x/builder/client/cli/tx.go:45, the return parameter from the Set function is not handled. If an error occurs, the NewAuctionBidTx function will fail silently.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Incorrect eld numbering",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-07-29 Audit Report - Skip Protocol Owned Builder v1.0.pdf",
        "body": "In proto/pob/builder/v1/tx.proto:30, MsgAuctionBid message skips eld number 2. The bid in line 41 should use 2, and transactions in line 45 should use 3 eld numbers.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Inecient execution in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Skip/2023-07-29 Audit Report - Skip Protocol Owned Builder v1.0.pdf",
        "body": "In x/builder/keeper/auction.go:79, the GetAllBalances function is called to get the bidders account balances to validate that they have sucient funds to bid. However, it is to validate all account balances because the bid deals with a single coin inecient denomination. The gas consumption can be reduced by using GetBalance, which retrieves one coin balance instead of all coin balances. Additionally, the AuctionBid function in x/builder/keeper/msg_server.go:38-55 calls the GetParams function multiple times. The gas consumption can be reduced by calling GetParams once and using the returned value for max bundle size, proposer fee, and the escrow account.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Claiming allocation will cause proposed receivers previous allocation to be overwritten, leaving funds inaccessible in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "contracts/builder_unlock/src/contract.rs:305-311 the In astroport-governance repository, the proposed receivers allocation is overwritten via PARAMS.save and STATUS.save without they have existing AllocationParams and AllocationStatus. If the proposed receiver decides to claim a new allocation while having an existing allocation, their existing allocations ASTRO token will be stuck in the contract. verifying whether of",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Original receivers that transferred allocation will not be able to receive new allocations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "contracts/builder_unlock/src/contract.rs:303-311 In the astroport-governance repository, if the original receiver had transferred their ownership of allocation to a new receiver, their AllocationParams is removed via PARAMS.remove in line 308. However, their AllocationStatus is not removed via STATUS.remove, which means that the original receiver will have an outdated AllocationStatus but no associated AllocationParams with it. of This is problematic since the original receiver will be unable to receive new allocations due to lines 153-158.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Leftover amount after providing liquidity is not refunded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "the astrozap repository, In contracts/astrozap/src/contract.rs:84 of offer_asset is calculated by using Newton's method. Since the method does not have 100% accuracy (in the referenced white paper, the specic example shows a 0.04% error), it will cause a remainder of tokens to be left in the contract. Moreover, Newtons method does (see not contracts/astrozap/src/math.rs:74). for offer_asset. MAX_ITERATIONS within It convergence can output erroneous guarantee values",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Miscongured schedule duration could cause division by zero error, leaving funds inaccessible",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "contracts/builder_unlock/src/contract.rs:427 In the astroport-governance repository, schedule.duration is used as a denominator to calculate the amount of tokens that can be unlocked between start time and end time. If the value is zero, a division by zero error would occur and will cause the specic allocation to be locked in the contract. of We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. UnlockedTokens query message does not include cliff period during calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "contracts/builder_unlock/src/contract.rs:362-372 In astroport-governance repository, query_tokens_unlocked of the uses tokens that are unlocked compute_unlocked_amount to compute the number of according to the current timestamp. The function does not include the schedules cli period when calculating the withdrawable token amount, this would cause an incorrect amount returned to the caller. An example calculation that includes a cli period can be found in contracts/builder_unlock/src/contract.rs:442-445.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Extra funds sent to AstroZap contract are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "In contracts/astrozap/src/contract.rs:74-79 of the astroport-governance repository, users sent funds are being used in handle_deposits to verify that the funds user claimed to have deposited are actually deposited to the contract. The current implementation does not return an error though if additional native tokens are sent to the contract, leaving them stuck in the contract. We consider this to be a minor issue, since it is caused by a user error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Duplicate accounts creation in xAstro token instantiation would cause inated xAstro total supply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "In contracts/xastro_token/src/contract.rs:104-108 of the astroport-core repository, duplicate accounts are not veried when creating initial accounts during the contract is passed twice in create_accounts, the accounts balance would be overwritten via BALANCES.save but total_supply would still record the balance amount of both. As a result, xAstro tokens total supply would be inated. the same account address instantiation phase. If We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Malicious users can transact NFTs with zero deltas, causing a loss of prot for pool owners",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "In contracts/infinity-swap/src/swap_processor.rs:560-571 and 718-730, the break statement will be entered if the swap fails. This is problematic because reused pools will not be stored in self.pools_to_save, which is responsible for saving the pool into storage. As a result, a malicious user could potentially exploit this by intentionally causing the second swap to fail when using the SwapNftsForTokens and SwapTokensForAnyNfts messages. This eectively allows them to buy or sell NFTs without aecting the deltas, resulting in a potential loss of prot for pool owners. Please see the unsaved_pools test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Swap fees are not applied throughout the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "In contracts/infinity-swap/src/pool.rs:127-133, the trade pool expects the caller to provide a swap fee percentage value, which represents the percentage of the swap that will be paid to the pool owner. However, the fee is not collected anywhere in the contract. Consequently, pool owners will not receive their share of swap fees when users trade on their pool.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Payment distribution will fail for zero seller amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "the contracts/infinity-swap/src/swap_processor.rs:410-416, In transfer_token function is used to distribute tokens to all intended recipients. If the seller amount becomes zero after deducting network, nder, and royalty fees, the transaction will revert because Cosmos SDK prevents sending zero amounts. As a result, trades will not be executed as intended.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Iterating through best-priced pools may fail due to an out-of-gas error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "The protocol enables NFTs to be exchanged for tokens while allowing multiple identical pools to coexist. When buying NFTs, it is possible to specify the maximum amount of tokens to spend in exchange for the lowest NFT price. To achieve this, it is necessary to iterate through existing pools to nd the highest price when selling NFTs or the lowest price when purchasing NFTs. The load_next_pool function in this contracts/infinity-swap/src/swap_processor.rs:439-452 purpose, iterating through all pools and sorting them to nd the optimal one based on the transaction type. serves the implementation does not account issue of excessive However, computational power consumption when many pools are created over time, either organically or by a malicious actor. In such cases, both operations, DirectSwapNftsForTokens and SwapTokensForAnyNfts, may consistently return errors related to exceeding the maximum gas limit, leading to a denial of service for the protocol. the potential for We classify this issue as major instead of critical because users can still trade using other entry points.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Pool activation is possible before depositing the required assets, resulting in an empty pool",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "The project's technical documentation outlines the process of creating a pair for one of the three types of pools. It begins with calling the CreatePool message with appropriate followed by depositing tokens or NFTs via the DepositTokens or parameters, DepositNfts messages. Lastly, is activated by calling the SetActivePool message. the pool the in However, contracts/infinity-swap/src/execute.rs:544 does not verify that a deposit has been made. Consequently, creating and activating a pool without making any deposit is possible, resulting in an empty pool. execute_set_active_pool function Please see the test_activate_without_deposit test case to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Trades will fail if the delta decreases the spot price to zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "In contracts/infinity-swap/src/pool.rs:364-377, and exponential bonding curves update the spot price by deducting their delta with respective calculations. In a scenario where the spot price becomes zero, Tokens and Nft pools will fail to update, as seen in lines 68-72 and 101-105. Consequently, pools that miscongured their delta will fail to purchase NFTs from users. linear Please see the error_updating_spot_price test case to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Possible incorrect denom emitted during contract instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "In contracts/infinity-swap/src/instantiate.rs:37, the denom attribute value is emitted as msg.denom. This is problematic because the contract uses NATIVE_DENOM, which is hardcoded to ustars. If the contract instantiator provides another type of denom, the contract will emit it, which may mislead users.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Pools can be deactivated through the SetActivePool message, leaving them in an inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "The is_active parameter, changeable via the SetActivePool message or directly through the set_active function, in contracts/infinity-swap/src/execute.rs:556 and is negated when removing it in contracts/infinity-swap/src/helpers.rs:214. is set and used during creation of a pool However, the documentation does not mention that it is possible to deactivate a pool by sending the SetActivePool message with a false value while it has deposits and is open for swaps. This deactivation prevents any further swaps.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Inecient pool type validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "In contracts/infinity-swap/src/pool.rs:165-173, the deposit_nfts function performs a validation check to ensure that the pool is of the NFT type. However, during the deposit of NFTs in contracts/infinity-swap/src/execute.rs:346, this validation is called after the NFT transfer is performed (see lines 336-344). the validation was performed earlier, the If execute_deposit_nfts function, the transaction could consume less gas before being reverted in case of an incorrect pool type. the beginning of such as at",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Unhandled zero-amount withdrawal",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "Using the WithdrawTokens and WithdrawAllTokens messages, a user can withdraw tokens from the specied pool. The funds are transferred from the contract to the recipient in using contracts/infinity-swap/src/helpers.rs:335. transfer_token function dened the However, these messages do not validate whether the amount is greater than zero. If a user attempts to withdraw zero tokens, an error will be returned by the Cosmos SDK, as BankMsg::Send does not support zero amount transfers.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Redundant parameter when depositing NFTs",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "In the contracts/infinity-swap/src/execute.rs:327-332, execute_deposit_nfts function requires the caller to provide a collection parameter, which is then checked to ensure the collection address matches the pool's collection address. This parameter can be removed, as the pool's collection address can be used directly instead, reducing gas consumption and code complexity.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Misleading parameter naming in swap_tokens_for_any_nfts function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "contracts/infinity-swap/src/swap_processor.rs:686, In swap_tokens_for_any_nfts min_expected_token_input, implying it represents a minimum expected input amount. parameter contains function the called a Since the function is used in contracts/infinity-swap/src/execute.rs:873 and contracts/infinity-swap/src/query.rs:428, the min_expected_token_input parameter is fed with max_expected_token_input, the naming is misleading as the function processes it as the maximum expected input amount. where",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Developer address is not emitted during contract instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "In contracts/infinity-swap/src/instantiate.rs:33-39, the response emits all provided parameters as attributes, excluding the developer address. This is inconsistent as the provided developer address is not emitted for o-chain listeners to index.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Inconsistent attribute name for pool identiers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-07-20 Audit Report - Stargaze Infinity Pool v1.1.pdf",
        "body": "contracts/infinity-swap/src/execute.rs:353, In and the attribute value for contracts/infinity-swap/src/swap_processor.rs:83, pool identiers is used as pool_id. On the other hand, other functions use id to indicate the pool identier, as seen in contracts/infinity-swap/src/pool.rs:453.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Use of dependencies with know security vulnerabilities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dock/Audit Report - Dock Wallet.pdf",
        "body": "An analysis of the dependency tree shows 117 known vulnerabilities in the dependency tree. Of these vulnerabilities, 2 are considered of critical severity and 35 are considered of high severity.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Non-deterministic iteration may break consensus",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "the following maps In a Cosmos SDK blockchain, non-determinism of blocks will cause the blockchain to halt. The is not deterministic: blockDistrState.Txs, iteration over blockDistrState.Contracts, in contractDistrState.TxGasUsed x/rewards/keeper/distribution.go:122, 133, 147 and 181 respectively. This can lead to consensus failure, since the order of iteration over a Go map is not guaranteed to be the same every time the program is executed. and",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Contract owners may set excessive FlatFee",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "The SetFlatFee function in x/rewards/keeper/msg_server.go:89 does not impose an upper-bound limit on the FlatFee amount. While the FlatFee is determined by the owner of a contract, governance should dene a maximum fee to prevent excessive amounts that may impact the usability of contracts that are popular on the chain. While this is unlikely, contract owners may introduce prohibitively high fee amounts after their contract has achieved mass adoption.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Missing usage description for transaction and query CLI commands",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "It is best practice to supply a long message for transaction and query CLI commands of a to both users and external Cosmos SDK application, since such messages are helpful developers. With the exception of getTxSetContractMetadataCmd, all transaction and query CLI commands for the rewards module in x/rewards/client/cli/tx.go:24-28 and x/rewards/client/cli/query.go:22-29 are missing long messages.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Mismatch between technical specication and implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "The technical specication in x/rewards/spec/01_state.md:74 species that an Object is pruned (removed) at the BeginBlocker. However, objects are actually pruned in the cleanupTracking function in x/rewards/keeper/distribution.go:237-238, which is executed during the EndBlocker.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Non-standard error codes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "to the documentation According Cosmos (https://docs.cosmos.network/main/building-modules/errors), there are restrictions on error codes. One such restriction is that error codes must be greater than one, because the value one in x/rewards/types/errors.go:8 is registered with the error code one. ErrContractNotFound errors. However, reserved internal ocial SDK for is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Miscellaneous code quality comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "Throughout the codebase, some instances of inecient code and misleading comments have been found.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Replaying CloseHolder message allows attackers to steal funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "In contracts/osmosis/zodiac_osmo_bal_lockup_vault/src/contract.rs:657 -658, the CloseHolder message resets the holders unlocking_for_repaying vector and distributes funds accordingly. However, the mutated holder information is not saved to the YIELD_TOKEN_HOLDERS storage, causing the storage to incorrectly reect that the holder still has funds, despite them being already distributed. Consequently, attackers can siphon funds from the vault by replaying the CloseHolder message with their own address, leading to a loss of funds for other holders. Moreover, if an attacker is closing their own position, they would receive all the funds except for the applied fee. Please see the test_repeated_holder_closure test case to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. The vault contract is not able to mint YT tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "BlockBeforeSend in The dened contracts/osmosis/zodiac_osmo_bal_vault/src/contract.rs:133, is executed by the Osmosis chain when sending tokens through the Bank module and is used by the protocol to execute custom logic to map YT tokens to the recipient during a send operation. message, Sudo This hook is implemented under the assumption that it is not executed when minting or burning tokens. assumption does not hold, however, the This SendCoinsFromModuleToAccount function here which calls SendCoins here, which implies that the BlockBeforeSend hook is executed even during mint operations. since the mint operation calls Since, during mint operations, the fromAddr is the address of the tokenfactory module, in an returned error will be contracts/osmosis/zodiac_osmo_bal_vault/src/contract.rs:149 trying to decrease its zero balance. when Please see the test_decrease_balance_user_not_existing test case to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Incorrect vault expiration condition allows arbitrary closure of legitimate holders",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "In contracts/osmosis/zodiac_osmo_bal_lockup_vault/src/asserts.rs:132- 134, the assert_holder_is_closeable function attempts to check that the current time does not exceed the maturity timestamp when closing a holder. This condition is incorrect because holders should only be allowed to be closed after the vault has expired, implying they did not withdraw their locked tokens in time, which should result in a penalty. Consequently, a malicious user could potentially close positions of holders who requested to unlock their yield tokens and receive the penalty amount as a reward, causing a loss of funds for the holder even if they intended to withdraw their locked tokens within the appropriate timeframe.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Large slippage tolerance allows for swap arbitraging",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "Slippage tolerance is used to determine the maximum deviation from the tokens that the user expects to receive to those actually received, for example, as a result of a swap. This is enforced through the min_token_out parameter. The smaller the value, the smaller amount of tokens can be received without the function returning an error. The contracts within scope make use of very low min_token_out values for swaps, allowing other uses arbitrage prots by executing a sandwich attack. This problem is exacerbated by the fact that swaps could be triggered by anonymous users through the Keep entrypoints. An attacker could monitor suitable target vaults in the protocol to arbitrage several swaps at once, choosing the time they are being executed by triggering the Keep functionality themselves. The following instances use potentially exploitable limits:  contracts/osmosis/zodiac_osmo_bal_lockup_vault/src/contract.r s:299 and 804  contracts/osmosis/zodiac_fee_collector/src/contract.rs:77 and  contracts/osmosis/zodiac_osmo_vamm/src/contract.rs:301  In this case, there are checks in place inside the reply handler that enforce a user-submitted slippage tolerance in line 329. However, no validation is applied to that user-supplied value, and a default of zero min tokens is used, which could lead to a similar situation to the one described above.  contracts/osmosis/zodiac_osmo_vamm/src/contract.rs:453 and 552  Similar to above, the user-supplied token_out_lower_bound is not validated for a minimum or suitable default.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. FlashLoanV message fails to transfer funds to the caller",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "In contracts/zodiac_flash_loan/src/contract.rs:196, the flash_loan_v function is designed to enable the caller to execute a series of messages before repaying the ash loan. However, the function does not transfer the requested loan asset to the caller. Consequently, users or smart contracts intending to borrow funds using the FlashLoanV message will not receive the funds they expect.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Excess principal tokens will be stuck in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "In the contracts/osmosis/zodiac_osmo_vamm/src/contract.rs:238-245, TO_PLP_FLASH_LOAN_LOGIC_REPLY_ID reply handler is designed to refund any excess yield tokens if the received principal tokens are less than required. However, there is no provision to handle a situation where the received principal tokens are more than the required yield tokens. This scenario could occur if the pool for principal and liquidity tokens is imbalanced during the swap, as seen in lines 610-626. Consequently, excess principal tokens will be left in the contract for anyone to retrieve.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Potential for front-running attack on CloseVaultStageTwo message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "In contracts/osmosis/zodiac_osmo_bal_lockup_vault/src/contract.rs:634 -640, the Keep message is internally invoked during the vault's stage two closure process. The keep function implements a cooldown period in lines 829-831 such that it can only be called after a specic time. As a result, malicious users can prevent others from calling the CloseVaultStageTwo message by frontrunning their transaction and calling the keep function rst, causing it to enter the cooldown state, eectively blocking the stage two completion process. We classify this issue as major because it aects the correct functioning of the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Holders with zero yield tokens cannot withdraw after stage two completion",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "In contracts/osmosis/zodiac_osmo_bal_lockup_vault/src/contract.rs:440 -453, the withdrawal function attempts to send the holders yield tokens once the vaults stage two is completed. This is problematic because it does not ensure that the holders yield tokens are not zero. As Cosmos SDK prevents sending zero amounts, holders with zero yield tokens will be unable to withdraw their unlocked liquidity tokens, causing their funds to be locked in the contract. We classify this issue as major because it aects the correct functioning of the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Possibly outdated parent vault congurations may be used",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "In contracts/osmosis/zodiac_osmo_bal_lockup_vault/src/contract.rs:64- 76, the parent vaults conguration is queried and stored in the Config struct. If the parent vault conguration gets updated, the owner would need to initiate another transaction to reect the new conguration in this contract, as seen in line 895. This approach leads to inconsistencies because an outdated parent vault conguration will be used if the owner does not update it immediately. Besides that, the owner can update the parent vault conguration to any arbitrary value, which might be incorrect. We classify this issue as major because it aects the correct functioning of the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Accrued fees are not sent to the fee collector contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "loan ash contract calculates the The in FLASH_LOAN_REPLY_ID contracts/zodiac_flash_loan/src/contract.rs:73 and 82. However, instead of sending this amount to the fee_collector address as per the specication, it is sent to snapshot.vault_address alongside the actual loan. fee reply handler of loans the the in As a consequence, the CONFIG eld fee_collector is unused during the contract outside of query entry points.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "11. Non-callback arbitrary messages accepted by the flash_loan_v function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "limits the callback messages that are executed through the The ash loan contract flash_loan function to ExecuteMsg directed to the sender only, as best practices dictate. However, this is not the case for the additional entry point handled by the flash_loan_v function. In that case, the function accepts arbitrary Cosmos messages for execution without any further restriction. For instance, this message could be used to move the contracts funds to an arbitrary address through a BankMsg. This would allow anyone to drain all the contracts funds when asking for a loan through the aected functionality. We classify this issue as major instead of critical, given that the flash_loan contract is not expected to hold any permissions on other contracts or hold any funds.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "12. Misconguring fee values causes bank transfers to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "In several instances of the contract, amounts to be transferred are not checked to be greater than zero. For instance, if the contract owner miscongures the fee value to be zero or the max value of 10000, either the fee or the actual transfer will fail and the transaction will revert since Cosmos SDK prevents sending zero amounts. The following code lines are aected:  contracts/osmosis/zodiac_osmo_bal_lockup_vault/src/contract.r s:419, 427, 568, 578, 694, 704, 728, and 736.  contracts/osmosis/zodiac_osmo_bal_vault/src/contract.rs:718 and 719. We classify this issue as minor because the contract owner can recover from it by updating the fee conguration.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Vaults are not enforcing ash loan repayment and fees amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "Vaults are designed not to enforce any specic logic for ash loans, like the requested fee amount and the restriction to repay the loan in the same block. Those functionalities are implemented in the ash loan contract, and the vault owner can allow a trusted ash loan contract to operate its funds. While this approach is achieving a good level of modularity, it shifts safety checks from the vault to the ash loan contract, which increases the attack surface. A compromised ash loan contract could allow an attacker to disrupt the service for vault users by blocking withdrawals or draining funds from the vault. This could happen, for example, if the keys of the ash loan contracts admin are compromised, allowing an attacker to upgrade the contract. We classify this issue as minor because the ash loan contract is a trusted entity set by the vault owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Incorrect error message in calc_pt_yt_ownership_split function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "In contracts/osmosis/zodiac_osmo_bal_lockup_vault/src/utils.rs:123-12 8, the error message states \"at sqrt(k) {lp_per_l} - compose of {pool_l} / {pool_shares}\", indicating that lp_per_l is calculated from pool_l divided by pool_shares. This message is incorrect because lp_per_l is calculated from pool_shares divided by pool_l, as seen in line 111.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Update of contract owner causes inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "contracts/osmosis/zodiac_osmo_bal_vault/src/contract.rs:358 and In the contracts/osmosis/zodiac_osmo_factory/src/contract.rs:165, CreateYieldVault message and create_vault function, respectively, instantiate a contract with the admin set to config.owner. This could be an issue since config.owner is an updatable eld. Updating the owner of these contracts leads to an inconsistency where the contract's admin diers from the current contract owner. Consequently, the previous owner may still have the capability to migrate the contracts, even though they are no longer the current contract owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Update of vault conguration could lead to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "contracts/osmosis/zodiac_osmo_bal_vault/src/contract.rs:577 and the owner In contracts/osmosis/zodiac_osmo_factory/src/contract.rs:581, is able to update the maturity_timestamp and the collateral_token, respectively. Updating these values leads to inconsistency if the contracts are already in use. Changing the maturity timestamp would manipulate the market since it will indirectly aect the value of PT and YT tokens. Updating the vaults collateral token leads to all deposits and stored data referring to the wrong token.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Possible vault key collision will lead to overwritten data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "In contracts/osmosis/zodiac_osmo_factory/src/contract.rs:187, during vault instantiation, a key is generated and stored. The key is composed of vault_type and collateral_token. However, no separator is used. Consequently, key collisions are possible with values that have the same concatenated result. If such a key collision occurs, existing data will be overwritten. We classify this issue as minor because the vault_type and collateral_token values are provided by the owner. Please see the test_create_vault_key_collision test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. RemoveTokenAction message silently fails",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "remove_token_action The contracts/osmosis/zodiac_fee_collector/src/contract.rs:135, fails if the provided token_action denom is not stored in the contract. function, dened in silently Consequently, a contract that executes the RemoveTokenAction message cannot correctly handle this error, and users are not getting feedback on the execution status.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Contracts are not compliant with CW2 Migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "The protocol contracts do not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "20. Owner can execute arbitrary ComosMsgs",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "The vault contract allows the owner to execute arbitrary CosmosMsgs through the ExecuteMsg::OwnerAction entry point. Among others, this message can be used to move contract funds to an arbitrary address through a BankMsg. In the event of compromised access keys or a malicious insider, this would allow the sweeping of all the funds of the contract. the In addition, the fee collector contract allows callbacks to execute arbitrary CosmosMsgs in through contracts/osmosis/zodiac_fee_collector/src/contract.rs:120-127. As this callback can be executed as part of the CONFIG.token_actions dened by the owner, they will be able to select the arbitrary message that would be executed. ExecuteMsg::Execute entry point",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "21. Insucient input validation across contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Zodiac Protocol/2024-01-02 Audit Report - Zodiac Protocol Core v1.0.pdf",
        "body": "The smart contracts within the scope currently lack sucient validation before saving conguration details. This could lead to issues that disrupt the correct behavior of the protocol and possibly lead to failing transactions. the lockup vault contract misses validation upon instantiation and update in Firstly, contracts/osmosis/zodiac_osmo_bal_lockup_vault/src/contract.rs:73- 84, 752-773, 879-906:  token_actions:  Lack of denom validation could lead to failing transactions.  Duplicate order value could cause undesired behavior when processing transactions.  Line that states to executmsg::swapdenom{in_denom, out_denom, pool}. If the only expected messages are the contract-only entry points SwapDenom and SwapToPool, the message should be restricted accordingly. the message restricted should be  If the action in the KeeperTokenAction is a SwapToPool message, the pool_id should be validated to hold the LP token denom as the parent vaults collateral_token denom to prevent incorrect LP tokens accruing in lines 227-229.  If the action in the KeeperTokenAction is a SwapDenoms message, the denom_in should be validated not to be the yield token denom to prevent transferring them.  A max limit should be implemented to the number of token actions to prevent an out-of-gas scenario in lines 848-864.  Allowed messages in the KeeperTokenAction should be limited to SwapDenoms and SwapToPool because other messages would fail.  maturity_timestamp is not enforced to be in the future, which could disrupt the expected behavior of the protocol. This happens during the contract instantiation and conguration update.  lockup_duration should be larger than zero, as MsgLockTokens of zero has no eect.  keep_cooldown_seconds should be larger than zero to implement a minimum cooldown duration.  closing_penalty_bps is not checked to be within the 0-9999 range. Fee transfer messages will fail if equal to the minimum, and the amount aected by the fee will fail to be transferred if a maximum fee is applied. Secondly, the fee collector contract misses validation upon instantiation and update in and contracts/osmosis/zodiac_fee_collector/src/contract.rs:17-32 157-178:  token_actions:  Lack of denom validation could lead to failing transactions.  Repeated order could cause undesired behavior when sending transactions.  A max limit should be implemented to the number of token actions to prevent an out-of-gas scenario in lines 246-260.  Possible centralization risk due to arbitrary Cosmos messages via ExecuteMsg::Execute message. Thirdly, the vault contract misses validation upon instantiation and conguration update in contracts/osmosis/zodiac_osmo_bal_vault/src/contract.rs:559-595:  maturity_timestamp should not be in the past for the protocol to work as intended. Besides that, this should not be updatable to prevent state inconsistencies between the factory contract and the vault contract.  collateral_token should be checked with pool_id to ensure the pool indeed uses the provided collateral token denom as liquidity token. Besides that, the value should not be updatable to prevent state inconsistency regarding contract balance.  ptoken_l should be checked to not be zero to prevent a division by zero error in line 112.  pool_id should be checked to ensure the pool is a XYK pool with a total of two assets.  claim_yield_fee is not checked to be within the 0-9999 range.  redeem_fee is not checked to be within the 0-10000 range. Fourthly, the factory contract does not validate the vault_types upon instantiation or update in contracts/osmosis/zodiac_osmo_factory/src/contract.rs:29-43 and 92-94. It should be noted that identiers of type string are allowed for this eld, which is prone to errors compared to an enum. Lastly, the flash loan contract does not validate the fee to be between 0 and 10000 upon in contracts/zodiac_flash_loan/src/contract.rs:28-47 and 247-275. instantiation update and",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Missing HTTP timeouts enable Slowloris DoS attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-04-29 Audit Report - Router Voyager Forwarder v1.0.pdf",
        "body": "In cmd/voyager-forwarder/main.go:86, an HTTP server is instantiated and enabled to listen for incoming requests on port metricPort. However, since no HTTP timeouts are in place to handle idle connections the server is vulnerable to Slowloris Denial-of-Service (DoS) attacks. This attack method operates by transmitting large amounts of data slowly, which might succeed in keeping the connection alive in the event of a timeout, ultimately resulting in a DoS.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "1. Attackers can cause DoS of the rebalancer contract by sending arbitrary coins to the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "get_inputs in The contracts/services/rebalancer/src/rebalance.rs:314, queries all the coin balances of an account and then iterates over them to create a targets_helpers vector for a target denom within the do_rebalance function. function, dened This iteration over bank balances is problematic because coins held in an account can be manipulated externally. For instance, an attacker can enumerate all valence accounts creating several worthless tokenfactory coins, and multi-send them to all of the accounts. This unbounded iteration will errors and leading to a DoS of the rebalancer contract. increase the gas consumption, up to the point of out-of-gas This issue can be resolved through a contract migration, but it would have a critical impact if the contract is instantiated without dening an admin and hence could not be upgraded.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Rebalancing mechanism scalability issues allow attackers to perform DoS attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "The rebalancing mechanism, specically the execute_system_rebalance function in contracts/services/rebalancer/src/rebalance.rs:28, executes the rebalance of the rst limit accounts. instance, an out-of-gas error can occur However, out-of-gas errors coupled with a potential incentive misalignment can restrict the number of accounts that can be rebalanced at one time and increase the total rebalance cost. For in the get_prices function dened in contracts/services/rebalancer/src/rebalance.rs:255-281 due to nested iterations through the denomination whitelists. The issue is the exhaustive pairing of all denominations from both whitelists, instead of limiting to those in use by the portfolios being rebalanced. Additionally, AuctionsManager contract. each inner iteration includes a smart query to the there Furthermore, The potential execute_system_rebalance function is permissionless so it is expected that any user can call the function to kick o a rebalance, but there is no guarantee that a user who is paying the gas and initiating the rebalance will even have their own account rebalanced. misalignment. incentive is a This implies that rebalancing may not be executed frequently enough and will not process all the accounts before the end of the cycle. Consequently, attackers can leverage the mentioned weakness to perform various attacks aiming to cause a DoS of the rebalancer. For instance, an attacker could spam a very large number of accounts registered to the rebalancer to make the rebalance operations more costly, discouraging executors that have to spend gas on rebalancing these accounts and consequently render the service unusable.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. UpdateDenomWhitelist and UpdateBaseDenomWhitelist execution may cause conicts with denoms in use and rebalancing halt",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "UpdateDenomWhitelist The in contracts/services/rebalancer/src/contract.rs:353, directly updates the DENOM_WHITELIST. message handler, the in Likewise, contracts/services/rebalancer/src/contract.rs:373, directly updates the BASE_DENOM_WHITELIST. UpdateBaseDenomWhitelist message handler, However, this may cause potential issues in the future for rebalancing and price calculation since the RebalancerConfig may contain targets with a denom that has been removed from the whitelist. in Consequently, contracts/services/rebalancer/src/rebalance.rs:308, halting the entire rebalancing cycle. get_inputs function could panic the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Incorrect leftover calculation if no tokens were sold during the auction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "In contracts/auction/auction/src/execute.rs:246-248, during the execution of in case no tokens were sold during the auction, total_sent_sold_token is not updated to track the amount of funds transferred. the finish_auction function, Consequently, auction, leading to incorrect calculations and the impossibility of nishing the dutch auction. the auctions available_funds will be added as leftovers to the next",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Prices equal to zero cause rebalancing to panic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "In contracts/services/rebalancer/src/rebalance.rs:313-316, during the execution of a rebalance, the get_inputs function performs a division by price. prices However, in contracts/auction/price_oracle/src/contract.rs:54, there is no validation to ensure that the price is not zero. storing when since price zero can the be Consequently, rebalances. in case the price is zero a division by zero will occur, blocking system",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Code IDs unregistered before whitelisting could allow attackers to instantiate whitelisted malicious contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "contracts/services_manager/src/contract.rs:31, In instantiate function does not perform any validation on the provided whitelisted_code_ids before they are saved to WHITELISTED_CODE_IDS. the This is potentially problematic because if a code ID is not currently stored on the chain, an attacker can attempt to upload a malicious whitelisted service with the aforementioned code ID. is issue This contracts/services_manager/src/contract.rs:164, contracts/auction/auctions_manager/src/contract.rs:31. present also the in UpdateCodeIdWhitelist message and in in We classify this issue as minor because this misconguration is only possible from the admin during the instantiation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Division by zero if the auction start block equals the end block",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "In contracts/auction/auction/src/helpers.rs:7 during the execution of calc_price function, terms.end_block and terms.start_block. the the block_diff is calculated as a subtraction between However, if both the values are equal, panic will be triggered due to a division by zero error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. SignedDecimal type has two zero values with dierent signs",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "In packages/valence-package/src/signed_decimal.rs, the implementation of the SignedDecimal type allows two zeros with dierent signs: specically (0, true) and (0, false), respectively corresponding to +0 and 0. That is possible because the implementation does not check that the values of the Decimal (e.g., element packages/valence-package/src/signed_decimal.rs:93, 101) or addition (e.g., packages/valence-package/src/signed_decimal.rs:69, 79). subtraction equal can be on Consequently, the operations could result in two dierent values representing zero.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Lack of contract ownership transfer functionality",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "In all the audited contracts, there is no way to update the Admin of the contract. Consequently, transfer the ownership of this contract, it would be impossible. in case of an issue with key management, or if it becomes necessary to",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Input vectors with duplicated elements could be stored in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "contracts/services_manager/src/contract.rs:31, In instantiate function does not perform any deduplication on the provided whitelisted_code_ids vector before saving it to WHITELISTED_CODE_IDS. the in contracts/services/rebalancer/src/contract.rs:63-64, Likewise, the denom_whitelist and base_denom_whitelist vectors are stored respectively in DENOM_WHITELIST and BASE_DENOM_WHITELIST without deduplicating them. Consequently, duplicated elements could be stored in the contract state and handled by its logic, which would cause unexpected behaviors and ineciencies.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Missing address validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "In contracts/services/rebalancer/src/contract.rs:152-158, during the update of the rebalance contract, the trustee address is not veried. As a result, the contracts could store invalid addresses leading to the inability to send messages correctly.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Centralization and risk of malicious manual price updates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "The documentation in contracts/auction/price_oracle/README.md:4-20 states that manual price update should be used only to set the initial price or if the price is not fresh enough. the However, contracts/auction/price_oracle/src/contract.rs:46-85 centralization concerns and risks of malicious manual price updates. update always admin can the price leading in to",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. max_limit parameter is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "max_limit The contracts/services/rebalancer/src/contract.rs:207, but similar packages/valence-package/src/services/rebalancer.rs:70-74. max_limit_bps parameter parameter not is is validated validated the value of in the in Consequently, any max_limit parameter range would be considered valid leading to possible miscongurations. We classify this issue as minor since only the admin can set the aforementioned value.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. The BPS value could overow",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "In contracts/services/rebalancer/src/contract.rs:135 and 193, a check ensures the sum of all total_bps does not equal 10000. this However, in contracts/services/rebalancer/src/contract.rs:121 and 180, making the entire check ineective. potential consider overow check does not a",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Missing validation for auction_strategy parameter",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "In contracts/auction/auction/src/contract.rs:63, msg.auction is stored in AUCTION_STRATEGY. However, the start_price_perc and end_price_perc elds of action_strategy are not validated before being stored in the contract leading to possible miscongurations. We classify this issue as minor since only the admin can set the aforementioned value.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Ineciencies in auction nalization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "In contracts/auction/auction/src/execute.rs:310-318, during the execution of the finish_auction function, a new element containing the computed avg_price is added to the TWAP_PRICES VecDeque. However, adding a new element to a VecDeque could require a reallocation with an O(n) asymptotic cost due to resizing operations. For instance, if the TWAP_PRICE_LIMIT constant is set to a large value, such as 1000, then adding a new price could result in copying 512 items due to VecDeque's internal buer resizing. Initially, an empty buer has a capacity of 0, and it expands by doubling its size each time a resize is necessary starting from 4. The last resize before increasing the capacity to 1024 provides an attack opportunity window. Consequently, this results in excessive gas spending for users potentially leading to an out-of-gas exception.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. The duration of unsold auctions is implicitly prolonged",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "In contracts/auction/auction/src/state.rs:29, the state variable end_block is dened and used to interpolate the current price to terminate an active auction. it However, in contracts/auction/auction/src/execute.rs:206 in the finish_auction function. duration auction aects only the an of terminated in the do_bid function dened in In fact, when the auction is contracts/auction/auction/src/execute.rs:106, variable available_amount is checked to be strictly positive but the end_block variable is not checked, so the duration of the auction is implicitly extended if it still has unsold tokens. the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Usage of expect and unwrap functions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "The unwrap and expect functions are used in the codebase to handle Options, for example contracts/services/rebalancer/src/contract.rs:92, contracts/services/rebalancer/src/rebalance.rs:136, 308, 316, 411, and 596. in However, the usage of those functions is generally discouraged because errors result in panics without meaningful error messages. They also cause the wasm execution to abort, which does not allow handling of the error from calling functions.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Excessive gas consumption during account registration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Timewave/2024-04-10 Audit Report - Timewave Computer Valence Services v1.0.pdf",
        "body": "contracts/services/rebalancer/src/helpers.rs:29-36, In function causes high gas costs when registering an account with the rebalancer service. the has_dup This function, designed to identify duplicate targets, operates with O(N2) complexity due to its nested iteration, despite the minor optimization of the inner loop. Consequently, it will cause the transaction executor to consume an excessive amount of gas.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Liquidated and excess funds are stuck in the liquidation lterer contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "contracts/liquidation-filterer/src/contract.rs:84, the In execute_liquidation function does not properly handle collateral transfer after a liquidation attempt. We outline three possible scenarios that causes funds to be stuck in the contract: Firstly, the liquidation logic forces the caller to provide funds in line 99, but there is a possibility that the user to liquidate is not liquidatable. In this case, the provided funds are not refunded. the red bank refunds excess funds to the liquidation lterer contract (see Secondly, contracts/red-bank/src/execute.rs:1083-1088). There is no way to withdraw these excess funds though. Lastly, the red bank contract will transfer Mars tokens to the contract after a successful liquidation attempt. There is no logic in the contract that allows a withdrawal in return for the liquidated collateral. As a result, the liquidated collaterals are inaccessible.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Liquidation lterer contract cannot process multiple liquidations eciently",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "contracts/liquidation-filterer/src/contract.rs:114, In two of Liquidation messages are constructed, debt_denom or user_address, the transaction will return an error. when them have the same least if at The former happens because the sub-messages reuse the total funds with the same denom. Since the rst message already includes all funds, the contract will not have enough funds to process the subsequent liquidation messages with the same denom. The latter fails because the contract would send duplicate liquidation messages to the red bank contract, and since liquidating a user twice is not possible, the transaction would fail too. Additionally, the liquidation lterer contract does not tolerate failures. The whole liquidation execution would fail if any liquidation attempts were frontrunned by another liquidator. As a result, undercollateralized positions might not be liquidated eciently during high volatility and activity in the market.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Smart contracts holding tokens on Terra classic cannot claim their airdrop",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "of the current airdrop implementation The in contracts/airdrop/src/contract.rs requires users to prove their ownership of Terra tokens by providing signatures using the same private keys that were used in Terra classic. Smart contracts, however, do not have the capability to sign messages as they do not have private keys. As a result, smart contracts are unable to provide the required signatures, making it impossible for them to claim airdrops. This prevents smart contract holders from participating in airdrops, which could lead to a signicant portion of the token holders being excluded from the airdrop distribution. contract smart",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. liquidation-filterer contract is not compliant with CW2 Migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The liquidation-filterer contract does not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. InstantiateMsg is not validated in the airdrop contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In contracts/airdrop/src/contract.rs:28, when handling the InstantiateMsg, no validation of the merkle_root length and sent funds is performed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Schedule structs are not validated in the vesting contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In  contracts/vesting/src/contract.rs:37,  contracts/vesting/src/contract.rs:102, and  contracts/vesting/src/contract.rs:65, the Schedule structs are handled without being validated. This could lead to situations where the start_time timestamp value is less than the current timestamp or the cliff value is greater than or equal to duration.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. liquidation-filterer contract could be optimized",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The liquidation-filterer contract is designed to be able to trigger a set of liquidations in the red bank. In order to accomplish this, the LiquidateMany message takes a list of Liquidate elements, iterates through all of them, performs a query in order to check if they are liquidatable, and then forwards the Liquidate messages to the red bank. Since the list of Liquidate elements could be of a relevant cardinality and each iteration performed both a query and a transaction, there is a possibility that the execution goes out of gas and reverts all the intended liquidations. Also, transactions can change the health status of a position, which invalidates previous query results.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/liquidation-filterer/Cargo.toml  contracts/airdrop/Cargo.toml  contracts/vesting/Cargo.toml While enabled implicitly through the workspace manifest, future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Contracts should implement a two step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Custom access controls implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "Contracts implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Incorrect comment for LiquidateMany message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In contracts/liquidation-filterer/src/msg.rs:17, the LiquidateMany message is Set emission per second for an asset to holders of its maToken. This is incorrect because the messages functionality is to liquidate multiple undercollateralized positions from the red bank. the comment for",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Suboptimal voting power calculation in vesting contract allows for unfairness in voting process",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The current implementation in contracts/vesting/src/contract.rs:199 calculates voting power from staked tokens, locked tokens in the vesting contract and unlocked tokens from the vesting contract that are not yet withdrawn. Ok(Some(position)) => position.total - position.withdrawn However, this calculation method is suboptimal because it does not account for tokens that are currently withdrawable. In fact, it allows users to vote on a proposal and immediately withdraw the withdrawable tokens, which means that the tokens used to vote are no longer staked and do not contribute to the voting power. This can lead to unfairness in the voting process.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Voting power is valid on the same block schedule created",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "contracts/vesting/src/contract.rs:197, In query_voting_power functionality determines a users voting power by checking the POSITIONS storage state. Since positions are directly updated in the same block when create_position is called, this might allow an exploit similar to the Beanstalk exploit. the it With that said, is currently not exploitable since only the contract owner can create is another smart contract allowing positions. However, suppose the contract owner permissionless position creation. In that case, an attacker can ash loan a big amount of Mars tokens to create a large position for themselves which comes with high voting power. We consider this a minor issue because it may lead to a vulnerability if the architecture changes in the future.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Astral assembly does not impose negative consequences for creation of low-quality or malicious proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "The end_proposal function in contracts/assembly/src/contract.rs:330 returns the proposal creators funds regardless of the outcome of the proposal. This does not provide any disincentive for submission of malicious or spam proposals, which could allow malicious actors to grief the assembly contracts.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Link validation allows for non fully formed domains to be whitelisted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "validate_links The in packages/astroport-governance/src/assembly.rs:387 performs validation on whitelisted links during instantiation and cong updates. Currently, the validation criteria for links is related to the characters of the string. This is potentially problematic when viewed in conjunction with how proposal links are checked against the whitelist. function is link proposal validation in The packages/astroport-governance/src/assembly.rs:280. the whitelisted links are used as a prex validation for the proposal link. This can be problematic if the whitelist contains entries that are not FDQNs (fully qualied domain names). Specically, if it will allow an attacker to create a the link does not contain a TLD (top level domain), if the whitelist malicious domain that will still pass the whitelist validation. For example, contains https://astroport, attackers could register a domain that shares the same prex such as https://astroport-gov.com or a domain that has a dierent TLD such as https://astroport.xyz to conduct an attack. handled Currently,",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. No minimum value for voting quorum in cong validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "the contracts assembly the In instantiate and update_config functions apply a maximum quorum size during cong validation. However, no validation is performed to ensure that the minimum quorum size is not below a sensible threshold. contract/assembly/src/contract.rs, in This could enable the quorum threshold to be set to a level whereby proposals could be passed without a signicant proportion of the total token supply being involved in the proposal.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Unbounded loop could run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "function The in contract/escrow_fee_distributor/src/contract.rs:284 uses a loop and break conditions to calculate the claim amounts from the last claimed period to the current period. calc_claim_amount found In the case that claims are not processed for a long period of time this loop may run out of gas and become unexecutable. However, due to the unlikelihood of this occurring and the fact that it would only aect one user the severity is noted as minor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. New owner proposal minimum and maximum expiry times",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "The function propose_new_owner in packages/astroport/src/common.rs:34-67 enables the current owner of a contract to propose a new owner who is subsequently able to claim the contract ownership. The original owner species an amount of time, expires_in, during which the proposal is claimable. However, there are no minimum or maximum requirements to the amount of time that the proposal can be active for. This could lead to a proposal that expires immediately preventing a proposed owner from claiming or alternatively a claim being active for excessives periods of time.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Incorrect attribute emission during pool deactivation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "of execution in The upon contracts/tokenomics/generator/src/contract.rs execution. However, the attribute action of that event is incorrectly dened as setup_pool. This could lead to event listeners or other queries from being unable to identify blocks that contain deactive_pool messages. deactive_pool function event emits the an",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Updating the expiration period can lead to unexpected behavior of live proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "the function in In contract/assembly/src/contract.rs:532 the expiration period can be updated. Doing so would also alter the expiration period of live proposals. This could have the consequence of live proposals ending much sooner than anticipated and lead to operational issues. update_config found",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Update of factory contract owner may cause inconsistency",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "execute_create_pair The in contracts/factory/src/contract.rs:352 instantiates a new pair contract, with the admin set to config.owner. This may be problematic as config.owner is an updatable value which may lead to a pair contracts admin being dierent from the factory contracts owner. function Note, that the scope of this issue is related to migrations of the pair contract. This means that the previous owner of the factory contract will remain the admin of the new pair contract and can perform contract migrations. This situation is not inherently malicious or exploitable, but it does present a situation where it becomes dicult to manage the migration of multiple pair contracts with potentially many dierent owners. the previous owner are compromised An extreme scenario where the private keys of presents room for human error since every pair would need to have the admin manually updated.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Blacklist design presents centralization concerns",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "a The receive_cw20 function in contracts/voting_escrow/src/contract.rs:447 implements CreateLock, ExtendLockAmount, and DepositFor functionality. While this does not pose a direct security threat, it allows the owner and guardian_addr to control which addresses have voting power. This raises concerns around centralization of the protocol. blacklist_check control access the to to",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Use of magic numbers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "In the factory contract in packages/astroport/src/factory.rs:61, numbers are used without context for calculations  so-called magic numbers. Usage of magic numbers is problematic since they decrease the maintainability of the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Duplicate zero amount check is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "the in In contracts/escrow_fee_distributor/src/contract.rs:182-216, claim amount is validated during the creation of the transfer message to ensure it is not zero. This check is repeated in the function transfer_token_amount in line 204. This is inecient. function claim the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Contract should return error if boolean parameter is updated to the same value that is currently set",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "update_config The in contracts/escrow_fee_distributor/src/contract.rs:377 allows the owner to update the contracts conguration parameters. To improve the user experience, the function should return an error if the value of is_claim_disabled is updated to the value that is currently set to inform the caller that the value has not been changed. function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Missing access control of strategy contract conguration updates allows attackers to DoS attack the protocol and redirect queries to malicious contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-19 Audit Report - Drop Contracts v1.1.pdf",
        "body": "the exec_config_update In contracts/strategy/src/contract.rs:187-226, function of the strategy contract allows updating the contract congurations such as the core, puppeteer, validator-set and distribution contract addresses, as well as the reference denom. However, since there is no access control for the function, anyone can update the contracts cong to arbitrary values. Consequently, attackers can consistently spam UpdateConfig messages to store invalid addresses for contract dependencies causing the strategy contracts queries to fail and disrupting protocol operations. Additionally, attackers could update contract dependencies to malicious contracts that return malicious data.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Incorrect fee accounting leads to loss of funds and DoS",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-19 Audit Report - Drop Contracts v1.1.pdf",
        "body": "get_stake_msg The in contracts/core/src/contract.rs:1063-1127, processes delegation messages, updating the COLLECTED_FEES with the amount to the respective fee_address. to be sent function, dened Those fees are then transferred from the ICA account to the fee collectors during the the get_non_native_rewards_and_fee_transfer_msg function execution of dened in lines 1301-1314. However, after the fees are transferred by the puppeteer contract to fee collectors, the COLLECTED_FEES map is not reset. Consequently, as the FSM continues normal operation, more fees are added and all the fees, including the ones that have been already sent, are transferred again. This leads to a loss of funds for the users and eventually causes a denial of service, due to the impossibility of transferring an amount larger than the balance of the ICA account.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. The protocol can get permanently stuck in the Staking state due to unhandled errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-19 Audit Report - Drop Contracts v1.1.pdf",
        "body": "the execute_tick_staking In contracts/core/src/contract.rs:693-696, function within the core contract acts as the designated handler when the ContractState transitions to Staking during routine procedures. However, if during this process the puppeteer contract callback to the PuppeteerHook stores a ResponseHookMsg::Error because of a timeout or an error in the ICA transaction, the execute_tick_staking function consistently returns an error in line 695. Consequently, lacking an alternative handler to progress the ContractState, the routine becomes unable to proceed, resulting in the protocol becoming permanently stuck.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. First bonding results in a division by zero error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-19 Audit Report - Drop Contracts v1.1.pdf",
        "body": "contracts/core/src/contract.rs:173-179, In function calculates the actual exchange_rate with the following formula: the query_exchange_rate _ = _ + _ + __  _  __ __ in a zero exchange_rate since However, during the rst bonding, delegations_amount, total_lsm_shares and unprocessed_unbonded_amount are zero while core_balance and current_stake would be the same amount. results it this Consequently, contracts/core/src/contract.rs:788, causing the protocol process bonding. division would result by in a in zero to not be able to error",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Attackers can spam Unbond messages to cause DoS of the protocol",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-19 Audit Report - Drop Contracts v1.1.pdf",
        "body": "In contracts/core/src/contract.rs:952-959, the execute_unbond function of the core contract allows users to unbond their tokens. By doing so, the execution appends an UnbondItem to the unbond_items vector of the current unbond_batch and then stores it in the contract. However, since there is no maximum cardinality of items that can be appended in the unbond_items vector and no minimum unbounding amount requirement, attackers could spam a large amount of Unbond messages with a small unbounding amount to grow the vector size. This would result in increasing the costs for encoding and storing the unbond_items vector to the point of the execution running out of gas and hindering users to unbond.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Incorrect mint calculation during DenomType::LsmShare bonding",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Drop/2024-08-19 Audit Report - Drop Contracts v1.1.pdf",
        "body": "In contracts/core/src/contract.rs:1005-1064, enables users to bond their tokens and mint derivatives. the execute_bond function However, if the denom_type is equal to DenomType::LsmShare, the amount is directly used without calculating the underlying amount. Consequently, an incorrect number of tokens is computed and minted, resulting in inaccurate accounting and potential nancial losses for users. This issue has been independently reported by a third party. Status: Externally Reported 7. Invalid nite state machine transitions prevent expected ow execution Severity: Major There are multiple instances of state transitions that are not considered valid in the context of the nite state machine (FSM). in the example, For in contracts/core/src/contract.rs:562, the FSM state is set to Claiming, even if there are no validators_to_claim. Since the state transition from Claiming to Unbonding is not valid this would prevent the branch from being executed in lines 574-579. execute_tick_idle, function However, even if the state of the FSM remained in the Idle state, the only valid transition to Unbonding is from Staking. This would prevent any unbondings in any other tick except execute_tick_staking. In particular, in execute_tick_claiming the branch cannot be executed in lines 651-654. Similarly, in execute_tick_transferring the branch in lines 676-679 would be an invalid state transition from Transferring to Unbonding.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Unsuccessful MsgTransfer message could drain the relayers funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Persistence/2023-02-17 Audit Report - pSTAKE Native v1.0.pdf",
        "body": "In x/lscosmos/keeper/handshake.go:488-500, the function responsible for handling Timeout and Acknowledgement_Error responses (see lines 196 and 258) originated by MsgTransfer messages try to resend them through GenerateAndExecuteICATx. In a scenario where a transaction always has unsuccessful responses, the execution will end up performing a loop between the controller and controlled chains with the result of draining the relayers funds. For example, this could happen if the controlled chain is halted or is performing an update. Additionally, an attacker may trigger multiple such transfers to congest and slow down the chain. As a result, users will nd their transactions taking more time to process.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Failed cross-chain requests are repeatedly processed in Router Chains EndBlocker, potentially causing Denial-of-Service",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-29 Audit Report - Router Integration v1.0.pdf",
        "body": "Cross-chain requests are processed at the end of each block in Router Chain's EndBlocker function. A request to ready to be executed, types.CROSSCHAIN_TX_READY_TO_EXECUTE, is handled in the Execute function and remains in this status until the cross-chain request is executed on the destination chain and orchestrators report the execution back to Router Chain. i.e., with the status set that is If executing the cross-chain request on the destination chain errors and the transaction reverts, relayers will attempt to retry the request. However, if the request repeatedly fails, Router Chain will indenitely process the request in the EndBlocker function, resulting in an ever-growing list of requests to be processed. This can cause a Denial-of-Service (DoS) attack on Router Chain. Such a failing cross-chain request can be caused on an EVM destination chain by having the 0x0000000000000000000000000000000000000000, routeRecipient bypassing the empty address check in the iSend function and causing the transaction to revert on the destination chain due to the zero-address validation in the iReceive function. set to Similarly, this can be caused by a malicious actor that uses an ASM contract that always reverts.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Malicious relayer can purposefully fail cross-chain requests on EVM destination chains",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-29 Audit Report - Router Integration v1.0.pdf",
        "body": "The Solidity GatewayUpgradeable contract receives cross-chain requests with the iReceive function, called by permissionless relayers, and calls the specied handler contract's iReceive function. This external call forwards all but 1/64 gas to the called contract, a measure employed by the EVM in EIP-150 to mitigate DoS attacks. If the supplied 63/64 gas to the external call is insucient, the call runs out of gas, while the caller iReceive function still has 1/64 gas available to nish the execution and to emit the IReceiveEvent event that will be picked up by orchestrators and forwarded to Router Chain as an acknowledgment request. This acknowledgment packet will have the execFlag set to false, signaling to the source chain contract that the cross-chain request has failed on the destination chain. This concludes the cross-chain request. This issue can be exploited by a malicious relayer by frontrunning a legitimate relayer, using its payload, and meticulously setting the gas limit such that the external call to the handler contract will be guaranteed to run out of gas. Consequently, this allows an attacker to cause a Denial-of-Service for cross-chain requests, as the destination contracts will not be able to process the request and run out of gas successfully. this vulnerability has also been observed in the iAck function of Similarly, GatewayUpgradeable contract and the iReceive function of contract. the the AssetBridge",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Fee settlement can be bypassed for inbound and crosstalk requests, resulting in relayers not being compensated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-29 Audit Report - Router Integration v1.0.pdf",
        "body": "Cross-chain request fees are settled on Router Chain as part of the SettleFees function called in every block. if the fee settlement in the called SettleFeeCrosstalkRequest function However, errors, for example, if the fee payer is unapproved, the acknowledgment request's status is to CROSSCHAIN_ACK_TX_COMPLETED in the CompleteNoAckRequests anyway set the relayer will not be function, eectively bypassing the fee settlement. As a result, compensated for the cross-chain request. Similarly, this issue also exists in the SettleAckFees function.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. NEAR gateway contract does not allocate sucient gas for handler calls",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-29 Audit Report - Router Integration v1.0.pdf",
        "body": "When the NEAR gateway contract calls the i_receive function of the handler contract, it only allocates a gas limit of 5 * TGAS. This is problematic because the allocated gas amount is insucient to nish all the executions without causing an out-of-gas error. the The NEAR asset-forwarder and asset-bridge contracts both implement i_receive function that will be executed by the gateway contract. However, both contracts will consume more than the allocated gas amount, causing the transaction to fail due to an out-of-gas error. For example, the NEAR asset-forwarder contract will allocate 10 * TGAS when transferring funds to the recipient, while the NEAR asset-bridge contract already consumes the full gas amount when calling the handle_ireceive_callback function. Consequently, all handler calls that consume gas units larger than 5 * TGAS will fail due to an out-of-gas error.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. AssetBridge deviates from standard safety practices by omitting ASM for custom security checks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2024-05-29 Audit Report - Router Integration v1.0.pdf",
        "body": "The Router protocol suggests that applications use Additional Security Modules (ASM) for additional security checks while processing the cross-chain request. As the AssetBridge contract is an application implemented by the Router team for token bridging, it should use ASM for additional security checks. The current impact is that there are no maximum limits on deposits, which is highly advisable. Additionally, ASM modules could be upgraded to enhance the bridge's security further.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. No validation of IBC message timeout",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport IBC v1.0.pdf",
        "body": "The length of controller and satellite contracts in: IBC message timeouts is dened during the instantiation and update of  contracts/controller/src/contract.rs:36  contracts/satellite/src/contract.rs:44  contracts/satellite/src/state.rs:55 However, there is no validation of this timeout value, which could lead to timeouts being dened that are of zero value or very high, up to u64::MAX. This may prevent the execution of cross-chain interactions as messages may expire before they can be handled or, in the case of very high timeout values messages may remain active indenitely. We classify this issue as minor since it can only be caused by the contract owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Contract creators can update the gas price into invalid integer value in order to disable the wasmxs BeginBlocker execution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "cw-injective:contracts/registry/src/contract.rs:149, In creator can update the gas price to an invalid string. the contract Since gas prices are supposed to be denominated in integer values, this would cause the in ToContractExecutionParams injective-core:injective-chain/modules/wasmx/types/exec_msgs.go:12 7 due to an invalid gas price. message fail to Consequently, the ExecuteContracts functionality in BeginBlocker will always fail due in to the FetchRegisteredContractExecutionList function returning an error injective-core:injective-chain/modules/wasmx/keeper/wasm.go:50. A malicious user can use this behavior to inhibit the BeginBlocker execution of the wasmx module.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Valid positions may be rejected prior the application of PnL",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "the During injective-core:injective-chain/modules/exchange/keeper/wasm_privil eged_action.go, the initial margin requirements of positions are veried twice: It is veried before and after the application of PnL in lines 128 and 139, respectively. synthetic handling trades of in Consequently, if a position does not fulll the initial margin requirement before the application it afterwards, an error is thrown. This implies that valid of position delta but does fulll positions can be rejected.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Governance is not able to eectively remove a contract from registry",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "In injective-core:injective-chain/modules/wasmx/proposal_handler.go:1 3-24 no proposal is dened that allows removal of a contract from the registry. The wasmx module can disable a contract, but the contracts creator could simply re-activate it by interacting with that contract. This implies that a compromised contract, a contract that has been migrated to a malicious code, or one that has lost its reputation, cannot be removed from the registry.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. registry contract and wasmx module are not aware of registered contract migrations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "The ContractRegistrationRequestProposal proposal species a contract address that should be added in the registry. The contract address identies the contract instance, but not its deployed wasm code. In fact, a malicious contract creator could migrate a registered contract to a new wasm binary in order to steal user funds or to execute malicious logic that can impact the entire chain, for example, a high resource computation in the begin_blocker handler.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Integer gas price type allows negative values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "The Int type is used to represent the gas price in the ContractRegistrationRequest struct in injective-core:injective-chain/modules/wasmx/types/wasmx.pb.go. dened As an integer type can hold both positive and negative numbers, a negative gas price would trigger an error during the execution of a wasmxs registered contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Max contract gas limit can be set lower than minimum execution gas limit, causing contract registration to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "In injective-core:injective-chain/modules/wasmx/types/params.go:111-1 there is no validation to ensure the MaxContractGasLimit value is higher than 21, keeper.MinExecutionGasLimit, which represents the minimum gas limit (90396 in injective-core:injective-chain/modules/wasmx/keeper/wasm.go:17). As a result, a misconguration of the maximum contract gas limit to be lower than 90396 would in the injective-core:injective-chain/modules/wasmx/proposal_handler.go:3 0 to always fail, aecting the handleContractRegistration functionality. validation cause",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Too many contracts registered would cause GetContracts and GetActiveContracts query messages to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "In cw-injective:contracts/registry/src/contract.rs:220 and 237, both to fetch all query_contracts and query_active_contracts messages attempt contracts registered in the storage and return them to the caller. This is problematic because the query could run out of gas in an execution context if too many contracts are stored.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Custom calls between Cosmos SDK modules and CosmWasm contracts require third-party developers to implement their own authorization logic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "The wasmx and exchange modules are performing authorized calls to particular CosmWasm contract handlers using custom logic. In order to do so, Cosmos SDK modules are performing Execute functions from wasm module impersonating the receiver contract. From the CosmWasm side, it is as if the message comes from the contract itself. This means that on the CosmWasm contract, contract developers need to implement custom authorization logic in order to restrict the access of a particular entrypoint only to Injective Cosmos SDK modules. Delegating the authorization of the interaction between modules and smart contracts to third-party developers is risky since they could not implement it in the right way or not implement it at all. Additionally, the workaround to use the receiver contract address to call modules reserved handlers has the side eect that the contract can execute calls that should be reserved to wasmx and exchange modules by itself.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Name validation can be bypassed with whitespace",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "In injective-core:injective-chain/modules/exchange/types/msgs.go:1288, the execution will revert if the data name provided is an empty string. This validation can be bypassed by providing whitespace. Ideally, whitespaces should be prohibited since they are also invalid names.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Consider deduping batch contract addresses in ValidateBasic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "In injective-core:injective-chain/modules/wasmx/types/proposal.go:83, the ValidateBasic function does not lter duplicate contract addresses contained in the ContractRegistrationRequests array. Such duplicate contract addresses would cause in each the injective-core:injective-chain/modules/wasmx/proposal_handler.go:6 0 since the contract is already registered. duplicated execution contract address fail for to",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Outstanding TODO comments present in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "TODO comments were found in the following code lines:  injective-core:injective-chain/modules/wasmx/keeper/wasm.go:1  injective-core:injective-chain/modules/wasmx/keeper/wasm.go:2  injective-core:injective-chain/modules/wasmx/keeper/wasm.go:2  cw-injective:packages/injective-cosmwasm/src/subaccount.rs:12",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. A dev-dependency is vulnerable to two CVEs",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "plotters The in cw-injective:packages/injective-math/Cargo.toml:27 is vulnerable to two CVEs: dev-dependency dened crate as a  RUSTSEC-2020-0159: chrono  RUSTSEC-2020-0071 - Potential segfault in the time crate",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. RouterCrossTalk: DoS by frontrunning with approving fees to a value of 0",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2022-11-27 Audit Report - Router v1.0.pdf",
        "body": "The RouterCrossTalk (and RouterCrossTalkUpgradeable) contracts implement the function approveFees to approve the generic handler to spend fee tokens. This function is from intended RouterCrossTalk. to  only  be  called  by implementation  contract inheriting the However,  the  function  visibility  is  external,  allowing  anyone  to  approve  fees  arbitrarily.  An attacker could front-run transactions with routerSend calls and call approveFees with a value of  0.  Eectively  preventing  the  generic  handler  from  spending  fee  tokens  and  leading to a DoS.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. RouterERC20Upgradable.sol: Paused contract does not pause minting/burning",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2022-11-27 Audit Report - Router v1.0.pdf",
        "body": "The router-protocol-router-bridge-contracts-v2/contracts/RouterERC20Up gradable.sol router-protocol-router-bridge-contracts-v2/contracts/RouterERC20Up gradableOld.sol contracts implement a pause mechanism. Currently, only token transfers are  disabled  while  the  contract  is  paused.  However,  minting  and  burning  should  also  be paused to allow mitigation in case of an exploit. and",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Static feeFactor allows economic attacks in certain market conditions, and leads to users overpaying in others",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2022-11-27 Audit Report - Router v1.0.pdf",
        "body": "In router-bridge-contracts-v2/contracts/GenericHandlerUpgradeable.sol :349, the fee is calculated on the basis of the feeFactor that admin sets and the gas value that user provides at the time of deposit. However, the feeFactor is calculated in terms of the  feeTokenAddress  so  it  can  match  the  value  of  the  native  token  of  the  destination chain.  Since  gas  prices  as  well  as  native  token  prices  are  uctuating  over  time,  but  the feeFactor  is  static,  a  misprising  of  transactions  can  easily  happen.  An  attacker  can economically attack the Router bridge when the target gas prices native token prices are high and,  eectively  paying  a  smaller fee. This would make Router run on a loss. In other market situations,  users  would  eectively  overpay  for  their  transactions. In practice, the feeToken and native token values would change every second, so it is not possible to appropriately set the feeFactor to prevent these issues.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Missing storage gaps for upgradeable contracts might lead to storage slot collisions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2022-11-27 Audit Report - Router v1.0.pdf",
        "body": "For  upgradeable  contracts,  there  must  be  storage  gaps  to  \"allow  developers  to  freely  add new state variables in the future without compromising the storage compatibility with existing deployments\"  (quote  OpenZeppelin).  Otherwise,  it  may  be  very  dicult  to  write  new implementation code. Without storage gaps, the variables in a child contract might be overwritten by the upgraded base  contract  if  new  variables  are  added  to  the  base  contract. This could have unintended and  very  serious  consequences to the child contracts, potentially causing loss of user funds or causing the contract to malfunction completely. Refer https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable bottom part the to of this article: issue This router-protocol-router-bridge-contracts-v2/contracts/ERC20SafeUpgr adeable.sol router-protocol-router-bridge-contracts-v2/contracts/handlers/Hand lerHelpersUpgradeable.sol. exists in both and",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Return value of transfer function not checked",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2022-11-27 Audit Report - Router v1.0.pdf",
        "body": "The return value of the solidity transfer function is not checked throughout the contracts in several places. instance For router-protocol-path-finder-api/Contracts/UniversalERC20.sol. the  universalTransfer  and  universalTransferFrom in in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Failure to revoke permission of the previous owner",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Router/2022-11-27 Audit Report - Router v1.0.pdf",
        "body": "The  _setLiquidityPoolOwner  function  of  router-protocol-router-bridge- contracts-v2/contracts/handlers/HandlerReserveUpgradeable.sol  does not revoke the permissions of the previous owner upon setting a new pool owner.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Wrong validation before setting Ethereum public key in conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Persistence/2022-01-20 Audit Report - Persistence Bridge - v1.0.pdf",
        "body": "In application/configuration/configuration.go:115, a validation check for non-emptiness of caspTMPublicKey is performed, but then the caspEthPublicKey conguration value is assigned.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Lack of authorization for privileged operations in the lpp contract allows users to manipulate the market",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The lpp contract does not implement an authorization logic for the execution of privileged operations and does not have the concept of a contract owner/administrator. This implies that anyone can send UpdateParameters messages to update critical contract parameters and base_interest_rate, addon_optimal_interest_rate, which can be used to manipulate the market. utilization_optimal like the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Price feeding mechanism could be permanently inhibited through market alarms",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The oracle allows contracts to subscribe to MarketAlarms in order to be notied when price changes trigger a particular condition. When a Feeder sends the FeedPrices message to update an asset price, a PriceAlarm message is dispatched and sent to all subscribing contracts. Since an O(n^2) unbounded loop through MarkedAlarms is needed to check and re alarms, a signicant number of subscriptions could lead to out of gas errors. Consequently, feeders will be permanently inhibited from providing new prices. A malicious actor could develop a contract with a computationally expensive PriceAlarm handler and subscribe potentially multiple MarketAlarms in order to cause the FeedPrices message to always run out of gas. Even without malicious intent, this issue is likely to occur since lease contract instances that users can instantiate from the leaser contract subscribe to alarms in the oracle.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Time alarms could be permanently disabled",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The timealarms contract allows other contracts to subscribe to TimeAlarms in order to be notied at a certain timestamp. The Notify transaction is used to trigger all stored alarms with a timestamp less than the actual time and execute the TimeAlarm transaction in the respective contracts. Since there is not a dened maximum number of stored alarms and a maximum amount of gas that TimeAlarm handlers can consume, the execution of Notify may run out of gas if a signicant amount of alarms are registered. Consequently, no time alarm could be triggered anymore. A malicious actor could intentionally deploy computationally expensive contracts that subscribe to TimeAlarms, consuming more gas than available and hence eectively disabling time alarms.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Lack of instantiation authorization in the lease contract allows attackers to instantiate it with arbitrary parameters and hence prevent liquidation and use arbitrary prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "During the execution of the InstantiateMsg of the lease contract, it is not enforced that its instantiator is the leaser contract. This implies that an attacker could instantiate a lease contract without the intermediation of the leaser, which allows the attacker to provide arbitrary parameters. For example, he could set a custom oracle address or liability congurations. This gives the attacker the ability to prevent liquidation and set arbitrary prices.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Incomplete Neutron messages support may lead to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "Contracts implement Neutron message specications but are not implementing their specic Sudo handlers used for handling message responses. This could lead to dierent inconsistencies and partial state updates in the protocol in case of errors or timeouts in the controlled chain. Some examples of the aforementioned behavior exhibited in the code:  In contracts/profit/src/profit.rs:63, a non acknowledged alarm can lead to prots not being transferred.  In contracts/lease/src/liquidation/alarm.rs:127, not properly rescheduled alarms can impact the timing of liquidations.  In contracts/lpp/src/contract/borrow.rs:57, failed attempts to transfer funds using BankMsg::Send through an interchain transaction are not handled.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Lack of alternate recipient address validation may lead to loss of users funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "When sending a ClaimRewards message to the lpp contract, the user can specify an alternate reward recipient in the other_recipient parameter. However, in contracts/lpp/src/contract/rewards.rs:34, during the execution of the try_claim_rewards function, the other_recipient address is valid. there is no validation in place to check that An invalid address will lead to the permanent loss of the users rewards.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Oracle is not resilient to feeders errors or manipulation attempts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "FeedPrices The in contracts/oracle/src/contract/exec.rs:61 enables feeders to submit their oracle prices on chain. message dened its associated Since in contracts/oracle/src/contract/feed.rs:92 does not perform any validation on inputs, it allows feeders to store incorrect data, for example a price equal to zero or multiple prices in the same block. try_feed_prices handler Also, the get_price function in packages/marketprice/src/feed.rs:55, which is responsible for providing the price of an asset, is returning the latest feeded one, without performing any calculation with other stored data points. By not performing any checks, nor transforming the data through any function that might catch outliers and data points that are not representing the real market price, the protocol allows the price to be manipulated by just introducing one corrupted observation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Contract ownership cannot be transferred",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The treasury, dispatcher, leaser, profit and oracle contracts do not implement an ownership transfer mechanism. Since the dened owner has the right to modify critical contract parameters and execute privileged messages, a compromise of its account would have devastating consequences for the protocol. It is best practice to oer functionality to transfer the ownership to another account.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Lack of price validation could lead to a division by zero error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/oracle/src/contract/feed.rs:67, there is no validation to ensure that prices are not equal to zero. Since throughout the codebase there are multiple calls to the inv function with the price value, there is a risk that the protocol performs a division by zero.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. It is not possible to migrate lease contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/leaser/src/cmd/borrow.rs:27-34, message is constructed with the admin parameter set to None. the lease contract instantiate This implies that the instantiated contract could not be migrated in case of a bug or a vulnerability disclosure.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Time alarms can be created for the past",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In packages/time-oracle/src/alarms.rs:60-69 the add function is not enforcing that a new time alerts timestamp is in the future.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Lack of validation for the UpdateParameters message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/lpp/src/contract/config.rs:9-22 the try_update_parameters function is updating the contract parameters without validating them. base_interest_rate, Since and addon_optimal_interest_rate are Percent values, they should be validated to be in the [0,1) interval. utilization_optimal We classify this issue as minor since only the contract owner can set those values.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Lack of validation of Dispatcher cong parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/dispatcher/src/contract.rs:45-50, the tvl_to_apr parameter is not validated during the dispatcher contract instantiation. This could lead to incorrect APR calculations and to not covered TVL intervals. We classify this issue as minor since only the contract owner can set this parameter.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Lack of validation of the leaser instantiation parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/leaser/src/contract.rs:29, during the leaser contract instantiation, not all the parameters are validated, such as liability and repayment. incorrect congurations could be used in the contract, such as a Liability As a result, instance with an incorrect attribute relationship, for example, a healthy factor smaller than the initial factor or greater than the max factor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Potential algebraic overows",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "Protocol contracts are not making use of checked operators in order to guard against algebraic overows. For example:  In contracts/lpp/src/state/deposit.rs:79. globals.balance_nlpn is incremented by deposited_nlpn without checking for overows. This assignment can be dangerous if the price of NLP is in the (0,1] range. In that case the entire global value could overow, which would aect rewards calculation.  In contracts/leaser/src/state/leaser.rs:23, an increment of an integer could cause an overow eventually. Since overflow-checks are enabled in Cargo.toml prole, the execution will panic if an overow occurs; however it should be better to be handled gracefully with an error message.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/treasury/Cargo.toml  contracts/dispatcher/Cargo.toml  contracts/timealarms/Cargo.toml  contracts/lpp/Cargo.toml  contracts/leaser/Cargo.toml  contracts/oracle/Cargo.toml  contracts/profit/Cargo.toml  contracts/lease/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Custom access controls implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The treasury, dispatcher, leaser, profit and oracle contracts implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Wrong variable name for APR",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/dispatcher/src/state/tvl_intervals.rs:72, a variable is named arp, when it aims to reect the APR value.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Typographical error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "contracts/leaser/src/error.rs:27, In IvalidLiability, while its correct spelling is InvalidLiability. error an variant is named",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Missing validation of the bridged_denom format",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf",
        "body": "In contracts/lido-satellite/src/msg.rs:16-21, not validate the format of the bridged_denom variable. the validate function does This is problematic since the contract is designed to hold only funds denominated in bridged denoms. Specically, the provided denom should adhere to the required format of ibc/{denom} before proceeding with any subsequent processing steps.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Additional funds sent by the user besides config.bridged_denom are locked",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf",
        "body": "In contracts/lido-satellite/src/execute.rs:15 and 39, the find_denom function checks for the existence of a Coin with the config.bridged_denom among the funds sent with the message. This validation does not ensure however that no other native tokens have been sent, and any such additional native tokens are not returned to the user, so they will be stuck in the contract forever. While blockchains generally do not protect users from sending funds to wrong accounts, reverting extra funds increases the user experience.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Missing check that the contract has enough funds to cover the creator_fee",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf",
        "body": "In contracts/lido-satellite/src/contract.rs:31, before creating a new denom, no check is performed to ensure that the contract has sucient funds to cover the creator_fee. the tokenfactory module Since in https://github.com/neutron-org/neutron/blob/v1.0.2/x/tokenfactory/keeper/createdenom.go#L1 5, if the contract does not hold enough funds, an error will be raised. denom creation imposes fee for a This behavior could complicate the contract deployment process and lead to ineciencies.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf",
        "body": "The lido-satellite contract does not enable overflow-checks for the release prole. While enabled implicitly through the workspace manifest, future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Hooks are not dispatched during stake and unstake messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In contracts/voting/dao-voting-native-staked/src/contract.rs:116-117, AddHook and RemoveHook messages allow the DAO to add or remove hooks to contracts that will be executed during stake and unstake messages. However, hook messages are not executed when execute_stake and execute_unstake are executed. For comparison, hook messages the dao-voting-token-factory-staked contract dispatches in as accordingly, contracts/voting/dao-voting-token-factory-staked/src/contract.rs:2 00 and 240. Consequently, hooks that the DAO adds will not be dispatched when a user stakes or unstakes funds. seen",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. DAO is unable to control the cw-tokenfactory-issuer contract for existing factory tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In contracts/voting/dao-voting-token-factory-staked/src/contract.rs:5 82-588, the cw-tokenfactory-issuer contract after instantiating it with TokenInfo::Existing. This the the dao-voting-token-factory-staked contract address, not the DAO address. ChangeContractOwner message dispatched because contract needed current owner step not the to is is is For comparison, new tokens created with TokenInfo::New transfer the ownership to the DAO, as seen in lines 693-700. Consequently, the DAO cannot execute privileged functions in the cw-tokenfactory-issuer contract, preventing the protocol from working as intended.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. AbsoluteCount can be congured to be greater than the total NFT supply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "execute_update_active_threshold in The contracts/voting/dao-voting-cw721-staked/src/contract.rs:424 does not validate that the AbsoluteCount active threshold set is less than or equal to the total NFT count before setting the value. This could allow for a situation where the count is set to a value that exceeds the total number of tokens in existence and thus can never be met. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. AbsoluteCount threshold for a new token is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "instantiate The in contracts/voting/dao-voting-token-factory-staked/src/contract.rs:6 4 does not explicitly handle the case where the active_threshold is specied with an AbsoluteCount type. Specically, it does not ensure the provided count value is larger than zero. function Consequently, the IsActive query will always return true when the AbsoluteCount value is set to zero, allowing dao-proposal-multiple and dao-proposal-single contracts to create proposals on inactive DAOs.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Protocol addresses can be blacklisted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "blacklist in The contracts/external/cw-tokenfactory-issuer/src/execute.rs:381 does not prevent the issuer contract from being blacklisted by any address with a blacklister allowance. This can cause a number of key contract functions to be blocked as the protocol will no longer be able to interact with the tokenfactory denom due to the validation in contracts/external/cw-tokenfactory-issuer/src/hooks.rs:17-18. function Note that this issue can only arise if a blacklister is compromised or misbehaves. Even if this issue occurs, the contract owner can recover from it by removing the address from the blacklist.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Group contract attribute key emits as address string",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In the contracts/voting/dao-voting-cw4/src/contract.rs:102, group_contract attribute key emits the value as the address string. This is incorrect because it should emit the actual contract address from the address variable value. Consequently, event indexers will be unable to index the instantiated group contract address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Newly instantiated NFT contract can have zero NFTs, locking the DAO",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In contracts/voting/dao-voting-cw721-staked/src/contract.rs:646-655, the initial_nfts sub-messages provided by the contract instantiator will be dispatched to the NFT contract to mint NFTs. Having at least one NFT minted is important to ensure the DAO can be controlled by the NFT owners. If no NFTs are minted, no one can control the DAO to mint new NFTs, thereby locking the DAO. The issue is that no validation ensures the initial_nfts sub-messages actually mint the NFT. For instance, it is possible to have two messages that rst mint the NFT and later burn it. For sg721 NFTs, the provided sub-messages can also be used to update the collection information instead of minting new NFTs.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Adding too many hooks may cause stake and unstake messages to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In contracts/voting/dao-voting-cw721-staked/src/contract.rs:213 and 264, the stake_hook_msgs and unstake_hook_msgs functions dispatch all hooks to the congured hook contracts when a user stakes or unstake funds. If there are too many hooks congured, the transaction will fail due to an out-of-gas error. Consequently, users are unable to stake or unstake funds in the contract, preventing it from working as intended. We classify this issue as minor because only the contract owner can add hooks, which is a privileged address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Incorrect events are emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In contracts/external/cw-tokenfactory-issuer/src/execute.rs:239, the set_whitelister function emits the action attribute value as set_blacklister, is in which contracts/external/cw-tokenfactory-issuer/src/execute.rs:436, where the whitelist function incorrectly emits the action attribute value as blacklist. incorrect. present issue This also is Consequently, event message, confusing o-chain listeners. indexers will incorrectly index the emitted action as the executed",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Lack of denom validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "The instantiate function of the voting-native-staked contract does not validate the in conguration part contracts/voting/dao-voting-native-staked/src/contract.rs:61. denom stored the as of As this piece of data cannot be updated, a mistake or typo would result in the contract needing to be deployed again.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. SG721 NFT creator role is not set to the DAO address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "The instantiate function of the dao-voting-cw721-staked contract modies the contents of the token instantiate message to set the minter to the contract address in contracts/voting/dao-voting-cw721-staked/src/contract.rs:39-44. However, for SG721 tokens, the privileged creator role that can update collection metadata and royalties is not modied. Consequently, the DAO cannot update the metadata and royalty congurations of the SG721 NFT token. This issue was discovered independently by the client while xing issues.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. BlockBeforeSend hook executes upon minting or burning",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "Sudo BlockBeforeSend in The contracts/external/cw-tokenfactory-issuer/src/contract.rs:140, is executed when sending tokens through the Bank module and is used by the cw-tokenfactory-issuer contract to enforce freezing and blacklisting of addresses. The current implementation does not consider that this includes the mint operation as it calls the SendCoinsFromModuleToAccount function here, which calls SendCoins here, message, dened the impact In this case, cw-tokenfactory-issuer contract modules address is whitelisted. vulnerabilities in future versions of the code. is limited to the minter not being able to mint the is in a frozen state unless the tokenfactory this incorrect assumption could lead to In addition, if",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Unstaking duration is not validated in the dao-voting-cw721-staked contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In comparison, In factory-nft:contracts/voting/dao-voting-cw721-staked/src/contract. rs:71 and 379, the unstaking duration is not validated to ensure the height and time are not the validation is performed for the dao-voting-token-staked zero. contract in factory-nft:contracts/voting/dao-voting-token-staked/src/contract. rs:64 and 286. Consequently, instant staking and unstaking could be possible due to zero staking duration. We classify this issue as minor because only the DAO can congure the unstaking duration, which is a privileged account.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Absolute count is not validated when instantiating NFT contract through factory contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In factory-nft:contracts/test/dao-test-custom-factory/src/contract.rs :343-350, absolute count validation is not performed after instantiating the NFT contract from the execute_nft_factory function. In comparison, this validation is performed when in lines 268-277 from the instantiating a cw_tokenfactory_issuer contract execute_token_factory_factory function. Consequently, the absolute count can be set to an invalid value, causing the IsActive query to always return true when the count is set to zero or return false by setting the count value higher than the total NFT supply.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. DAO will be locked if the minter is set to the DAO address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In factory-nft:contracts/test/dao-test-custom-factory/src/contract.rs :93, the execute_nft_factory function instantiates a new NFT contract without support of automatically minting new NFTs. If cw721_instantiate_msg.minter is set to the DAO address, it will cause the DAO to be locked because no one owns the initial NFTs. Since proposals cannot be created, new NFTs cannot be minted.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. DAO will not accept pending ownership transfer automatically",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In factory-nft:contracts/voting/dao-voting-cw721-staked/src/contract. rs:685, the UpdateOwnership message is dispatched to transfer the NFT mint ownership to set with the ModuleInstantiateCallback to accept the NFT mint ownership automatically in the DAO contract. DAO address. However, response data not the is Consequently, the DAO members need to create a proposal to accept the mint ownership of the NFT contract manually. issue This factory-nft:contracts/test/dao-test-custom-factory/src/contract.rs :325-334 from the execute_token_factory_factory function. present also is in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. TokenContract query will fail for TokenInfo::Existing tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In factory-nft:contracts/voting/dao-voting-token-staked/src/contract. rs:405, the TokenContract query tries to load the TOKEN_ISSUER_CONTRACT storage value. Since tokens instantiated as TokenInfo::Existing enum will not be stored in the TOKEN_ISSUER_CONTRACT storage, the TokenContract query will always error for them.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. BEFORE_SEND_HOOK_FEATURES_ENABLED is not exposed through smart queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In contracts/external/cw-tokenfactory-issuer/src/contract.rs:146, no smart queries expose the BEFORE_SEND_HOOK_FEATURES_ENABLED storage state value. This forces users and other contracts to perform a raw query to read the stored value, decreasing user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Misleading from attribute when burning funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In contracts/external/cw-tokenfactory-issuer/src/execute.rs:121, the from attribute is emitted as the callers address. This might be misleading because o-chain listeners might expect the from address to be the burn_from_address address, which is the address that has their funds burnt.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "20. Code reusability can be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "There are a number of validation functions in the scope of this audit that are reimplemented for each contract, decreasing the maintainability and readability of the code.  The validate_duraton in dao-voting-native-staked, dao-voting-token-factory-staked, and cw20-staked. duplicated validation is  The active_threshold in contracts/voting/dao-voting-cw20-staked/src/contract.rs:41 and contracts/voting/dao-voting-token-factory-staked/src/contract .rs:81. duplicated validation is  The active_threshold validation is duplicated in contracts/voting/dao-voting-cw721-staked/src/contract.rs:89 and contracts/voting/dao-voting-cw721-staked/src/contract.rs:437.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "21. Inconsistent attribute names and orders",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-10-16 Audit Report - DAO DAO Updates v1.0.pdf",
        "body": "In several values are emitted with dierent attribute names or dierent orderings when emitting events. instances in the codebase, there are inconsistencies where the same attribute  In contracts/external/cw-tokenfactory-issuer/src/execute.rs:358, the allowance value is emitted as amount attribute name. This is inconsistent with the set_burner function, which emits the allowance attribute name in line 331.  In contracts/voting/dao-voting-cw4/src/contract.rs:199, new group contracts emits the address with the group_contract_address attribute name, while existing group contract emits the address with group_contract attribute name in line 102.  In contracts/voting/dao-voting-token-factory-staked/src/contract .rs:704, new tokens emit the attribute name as denom while existing tokens emit it as token_denom in line 119.  In contracts/voting/dao-voting-cw721-staked/src/contract.rs:675, the method attribute is emitted in a later place compared to the Existing enum in line 675, which emits in the rst place. Consequently, event indexers and o-chain listeners might be misled due to dierent attribute names and attribute orders.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Swap operations are vulnerable to sandwich attack",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Yieldmos/2024-05-17 Audit Report - Yieldmos Outposts Osmosis v1.0.pdf",
        "body": "packages/osmosis-helpers/src/osmosis_swap.rs:384, In Osmosis MsgSwapExactAmountIn message constructs the minimum amount of swap output (indicated as token_out_min_amount) value as zero. This is problematic as this essentially disables slippage protection. the Consequently, an attacker can perform a sandwich attack by purchasing the asset at the current price, forcing the Compound message to buy the asset at an increased price, and then immediately selling it for a prot. This attack can be performed repeatedly to cause a loss of funds for the user because the asset will be bought at an abnormally high price. This issue is present across a few instances in the codebase:  packages/osmosis-helpers/src/osmosis_lp.rs:111  packages/osmosis-helpers/src/osmosis_swap.rs:384  packages/osmosis-helpers/src/osmosis_swap.rs:424",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Users can manipulate fee amounts in their favor",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Yieldmos/2024-05-17 Audit Report - Yieldmos Outposts Osmosis v1.0.pdf",
        "body": "In contracts/osmostake/src/contract.rs:179, the Compound message allows the caller to specify the tax_fee amount for the compound operation execution, which is the fee amount that the protocol will charge through the split_rewards function in the authzpp contract. The issue occurs when users set the max_fee_percentage to a zero value amount to force AuthorizedCompounder to compound for free. Since the fee percentage is determined by the minimum value of the max_fee_percentage dened by the user and the granter-provided percentage value, the min function will evaluate zero as the base minimum, causing the protocol to receive zero tax fees. We classify this issue as critical since the protocol loses fee income.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Users can redirect tax fees to their address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Yieldmos/2024-05-17 Audit Report - Yieldmos Outposts Osmosis v1.0.pdf",
        "body": "In contracts/osmostake/src/contract.rs:176-184, the Compound message allows an AuthorizedCompounder to compound on behalf of users and charge the percentage of fee rewards depending on the tax_fee parameter. The authzpp contract will compute the rewards and distribute the tax_fee parameters portion to the taxation_address. However, since users can set taxation_address to any arbitrary address when creating the Grant, the user can set the address to themselves to receive the reward splits, causing the protocol to receive zero fees after compounding for the user. We classify this issue as critical since the protocol loses fee income.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Incorrect denom validation in Compound message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Yieldmos/2024-05-17 Audit Report - Yieldmos Outposts Osmosis v1.0.pdf",
        "body": "In contracts/osmodca/src/contract.rs:184, the Compound message validates the compound token denom as ujuno. This is incorrect because the native token denom to auto-compound in the Osmosis chain is uosmo, not ujuno. Consequently, the Compound message will always fail as users cannot send ujuno native tokens in the Osmosis chain.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Incorrect message ordering causes compounding to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Yieldmos/2024-05-17 Audit Report - Yieldmos Outposts Osmosis v1.0.pdf",
        "body": "contracts/osmodca/src/execute.rs:221, function In appends the swap messages (indicated as swap_msgs) after the token transfer message (indicated as send_msgs). This is problematic because the transfer message intends to send the post-swapped token to a recipient, which will fail due to insucient balance as the swap is not performed rst. prefs_to_msgs the This issue is present across several instances in the codebase:  contracts/osmodca/src/execute.rs:221  contracts/osmodca/src/execute.rs:259  contracts/osmostake/src/execute.rs:232  contracts/osmostake/src/execute.rs:270",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Incorrect token_in parameter during simulations causes compounding to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Yieldmos/2024-05-17 Audit Report - Yieldmos Outposts Osmosis v1.0.pdf",
        "body": "In the packages/osmosis-helpers/src/osmosis_swap.rs:360, generate_swap_and_sim_msg function passes the from_asset.denom value to the token_in parameter when simulating the swap in line 303. This is incorrect because token_in requires the value to include the token amount and token denom (e.g., 123uosmo instead of uosmo) to query the EstimateSwapExactAmountInRequest message correctly. Consequently, the auto-compounding will fail due to the simulation failure. This issue is present across a few instances in the codebase:  packages/osmosis-helpers/src/osmosis_swap.rs:360  packages/osmosis-helpers/src/osmosis_swap.rs:432",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Deposited funds remain locked in custom bond contract for perpetuity custom_bond",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "The at contracts/custom_bond/src/execute.rs:169 does not include any functionality to transfer the deposited principal token funds into the custom_treasury contract. Because of this, any deposited principal token funds will remain locked in the deposit contract for perpetuity. deposit contracts function",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Fees sent to the incorrect treasury leads to loss of Olympus treasury income",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "During the bond creation using create_bond_from_temp and create_bond at contracts/factory/src/contract.rs:231 and 282, the factory contract is using the incorrect value of custom_treasury as olympus_treasury instead of config.treasury. The config.treasury treasury address provided during the initialization at contracts/factory/src/contract.rs:36 is currently unused. The issue can be xed through governance because the olympus_treasury address can be changed through the update_olympus_treasury function. But the collected fees would not be sent to the olympus_treasury until the address is correctly set, they would be transferred to the custom_treasury contract which Olympus does not own.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Additional deposits will reset the vesting term of existing bonds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "Depositing additional funds to an existing bond will cause the vesting term of these existing deposits to be reset in contracts/custom_bond/src/execute.rs:261. That implies that funds that are not yet redeemed by the bonder will have an extended vesting period. i.e on January 6. Suppose that after 4 days, For example, if Alice deposits 100 token A (principal token) on January 1, the vesting term is 5 days and the bond price is 25, then she would get 4 payout tokens after the completion of 5 days, i.e. on January 5 Alice deposits an additional 100 token A and Alice did not redeem during those 4 days, then her new vesting term will be again 5 days as per line 261. If she wants to redeem after 1 day, i.e. on January 6, she will only be able to redeem 8 * 1 / 5 = 1.6 token B, even though the previous 4 tokens should have already been vested.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Missing support for upgrades of bond and treasury contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "the bond and treasury contracts sets the factory contract as the admin in Creation of contracts/factory/contract.rs:197, 226, and 277. This means only the factory contract can upgrade the bond and treasury contracts, but there is no function in the factory contract to execute updates. The contracts also lack versioning information that can be handy in the future during upgrades of the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Centralization risk in withdrawal of treasury funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "Currently, contracts/custom_treasury/src/contract.rs:118 withdraw is access the to function controlled by in the assert_policy_privilege function which ensures that the info.sender equals the config.policy address. The withdraw function allows the policy account to issue an arbitrary withdrawal from the treasury to any recipient. In the event of the policy account being compromised, an attacker would have the ability to completely drain the treasury. We classify this nding as minor because while the impact would be major, the likelihood of this event occurring is low if strong key management practices are used on the policy account.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Usage of dierent versions of cw20 crate",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "Within the project's Cargo.toml les, dierent versions are used for the cw20 crate:  Version 0.10.3 in contracts/custom_treasury/Cargo.toml:28  Version 0.8.0 in contracts/custom_bond/Cargo.toml:29  Version 0.8.0 in contracts/olympus_pro/Cargo.toml:20",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Users' inactivity could permanently freeze the protocol",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "calculate_streaming_fee The in contracts/core/src/state/mod.rs:44-75 calculates the time-weighted streaming fee with the following formula: function dened  = (1 +   )   1 where  is the elapsed time since the latest stream fee application. If this time delta gets too big, the exponential operation could perform an overow, reverting the message handling. This could happen, for example, after a chain upgrade or during a bear market where users are less interested in interacting with the contract. Since the calculate_streaming_fee function is executed for each Execute message, its overow and revert of the message would permanently freeze the protocol. A test case is provided in Appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Rebalance nalization may become unachievable due to streaming fee collection",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "Streaming fees are collected via the collect_streaming_fee function implemented in in contracts/core/src/execute/fee.rs contracts/core/src/contract.rs:67, including rebalance messages. execution message every on If the deation target units are attained during rebalancing (i.e., target_unit == current_unit  notice the strict equality check), decrementing the collected fee from the current asset units in line 139 of the collect_streaming_fee function will result in an inability to pass the strict equality check in the finalize function. As a result, rebalancing becomes stuck and cannot be nalized.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Inability to inate an asset caused by using the wrong coin denomination for swapping the reserve to asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The inflate function incorrectly uses the RESERVE_DENOM constant as the token_in argument in contracts/core/src/execute/rebalance.rs:436. msg_swap_exact_in call the for Since RESERVE_DENOM has a constant \"reserve\" value, which is not a valid coin denomination, the intended swap fails, causing the transaction to revert.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Asset deation uses wrong swap direction by swapping the reserve to the asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The process of deating an asset during rebalancing involves swapping an exact amount of the asset (denom) to the reserve (token.reserve_denom). in the current However, in implementation, contracts/core/src/execute/rebalance.rs uses the asset coin denomination denom as the token_out argument for the msg_swap_exact_out function, resulting in the reserve being swapped to the asset rather than the intended swap of the asset to the reserve. deflate function the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Deating an asset distributes the asset amount rather than the reserve amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The deflate function within contracts/core/src/execute/rebalance.rs is designed to distribute the reserve amount received to the RESERVE_BUFFER via the distribute_after_deflate function for subsequent asset ination. However, the current implementation mistakenly distributes the asset amount instead of the reserve amount. This can lead to incorrect accounting of reserves and prevent subsequent ination of assets.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Total supply is not correctly computed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "In contracts/core/src/execute/mod.rs:100, during the execution of Burn messages, the total supply is decreased by the amount of the received tokens. However, since part of the users provided tokens is sent to the fee_collector because of the burn fee, the computed total supply is not correct because it is not accounting for the fees. This implies that the total supply recorded in the contract is smaller than the actual one and a Burn message from the fee_collector would redeem more collateral than expected.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. ClaimProof does not include beneciary address, which allows front-running of airdrops",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "of types proofs in  Two contracts/airdrop/src/execute.rs:108-116, extracting the claim_proof distinguishes between the Account and ClaimProof types. While the Account type always includes the address of the beneciary, ClaimProof allows claiming with an arbitrary string. airdrops for supported logic are the for This is problematic because it enables front-running of these claims. When an attacker sees the proof string, he can submit it himself and claim the amount before the user.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. The same claim proof can be used multiple times",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "In contracts/airdrop/src/lib.rs:18, the user input that is proven is dened as {claim_proof}{amount}, i.e., concatenation of the claim proof and the amount. This input is veried with the provided claim proof. Because this encoding is ambiguous, an attacker can craft multiple combinations that result in the same user input and which are not rejected as invalid or duplicates. For instance, let us assume that claim_proof = abcd1234. An amount of 5 results in a user input of abcd12345, which is the value of the leaf. However, setting claim_proof = abcd123 and amount = 45 also results in user input of abcd12345. Because it is only veried (in contracts/airdrop/src/execute.rs:142), both calls will succeed and the user can claim 45 + 5 = 50 tokens instead of the intended 5. claim_proof before used was that not the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "9. Inability to mint, burn and rebalance index tokens following the initial deate rebalance trade",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "Deating of an asset persists and updates the temporary accounting asset RESERVE_DENOM as part of the UNITS map alongside the other assets of the index. This RESERVE_DENOM is a constant string that resolves to \"reserve\" and is not a valid coin denomination. Any attempt to transfer this asset will result in an error. Due to the assumption that all assets within the UNITS map are tokens with valid coin denominations, the core functionalities of the protocol - minting, burning, and rebalancing - stop working after the initial deate rebalance trade, as RESERVE_DENOM is also added to the UNITS map. Minting  Since minting index tokens requires sending all asset tokens of UNITS along with the minting message, it is not possible to mint index tokens as RESERVE_DENOM cannot be transferred.  The Burning in contracts/core/src/state/units.rs determines the amount of underlying assets to redeem to the user when burning index tokens. Those assets are then transferred to the user. However, as RESERVE_DENOM is kept within the UNITS map and not removed from the redeemable assets, the transfer and hence the transaction reverts. get_redeem_amounts function fees are automatically Rebalancing  In the case of streaming fees being congured, collected and realized on every rebalance message. However, fees are also incorrectly collected from RESERVE_DENOM. As it is not possible to transfer the collected fees of the RESERVE_DENOM coin denomination, rebalancing reverts.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "10. Rebalance may not be nalizable because of rounding error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The function distribute_after_deflate distributes the amount provided after an ination operation to the RESERVE_BUFFER entries for the dierent tokens. It does so by rst calculating the individual share for each token by dividing the weight by the total weight and then multiplying this ratio by the amount. However, because xed point arithmetic is used, there can be a very small loss of precision (in the 18th decimal place) when performing the division. While this loss of precision generally would be negligible, it breaks an important invariant of the rebalance operation: The sum of all RESERVE_BUFFER entries will no longer be equal to the RESERVE_DENOM balance. is for This the problematic In the contracts/core/src/execute/rebalance.rs:470, RESERVE_DENOM balance is exactly zero. But since this balance can only be decreased by consuming RESERVE_BUFFER entries, the condition may fail when there is a small amount left due to the imprecision of the calculation. Therefore, nalizing the rebalance operation will not be possible. nalization. required that is it",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "11. Burning index tokens via the periphery contract yields substantially fewer asset tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "Burning index tokens via the periphery BurnExactAmountIn message invokes the burn_exact_amount_in function in contracts/periphery/src/execute.rs. This function in contracts/core/src/query.rs to determine the redeemable amounts of asset tokens, which are then swapped to a desired token (output_asset). simulate_burn function located core calls the the simulate_burn However, to amount_with_fee. Instead of calculating the burn fee amount and deducting it from the provided amount of index tokens, it multiplies the amount with the fee.burn ratio in line 119. This results in the amount_with_fee being just the fee, not the amount minus the fee. incorrectly the burn function applies fee Consequently, the amount_with_fee is substantially smaller than the provided amount of index tokens. As a result, the periphery contract will swap only a fraction of the redeemed assets to the desired token. As users can provide a minimum amount (min_output) of the desired token to receive, the transaction fails if this condition is not met. This renders the BurnExactAmountIn periphery message unusable.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "12. The streaming fee calculation formula returns wrong results for some input values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "calculate_streaming_fee The in contracts/core/src/state/mod.rs:44-75 calculates the time-weighted streaming fee with the following formula: function dened  = (1 +   )   1 where  is the elapsed time from the latest stream fee application. Since this function returns a rate that has to be deducted from token units, the result must input be in the [0,1] range. Since the result depends on the and the    variables, it may fall outside of this range for some of those values. Results outside of the mentioned range would cause wrong calculations resulting in token units being incorrectly reduced and accrued to the fee collector. A graphical simulation is provided in the Appendix.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "13. Minting and burning index tokens interferes with rebalancing and can render rebalance nalization unachievable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "As minting and burning index tokens continue to work while rebalancing is ongoing, the total supply of index tokens can uctuate during rebalancing. During rebalancing, the deflate_reserve and deflate functions deate assets, while in the inflate inflate_reserve functions assets inate and contracts/core/src/execute/rebalance.rs. These functions use the current supply of index tokens (token.total_supply) to perform calculations. For example, amount of reserve tokens to the total supply of index tokens (token.total_supply). the inflate_reserve function calculates the swap_unit ratio of the reserve The in is contracts/core/src/execute/rebalance.rs:355 and persisted in the UNITS map. RESERVE_DENOM swap_unit reduced then unit by As the token.total_supply changes during the rebalancing process, the swap_unit increases or decreases accordingly. This can result in RESERVE_DENOM never reaching 0, which is required to nalize the ongoing rebase.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "14. Asset ination simulates the swap incorrectly and expands by the wrong amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "Inating an asset by a certain amount is achieved by swapping the reserve to the asset. To determine the resulting amount (amount_out) of the asset (denom), the token swap is in simulated contracts/core/src/execute/rebalance.rs:402. sim_swap_exact_in function using the instead of using the reserve coin denomination (token.reserve_denom), the However, asset denom is used as the token_in argument for the sim_swap_exact_in function. As a result, the swap is simulated from the asset to the reserve instead of the reserve to the asset. This results in either a failed transaction due to the unsatised min_amount_out slippage protection or, in using the wrong amount the slippage protection is bypassed, (amount_out) to calculate the expansion amount (expand_unit) of the asset. if Additionally, this incorrect amount_out value is supplied as the token_out_min argument for the msg_swap_exact_in function in line 438, potentially causing the swap to fail due to the unsatised slippage protection condition.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "15. An invalid rebalance conguration could prevent its nalization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "Rebalance::validate in The validating the contracts/core/src/state/rebalance.rs is rebalance cong before the protocol's governance can initiate a new rebalance. Once a rebalance has started, the cong can not be altered until the rebalance is nalized. responsible function for However, the current implementation of the Rebalance::validate function is missing some important checks, which can lead to failed rebalances. Specically, if the ination ratios in the conguration are incomplete or empty, it will not be possible to utilize the reserve fully. When attempting to nalize the rebalance, the non-zero check in contracts/core/src/execute/rebalance.rs:468 will fail, causing the nalization of the rebalance to fail. UNITS[RESERVE_DENOM] of Similarly, if the conguration includes duplicate coin denominations within the inflation and deflation vectors, the nalization of the rebalance will fail because of the guard in contracts/core/src/state/rebalance.rs:456-463. the impossibility of a Rebalance being nalized as strict equality cannot be true for two instances of the same denom with dierent amounts. results This in We classify this issue as major because only governance can initiate a rebalance and dene its conguration.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "16. Streaming fee realization mechanism can be manipulated by the fee collector to maximize prot",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The function realize_streaming_fee can be executed by the designated fee collector address at any time in order to collect fees. collected fees The calculated by multiplying the unit value with the token.total_supply in contracts/core/src/execute/fee.rs:156 for each Coin. are This is problematic because while unit is a time-weighted value, token.total_supply is a value that uctuates over time, leading to too high or low streaming fees. Moreover, it may be economically feasible for the fee collector to temporarily inate the total supply (by minting), execute realize_streaming_fee, and burn the tokens again.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "17. Tokens that are sent by mistake are not refunded when minting",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The function mint calls assert_units to calculate how many tokens to refund for all backing assets in contracts/core/src/execute/mod.rs:43. The assert_units function checks that info.funds contains an entry for every element in assets, in order to calculate refunds for these elements. However, it is not validated that info.funds does not contain any additional entries. Therefore, info.funds is checked to be a superset of assets. This means that if a user sends other tokens along the call, those will be lost and not refunded.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "18. Fees rates are not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "In contracts/core/src/contract.rs:30-40, during the contracts instantiation, input provided fee rates dened in msg.fee_strategy are not validated to be in the [0,1] range. that range will cause errors in calculations since fees could exceed Values outside of amounts.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Inconsistent query results and failed index token burns due to lack of considering a minimum fee for small index token amounts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "simulate_mint The contracts/core/src/query.rs lack Uint128::one(), make_burn_msgs_with_fee_collection contracts/core/src/execute/fee.rs. unlike and the simulate_burn application of the functions in a minimum fee of and in functions make_mint_msgs_with_fee_collection This absence of a minimum fee in the simulate_mint function results in incorrect query results. Additionally, the lack of applying a minimum fee in the simulate_burn function results in a failed burn transaction for small index token amounts (if amount * fee < 1) when used via the periphery contract. This occurs because the make_burn_swap_msgs function in contracts/periphery/src/msgs.rs expects a larger amount of redeemed asset tokens than actually received and fails to swap due to insucient funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Missing tax deductions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "The stable yield manager does not deduct taxes. While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is small.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Price oracle block height not validated which may return out of date values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "get_mirror_asset_oracle_uusd_price in The contracts/delta_neutral_position/src/util.rs:39-53 does not validate that the price information for the specied mAsset is up-to-date. Currently, the contract takes the returned rate and returns it as the valid uusd price for the mAsset to the caller without performing a block height validation to ensure that the price feed is accurate. The mirror price response includes both   last_updated_base and last_updated_quote values for this purpose. function The Mirror mint contract does provide the functionality to return an error if the price is not within the get_mirror_asset_oracle_uusd_price query does not currently provide the optional block_time parameter so this operation will not occur. block_time, seconds but the of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Loss of precision during fee calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "The contract EthereumManager performs multiplication after division while calculating the fee in line 185. This can lead to imprecision due to rounding.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Consider adding more validations to Solidity contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "Consider adding the following validations in the Solidity contract to prevent accidental value updates. 1. EthereumManager.sol: for CROSS_CHAIN_FEE_BPS to prevent any accidental update that can cause wrong fee calculation and result in loss of funds for the end-user. Consider adding upper limit an 2. EthereumManager.sol: Consider adding zero address validation while updating the FEE_SINK address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Delta neutral position should implement a migrate only if newer pattern",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "The delta neutral positions contracts are currently migrated in an asynchronous fashion. This is ne, but the pattern can be improved by adding validation to ensure that the migration is only occurring if the version supplied is newer.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. migrate_position_contracts allows anyone to perform migrations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "migrate_position_contracts The in contracts/delta_neutral_position_manager/src/contract.rs:144 does not restrict who can migrate the contracts. Currently, anyone can call this function and pass in whichever positions or position contract addresses they wish to migrate. While this is not inherently malicious, the best practice would be to restrict the entry-point. function We consider this issue to be informational since the code ID thats used after migration can only be set by the administrator.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Certain cross-chain and Terra transfers are overly permissive",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "public functions initiate_outgoing_token_transfer and The in process_cross_chain_instruction contracts/terra_manager/src/crosschain.rs:28 and 378 respectively are overly permissive. These functions are callable from any terra address, yet are only intended to be called by the Aperture strategy and manager contracts. In order to limit the attack surface of these contracts, it would be better to add access control to the contracts. found as",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Use of the term info may impact readability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "delta neutral position contract The both and contracts/delta_neutral_position/src/rebalance.rs:123 represent contracts/delta_neutral_position/src/contract.rs:472 terraswap pool info. This may impact readability and maintainability of the code because the name may conict or be confused with info, which is commonly used to represent CosmWasm MessageInfo. info uses term the to in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Claiming may become impossible after many users have claimed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Coinhall/2023-09-26 Audit Report - Coinhall Genie v1.0.pdf",
        "body": "The function query_status in the contracts/genie-airdrop/src/state.rs queries the number of elements of the USERS map with a range query. This operation is unbounded and may therefore eventually consume too much gas after many users have already claimed, leading to many entries in the USERS map. Because the function is called by the handle_claim and handle_transfer_unclaimed_tokens functions, this implies that it is no longer possible for users to claim and for the owner to retrieve unclaimed tokens. The funds would therefore be lost irrevocably.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Not registering campaign_id may lead to unexpected issues in o-chain components",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Coinhall/2023-09-26 Audit Report - Coinhall Genie v1.0.pdf",
        "body": "The CreateAirdrop message takes campaign_id as a parameter, which has a String type. This campaign_id is not used anywhere in the contract logic and according to the technical documentation, it serves as metadata for o-chain components. While this does not generate a security risk for the contract itself, the fact that it is not registered in a genie-airdrop-factory contract mapping can lead to a situation where there will be two or more genie-airdrop contracts with the same campaign_id. Such a collision may mislead users and o-chain components and may have unintended eects on them, for example, compromising the integrity of the campaign due to overwriting records with a new, just created campaign with the same ID.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Unbounded iteration over missions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Coinhall/2023-09-26 Audit Report - Coinhall Genie v1.0.pdf",
        "body": "In contracts/genie-airdrop/src/state.rs:211-238 an iteration happens over the State structures unclaimed_amounts eld of type Vec<Uint128>. When the airdrop is congured with an extensive number of missions, this unbounded iteration can lead to high gas consumption, up to the point where the call leads to an out-of-gas error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. from_timestamp is not veried to be greater than the current time",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Coinhall/2023-09-26 Audit Report - Coinhall Genie v1.0.pdf",
        "body": "When creating a campaign, the user provides two time values: from_timestamp and veried whether to_timestamp. During the instantiation operation, to_timestamp is greater than from_timestamp, so that the campaign lasts at least one time unit. is it However, there is no verication that the from_timestamp is equal to or greater than env.block.time.to_seconds(). As a consequence, it is possible that the campaign will never start, or that it will not be possible to add funds to the campaign because the status will be incorrect.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Additional funds sent to the contract are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Coinhall/2023-09-26 Audit Report - Coinhall Genie v1.0.pdf",
        "body": "In contracts/genie-airdrop/src/state.rs:167, a check is performed that ensures that in the transaction there is at least one Coin with the expected denom eld. This validation does not ensure however that no other native tokens have been sent, and any such additional native tokens are not returned to the user, so they will be stuck in the contract forever. While blockchains generally do not protect users from sending funds to wrong accounts, reverting extra funds increases the user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. No handler for unexpected cw20_msg.msg, potentially leading to locked funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Coinhall/2023-09-26 Audit Report - Coinhall Genie v1.0.pdf",
        "body": "In contracts/genie-airdrop/src/contract.rs:118, there is a match statement for the cw20_msg.msg. The only supported Cw20HookMsg is IncreaseIncentives. However, if the message is dierent, the smart contract does not provide any action for it, neither is an error returned. The execution of the function will then end silently, which in turn may lead to locked funds in the contract. We classify this issue as informational since it only occurs when a user sends funds to the contract with a dierent, unsupported message. However, to improve the user experience and reduce the impact of user errors, reverting in such situations is recommended.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Suboptimal input data format for payout computation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Coinhall/2023-09-26 Audit Report - Coinhall Genie v1.0.pdf",
        "body": "the claims_amount In contracts/genie-airdrop/src/contract.rs:201-205, parameter of type Binary is decoded into a Vec<Uint128>. The vector's length is tied to the preset number of missions. Oversized vectors with sparse rewards introduce ineciencies, leading to high gas costs: 1. Sparseness of the actual data causes redundant data sent in the smart contract call. This data undergoes encoding at the client, transmission, and a multi-step on-chain decoding process, which includes UTF-8 decoding and splitting by comma. For example, the string \"0,0,0,0,13,0,0,0,0,0,0,0,37,0,0,0,0\" contains 17 elements but only 2 are really used. 2. A multitude of zero values in claim_amounts causes unnecessary loop iterations when calculating the total payout (refer to lines 238-250). In the aforementioned in addition to 2 productive example, 15 unnecessary iterations are performed, iterations.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Contracts should implement a two step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Coinhall/2023-09-26 Audit Report - Coinhall Genie v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Inecient claims payout computation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Coinhall/2023-09-26 Audit Report - Coinhall Genie v1.0.pdf",
        "body": "In contracts/genie-airdrop/src/contract.rs:238, a for loop iterates over a potentially extensive vector of claim amounts. During this iteration, payouts are computed, but edge cases when amount and user_info.claim_amounts[i] are equal or both are zero are not ltered out. Such cases lead to several unnecessary checked arithmetic operations with zero while not inuencing the nal payout.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Ethereum events are not correctly conrmed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "Events emitted by the Ethereum smart contracts must reach a certain amount of block conrmations before validators vote to include them on Namada. An event is conrmed if the dierence between the heights of the current block and the block containing the event is greater than or equal to the required amount of conrmations. the PendingEvent::is_confirmed However, in apps/src/lib/node/ledger/ethereum_node/events.rs:206 considers a block conrmed if the required amount of confirmations is greater than or equal to the block height dierence. Thus, there are more block conrmations, the block is considered unconrmed and discarded from further processing. This leads to frozen funds in case of the TransferToNamada event. function if",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Missing replay protection for signatures",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "in the current validators function set are provided in the execution of the Signatures of contracts/contract/Governance.sol:42, upgradeContract upgradeBridgeContract function in contracts/contract/Governance.sol:60 and addContract function in contracts/contract/Governance.sol:77. In all three functions, messageHash gets calculated to validate the given signatures. There is no replay protection for these functions though, which implies that an attacker can use previously provided signatures to again upgrade/update the state of the contract given that the validator set during the signature creation time is the same as the attack time. For example, an attacker may replay a previous upgrade and then execute a message, which may lead to irrecoverable state inconsistencies in the contract.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Bridging tokens from Ethereum to Namada with an invalid amount of receiver addresses will freeze escrowed funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "ERC-20 tokens are transferred from Ethereum to Namada using the transferToNamada function in contracts/Bridge.sol. The appropriate Namada receiver addresses are provided with the function parameter address[] calldata _tos. After transferring the specied tokens to the Bridge contract for escrow, an event TransferToNamada is emitted and processed by Namada validators. However, if the amount of _tos receiver addresses does not match the length of the other parameters _froms and _amounts, the event is discarded. Escrowed ERC-20 tokens for this specic token transfer transaction are locked and the user can not withdraw funds.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Oracle uses an unbounded queue which might lead to out-of-memory issues",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "In apps/src/lib/node/ledger/ethereum_node/oracle.rs:33 in the Oracle struct the sender attribute is of type UnboundedSender. Its unbounded nature might cause an out-of-memory termination of the process in case the reader side of the channel cannot consume events as fast as the producer creates them. There might be a possibility of an attack in which a large number of events on the Ethereum side are crafted with the intention of exhausting the memory of the node.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Incorrect accounting of voting power for Ethereum events",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "In apps/src/lib/node/ledger/shell/vote_extensions/ethereum_events.rs: 186, the voting power for events gets accounted for cumulatively rather than per event to check whether sucient votes are provided for Ethereum events by Namada validators. This allows malicious validators to successfully add invalid events. For example, an event crafted without actually locking funds in the Ethereum smart contract could be used to mint new funds on the Namada chain.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. The minimum number of block conrmations required to bridge ERC20 tokens from Ethereum to Namada is not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "Transferring ERC20 tokens to Namada by using the transferToERC function in the contracts/Bridge.sol contract emits the TransferToNamada event. This event includes the number of block conrmations that must be reached on the Ethereum chain before validators vote to include them on Namada. This number is provided by the function parameter uint256 confirmations and must be at least the protocol-specied minimum initially set to 100. However, this aforementioned invariant is not number of conrmations, enforced in the apps/src/lib/node/ledger/ethereum_node/events.rs:288. As a result, a user can circumvent the protocol-specied minimum number of conrmations, which might be exploited to double-spend funds. RawTransfersToNamada::decode function in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Slashable oense for voting on an unconrmed event is not accounted as misbehavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "slashing applying When in apps/src/lib/node/ledger/shell/mod.rs:525, EvidenceType gets matched with the SlashType. Voting on unconrmed events is considered a slashable oense according to the provided documentation, but it is not accounted for as one of the variants of EvidenceType. This allows validators to vote on unconrmed events. This issue may be abused by malicious validators to double-spend funds. validators",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Validator set update protocol transactions are not validated in the process proposal phase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "Transactions in newly proposed blocks are validated by all validator nodes in the in Shell::process_proposal valid apps/src/lib/node/ledger/shell/process_proposal.rs type transactions. However, contrary to properly validating protocol ProtocolTxType::EthereumEvents, type ProtocolTxType::ValidatorSetUpdate are not currently validated. transactions of transactions ensure to of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Unsafe use of selfdestruct",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "Using selfdestruct in contracts/contract/Bridge.sol:160 is not safe because ERC20 funds would be lost those funds were not withdrawn before executing the selfdestruct function. There is no inherent protection that makes sure all funds are withdrawn from the contract before selfdestruct so there is a risk of human error of misplacing an ERC20 token address within the _tokens param of withdraw function. if",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. The total size in bytes of the transactions in a block proposal can exceed the block byte size limit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "Tendermint expects the application to check whether the size of all transactions exceeds the byte limit RequestPrepareProposal.max_tx_bytes, which by default to 1048576 bytes. If so, the application must remove transactions at the end of the list until the implementation of total byte size is at or below the limit. However, in Shell::prepare_proposal not apps/src/lib/node/ledger/shell/prepare_proposal.rs:48-57 enforce this limit. Therefore, if the transaction byte size limit surpasses the limit, Tendermint will reject the block. the current is set does For more details, see requirement number 2 in Tendermints' formal requirements.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Smart contract hub can upgrade contracts to an already used contract address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "The contracts/Hub.sol contract holds references to the addresses of the latest contract version. Contracts are upgraded to a newer address with the upgradeContract function. However, the current implementation does not verify if the Hub contract already uses the new contract address. Even though there is no immediate security implication, upgrading to an already used contract address should be prevented, similar to how it is implemented in the addContract function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. The minimum number of conrmations needed to trust an Ethereum branch should be set to 100",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "According to the specs, TransferToNamada events may include a custom minimum number of conrmations, which must be at least the protocol-specied minimum number of conrmations to 100. However, MIN_CONFIRMATIONS in apps/src/lib/node/ledger/ethereum_node/oracle.rs:19 is currently set to 50, deviating from the specs. initially but set is",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Less than half of the available wrapped transactions from the mempool are potentially included in a proposal",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "A block proposer anticipates including half of the available wrapped transactions from the mempool in a new block proposal. However, the Shell::build_mempool_txs function in takes apps/src/lib/node/ledger/shell/prepare_proposal.rs:136-148 rst half of the transactions in txs: Vec<Vec<u8>> and then lters the transactions to only include TxType::Wrapper transactions. In case there are non-wrapper transactions in this batch of taken transactions, the block will include less than half of the anticipated wrapped transactions from the mempool.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Include a check to ensure that a transfer is sent only if the slashed_amount is greater than 0",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "In apps/proof_of_stake/src/lib.rs:881 the transfer method is regardless of the amount being slashed. called",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Instance of potential integer overow on arithmetic operations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "the calculating When apps/src/lib/node/ledger/shell/vote_extensions/ethereum_events.rs: 186 there is no check for arithmetic overow. In the event of an overow, events that should be part of ethereum_events::VextDigest will otherwise be ignored. However, this event seems unlikely to ever happen, since the total voting power is greater than the sum of the validator voting powers. validator_voting_power in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Typographical error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "In TransactionGasExceedededError has a spelling mistake. shared/src/ledger/gas.rs:13, the enum variant",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Unlimited iterator stack might allow an attacker to crash the node, halting block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "The global map iteratorStack in api/iterator.go has no upper limit, which might allow an attacker to exhaust the memory of the node by creating recursive CosmWasm messages/queries that create many entries on the stack. While gas limits might prevent this issue if they are set properly, there is no guarantee that the memory is big enough to hold all the iterator stack entries the gas limit permits. This issue might cause the node to crash, potentially leading to a halt of block production if block producers are aected.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. FFI result handling may lead to memory leaks in certain cases",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "During calls from Rust to Go code through the FFI, UnmanagedVectors are created for error messages. This happens in:  The canonical_address function in libwasmvm/src/api.rs:51.  The human_address function in libwasmvm/src/api.rs:79.  The next function in libwasmvm/src/iterator.rs:60.  The query_raw function in libwasmvm/src/querier.rs:45.  The get function in libwasmvm/src/storage.rs:29.  The scan function in libwasmvm/src/storage.rs:65.  The set function in libwasmvm/src/storage.rs:118.  The remove function in libwasmvm/src/storage.rs:146. These UnmanagedVectors are destroyed within the into_ffi_result function, but only if the closure dened in libwasmvm/src/error/go.rs:75-80 is executed. That only the GoResult::Other or happens in the cases where the GoResult is of either GoResult::User variant. In all other cases, a memory leak can occur if the called code is writing to the UnmanagedVectors. In some cases, a similar issue exists with the result coming from through the FFI, for instance:  The canonical_address function in libwasmvm/src/api.rs:50.  The human_address function in libwasmvm/src/api.rs:78.  The next function in libwasmvm/src/iterator.rs:58 and 59.  The query_raw function in libwasmvm/src/querier.rs:44.  The get function in libwasmvm/src/storage.rs:28. Those UnmanagedVectors are only consumed if no error is returned, but the Go code could in theory write to those unmanaged vectors, even if an error is set. This would also cause a memory leak. Finally, the iterators next function only consumes the UnmanagedVector of the value if the key is not None in libwasmvm/src/iterator.rs:83.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Gas overow errors are treated as normal panics and do not consume Cosmos SDK gas, which can be exploited to halt block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "Within callbacks into Cosmos SDK, there is a special ErrorGasOverflow which occurs if the uint64 that is used to store gas consumption overows (see store/types/gas.go in Cosmos SDK). In such a case of an ErrorGasOverflow, Cosmos SDK sets the consumed gas to 0 in store/types/gas.go:77. The wasmvm callbacks treat such gas overow errors as normal panics, as opposed to treating them as ErrorOutOfGas, see api/callbacks.go:73-78. This leads to a gas consumption of 0 units for the Cosmos SDK related functionality. An attacker may exploit this by sending multiple messages that deliberately cause the Cosmos SDK gas counting to overow. While such messages would revert, they would consume less gas than expected such that block production might surpass Tendermints propose timeout. That could cause block production to halt.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. IBC packet receive functions result is not unwrapped, which is inconsistent and error-prone",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "The IBCPacketReceive function in lib.go:510 returns a result, and does not unwrap the errors as all other functions in lib.go do. That is inconsistent and may lead to errors if not properly handled by the calling context.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Assumption that caller of VMs create function limits contract size is inconsistent and error-prone",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "As mentioned in the TODO in lib.go:67, the VMs Create function does currently not enforce any gas limits during contract creation. Since the singlepass compiler is used, gas counting during compilation is not necessary  but the caller of the function should ensure that the size of the wasm code is limited such that block production of the underlying blockchain cannot come to a halt. Moving that responsibility to the caller is inconsistent since other functions of the VM do accept gas limits. It also requires clear documentation and introduces the likelihood of mistakes by the wasmvm integrator.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Caught Rust panics do not log errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "In several places in the codebase, panics are caught using catch_unwind. catch_unwind returns an Err(cause), where cause is the object that invoked the panic. Currently, the cause is neither logged nor returned. This negatively impacts maintainability. Instances are: libwasmvm/src/cache.rs:43, 92, 116, 143, 169, 230, 305, as well as libwasmvm/src/calls.rs:433 and 517.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Outdated specication/documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "The documentation in various Markdown les is outdated, for example: - - - - - - - - implementation of the Instantiate, Execute and Query interfaces in implementation in spec/Specification.md:43 describes that the balance of a contract instances account is passed in, which is not implemented at the moment. Accordingly, the current the ContractInfo in types/env.go:24 does not contain the Balance eld as is documented in lines 99-100. The documentation of spec/Specification.md:54-59 do not match their lib.go:118, 166, and 211. The documentation of the Result struct in spec/Specification.md:116 does not match the implementation of ContractResult in types/msg.go:12. The documentation of the CosmosMsg struct in spec/Specification.md:141 does not match its implementation in types/msg.go:68. in The spec/Specification.md:161 and 180 are not implemented. Also in lines spec/Specification.md:159 and types/msg.go:238-239 it is stated that a contract is immutable once deployed, but there is no enforcement of immutable interfaces between contract upgrades. The Params struct in spec/Specification.md:75 is now called Env and does contain TransactionInfo instead of MessageInfo, see types/env.go. The comment providing storage iteration/scans in the future, which is already implemented. Additionally, the codebase contains several TODOs in comments that are already resolved, e. g. in types/ibc.go:148 or in lib.go:67 (gas counting is addressed by caller and singlepass backend prevents JIT bombs in the contract code). in spec/Specification.md:202 describes the possibility of ContractMsg documented OpaqueMsg structs and",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Inconsistent type usage for usedGas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "The type of usedGas is used inconsistently  in some instances C.uint64 is used, in others the type alias cu64: The functions cSet, cDelete, and cQueryExternal utilize C.uint64 instead of cu64 in api/callbacks.go.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Lottery is (almost) never considered started, allowing user interaction during a running lottery which will lead to inconsistent contract states",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "In several places in the lotto contract, the condition !current_lottery.rand_round == 0 is used to determine whether the current lottery has been started. That condition will never return true though, since !current_lottery.rand_round is evaluated rst, leading to a binary not operation on the unsigned integer, which is in almost all cases not equal to 0. The condition is found in contracts/lotto/src/contract.rs:228, 366, 567, 658, and 807. This issue implies that deposits, gifts, withdrawals, sponsor withdrawals and claims are still possible while a lottery is running, leading to an inconsistent contract state.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Combinations beginning with 99 will not receive their prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "In the execute_prize function of the lotto contract, winners are determined with a storage iteration in contracts/lotto/src/prize_strategy.rs:181. The iteration starts at the rst two digits of the winning sequence of the lottery and ends at the next integer, excluding that number. For the case of the starting digits 99 though, the next integer would be 100, which is reduced to 99 in line 175. The iteration uses an exclusive upper bound in line 185, which means that the iterator would go from 99 to 99, and hence nish directly without any iteration. That implies that any combination starting with 99 will not be determined as a winner, which is incorrect. Conversely, no winners will be stored if the winning sequence starts with 99.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Lotto contracts incremental glow emission rate may be bypassed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "lotto contracts The contracts/lotto/src/contract.rs:885 glow_emission_rate. Updates are increments/decrements GlowEmissionRate query. of the determined that execute_epoch_ops used is function to update glow_emission_rate are done through the distributor in the in contracts The execute_epoch_ops function has no access control and no rate limit though, which means that any user can call it repeatedly to bypass incremental adjustments.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Claiming deposits from the lotto contract can run out of gas if a user has many unbonding info entries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "During the lotto contracts claim_deposits function, an unbounded iteration happens over a depositors unbonding_info vector in contracts/lotto/src/helpers.rs:44. If In the current that vector contains too many entries, implementation, that issue cannot be recovered from, which leads to a user being unable to retrieve their funds back. run out of gas. the call will While this issue can lead to inaccessible user funds, we do not classify it as critical since it is very unlikely for a user to have a large number of unbonding_info entries. It is still possible, for example, if another contract builds on top of Glow and withdraws in quick successions.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Exchange rate queries in lotto contract may receive outdated values, leading to share uctuations and unused UST stuck in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "or In multiple places in the codebase, Anchors aUST/UST exchange rate is queried through an EpochState query and then used calculate the aUST/UST value of deposited, gifted, sponsored (in contracts/lotto/src/contract.rs:260, 399, 507, 580, 674, and 74). The query does not include the current block number though. Without a block number, Anchor returns the exchange rate based on the last interest computation, not the latest one. That implies that the actual exchange rate may be lower than expected, with the following consequences: UST/aUST withdrawn execution during lottery and  During deposit, gift, and sponsor, the stored share will be higher than the actual aUST received. That will cause the shares to vary slightly between depositors.  During withdrawal, sponsor withdrawal, and lottery execution, too much aUST is burned, leading to unused UST stuck in the contract. Additionally, in the withdraw, sponsor_withdraw and execute_lottery functions the UST amount sent back from Anchor will have taxes deducted, while the amount used in the lotto contracts calculations is not considering taxes. That causes too many funds to be distributed, which implies that the last users will not be able to claim their deposits back due to the condition in contracts/lotto/src/contract.rs:863.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Winning sequence calculation may panic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "The winning sequence of a lottery is determined in the sequence_from_hash function of the lotto contract function, a hexadecimal string is ltered by decimal characters, and then the resulting string is sliced into the winning sequence. That slicing is done by index access of the string in line 16, which will in contracts/lotto/src/oracle.rs:14. Within that panic if the ltered string is shorter than 6 characters. Since a hexadecimal string can contain no single decimal character (an example is 0xaaaa..aa), such a panic will eventually occur. We consider this issue not to be critical since it is very unlikely and recoverable by triggering the execute_prize function again, which should result in a dierent hash and resolve the issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Updates of the lotto contracts split factor cong value will leave user funds inaccessible and lead to errors during award calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "the function in of In update_config contracts/lotto/src/contract.rs:1010, the split_factor can be updated. That split_factor is used during deposits/gifts and withdrawals to update the pools lottery_deposits, lottery_shares, and deposit_shares values. If it is changed while the lotto contract holds any user deposits, any subsequent withdrawal will apply a dierent split_factor and hence lead to an inconsistent state. contract lotto the That implies that the subtractions in contracts/lotto/src/contract.rs:737-738 will panic for the last users trying to withdraw their tokens, leaving them unable to access their funds. Additionally, the execute_lottery function in contracts/lotto/src/prize_strategy.rs:69-102 would lead to unexpected errors. the award calculation of We classify this issue as minor since it can only be caused by the contract owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Winner prize calculation will leave inaccessible division remainder in lotto contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "During the lotto contracts winner prize calculation, integer division is used to determine the prize for the winner in   contracts/lotto/src/helpers.rs:78. That integer division will leave a remainder in the contract, which is inaccessible by anyone.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Lack of prize distribution validation in lotto contract could lead to too high prizes distributed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "The prize_distribution passed to the lotto contracts instantiate function and used in contracts/lotto/src/contract.rs:71 is not validated. If the sum of its items is greater than one, higher prizes will be assigned to winners than available, and the last winners to claim their prizes will run into an InsufficientClaimableFunds error. We still classify this issue as minor since it can only be caused by the owner during instantiation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Attackers can drain funds from contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:245, the execute_set_recipient function sets the escrow status to EscrowStatus::Active even if the escrow is already completed and its funds were transferred. This allows an attacker to reactivate completed escrows to drain funds from the contract by executing SetRecipient and Approve messages repeatedly. Additionally, since in src/commands.rs:610 the function send_tokens returns an empty vector when the balance is empty, even if the receiver did not deposit funds, the sender can still perform the attack draining funds from the contract. Please see the steal_funds test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Malicious arbiters can steal funds by overwriting the recipient address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:408-415, an arbiter needs to approve the escrow before processing the trade. A malicious arbiter can execute the SetRecipient message to overwrite the recipient address to another one under its control and then call the Approve message to steal the original recipients funds. Please see the arbiter_steal_funds test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Funds are locked if the recipient has deposited and the arbiter does not approve the escrow before the deadline",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:408-415, the arbiter is required to approve the escrow to process the trade if it is created providing an arbiter and recipient. If the arbiter does not approve the escrow before the deadline, funds will be stuck in the contract. In fact, both Approve and Refund messages will revert respectively with Expired and RecipientAlreadyDeposited contract errors. Due to the impossibility of the arbiter rejecting an escrow and refunding both parties, this issue is likely to happen when the arbiter opposes the trade. Please see the funds_stuck_arbiter_after_deadline test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Escrows can be completed without recipients interaction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:255, the execute_approve function does not verify the recipients balance is not empty when processing the trade, allowing the trade to be completed without any deposits from the recipient. This is problematic because the recipient could collude with the arbiter to approve the escrow and steal the creators funds. Consequently, the creators funds will be sent to the recipient, while the creator receives nothing in return. Please see the approve_without_deposit test case to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Escrow and vesting end times should be enforced to be in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "During the execution of Create messages, in both src/commands.rs:126-129 and src/commands.rs:196, the vesting_end_time and end_time timestamps are not validated to be in the future. This could lead to scenarios where the newly created escrow is already expired, or the vested tokens are immediately redeemable.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Division by zero error if creator or receiver fee percentage is set to zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "During contract instantiation, zero percentage fees for creator or receiver are accepted. However, since this value is used as a denominator in the calc_minimum_balance function in src/commands:696 during the handling of Create messages, a zero value will lead to a division by zero error. if any the Additionally, transfer_tokens_messages function will fail because the contract will try to send zero amount of fees, which will be prevented by Cosmos SDK. fee collectors are miscongured to receive zero fees,",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Missing address validation during contract instantiation and conguration update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "During contract UpdateConfig messages in src/commands.rs:16-51, admins addresses are not validated. instantiation in src/contract.rs:28-54 as well as execution of the fee_collectors and Storing invalid addresses could lead to unexpected behavior like errors when completing escrows because of the failure of Bank messages directed to an invalid fee collector address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Fee collectors' percentage sum should not exceed 100",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "both In fee_collectors vector provided by the admin is set in the CONFIG struct. src/contract.rs:40-42 src/commands.rs:35-40, and the Since this vector represents a weighted list of addresses that should receive fees, the sum of the percentages of all the vectors elements should not exceed 100 to avoid charging more fees than expected. Additionally, duplicate addresses are allowed in the vector, potentially leading to higher fees than intended. We classify this issue as minor since only the contract admin can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Contract-dened admins can lock user funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:655-691, the calc_fees function iterates over all fee collectors for each balance coin in order to send fees through Bank messages. limit Since no upper for fee_collectors is enforced, admins could store a large fee_collectors vector in order to let the contract run out of gas during the calc_fees function execution. Consequently, all the messages that involve the sending of funds will fail, leading to the lock of user funds in the contract. We classify this issue as minor since it can only be caused by admins who are community-trusted entities.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. OTC_ACTIVE_PAIRS_COUNT is not decrement when public OTC is modied into private",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:230, the execute_set_recipient function does not decrease the active OTC pairs when a public OTC trade becomes private. Consequently, incorrect values. this causes the MarketEscrowActivePairsCount query to return Please see the public_to_private_does_not_decrease_active_otc test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Missing validation to ensure that creator_balance is not equal to asking_price",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:96, creator_balance is equal to the asking_price. the function execute_create is not checking if the If an escrow with the same provided and asked coins denom and amount is created, this could generate a potentially unwanted arbitrage opportunity and make the creator lose funds on the trade.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Admin can update fee_collectors to an empty vector",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "src/commands.rs:35-40, fee_collectors, In assert_has_fee_collectors is not called to ensure the fee collectors vector is not empty. update during an of This is inconsistent with the contract instantiation phase in src/contract.rs:36.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Redundant partial ll validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:461-463, the if statement ensures the escrow allows partial lls in the execute_receiver_partial_deposit function. This check can be removed as the same validation is performed in src/commands.rs:333.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Incorrect comment for vesting_end_time",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:90, the comment documents that vesting_end_time represents the vesting start time. This is incorrect, as the variable represents the vestings end time.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Loss of escrow information after the execution of Refund messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "During the handling of Refund messages, the execute_refund function removes the selected escrow data from the storage. While this is not a security issue, it could degrade the user experience since escrow information is not queriable anymore, and all the involved parties have no more reference to their operations. Additionally, in the case of partially lled escrows, the removal of the original escrow could lead to the impossibility of retrieving data from its partial_fill_of_id.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Custom access controls implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "The contract implements custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Late depositors would get the same amount of dividend as early depositors, causing an unfair dividend allocation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "In contracts/core/phaser/src/contract.rs:211, new users that stake their kUST tokens will have their last_dividend_points set to 0. This is problematic since the value of last_dividend_points is used to determine the amount of dividends a user is entitled to claim as seen in contracts/core/phaser/src/util.rs:72-78. This would cause late depositors to claim the same dividend allocation as early depositors, resulting in unfair dividend allocation and possibly insucient funds in the contract. is also issue present in This of contracts/core/vault/src/contract.rs:262. last_accumulated_yield_weight is used to calculate the yield users are entitled to earn in contracts/core/vault/src/cdp.rs:40-53. As above, late depositors would be able to claim more yield than intended. contract value vault Here, the the in",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Malicious users can trick the system into receiving more yield than entitled",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "In contracts/core/vault/src/contract.rs:252-256, existing depositors will have their cdp.total_deposited value increased based on the amount they deposited without allocating the yield beforehand. This is problematic because the yield earned is based on the user's deposited amount as seen in contracts/core/vault/src/cdp.rs:50. Consequently, a malicious user can deposit funds repeatedly into the vault contract and withdraw them after some time to claim more yield than they should have received.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Users are unable to withdraw all funds from vault contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "Users are able to call the Redeem message in order to withdraw UST or aUST from the vault contract. Before that, the users collateral debt position (CDP) is checked to verify the user's position is not undercollateralized. However, users will be unable to withdraw the max available amount of funds since the is_cdp_healthy_after_withdraw function veries that using Decimal256::from_ratio as seen in contracts/core/vault/src/cdp.rs:21. If the user attempts to withdraw all available funds, the value passed would become 0 and eventually cause a division by 0 panic. collateralization users CDP lower than limit the the by is",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Updating users collateral debt position causes loss of yield",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "In contracts/core/vault/src/cdp.rs:29, users cdp.total_credit value is updated when the earned yield is higher than users debt. If the user has an existing cdp.total_credit balance, it would be overwritten due to the latest value being directly set instead of increased along with the existing balance. This would cause a portion of the users earned yield to be stuck in the contract.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Users are unable to withdraw funds once phaser is started",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "the update_account function In contracts/core/phaser/src/util.rs:63, attempts to deduct users entitled dividend from cfg.unclaimed_div value. This value can only be increased when theres an increase in UST allocations as seen in line 54. However, the increased amount comes from cfg.total_div which means the amount will never be enough to deduct users entitled dividend, which will cause an underow error. To illustrate the scenario: 1. Alice stakes user.deposited_synth_tokens cfg.total_deposited_synth_tokens to be 100. kUST via ReceiveMsg::Stake, this would cause and 2. 200 UST is sent via Distribute message which causes cfg.total_deposited_base_tokens and cfg.buffer to be 200. 3. Bob decides to stake 50 kUST which would cause run_phaser to execute. Assuming cfg.phase_period has passed, the contract will enter line 53-54 with cfg.total_div and cfg.unclaimed_div value as 2 (200/100 = 2). 4. At this point, theres a high possibility that no one can withdraw their funds since the phaser is executed. update_account. 5. Alice decides to withdraw her tokens by calling ExecuteMsg::Unstake which will call from dividends_owing function would be 200 (100*2 = 200, see lines 73-75). Since the value of cfg.unclaimed_div is 2 while the owing value is 200, this would cause an underow error in line 63. returned amount owing result, the In This issue also aects other entry points that call update_account function, which are Phase, Stake, and Unstake.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. More synthetic tokens are burned than intended",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "In contracts/core/phaser/src/contract.rs:376, the amount of synthetic tokens burned depends on the balance of user.realized_tokens and not on the currently phased amount. This would cause more synthetic tokens being burned than the intended amount, which opens the possibility that there are not enough synthetic tokens in the phaser contract. As a result, this would cause a loss of funds for the protocol.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Claim message in phaser contract withdraws more UST than the user should own, leading to a loss of funds for other users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "In contracts/core/phaser/src/contract.rs:309-313, when a user decides to claim their phased UST, the contract withdraws the amount in aUST without calculating the exchange rate. Due to the fact that aUST usually trades above UST, this may lead to a withdrawal of a greater amount of UST from the adapter than the user should be able to claim. This causes a loss of funds for the whole protocol.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Anchor exchange rate used might be out of date due to missing block height argument",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "The Anchor exchange rate is queried from the Anchor contracts, through the utility function epoch_state, in contracts/core/adapters/anchor/src/msg.rs:102-114. However, no block height argument the block height argument, Anchor returns a raw exchange rate from stored values without accruing interest since the last update, which means an outdated exchange rate is returned. Using this value could lead to slightly incorrect calculations. is supplied. Without dened",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. The contract can be drained completely, and attackers can pay in esoteric currencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/Audit Report - Out.pdf",
        "body": "In src/user/execute/buy_shares.rs:47,85 info.funds[0].amount is used to determine the amount of inj sent to the contract, but it is never checked if it is actually denominated in inj. Consequently, the current payment system in the contract allows users to pay in any denomination. This exibility leads to two critical consequences: 1. Diverse Currency Acceptance: Users can pay with a currency dierent from the intended one. 2. Exploitation of Excessive Payment Refunds: More concerning is the vulnerability arising from the mechanism of refunding excessive payments. When a user overpays in a currency other than the desired inj, the system automatically calculates and refunds the excess amount in inj. This process can be exploited by a malicious attacker. By intentionally overpaying with a dierent currency, an attacker can trigger a refund that drains the entire balance of the contract, as the refund is made in inj.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Zero-amount token transfers will fail, preventing shares from being traded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/Audit Report - Out.pdf",
        "body": "In many instances, the BankMsg::Send message is used to transfer collected fees, denominated in inj tokens, to the respective recipients. However, if the transfer amount is zero, the BankMsg::Send message will fail, causing the transaction to revert and shares not to be bought or sold. While this is explicitly checked for the referral_fee fee in src/user/execute/sell_shares.rs:76, such a check is missing in all other instances:  src/user/execute/buy_shares.rs:69-72, 74-77, and 78-81.  src/user/execute/sell_shares.rs:66-69 and 71-74.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Missing address validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/Audit Report - Out.pdf",
        "body": "In many instances, addresses supplied as type Addr to messages are not validated and are used as-is. While any invalid addresses supplied to the buy_shares and sell_shares it is considered best practice and a function will error in the BankMsg::Send message, better user experience to validate addresses early on and error with a meaningful error message. For example, in src/owner/execute/set_fee_destination.rs:15, a conguration error of a wrong state.protocol_fee_destination address could lead to every transaction failing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Economic risk due to unsustainable pricing model",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/Audit Report - Out.pdf",
        "body": "The protocols pricing curve follows an exponential rate of growth based on a formula with some magic numbers. There is no clear justication for the use of those numbers and the reason the price is an exponential function of supply. For example, an early investor, specically the rst share buyer, would be in a 125% prot, even if they sell when the total supply is two. Their downside is also limited to the maximum amount of fees, which could be up to 25%. This makes early investors very well positioned to prot quickly and leaves later investors vulnerable to signicant losses if people on a signicant prot decide to materialize it. In addition, increasing the margin of potential loss for users. the maximum amount of fees sets the spread at a hefty 25%, signicantly it is worth noting that there is no cap on the supply, which would have been a relief Also, factor in case the demand for the shares dropped. Additionally, the potential for exploitation by individuals with access to automated trading tools or a substantial social media following is aggravated due to the exponential dynamics. These parties may leverage the protocol to articially generate hype, manipulating market dynamics. Nature of the Issue: This concern, primarily economic, mirrors scenarios observable in low-liquidity markets without a predened pricing curve. In such environments, practices like wash-trading can articially inate prices before a sell-o, or referrals are compensated through unocial channels. Its important to note that while this issue is signicant, it is classied as minor as it could arise in other low-liquidity markets without a pricing curve. Nevertheless, by oering only an exponential curve, the pricing dynamics are preset, and the protocol also faces some reputational risk due to not oering a predictable environment for all participants, safeguarding against potential manipulative practices and fostering long-term viability. it's important to note that the pricing mechanism is particularly vulnerable to Additionally, frontrunning and transaction ordering MEV: If an institution/block producer is able to frontrun, they are facing a determined price for each transaction. For buying transactions, the user will be only aected if they overpay because the transaction will fail otherwise, but for selling transactions, institutional traders might have a big advantage, prioritizing their own trades and thus creating larger losses for the user.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Inability to change the contract owner",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/Audit Report - Out.pdf",
        "body": "During the contract instantiation in the instantiate function in src/contract.rs:37, the contract owner is set to the message caller, info.sender. However, the contract can not be changed to a dierent address, presenting a risk to the contract ownership in case the owner account keys are compromised or a change of ownership is desired. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. The toggle_trading function potentially emits misleading events",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/Audit Report - Out.pdf",
        "body": "The function toggle_trading in src/owner/execute/toggle_trading.rs:5 is used to change the trading_is_enabled boolean state variable and subsequently prevent or allow buying and selling shares. This function emits events each time the state is set. However, the function could just reset the value of trading_is_enabled to the existing value. This would emit an event that o-chain participants may nd confusing, as it might be assumed that this is a change in the state.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Remove unused imports, errors, and variables",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/Audit Report - Out.pdf",
        "body": "There are instances of unused imports, errors, and variables in the codebase:  Unused error InsufficientPayment in src/error.rs:28.  Unused error BuySellQuantityLimitExceeded in src/error.rs:25.  Unused error SerializationError in src/error.rs:19.  Unused error NotFound in src/error.rs:16.  Unused error CustomError in src/error.rs:13.  Unused variable shares_holders in src/user/execute/buy_shares.rs:36.  Unused in shares_balance variable src/user/execute/sell_shares.rs:19.  Unused import StdError in src/user/execute/buy_shares.rs:6.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Use of magic numbers and hardcoded values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/Audit Report - Out.pdf",
        "body": "Throughout the codebase, there are many instances of magic numbers:  Hardcoded denom inj in src/user/execute/buy_shares.rs:71, 76, 80, 89, and src/user/execute/sell_shares:63, 68, 73, 79.  Magic fee limit values in src/owner/execute/set_protocol_fee_percent.rs:14,36, src/owner/execute/set_referral_fee_percent.rs:14,35, src/owner/execute/set_subject_fee_percent.rs:14,35, src/contract.rs:36-43.  Magic values in pricing curve in src/util.rs:13.  Magic values in the instantiation in src/contract.rs:38-43 and",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/Audit Report - Out.pdf",
        "body": "The contract in scope of the review does not enable overflow-checks in Cargo.toml for the release prole.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Non-deterministic iteration in BuildDependencyDag may break consensus",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In x/accesscontrol/keeper/keeper.go:333, nodes iterate over anteDepSet. Due to the non-deterministic behavior of iteration over maps in Go, there could be two dierent types of errors from ValidateAccessOp. This could lead to consensus failure.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. RegisterWasmDependency allows anyone to register contract dependency mappings that can increase gas consumption",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "function RegisterWasmDependency in The x/accesscontrol/keeper/msg_server.go:22 allows anyone to register contract dependency mappings. It does not validate if the transaction sender is the contract owner. the Sei Chain where the These contract dependency mappings are used by in GetWasmDependencyMapping x/accesscontrol/keeper/keeper:126 gets a contracts dependency mapping information. This may create opportunities for attackers to exploit applications on top of Sei Chain. For instance, an exploiter can make the getMessageMultiplierDenominator function return WasmCorrectDependencyDiscountDenominator. This will lead to an increase of the the DispatchMsg function in gas consumption for wasmbinding/message_plugin.go:118 of Sei Chain does not validate message dependencies if a contracts WasmDependencyMapping is disabled. app/antedecorators/gas.go:34 that particular contract. Moreover, function dened Chain Sei of in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Several errors are not handled and may cause an inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "there are unhandled errors that allow execution to In several places of continue even when operations have failed. This may produce inconsistent states and unexpected panics. the codebase, Instances of unhandled errors can be found in:  x/bank/keeper/keeper.go:47  x/bank/keeper/keeper.go:456  x/bank/keeper/keeper.go:434  x/bank/keeper/keeper.go:378  x/accesscontrol/handler.go:14  baseapp/abci.go:31 As an example, the UpsertDeferredSends function may return an error, which is not checked. The calling function, DeferredSendCoinsFromAccountToModule, should propagate the Error upstream, but since the Error is not handled this will not happen. Since the execution would continue, it may leave the network in an inconsistent state or cause an unexpected panic.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Missing LegacyAmino codec registration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In x/accesscontrol/module.go:45, the RegisterLegacyAminoCodec function does not register the modules LegacyAmino codec. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Use of deprecated function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "x/accesscontrol/client/utils/utils.go:15 and In x/accesscontrol/client/utils/utils.go:28, the ReadFile function is called from the ioutil package, yet that package is deprecated as of Go 1.16. The function should be used from the os package instead.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Resolve TODOs before release",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "There are multiple TODOs in the codebase that may refer to sensitive or important logic. Instances are:  baseapp/abci.go:170  baseapp/baseapp.go:717  x/accesscontrol/keeper/keeper.go:406  types/module/module.go:289",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Unnecessary lock acquisition might negatively impact performance",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In types/context_cache.go:68, there is a check to circuit break in case the amount is not valid. However, before that check, a lock is acquired which is not needed for this specic validation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. MintCoins does not perform a nil pointer validation in case the module name is passed incorrectly",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In x/bank/kepper/keeper.go:561, the module account is retrieved to add coins to it through the createCoins function in line 565. However, if the moduleName does not exist, it would return a nil pointer from the GetModuleAccountAndPermissions function. Currently, the only place that the function is called is in x/mint/keeper/keeper.go:103, and the module name is a constant. Therefore, unless that specic module name does not exist, there is no attack vector with the current design.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Unused assignment in GetSigners",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In types/tx/types.go:125, there is an assignment to the variable seen which is never used thereafter.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Commented code in encryptPrivKey",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In encryptPrivKey in crypto/armor.go:149, there is an assignment that has been commented out.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Missing usage description for transaction and query CLI commands",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "transaction in The commands and and x/accesscontrol/client/cli/tx.go:18 x/accesscontrol/client/cli/query.go:13 are missing a long message to describe their usage, which could be helpful for users and external developers. accesscontrol module query the of",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Miscellaneous comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "Across the codebase, various instances of unused code and misleading comments have been found.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Slashing distribution may create a tragedy of the commons where slashing is never applied and new users are disincentivized to enter the protocol",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "function calculate_new_withdraw_rate time (minus an unbonding_period delta time). in The lido_cosmos_hub/src/unbond.rs:129 updates the historical withdraw_rate of a given batch to account for slashing events that happened between the unbond epoch and the current In line 140 of a each calculate_new_withdraw_rate, batch_slashing_weight, which is the proportion of the unbonded ATOM amount of a given last unbonded ATOM of execute_withdraw_unbonded execution. That implies, that no matter when the slashing occurred, slashing will aect all users that have unbonded but have not yet withdrawn. all batches assigned batch batch since total gets the the to This mechanic can create a tragedy of the commons situation, as waiting unstakers are incentivized to not withdraw, since their slashing amount will be reduced the more other users unbond in subsequent batches. Worst case, this can result in a deadlock where no one is incentivized to withdraw. Moreover, new stakers coming in when there are pending slashes will participate in those not yet applied slashes, disincentivizing new users to stake funds. Due to the condition in contracts/lido_cosmos_hub/src/unbond.rs:59, external intervene to resolve the problem by triggering a new withdraw_rate users cannot calculation, since withdrawing is restricted to users that have pending withdrawals.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Unbounded unbond history entries may cause all deposited funds stuck in the hub contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "running out of gas causing stuck irrecoverable funds in the hub contract. The execute_withdraw_unbonded function contains unbounded loops which have the In risk of the lido_cosmos_hub/src/contract.rs:102, calculate_newly_added_unbonded_amount function, there is an unbounded loop that in line 203, iterates over the unprocessed UnbondHistory entries. In a similar manner, inside within the process_withdraw_rate function, another unbounded loop iterates over the same UnbondHistory entries that haven been just processed. If there are no withdrawals for a long enough timeframe, or if the epoch_period is very short, there may be too many entries so this cannot be processed as it would run out of gas, leaving all funds stuck forever in the contract. We do not classify this issue as critical since any user withdrawing unbonded funds will move the last_processed_batch forward, iterations the next withdrawing user needs to process. reducing the number of",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Unbounded unbond wait entities may cause user funds to be stuck in hub contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "an unbounded loop starting in The get_finished_amount function contains lido_cosmos_hub/src/state.rs:113 that iterates over each UnbondWaitEntity of a user. Removal of deprecated batches in the   remove_unbond_wait_list function in line 67 is also unbounded. If there are no withdrawals for a long enough timeframe, or if the epoch_period is short, there may be too many entries so this iteration would run out of gas, leaving the funds of the given user stuck in the contract. issue same could The in lido_cosmos_hub/src/contract.rs:483 and the query_get_finished_amount function in contracts/lido_cosmos_hub/src/state.rs:137 to run out of gas, making the WithdrawableUnbonded and UnbondRequests query unusable. query_unbond_requests function cause the We do not consider this issue to be critical, since the probability of a user experiencing this issue is fairly small. However, its theoretically possible and may happen when using bots and/or automated bonding/unbonding strategies.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Missing validation of Lido fee rate may cause reward dispatch to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "The lido_fee_rate parameter in the Cosmos Reward Dispatcher contract determines the fee Lido applies to bonded Atom rewards. However, there is no validation that this value is smaller instantiation the (lido_cosmos_rewards_dispatcher/src/contract.rs:39) execute_update_config function (line 113). If the fee parameter is bigger than one, dispatch of rewards will fail due to an underow in line 147. Decimal::one() contract than or at in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing validation for stored validator and guardian addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "of list addresses The in lido_cosmos_validators_registry/src/contract.rs:46 is not validated as Addr type. Likewise, addresses are not validated in the add_validator function in line 116. REGISTRY validators stored of in issue is present in lido_cosmos_hub/src/contract.rs:142 in the A similar execute_add_guardians function, where the new GUARDIANS addresses stored are not validated as Addr.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Unbounded guardians query may run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "contracts/lido_cosmos_hub/src/contract.rs:409, In query_guardians iterates over all guardians in storage. Since there can be an unlimited amount of guardians in storage, this iteration can run out of gas. We mark this issue as minor since guardians can only be added by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Slashing is not accounted for in queries which may give wrong results and cause unexpected behavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "lido_cosmos_hub/src/contract.rs:451 In function query_withdrawable_unbonded returns the withdrawable amount for a given address. However, the latest withdraw_rate is not taken into account which is discounting any slashing events that may have occurred. Hence, this query may return incorrect results which may cause unexpected behavior on 3rd party applications integrated with Lido. the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Negative unbonded amounts are not being handled when calculating the withdraw rate",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "In contracts/lido_cosmos_hub/src/unbond.rs:163, when calculating the new withdraw_rate, there is a signed subtraction that might return a negative value. If that were to happen, tokens would be sent to the users that the user should not receive. This could occur if the full amount were slashed, or if nearly the full amount is slashed due to rounding/truncation. Even though this scenario is unlikely, it is theoretically possible as the Cosmos SDK allows a slashing fraction of 100%.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Missing denomination check may become problematic in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "only which contracts Lido Cosmos Hub the Currently, the underlying_coin_denom, In contracts/lido_cosmos_hub/src/contract.rs:341 there is a check to add the delegation amount of the underlying_coin_denom. However, other denominations that are delegated at the same time will be ignored. This could cause issues if the protocol were to add new staking tokens in the future. A similar missing denomination check is also present in contracts/lido_cosmos_validators_registry/src/contract.rs:160 and 223. staking updated. support be cannot in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Users might lose unbonded funds to users that unbond in the next batch if the unbonding period of the hub contract is shorter than the one of the underlying blockchain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "expected undonded amount with Within the execute_withdraw_unbonded function, slashing is applied to an undelegation batch by adjusting the statom_withdraw_rate of that badge. This is done by comparing the The actual_unbonded_amount is calculated by subtracting the stored prev_hub_balance in hubs from contracts/lido_cosmos_hub/src/unbond.rs:193. expected undbonded amount is then computed in the calculate_newly_added_unbonded_amount function by iterating over all unbonding history entries from the last processed/released one to the one thats older than unbonding_period param. unbonded amount. balance current ATOM actual The the the This works well if the unbonding_period param is equal to or greater than the underlying blockchains unbonding period. If the unbonding_period param is too short though, the expected unbonded amount may be bigger than the actual unbonded amount, even if no slashing happens. the statom_withdraw_rate will be too low, and unbonding users lose funds to users in the next unbonding batch. In that case, Despite the severe implications of a too short unbonding_period param, we classify this issue as minor, since governance can ensure equality of the periods by carefully making required changes.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Users are subject to slashing between unbonding and undelegation batch execution, which is currently not documented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "The current implementation of Lido nance does undelegations in batches for eciency reasons. Undelegations happen at most every epoch_period through the logic in the execute_unbond_statom function at lido_cosmos_hub/src/unbond.rs:289. That implies that users that have sent unbond messages to the hub contract will still be subject to slashing until the delegation batch is executed. This behavior is dierent from Cosmos SDKs slashing module, which only slashes delegators that were active when the slashing event occurred. This dierence is currently not documented.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Ability to pause hub contract increases risks associated with compromised owner key",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "The hub contains a paused param, which can be set/unset at any time by the owner to pause/unpause in contracts/lido_cosmos_hub/src/contract.rs:177 and 196. If the owner key is ever compromised or lost, funds may be left inaccessible forever in the contract. contracts the We classify this issue as informational since a compromised owner key has other severe implications and proper key management is an underlying assumption of the protocol in any case.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Exchange rate is not updated after bonding rewards and may exhibit small variations due to rounding/truncation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "In contracts/lido_cosmos_hub/src/bond.rs:94, when the BondType is StAtom, the exchange rate is not updated. Since the new stATOM is minted in proportion to the exchange rate, it should remain identical. However, due to rounding/truncation, the exchange rate may be subject to small variations and these are not accounted for.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Storing exchange rate and total stATOM issued in hubs state is inecient and complicates the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "a hub eld State contains contracts statom_exchange_rate The in packages/basset/src/hub.rs:28, which is updated in several places throughout the codebase, for example whenever rewards are accumulated. Since rewards are accruing on on an ongoing basis, the stored exchange rate will be almost instantly outdated. To use the correct value, the current implementation updates the stored exchange rate before every usage, including before a query of the State. Consequently, there is little point in storing the statom_exchange_rate in the State in the rst place. Storing unnecessary data is inecient and makes the codebase more complicated. Similarly, the State contains a eld total_statom_issued in line 26. However, this is inecient as it should be equivalent to the supply of stATOM, which is queried within the function call in contracts/lido_cosmos_hub/src/bond.rs:71.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Outdated references to Terra implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "The documentation states that any logic related to the Terra implementation should be marked as an issue. In this informational issue, we list comments and code that references the Terra implementation. - All contracts and packages use version 0.16.0 of cosmwasm-std, which is a legacy version only used on Terra. - Comment in lido_cosmos_validators_registry/src/contrac.rs:156 referencing Terra Core. - Outdated documentation title in contracts/lido_cosmos_hub/README.md:1.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Duplicate check slashing message is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "the in In contracts/lido_cosmos_token_statom/src/handler.rs:51-62, a duplicated slashing message in case the burn sender is not the hub_contract. The second CheckSlashing message does not have any new eect on the state, so it seems unnecessary. message Burn there is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Inaccurate logic conditions in delegation calculation can undermine the eciency of the contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "the in In lido_cosmos_validators_registry/src/common.rs:38, if coins_per_validator + extra_coin is equal to validator.total_delegated, an unnecessary iteration over the loop will be made when bonding or removing a validator. calculate_delegations function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Name and version of stATOM contract are incorrectly set up",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "inherits its instantiate function from cw20-base, The stATOM cw20-compliant contract in calling cw20_init incorrectly lido_cosmos_token_statom/src/contract.rs:41. This function will store the CONTRACT_NAME to crates.io:cw20-base and CONTRACT_VERSION to 0.8.0, instead of crates.io:lido_cosmos_token_statom and 1.0.0 respectively. function the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Remove unused code to improve contract size and readability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "such code Unused in lido_cosmos_hub/src/state.rs:35 increases contract bloat without providing any in functionality. package/basset/src/contract_error.rs:5. MAX_DEFAULT_RANGE_LIMIT ContractError example Another const enum the as is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "20. Marking paused parameter in the Hub as an Option adds unnecessary complexity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "hub contract The in paused packages/basset/src/hub.rs:141, that guardians and the contract owner can use in critical situations to disable most interactions with the contracts. However, the type of paused is Option<bool> instead of just bool, which adds extra unnecessary complexity. parameter dened switch, has a",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "21. Incorrect query function name may negatively aect user and developer experience",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "function in The contracts/lido_cosmos_hub/src/contract.rs:489 is referencing a dierent storage map UNBOND_HISTORY_MAP which may confuse users and may cause further issues if 3rd party developers query this function. query_unbond_requests_limitation",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. Iteration over queued stakings in end blocker can be exploited to halt block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/All in Bits/2022-04-04 Audit Report - Budget and Farming Cosmos SDK Modules v1.0.pdf",
        "body": "Within the EndBlocker of the farming module, multiple iterations occur over all queued stakings in x/farming/keeper/staking.go:399. An attacker could create a large number of stakings in an epoch to cause the end blocker to run too long to nish creation of the block within Tendermints propose timeout. The cost of this attack is relatively small since the staked amount could be minimal, and staking itself is not gas-intensive.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "1. Risk of Denial-of-Service of the merkle hook",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "The PostDispatch execute message in contracts/hooks/merkle/src/lib.rs:80 is callable by any sender and results in an insertion into the Merkle tree so long as the message matches the latest_dispatch_id. The latest_dispatch_id is a known value that can be queried from the mailbox. This will allow attackers to spam the Merkle tree by repeatedly calling PostDispatch with duplicates of the latest dispatched message. The duplicated message identiers are not rejected and pollute the tree. Consider the case of inserting into a Merkle tree 1,000,000th leaf. The Merkle tree, including its intermediate nodes (one less in number than its leaves), amounts to 1,999,999 32-byte nodes, totaling 63,999,968 bytes. The default Cosmos SDK rate for smart contract storage writes is 30 gas per byte, plus a at write fee. Consequently, the gas required for storing a Merkle tree with 1,000,000 message IDs is approximately 1,919,999,040. The actual monetary cost varies with the network's specic conditions and load at any given time. For example, in Osmosis, the minimum gas price can be 0.0025 uosmo, and the average is around 0.025 uosmo. Assuming an OSMO price of 0.33 USD, the minimum cost for this operation would be about 1.5 USD, and the average cost would be about 15 USD. The tree size grows linearly with its leaves. Thus, for the billionth message, the minimum gas cost could surpass 1,500 USD, while the average fee may reach around 15,610 USD. As a consequence, the cost of operating the hook grows proportionally to the amount of messages processed and can reach levels unacceptable for users. A malicious party could deliberately invest funds to render the hook inoperative.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Lack of info.funds transfer to postDispatch leads to failure of subsequent operations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "The TransferRemote message allows funds to be transferred via callbacks through the Mailbox contract directly to the destination chain if the route for dest_domain has been found. when calling However, in contracts/warp/native/src/contract.rs:204, no funds are transferred as transactions and calls. info.funds that could cover the costs of gas of subsequent Therefore, they will return errors and revert, making the functionality unusable. mailbox::dispatch method the This vulnerability was also independently identied by the client during the audit and resolved by introducing the \"approve and transfer from\" method.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Resource intensive Multisig ISM verify_message query",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "includes an intensive computation for verify_message in The Multisig ISM contract contracts/isms/multisig/src/query.rs:19-66. The verication performs a linear pass through all provided signatures, recovering public keys from them, and performing a nested linear scan to nd matching validators. This results in a quadratic computational complexity operations, secp256k1_verify and eth_addr, are executed for each signature. The code involved in this issue has been updated in Phase 2 of this audit but the issue remains. resource-intensive Furthermore, verication. two the of Heavy computations in smart contracts lead to high gas fees and increase the risk of Denial-of-Service attacks. Note that queries to external contracts in CosmWasm impose gas restrictions, so the caller of this query may experience out-of-gas errors. The result of this is that messages may fail to be processed by the mailbox if the query exceeds wasmd smart query limits.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Warp contracts do not specify hook in transfer_remote function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "The transfer_remote function in both warp contracts currently sends a mailbox dispatch message with a hook parameter hardcoded to None. This undermines the design of the protocol by not utilizing the hooks feature. This issue was also independently identied by the client during this audit.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Multisig ISM may cause out-of-gas errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "ISM contract The Multisig in contracts/isms/multisig/src/execute/validator.rs:26. This function exhibits ineciencies that escalate costs as the number of validators rises: enroll_validator contains function the 1. validators.0.iter performs a linear pass through all already enrolled validators. 2. validators.0.sort_by operates with O(N logN) complexity, where N is the total number of validators. The same ineciencies impact the unenroll_validator function in this le. This issue is classied with minor severity since only the owner has the authority to enroll and unenroll validators.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Static multisig threshold design presents scalability concerns",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "The Multisig ISM (Interchain Security Module) relies on a static threshold parameter to verify messages based on the number of validators that have veried the message. This parameter's storage is dened on contracts/isms/multisig/src/state.rs:15 as a mapping from secured domains to threshold values. A xed threshold number is not reliable because as the number of validators increases, the probability of collusion or leaked keys also rises. Therefore, the threshold should always be adjusted according to the current number of validators.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. A zero threshold will make it impossible to verify a message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "The aggregate ism contract allows the minimum value of the THRESHOLD state parameter to In the functions be set in responsible the and contracts/isms/aggregate/src/lib.rs:126-128 to zero in contracts/isms/aggregate/src/lib.rs:55. verifying message for contracts/isms/multisig/src/query.rs:55-59, after obtaining conrmation from the rst validator, the threshold value is decreased by one. Since the value was initially equal to zero, an underow occurs, which will result in a panic. As a consequence, this operation cannot be completed successfully, leading to a state of unusability.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Pausable endpoint not exposed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "contract mailbox in is The contracts/core/mailbox/src/contract.rs:39. However, the pausable-related execute entry points are not exposed in the execute function in lines 45-64. Therefore, it is not possible to pause the contract after being instantiated, rendering this security mechanism ineective. instantiated pausable feature with the Additionally, the contract is instantiated with pausable set to false. To ensure no users the dispatch or process messages before the default_ism, attempt default_hook, and required_hook have been set, it could be benecial to instantiate the contract in a paused state and once the initial setup occurs unpause the contract. to pass",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Strategic planning is crucial for Mailbox contract upgrades",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "at check The rejects messages from older Mailbox versions. Upgrading the destination contract with messages in transit would lead to failure of their delivery albeit being paid and veried. contracts/core/mailbox/src/execute.rs:217-223 To manage this, dispatching new messages might be temporarily halted using the Pausable the Router hook can be employed. However, as hook. For domain-specic pausing, Mailbox instances across dierent domains could have separate ownership, coordinated upgrades necessitate prior agreements among all updates. involved parties for synchronous lane",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Missing address validation and normalization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "Multiple contracts within the scope of this audit lack address validation or normalization steps. Some of the aected instances cause just a transaction failure when an incorrect address is provided, wasting gas. But others would render some features unusable until a valid address is recorded. The following instances were found:  dispatch_msg.recipient_addr in contracts/core/mailbox/src/execute.rs:151-156. Although it is not possible to validate the address as it belongs to a dierent chain, the address could be normalized to lowercase.  recipient in contracts/core/mailbox/src/execute.rs:215  msg.recipient in contracts/hooks/routing-custom/src/lib.rs:185  refund_address in contracts/igps/core/src/execute.rs:114  router in packages/router/src/lib.rs:98  set.route in packages/router/src/lib.rs:74",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Lack of input validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "Multiple contracts within the scope of this audit lack input validation, for example of HRP, the gas token, and the oracle congurations. Invalid inputs can render the contracts unusable until a correct value is provided. In some cases parameter updates require deploying a new contract.  msg.hrp in contracts/core/va/src/contract.rs:46  msg.gas_token in contracts/igps/core/src/contract.rs:34  msg.hrp in contracts/igps/core/src/contract.rs:35  msg.hrp in contracts/core/mailbox/src/contract.rs:27  msg.hrp in contracts/isms/multisig/src/contract.rs:35  config in contracts/igps/oracle/src/contract.rs:54 and 71",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Aggregate hook does not consider alternate denominations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "The quote_dispatch function in contracts/hooks/aggregate/src/lib.rs:147 does not account It incorrectly assumes that all gas coins are of the same denomination, which cannot be guaranteed. Ultimately this could cause an error further in the execution of the dispatch when the necessary funds are not present. for the possibility of having gas coins of dierent denominations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Missing entry point to remove ISM entries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "routing The in contracts/isms/routing/src/contract.rs:55 to add ISM entries to the storage. However, there is no Remove entry point to delete an undesired entry. implements contract entry point Set a",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Maintainability considerations for Merkle tree",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "The Merkle package in packages/interface/src/types/merkle.rs contains several issues not posing any immediate threat, but potentially aecting future versions of the system. 1. 2. In line 11, the type of the constant ZERO_HASHES is incorrectly parameterized by constant HASH_LENGTH. The number of hashes should relate however to the Merkle tree's depth, not the hash value length. Currently, changing TREE_DEPTH results in runtime errors during Merkle tree operations. In line 8, the constant MAX_LEAVES is incorrect. The maximum number of a Merkle tree's leaves must be a power of 2. The impact is that the very last leaf slot cannot be lled. For example, if TREE_DEPTH is set to 3, the 8th value is wrongly rejected by the tree.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Misleading ContractErrors and events emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "The codebase contains some events and errors that may mislead users. Misleading errors have been found in:  The announce function in contracts/core/va/src/contract.rs:145-148 returns Unauthorized when REPLAY_PROTECITONS contains replay_id already.  ExecuteMsg::PostDispatch in contracts/hooks/merkle/src/lib.rs:94-98 returns Unauthorized when latest_dispatch_id is not the same as decoded_msd.id. in Additionally, contracts/igps/oracle/src/contract.rs:63 does not emit the \"owner\" attribute. SetRemoteGasData function the This is dierent from the SetRemoteGasDataConfigs function, which contains the same functionality, but accepts a vector instead of a single object.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Remove debugging messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "The codebase contains several debugging messages, e.g. using deps.api.debug. It is best practice to remove these debug messages before releasing the code in production.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Remove duplicated code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "in The contracts/isms/multisig/src/execute.rs:77-110 utilizes duplicated code to the denition of enroll_validators from the same le. enroll_validators function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Unused events",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "There are several events in the codebase that are currently unused:  Paused in contracts/hooks/aggregate/src/error.rs  RouteNotFound in contracts/isms/aggregate/src/error.rs  OwnershipTransferNotStarted OwnershipTransferAlreadyStarted contracts/isms/multisig/src/error.rs and in  emit_init_transfer_ownership, and contracts/isms/multisig/src/event.rs emit_revoke_transfer_ownership emit_finish_transfer_ownership in  InsufficientFunds and MessageNotFound in contracts/core/mailbox/src/error.rs",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Mailbox should explicitly block same domain dispatch messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "The dispatch function in contracts/core/mailbox/src/execute.rs:161 does not explicitly block messages where the destination domain is the same as the local domain. While this does not pose any security concerns because the dispatch messages cannot cause any harm to the contracts it may negatively impact user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "20. Usage of panics for error handling",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "There are several instances of usage of the expect and unwrap functions for error handling in the codebase. The usage of expect and unwrap is generally discouraged because they raise panics without a user-friendly error message. Panics also causes the wasm execution to abort, which does not allow handling the panic from the calling context.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "21. Lack of attached funds may cause ineciencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "contract mailbox in The contracts/core/mailbox/src/execute.rs:27-72 which the dispatch function in line 167. The returned values determine the amount of funds attached to the PostDispatch messages that are sent to hooks and relayers. get_required_value function by contains called is a If no funds have been attached to the call, line 41 returns None values which will result in messages without attached funds, even if that is a requirement. This will cause the transaction to fail at a later stage, unnecessarily wasting gas. Similarly, line 62 returns the received funds in case they are less than the required funds which will cause a failure.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "22. Storage elements are not all available through queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hyperlane/2024-02-13 Audit Report - cw-hyperlane v1.0.pdf",
        "body": "The va contract does not expose the HRP, MAILBOX, and LOCAL_DOMAIN storage state values through smart queries in contracts/core/va/src/contract.rs:75-82. This forces users and other contracts to perform a raw query to read the stored value, tying their code to the current implementation of the va contract, which is error-prone.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Password still in memory after logout",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "Unlike the mnemonic, the password (which can be used to retrieve the mnemonic) is still visible in memory after the user is logged out. For instance, the following memory dump was taken after logging out on a Windows machine: $ strings nym-wallet.DMP | grep \"AAAa1\" AAAa1234!@ The password of the user was AAAa1234+@ and this string is still in memory after logging out.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Mnemonic kept in memory after account creation within the wallet",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "To ensure that the mnemonic is not kept in memory, it is overwritten with a fresh mnemonic in the zeroize implementation (within account_data.rs). This works well and we ensured that the mnemonic cannot be retrieved from a memory dump after the user is logged out. However, this is not the case when a new account is created within the wallet (clicking on the account symbol and then selecting Create account). Then, the mnemonic is still kept in memory, even after the user is logged out. This can be seen in the following screenshot, where a memory dump on Windows was taken after the user was logged out. Previously, an account with the mnemonic frequent husband lecture orphan position surround pumpkin twin write express axis employ guard outside defense swim impulse spot hair punch load today tragic because\" was added within the app:",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Limited range of password special characters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "PasswordStrength The in nym-wallet/src/pages/auth/components/password-strength.tsx uses regex patterns to validate the strength of a password. However, the regex pattern for a \"strong\" password enforces a strict set of symbols, disallowing certain characters such as \"}\" from being used. This restriction limits the range of possible passwords and makes it easier for an attacker to successfully guess a password through brute-force methods. component React",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. User is forced to copy the mnemonic phrase to the clipboard",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "During account creation, the user is presented with the mnemonic phrase and is required to click the \"Copy mnemonic\" button, which copies the phrase to the clipboard. This practice poses a security risk as the mnemonic phrase may be accessed by other applications.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. No conrmation of mnemonic when account is added in the wallet",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "When a new account is created on the start screen using Create account, there is no conrmation ow ensure that the user backed up/noted down the mnemonic. Instead, only the password is required to continue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Mix node description requested via HTTP",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "The function get_mix_node_description (within bond.rs) requests the description of a mix node via unencrypted HTTP. While this information is only used for display purposes (limiting the impact of a MITM attack on the connection), it is still recommended to use encrypted connections for all external requests.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Known vulnerabilities in dependencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "There are known vulnerabilities in two dependencies (crate chrono and time): chrono 0.4.19 Potential segfault in `localtime_r` invocations 2020-11-10 RUSTSEC-2020-0159 https://rustsec.org/advisories/RUSTSEC-2020-0159 Crate: Version: Title: Date: ID: URL: Solution: Upgrade to >=0.4.20 Dependency tree:  vesting-contract 1.1.0  nym_wallet 1.1.1  nym-wallet-types 1.0.0   nym-types 1.0.0 chrono 0.4.19  vergen 5.1.17             nym_wallet 1.1.1  validator-client 0.1.0        nym_wallet 1.1.1  nym-wallet-types 1.0.0  nym-types 1.0.0  nym_wallet 1.1.1  nym_wallet 1.1.1  nym-wallet-types 1.0.0 time 0.1.43 Potential segfault in the time crate 2020-11-18 RUSTSEC-2020-0071 https://rustsec.org/advisories/RUSTSEC-2020-0071 Crate: Version: Title: Date: ID: URL: Solution: Upgrade to >=0.2.23 Dependency tree: time 0.1.43  chrono 0.4.19  vesting-contract 1.1.0  nym_wallet 1.1.1  nym-wallet-types 1.0.0   nym-types 1.0.0  vergen 5.1.17             nym_wallet 1.1.1  validator-client 0.1.0        nym_wallet 1.1.1  nym-wallet-types 1.0.0  nym-types 1.0.0  nym_wallet 1.1.1  nym_wallet 1.1.1  nym-wallet-types 1.0.0 Similarly, there are NPM packages with known vulnerabilities (which are shown when running yarn audit). The output of running yarn audit indicates that 63 vulnerabilities were found in the audited packages. Of these vulnerabilities, 2 are rated as moderate, 46 are rated as high, and 15 are rated as critical.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Inadequate password strength validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "React PasswordStrength in The validates nym-wallet/src/pages/auth/components/password-strength.tsx the strength of a password on a scale of \"insucient\", \"medium,\" and \"strong\". The password strength calculation is based on the length of the password and the occurrence of a set of predened characters. However, this calculation is inadequate and may classify low entropy passwords, such as abc1234! or passw0rd! as \"strong\" passwords. This could lead to a complete loss of funds if an attacker can obtain an encrypted wallet le and successfully guesses the password, for example by using common password lists. component",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Unhandled errors thrown by asynchronous functions in React hooks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "If errors thrown by asynchronous functions within React hooks are not caught and handled properly, they will be silently ignored and the React error boundary will not be triggered. The user will not be notied of the error and the application may end up in an inconsistent state. The following but incomplete list of hooks is aected: - - - nym-wallet/src/context/main.tsx:109 nym-wallet/src/context/main.tsx:147 nym-wallet/src/context/main.tsx:160",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Rewards are lost if the distribution is funded after the expiry",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-08-14 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.0.pdf",
        "body": "In contracts/distribution/dao-rewards-distributor/src/contract.rs:303, the execute_fund function restarts the distribution if it is not continuous and already expired at the current block. This is problematic because rewards accrued from the last updated timestamp active_epoch.last_updated_total_earned_puvp to the ending timestamp active_epoch.ends_at will be lost. Consequently, stakers will not receive the rewards for the staking period, causing a loss of rewards. Please see the test_lost_rewards test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Incorrect reward distribution due to inconsistent voting power queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-08-14 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.0.pdf",
        "body": "In contracts/distribution/dao-rewards-distributor/src/rewards.rs:113- 136, the get_active_total_earned_puvp function computes the reward index by dividing the accrued rewards by the total voting power queried from the previous block height (see contracts/distribution/dao-rewards-distributor/src/helpers.rs:19). This is incorrect because the user reward is computed with voting power queried from the in current contracts/distribution/dao-rewards-distributor/src/helpers.rs:33. height, block seen as Consequently, the reward index will be computed using an outdated total voting power, resulting in incorrect reward distribution. An attacker can exploit this issue by staking many tokens one block before claiming the rewards to receive more at the expense of other users. Please see the test_claim_more_rewards test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Users can inate their voting power by registering duplicate NFT token IDs",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-08-14 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.0.pdf",
        "body": "In the contracts/voting/dao-voting-onft-staked/src/contract.rs:149, execute_confirm_stake function does not validate that the supplied NFT token IDs are not duplicates. This is problematic because the register_staked_nfts function in increases contracts/voting/dao-voting-onft-staked/src/state.rs:65-77 the users voting power based on the total number of token IDs supplied, which may include duplicates. An attacker can exploit this issue by calling the execute_confirm_stake function with duplicates of a token ID, granting them a high amount of voting power without requiring them to stake the necessary NFTs. These voting powers can be weaponized to manipulate the DAO into dispatching malicious messages, such as transferring funds to the attacker.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Missing validation of submission policy during contract migration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-08-14 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.0.pdf",
        "body": "In packages/dao-pre-propose-base/src/execute.rs:670, the migrate function allows the contract migration admin to set the PreProposeSubmissionPolicy when updating the contract. However, no validation ensures the supplied policy does not accidentally lock the DAO due to an invalid conguration. We classify this issue as minor because it can only be caused by the contract migration admin, which is a privileged account.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Units of duration are not distinguished",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-08-14 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.0.pdf",
        "body": "Time durations are crucial However, the data types implemented are error-prone. to the logic of the dao-rewards-distributor contract. the example, For contracts/distribution/dao-rewards-distributor/src/helpers.rs:78 subtracts one Expiration from another. Although the end and start parameters explicitly indicate the unit duration types (i.e., blocks or seconds), this information is not preserved in the output as the function returns u64 instead of the Expiration struct. get_exp_diff function in the get_exp_diff function returns 0 if Additionally, Expiration::Never, which is mathematically incorrect. the input parameters are both Similarly, the get_duration_scalar function in line 42 removes the duration unit information and directly returns the inner value as u64, further elevating the potential for errors. Consequently, the code responsible for managing distribution schedules and timeframes becomes more challenging to interpret, particularly when it involves arithmetic operations with mixed time units. This complexity increases the likelihood of bugs in these segments.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Suboptimal storage update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-08-14 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.0.pdf",
        "body": "In the packages/dao-pre-propose-base/src/execute.rs:199, execute_update_config function validates the submission_policy parameter in line 213 and updates it in the Config state. this is inecient because the Config state is retrieved in line 211 before However, validating the submission policy. If the submission policy does not pass the validation, the loaded storage value (indicated as the prev variable) remains unused.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Duplicate distribution congurations can be created",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-08-14 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.0.pdf",
        "body": "In contracts/distribution/dao-rewards-distributor/src/contract.rs:129, the execute_create function allows the contract owner to create a distribution. However, other distributions may already exist with the same conguration, causing duplicate distributions to be created.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Suboptimal usage of optional vectors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-08-14 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.0.pdf",
        "body": "The Option<Vec<...>> type is prevalent across the codebase. Although it is useful to distinguish between an empty and an absent list in certain scenarios, this distinction is currently not used in the codebase, which is inecient and increases code complexity. in example, packages/dao-voting/src/pre_propose.rs:72-84, For the PreProposeSubmissionPolicy enum declares the denylist and allowlist elds to Option<Vec<String>>. The lists are parsed with unwrap_or_default, which converts conguration in empty updating the submission policy to None before lists packages/dao-pre-propose-base/src/execute.rs:291 and 365. This indicates there is no meaningful distinction between None and an empty vector. Hence, we conclude that Option<Vec<...>> serves more as an optimization than a necessity. Given that modern Rust minimizes the memory footprint of empty vectors, the complexity added by Option<Vec<...>> pattern outweighs its benets. Consequently, the code complexity is increased due to additional checks and unwrapping without a signicant memory eciency gain.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Storage collection considerations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-08-14 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.0.pdf",
        "body": "the contracts/voting/dao-voting-onft-staked/src/state.rs:33, In STAKED_NFTS_PER_OWNER state is dened as Map<(&Addr, &str), Empty>. This mapping type is optimal for scenarios when tokens are added incrementally, so the storage updates only mutate the aected entries without needing to read and write other unaected tokens. However, STAKED_NFTS_PER_OWNER can also be used in batch updates in lines 72-75 or 101-110. This scenario is problematic in the current implementation because it requires querying and mutating multiple storage entries one by one, increasing the gas consumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Code deduplication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-08-14 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.0.pdf",
        "body": "code in The packages/dao-pre-propose-base/src/execute.rs:262-283, and 330-351 are identical. These segments implement modifying permission lists with iteration, deduplication, and address validation, which can be abstracted as reusable components to increase code maintainability. 307-328, segments",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Unnecessary code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-08-14 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.0.pdf",
        "body": "contracts/voting/dao-voting-onft-staked/src/contract.rs:178-180, In the execute_confirm_stake function removes the PREPARED_ONFTS state based on the supplied token IDs. This is unnecessary because the register_staked_nfts function in already contracts/voting/dao-voting-onft-staked/src/state.rs:73. removes them",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Lack of accounting for slashing could lead to a bank run, resulting in loss of funds for slow depositors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "to for The due logic example slashing. The codebase does not handle any reduction in a pools total value locked, which could happen the TransferWithdrawalToLocalChain function is implemented with the assumption that the amount returned by the unbonding callback will be equal to the amount specied at the beginning of the unbonding request. In the event that slashing occurs, the module will have a lower than expected balance which will cause later withdrawal requests to fail. This will create a situation where early withdrawals can be fully lled while later withdrawals will fail once the module's balance drops below the requested withdrawal amount. These withdrawals will fail until the module's balance is re-capitalized. The missing amount would need to be fully refunded to the modules balance for all users to be able to successfully withdraw their initial amounts. in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Updating the validator set of a pool does not trigger a redelegation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "If the proposal passes, The parameters of a pool can be updated through an update-pool proposal, including any changes to the validator set. the pool will be updated in x/millions/keeper/keeper_pool.go through the UpdatePool function. However, a change in the validator set does not trigger a redelegation to the new set of validators, instead only the ag isEnabled is updated. Any new deposits will be delegated to the new set of validators but for existing delegations to be updated, depositors need to withdraw, wait for the three-week unbonding period and redeposit.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Delegated funds cannot be redelegated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The codebase does not send redelegate packets, thus the function RedelegateCallback In the situation in x/millions/keeper/callbacks_redelegate.go is never used. where delegations need to ow from one validator to another (e.g. if a validator stops validating blocks) after the validator set got updated through the update-pool proposal, every depositor would need to manually withdraw, wait for the three-week unbonding period, and redeposit. This will require coordination, manual actions by users and impact the overall staking returns, as some depositors may not follow those steps and others have to wait for the unbonding period.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. DrawRetry will always fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The function DrawRetry in x/millions/keeper/msg_server_draw.go:13 does not behave correctly, and as a result, the draw will never be able to be re-executed. The and ClaimRewardsOnNativeChain, ExecuteDraw functions are all incorrectly called with the parameter draw.PoolId instead of the DrawID. This will cause the TransferRewardsToLocalChain and ExecuteDraw functions to fail due to an erroneous draw state. The ClaimRewardsOnNativeChain function will be executed successfully, claiming pool rewards but returning a wrong draw, unless draw.DrawId is equal to draw.PoolId. This means that any draw that fails its initial execution, will be stuck in an erroneous state. TransferRewardsToLocalChain,",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. MinDepositAmount is not strictly enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The function SetParams in x/millions/types/params.go:21 does not explicitly validate that the value of MinDepositAmount is not zero. Although a proposal to update the parameters would prevent a minimum deposit amount of zero, as it is caught in the update_params messages ValidateBasic function, MinDepositAmount could be set to 0 during genesis without causing an error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. The chain could be spammed with deposits of negligible amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The function SetParams in x/millions/types/params.go:36 does not enforce a reasonable minimum acceptable amount for MinDepositAmount. Thus, the parameter can theoretically be set close to zero, allowing for spam deposits with negligible amounts. The LaunchNewDraw function is triggered by the BeginBlocker function and iterates over an unbounded loop of deposits. The ability to add a high amount of negligible deposits can allow an attacker to slow down or even halt block production. The minimum deposit needs to be reasonably high to provide enough nancial disincentive against such an attack. We classify this issue as minor since governance controls this value.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. An updated InitialDrawAt cannot be enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The ShouldDraw function in x/millions/types/draw_schedule.go returns true if a draw should be executed. For the rst draw, it will only return true if it is passed the InitialDrawAt parameter of DrawSchedule. However, if the draw schedule is updated through a proposal and a new InitialDrawAt is set to a time in the future, this will not be enforced since the condition in line 46 will not be met. Thus, draws will continue to be drawn every DrawDelta, even if InitialDrawAt has not been met.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Missing validation checks in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "There are missing or insucient validation checks in the codebase:  The PrizeBatch validation in x/millions/types/prize_batch.go:19 allows for a DrawProbability of 0. A prize strategy that has 0 draw probability for all batches would make it impossible for the pool to have a winner.  The FeesStakers parameter is not validated in x/millions/types/proposal_update_params.go.  The DrawSchedule validation in x/millions/types/draw_schedule.go:10 does not check if DrawDelta is less than the MaxDrawScheduleDelta. Use the ValidateNew function for validation of DrawSchedule instead.  The PoolId, DepositId, and ToAddress are not properly validated in in MsgWithdrawDeposit x/millions/types/message_withdraw_deposit.go:36.  In the in MsgDeposit's x/millions/types/message_deposit.go:49, the msg.Amount is being checked to ensure the amount deposited is not negative, but it does not check if the amount is 0. ValidateBasic function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Inactive validators may receive delegations, reducing protocol yield",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "DelegateDepositOnNativeChain The in x/millions/keeper/keeper_deposit.go:111 delegates deposits to the native chain of the pool. However, it is possible for a validator to have already stopped validating and unbonded at the time the latest pool validator set has been proposed and approved. This would allow delegations of pool deposits to inactive validators that will not produce any yield. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. PrizeExpirationDelta parameter can be set to a value that prevents prize claims",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The function ValidateBasics in x/millions/types/params.go:36 would allow for a PrizeExperiationDelta as short as a second. Very short periods would prevent winners from claiming their prizes. We classify this issue as minor since it can only be caused by governance.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. FeesStakers parameter can be set unreasonably high",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The function ValidateBasics in x/millions/types/params.go:36 does not prevent an unreasonably high value for the FeesStakers parameter. Although this parameter is controlled by governance, it is possible to be set close to 1, which would mean that all draw proceedings will be taken as fees, causing depositors to receive only a minimal amount of rewards.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Redundant checks are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The codebase contains redundant checks that lead to ineciencies:  The last draw state check in x/millions/keeper/keeper_draw.go:51 is a through duplicate it x/millions/keeper/keeper_blockers.go:375, ListPoolsToDraw. validation invoked already as is  The ValidateDenom function in x/millions/types/pool.go checks the length of the denomination inside the function. The validation checks in lines 20 and 26 can be removed.  The validation to check if the sender has sucient balance in is  The x/millions/keeper/msg_server_deposit.go:60-62 is duplicate as it already checked in the SendCoins function called in line 79. sanitizedDenom in x/millions/keeper/msg_server_deposit.go:34 can be removed if a stateless check is performed in the message ValidateBasic function in x/millions/types/message_deposit.go:37. function  A length of validators check in x/millions/keeper/keeper_pool.go:251 is in duplicate x/millions/types/proposal_update_pool.go:49. checked already being as is it  The in x/millions/types/message_deposit.go:53 can be removed as it is being checked already through the AccAddressFromBech32 function in line 55. strings.TrimSpace call  All the transaction commands in x/million/client/cli/tx.go:25-30 call msg.ValidateBasic. This is unnecessary, since the function is already invoked in the GenerateOrBroadcastTxWithFactory function.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Outstanding TODO comments in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "There are multiple TODOs in the codebase that may refer to important logic. Instances are:  x/millions/keeper/keeper_draw.go:199  x/millions/keeper/keeper_pool.go:85",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Inaccurate messages may confuse or mislead users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "Across the codebase, instances of inaccurate messages have been found, that could confuse or mislead users.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Missing usage description for all transaction and query CLI commands",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "the and transaction in All and x/million/client/cli/tx.go:25-30 x/million/client/cli/query.go:37-59 are missing a long message that describes their usage, which would be helpful for users and external developers. the Millions module query CLI commands for",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Code ineciencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "There are several parts of the codebase that can be optimized to perform stateful and stateless checks, reduce computational resources and gas consumption:  Trim whitespace to catch more cases of invalid values instead of just empty strings for the parameters ChainId, Bech32PrefixAccAddr, and Bech32PrefixValAddr in x/millions/types/pool.go:13, ValidateBasic.  In x/millions/types/message_deposit.go:44-51, using msg.Amount.Validate can replace the implemented functions.  In x/millions/types/proposal_register_pool.go:59-64, validation checks with strings.TrimSpace can be replaced with the ValidateDenom function from Cosmos SDKs types package.  The ComputeSplitDelegations in x/millions/keeper/keeper_deposit.go:130-133 and 158-161 can be combined. function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Code quality could be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "Across the codebase instances of unused or commented code have been found.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Unused pool states",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "the pool states PoolState_Paused and PoolState_Killed are unused. Currently, Additionally, in x/millions/keeper/msg_server_deposit.go:15 allows for deposits to be made to a paused pool. If a paused pool state was implemented in the future without updating this function it could be problematic. Deposit function the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Additional rewards are ignored",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "the OnClaimRewardsOnNativeChainCompleted ignores additional coins Currently, returned in the ICA claim rewards callback if they do not match the module account. With interchain security, it is becoming more common to expect chains to return more than one type of reward coin. Overall this would also increase the rewards users receive. there in Additionally, x/millions/keeper/keeper_draw.go:193 that iterates over every coin received. While the likelihood of receiving a large amount of additional coins from a trusted chain is low this edge case should still be handled. unbounded iteration an is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Limitations on base two logarithm implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/helper.rs:2-25, the log2_u64_with_decimal function implements a custom version of a base two logarithm. However, there are issues with its current implementation:  The function returns 0 for the base 0 logarithm, which is incorrect because the result run reproduce undened please value. this, be To should an log2_u64_with_decimal(0).  The function does not correctly handle all values of u64. An overow error will trigger during multiplication if a large value is provided. To reproduce this error, please run log2_u64_with_decimal(7259549383510990226).",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Coecient calc implementation diers from documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "calc_coefficient The in packages/eris/src/helpers/slope.rs:6-10 is documented with the following line: Coefficient to 1 and [`MAX_LOCK_TIME`] is 9. However, the actual implementation does not adhere to this comment as when the interval is zero weeks, the returned value will be zero instead of one. calculation [`WEEK`] function where equal found is This issue has been raised as informational as every instance that calls the aected function checks the supplied interval to not be zero before or cant be zero given the contracs logic.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "3. Multiple rounding issues may cause zero rewards being distributed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf",
        "body": "functions of Several the locking contract are aected by rounding issues since their mathematical operations use U128 integers for divisions where the numerator is smaller than the denominator. This causes the result to be truncated to zero instead of the desired ratio before it is multiplied, causing the whole operation to be zero. Therefore, reward distribution will result in a zero tokens distribution. In particular in the The aected operations can be found on rewards related features. calculate_bribe_reward, and calculate_surplus_reward functions. The aected instances can be found at and locking:src/contract.rs:770, locking:src/query.rs:322. calculate_rebase_reward 888, 870, 904, 919,",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "16. Limitations on base two logarithm implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/helper.rs:2-25, the log2_u64_with_decimal function implements a custom version of a base two logarithm. However, there are issues with its current implementation:  The function returns 0 for the base 0 logarithm, which is incorrect because the result run reproduce please value. this, be To should an log2_u64_with_decimal(0). undened  The function does not correctly handle all values of u64. An overow error will trigger during multiplication if a large value is provided. To reproduce this error, please run log2_u64_with_decimal(7259549383510990226).",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Limitations on base two logarithm implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraHacks/2024-03-04 Audit Report - DoraHacks Quadratic Grant Injective v1.0.pdf",
        "body": "In src/helper.rs:2-25, the log2_u64_with_decimal function implements a custom version of a base two logarithm. However, there are issues with its current implementation:  The function returns 0 for the base 0 logarithm, which is incorrect because the result run reproduce undened please value. this, To should an log2_u64_with_decimal(0). be  The function does not correctly handle all values of u64. An overow error will trigger during multiplication if a large value is provided. To reproduce this error, please run log2_u64_with_decimal(7259549383510990226).",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Tight coupling of the Mint and Burn MsgServer and Keeper functions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2024-01-17 Audit Report - Noble tokenfactory Changes and fiattokenfactory v1.0.pdf",
        "body": "and Burn Mint The and in keeper/msg_server_burn.go in both the tokenfactory and fiattokenfactory modules were refactored by extracting the logic from the MsgServer functions to separate Keeper functions to expose them to other Cosmos SDK modules within the same chain. keeper/msg_server_mint.go functions The original MsgServer function signatures have been reused. Specically, the MsgMint and MsgBurn message types are used as parameters. Moreover, the keeper functions return the same response types as the MsgServer functions. it is considered best practice to keep the MsgServer and Keeper functions However, decoupled by using explicit function parameters and appropriate return types. This allows for more exibility in the future, for example, if the MsgMint message or MsgMintResponse return type needs to be refactored.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Slippage is not correctly applied during liquidity balancing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "In contracts/osmosis-cl-vault-fixed-width/sc/helpers/mod.rs:377-383, a swap message is created to balance the inventory held by the vault post-subscription or -redemption. This message ensures that the token_out_min_amount is not lower than an the variable token_out_amount is estimate plus the specied slippage. However, calculated using an estimate of the swap to which slippage is subsequently applied. As the output estimate already includes any price impact the further application of slippage is not eective.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. The contracts position can arbitrarily be set to zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "The execute_compound function passes the argument disregard_funds to the in BalanceLiquidity contracts/osmosis-cl-vault-fixed-width/src/execute/compound.rs:52 and 61. CreatePosition messages and If the argument disregard_funds is identical to the contracts current position in the concentrated liquidity pool, an empty position will be created as CreatePosition will ignore the provided funds when eectively creating the new position after having withdrawn the position in full due to the MsgWithdrawPosition message added in line 73. The previous deposits will sit as a balance in the contract until a new Compound message is processed not ignoring the aected funds. In addition to preventing any incentives and rewards from being generated in the meantime, this action could move the market signicantly if the action is successful. As the Compound entry point is permissionless an attacker could combine this as part of a larger attack aimed to aect the price of the pool.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Reply handler errors may block deposits and redemptions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "The deposit and redeem functions of the contract rst dispatch a compound sub-message functionality. The execute_compound function in before proceeding with their contracts/osmosis-cl-vault-fixed-width/src/execute/compound.rs:18 dispatches MsgCollectIncentives and MsgCollectSpreadRewards sub-messages to the Osmosis concentrated-liquidity module. The Osmosis module then collects incentives and spread rewards for the contract address and returns the coins that the reply handler of the contract passes to the send_fees_to_treasury function. in the reply issue exists handler in The contracts/osmosis-cl-vault-fixed-width/src/reply.rs:163 and 169. The reply handlers do not account for the situation where the Osmosis responses return no coins the to send_fees_to_treasury function attempts to send an empty vector of coins. This would create a situation where deposits or redemptions could be blocked if there are no incentives or spread rewards to be collected. handlers would error when collected. contract case, reply this the the be of In An example scenario would be if there are some deposits or withdrawals within a single block. The rst operation would successfully claim the spread rewards and incentives, but then subsequent calls would error because the amount of rewards and incentives would be returned as None.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Inability to rebalance would prevent all deposits and redemptions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "of execution in During contracts/osmosis-cl-vault-fixed-width/src/helpers/mod.rs:225-398, a binary search is used to calculate how many tokens should be swapped to keep the target thrown in search cannot be completed, inventory contracts/osmosis-cl-vault-fixed-width/src/helpers/mod.rs369-373. rebalance an error operation ratio. the is a If This could occur frequently in a particularly illiquid market with an imbalanced vault and would prevent both deposits and redemptions from taking place and locking users' funds. We classify this issue as minor as the scenario in which this occurs is unlikely.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Depositor funds may remain unused",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "The share of the pool that a user receives during the deposit of funds into the vault is calculated using the delta in liquidity provided. However, during the creation of the new in position contracts/osmosis-cl-vault-fixed-width/src/execute/compound.rs:159 -171 it is possible that not all deposited funds are added. Under certain market conditions, the dierence in the amount of liquidity supplied and added to the position could be non-negligible resulting in the depositor receiving a smaller proportion of share funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Lack of conguration validations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "the The osmosis-cl-vault-fixed-width contract performs validation of its conguration through in ConfigUnchecked::check contracts/osmosis-cl-vault-fixed-width/src/state.rs:149-244. However, some elds lack validation which would prevent some features from being rendered unusable if an incorrect value is assigned by mistake. function  If discount_factor remains unvalidated, to a value such as Decimal::one() which would cause the vault to sell staked assets far below the market value. Therefore the allowed range should be limited, for example to be between 0 and 25%. it could be set  If the range_width in contracts/osmosis-cl-vault-fixed-width/src/helpers/mod.rs:169, resulting in an arbitrarily large lower_tick. overow exceeds occur one, will an  If balancing_tolerance is set to zero, it could make balancing unreachable within the iterations due to dust rounding.  If redemption_rate_age_tolerance in contracts/osmosis-cl-vault-fixed-width/src/helpers/mod.rs:162 would always error. On the other hand, an excessively large value would allow old rates to be taken as valid. check zero, the set to is  If redemption_fee to contracts/osmosis-cl-vault-fixed-width/src/reply.rs:125 result in a transfer of zero value, causing the whole transaction to revert. ban message one, the set is crafter in will  If deposit_fee one, contracts/osmosis-cl-vault-fixed-width/src/execute/basic_vaul t.rs:55 results in no remaining balance being available for AddLiquidity which will make MsgAddToPosition fail and the transaction revert. set to is  If incentive_denoms contains duplicate assets, the BasketLiquidate message in of execute_compound contracts/osmosis-cl-vault-fixed-width/src/execute/compound.r s:108 will fail, reverting the whole transaction.  If incentive_denoms has a large enough number of assets, the for loop in contracts/osmosis-cl-vault-fixed-width/src/execute/compound.r s:91 may run out of gas, preventing compounding.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Cong update is lacking incentive denom validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "execute_update_config in The contracts/osmosis-cl-vault-fixed-width/src/execute/basic_vault.rs: 120-139 allows the admin to modify the congurations incentive_denoms vector. However, as it relies on ConfigUnchecked::check for validating the contents of the vector, the incentive_denoms vectors. This results in redundant operations as it will rst swap one of the pool tokens for the other and then the BalanceLiquidity message will swap them again for the correct amounts. tokens token0 and token1 would be allowed to be part of the pool function Please note that this is not the case upon instantiation, as additional validation to cover this in scenario contracts/osmosis-cl-vault-fixed-width/src/contract.rs:50-58. included is",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "The following packages and contracts do not enable overow-checks for the release prole:  contracts/osmosis-cl-vault-fixed-width/Cargo.toml  Cargo.toml",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Remove unnecessary and unused code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "The osmosis-cl-vault-fixed-width contract contains several pieces of unnecessary or unused code. Although not a security issue, this decreases readability and maintainability while slightly increasing gas costs in some scenarios.  In contracts/osmosis-cl-vault-fixed-width/src/execute/compound.r s:130 the CONFIG is loaded, but never used.  In contracts/osmosis-cl-vault-fixed-width/src/reply.rs:146 the balances of the pool assets are queried and assigned to _pool_balances but never used.  The PREVIOUS_LIQUIDITY in contracts/osmosis-cl-vault-fixed-width/src/state.rs:37 is never used. constant storage  The FORCE_WITHDRAW_WHITELIST in contracts/osmosis-cl-vault-fixed-width/src/state.rs:33 is only used in queries but information is never saved using it. constant storage  In contracts/osmosis-cl-vault-fixed-width/src/state.rs:208 and 216 Decimal values are validated to not be below zero. These conditions will never be met as the type only allows unsigned values.  The get_pool_asset_balances in contracts/osmosis-cl-vault-fixed-width/src/helpers/mod.rs:120 -131 is never used. function  In  When contracts/osmosis-cl-vault-fixed-width/src/execute/contract.r s:51 a duplicate pool query is performed. performing in contracts/osmosis-cl-vault-fixed-width/src/helpers/mod.rs:318 the pool is queried on each iteration. However, the value could be retrieved prior to the loop saving computational resources. search binary the  The balance_liquidity function calculates tokens_after_swap and includes in it contracts/osmosis-cl-vault-fixed-width/src/helpers/mod.rs:386 -395. However, this information is never checked by the callee in a later reply handler, making it unused. return value as a  During the contract instantiation, the get_cl_pool_with_id query is called twice with in same contracts/osmosis-cl-vault-fixed-width/src/contract.rs:38 and 51. pool_id the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Error message can be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "ConfigError in The currently contracts/osmosis-cl-vault-fixed-width/src/contract.rs:42 does not provide an informative error message to users. It is best practice to provide meaningful errors where possible. In this case, the minimum funds that must be sent are not communicated. message",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Unimplemented queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "the queries Many of are unimplemented. Users wil hencel be unable to access vital information about the contracts state. The following queries are currently unimplemented: in the osmosis-cl-vault-fixed-width contract  PreviewDeposit  PreviewRedeem  TotalAssets  ConvertToShares  ConvertToAssets",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Ineective sub-message error handling",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2024-09-04 Audit Report - Apollo Osmosis Fixed Width Range Vault v1.0.pdf",
        "body": "Sub-messages dispatched by the contract are all sent with the ReplyOn::Always directive. This option is useful when the contract specically handles the return reply with a specic operation as is done for the InternalMsgCompound reply handler. In the reply handler in other contracts/osmosis-cl-vault-fixed-width/src/reply.rs:183 sub-message errors will simply be caught in the last condition. This is potentially error-prone and unnecessary as the sub-message errors will be eectively handled without the reply handling. Specically, the following messages do not need to be dispatched with the ReplyOn::Always directive: all  MsgCollectIncentives in contracts/osmosis-cl-vault-fixed-width/src/execute/compound.r s:64  MsgCollectSpreadRewards in contracts/osmosis-cl-vault-fixed-width/src/execute/compound.r s:68  MsgCreatePosition in contracts/osmosis-cl-vault-fixed-width/src/execute/compound.r s:182  MsgAddToPosition in contracts/osmosis-cl-vault-fixed-width/src/execute/compound.r s:233  MsgWithdrawPosition in contracts/osmosis-cl-vault-fixed-width/src/execute/compound.r s:263",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attackers can trigger a share ination attack to steal user funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-09-13 Audit Report - IxoSwap v1.1.pdf",
        "body": "In ixo-swap/src/contract.rs:265, the get_lp_token_amount_to_mint function mints the LP token amount based on the sent amount if the total supply is zero. This is problematic because attackers can execute a share ination attack to steal funds provided by the user, resulting in a loss of funds scenario. An attack scenario is illustrated below: 1. The contract is newly instantiated",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. The attacker redeems their LP tokens for the underlying liquidity, which includes the users funds. Consequently, the funds provided by the user are stolen by the attacker. Since the LP tokens total supply reverts back to zero after exploitation, the attacker can repeatedly execute this attack to steal funds from subsequent users who provide liquidity to the pool. Please refer reproduce this issue. to the test_share_inflation_attack test case in the appendix to Recommendation We recommend burning a small number of dead shares to the pool contract when providing initial liquidity. Status: Resolved 2. Attackers can swap lower-value tokens for valuable assets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-09-13 Audit Report - IxoSwap v1.1.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-09-13 Audit Report - IxoSwap v1.1.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Lack of attributes emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-09-13 Audit Report - IxoSwap v1.1.pdf",
        "body": "In several instances of the codebase, the emitted attributes do not include information about the entry points and values in ixo-swap/src/contract.rs:  The execute_add_liquidity, execute_remove_liquidity, and execute_swap, execute_update_config functions does not emit the action attribute to be the called function. Consider adding the attribute in the response eld, similar to line 241.  The execute_freeze_deposits function should include the freeze value in line execute_pass_through_swap, 241.  The execute_swap function should include the recipient address in line 1117.  The reply entry point should include the LP token address in line 1400. It is best practice to emit events and attributes to improve the usability of the contracts and to support o-chain event listeners and blockchain indexers.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. execute_freeze_deposits can be called with the same status",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-09-13 Audit Report - IxoSwap v1.1.pdf",
        "body": "In ixo-swap/src/contract.rs:227, the execute_freeze_deposits function does not validate that the freeze status is not equal to the FROZEN state status. For example, if the FROZEN state is true, calling the function with freeze value as true will not trigger any actual changes to the contract as the results are the same. Consequently, this may mislead o-chain listeners and indexers since no actual changes are made to the contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. FROZEN storage state is not exposed through smart queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-09-13 Audit Report - IxoSwap v1.1.pdf",
        "body": "the query entry point does not expose the In ixo-swap/src/contract.rs:1281, FROZEN storage state value through smart queries. This forces third-party contracts to perform a raw query to read the stored value, which is error-prone and decreases user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Unused error message in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-09-13 Audit Report - IxoSwap v1.1.pdf",
        "body": "In ixo-swap/src/error.rs:13, the NoneError is dened but not implemented across the codebase. Unused code reduces the code readability and maintainability in the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Panic usage should be avoided",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-09-13 Audit Report - IxoSwap v1.1.pdf",
        "body": "ixo-swap/src/token_amount.rs:20 In and get_single functions panic with a plain error message if the provided TokenAmount is incorrect. This decreases user experience as users will not be able to interpret the actual error that occurred. get_multiple and 29, the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Outstanding TODO comment in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-09-13 Audit Report - IxoSwap v1.1.pdf",
        "body": "In ixo-swap/src/contract.rs:1323, the query_info function contains a TODO comment to retrieve the total supply. However, the query for the LP tokens total supply has already been implemented in line 1329.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. In-house implementation of well-known features is discouraged",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/ixo/2024-09-13 Audit Report - IxoSwap v1.1.pdf",
        "body": "In ixo-swap/src/contract.rs:493-505, the validate_input_amount function validates the user sent the actual funds as specied based on the given_amount and given_denom parameters. Although no vulnerability was found aecting the function, well-known libraries that are continuously reviewed by the community. it is still best practice to use",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. The new owner account claims ownership, which applies the conguration changes. Status: Acknowledged 13. Miscellaneous comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Volta/2024-09-18 Audit Report - Volta CosmWasm v1.0.pdf",
        "body": "Miscellaneous recommendations can be found below.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Block production halts if the mempool size exceeds 100MB",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Slide SDK/2024-09-20 Audit Report - Slide SDK v1.1.pdf",
        "body": "the CreateProposalBlock method of In the BlockExecutor, dened in vm/types/state/executor.go:99-149, transactions from the mempool are processed by the PrepareProposal method and subsequently validated by the Validate function to ensure their combined size is smaller than MaxBlockSizeBytes, set at 100MB. This security check is intended to prevent the constructed transaction list from exceeding this size, as it should have been enforced by the PrepareProposal. However, due to the Incorrect cast from into64 to uint64 makes the txSelector unable to prune transactions in the PrepareProposal and Unlimited transaction retrieval from mempool can lead to DoS issues, this maximum size is not enforced and the proposed block contains all the transactions in the mempool. Consequently, attackers can exploit this vulnerability by sending more than 100MB of transactions to the mempool, causing the Validate function to return an error. This error is propagated to the BuildBlock method which returns an error to AvalancheGo leading to the impossibility for the VM to create new blocks.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Casting uint to int can lead the VM to panic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Slide SDK/2024-09-20 Audit Report - Slide SDK v1.1.pdf",
        "body": "the GenesisChunked RPC method, the In vm/rpc.go:329, during the execution of chunk argument is dened as uint and it is then cast to an int, which can result in a negative number due to overow if the chunk value is large. this causes the subsequent conditional statement to evaluate to false, Consequently, resulting in ResultGenesisChunk being returned with a negative ChunkNumber which is then used to access the rpc.vm.genChunks array. Since array indices must be non-negative, attempting to access the array with a negative index causes a panic, halting the block production of the VM. Attackers can leverage this behavior by sending arbitrary chunk values to the RPC endpoint to stop the VM.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Incorrect cast from int64 to uint64 makes the txSelector unable to prune transactions in the PrepareProposal",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Slide SDK/2024-09-20 Audit Report - Slide SDK v1.1.pdf",
        "body": "In vm/types/state/executor.go:121, the CreateProposalBlock method of the BlockExecutor sets maxDataBytes to -1, which is invalid as it must be a positive value since only maxBytes can accept a negative value. This results in constructing the RequestPrepareProposal struct with MaxTxBytes set to -1. Then the PrepareProposalHandler of the Cosmos SDK baseapp is executed, MaxTxBytes, which is represented as int64, is cast to uint64 and then passed to the SelectTxForProposal method of the txSelector to prune transactions exceeding the maximum bytes and gas limits. However, 18446744073709551615 bytes, which is approximately 18446744TB. casting -1 from int64 to uint64 results in MaxTxBytes being Consequently, an exceedingly large transaction limit could lead to processing an enormous transaction list, allowing attackers to perform denial-of-service (DoS) attacks by spamming a large number of transactions.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Unlimited transaction retrieval from mempool can lead to DoS",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Slide SDK/2024-09-20 Audit Report - Slide SDK v1.1.pdf",
        "body": "In vm/types/state/executor.go:99 the CreateProposalBlock method of BlockExecutor ReapMaxBytesMaxGas function, passing -1 for both maxBytes and maxGas parameters. from the mempool transactions retrieves invoking by the the However, this eectively instructs the CListMempool implementation to ignore any size and gas limits when fetching transactions, resulting in all transactions in the mempool being handled in a single batch. This behavior can cause denial-of-service (DoS) attacks and timeouts, as the node may become overloaded by attempting to process all transactions in the mempool within a single block.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Overly permissive gRPC default options",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Slide SDK/2024-09-20 Audit Report - Slide SDK v1.1.pdf",
        "body": "The Serve function, dened In landslidevm.go:73-160, is responsible for starting the gRPC server and it accepts various grpc.ServerOption arguments. When not specied, landslidevm.go:51-65. these arguments default to DefaultServerOptions, dened in However, this default conguration is excessively permissive and could lead to potential denial-of-service (DoS) attacks. Specically, setting MaxRecvMsgSize to math.MaxInt changes the default maximum receive message size from 4MB to 9223372TB. Similarly, MaxConcurrentStreams is set to math.MaxUint32, allowing an excessively large number of concurrent streams. We are reporting this issue with minor severity since the aforementioned server is expected to be only exposed locally to interact with the AvalancheGo node.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Incorrect boolean value assigned to allowShutdown during VM initialization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Slide SDK/2024-09-20 Audit Report - Slide SDK v1.1.pdf",
        "body": "When initializing the VM, the New function is called, which subsequently invokes the NewViaDB function to congure some VM state parameters. One of these parameters is allowShutdown, which stores information about whether a node is ready to shut down via the Shutdown operation. However, the default assigned value is True, while the logic does not allow the parameter value to be changed to False anywhere in the code. Consequently, when in landslidevm.go:110 via the CanShutdown function will always return True, which will result in incorrect execution of the syscall management logic. performed operation, Serve calling check the the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Faulty header validation in the attestation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Node Library.pdf",
        "body": "node/src/chain/header_validation.rs:409, In verify_block_att identies all committee members as voters by merging them without validating that they voted. the This might lead to faulty validation of the block header, i.e. in labeling a non-valid candidate header as valid, which is considered a critical error.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Faults are not written into a block",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Node Library.pdf",
        "body": "In consensus/src/proposal/block_generator.rs:140, saved into the new block. the vector faults is However, the vector is empty because it is only initialized on line 114 with expression Vec::<Fault>::new(). The header of this block doesnt contain any information about the faults as well, because the merkle root is derived from the empty vector.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. MAX_PENDING_SENDERS ag gets ignored",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Node Library.pdf",
        "body": "In node/src/network.rs:43-51 the reroute function ignores if there are too many messages to be rerouted. the pending_senders counter is reset to zero and a warning message is logged. However no the MAX_PENDING_SENDERS ag is exceeded, If other actions such as limiting the messages are performed and logic for intervention for operators is provided. This could lead to an excessive rerouting of messages and potentially an overload of the operating or other nodes.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Transaction lters are unimplemented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Node Library.pdf",
        "body": "In node/src/mempool.rs:51-59 the TxFilter is unimplemented. As a consequence is it not checked if a transaction is a duplicate, nullied, or exists in the issue in production, unimplemented features are mempool. While this can be a critical reported as major.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Hardcoded genesis date can lead to a stuck network",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Node Library.pdf",
        "body": "At node startup, as dened in node/src/chain.rs:276, the genesis block is generated if the current chain tip is not yet initialized in local storage. However, the genesis date is hardcoded to March 25, 2024 as can be seen in node/src/chain/genesis.rs:14. Not only a network based on this particular commit is dicult to be launched, but also this approach in general poses challenges if the network launch fails and needs rescheduling. Genesis date modication requires source code modication, followed by recompilation and distribution of the binary to the node environment. Providing the genesis date via a genesis cong could streamline this process. rst block, candidate More importantly, the genesis date is not validated against the local clock. The timestamp for the is determined by fall consensus/src/proposal/block_generator.rs:122. This timestamp must within a specic time range, relative to clocks of other provisioners in the network. Delay in block production is a slashable event, so a block timestamp must not be too far in the past. Delayed blocks are rejected in node/src/chain/header_validation.rs:105. This the genesis block, atop built means that the next block after the genesis cannot be built without violating the protocol rules. At the same time, setting the timestamp of the genesis block too far into the future is also see block's problematic, node/src/chain/header_validation.rs:115. acceptance prevents nodes, other the by as it",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Mempool can grow arbitrarily large",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Node Library.pdf",
        "body": "In node/src/mempool.rs, the function accept_tx does not perform any checks on the number of transactions that are already in the mempool. An attacker could abuse this by spamming a lot of low-value transactions and overwhelm nodes with these transactions, which can ultimately lead to a Denial of Service for particular nodes or the whole network.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Missing entitlement causes deposit transactions to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2024-09-20 - Celer Flow Contracts.pdf",
        "body": "In transactions/safebox_deposit.cdc:13, the from argument is not implemented as an authorized reference with the FungibleToken.Withdraw entitlement. This is required as the deposit function in cadence/contracts/SafeBox.cdc:134 requires as the auth(FungibleToken.Withdraw)&{FungibleToken.Provider}. reference type Consequently, the transaction will fail to execute.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Missing receiver capability validation leads to locked funds at Flow chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2024-09-20 - Celer Flow Contracts.pdf",
        "body": "A FungibleToken.Receiver capability named receiverCap is retrieved from a congured token public path in contracts/SafeBox.cdc:186 for the receiver address. This oversight may However, no validation ensures the fetched capability supports the intended receiving token in type. contracts/DelayedTransfer.cdc:101 if the receiver capability reference (indicated as recRef) does not align with the receiving token vault type. cause the executeDelayXfer function to fail Consequently, users may be unable to withdraw funds from Flow chain despite the corresponding burn transaction already executed on the counterparty chain. We classify this issue as minor because the likelihood of encountering an invalid receiving capability at the specied public path is low. Potential causes include users holding a dierent token at the same path or interacting with malicious dApps that manipulate user capability paths. A recovery plan could be initiated in which users must manually replace the incorrect capability with the correct capability in the congured path and re-execute the this leads to operational overhead and executeDelayXfer function. Nevertheless, decreased user experience.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Verifying signatures may fail due to the execution limit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2024-09-20 - Celer Flow Contracts.pdf",
        "body": "In contracts/cBridge.cdc:57, the verify function accepts a variable-length array of signatures in the sigs argument. The function logic implements an inner loop inside an outer loop to nd the matched signature, as seen in lines 61-87. This may cause the execution eort of such logic to reach the execution limit on Flow chain, causing the verify function to fail if there are many signatures.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Inconsistent return types cause obstacles in writing generic transactions and scripts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2024-09-20 - Celer Flow Contracts.pdf",
        "body": "Throughout the implementation of the fungible token contracts, the following functions do not return the @{FungibleToken.Vault} type value:  withdraw  contracts/ceAVAX.cdc:105  contracts/ceBNB.cdc:107  contracts/ceMATIC.cdc:84  mintTokens  contracts/ceAVAX.cdc:199  contracts/ceBNB.cdc:201  contracts/ceDAI.cdc:178  contracts/ceMATIC.cdc:178  contracts/ceUSDT.cdc:199  contracts/ceWETH.cdc:199  createEmptyVault  contracts/ceBNB.cdc:138  contracts/ceBNB.cdc:162  contracts/ceBUSD.cdc:139  contracts/ceDAI.cdc:115 Consequently, the code complexity and maintainability will increase because each contract requires its own customized transaction and script les to return the correct resource types.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Unused entitlement",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2024-09-20 - Celer Flow Contracts.pdf",
        "body": "In cadence/contracts/VolumeControl.cdc:3, the Update entitlement is dened but not implemented, which reduces code readability and maintainability.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Getter functions are not marked with the view keyword",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2024-09-20 - Celer Flow Contracts.pdf",
        "body": "In Cadence 1.0, view functions are introduced to enforce getter functions that do not modify any state. However, this is not enforced in the following functions:  getSigners in cadence/contracts/cBridge.cdc  delayTransferExist and getDelayBlockTs in cadence/contracts/DelayedTransfer.cdc  hasMore, toUint64, toUint256, toAddress, toUFix64, and toString in cadence/contracts/Pb.cdc  eqToken in cadence/contracts/PbPegged.cdc  getTokenConfig and recordExist in cadence/contracts/PegBridge.cdc  getTokenConfig and recordExist in cadence/contracts/SafeBox.cdc  getEpochVolume and getLastOpTimestamp in cadence/contracts/VolumeControl.cdc",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Suboptimal balance update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2024-09-20 - Celer Flow Contracts.pdf",
        "body": "In cadence/contracts/RLY.cdc:133, the burnCallback function sets the balance to zero regardless of the current balance. This is suboptimal as the balance may already be zero, making it a redundant operation. This issue also aects the following contracts:  cadence/contracts/ceAVAX.cdc:133  cadence/contracts/ceBNB.cdc:135  cadence/contracts/ceBUSD.cdc:112  cadence/contracts/ceDAI.cdc:112  cadence/contracts/ceFTM.cdc:112  cadence/contracts/ceMATIC.cdc:112  cadence/contracts/ceUSDT.cdc:133  cadence/contracts/ceWBTC.cdc:133  cadence/contracts/ceWETH.cdc:133",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Unlimited transactions in proposal blocks can lead to denial of service",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Consensus.pdf",
        "body": "block. In rusk/consensus/src/proposal/handler.rs:80-112 the verify_new_block function of the ProposalHandler, there is no limit on the number of transactions in a operation candidate p.candidate.txs().iter().map(|t| t.hash()).collect() iterates over all transactions to calculate their hashes before computing the merkle root. An attacker could exploit this by submitting a candidate block with an extremely large number of transactions, causing excessive computation time and potential denial of service. The",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Committee members can vote multiple times",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Consensus.pdf",
        "body": "The function collect_vote in consensus/src/aggregator.rs should ensure that each committee member can only vote once per round. However, it only contains a debug_assert in line 96 which will panic when a committee member has already voted. But because debug_assert instead of assert is used, this will only be done for non optimized builds, i.e. not for production builds.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Committee members can submit conicting votes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Consensus.pdf",
        "body": "A committee member that has voted valid during the validation step could vote invalid during the ratication step. This could be used by committee members to obfuscate malicious behavior, while sabotaging the consensus.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Emergency block is unimplemented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Consensus.pdf",
        "body": "According to the documentation an emergency empty emergency block is produced after 255 iterations. This is not the case. Unimplemented production relevant features are a major issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Slashing for block generator is disabled after 10 iterations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Consensus.pdf",
        "body": "consensus/src/proposal/step.rs:62, constant In config::RELAX_ITERATION_THRESHOLD is used to limit the number of iterations from which we extract failed attestations. Currently, this constant is declared to be the number 10. the After the number of iterations in a single round reaches 10, only the 10th iteration is used to extract failed attestations, even if the 50th iteration is in progress. Failed attestations are used in rusk/src/lib/chain/rusk.rs to extract generators to slash them for inactivity, see the function reward_slash_and_update_root (line 538). As a consequence of using this limit, generators from iterations 11, 12, 13 etc. are not slashed for neglecting their duties. Malicious generators can safely idle till the end of round if the block has not been conrmed during the rst 10 iterations.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Inecient order of checks in verify_new_block can be exploited by attackers to overload the system.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Consensus.pdf",
        "body": "rusk/consensus/src/proposal/handler.rs:80-112 function In the verify_new_block, expected_generator!= p.sign_info.signer.bytes() at the end of the function. This means computationally intensive operations like signature verication, previous block hash checking, and merkle root calculation are performed before conrming the block came from the expected generator. Attackers can exploit this even if the issue Unlimited transactions in proposal blocks can lead executes check the to denial of service is xed to cause an excessive number of unnecessary calculations and potentially overload the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Dierent calculation logic for majority and supermajority",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Consensus.pdf",
        "body": "In the le consensus/src/user/committee.rs, the required credits for the majority and supermajority are calculated in lines 41-45. For the supermajority, the credits are determined by multiplying the committee credits with the threshold and taking the ceiling of this result. For the majority, the committee credits are also multiplied with the majority threshold, but this is then casted to a usize and 1 is added to the result. In most cases, these two approaches are equivalent. However, when the committee credits are an exact multiple of MAJORITY_THRESHOLD, the required credits are higher by one. For instance if there are 4 the 0.5 committee SUPERMAJORITY_THRESHOLD set to 0.67, the required credits will be 3 for both. MAJORITY_THRESHOLD credits with and the set to If the MAJORITY_THRESHOLD and SUPERMAJORITY_THRESHOLD were set to the same value, this would also mean that the required credits for the majority would be higher than for the supermajority, which does not make sense. Moreover, if it was set to 1.0, it would never be reachable.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Iteration context is not reset when new iteration begins",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Consensus.pdf",
        "body": "Within consensus/src/iteration_ctx.rs:105-108 the function on_begin is dened. This function is called when a new iteration begins, and it updates the iteration counter inside the IterationCtx structure. However, this increment is not consistent with the other elds of the structure, namely join_set and timestamps. The join_set variable tracks all asynchronous tasks started during an iteration. If it's not reset when the new iteration begins, computation from the previous iteration might still be running and cause inconsistent state changes. The timeouts variable is involved in the adaptive timeout algorithm and contains current values of delays. New iteration involves a dierent committee with dierent availability, so timeouts should be reset to its default value.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Suboptimal usage of BTreeMap",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dusk/2024-09-20 Audit Report - Rusk Consensus.pdf",
        "body": "The le consensus/src/user/provisioners.rs demonstrates a wise choice of data structure to track all available provisioners, namely BTreeMap. However, the structure is not utilized to the maximum of its capabilities. The set of provisioners eligible for participation in the current round committee is computed by iterating all provisioners (line 154), ltering them by round and minimum stake (line 155), cloning their stakes (line 245), comparing each public key with an excluded one (line 251) and, nally, constructing a new map from the iterator (line 252). These iterations are excessive and reduce tolerance to DoS attacks against the network.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Potential loss of funds due to missing address validation in submit function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-09-23 Audit Report - Dora Vota Migration Contract v1.0.pdf",
        "body": "In contracts/DoraBridge.sol:95-113, the submit function allows users to burn their tokens on Ethereum and emits an event to mint the same tokens on the Dora Vota chain at a specied _votaAddr address. However, there is no validation to ensure that the _votaAddr is provided. If this address is not provided, the Submit event will be emitted without a receiver address. This would result reference to where they should be minted. in a permanent loss of funds, as tokens would be burned without a",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Missing address validation in the changeAdmin function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-09-23 Audit Report - Dora Vota Migration Contract v1.0.pdf",
        "body": "In contracts/DoraBridge.sol:49-53, the changeAdmin function allows the current admin to transfer its role to another address. However, it does not validate whether the provided _admin address is valid. This omission could result in the admin being set to a nonexistent or incorrect address, potentially causing the protocol to become stuck since the admin would be unable to execute its required operations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Possible duplicates in txHashes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-09-23 Audit Report - Dora Vota Migration Contract v1.0.pdf",
        "body": "In contracts/DoraBridge.sol:119-129, the process function is called by the admin after the tokens are bridged on the Dora Vota chain. This function serves as a verication mechanism for the user by recording the txHash of the mint transaction on the Dora Vota chain. However, the process function lacks validation to check if the _txHash provided is already present in the _txHashes array. Although txHash values are expected to be unique for each transaction under normal circumstances, the absence of this validation allows admins to inadvertently or maliciously add duplicate entries to the _txHashes array.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Missing address validation in the constructor",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-09-23 Audit Report - Dora Vota Migration Contract v1.0.pdf",
        "body": "In contracts/DoraBridge.sol:25-29, whether the provided _admin and _token addresses are valid. the contracts constructor does not check This lack of validation could lead to unintended behavior and miscongurations, as it could allow the instantiation of the contract without having references to the token contract or the administrator.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Potential out-of-gas error in the recordOf function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-09-23 Audit Report - Dora Vota Migration Contract v1.0.pdf",
        "body": "In contracts/DoraBridge.sol:66-77, the recordOf view function iterates through all the _usersRecords of the provided address and returns for each of them a Record. However, the iteration over the _usersRecords array is unbounded and could result in a computationally expensive operation if the user executes the submit function multiple times. Although recordOf is a view function, the gas limit is still enforced by the RPC nodes, potentially leading to out-of-gas errors if the array grows too large.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Functions called externally are dened as public",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-09-23 Audit Report - Dora Vota Migration Contract v1.0.pdf",
        "body": "The changeAdmin, recordOf, getUnprocessedRecords, submit, and process functions dened in contracts/DoraBridge.sol are called only externally, but dened as public, which is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-09-23 Audit Report - Dora Vota Migration Contract v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. The DoraBridge contract is not pausable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-09-23 Audit Report - Dora Vota Migration Contract v1.0.pdf",
        "body": "Bridge contracts typically will exploits that can cause a loss of funds. implement pausable functionality to protect users from In addition, due to the design of the bridge, it may be necessary to halt the execution of the submit function immediately after the o-chain actor responsible for handling events is suspended. This precaution is important to prevent users from burning their tokens.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. The Process event is not indexed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-09-23 Audit Report - Dora Vota Migration Contract v1.0.pdf",
        "body": "Indexing event elds signicantly enhances the accessibility of these elds for o-chain tools that parse events. However, indexed keyword for the count and processed elds. in contracts/DoraBridge.sol:47, the Process event is missing the This omission could slow down event processing and make data retrieval less ecient for o-chain tools.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Miscellaneous comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DoraFactory/2024-09-23 Audit Report - Dora Vota Migration Contract v1.0.pdf",
        "body": "Miscellaneous recommendations can be found below.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attackers providing incorrect or malicious price feed can buy tokens at an arbitrary price",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "feed_account, The programs/gcx/src/instructions/buy_offer.rs:179 programs/gcx/src/instructions/initial_buy.rs:137, the SOL/USD price feed from the Pyth oracle. dened in and is intended to provide the current However, the provided feed_account is an account owned by the Pyth oracle, nor does it conrm that the account reports the correct price feed. implementation does not validate whether Consequently, attackers can exploit this vulnerability by providing a dierent Pyth price feed they can account or an entirely fake account with incorrect price data. By doing so, manipulate the price feed to purchase tokens at an articially deated price, leading to potential nancial losses for the platform and its users. For example, a buyer could present a manipulated price feed that proposes a much lower SOL/USD price, allowing them to acquire tokens for far less than their true market value.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Market can be initialized without seller authorization and before all tokens have been sold",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "InitializeMarket The in programs/gcx/src/instructions/create_token.rs is intended to enable Stage 2 of token distribution by allowing the token owner to initiate a market for token exchange after all tokens have been sold during Stage 1. instruction handler However, there is no verication to ensure all tokens have been sold in Stage 1 before enabling Stage 2 and the instruction does not implement any authorization mechanism, permitting anyone to execute it. the market can be initialized before the completion of Stage 1, disrupting the Consequently, token distribution process. Additionally, the lack of authorization allows anyone to start a marketplace for tokens without the owners consent, potentially leading to unauthorized market creation and disruption of token economics.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Incorrect math leads to underpriced tokens when buying an oer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "programs/gcx/src/instructions/buy_offer.rs:40-53 the In computation when buying an oer from the marketplace is incorrect. token price Specically, the amount is divided two times by LAMPORTS_PER_SOL which leads to an incorrect price due to unit mismatch in the computation. Consequently, the price denominated in SOL required to buy the oer is incorrect and not predictable by users leading to failed transactions and severely underpriced tokens.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Token transfers will always fail due to incorrect account seed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "holder_state The in programs/gcx/src/instructions/transfer_tokens.rs:70-71 is derived via the b\"token_holder\" seed string. instruction account dened context the in However, since it is derived and initialized via the b\"holder_state\" seed string in all other instances throughout the protocol, the transfer_token instruction will always fail since the required holder_state PDA does not exist for this specic seed. Consequently, it is not possible to transfer tokens.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Inconsistent accounting of token decimals throughout the protocol",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "The decimals of token_amount are inconsistently accounted for throughout the whole protocol. BuyMarketPlaceOffer in The handler, programs/gcx/src/instructions/buy_offer.rs:16-141, the token_amount has 0 decimals according to the price calculations in lines 40-54, which is based on the price per whole token. However, within the same function, the check in line 77 and the token transfer in lines 134-137 require the token_amount to have 9 decimals. instruction suggests dened that the instruction InitialBuy in handler, Similarly, programs/gcx/src/instructions/initial_buy.rs:16-104, that token_amount has 0 decimals according to the price calculations in lines 30-42, which is based on the price per whole token, and the token transfer in lines 101-104, which explicitly upscales the amount from 0 to 9 decimals. However, within the same function, the check in line 50 requires the token_amount to have 9 decimals in the rst place. dened suggests of instances Further programs/gcx/src/instructions/transfer_tokens.rs, programs/gcx/src/instructions/create_offer.rs, programs/gcx/src/instructions/create_token.rs. inconsistent decimals token also exist within and Consequently, this mismatch between decimals could lead to transaction failure, invalid price computation, and wrong token amounts being transferred.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Users can buy tokens from sellers with the Stage 1 mechanism after the market is initialized",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "handle_initial_buy The in programs/gcx/src/instructions/initial_buy.rs:16, allows users to buy tokens from sellers at a xed price during Stage 1. instruction handler, dened However, this instruction is still executable by users to buy tokens from the seller in Stage 2 after the market initialization. Consequently, this enables a behavior that diverges from the specication and, if the seller rebuys the tokens in the marketplace, could lead to market manipulations.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Token holders can create an innite number of unbacked oers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "In the handle_create_or_modify_marketplace_offer instruction, dened in the execution checks if the programs/gcx/src/instructions/create_offer.rs, seller_mint_ata account holds at least the amount_offered tokens. However, these tokens are not recorded or transferred to any escrow account after the validation. As a result, the seller can create an innite number of oers without actually having the required tokens to back them leading to spamming the marketplace with oers that cannot be fullled.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Marketplace oers can be reinitialized",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "CreateOrModifyMarketplaceOffer in The programs/gcx/src/instructions/create_offer.rs species the oer account as init_if_needed which instructs Anchor framework to create an account if it did not exist previously or use the currently existing one during execution. instruction dened handler As a consequence, any seller can modify their oer at any point in time without restrictions, which includes, but is not limited to changing its price. The particularly malicious scenario is as follows: First, a malicious user sets up an oer. Once a legitimate user wants to accept the oer using BuyMarketPlaceOffer instruction, the malicious user can frontrun the legitimate users transaction and re-initialize the oer with a dierent price, causing nancial loss to the legitimate user. It is worth noting that currently, frontrunning in Solana requires running a malicious validator, however, a MEV infrastructure project may be available in the future that will facilitate frontrunning attacks. Additionally, a malicious user might still try to modify the oer in hopes of deceiving legitimate users who would see previous prices in the frontend components.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Invalid boolean arithmetic leads to a verication bypass",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "programs/gcx/src/instructions/create_offer.rs, the In CreateOrModifyMarketplaceOffer instruction handler implements a verication mechanism in line 21 that is intended to allow oer creation only when the marketplace is initialized and the program is congured to enable market oers. Specically, the following boolean arithmetic is responsible for checking for a failing condition and failing the execution if they are not met: _. __  ___. _ However, this boolean arithmetic is not correct as the logic AND makes the program fail execution only if both boolean values are set to false. Considering that anyone can set a market as initialized because Market can be initialized without seller authorization and before all tokens have been sold, the scenario where the market is initialized (mint_owner_token_state.market_initialized is set to true) and the program does not allow market oers (program_state.allow_market_offers is set to false) appears to be easily achieved. Consequently, marketplace oers can be created at any time by anyone, even if program's global settings disable it. the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Assuming negative sign of Pyth price feed exponent can lead to incorrect token pricing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "token in The and programs/gcx/src/instructions/initial_buy.rs:37-41 programs/gcx/src/instructions/buy_offer.rs:45-49 are performed on a Pyth price feed which is given by price and expo, i.e. price*10^expo. computations price However, both instances assume the expo to be always negative and therefore reconstruct the price via price/10^abs(expo). Still, according to the rst example in the pyth_sdk_solana::Price documentation, the expo can also be positive. Consequently, returned expo is not negative. the current implementation can lead to wrong token pricing in case the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "11. Multiple minting is allowed in the CreateToken instruction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "CreateToken in The programs/gcx/src/instructions/create_token.rs:7:38 is responsible for minting initial tokens to an authority account and setting the market associated with them as not initialized. instruction handler However, since mint, mint_ata, and token_state accounts are marked with init_if_needed the Anchor framework will not fail the execution if those accounts are already created allowing the program owner to execute the mint of tokens to the same authority multiple times. This behavior diverges from the specication since it would inate the amount of the designated initial tokens per user. We are reporting this issue with minor severity since only the program owner can execute the mint.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Lack of input validation for the initialize_program_state instruction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "the init In in programs/gcx/src/states/program_state.rs:15:33 there is no validation on the provided data. ProgramState, implementation function dened for the Specically, market_program_fee, initial_fee, and allow_market_offers should be within the range of (0, 100) as they represent a percentage. market_owner_fee, parameters Similarly, initial_token_price should be enforced to be greater than 0 to make the subsequent transfer succeed. Consequently, underows or division by zero errors. this can lead to incorrect or undesirable behavior, potentially leading to",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Possible precision loss due to incorrect calculations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "The programs/gcx/src/instructions/buy_offer.rs:40:54 calculates token prices. BuyMarketPlaceOffer instruction handler in Currently, divisions are intertwined with multiplications. Furthermore, all calculations are done on the u64 type. Such an approach to the calculation is inherently subject to higher precision losses which may result in an inaccurate price. the same instruction Furthermore, in programs/gcx/src/instructions/buy_offer.rs:56:70 is calculating the values to be transferred - the actual amount of tokens for sale along with fees for project and market owner. Each value is calculated independently using arithmetic operations which include division. Due to the inherent precision loss associated with integer division it is possible that the sum of all calculated values would not add up to the initial total value. If this scenario occurs, some of the lamports would be stuck in the program account. handler",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Missing check allows to set any account as token authority",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "accounts The in the programs/gcx/src/instructions/create_token.rs:41:71 contains a member called authority that is used to set the authority eld in the TokenState account. CreateToken instruction struct for the CreateToken instructions accounts struct species this member to be However, AccountInfo causing the instruction to accept any account provided, making it possible to use an incorrect one. We are reporting this issue with minor severity since only the program owner can execute the mint.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Program state initialization is fully permissionless",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "InitializeState in The programs/gcx/src/instructions/program_state.rs, to permissionlessly create their own program_state PDA. This allows users to own and operate their instance of the protocol, while an indenite number of such instances can coexist, all using the same program ID. instruction, dened anyone allows into interacting (e.g. it also enables scammers to trick Although this permissionless nature might be intended, users initial buy or marketplace buy/sell) with a malicious program_state without any suspicion, due to interacting with a known & trusted program ID.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Holder status is not used",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "HolderState The in programs/gcx/src/states/holder_state.rs, species a member of boolean type called active. account, dened However, it has been observed that this value is not used in the program and it is always set to true when the account is initialized and there are no paths in the code to update it.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Miscellaneous comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Out/2024-09-24 Audit Report - Out GCC.pdf",
        "body": "Miscellaneous recommendations can be found below.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Rewards are lost if the distribution is funded after the expiry",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "In contracts/distribution/dao-rewards-distributor/src/contract.rs:303, the execute_fund function restarts the distribution if it is not continuous and already expired at the current block. This is problematic because rewards accrued from the last updated timestamp active_epoch.last_updated_total_earned_puvp to the ending timestamp active_epoch.ends_at will be lost. Consequently, stakers will not receive the rewards for the staking period, causing a loss of rewards. Please see the test_lost_rewards test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Incorrect reward distribution due to inconsistent voting power queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "In contracts/distribution/dao-rewards-distributor/src/rewards.rs:113- 136, the get_active_total_earned_puvp function computes the reward index by dividing the accrued rewards by the total voting power queried from the previous block height (see contracts/distribution/dao-rewards-distributor/src/helpers.rs:19). This is incorrect because the user reward is computed with voting power queried from the in current contracts/distribution/dao-rewards-distributor/src/helpers.rs:33. height, block seen as Consequently, the reward index will be computed using an outdated total voting power, resulting in incorrect reward distribution. An attacker can exploit this issue by staking many tokens one block before claiming the rewards to receive more at the expense of other users. Please see the test_claim_more_rewards test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Users can inate their voting power by registering duplicate NFT token IDs",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "In the contracts/voting/dao-voting-onft-staked/src/contract.rs:149, execute_confirm_stake function does not validate that the supplied NFT token IDs are not duplicates. This is problematic because the register_staked_nfts function in increases contracts/voting/dao-voting-onft-staked/src/state.rs:65-77 the users voting power based on the total number of token IDs supplied, which may include duplicates. An attacker can exploit this issue by calling the execute_confirm_stake function with duplicates of a token ID, granting them a high amount of voting power without requiring them to stake the necessary NFTs. These voting powers can be weaponized to manipulate the DAO into dispatching malicious messages, such as transferring funds to the attacker.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Missing validation of submission policy during contract migration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "In packages/dao-pre-propose-base/src/execute.rs:670, the migrate function allows the contract migration admin to set the PreProposeSubmissionPolicy when updating the contract. However, no validation ensures the supplied policy does not accidentally lock the DAO due to an invalid conguration. We classify this issue as minor because it can only be caused by the contract migration admin, which is a privileged account.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Units of duration are not distinguished",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "Time durations are crucial However, the data types implemented are error-prone. to the logic of the dao-rewards-distributor contract. the example, For contracts/distribution/dao-rewards-distributor/src/helpers.rs:78 subtracts one Expiration from another. Although the end and start parameters explicitly indicate the unit duration types (i.e., blocks or seconds), this information is not preserved in the output as the function returns u64 instead of the Expiration struct. get_exp_diff function in the get_exp_diff function returns 0 if Additionally, Expiration::Never, which is mathematically incorrect. the input parameters are both Similarly, the get_duration_scalar function in line 42 removes the duration unit information and directly returns the inner value as u64, further elevating the potential for errors. Consequently, the code responsible for managing distribution schedules and timeframes becomes more challenging to interpret, particularly when it involves arithmetic operations with mixed time units. This complexity increases the likelihood of bugs in these segments.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Expired linear distributions cannot be paused",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "In contracts/distribution/dao-rewards-distributor/src/state.rs:271-27 2, the transition_epoch function sets the distribution ending period (Epoch.ends_at) to the current block height or timestamp. This is problematic because the distribution may have already expired in the previous block, which causes the ending period to be updated incorrectly. Consequently, expired linear distributions cannot be paused due to an overow error in contracts/distribution/dao-rewards-distributor/src/state.rs:285-28 8, preventing the protocol from working as intended. Thi issue has been independently reported by the client.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Suboptimal storage update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "In the packages/dao-pre-propose-base/src/execute.rs:199, execute_update_config function validates the submission_policy parameter in line 213 and updates it in the Config state. this is inecient because the Config state is retrieved in line 211 before However, validating the submission policy. If the submission policy does not pass the validation, the loaded storage value (indicated as the prev variable) remains unused.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Duplicate distribution congurations can be created",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "In contracts/distribution/dao-rewards-distributor/src/contract.rs:129, the execute_create function allows the contract owner to create a distribution. However, other distributions may already exist with the same conguration, causing duplicate distributions to be created.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Suboptimal usage of optional vectors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "The Option<Vec<...>> type is prevalent across the codebase. Although it is useful to distinguish between an empty and an absent list in certain scenarios, this distinction is currently not used in the codebase, which is inecient and increases code complexity. in example, packages/dao-voting/src/pre_propose.rs:72-84, For the PreProposeSubmissionPolicy enum declares the denylist and allowlist elds to Option<Vec<String>>. The lists are parsed with unwrap_or_default, which converts conguration in empty packages/dao-pre-propose-base/src/execute.rs:291 and 365. This indicates there is no meaningful distinction between None and an empty vector. updating the submission policy to None before lists Hence, we conclude that Option<Vec<...>> serves more as an optimization than a necessity. Given that modern Rust minimizes the memory footprint of empty vectors, the complexity added by Option<Vec<...>> pattern outweighs its benets. Consequently, the code complexity is increased due to additional checks and unwrapping without a signicant memory eciency gain.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Storage collection considerations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "the contracts/voting/dao-voting-onft-staked/src/state.rs:33, In STAKED_NFTS_PER_OWNER state is dened as Map<(&Addr, &str), Empty>. This mapping type is optimal for scenarios when tokens are added incrementally, so the storage updates only mutate the aected entries without needing to read and write other unaected tokens. However, STAKED_NFTS_PER_OWNER can also be used in batch updates in lines 72-75 or 101-110. This scenario is problematic in the current implementation because it requires querying and mutating multiple storage entries one by one, increasing the gas consumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Code deduplication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "code in The packages/dao-pre-propose-base/src/execute.rs:262-283, and 330-351 are identical. These segments implement modifying permission lists with iteration, deduplication, and address validation, which can be abstracted as reusable components to increase code maintainability. 307-328, segments",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Unnecessary code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2024-09-24 Audit Report - DAO DAO Rewards Distributor, x_onft Staked Voting, BitSong FanToken Factory, Permission Granularity v1.1.pdf",
        "body": "contracts/voting/dao-voting-onft-staked/src/contract.rs:178-180, In the execute_confirm_stake function removes the PREPARED_ONFTS state based on the supplied token IDs. This is unnecessary because the register_staked_nfts function in already contracts/voting/dao-voting-onft-staked/src/state.rs:73. removes them",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Liquidation queue contract receives fewer collaterals than expected when liquidating more than one asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "In contracts/bl-market/src/execute.rs:1211-1286, the liquidate function implements logic to execute a liquidation on unhealthy positions. Based on the the LiquidationAmountResponse queried from the liquidation queue contract, process_ptoken_transfer_to_liquidation_contract function will be called for each collateral to transfer pTokens from the borrower to the liquidation queue contract. These messages are intended to be collected within the Response created in line 1209. However, the Response variable will be reinitialized in lines 1264-1271 when there is more than one collateral to liquidate, causing the previous collaterals TransferOnLiquidation message not the collaterals must be transferred to the liquidation queue contract as part of the liquidation logic. to be dispatched. This is incorrect because all Consequently, the liquidation queue contract will only receive one out of all the expected collaterals, causing a loss of funds for bidders as there are insucient collaterals to be claimed. Please see the test_liquidate_double_asset_poc test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Users can steal funds by receiving more liquidation fees, causing a loss of funds for bidders",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "contracts/liquidation-queue/src/contract.rs:1074, the In the execute_dynamic_liquidation collateral_amount parameter, representing the amount of collateral tokens to liquidate. the repayment amount based on the In return, receive a portion of the caller will function specify allows caller the to config.liquidator_fee contracts/liquidation-queue/src/contract.rs:1197-1205. percentage, as seen in the LiquidateDirect When in the contracts/liquidation-queue/src/contract.rs:1172-1184, calculate_liquidation_amounts function computes the required repayment amount based on the borrowers debt position. If any excess debt token is sent, the tokens will be refunded in contracts/bl-market/src/liquidate.rs:203-211. message called is However, the liquidation-queue contract does not account for this scenario, allowing users to receive more liquidation fees than intended because the provided collateral amount is not fully consumed during liquidation. The contract will receive a lower collateral amount than expected, the ClaimLiquidations message. resulting in an insucient funds error when bidders call Consequently, malicious users can receive more liquidation fees by specifying the collateral_amount parameter to a value higher than the borrowers collateral balance, causing refunded tokens to be stuck and risking the protocols solvency.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Utilization rate can be exploited to surpass 100% for new markets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "In contracts/bl-market/src/interest_rate.rs:279-281, the utilization rate of a market is determined by the ratio of total debt divided by total collateral. If a new market is instantiated with zero deposits, an attacker can inate the utilization rate to steal funds from the contract. An exemplary step-by-step attack follows: 1. ATOM market is instantiated. 2. The attacker creates two accounts: account1 and account2. 3. account1 becomes the rst depositor and deposits 1 uatom, increasing the markets total collateral",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. account1 receives around 84000 ATOM after 10 seconds due to the inated utilization rate. For more information on this type of attack, please refer to the Silo Finance Vulnerability Disclosure. Recommendation We recommend limiting the utilization rate to a maximum value of 100% with the min function. Status: Resolved 4. Incorrect price mechanism used during liquidation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "9. Refund amount is not excluded when computing the utilization ratio",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "contracts/bl-market/src/execute.rs:967, In calls update_interest_rates with the liquidity_taken argument set to zero. This is incorrect because the liquidity_taken argument should be set to the refund amount in contracts/bl-market/src/execute.rs:938-946. function repay the debt The update_interest_rates function computes the utilization ratio based on the ratio of in total contracts/bl-market/src/interest_rate.rs:267-284. Since a refund will be performed, the total collateral must be decreased by the refund amount to correctly compute in the contracts/bl-market/src/interest_rate.rs:304-315. collateral markets liquidity borrow seen rate, total rate and as to Consequently, lenders to receive fewer rewards and borrowers to pay lesser interest. the utilization ratio will be computed to be lower than intended, causing",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Deactivated markets can be liquidated and repaid",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "In contracts/bl-market/src/contract.rs:193, the LiquidateDirect message does not return an error if the debt or collateral market is inactive. This violates the comment in packages/bl-core/src/bl_market/mod.rs:104-105, which indicates that a deactivated market cannot perform any actions, including debt repayment and liquidation.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "11. Risk of withdrawing funds within the liquidation threshold limit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "In contracts/bl-market/src/execute.rs:638-644, the withdraw function allows users to withdraw assets as long the liquidation threshold is not exceeded. This is incorrect because the function should instead check the users maximum Loan-to-Value (LTV) restriction. The LTV is meant to be a safe buer before the liquidation threshold is triggered so that users are not being liquidated after withdrawing their funds. For comparison, the borrow function enforces the users position to not exceed the max LTV restriction, as seen in contracts/bl-market/src/execute.rs:784-789. they are at Consequently, a borrower may borrow collaterals at the max LTV and withdraw the collateral until the liquidation threshold, exposing them to liquidation risks and circumventing the risk management buer of the protocol. In a strongly downward trending market, aggravated limited liquidity or block space for liquidations, this issue could lead to a steep increase in unhealthy positions, risking the protocols solvency.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "12. Liquidation may fail due to out-of-gas errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "In contracts/bl-market/src/execute.rs:1123-1179, multiple iterations occur over the user_asset_position vector, which may cause the transaction to fail due to an out-of-gas error. Specically, the assets in the users position are iterated in lines 1123, 1143, and 1156. this by opening many asset positions to force Consequently, borrowers could exploit liquidations to fail due to gas limits, causing a loss of funds for lenders and risking the protocols solvency. We classify this issue as major because the maximum number of positions that can be opened depends on the number of assets supported by the contract owner, which is a privileged account.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "13. Market deposit limits may be surpassed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "contracts/bl-market/src/execute.rs:510-519, In function implements an incorrect method of validating that the total deposits do not exceed a markets deposit cap. Specically, line 514 enforces the following condition: deposit the market.deposit_cap_scaled <= market.ptoken_address.total_supply + deposit_amount * SCALING_FACTOR This is problematic because the get_scaled_liquidity_amount function in lines 527-528 computes the mint amount based on the markets liquidity index. If the index increases, in amount contracts/bl-market/src/interest_rate.rs:226-230. pTokens minted lesser, seen the will be as Consequently, the same amount of collateral deposited will result in dierent amounts of pTokens minted when the liquidity index exceeds Decimal::one(), resulting in the pToken's total supply to grow at a slower pace than the collateral deposits, ultimately causing the maximum deposit limit to be surpassed. Please see the test_deposit_limit_is_broken_poc test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "14. Premium slot validation is voided",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "In contracts/liquidation-queue/src/contract.rs:546-548, the submit_bid function does not return an error if the provided premium slot is invalid. This is because StdError is simply instantiated but not returned. Consequently, users can submit bids with the premium slot greater than the maximum slot, causing their bids not to be utilized for liquidation in line 980, ultimately risking the protocols solvency as the liquidation-queue contract fails to liquidate undercollateralized positions from the bl-market contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "15. Free and instant bid retractions create risk-free prot vectors for well-funded attackers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "users in retract Allowing contracts/liquidation-queue/src/contract.rs:836 generates the possibility for well-capitalized actors to place spoof bids to ll up the 0% discount slot to discourage other users from depositing into any bid pool. instantly bids to This may allow attackers with big capital to front-run liquidations by lowering their bids from a 0% discount to the lowest possible slot in which their capital will be utilized, eectively increasing the price discount received for minimal operational gas cost. Consequently, users with small capital will be disincentivized from depositing funds to the liquidation-queue contract as they will receive zero prot, allowing the attacker to receive most of the liquidation prots. This risks the protocols solvency as the attacker has the majority control over the liquidation bidding mechanism. For example, if the attacker decides to retract all their bids during a market crash, borrowers with undercollateralized positions will not be liquidated on time, causing a loss of funds for lenders.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "16. Linear premium slots might lead to suboptimal risk of liquidator incentives",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "The premium slots of the liquidation queue contract that discount the price of the collateral of limits the liquidatable positions are congured linearly. This is problematic because it customizability of the protocol and liquidation queue  particularly for larger positions of downward-trending collateral. Typically, one would assume that for relatively stable assets/collateral, very small steps would already incentivize participation from liquidators. In contrast, larger steps may be needed to incentivize participation for more volatile collaterals. However, when collateral depegs or the overall market sentiment changes, it transitions from a stable to an unstable market. A linear premium slot design is insucient for such scenarios and assets because it would require smaller and larger steps. The rst slots may contain small discounts, while those closer to the maximum could contain larger discounts for collateral under heavy distress.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Missing validation when updating congurations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "The following instances illustrate missing validation in the codebase:  The liquidation_bonus in contracts/bl-market/src/execute.rs:276 is not validated as in line 396 to ensure the values are within the logical cause the LiquidateDirect message to fail. range, which may parameter  The CONFIG in contracts/liquidation-queue/src/contract.rs:53 is not validated as in line 483, which may cause invalid market and oracle timeframes to be congured.  The target_health_factor parameter is not validated to be greater than or equal to 100% in packages/bl-core/src/bl_market/mod.rs:118, which may cause the borrower to be liquidated more than once. struct  The protocol_liquidation_fee parameter is not validated to be lower than 100% in packages/bl-core/src/bl_market/mod.rs:118, which may cause the LiquidateDirect message to fail. We classify this issue as minor because it can only be caused by a misconguration from the contract owner, which is a privileged address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Non-existing price sources can be removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "In contracts/oracle/src/contract.rs:150, the remove_price_source function does not ensure the provided denom exists in the PRICE_SOURCES state before removing it. This would result in a no-op operation instead of returning an error because the remove function does not check whether the key exists in the storage, potentially confusing users as they believe the denom is a valid key inside the PRICE_SOURCES map.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Lack of a secondary fallback price feed oracle",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/SendIt/2024-09-25 Audit Report - SendIt Contracts v1.0.pdf",
        "body": "The codebase depends on a single oracle contract with no backup oracles implemented. If the oracle's price is stale, the protocol operations will be incorrect and eventually suspended. It is best practice to congure a backup oracle.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Excess reward distribution due to incorrect reserve shares calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "In crates/core/hub/position.rs:286, the reserve_shares_payment value is calculated by subtracting amo_shares_allocation from total_issued_shares. This is problematic because total_issued_shares denotes the total shares within the protocol, not the excess shares intended to be distributed to depositors. Since the contract does not hold the actual reward amounts, users will unknowingly withdraw from other depositors balances once the accrued rewards have been exhausted. Consequently, late-withdrawal users will be unable to withdraw due to insucient funds, ultimately risking the protocols solvency.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Repaying and redeeming synthetic tokens does not normalize decimals to primary deposit asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "the amount In crates/core/hub/position.rs:1221 and lines 1617-1634, parameter denominated in synthetic tokens is used to repay debt and redeem underlying assets. This is problematic because the users debt and reserve redeemable are denominated in the primary deposit asset, not the synthetic token asset. Since the synthetic token and primary deposit asset might have dierent decimal values, the sent amount should be normalized to the correct decimal before decreasing the users debt the mint_synthetic function in or crates/core/hub/position.rs:968-985 normalizes the primary deposit asset decimals to synthetic token decimals before minting them to the user. redeeming the underlying assets. For example, Due to this misalignment, users will repay more debt with fewer funds and redeem more underlying assets if the number of synthetic token decimals is higher than that of the primary deposit asset. Conversely, if the synthetic token decimals are fewer than the primary deposit asset, users will still have outstanding debt even after repaying in full and redeeming fewer underlying assets.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Unimplemented oracle querying feature",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "The advance_fee_rate function is expected to query the fee rate through the congured oracle address the function seems to be pending development as it only contains an unimplemented exception. in crates/cosmwasm/vanilla/hub.rs:153-159. However, Oracle features are usually error-prone and should be reviewed with care. Although not a security issue, this nding has been raised as a minor risk to highlight the dangers of this functionality not undergoing thorough auditing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Potential bypass of access control in the hub contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "The hub contract has implemented several access controls that the contract admin can manage. These controls are designed to limit certain actions within the contract. However, these restrictions may be bypassed through alternative entry points, thus circumventing the defenses. Specically, the ConvertCredit message allows users to convert their credit into collateral, subsequently increasing their collateralized debt position. This function might bypass the intended restrictions set by the VAULT_DEPOSITS_ENABLED storage state and deposit proxy. For instance, this could occur if the intended function of disabling a deposit is to prevent users from increasing their collateral or if the deposit proxy is specically designed to limit collateral increases. Similarly, the SelfLiquidate message allows users to fully liquidate their positions, receiving funds in synthetic tokens or primary deposit assets. This function might bypass the if the redeem proxys intended restrictions for the redeem and mint proxy. For example, purpose is to ensure that only the proxy can redeem underlying assets or if the mint proxys purpose is to ensure that only the proxy can mint new synthetic tokens. Consequently, restrictions set by the contract admin may be circumvented, potentially leading to unintended consequences.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Potential out-of-gas in AllVaults query",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "In crates/core/hub/query.rs:75-79, the AllVaults query message iterates through and returns all vaults registered in the hub contract. If many vaults are registered, the query might fail due to an out-of-gas error.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Smart queries expose insucient contract storage states",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "The hub and vault contracts query messages expose minimal contract storage states. reserve reserve shares, Important redeemable, total deposits, and total shares are not exposed through smart queries. information such as the contract admin address, Consequently, users and other smart contracts must perform raw queries to fetch these values, decreasing user experience and tying queries to the underlying storage implementation, which is error-prone.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Duplicated authorization code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "The set_admin function includes duplicated code in crates/core/admin.rs:40-47, which is the same code as the authorize function. We classify this issue as an informational maintainability, which could be error-prone. issue because duplicated code impacts",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Repeated validation on callback handling",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "The deposit_callback and sync_callback functions validate that the vault contract has the strategy and share asset contracts congured in storage at the beginning of their execution in crates/core/vault/holdings.rs:495-501 and lines 581-583. These same checks are already performed at the beginning of the deposit and synchronization execution ows. However, it is not possible to have them unset before the reply is handled by the mentioned functions, therefore making them redundant. A similar instance was found in crates/core/hub/position.rs:1129, aecting the validation of the advance feature being enabled. We classify this issue as an informational increases gas costs. issue because repeated code unnecessarily",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Unoptimized deposit asset validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "Validation on the received collateral asset is not done in the hub or vault contracts. Therefore, it will cause an error in a later stage of the execution ow, unnecessarily wasting gas. if an incorrect asset is submitted, The following Core messages of the hub contract are aected:  CoreMsgKind::MintOnBehalf  CoreMsgKind::Mint  CoreMsgKind::Repay  CoreMsgKind::DepositOnBehalf  CoreMsgKind::Deposit",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Overow checks are not enabled for the release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/vanilla-cw/amulet-hub/Cargo.toml  contracts/vanilla-cw/amulet-mock-strategy/Cargo.toml  contracts/vanilla-cw/amulet-vault/Cargo.toml  crates/core/Cargo.toml  crates/cosmwasm/api/Cargo.toml  crates/cosmwasm/iface/Cargo.toml  crates/cosmwasm/parse/Cargo.toml  crates/cosmwasm/vanilla/Cargo.toml  crates/storage/Cargo.toml  xtask/Cargo.toml While enabled implicitly through the workspace manifest, future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Misleading comments in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-01-08 Audit Report - Amulet v1.0.pdf",
        "body": "The hub contract included detailed comments on the user who is expected to interact with some of the functions. Several of them detailed that the function should return an error if The sender is not the vault creator or admin. Although not a security issue, this is misleading for the current implementation because both the vault creator and the admin are the same address. Therefore, referencing the same role twice. The aected comments can be found in lines crates/core/hub/config.rs:336, 362, 395, 423, 451, 479, 507, 535, 581, 609, 637, 665, and 693. the allocate_dormant_state_surplus function includes the following Similarly, the in crates/core/hub/position.rs:743: Returns the total value of comment Reserves payment, if any. This is incorrect as the function only allocated surplus to the treasury contract. Therefore, it only returns Ok(None), and it is not possible to perform any reserve payment.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Unusable Reconcile and ReceiveUnbonded messages break the reconciliation process",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-02-07 Audit Report - Amulet Neutron PoS Strategy v1.0.pdf",
        "body": "In contracts/strategy/neutron-pos/msg.rs:69-74, the strategy contract allows calling the Reconcile and ReceiveUnbonded messages. However, both messages in the cannot contracts/strategy/neutron-pos/contract.rs:225-227. validation currently permits only the Deposit and Donate messages to attach funds and triggers an error if funds are attached to other messages. validation The properly called due be to to funds require This becomes problematic because both the Reconcile and ReceiveUnbonded in be messages receiving the contracts/strategy/neutron-pos/execute.rs:430 unbonding in function line contracts/strategy/neutron-pos/msg.rs:106 does not consider Reconcile and in leading ReceiveUnbonded contracts/strategy/neutron-pos/contract.rs:226 if funds are attached to these messages. to or when is_payable Furthermore, messages, \"payable\" attached amount cover error 457. fees the an as to in Consequently, the reconciliation process cannot be triggered because Neutron IBC fees cannot be sent, and the unbonded funds cannot be sent back to the contract, preventing the contract from working as expected.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Pending deposits are incorrectly deducted twice and stuck in contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-02-07 Audit Report - Amulet Neutron PoS Strategy v1.0.pdf",
        "body": "In contracts/strategy/neutron-pos/reconcile/state_machine.rs:156, the the function restart_delegate_tx ReducePendingDepositByInflightDeposit command with the in-ight deposit for amount when is StrategyState::NoDeposits. This is problematic because the pending deposit DelegateTx::Failed reconciliation retrying phase calls the already contracts/strategy/neutron-pos/reconcile/state_machine.rs:125. TransferTx::Pending reduced phase, during the as seen in Consequently, DelegateTx::Pending keeps failing, causing users' deposits to be stuck in the contract. deposits will repeatedly deducted pending the be if the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. The delegation slot is not decreased when losses are detected",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-02-07 Audit Report - Amulet Neutron PoS Strategy v1.0.pdf",
        "body": "In contracts/strategy/neutron-pos/reconcile/state_machine.rs:371-381, the start_reconcile_process function determines whether a loss has occurred (i.e., slashing penalty applied to the validator) by checking the dierence between queried delegation balance and expected delegation balance. The expected delegation balance comes in contracts/strategy/neutron-pos/reconcile.rs:470, which records the amount of funds delegated. slot_delegated function from the The problem occurs when a slashing penalty occurs, and the delegation amount is not deducted from the detected_loss amount. The IncreaseDetectedLosses command does not handle this, as it only increases the slot_detected_losses for the total deposits to be synced later. Assume a scenario where there is a delegation of 100 funds. In the rst reconciliation, a slashing penalty of 10 is applied, and the remaining funds delegated on-chain is 90 (100-90). However, the slot_delegated amount remains at 100. In the second reconciliation, no slashing action occurred, so the ICQ result returns 90. This is problematic because the reconciliation process will compute the detected loss to be 10 in (100-90) The contracts/strategy/neutron-pos/reconcile/state_machine.rs:376. correct detected loss value should be 0 because no slashing penalty is actually applied. Consequently, the detected loss will be incorrect, causing a loss of funds for the users.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Reconciliation height is not updated after completion",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-02-07 Audit Report - Amulet Neutron PoS Strategy v1.0.pdf",
        "body": "after_withdraw_tx In contracts/strategy/neutron-pos/reconcile/state_machine.rs:469-473, the function the the SetLastReconcileHeightToCurrentHeight ActiveDepositsPhase to Idle. This is problematic because when the reconciliation process is called again, the start_reconcile_process function in line 343 will use the outdated last_reconcile_height value, causing the fees computation, loss detection, and unbonded requests to be triggered again. does command call setting not when Consequently, triggering reconciliation with the outdated reconciled height will cause larger fees to be computed, excess deduction of slashing penalty, and unnecessary unbonded requests to be issued, resulting in a loss of funds.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Excess funds consumed due to storage not being cleared",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-02-07 Audit Report - Amulet Neutron PoS Strategy v1.0.pdf",
        "body": "In contracts/strategy/neutron-pos/reconcile/state_machine.rs:623-627, the restart_delegate_tx function sets the in-ight deposit to include the fees if the fee recipient is not specied. This happens during the DelegateTx::Failed phase with pending in-ight deposits and fees. The issue is that the fee is not cleared after adding to the in-ight deposit. Assume the rst reconciliation is called with an invalid fee recipient on the remote chain, so it fails. In the second reconciliation call, the reconciler does not provide the fee recipient. This causes the in-ight deposit amount to be updated to include the fees, as seen in line 626. The second reconciliation fails, and a third reconciliation is required. Since the in-ight fees are not removed from the storage, and the in-ight deposit includes it, excess funds will be sent to the remote chain in line 632 if the reconciler provides a fee recipient or line 627 if not. Consequently, the sent funds will unknowingly consume excess ICA balance instead of the delegation rewards, potentially causing the TransferInflightUnbonded command to fail due to insucient funds.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Interchain accounts cannot be accessed if the channel closes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Amulet/2024-02-07 Audit Report - Amulet Neutron PoS Strategy v1.0.pdf",
        "body": "The strategy contract creates interchain accounts on the remote chain for each validator to perform staking operations. The interchain messages will be processed in the same order ow due to the ordered channel and close if an error occurs in the sudo handler or a timeout occurs. since there are no entry points The issue arises the RegisterInterchainAccount message to recover access to the interchain account in case the channel closes. This can happen when the SudoMsg::Timeout message gets entered or when the reconcile function called by the handle_response function fails, see contracts/strategy/neutron-pos/sudo.rs:116. the admin to call for Consequently, the admin cannot recover access to the interchain account, preventing the protocol from working as expected.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "1. ASTRO pools can be voted for emissions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-08-20 Audit Report - Astroport vxASTRO Updates v1.0.pdf",
        "body": "In the contracts/emissions_controller/src/execute.rs:211-221, whitelist_pool function returns an error if the pool is one of the outposts ASTRO pools. This means that if an ASTRO pool is congured in the outposts, the pool cannot be voted on because they already receive at emissions, as indicated by the comment in line 211. However, this validation can be bypassed if a user whitelists the pool before the contract owner updates the pool via the update_outpost function. This causes the pool to remain whitelisted, and users can vote on it to receive emissions. Consequently, in contracts/emissions_controller/src/execute.rs:211-221 is not enforced, allowing the pool to receive voted and at emissions, which is not the protocols intended behavior. validation the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. The QueryWhitelist query might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-08-20 Audit Report - Astroport vxASTRO Updates v1.0.pdf",
        "body": "In contracts/emissions_controller/src/query.rs:101 the QueryWhiteList returns all whitelisted pools. Since pool creation is permissionless, there is no limit to the number of existing pools. Therefore, the whitelist may become very long, either due to a malicious actor or due to organic growth. In such a case, the query may not be able to complete due to exceeding the gas limit. Although this does not impact any other existing protocol logic, aside from this query itself, it can have security implications for other protocols using this query.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Previous owner retains contract migration privileges",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-08-20 Audit Report - Astroport vxASTRO Updates v1.0.pdf",
        "body": "contracts/emissions_controller/src/instantiate.rs:98 and In contracts/emissions_controller_outpost/src/instantiate.rs:57, the voting escrows contract migration admin is set to the emission controllers contract owner. This is problematic because the emission controllers contract owner may be transferred via the ProposeNewOwner and ClaimOwnership messages, but the previous owner retains contract migration permission. If the previous owner is compromised or malicious, the voting escrow contract can be migrated into a malicious code ID to steal users' funds. We classify this issue as minor because it can only be caused by the contract owner, which is a privileged account.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Multiple storage states are not exposed through smart queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-08-20 Audit Report - Astroport vxASTRO Updates v1.0.pdf",
        "body": "In multiple contracts, the query entry points do not expose some storage state values through smart queries. This forces third-party contracts and nodes to perform a raw query to read the stored value, which is error-prone and decreases user experience. Occurrences:  OWNERSHIP_PROPOSAL in contracts/emissions_controller/src/state.rs  OWNERSHIP_PROPOSAL, REGISTERED_PROPOSALS and PROPOSAL_VOTERS in contracts/emissions_controller_outpost/src/state.rs",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Inconsistent documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-08-20 Audit Report - Astroport vxASTRO Updates v1.0.pdf",
        "body": "contracts/assembly/src/contract.rs:86 a In Cw20ReceiveMsg should be processed. However, the contract code does not contain any logic to support such operation. comment states that a Additionally, CastVoteOutpost ExecuteMsg is not present in the comments between lines 82 and 104, describing all available functionalities.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Migrate handler does not support fee_share migration for all contract versions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-10-17 Audit Report - Astroport Fee Sharing v1.0.pdf",
        "body": "The fee_share storage eld is introduced in contracts/pair/src/state.rs:25, contracts/pair_concentrated/src/state.rs:43, and contracts/pair_stable/src/state.rs:32. This change requires a state migration for existing contracts deployed with an earlier version. However, this migration is not implemented for all contract versions. In contracts/pair/src/contract.rs:1336, the migrate function does not migrate the fee share state for the 1.3.0 and 1.3.1 contract versions. This is problematic because migrating from both versions will cause the Config storage state to be unable to serialize properly due to the required fee_share eld being unimplemented. Likewise, the pair concentrated contract does not implement the required migration for versions 1.2.4, 2.0.3, and 2.0.4, and the pair stable contract does not implement for in versions and and contracts/pair_concentrated/src/contract.rs:954-957 contracts/pair_stable/src/contract.rs:1071. 3.1.0, 3.0.0 seen as We classify this issue as minor because the contract migration admin can recover from this issue by implementing the state migration and initiating another contract upgrade.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Fee share implementation is not reected in the convert_config function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-10-17 Audit Report - Astroport Fee Sharing v1.0.pdf",
        "body": "the contracts/periphery/liquidity_manager/src/utils.rs:273, In convert_config function sets the fee_share to None. This is incorrect because if the pair stable contract implements a fee-sharing mechanism, the fee-sharing status will be incorrectly represented. We classify this issue as minor because future versions may be aected by the incorrect values in the convert_config function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Errors during the fee sharing transfer revert swaps",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-10-17 Audit Report - Astroport Fee Sharing v1.0.pdf",
        "body": "The fee share logic implemented for the pair, pair_concentrated, and pair_stable contracts dispatch a transfer to the fee_share.recipient with the appropriate fee share amount. in a contracts/pair/src/contract.rs:715. If the token transfers to the recipient errors, the entire swap transaction will revert. executed message Cosmos seen This with as is This error state can be introduced either unintentionally or intentionally. For example, if the recipient is in the token factory denom blacklist, it would cause an error to be thrown by the BlockBeforeSend hook. Also, a CW20 contract could be congured to purposefully error to revert all swap transactions. We classify this issue as informational due to its extremely low likelihood of occurrence. The Astroport community is expected to heavily scrutinize fee share recipients and have little incentive to cause such a disruption to the protocol due to potential reputation damage. Additionally, Astroport governance can take immediate action to remediate the situation by removing the fee share from the aected contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Edge case scenarios and functional requirements are not covered",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-10-17 Audit Report - Astroport Fee Sharing v1.0.pdf",
        "body": "The test cases for the codebase are inconsistent across the contracts despite targeting the same mechanism. Also, they do not cover certain edge cases, for instance:  Edge cases where 0 or MAX_FEE_SHARE_BPS is set as fee-sharing value.  Updating fee-sharing value.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. General code improvements",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2024-10-17 Audit Report - Astroport Fee Sharing v1.0.pdf",
        "body": "In several instances of the codebase, the code quality and readability can be improved:  The comments in contracts/pair_concentrated/tests/pair_concentrated_integrati and on.rs:1757 contracts/pair_concentrated/tests/pair_concentrated_simulatio n.rs:101 mention the fee value as 5%, while the implementation sets it to 10%.  contracts/pair/src/contract.rs:703 uses a hardcoded value of 10000, which can be converted into a constant.  The in contracts/pair_concentrated/tests/pair_concentrated_integrati on.rs:1744 mentions setting the fee_share to max+1, but it is set to 0 in the implementation. comment",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Owner loses their NFT if the auction ends without bids",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "The claim_nft function in impls/auction/mod.rs:254 is responsible for distributing the NFT and funds when an auction ends. If there are bids, the NFT is sent to the highest bidder, while the tokens are sent to the auction creator. However, causes a loss for the owner, as the NFT should be refunded if the auction fails. if there are no bids for the auction, the NFT is not refunded to the owner. This",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attackers can back-run allowance to buy NFT at a low price, causing a loss for the owner",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "To list an NFT for sale or auction, the owner must perform two transactions. The rst the marketplace contract, and the second transaction approves an allowance for transaction calls the list_nft_for_sale or list_nft_for_auction functions in contracts/marketplace/lib.rs:244 or 283. correctly the NFT in While both functions impls/marketplace/mod.rs:52-54 and impls/auction/mod.rs:59-61, they do not validate that the caller is the owner. This means anyone can list or auction the NFT for sale if the owner approves a valid allowance. the creator owns validate that This opens up an attack vector where an attacker can back-run the allowance transaction to list the NFT with a low price (typically under market value) and purchase it. Back-running means that the attackers transaction is executed immediately after the victims transaction is processed. An example attack scenario is illustrated below: 1. The owner approves an allowance for the marketplace contract. 2. The attacker back-runs the transaction to list the NFT with a low price",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. The attacker gains prot after selling the NFT at its market price. Although both the list_nft_for_sale and list_nft_for_auction functions are susceptible to this vulnerability, sophisticated attackers would use list_nft_for_sale, as it allows them to purchase the NFT at a lower price immediately before the owner or admin cancels the trade. Recommendation We recommend modifying the list_nft_for_sale and list_nft_for_auction functions so only the owner can list or auction their NFTs. Status: Acknowledged 3. Native funds are incorrectly transferred to the caller",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Incorrect logic condition check in the _admin_or_owner function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "In impls/admin_access/impls.rs:46-49, the _admin_or_owner function validates whether the caller is one of the admins or is the contract owner. However, the logic in line 47 checks that the caller is both the admin and the owner, which diers from the intended functionality. Since there can only be one contract owner, admins who are granted roles from the contract owner cannot call the privileged functions as expected.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Lack of validation for royalty leads to stuck funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "arch_nft in The contracts/arch_nft/lib.rs:120. The issue is that the constructor does not validate the royalty value to be less than the max BPS value of 10000 (see lines 96-98). new_default constructor contract denes a This is problematic because a royalty value larger than the max BPS value breaks the marketplaces in impls/shared/utils.rs:22-30 computes the royalty fees when concluding a trade. If the fee value exceeds 10000, the IntegerUnderflow error in line 30 will be triggered. apply_fee functionality. Specically, function the the claim_nft function will error Consequently, in impls/auction/mod.rs:297, reverting the transaction. This will result in the NFT and bidders funds being stuck in the contract, causing a loss of funds for the auction creator and the winning bidder.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Incorrect creator accounts implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "The account_manager contract in contracts/account_manager/lib.rs:105-131 allows users to create User and Creator accounts. Their implementations can be found in the impls/user and impls/creator directories. However, implements same contracts/user/lib.rs, which is incorrect. the Creator account contract dened in contracts/creator/lib.rs in functionalities contract account User the the as Consequently, the create_creator_account function will incorrectly create Creator accounts as User accounts, causing creators to be unable to create collections and breaking the protocols functionality.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Excess funds sent by users will be stuck",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "The marketplace contract allows sellers to decide whether they want to receive native or PSP22 tokens as the medium of exchange. When purchasing or bidding on the NFTs, the assure_transfer function in impls/shared/currency.rs:126-137 implements validation mechanisms to ensure the user sends sucient native funds. However, no logic has been implemented to refund the user if they have sent excess funds. If a user sends more funds than required, those tokens will be stuck in the contract. This can also happen when the traded currency is PSP22 tokens, but the user included native tokens when calling the functions. aected The impls/marketplace/mod.rs:123, respectively. functions are buy_nft, 178, buy_batch, in impls/auction/mod.rs:194, bid_nft and and While blockchains generally do not protect users from sending funds to the wrong accounts, reverting extra funds increases the user experience.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Irrecoverable protocol functionalities due to ownership transfer and renouncement",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "The account_manager contract allows users to create accounts as individual contracts in contracts/account_manager/lib.rs:105-131. The contracts are instantiated with a hard-coded salt and then added to the mapping with the key entry as the callers address. This approach limits the caller from creating only one instance of the User and Creator account types, as the AccountAlreadyExists error will be raised if the account already exists. The instantiated contracts implement an Ownable trait, allowing functionalities to transfer and renounce ownership. If the user wants to create a new account type (e.g., because contract ownership was transferred or renounced by mistake), the transaction will fail.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Role-based access control assignment does not follow best practices and centralization issues",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "The marketplace contract implements a role-based access control mechanism. It denes two roles: owner and admin. The roles are set function in contracts/marketplace/lib.rs:210-213. in the constructor However, those roles are both assigned to a single AccountId, which is not a valid approach. Role-based access control mechanisms should follow separation of concerns, with each role responsible for a specic aspect of a conguration or certain privileged operations. Assigning multiple roles to the same entity defeats the purpose of implementing a role-based access control scheme. Similar issues can be observed in contracts/account_manager/lib.rs:92-95 and contracts/collection_fabric/lib.rs:116-119. Additionally, the privileged roles should only be responsible for maintaining and conguring the protocol itself. If the privileged roles can bypass the business logic to forcefully change the state of the contract, they introduce centralization concerns. could bypass the ownership check to execute the For example, admin roles cancel_auction function in impls/auction/mod.rs:166-168, the start_auction function in impls/marketplace/mod.rs:95-97. This may be undesired for the auction/listing creator. cancel_listing 133-135, function lines and the in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Identical token IDs may lead to confusion",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "arch_nft The impls/collection/impls.rs:108, allowing the owner to create new NFTs. mint_with_metadata implements contract a function in The issue is that the owner needs to provide an ID when creating an NFT. The ID parameter is an enum that contains many variants, such as U8(u8), U16(u16), U32(u32), U64(u64), U128(u128), and Bytes(Vec<u8>). This means the owner can mint Id::U8(1) and Id::U64(1) as two dierent NFTs but will be represented as token ID 1 on the front end, potentially confusing users.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Redundant validations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "The buy_nft function in the marketplace contract allows a user to purchase a listed NFT. Several validations are implemented to ensure that only a valid transaction can be completed. In particular, the assure_transfer function in impls/marketplace/mod.rs:148 ensures that the native funds sent are sucient to cover the cost of the NFT. However, this validation is redundant because the transfer_from function in line 157 also performs the validation in impls/shared/currency.rs:181. Consequently, consumed for the transaction. the same validation is performed twice, unnecessarily increasing the gas Furthermore, the bid_nft function validates the auctions start time to be larger than the timestamp in impls/auction/mod.rs:210-212. This validation is redundant current because the start_auction function in impls/auction/mod.rs:141-143 already checks it, which must be called before the bidding phase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. NFT can be listed as free",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "the list_nft_for_sale function does not In impls/marketplace/mod.rs:42, validate the price parameter, representing the NFT sale price. This means it is possible to list NFTs for free, which may cause creators to lose them if a misconguration occurs.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Unnecessary account_id function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "contract arch_nft The in contracts/arch_nft/lib.rs:152-154, which returns the contract address. This function is not required because the caller needs to know the contracts AccountId to call it, defeating the functions purpose. account_id function denes the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Code optimizations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "The buy_batch function in impls/marketplace/mod.rs:178 allows users to purchase multiple NFTs. The function accepts a vector of listing IDs, and for each entry, it ensures a listing is associated with it and validates its state in lines 181-199. Subsequently, the function parses the vector again to compute the required native funds to be transferred along with the call in lines 201-213. Those operations are performed in two separate fold executions on two separate iterators, which can be simplied into a single pass over the vector. Additionally, the buy_batch function does not validate the ID vector to contain unique values. If there are duplicate IDs, the whole transaction will be reverted. This could be avoided by ltering unique elements in the vector.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Missing validation on strings may lead to cross-site scripting",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "the token_name, token_uri, and In contracts/arch_nft/lib.rs:123-125, additional_info attributes are not validated or sanitized. If these values are displayed in raw format on the dApp front end, they may be parsed as JavaScript or HTML, opening up client-side attack vectors that may target end-users, such as cross-site scripting (XSS). This issue is also present in the collections creation and user object attributes.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Unused errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archisinal/2024-08-21 Audit Report - Archisinal Marketplace v1.0.pdf",
        "body": "In traits/mod.rs:21, codebase. However, AuctionHasNoBids errors are not used. the ArchisinalError enum lists all errors used across the and the CreatorIsNotCaller, CallerIsAuctionOwner,",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    }
]