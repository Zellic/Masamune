[
    {
        "title": "1. Issue",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/pTokens/20210212_pTokens Bridges Ongoing Audit Report.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Attackers can cause a consensus failure by sending coins through IBC",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "in x/tariff/keeper/allocation.go:30 During the execution of the BeginBlocker, a panic occurs in the AllocateTokens the function SendCoinsFromModuleToAccount function returns an error. This error can be caused if a zero-amount coin is passed to the SendCoinsFromModuleToAccount function. Currently, there is no check in the AllocateTokens function that prevents a coin with a zero amount from being added to coins. if An unsuspecting user or an attacker could cause such a panic by sending a coin with an amount in the [10_000, 19_999] range through IBC. Since the scale factor is 10_000 and the result is truncated, this would cause the sending of coins with a zero amount using the SendCoinsFromModuleToAccount function, which would cause a panic as described above. Consequently, the chain will be permanently halted since the error is not recoverable without pruning the state. A test case able to reproduce this issue can be found in Appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Panic in SendCoinsFromModuleToAccount causes chain to halt",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "When the BeginBlocker is executed, AllocateTokens function dened in x/tariff/keeper/allocation.go:30. there is a possibility of a panic in the This panic occurs when the SendCoinsFromModuleToAccount method of bankKeeper encounters an error. One such error can arise if the recipient's address is listed in the Bank modules blacklist. The purpose of blacklisting is to prevent users from sending funds to module accounts or to proactively block specic malicious accounts as determined by the governance. An attacker could forge a message to send coins to these blacklisted accounts, causing a panic that halts the chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Fee will round to zero for small fees or amounts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "The SendPacket function in x/tariff/keeper/keeper.go:81-82 introduces a rounding issue that can occur when the bpsFee or the fullAmount take small values. The rounding will be in favor of the user and will round down to 0. using example, For in docs/modules/tariff.md, amounts under 10000uDenom will have a fee value that rounds down to 0. TransferFeeBps from the value docs the of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. A large number of DistributionEntities could slow down and even halt the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "The AllocateTokens function dened in x/tariff/keeper/allocation.go:7-33 is responsible for distributing fees to DistributionEntities during the BeginBlocker. Since it performs an unbounded loop through all the registered DistributionEntities, it could cause the BeginBlocker execution to take more time than expected. This could slow down the chain or, in the worst case, halt the node because Tendermints timeouts are hit. classify issue We DistributionEntities. this as informational since only governance can register",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Remove unused functions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "There are some instances of unused functions in the codebase:  The String function in x/tariff/types/params.go:139.  The GetAccount function in x/tariff/types/expected_keeper.go:11.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Use of magic numbers decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf",
        "body": "In the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. In x/tariff/types/params.go:85, transferFeeBPS is greater than a hard-coded value of 10000. there is a validation check if the value of In x/tariff/keeper/keeper.go:81, the values 4 and 1 are hard-coded.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. addr with a length that is not a multiple of 0x20 may lead to incorrect results",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "contracts/v0.8/PrecompilesAPI.sol:33, In the resolveAddress function, the provided addr length should be a multiple of 0x20, but a user can provide any arbitrary length of bytes as input and there is a possibility that the user will receive incorrect output because the current code does not validate the length of the provided addr param. execution of during the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Address lookup via PrecompilesAPI.lookupAddress fails due to incorrect memory access",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "PrecompilesAPI.lookupAddress The in contracts/v0.8/PrecompilesAPI.sol uses Yul to call the lookup_address FEVM precompile. However, accessed by using mload(actor_id) instead of using a xed length of 32 bytes. mload loads a word from memory at the given address. actor_id is a static variable of the type uint64, not a memory pointer. This leads to incorrect memory access. the actor_id length is incorrectly function library The same issue is present in the PrecompilesAPI.getActorType function in line 73.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Hardcoded outputSize results in data loss during a delegatecall",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "contracts/v0.8/utils/Actor.sol:87, In MAX_RAW_RESPONSE_SIZE parameter is used to restrict the outputSize of the delegatecall Yul instruction, while FVM actors can return data sizes greater than 0x300. Due to the hardcoded output length, the return data is truncated, resulting in unexpected behavior of the call function. the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Hardcoded GAS_LIMIT used to call precompiles may lead to gas exhaustion",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "The library uses a GAS_LIMIT constant to specify the maximum amount of gas a precompile can consume. The actual gas consumption depends on the actual FEVM implementation, which may change over time. This makes it impossible to predict the Actor.call precompile execution gas cost, and hence with a hardcoded GAS_LIMIT, the precompile call could run out of gas.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing sanity check for codec value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "According to the comment in contracts/v0.8/utils/Actor.sol:49, codec should always be cbor. However, the user can provide any codec, while the Solidity code assumes it to be cbor. Without validation of the codec parameter, there is potential for incorrect results if the FEVM returns a response that is encoded with a dierent codec than cbor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Calling the actor precompile conceals the revert reason",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf",
        "body": "The Actor library in contracts/v0.8/utils/Actor.sol performs a delegatecall to the actor precompile. However, in the event of a revert, the revert reason is suppressed and not returned. This could negatively impact the developer and user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. Inconsistent admin duplicate validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-07-13 Audit Report - Astroport Concentrated Liquidity Pool with Injective Orderbook Integration v1.0.pdf",
        "body": "The free-granter contract performs validation of the submitted admin addresses in contracts/periphery/fee_granter/src/state.rs:15-23. However, no checks on address duplication are performed in this function. While the update function performs its own separated checks, this is not the case with the instantiation function. As there is a maximum of two admins, duplicate addresses would limit operations. tWe classify this issue as minor since admin addresses can be updated to remove duplicated addresses.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Gas is not consumed if the transaction returns an error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The ConsumeGas function is used in the lend module to increase the GasMeters consumed gas by a set amount. Within the Comdex appchain, these amounts are pre-dened based on anticipated values. This method is problematic because gas is only consumed after successful execution and not in the event of an error. Even if the function returns an error, computation still occurs and gas should be consumed. The ConsumeGas function is called in lines:  x/lend/keeper/msg_server.go:30  x/lend/keeper/msg_server.go:44  x/lend/keeper/msg_server.go:58  x/lend/keeper/msg_server.go:72  x/lend/keeper/msg_server.go:84  x/lend/keeper/msg_server.go:96  x/lend/keeper/msg_server.go:108  x/lend/keeper/msg_server.go:121  x/lend/keeper/msg_server.go:135  x/lend/keeper/msg_server.go:147  x/lend/keeper/msg_server.go:176  x/lend/keeper/msg_server.go:190 In these occurrences, the predened gas amount is not consumed in the event of an error because the ConsumeGas invocations are located at the end of the transaction execution. Consequently, a malicious actor is able to spam transactions that trigger errors in the middle of the execution without being charged the dened gas fees.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Input-dependent iteration in Lend modules BeginBlocker may slow down or stop block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "BeginBlocker is a function that is executed at the beginning of every block, even if there are no transactions. It should have a light and constant computational footprint to avoid any negative impacts on block production. Too much computational weight at the beginning of each block may cause block production to slow down, or even surpass Tendermints propose timeout, which results in a halt of the blockchain. Consequently, it is best practice to make the BeginBlocker execution independent, or at least sub-linearly dependent, from the amount of data stored on-chain. In the Lend module in x/lend/abci.go:13-23, the execution loops through all stored borrows in order to balance stable rates. Since borrows cardinality will grow with chain adoption or due to a spam attack, the issue described above will occur.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Batch mechanism in Liquidation modules BeginBlocker may allow malicious manipulations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "the Liquidation In x/liquidation/keeper/liquidate_borrow.go:11-113 x/liquidation/keeper/liquidate_vaults.go:12-93, through all the borrow positions in order to check the collateral ratio health. BeginBlocker, modules specically in and the execution loops Since positions cardinality will grow with chain adoption or due to a spam attack, in order to defend against issues like Input dependent iteration in Lend modules BeginBlocker may slow down or stop block production, functions implement a batching mechanism. It splits borrowing positions slice into dierent partitions of params.LiquidationBatchSize size. This implies that it could happen that positions that are not healthy in a block interval but are not included in a batch of that interval are not liquidated. This implementation also exposes a vulnerability where a malicious actor could manipulate the mentioned slice in order to create positions that will not be liquidated in a dened interval.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Error raised in BeginBlocker could lead to state corruption",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "In x/liquidation/abci.go:13-27 and x/lend/abci.go:13-23 both Lend and Liquidation modules wrap an ApplyFuncIfNoError function in order to gracefully handle errors. BeginBlockers execution logic their in This function logs errors but has no control over the state and no mechanism to revert partial updates. This implies that if an error is raised in the middle of an execution ow, the execution will stop and log the error, but no action will be taken in order to revert state updates that have been done leading to state corruption.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Incorrect conditions when rebalancing stable rates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "In x/lend/keeper/iter.go:203-209, the RebalanceStableRates function checks conditions to see if rebalancing must be triggered. The Commodo documentation states that stable rates should be decreased if    + 20% and increased if  + 20%         90% . However, the actual implementation is using dierent conditions. Stable rates are decreased if    + 20% and increased if,  + 20%      >  90% . This leads to a malfunctioning stable interest rate model. An attacker may create multiple accounts with borrowing positions with a stable interest rate for an asset and ensure that the borrowing rate is slightly less than 20% so that the increase condition will never be triggered to rebalance the stable rate even though the utilization ratio hits more than 90%. When the utilization ratio hits 100%, it impacts lenders unable to withdraw their stable assets.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. FundModAcc allows funds to be sent to any module which may result in permanently lost funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The FundModAcc function in x/lend/keeper/keeper.go:1388 allows for the caller to specify any module name for funding. This is problematic because funds could be sent to a module that is not designed to handle them making them stuck in the module. The BankKeeper will return an error if the module name is invalid, but as long as the module name specied is valid, this function will allow for funds to be sent. While any address may call this function, we do not classify it as critical since users would not normally be sending funds directly to a module.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Borrow positions InterestAccumulated is not updated before liquidation, leading to an incorrect interest calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "in The x/liquidation/keeper/liquidate_borrow.go:11 does not update the borrow positions InterestAccumulated before performing the liquidation operations. LiquidateBorrows function As a result, a stale value of borrowPos.InterestAccumulated is being used in x/liquidation/keeper/liquidate_borrow.go:60, 76, and 94 to calculate the currentCollateralizationRatio, which leads to an incorrect value. a when addition, in In x/liquidation/keeper/liquidate_borrow.go:115, the stale value is used to set LockedVault.UpdatedAmountOut. This can become especially problematic when the borrow position is large and the interest has not been updated for a long time period, in which case the LockedVault.UpdatedAmountOut will be incorrect by a considerable amount. created borrow locked being is",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. BeginBlocker allows for errors to silently pass without being logged",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The functions called during BeginBlocker do not properly propagate error information. Instead, they continue execution and silently pass on the condition that caused the error. This results in suboptimal visibility of the conditions that are causing errors. example, For in x/liquidation/keeper/liquidate_vaults.go:12 simply executes continue when errors are encountered. LiquidateVaults function the While we acknowledge that an error or panic should not necessarily halt the BeginBlocker, it is best practice to log the conditions that are causing errors. In this example, a liquidatable vault could be silently passed because there is no visibility into which errors are being encountered or even which vaults caused the errors.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Missing validation checks in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "There are some missing validation checks in the following transaction message types as well as the Lend modules governance handler messages:  In x/lend/types/pair.go:18, validation is done only on CPoolName eld.  In x/lend/types/pair.go:25, validation on AssetToPairMapping is not implemented.  In x/lend/types/pair.go:29, validation on AssetRatesParams is not implemented.  In x/lend/types/gov.go:195, validation on AuctionParams is not implemented.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Vault collateralitzationRatio does not account for newly accumulated interest",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "LiquidateVaults The in x/liquidation/keeper/liquidate_vaults.go:12 uses an outdated value of because totalOut vault.InterestAccumulated is not updated. collateralitzationRatio calculate function to In fact, the vault interest is updated in line 71 when the CalculateVaultInterest function is called. This results in collateralitzationRatio not reecting the current accumulated interest. We report this as minor because unlike the issue Borrow positions InterestAccumulated is not updated before liquidation, in this case, LiquidateVaults updates the position so the LockedVault.UpdatedAmountOut is correctly evaluated.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Incorrect value provided to VerifyCollateralizationRatio function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The VerifyCollateralizationRatio function takes liquidationThreshold as the last parameter and uses it the collateralization ratio is greater than the liquidation threshold. to perform validation for whether or not in order In four dierent instances, the function is incorrectly called with the LTV instead of the liquidationThreshold:  x/lend/keeper/keeper.go:541  x/lend/keeper/keeper.go:662  x/lend/keeper/keeper.go:720  x/lend/keeper/keeper.go:1159 This implies that depending on the value of LTV set by governance, the function either always returns ErrorCollateralizationRatio or bypasses the validation which could lead to unexpected results.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. UpdateLendPairsRecords allows governance to update lend pairs even if they have liquidity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The UpdateLendPairsRecords function in x/lend/keeper/pair.go:39 allows governance to update either AssetIn or AssetOut for an existing lend pair. If that existing lend pair is currently being utilized, this could have unintended consequences. Based on the documentation it does not seem that there is any specic reason for allowing updates of lend pairs.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. AddAuctionParamsData does not prevent existing data from being overwritten",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The AddAuctionParamsData function in x/lend/keeper/pair.go:227 does not ensure that existing data with the same key does not exist before saving the provided AuctionParams. This allows governance to overwrite existing data. We classify this as a minor issue because only governance can call this function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. AddAssetRatesParams returns incorrect error message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "The AddAssetRatesParams function in x/lend/keeper/pair.go:200 returns the incorrect error \"Asset Rates Params not found\" when the record already exists.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. CLI uses ags instead of arguments to parse proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "In  x/lend/client/cli/tx.go:437,  x/lend/client/cli/tx.go:523,  x/lend/client/cli/tx.go:778, and  x/lend/client/cli/tx.go:901, for the commands the CmdAddNewLendPairsProposal, CmdAddPoolProposal, and CmdAddNewAssetRatesParamsProposal, CmdAddNewAuctionParamsProposal governance proposals currently receive a proposal le as a ag.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Unneeded positivity validation for unsigned integers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "the ValidateBasic functions in x/lend/types/tx.go validate that the ID All parameter is a positive number. As unsigned integer type can never be negative, those checks are redundant. Therefore, they can be removed.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Unnecessary aliases pattern increase technical debt",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "are there Currently, in x/lend/types/expected_keepers.go, while the keeper uses the functions from alias.go that reference expected/keeper.go. Having an alias.go le dening all functions of external modules is not necessary and decreases maintainability. external modules functions dened some for",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Duplicated ValidateBasic invocation in CLI",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf",
        "body": "Some CLI commands dened in  x/lend/client/cli/tx.go:426,  x/lend/client/cli/tx.go:517,  x/lend/client/cli/tx.go:615,  x/lend/client/cli/tx.go:693,  x/lend/client/cli/tx.go:761,  x/lend/client/cli/tx.go:894, and  x/lend/client/cli/tx.go:986, call the msg.ValidateBasic function before calling GenerateOrBroadcastTxCLI or GenerateOrBroadcastTxWithFactory. As msg.ValidateBasic is already called inside GenerateOrBroadcastTxWithFactory, this is an unnecessary and duplicated invocation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attackers can block pool tuning by voting on many dummy pools",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "In the contracts/generator_controller/src/contract.rs:398-416, tune_pools function attempts to process each pools votes in an unbounded iteration. In the case that the number of pools is too many, the execution may run out of gas and fail. An attacker can use this loop to block pool tuning: 1. The attacker creates many addresses and stakes xASTRO for minimum voting power",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Finally, the tune_pools function will attempt to process all child contracts added by the attacker in line 399. The attack will succeed when the function fails due to an out-of-gas error. As a result, the TunePools message will always fail, preventing majority-voted pools from receiving allocation points. Please refer to the test_jam_tuning test case for the attack scenario mentioned above. Recommendation We recommend implementing a whitelist of liquidity pool contracts that can be voted on. Status: Resolved 2. Proposals message order not enforced on IBC execution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. KickBlacklistedVoters missing from documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "In contracts/generator_controller/src/contract.rs:89-108, controllers ExecuteMsg::KickBlacklistedVoters is not dened. documented. messages execution are the generator the However,",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Unnecessary CW20 sender validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "contracts/assembly/src/contract.rs:170, In contracts receive_cw20 function performs address validation for the sender parameter of the CW20 message. This is unnecessary because the sender parameter comes from info.sender, validated by Cosmos SDK already. assembly the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Unnecessary conversion to lowercase in addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "The contracts within scope used the addr_validate_to_lower helper function to sanitize addresses. Since CosmWasm 1.0.0, the addr_validate utility also validates address capitalization, hence making it redundant to perform this check manually.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Misleading error messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf",
        "body": "In contracts/assembly/src/contract.rs:680 and 683, the assembly contracts update_ibc_proposal_status function returns Unauthorized errors even for cases that are not related to authorization, which can be misleading for users. This is the case if the proposal.status does not match one of the expected ones in line 671. This also happens if config.ibc_controller is congured to None, the if statement in line 669 will result in an Unauthorized error.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Missing denom validation when adding incentives could lead to insucient funds error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "contracts/incentives/src/helpers.rs:95-100, In validate_incentive_schedule function lacks validation to ensure that denomination matches the incentive denomination. the the sent This is problematic because it allows potential attackers to create an incentive schedule with a dierent denomination as long as the amount sent is correct. Consequently, due to an insucient funds error. legitimate users may encounter diculties in claiming their rightful rewards A test is reproducing test_incorrect_denom_deposit test case. issue case this provided in the Appendix in the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Incorrect calculation when simulating with multiple routes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In contracts/oracle/wasm/src/helpers.rs:145-160, the add_route_prices function loads the price source for the denom and multiplies it with the current price. This is incorrect because the third route assets currency is not considered. To illustrate, assume a price source is created with three route assets (e. g. ATOM => MARS => OSMO) while the base denom is congured as USDC. The rst route asset will be simulated in Astroport, making the price currency MARS. After that, the function loads the MARS price from storage and multiplies it, resulting in the price currency becoming USDC. The problem arises when multiplying with the third route assets price, OSMO. When the price source is retrieved, the price currency is expected to be OSMO, not USDC. The function will calculate the price as follows:   =               This is incorrect, because the price currency after the second route asset multiplication (MARS) is not denominated as the third route assets currency (OSMO). Consequently, introduces a aw in the calculation process. this discrepancy in the expected currency versus the actual currency",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Utilization rate can be exploited to surpass 100% for new markets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In contracts/red-bank/src/interest_rates.rs:290-294, the utilization rate of a market is determined by the ratio of total debt divided by total collateral. If a new market is instantiated with zero deposits, an attacker can inate the utilization rate to steal funds from the contract. An exemplary step-by-step attack follows: 1. ATOM market is instantiated. 2. The attacker becomes the rst depositor and deposits 1 uatom, increasing the markets total collateral. 3. The attacker donates 1000 ATOM to the contract directly",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. The attacker receives around 84000 ATOM after 10 seconds due to the inated utilization rate. For more information on this type of attack, please refer to the Silo Finance Vulnerability Disclosure. A test case reproducing this issue is provided in the Appendix in the zero_deposit_poc test case. Recommendation We recommend limiting the utilization rate to a maximum value of 100%. Status: Resolved 4. Removing whitelisted denoms causes leftover rewards to get stuck",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Duplicated denoms might cause incorrect whitelist counts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "contracts/incentives/src/contract.rs:173 In the execute_update_whitelist function does not dedupe denoms in the add_denoms and remove_denoms vectors. 187, and This is problematic because providing duplicate denoms to be added or removed would inate the whitelist_count variable, causing an incorrect state stored in the contract. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Oracle centralization risks with Fixed price sources",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In the current design, the owner can post arbitrary prices to the oracle using a Fixed price and source contracts/oracle/osmosis/src/price_source.rs381-392. not validated, and every value is accepted. contracts/oracle/wasm/src/price_source.rs:184-195 Prices are in This can be problematic since an attacker that gets access to the private key of the owner can arbitrarily manipulate prices without any restrictions. For example, the attacker could set the price of all assets to 0, which would allow the attacker to liquidate all users at their loss. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Misconguring tolerance value to be higher than window size causes incorrect price reported",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "the contracts/oracle/wasm/src/price_source.rs:316-321, In query_astroport_twap_price function iterates over all snapshots to nd those whose period falls within a specied tolerable window. This window is dened as the period ranging from the window size minus tolerance to window size plus tolerance. This calculation implies that the window size exceeds the tolerance period. Suppose the owner miscongures either the tolerance to be higher than the window size or the window size to be lower than the tolerance. In such situations, the above assumption will not hold, and the tolerable window period will not be eectively enforced. Consequently, the valid tolerable window period could be a value smaller than window size minus tolerance or higher than window size plus tolerance, aecting the nal price reported. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Removing price sources in the oracle could stop reward collector operations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In contracts/oracle/base/contract.rs:106, RemovePriceSource messages in order to remove price sources from the oracle. the contract owner can execute However, the removal of asset prices could have a detrimental impact on the operations of the swapper and reward collector contracts. Specically, in contracts/swapper/astroport/src/route.rs:91-92, the swapper retrieves oracle prices during a swap process. If the owner proceeds to remove the price source associated with the fee_collector_denom or the safety_fund_denom, the swap operation will encounter an error. This would render it impossible to carry out asset swaps within the reward collector.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Missing prerequisites check when adding a Pyth price source",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In and contracts/oracle/wasm/src/price_source.rs:184 contracts/oracle/osmosis/src/price_source.rs:381, when validating a Pyth price source, no validation is performed to enforce prerequisites. In fact, since Pyth prices are denominated in USD, a price source from USD to base_denom is needed in order to compute prices correctly. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/address-provider/Cargo.toml  contracts/incentives/Cargo.toml  contracts/oracle/base/Cargo.toml  contracts/oracle/osmosis/Cargo.toml  contracts/oracle/wasm/Cargo.toml  contracts/red-bank/Cargo.toml  contracts/rewards-collector/Cargo.toml  contracts/swapper/base/Cargo.toml  contracts/swapper/astroport/Cargo.toml  contracts/swapper/osmosis/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Funds in the swapper contract can be stolen",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf",
        "body": "In contracts/swapper/base/src/contract.rs:155-182, the swap_exact_in function swaps Coins dened in coin_in input parameter without checking that they are provided by the user in info.funds. This vulnerability enables potential attackers to seize all the coins within the contract by sending swap messages with specically chosen coin_in parameters. We classify this issue as informational because the swapper contract is not intended to hold any funds, as the TransferResult message will distribute all the funds out.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Missing tax deductions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "The stable yield manager does not deduct taxes. While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is small.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Price oracle block height not validated which may return out of date values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "get_mirror_asset_oracle_uusd_price in The contracts/delta_neutral_position/src/util.rs:39-53 does not validate that the price information for the specied mAsset is up-to-date. Currently, the contract takes the returned rate and returns it as the valid uusd price for the mAsset to the caller without performing a block height validation to ensure that the price feed is accurate. The mirror price response includes both   last_updated_base and last_updated_quote values for this purpose. function The Mirror mint contract does provide the functionality to return an error if the price is not within the get_mirror_asset_oracle_uusd_price query does not currently provide the optional block_time parameter so this operation will not occur. block_time, seconds but the of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Loss of precision during fee calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "The contract EthereumManager performs multiplication after division while calculating the fee in line 185. This can lead to imprecision due to rounding.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Consider adding more validations to Solidity contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "Consider adding the following validations in the Solidity contract to prevent accidental value updates. 1. EthereumManager.sol: for CROSS_CHAIN_FEE_BPS to prevent any accidental update that can cause wrong fee calculation and result in loss of funds for the end-user. Consider adding upper limit an 2. EthereumManager.sol: Consider adding zero address validation while updating the FEE_SINK address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Delta neutral position should implement a migrate only if newer pattern",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "The delta neutral positions contracts are currently migrated in an asynchronous fashion. This is ne, but the pattern can be improved by adding validation to ensure that the migration is only occurring if the version supplied is newer.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. migrate_position_contracts allows anyone to perform migrations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "migrate_position_contracts The in contracts/delta_neutral_position_manager/src/contract.rs:144 does not restrict who can migrate the contracts. Currently, anyone can call this function and pass in whichever positions or position contract addresses they wish to migrate. While this is not inherently malicious, the best practice would be to restrict the entry-point. function We consider this issue to be informational since the code ID thats used after migration can only be set by the administrator.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Certain cross-chain and Terra transfers are overly permissive",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "public functions initiate_outgoing_token_transfer and The in process_cross_chain_instruction contracts/terra_manager/src/crosschain.rs:28 and 378 respectively are overly permissive. These functions are callable from any terra address, yet are only intended to be called by the Aperture strategy and manager contracts. In order to limit the attack surface of these contracts, it would be better to add access control to the contracts. found as",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Use of the term info may impact readability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf",
        "body": "delta neutral position contract The both and contracts/delta_neutral_position/src/rebalance.rs:123 represent contracts/delta_neutral_position/src/contract.rs:472 terraswap pool info. This may impact readability and maintainability of the code because the name may conict or be confused with info, which is commonly used to represent CosmWasm MessageInfo. info uses term the to in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. The moving average time limit can be incorrectly set to zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "In contracts/pair_concentrated/src/const.rs:49, the boundaries of the moving average time limit are dened as an including range between zero seconds and a week. since is However, contracts/pair_concentrated/src/state.rs:304 and it can be set to zero, could cause a division by zero error. ma_half_time denominator used the as in it",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Factory contracts ownership transfer freezes pair contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "During the handling of ExecuteMsg, the migration_check function dened in contracts/pair_concentrated/src/contract.rs:215-218 ensures that there is no pending ownership transfer in the factory contract. When the factorys new owner accepts their role by executing the ClaimOwnership message, all registered pairs are added to the PAIRS_TO_MIGRATE vector. When a pair is in this vector, the migration_check function returns an error and all the pair operations are disabled. The factorys new owner can then reactivate pairs by executing the MarkAsMigrated message. This implies that all pair operations will fail while even just one pair is not yet migrated. Such a situation may be caused by a migration issue or a compromise of the factory contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Unnecessary nested loops when initializing cumulative prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "When instantiating the contract, the cumulative price vector is initialized with default values in contracts/pair_concentrated/src/contract.rs:80-84. Within two nested loops, it is then veried that assets are not duplicated before pushing them to the relevant vector. As there can only be two assets, the usage of nested loops is unnecessary, increases code complexity, and reduces readability.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Incorrect error message for CW20 token swap",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "a Swap in operation When contracts/pair_concentrated/src/contract.rs:243-245, offer_asset is validated to not be a CW20 token. If it is, an incorrect ContractError::Unauthorized error is returned. performed is This provides a poor user experience as it may be dicult for users to identify the source of the error when executing a swap transaction with a non-native asset.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Unsafe math usage could lead to division by zero error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "The query_compute_d function is used to compute the current pool D value by invoking Calc_d and newton_d functions. However, if the pool has no liquidity yet (i. e. before the rst use of provide_liquidity), a division in contracts/pair_concentrated/math/math-decimal.rs:65. occur error zero can by A test case showcasing this issue is provided in the Appendix.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Unclear error message for a single-sided initial deposit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "The contract does not allow the rst deposit to be a single-sided one by returning an in only InvalidZeroAmount contracts/pair_concentrated/src/contract.rs:414-415. provided asset error one is if However, understanding why their liquidity provision is not successful. this error message is not self explanatory and may prevent a user from",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Unnecessary tax deductions are performed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "performing When packages/astroport/src/asset.rs:92. tokens native transfers tax deductions are performed in However, calculations. the function to compute tax always returns zero instead of performing actual",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Validation can be performed earlier",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "there is a check that In contracts/pair_concentrated/src/contract.rs:59, prevents the code from running if the amount of assets provided in msg.msg_info is dierent waom two. Since this information is always available, check_asset_infos and potentially abort the execution early to save resources. this check can be done before calling in contracts/pair_concentrated/src/contract.rs:377, the check for Similarly, invalid number of assets can be done before querying the pools and running check_assets.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Mismatch between comments and code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "In contracts/pair_concentrated/src/state.rs:261, the get_amp_gamma function state that the parameters stored in the future parameters will be returned in case the block time is greater than the value in self.future_time. the comments for However, parameters are also returned if the block time is equal to the self.future_time. contracts/pair_concentrated/src/state.rs:264, in the future",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Arithmetic operations can be optimized",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "In contracts/pair_concentrated/src/utils.rs:291, in order to get the index of ask_ind, a subtraction is performed. Given that ask_ind can be either 0 or 1, this is not the most ecient way to compute a bit ip. In contracts/pair_concentrated/src/utils.rs:415, a sum of two dierences is calculated to get to the the deviation, which is dened as the sum of the distances between the value of two deposits and the average deposit value. Given that there are only two elements, this computation is not ecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Duplicated fee address checks during Swap",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf",
        "body": "During the handling of Swap messages, fee_address is provided. there are multiple checks to ensure that the In contracts/pair_concentrated/src/contract.rs:747, an explicit check is made but it is not required since the check in line 748 depends on the logic in line 702 that already validated the existence of the fee address.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. No validation of IBC message timeout",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport IBC v1.0.pdf",
        "body": "The length of controller and satellite contracts in: IBC message timeouts is dened during the instantiation and update of  contracts/controller/src/contract.rs:36  contracts/satellite/src/contract.rs:44  contracts/satellite/src/state.rs:55 However, there is no validation of this timeout value, which could lead to timeouts being dened that are of zero value or very high, up to u64::MAX. This may prevent the execution of cross-chain interactions as messages may expire before they can be handled or, in the case of very high timeout values messages may remain active indenitely. We classify this issue as minor since it can only be caused by the contract owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Setting total supply incorrectly when registering a beta invitation will lead to failures when claiming and distributing tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:203-209 of the beta-game-launcher repository, the total supply value is not validated to be higher than the total required amount as seen in lines 398-407 and lines 526-535. If the total supply value is set to be lower than required, it would cause claim, token_distribute, or both to fail due to minting capacity reaching the maximum. This will cause users to be unable to claim their shares of game and fan tokens. Likewise, the admin would be unable to distribute main and game tokens to recipients, causing a loss of funds for the users and recipients.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Updating main token address may cause state inconsistency",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:146-148 of the beta-game-launcher repository, the address of the main token can be updated to a dierent value. If the main token address is updated while the contract has an existing config.main_token value, it would cause an inconsistency between the contracts state and the actual token balance held in the contract. As a result, this would cause a series of problems such as users being unable to withdraw their tokens due to insucient contract balance.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Decimals are not accounted for in calculation of main_token_amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "the beta-game-launcher repository, In contract/src/execute.rs:300 of the buy_amount is multiplied by the invitation_price to ensure that sucient main_token and main_token is invitation_price can have dierent numbers of decimal places, the calculation may be performed incorrectly. This could lead to a user being able to purchase at a lower price than expected. supplied. However, the game_token, as",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Equal value of sold amount and soft cap causes inconsistent evaluation of condition",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:371-373 of the beta-game-launcher repository, the claim function would evaluate passed as true only if the sold amount is higher than the soft cap value. This is inconsistent with the token_distribute functionality as seen in lines 508-510 since the execution would continue if the sold amount is equal to or greater than the soft cap value. In an edge case where both the sold amount and the soft cap value are equal, the claim function would determine the invitation as a failure but the token_distribute function would determine the invitation as a success. In a worst-case scenario, the users funds would be incorrectly distributed to the recipients which might cause slow users unable to have their funds refunded back due to insucient balance held in the contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Missing validation on main_token_distributions during update cong",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:154-156 of the beta-game-launcher repository, the distribution values in main_token_distributions are not validated as seen in lines 27-36. This means that theres a possibility that the sum of the distribution rate can be over 100%, potentially causing the token_distribute function in lines 515-524 to either distribute more funds than intended or fail due to insucient funds. We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Duplicate accounts creation would inate token total supply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In src/contract.rs:63-71 of the cw20 repository, duplicate accounts are not veried when creating initial accounts during the contract instantiation phase. If the same account address is passed twice in create_accounts, the accounts balance would be overwritten via BALANCES.save but total_supply would still record the balance amount of both. As a result, the tokens total supply would be inated. We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Owner and main_token addresses are not validated during instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:20 of the beta-game-launcher repository, during the handling of the Instantiate message, owner and main_token addresses are not validated. This may cause the contract to be initialized with invalid values. This issue is also present during the cong update phase in lines 146-152.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. cw20 is based on a legacy version of the CW20 standard",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In the cw20 repository there is a legacy implementation of cw20 token. As stated in that implementation repository :1 This contract is modied for the purpose of migration from a Columbus-4 cw20 token contract to Columbus-5. Using the ocial version of cw20 is strongly recommended for other usages Unlike the latest version, the legacy version does not support the marketing eld which is required in contract/src/execute.rs in lines 254-277. As a result, using the legacy version of CW20 token code id would cause register_beta_invitation functionality to fail due to the dierences between the latest CW20 contract token interface and the one used in this contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Incorrect contract name in cw20",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In src/contract.rs:21 of the cw20 contract, the CONTRACT_NAME is set equal to crates.io:cw20-base. This is the template contract name of the CW20 contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Centralization of NFT unlocking",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs:95-98 of the lock-nft repository, only the owner of the contract can unlock users NFTs and return them back to them. If the owner key is compromised, the remaining locked NFTs in the contract will be inaccessible.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Admin operations implement custom logic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In all contracts there is the concept of Admin, which is an account that has exclusive permissions to execute some messages. As there is already a battle-tested implementation of this that takes care of validation and its ready out of the box, it should be better to use that one instead of using custom logic.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. No error message for query of non-existent token",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/query.rs:28-35 of the lock-nft repository, users can query the owner of a token using an nft_address and token_id as the key. In the case that there is no token with such a key an empty string is returned as the owner. This leads to a worsened user experience as incorrect queries cannot be easily diagnosed.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  lock-nft/contract/cargo.toml  beta-game-launcher/contract/cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Canonical address transformations are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "While previously recommended as a best practice, usage of canonical addresses for storage is no longer encouraged. The background is that canonical addresses are no longer stored in a canonical Additionally, the codebase is more complicated with address transformations. format, so the transformation just adds overhead without much benet.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Typographical errors found in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf",
        "body": "In contract/src/execute.rs of the beta-game-launcher repository, there were several typographical errors found in lines 35-301. Specically, the word queal should be replaced with equal while the word worng should be replaced with wrong.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Setup function can be used by anyone to take control of the gateway contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the Solidity contract contracts/src/AxelarGatewayMultisig.sol the setup function can be called multiple times by anyone, allowing an adversary to take over control of the key privileged roles. This is due to the function being externally callable and not protected by any pre-condition other than not being callable on the implementation contract directly. However, since the storage contract the proxy this guard does not prevent unauthorized invocations. is that of This issue also applies to contracts/src/AxelarGatewaySinglesig.sol (out of scope).",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Non-unique key for identifying voting topics implementations may lead to lost proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the Solidity contract contracts/src/AdminMultisigBase.sol function the hash of msg.data is used to identify proposal topics. This value is used as a key to store the topic in the eternal storage contract (key-value store). However, msg.data simply encodes functions and parameters, meaning that repeated proposal of the same operation will result in the key being calculated with the same result. In this case, the previous proposal would be overwritten in storage and lost. msg.data can also be malleable due to dierent libraries or wallets adding trailing zeros which could lead to key mismatch (see issue Manual storage management in upgradability pattern used is error-prone and may lead to storage key conicts).",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Gateway contract address depend on token symbol only and might clash",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "Token contracts and burner contracts are deployed using the create2 opcode, in order to deterministically calculate the addresses on both sides. Since the initialization code remains constant for all tokens the only distinguishing factor for dierent deployments is the salt used in the address calculation. To this end, the codebase uses the hash of the token symbol. Since the token symbol becomes the only identier of an asset, tokens with the same symbol will clash, resulting in the same contract address. Eectively, only 3 bytes of input are used to produce a 32-byte hash value. This may lead to accidental overwriting of assets.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Expired polls can be voted on",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the x/vote/types/types.go module, the Vote method lacks a check whether the poll has been expired, allowing expired polls to be voted on.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Manual storage management in upgradability pattern used is error-prone and may lead to storage key conicts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "The Solidity smart contracts use an eternal storage pattern using a hash of an identier key as a manual storage pointer.. This introduces a source of potential errors since keys with the same name result in the same hash causing storage to be overwritten. The reverse can also occur if the source of the key calculation may be encoded slightly dierently by o-chain libraries. An example of this occurring is the msg.data eld used as a key in contracts/src/AdminMultisigBase.sol. This eld may have trailing zeros, depending on the wallet implementation used to interact with the smart contract, resulting in dierent key calculations and failure to look up the correct entry.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. ExportGenesis should return the genesis state instead of nil",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the x/axelarnet module, the genesis export returns nil.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Panic used for non-eligible validators in ination calculation breaks iteration for the other eligible bonded validator",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "Function handleTssInflation in x/reward/abci.go uses panic during the bonded validator iteration when a validator is found to be not eligible. This will skip the other eligible bonded validators.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Single invalid key causes subsequent valid keys to be skipped when batch-registering external keys",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the RegisterExternalKeys function in x/tss/keeper/msg_server.go, the iteration skips valid keys when an invalid key is present in the slice by returning from the method when it nds any validation error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. RouteIBCTransfer is not considering all the valid chain entries in case of error during iteration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf",
        "body": "In the x/axelarnet module message server function, the RouteIBCTransfers returns on encountering an error during iterations. This will cause the method to skip all other entries in the slice over which the iteration is performed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Users that unbond from yAsset contract in XPrism mode receive twice their bonded amount minus the fees, and fees are not collected",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "StakingMode::XPrism, In contracts/prism-yasset-staking/src/staking.rs:96-108 and 116 if mode user == - withdrawal_fee. At the same time, the fees are not sent to any other contract. This leads to draining funds from other users and fees not being distributed to stakers, compromising incentives to stake. 2*unbonded_amount receives the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Lack of tax deduction in limit order contract leads to other users funds being spent",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "In contracts/prism-limit-order/src/order.rs:319 and 322 no taxes are deducted during the execution of the swap. Without deducting taxes, the contract will pay taxes for the swap from its own balance, which will consume the oered amounts of other limit orders, leading to a failure to execute those other limit orders in the future. This would aect a wide range of users of the protocol, who would permanently lose their funds.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Missing total bond amount decrease during unbonding from launch pool contract leaves rewards stuck in contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "the in In contracts/prism-launch-pool/src/contract.rs:206-215, the total_bond_amount is not decreased by the unbonded amount. This implies that for any further rewards, the denominator in line 277 will be too big, leading to any bonded users proportionally losing out on further rewards. unbond function",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Users might lose their bonds if unbonding periods of vault contract and Terra protocol are not the same duration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "If no batch is released in contracts/prism-vault/src/unbond.rs:255, the actual unbonded amount is still set to zero in line 317. Moreover, the prev_vault_balance is updated in the calling function execute_withdraw_unbonded in line 191. This might cause lost funds because the vault unbonding period can be freely set, while the Terra unbonding period is xed to 21 days. Two cases are possible. On the one hand, if the unbonding period used in the contract is longer than the actual unbonding period of the Terra protocol, this might lead to lost funds. On the other hand, if the unbonding period is set to less than the actual unbonding period, slashing of validators might lead to a situation where users can avoid being aected by slashing at the cost of other users because the slashing is not executed. Despite the severe implications of a mismatch of the unbonding periods, we classify this issue as minor, since governance can ensure equality of the periods by carefully making required changes.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Exchange rate peg mechanism allows users to prot from slashes and inhibits liquidity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "peg rate exchange in The and contracts/prism-vault/src/bond.rs:119-129 contracts/prism-vault/src/unbond.rs:41-51 might compromise the incentives of users and validators, depending on the parameter values of the threshold and the recovery_fee. There might be a free lunch for any user that bonds directly after a possible slashing event. implemented mechanism this First, compromises contracts/prism-yasset-staking/src/rewards.rs:28-35 stakers_portion could become larger than one. computations made where in the Second, in the worst case, if a potential prot from a free lunch is large enough, validators might be incentivised to trigger slashing in order to realize these prot opportunities. This might compromise the protocol. Third, users that wish to unbond after slashing have to pay up to the maximal peg recovery fee peg_fee in order to restore the peg. This leads to a rst-mover disadvantage in the sense that one single user might need to pay for the whole slashing. This in turn disincentivizes unbonding and reduces the liquidity of all derivative tokens. These issues are caused by the peg recovery mechanism. In contrast to the Anchor protocol, which uses a similar mechanism, Prism does not have a natural peg recovery by accruing rewards on cLUNA.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Withdrawal of funds may fail if a user unbonds many times without withdrawing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "In contracts/prism-vault/src/state.rs:60, 76, 89 and 114, iterations over the UNBOND_WAITLIST may run out of gas, if the list has many entries. Many entries might occur if a user unbonds regularly, but does not withdraw. That could happen for example if the user is a bot that automatically bonds daily. As a consequence, withdrawing funds may fail. There is currently no way to recover from this issue. Similarly the query in line 139 can run out of gas and fail.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Protection against mass withdrawals is weak and can be bypassed with multiple accounts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "In contracts/prism-fair-launch/src/contract.rs:185-187 in order to prevent massive withdraw on phase 2 (as stated in the comment), a fee is charged if withdraw_amount is greater than cfg.withdraw_threshold. This mechanism can easily be avoided by withdrawing multiple times with amounts less than or equal to cfg.withdraw_threshold. Elaborate exploiters can also bypass it easily by using multiple accounts to execute greater withdrawals.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of conguration validation in vault and yAsset staking contracts can cause errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "The conguration of peg_recovery_fee and er_threshold can be set to values larger than one in contracts/prism-vault/src/contract.rs:78-79 as well as in in contracts/prism-vault/src/config.rs:38-39. This might and contracts/prism-vault/src/bond.rs:124-126 contracts/prism-vault/src/unbond.rs:45-47. cause errors An equivalent problem occurs in prism-yasset-staking/src/contract.rs:37 and 42 where protocol_fee and withdraw_fee can be set to values larger than one, which might cause errors in contracts/prism-yasset-staking/src/rewards.rs:70 and prism-yasset-staking/src/contract.rs:116, respectively. We consider this a minor issue, since it can only be caused by oversight of the contract owner. However, errors in production can lead to downtime of the protocol.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Conguration updates in gov contract might aect votes in progress",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf",
        "body": "be In contracts/prism-gov/src/contract.rs:205-210, quorum and threshold in aects can contracts/prism-gov/src/polls.rs:141-146, which could aect the outcome of a vote. In addition, proposers might lose their deposit on existing polls after a change of the quorum. updated. progress votes This in As the values can only be updated by the contract owner or through governance, we consider this a minor issue. An update coming through governance would be visible by any proposer at the time of poll creation. Since the outcome of a poll that updates quorum or threshold values might not be certain, proposers could be disincentivized to create new polls during such a period.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Lack of authorization for privileged operations in the lpp contract allows users to manipulate the market",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The lpp contract does not implement an authorization logic for the execution of privileged operations and does not have the concept of a contract owner/administrator. This implies that anyone can send UpdateParameters messages to update critical contract parameters and base_interest_rate, addon_optimal_interest_rate, which can be used to manipulate the market. utilization_optimal like the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Price feeding mechanism could be permanently inhibited through market alarms",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The oracle allows contracts to subscribe to MarketAlarms in order to be notied when price changes trigger a particular condition. When a Feeder sends the FeedPrices message to update an asset price, a PriceAlarm message is dispatched and sent to all subscribing contracts. Since an O(n^2) unbounded loop through MarkedAlarms is needed to check and re alarms, a signicant number of subscriptions could lead to out of gas errors. Consequently, feeders will be permanently inhibited from providing new prices. A malicious actor could develop a contract with a computationally expensive PriceAlarm handler and subscribe potentially multiple MarketAlarms in order to cause the FeedPrices message to always run out of gas. Even without malicious intent, this issue is likely to occur since lease contract instances that users can instantiate from the leaser contract subscribe to alarms in the oracle.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Time alarms could be permanently disabled",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The timealarms contract allows other contracts to subscribe to TimeAlarms in order to be notied at a certain timestamp. The Notify transaction is used to trigger all stored alarms with a timestamp less than the actual time and execute the TimeAlarm transaction in the respective contracts. Since there is not a dened maximum number of stored alarms and a maximum amount of gas that TimeAlarm handlers can consume, the execution of Notify may run out of gas if a signicant amount of alarms are registered. Consequently, no time alarm could be triggered anymore. A malicious actor could intentionally deploy computationally expensive contracts that subscribe to TimeAlarms, consuming more gas than available and hence eectively disabling time alarms.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Lack of instantiation authorization in the lease contract allows attackers to instantiate it with arbitrary parameters and hence prevent liquidation and use arbitrary prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "During the execution of the InstantiateMsg of the lease contract, it is not enforced that its instantiator is the leaser contract. This implies that an attacker could instantiate a lease contract without the intermediation of the leaser, which allows the attacker to provide arbitrary parameters. For example, he could set a custom oracle address or liability congurations. This gives the attacker the ability to prevent liquidation and set arbitrary prices.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Incomplete Neutron messages support may lead to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "Contracts implement Neutron message specications but are not implementing their specic Sudo handlers used for handling message responses. This could lead to dierent inconsistencies and partial state updates in the protocol in case of errors or timeouts in the controlled chain. Some examples of the aforementioned behavior exhibited in the code:  In contracts/profit/src/profit.rs:63, a non acknowledged alarm can lead to prots not being transferred.  In contracts/lease/src/liquidation/alarm.rs:127, not properly rescheduled alarms can impact the timing of liquidations.  In contracts/lpp/src/contract/borrow.rs:57, failed attempts to transfer funds using BankMsg::Send through an interchain transaction are not handled.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Lack of alternate recipient address validation may lead to loss of users funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "When sending a ClaimRewards message to the lpp contract, the user can specify an alternate reward recipient in the other_recipient parameter. However, in contracts/lpp/src/contract/rewards.rs:34, during the execution of the try_claim_rewards function, the other_recipient address is valid. there is no validation in place to check that An invalid address will lead to the permanent loss of the users rewards.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Oracle is not resilient to feeders errors or manipulation attempts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "FeedPrices The in contracts/oracle/src/contract/exec.rs:61 enables feeders to submit their oracle prices on chain. message dened its associated Since in contracts/oracle/src/contract/feed.rs:92 does not perform any validation on inputs, it allows feeders to store incorrect data, for example a price equal to zero or multiple prices in the same block. try_feed_prices handler Also, the get_price function in packages/marketprice/src/feed.rs:55, which is responsible for providing the price of an asset, is returning the latest feeded one, without performing any calculation with other stored data points. By not performing any checks, nor transforming the data through any function that might catch outliers and data points that are not representing the real market price, the protocol allows the price to be manipulated by just introducing one corrupted observation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Contract ownership cannot be transferred",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The treasury, dispatcher, leaser, profit and oracle contracts do not implement an ownership transfer mechanism. Since the dened owner has the right to modify critical contract parameters and execute privileged messages, a compromise of its account would have devastating consequences for the protocol. It is best practice to oer functionality to transfer the ownership to another account.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Lack of price validation could lead to a division by zero error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/oracle/src/contract/feed.rs:67, there is no validation to ensure that prices are not equal to zero. Since throughout the codebase there are multiple calls to the inv function with the price value, there is a risk that the protocol performs a division by zero.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. It is not possible to migrate lease contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/leaser/src/cmd/borrow.rs:27-34, message is constructed with the admin parameter set to None. the lease contract instantiate This implies that the instantiated contract could not be migrated in case of a bug or a vulnerability disclosure.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Time alarms can be created for the past",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In packages/time-oracle/src/alarms.rs:60-69 the add function is not enforcing that a new time alerts timestamp is in the future.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Lack of validation for the UpdateParameters message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/lpp/src/contract/config.rs:9-22 the try_update_parameters function is updating the contract parameters without validating them. base_interest_rate, Since and addon_optimal_interest_rate are Percent values, they should be validated to be in the [0,1) interval. utilization_optimal We classify this issue as minor since only the contract owner can set those values.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Lack of validation of Dispatcher cong parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/dispatcher/src/contract.rs:45-50, the tvl_to_apr parameter is not validated during the dispatcher contract instantiation. This could lead to incorrect APR calculations and to not covered TVL intervals. We classify this issue as minor since only the contract owner can set this parameter.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Lack of validation of the leaser instantiation parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/leaser/src/contract.rs:29, during the leaser contract instantiation, not all the parameters are validated, such as liability and repayment. incorrect congurations could be used in the contract, such as a Liability As a result, instance with an incorrect attribute relationship, for example, a healthy factor smaller than the initial factor or greater than the max factor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Potential algebraic overows",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "Protocol contracts are not making use of checked operators in order to guard against algebraic overows. For example:  In contracts/lpp/src/state/deposit.rs:79. globals.balance_nlpn is incremented by deposited_nlpn without checking for overows. This assignment can be dangerous if the price of NLP is in the (0,1] range. In that case the entire global value could overow, which would aect rewards calculation.  In contracts/leaser/src/state/leaser.rs:23, an increment of an integer could cause an overow eventually. Since overflow-checks are enabled in Cargo.toml prole, the execution will panic if an overow occurs; however it should be better to be handled gracefully with an error message.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/treasury/Cargo.toml  contracts/dispatcher/Cargo.toml  contracts/timealarms/Cargo.toml  contracts/lpp/Cargo.toml  contracts/leaser/Cargo.toml  contracts/oracle/Cargo.toml  contracts/profit/Cargo.toml  contracts/lease/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Custom access controls implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "The treasury, dispatcher, leaser, profit and oracle contracts implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Wrong variable name for APR",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "In contracts/dispatcher/src/state/tvl_intervals.rs:72, a variable is named arp, when it aims to reect the APR value.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Typographical error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf",
        "body": "contracts/leaser/src/error.rs:27, In IvalidLiability, while its correct spelling is InvalidLiability. error an variant is named",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Access nodes are not ltered when approving or setting default node",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/DelegatorManager.cdc:957 and 984, the admin can initialize an approved list of node operators or set a default node to stake using the initApprovedNodeIDList and setDefaultNodeIDToStake functions. However, no validation ensures the initialized or selected nodes are not access nodes. nodes access be Since cadence/contracts/standard/emulator/FlowIDTableStaking.cdc:1183-11 86, misconguring an access node as the default staking node prevents users from staking FLOW tokens and redeeming FLOW tokens instantly from the liquid staking contract. delegated cannot seen as to in This could happen when the admin calls setDefaultNodeIDToStake with an access node as the nodeID argument or during the advancing epoch phase in the filterApprovedNodeListOnEpochStart function at line 633. We consider this a minor issue since only the admin can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Migrate function does not enforce minimum staking amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/LiquidStaking.cdc:185, the migrate function does not check whether the delegated tokens are greater than or equal to the minimum staking amount. Unlike the stake functions precondition check in line 60, the validation is not enforced in the migrate function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Minimum staking amount and staking cap are not validated against each other",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/LiquidStakingConfig.cdc:100-108, the admin can set the minimum staking amount and staking cap for the liquid staking protocol. Since the minimum staking amount is expected to be lower than the staking cap and vice versa, misconguring the values would prevent users from staking their FLOW tokens due to cadence/contracts/LiquidStaking.cdc:60 and 62. there should be a precondition check to ensure the updated values are higher/lower than the other. Ideally, We consider this a minor issue since only the admin can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Trust dependency on admin keys",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/stFlowToken.cdc:121, the mintTokens functions access modier is set to access(account). Theoretically, the account owner can mint as many stFlow tokens as required by deploying a new contract that calls the mintTokens function or performing a contract upgrade that modies the access modier access(all) keywords. into pub or The possibility of the admin is malicious or the private key is compromised. With that said, both deploy and update contract actions will emit events that o-chain listeners can fetch, which are easily trackable and monitorable with tools. this happening is that",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Incorrect event emitted when admin modies isMigratingPaused conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "the cadence/contracts/LiquidStakingConfig.cdc:137, In the emitted ConfigStakingPause isMigratingPaused conguration. This is incorrect, as the ConfigMigratingPause event should be emitted instead. updates admin event when the is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Supply start index higher than the end index causes collectDelegatorsOnEpochStart to perform empty execution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/DelegatorManager.cdc:503, the while loop attempts to collect all delegators to the next epoch based on the provided start and end index. If the start indexs value is supplied higher than the end index, the loop will not execute, causing the collectDelegatorsOnEpochStart function to collect zero delegators.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. initApprovedNodeIDList gas consumption can be reduced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In cadence/contracts/DelegatorManager.cdc:962-964, the for loop attempts to insert the approvedNodeIDList dictionary with the nodeIDs argument key and value. This causes unnecessary gas consumption as the values can be set directly.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Distributing tokens to the same node operator yield no dierence",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In the cadence/contracts/DelegatorManager.cdc:826, transferCommittedTokens function allows a strategy bot to transfer committed tokens from one delegator to another. Since no validation ensures that fromNodeID and toNodeID are not the same node operator, the result of the execution would yield no dierence.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Typographic errors and duplicate comments found in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf",
        "body": "In several instances of the codebase, typographical errors were found along with duplicate code comments.  cadence/contracts/DelegatorManager.cdc:125 contains an additional protocol word at the end of the sentence  cadence/contracts/LiquidStakingConfig.cdc:13 contains a typographical error of minimum This aects the readability of the contracts.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Blacklist policy is not enforced for other chain addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/blockibc_middleware.go:111-115, the sender address is checked to not be blacklisted when performing an IBC token transfer. Since ICS-20 token transfers involve escrowing USDC to other chains, the blacklist policy should ensure that other blacklisted chain addresses cannot redeem the locked USDC with their IBC vouchers. However, this is not possible due to the AccAddressFromBech32 validation in x/tokenfactory/types/message_blacklist.go:45-48, which can only validate native Bech32 prex addresses. This implies that addresses on other chains can redeem USDC independent of a blacklist, since they cannot be blocked by the blacklist. For example, the following command fails when trying to blacklist a Juno address: nobled --home $CHAINDIR/$CHAINID tx tokenfactory blacklist juno1t8ehvswxjfn3ejzkjtntcyrqwvmvuknzy3ajxy --from $(nobled keys show blacklister -a) -y Error: invalid blacklist address (invalid Bech32 prefix; expected noble, got juno): invalid address This issue also aects the receiver blacklist policy in app/ante.go:89-93 when initiating an ICS-20 token transfer. Consequently, the blacklister will not be able to prevent users from transferring USDC to malicious addresses on other chains. We classify this issue as major because the blacklist policy is considered an important security feature in Nobles architecture.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Minting denom can be transacted through IBC during a paused state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "x/tokenfactory/blockibc_middleware.go:92-114, In OnRecvPacket handler does not validate the keepers paused state when receiving ICS-20 fungible token transfer packets. When the keepers paused state is true, all internal and external transfers are disallowed, as seen in app/ante.go:39-43. However, other chains can still transact USDC tokens to the native chain, eectively bypassing the paused state. the We classify this issue as major because the paused state is considered an important security feature in Nobles architecture.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. IBC middleware does not parse denoms trace when receiving ICS-20 packet data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/blockibc_middleware.go:101-103, security measure will be skipped if the packets denom is not the congured minting denom. As mentioned in lines 83-85, this is to ensure that the sender and receiver are not blacklisted if they were to transact an IBC voucher representation of USDC. the blacklist However, this approach will never work because the receiving packets denomination is constructed with a record of channels for which they have been transferred across chains, such as transfer/channel-40/uusdc. Consequently, the condition in line 101 will always evaluate as true, eectively bypassing the blacklist policy in lines 105-115.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Incorrect minterController genesis state validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/types/genesis.go:54, the MinterControllerKey function is used to derive the minter controller key from a minter controller address. However, the minter controller address is passed as an elem.Minter in the current implementation. This sets an incorrect minter controller key to validate a duplicated index. Therefore, as the specied key does not contain any data, accessing data onchain would not be possible.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Deviation from specication: A controller can set up any number of minters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "to the the specication, ConfigureMinter According in x/tokenfactory/keeper/msg_server_configure_minter.go:12 should only be called by the minterController and set its corresponding minter. However, the current implementation of ConfigureMinter does not validate that the minter address being congured matches the specied address that the MinterController controls. The same in issue x/tokenfactory/keeper/msg_server_remove_minter.go:12. Because of that, the relationship between MultiController and minter becomes one-to-many instead of one-to-one. This deviates from the specication. RemoveMinter function function exists the in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Separation of privileged addresses is not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "While there has been an extensive eort made to develop privileged accessed roles within the Noble chain, privilege separation of these roles is not properly enforced. Currently, there is no validation to ensure that these privileges cannot be shared by a single address. In the unlikely case of a compromised account, account sharing may have severe implications. For example, the Owner can assign the Blacklister, Master Minter, and Pauser roles to itself. While new addresses can easily be generated and all roles can technically be owned by the same entity using dierent addresses, it is best practice to restrict address reuse. Another step that can be taken to reduce the impact of a compromised account is to implement timelocks to prevent frequent updates of addresses.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Modifying minting denom allows blacklisted users to transact the old denom",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/genesis.go:45-47, supplying a dierent MintingDenom will cause the SetMintingDenom function to modify the mint denom. This is problematic since the blacklist functionality only works based on the current minting denom, as the decorator in app/ante.go:67-98 only validates that the addresses are not blacklisted if the transacted denom is the congured minting denom. Consequently, blacklisted users who were previously unable to transact the old minting denom can now transact that denom like other users. Additionally, all minters would need to update their old allowances denom to continue minting new tokens. We classify this issue as minor because only the governance can cause it, which requires cooperation among impacted parties.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Minters can be added during a paused state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/keeper/msg_server_configure_minter_controller.go:12 the x/tokenfactory/keeper/msg_server_configure_minter.go:12, and functions can be ConfigureMinterController and ConfigureMinter keeper executed even if the keepers paused state is set to true. This is inconsistent with the pausing section of the token design specication. As mentioned in that specication, adding minters should be prevented while the contract is paused.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Amino codec must be registered to support end users with hardware devices like Ledger",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/types/codec.go:77, Amino should be used to register all interfaces and concrete types for the tokenfactory module. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Incomplete genesis validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/types/genesis.go:29-63, validating all the provided GenesisState attributes. the Validate function is not There is no logic in place that validates Pauser, Owner and Blacklister addresses and that enforces Denom to be a non-empty string.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Missing validation for existing blacklisted address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In x/tokenfactory/keeper/msg_server_blacklist.go, the Blacklist function is used for adding new addresses, however in its current implementation, it is not veried whether a new address is already on a blacklist or not. As a result, the operation succeeds without an error, which may give indexers or other o-chain services the misleading impression that a specic address has not yet been blacklisted.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Missing blacklist validation during minter conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In the x/tokenfactory/keeper/msg_server_configure_minter.go, ConfigureMinter method is used to add a minter. However, its current implementation does not check if the provided msg.Address is on a blacklist. This allows adding a blacklisted address as a minter.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Tokenfactory does not perform two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "in The x/tokenfactory/keeper/msg_server_update_owner.go:12 does not perform a UpdateOwner function two-step ownership transfer. In the unlikely event that the new owner is set to an incorrect address, then the owner will not be able to be reset, and the owner functionality will be lost.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Succinct event emission restricts information available to indexers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "All dened messages emit TypedEvent events containing the submitted message. However, those events contain only limited detail and may not represent enough information for indexers and other o-chain services.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Amount and Allowance message attributes are not validated to be greater than zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In the ValidateBasic functions in  x/tokenfactory/types/message_burn.go:45,  x/tokenfactory/types/message_configure_minter.go:41, and  x/tokenfactory/types/message_mint.go:41, the Amount and Allowance attributes are not validated to be greater than zero. This implies that messages that contain invalid values can pass the ValidateBasic validation without triggering an error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Incorrect eld numbers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "The GenesisState message in proto/tokenfactory/genesis.proto uses an incorrect eld number starting from 9. The minterControllerList should have 9, and mintingDenom should have 10 eld numbers.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. InitChainer and BeginBlocker are set twice",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "In app/app.go:571-572 and app/app.go:593-594, SetBeginBlocker methods are called twice, which is inecient. the SetInitChainer and",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Unnecessary validation of From address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "Additional validation for the From address in ValidateBasic functions in the lines below are not necessary since that address belongs to the transaction sender address and is already validated:  x/tokenfactory/types/message_blacklist.go:41  x/tokenfactory/types/message_burn.go:41  x/tokenfactory/types/message_configure_minter_controller.go:4  x/tokenfactory/types/message_configure_minter.go:42  x/tokenfactory/types/message_mint.go:42  x/tokenfactory/types/message_pause.go:40  x/tokenfactory/types/message_remove_minter_controller.go:41  x/tokenfactory/types/message_remove_minter.go:41  x/tokenfactory/types/message_unblacklist.go:41  x/tokenfactory/types/message_unpause.go:40  x/tokenfactory/types/message_update_blacklister.go:41  x/tokenfactory/types/message_update_master_minter.go:41  x/tokenfactory/types/message_update_owner.go:41  x/tokenfactory/types/message_update_pauser.go:41",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Duplicated ValidateBasic invocation in CLI",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf",
        "body": "CLI commands transaction All in registered x/tokenfactory/client/cli/tx.go call the msg.ValidateBasic function before calling GenerateOrBroadcastTxCLI. As msg.ValidateBasic is already called inside the GenerateOrBroadcastTxCLI, this is an unnecessary and duplicated invocation. GetTxCmd function the in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Withdrawal and staking of voting rewards fails if too many locked balance entries exist",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/Mirror v2 Audit Report.pdf",
        "body": "the in In get_withdrawable_polls contracts/mirror_gov/src/staking.rs:317, an unbounded iteration over the entries in locked_balance is performed. In each iteration, two storage entries are read. If the and StakeVotingRewards messages would fail, and it would be impossible for a user to recover and withdraw their rewards. WithdrawVotingRewards transaction function runs gas, out the of This issue only aects individual users and the likelihood of the locked_balance list growing to the point of the described issue is very low. Hence we classify this issue as minor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Fees held by spot vault are locked forever",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "During the instantiation of a spot vault contract the fee_recipient is dened as the contract itself, see contracts/ninja-vault-spot/src/contract.rs:31. However, there is no function that allows the fees accrued to be withdrawn, eectively locking the funds forever.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Inventory imbalance under certain parameter constellations will disable the risk management framework",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "In order to conduct risk management, the team modeled a reservation price that is dierent from the current mid-market price to be the center of the orders. To account for changes in volatilities, the orders price is a function of the volatility. However, for every imbalance ratio there exists a parameter combination of reservation_price_sensitivity_ratio and reservation_spread_sensitivity_ratio such that the proposed head and tail can be set to market price, by supplying liquidity or withdrawing liquidity, irrespective of the state of volatility. Specically contracts/ninja-vault-spot/src/mm_bot/order_management.rs:17, variable proposed_buy_head can be equal to in the _  +     where  = __  ___     ___ can be zero if: ___    2  ___ (i.e. states of high volatility and trending price behavior) An attacker with access to signicant liquidity could leverage this property during market turmoil to disable the risk management framework, as described above, pushing the vault to an imbalance such that  = 0 .",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Price threshold for price invalidity is prone to manipulation and might lead to full loss of users funds in case of a breakdown of a market or an asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "In contracts/ninja-vault-derivatives/src/mm_bot/bot.rs:40 a 30% interval is used to render the mark price as invalid. If the new price is out of this interval, the logic in contracts/ninja-vault-derivatives/src/mm_bot/risk_management/oracl e.rs closes positions if protable, or leaves them open and stops all trading activities if not protable. Although this is meant to be a protection against erroneous or manipulated prices, its ecacy is low as an attacker that is capable of manipulating the price by 30%, will also be able to manipulate the price by 29% in one block and 2% in the next or simply manipulate the price by 29.99%. In case of a non-manipulated change by 30% and a continuing trend in the same direction, a losing position will never close  leading to a  full loss of funds for users. There is a way to recover if an admin updates the last_valid_mark_price in in this is an contracts/ninja-vault-derivatives/src/config.rs:91. However, inadequate risk management for an automated trading system with multiple vaults running simultaneously 24/7. In addition, it goes against best practices that admins can update prices as enabled. tool",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Updating Ninja token address may cause state conicts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "The owner of the master contract has the ability to update the address of the Ninja token stored in the contracts cong. Altering the Ninja token address could have the eect of causing a state conict in other contracts that use the address stored within the master contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Vault contract invocations should be prevented prior to registration with master contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "Vault contracts are designed to be deployed and instantiated from their owner and then successfully initialized from the ninja-master executing the RegisterForMaster transaction. This message execution sets the subaccount_id and instantiates the CW20 contract responsible for managing the vaults lp_tokens. Before this initialization, the vault is not ready to be used and user space transactions and queries should return a meaningful error message.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Large order_density could lead to the execution running out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf",
        "body": "In contracts/ninja-master/src/contract.rs:111-136, the following functions  get_is_authorized_order_data,  get_is_authorized_spot_order, and  get_is_authorized_derivative_order perform an unbounded iteration through orders. Since the length of the vector is related to order_density and this parameter has not an upper bound, a large value assigned to it could lead the execution to run out of gas. analogous An contracts/ninja-master/src/contract.rs:336-375 synthetic_trade.user_trades. problem also occurs in with",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Bad debt state is not recorded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "In contracts/margined_engine/src/messages:185, the withdraw function called when executing the WithdrawMargin message is updating the bad_debt attribute of the state. As state is passed as a &mut, the withdraw function caller has in the state variable the updated bad_debt value. The state is not stored though, hence the new value is available only in the current execution scope and cannot be retrieved in a subsequent execution. Consequently, the bad_debt information is never saved in the contract store, and the information is lost. This implies that the margined_engine could be insolvent or with an insolvency risk without being aware. Additionally, the State query, which will be used to track the margined_engine status, would always report the bad_debt metric to be lower than the real accrued debt. See Appendix-1 for a test case that shows this issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Incorrect accounting during liquidation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "The margined engine contract incorrectly keeps track of the funds that should be requested or sent to the insurance funds contract upon liquidation. of the case liquidation_fee In in contracts/margined_engine/src/reply.rs:458, remain_margin.margin is not set to zero at the end of the if block, eectively being used rst in the calculation of bad_debt and later on the transfer of remaining margin at line 474. This results in the engine contract unexpectedly moving additional funds to the insurance fund contract. remain_margin.margin > if there is no previously recorded state.bad_debt and the engine contract In addition, doesnt have enough funds to pay a liquidator, the missing amount would be withdrawn twice from the insurance fund contract: The rst during realize_bad_debt in line 468 and a second time during withdraw in line 479. Given the Bad debt state is not recorded issue, this could cause the Insurance Fund contract to be drained faster than expected, potentially causing insolvency issues if not watched carefully. Additionally, these extra transfers incremented gas costs on every transaction related to the aected feature. See Appendix-3 for a test case that shows this issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Bad debt is wrongly reset upon realization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "the in When realize_bad_debt non-zero is contracts/margined_engine/src/utils.rs:81 state.bad_debt value, instead of updating it with any additional bad_debt and withdrawing funds from the insurance fund contract, it is reset to zero and no transfer from the insurance fund is requested. This implies losing track of any previous debt and not covering the new one given the lack of withdrawal from the insurance fund. function called with a Consequently, the contract could be at an insolvency risk without the team being aware as the bad_debt value being reported would be lower than the real accrued debt.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Possible inconsistencies when conguring decimal values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "values decimal In both margined engine and virtual AMM contracts, contract instantiators are required to in specify and contracts/margined_engine/src/contract.rs:62-66 contracts/margined_vamm/src/contract.rs:40. There is no validation that ensures both values are same and consistent with each other when conguring and updating the decimal values via contracts/margined_engine/src/handle.rs:83. If both it will yield incorrect results when executing contracts assume dierent decimal values, SwapInput and SwapOutput, potentially returning a higher or lower output amount than intended that directly aects trader's position size. seen as the MAX_ORACLE_SPREAD_RATIO in Moreover, contracts/margined_vamm/src/contract.rs:26 is represented as 10% with 8 decimal values, meaning that the intended decimal values should be 9 (100_000_000 / 0.1 = 1_000_000_000). Since the constant value cannot be modied, a misconguration of decimals in contracts/margined_vamm/src/query.rs:230 to return an incorrect spread limit exceeded result. query_is_over_spread_limit constant would cause being not that, native token decimals Besides seen in packages/margined_common/src/asset.rs:191. This collides with the virtual AMM satisfy intends decimals MAX_ORACLE_SPREAD_RATIO constant value. are assumed as 6 as requirement decimals accept values since to to it",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Margined engine cannot support native tokens as collateral during mainnet production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "In the packages/margined_common/src/validate.rs:28-33, validate_eligible_collateral functionality only recognizes ujunox and uwasm as supported native tokens when conguring and updating eligible collateral assets. Since ujunox prex only exists in Juno Testnet and uwasm prex originates from wasmd, the hardcoded native tokens will not be usable during production as they dont exist in the Juno mainnet. Also, as not all native tokens follow the utoken convention and could have a custom decimal digits in packages/margined_common/src/asset.rs:191 could lead to possible wrong calculations. representation, hardcoded value 6u8 the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Emergency ShutdownVamms messages are not able to execute SetOpen transactions due to lack of permissions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "In contracts/margined_insurance_fund/src/handle.rs:78, when handling ShutdownVamms messages, the execution is iterating through all the VAMMs registered in the insurance_fund in order to send VammExecuteMessage::SetOpen { open: false } messages to them. Those messages are wrapped in a SubMsg and have the purpose of pausing that specic VAMM. the SetOpen However line contracts/margined_vamm/src/handle.rs:98 that is only accepting transactions intended to be the insurance_fund contract. from its registered Owner that Consequently all the SetOpen SubMsg will fail due missing Owner role permissions. message handler is not guard has at a",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Updating eligible collateral causes state inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "the contract owner can In contracts/margined_engine/src/handle.rs:73-84, update the eligible collateral, which also updates the decimal values accordingly. This is problematic for the following reasons: Firstly, it would cause a state inconsistency issue. The actual balance held in the contract for the newly congured eligible collateral might be dierent than the recorded state. As a result, traders might be unable to withdraw excess margin due to insucient balance. Secondly, it causes a decimal collision issue as the virtual AMM that the margined engine contract interacts directly with is unable to have the decimal values updated. This causes inconsistencies between the two contracts and will be further elaborated on in the next section. is the than previous it would cause incorrect ratios and liquidation fees if the newly congured decimal Lastly, initial_margin_ratio, value. lower value maintenance_margin_ratio, and liquidation_fee values use decimal value as limit (i.e. 0% to 100%), a lower decimal congured will cause ratios and liquidation fees to exceed the 100% limit. For example, if the previous decimal value is 9 and the new eligible collateral uses 6 decimals, a congured 10% ratio or liquidation fee would become 10000%, which will likely cause all positions to be undercollateralized due to contracts/margined_engine/src/handle.rs:284. partial_liquidation_margin_ratio Since We classify this issue as minor, since only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Insurance fund beneciary can be updated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf",
        "body": "The insurance fund contract allowed its owner to update the beneciary at any time as seen in contracts/margined_insurance_fund/src/handle.rs:36. A malicious insider or an attacker that compromised the keys of the legitimate administrator would be able to set themselves as the beneciary and then withdraw the contracts funds. We classify this issue as minor since only the owner can update the insurance fund beneciary and it is assumed that the owner is a trusted party.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Pools allow attackers to extract free value with minimal cost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "The compute_swap function in contracts/pair/src/contract.rs:733 uses unsigned integers for its calculations without rounding, which opens up a way for an attacker to extract value from a pool with a very small cost. As an example, imagine a pool with 5_000_000_000_000 A tokens, and a pool with 1_000_000_000 B tokens. If a user now sends 1 B token, we expect the user to get 5_000 A tokens back. When a user sends 1 A token, we expect the user to get 0 B tokens back (actually 0.0002, but since we are dealing with integers here, the remainder will be dropped). The current implementation incorrectly returns 1 B token though. Imagine further that the value of 1 B token is 5_000 USD, and the value of 1 A token is 1 USD, an attacker can now get a risk free return of around 4_999 USD (minus transaction fees) per transaction. If the attacker repeats this attack, they will be able to drain the pool. Even worse, whenever the attacker shifts the balance enough, other arbitrageurs will be able to extract value by bringing the pool back to the 5_000 to 1 ratio, allowing the attacker to repeat the attack from where they started. Here is a failing test case demonstrating the example: #[test] fn compute_swap_rounding() { let offer_pool = Uint128::from(5_000_000_000_000_u128); let ask_pool = Uint128::from(1_000_000_000_u128); let offer_amount = Uint128::from(1_u128); let commission_rate = Decimal::from_ratio(0_u128, 1_u128); let return_amount = Uint128::from(0_u128); let spread_amount = Uint128::from(0_u128); let commission_amount = Uint128::from(0_u128); assert_eq!( compute_swap(offer_pool, ask_pool, offer_amount, commission_rate), Ok((return_amount, spread_amount, commission_amount)) ); }",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attacker can cause the generators send orphan proxy rewards function to run out of gas, locking orphan rewards in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "the send_orphan_proxy_rewards in In contracts/tokenomics/generator/src/contract.rs:721, USER_INFO storage map is iterated over with the LP token prex. That iteration is unbounded. An attacker can deposit many the send_orphan_proxy_rewards function to run out of gas. There is currently no way to recover from such an attack, any orphan rewards would be locked forever in the contract. to make the iteration long enough for function the small amounts The query_orphan_proxy_rewards query handler exhibits the same issue in line 880, which could potentially cause calling contracts to run out of gas.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Lack of access control on maker contracts set cong function allows anyone to set themselves as the fund receiver",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "is no access in There contracts/tokenomics/maker/src/contract.rs:225, implying that anyone can change the maker contracts cong. An attacker can for example set themselves as the fund receiver, or change the percentage of funds that goes to governance. set_config restriction function the on",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Lack of access control on generator contracts set tokens per block function allows anyone to set number of tokens per block and extract value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "is no access restriction on the set_tokens_per_block function in There contracts/tokenomics/generator/src/contract.rs:756, implying that anyone can change the tokens_per_block. An attacker can for example set a high number of tokens per block and extract value.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Lack of mass updating pools before changing alloc points leads to incorrect allocation of pending rewards and causes orphan rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "In the add function in contracts/tokenomics/generator/src/contract.rs:154, total_alloc_point gets updated, which implicitly changes the allocation for all other pools. Currently, no mass update is performed before that change. That implies that any pending rewards will be distributed according to the updated allocation, causing some rewards to stay unclaimed in the contracts. imagine there is only one pool A, which has 100 alloc_point out of a For example, total_alloc_point of also 100. Also suppose that a total of 10 tokens have been accrued so far in rewards, but they have not yet been assigned to pool A. According to these numbers, the LP holders of pool A are entitled to a total of 10 reward tokens. Imagine now that pool B gets added with an alloc_point of 300, and immediately afterwards, the rewards for pool A are calculated and allocated. At that point, pool A will only have 100 alloc_point out of 400 total_alloc_point, and LP holders will now only receive 2.5 of the reward tokens. The remaining 7.5 rewards will stay unallocated in the contract. Those tokens may be withdrawn using the SendOrphanProxyReward message. The same issue exists in the set function in 197.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Vested but not yet claimed tokens will be lost when replacing a vesting schedule for an account",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "from When updating a vesting account in the register_vesting_accounts function, previous vesting schedules may be replaced with updated ones. During that logic, any unclaimed amounts in contracts/tokenomics/vesting/src/contract.rs:136. to_receive is then used to reduce the amount that will be transferred from the owner in line 155 (or is refunded to the owner in line 168). Any vested, but not yet claimed amounts are also part of to_receive, and will hence be lost from a users point of view. to_receive schedule vesting added are the to",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Missing spread calculation of stable pair contract is misleading to users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "is not In the pair stable contracts compute_swap and compute_offer_amount functions, the spread in contracts/pair_stable/src/contract.rs:832 and 872. Without the actual spread, the max spread assertion, as well as the returned spread amount, are useless, which is misleading to users. hardcoded computed, rather but yet to A TODO exists in the code that mentions the need for spread calculation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of access control on the generator contracts set allowed reward proxies function allows anyone to set proxies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "There is no access restriction on the set_allowed_reward_proxies function in contracts/tokenomics/generator/src/contract.rs:655, implying that anyone can set proxies that can be used when adding an LP token to the pool. We consider this only a minor issue since only an owner can add LP tokens to a pool. Still, an attacker can grief the owner by removing reward proxies from the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Duplicate storage in two contracts could lead to inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf",
        "body": "i. e. asset_infos, contract_addr, liquidity_token, and pair_type, Both factory and pair contracts store the PairInfo struct which contains information about in pairs, in contracts/factory/src/state.rs:19 and contracts/pair/src/state.rs:16 contracts/pair_stable/src/state.rs:17. This duplicate storage might lead to inconsistencies between the two contract states. and",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Anyone can whitelist a new vAMM or overwrite an existing one",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "contracts/factory/src/contract.rs:45, In executing ExecuteMsg::Whitelist message, there is no check on the senders address of the transaction to ensure that it is contained in the admins list. when This may lead to three malicious behaviors:  Anyone can instantiate and whitelist a new vAMM on behalf of admins passing arbitrary parameters.  As vAMMs are indexed in the VAMM_ADDRS Map with the stringication of currency_pair as the key, anyone can overwrite an existing vAMM address mapping with a new one with arbitrary parameters.  Using the DelTranche in contracts/risk-fund/src/contract.rs:86, maliciously registered vAMMs can drain the risk fund completely.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Risk fund is not able to partially disburse creditors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/risk-fund/src/state/tranche.rs:366, when disbursing from the risk fund, the execution tries to take all possible funds from tranches in order to pay the creditor. If there aren't enough funds, it will return an error causing creditors to not get funds, not even partially based on the availability.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. saveSwapInstruction can be executed by anyone with arbitrary values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/risk-fund/src/contract.rs:73, there isnt any check on the message sender role when executing a saveSwapInstruction message. As this message is used to save and update the Astroport swap pair contract address for a specic pair, the execution of it should be restricted to admins only. In fact, a malicious actor could overwrite a legit Astroport swap pair address to a malicious one. Such a malicious pair could receive UST, emit appropriate events, but not actually return another asset. This is also possible because ReplyKind::AstroportSwapUst parses the asset information from the returned event.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. assert_admin might run out of gas and contract-specic admins might lead to inconsistency and misconguration risks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/factory/src/state/admin.rs:13, iterations over ADMIN_ADDRS may run out of gas if the vector has too many entries. Because admins cannot be removed there is currently no way to recover from this issue (see issue 11). Additionally, dierent contracts, e.g. the vAMMs, and the vault, might all contain distinct lists of admins, which the factory, introduces the risk of misconguration.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Risk fund is not aware of the fees sent from the vault",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/vamm/src/contract.rs:98, contracts/vamm/src/state/liquidation.rs:309 and 314, the vAMM is sending a message to the vault VammMsg::SendFunds. in order to send collected fees to the risk fund using The execution of this message is sending funds to the risk fund through a BankMsg::Send but its not directly triggering a mechanism to collect fees. This may lead to the contract not being aware of the collected fees and to capital ineciency of fees that are already in the risk fund but are not in tranches.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. is_vamm_addr might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/factory/src/state/address.rs, the is_vamm_addr function has an asymptotic cost of O(n) and can make the message run out of gas depending on the length of VAMM_ADDRS and the to_check parameter position in the array. This can happen when calling QueryMsg::IsVamm from the risk funds can_disburse function. Since any user can add vAMMs (see issue 1), an attacker can exploit this vulnerability to deny the expected functionality.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Prices collected from oracle are inverted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "During liquidation, the current price is calculated as UST/asset, in the same way as it is calculated in or contracts/vamm/src/state/market.rs:112-119. spot_price mark_price for As prices returned from Chainlink are represented as asset/UST and they use a dierent method respecting mark_price,  calculations between those two values are inconsistent.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. CollectFee message execution might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/risk-fund/src/contract.rs:62, under certain circumstances, the execution of the CollectFee message can consume a big amount of gas and in the worst case can run out of gas. Consider as an example the scenario that the UST tranche is almost full. 1. Alice sends a CollectFee message. 2. The execution will call the collect_fee function and will ll the UST vault with UST in the msg funds. 3. Now, assume that this will not consume all the funds in the msg. The execution will call recursively collect_fee in order to ll the second tranche. 4. This will cause an interaction with Astroport, we need 2 queries to correctly create the message and then send it. 5. Astroport contract execution returns a reply. 6. Contract uses the reply to update the tranche state. 7. If there still are some funds in the msg, the execution will call another time the collect_fee function. 8. Here we can potentially loop several times until the execution will ll all the tranches or user funds sent in the message will be depleted. This issue is not unlikely to happen if the UST tranche is almost full.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Risk fund can be drained completely due to unpriced vega risk, if highly volatile assets are listed or volatility conditions change",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "Suppose that an asset faces above normal volatility conditions and suppose that an attacker creates two large and maximum leveraged positions with two distinct wallets one short (A) one long (B) such that the expected sum of the payout of the two positions is A+B-fees, and the expected value of A+B is E(A+B) = 0. If the market volatility is large enough to assure that the collateral of one position will not be enough to cover its losses, an exploiter can create a series of payments to drain all funds from the risk fund. In layman's terms this is because the losses of the losing position are limited (since bad debt doesnt exist) and the earnings of the winning position are not capped but are paid out entirely until the risk fund is empty. Because such an attack requires sound nancial engineering and is only possible during adverse market conditions of a given asset, we do not consider this to be a major issue. However, this attack vector also highlights another important vulnerability of the protocol. Because very risky/volatile assets are covered by the same tranches of the risk fund as less risky assets, less risky positions might lose their risk fund coverage from adverse events in the more risky segment. Especially for risk averse users that use the protocol for hedging purposes, this might be an undesired property.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Extensive admin permissions go against best practice",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "It is best practice to restrict admin permissions to actions that do not directly allow access to or could create a loss of user funds. Under the current architecture, admins have several such permissions: 1. 2. contracts/vamm/src/contract.rs:224, using In ExecuteAdminMsg::ForceMarketPrice, the market price can be set to arbitrary values putting users' funds at risk of liquidation. In contracts/vault/src/contract.rs:67, any address can be added as a new vAMMs address using ExecuteMsg::InsertVamm, which then can drain funds from the vault completely via VammMsg::SendFunds. 3. In contracts/vamm/src/state/config.rs:69-111, updated such that: the config can be a. Only full liquidations take place, via updates of config.liquidation_total_ratio. b. The likelihood of liquidations increases drastically, via updates of config.mark_price_divergence. c. Liquidation rewards are sent fully to the liquidating address, via updates of config.liquidation_reward_split. 4. 5. In contracts/risk-fund/src/contract.rs:86, DelTranche can be called by admins and vAMMs. It sends the funds to the sender. In contracts/risk-fund/src/contract.rs:35, it is possible to add a new admin but not possibility to remove an admin. This makes it impossible to stop malicious admins. This issue is especially problematic due to the smart contracts support of multiple admin accounts  administering these requires o-chain maintenance, which is prone to human error.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "11. bigint crate is aected by CVE-2020-35880",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "a In rust/utils/Cargo.toml:17 of the levana-common repository, bigint is specied in as https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35880 and https://rustsec.org/advisories/RUSTSEC-2020-0025.html that crate is aected by a Critical CVE with a score of 9.8. dependency. reported As The crate is not maintained anymore and contains several known bugs (including a soundness bug).",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Address provider does not validate addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/address-provider/src/contract.rs:44, ExecuteMsg::Change function handler execute_change takes a to parameter of type Addr. This may cause an unvalidated address to be stored.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. vAMMs conguration parameters are not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/vamm/src/state/config.rs:69, the update_config function which is called when initializing and updating config lacks validation on conguration parameters before saving them. As some of them are intended to be in a specic range and used in math operations, this may lead to inconsistency and execution errors caused by division by zero or assigning negative values to unsigned integers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Admins can insert unvalidated vAMM addresses in the vault",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/vault/src/contract.rs:70, insert_vamms allows adding a new vAMM address in the VAMM_ADDRS array without validation. This may cause inconsistencies in VAMM_ADDRS.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Some possible values of vbase_liquidity can make vAMM unusable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "contracts/vamm/src/state/markets.rs:158, In using vbase_liquidity taken from the InstantiateMsg to initialize quote, base and k of the curve. init_curve is As there is no validation for vbase_liquidity, a value of this parameter equals to or less than 0 can make the vAMM unusable as this will cause:  Case vbase_liquidity == 0: quote, base and k all with zero value  Case vbase_liquidity < 0: quote and base with a negative value",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Its not possible to change the admin of the address provider contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/address-provider/src/contract.rs, the admin cw_controller is registering the contract admin address in the instantiate message. After that, its not possible for the admin to change its address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Its not possible to add or remove admins in Factory, Spot Price, vAMM and Risk Fund contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In Factory, Spot Price, vAMM and Risk Fund contracts instantiate function, the list of admins is taken from the InstantiateMsg message. the instantiation, After its not possible for admins to be added or removed. This is problematic since a compromised admin address cannot be removed or replaced with a new one.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Lack of validation of AddTranche cong values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "In contracts/risk-fund/src/contract.rs:80 when executing the AddTranche message, values in the cong object are not validated. This can lead to a not working tranche registered in the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Iterations over tranches might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf",
        "body": "the In contracts/risk-fund/src/state/tranche.rs:59-73, tranches might run out of gas, if too many tranches exist. As this can happen only through admin error and is recoverable, we classify this as a minor issue. iterations over",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Unauthorized swap adjustments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "update_swap_adjustment_handler in The allows contracts/dca/src/handlers/update_swap_adjustment_handler.rs updating the swap adjustments for a specic strategy, eectively increasing or decreasing the number of tokens swapped. However, this function, which is supposed to be callable only by the contract admin, lacks authorization checks. An attacker can save arbitrary swap adjustments for any strategy, potentially grieng the protocol  for example, by setting it to a value of 0. function We would like to point out the described vulnerability was also detected by the Calculated Finance team during the audit. A x was prepared, which was then reviewed by the Oak Security team. that",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Destination address set to the DCA contract address allows disbursement of escrowed funds at any time",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "the DCA contracts In in contracts/dca/src/helpers/disbursement.rs, swapped and escrowed funds are disbursed to the provided destination addresses of a vault. Destination addresses can be used as arbitrary callbacks by specifying a custom message. get_disbursement_messages function However, the destination address is not checked to ensure it is not the DCA contract itself. This allows for the execution of messages in the context of the DCA contract as the caller of the message. For example, providing the DisburseEscrow message would lead to the disbursement of escrowed funds whenever funds are distributed, contradicting the intended behavior of disbursing escrowed funds only in specic situations, e.g., upon vault cancellation.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. PerformanceAssessmentStrategy::CompareToStandardD ca is incorrectly used for a vaults performance_assessment_strategy when choosing SwapAdjustmentStrategyParams::WeightedScale",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "a the with new vault create_vault_handler in Creating contracts/dca/src/handlers/create_vault.rs allows specifying a performance assessment and swap adjustment strategy. The swap adjustment strategy can be either set to or SwapAdjustmentStrategyParams::RiskWeightedAverage SwapAdjustmentStrategyParams::WeightedScale. The performance assessment strategy determines if a vault should continue to swap tokens based on the performance of the for SwapAdjustmentStrategyParams::RiskWeightedAverage. supposed function used vault only and be to is the However, to performance_assessment_strategy PerformanceAssessmentStrategy::CompareToStandardDca in line 120 for both swap adjustment strategies, regardless of the chosen strategy. set is As a result, the vault's escrow_level, supposed to be set to 0, is set to the escrow level in line 127. Additionally, cong value (risk_weighted_average_escrow_level) Instead of imposing swap and automation fees in the incorrect swap fees are charged. in disburse_funds_handler contracts/dca/src/handlers/disburse_funds.rs:43 and 48, performance fees are applied. As the performance fees are calculated based on the protability delta between the standard DCA and the DCA+ strategy and the vault not using the DCA+ strategy, performance fees will be inaccurately calculated. function",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Spot price usage may be exploited through oracle manipulation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "During trigger execution, the belief price is determined using the query_belief_price function in contracts/dca/src/helpers/price.rs:8-48. In line 38, the pools are queried for their spot price, which could be manipulated on low liquidity pools. This issue is exacerbated due to the lax limits on slippage described below in the issue Default slippage_tollerance is set to the maximum value and because ExecuteTrigger is permissionless. An attacker could monitor existing vaults to compile a list of targets and exploit them by executing triggers at the correct time after manipulating the oracles spot price.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. due_date of the disburse escrow task is not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "Canceling a vault through the cancel_vault_handler function stores a task in storage to disburse escrowed funds. The due_date is designed to limit the execution of the task to a specic time in contracts/dca/src/handlers/cancel_vault.rs:35. calculated based on the current block frame and is time However, when disbursing escrowed funds via the disburse_escrow_handler function in contracts/dca/src/handlers/disburse_escrow.rs, the previously stored task is not loaded, and its due_date is not checked. This means that escrowed funds can be disbursed at any time by the contract admin, even when the due_date has been surpassed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Default slippage_tollerance is set to the maximum value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "Slippage tolerance determines the maximum allowable deviation between the anticipated number of tokens a user expects to receive, such as in a token swap, and the actual number tokens received. A higher value implies a smaller amount of tokens being received, of increasing the loss of value for the user. Within the audited contracts, slippage tolerance is used in two functionalities:  Calling the trigger through the ExecuteTrigger message, which swaps tokens in accordingly the contracts/dca/src/handlers/execute_trigger.rs:207. selected strategy to  Providing the contracts/dca/src/handlers/z_provide_liquidity.rs:37. ZProvideLiquidity liquidity using message in In both instances, the user can optionally dene a custom slippage value. If none is provided, the default value will be used. the default value for slippage_tolerance (for ExecuteTrigger) and However, slippage_tollerance (for ZProvideLiquidity, please note the spelling mistake in the variable name) is Uint128::one(). Consequently, users may experience signicant losses when using these functionalities without dening a custom slippage tolerance value. In the case of pairs with low liquidity, such token swaps may be detected by MEV bots, which could sandwich the messages and thereby extract maximum value from the user. In addition, note that in both of the above-mentioned cases, the functions do not validate the optional user-provided slippage parameters. Consequently, if their value is greater than 1, there will be an underow in contracts/dca/src/helpers/swap.rs:23 and contracts/dca/src/handlers/z_provide_liquidity.rs:49, which will result in a panic.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Vault deposits can trigger recursive trigger executions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "a in via can vault deposit in Anyone deposit_handler contracts/dca/src/handlers/deposit.rs. the vault was inactive prior to the deposit, a new trigger is saved in line 96 with the target time set to the current block time, prompting an immediate execution. If the vault has destination addresses congured to deposit distributed funds directly into other vaults, this can possibly lead to recursive trigger executions. the If function the described vulnerability was also detected by the We would like to point out Calculated Finance team during the audit. A x was prepared, which was then reviewed by the Oak Security team. that",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of conguration parameter validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "Most of the conguration parameters are properly validated before saving them to storage. However, the following parameters are missing validation steps both upon instantiation in contracts/dca/src/handlers/instantiate.rs:23-33 and upon update in contracts/dca/src/handlers/update_config.rs:24-34 :  A maximum size is not enforced for the fee_collectors vector. This could lead to out-of-gas errors during iteration if a big enough list of collectors is supplied.  Empty allocations in the fee_collectors vector are not rejected.  A page_limit of zero is not rejected, even though it would render some of the contracts queries ineective, as no elements would be returned. In addition, the assert_page_limit_is_valid function implements a default value of 30, therefore if the limit is below that number, any query that makes use of the default value will return an error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Inconsistent pair identication in storage",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "When saving new pairs in contracts/dca/src/state/pairs.rs:7-9, the storage key is determined as format!(\"{}-{}\", denoms[0], denoms[1]). Therefore, both pairs A-B and B-A are saved as dierent pairs with potentially dierent routes. The find_pair function in lines 15-23 checks the existence of both options, however, it will always return the rst that matches the submitted ordering. Returning dierent unexpected inconsistencies in gas costs and swap fees. routes depending on the order of the assets in a pair will cause",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. minimum_received_amount not applied to swaps might give a false sense of security",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "through the execute_trigger_handler function in When executing a trigger contracts/dca/src/handlers/execute_trigger.rs, vault.minimum_received_amount is checked against belief_price. However, it is not instead, vault.slippage_tolerance is supplied. swap message 207-215, provided actual lines the to in Since no verication exists to guarantee that vault.slippage_tolerance aligns with the same the minimum_received_amount creates a false sense of security for users, as it is not eectively used in the nal swapping process. minimum_received_amount, usage level risk as of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Lack of validation upon swap adjustment",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "The update_swap_adjustment_handle function allows for arbitrary values to be submitted as the swap adjustment, aecting the number of tokens to be swapped by this factor. If a large value is assigned, the swap will fail, as the resulting amount designated for swapping will exceed the available funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Lack of validation in liquidity provision cache",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "z_provide_liquidity_handler in The function not contracts/dca/src/handlers/z_provide_liquidity.rs:28-35 validate the saving provider_address PROVIDE_LIQUIDITY_CACHE storage. Providing an incorrect address will cause the subsequent reply handlers to fail, wasting computational resources, or rendering the locking useless if a duration of zero is provided. does to it user-submitted before the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Lack of validation of custom swap fee denom",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "create_custom_swap_fee_handler The function in not contracts/dca/src/handlers/create_custom_swap_fee.rs:9-23 validate that the supplied denom actually exists. In case of a typo, the admin might not be aware of the error, and since the expected denom will not be found, no fee will be applied to the desired operations. does",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Misleading lack of feedback upon fee removal",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "remove_custom_swap_fee_handler in function The not contracts/dca/src/handlers/remove_custom_swap_fee.rs:7-19 validate that the supplied denom is part of the current custom fees. Since no feedback is returned when removing a non-existing element from the storage, the admin would not be aware of the error, for example, in case of a typo. Therefore undesired fees will still be charged afterward. does",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. New vaults may be inactivated right after creation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "create_vault_handler in The contracts/dca/src/handlers/create_vault.rs does not assert the initial token deposit info.funds[0].amount is sucient to guarantee a successful swap of the desired number of tokens, i.e. swap_amount. As a consequence, such a vault would be inactive and unable to perform token swaps due to insucient funds. function that",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Lack of role-based access controls for the pausing mechanism",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "The codebase implements a pausing mechanism, which is in line with best practices. However, all of the administrative functions of the contract are centralized in the admin role, which goes against the principle of least privilege. Segregating the pauser role has the additional benet of swifter reactions in case of need when assigned to an EOA compared to the admin that might be managed by a multisig or a governance contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Swap pair route can have duplicate entries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "create_pair_handler The in contracts/dca/src/handlers/create_pair.rs allows the contract admin to create and update swap pairs. The pair.route eld is used to specify the route (i.e., pool ids) that should be used for swapping tokens. While there are various checks in place to ensure that the route is not empty and the route matches the base_denom and quote_denom, there is no check to ensure that the route does not contain duplicate entries. function A swap pair with duplicate route entries will increase the total swap fees and gas costs when swapping tokens.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Vault label length is not validated to be less than 100 characters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "Users can specify a label when creating a new vault via the create_vault_handler function in contracts/dca/src/handlers/create_vault.rs. The label is stored in the vault.label eld and is solely used for o-chain display purposes. While updating a vaults in contracts/dca/src/handlers/update_vault.rs is restricted to 100 characters, there is no such restriction when creating a new vault. update_vault_label_handler function label the via In addition, empty labels are allowed which do not serve the intended asset identication purpose.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Inability to update important vault conguration parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf",
        "body": "A vault owner can currently update the vault label via the update_vault function in other contracts/dca/src/handlers/update_vault.rs. However, important vault conguration parameters that cannot be updated once the vault is created. This includes the swap slippage tolerance (slippage_tolerance), the minimum receive amount (minimum_receive_amount), and the destination addresses (destinations) for fund disbursement. there are The inability to update these parameters can be problematic in certain situations. For instance, if the vault owner wants to increase the slippage tolerance to ensure that the vault is able to swap tokens even when the market is volatile or liquidity is low, or if the initially provided slippage value was too conservative. In such cases, they would have to cancel the vault and create a new one.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Duplicate member addresses inate the total weight value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "the contract instantiation in phase During contracts/cw4-voting/src/contract.rs:32-37, the msg.initial_members vector that contains the Member struct address and weight is not validated to make sure the If a duplicate member address is member address is unique across the whole contract. provided, the associated address and weight would be overwritten by the USER_WEIGHTS storage state, as seen in line 35. However, the total weight value in line 36 would still include the nonexisting member weight. This would impact voting outcomes. A test case demonstrating the above scenario can be found in appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Duplicate item name causes ghost contracts to be instantiated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "In contracts/cw-core/src/contract.rs:83, the msg.initial_items parameter that contains the InitialItem vector is not validated to have unique item names. Having two or more items with the same name would cause them to be instantiated as ghost contracts because eventually, the item name with the highest reply id would be used, as seen in line 746. As a result, this causes ineciencies in the contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Lack of delay when executing proposals makes contracts prone to governance attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "In contracts/cw-proposal-single/src/contract.rs:217, there are no time delays when executing passed proposals. An attacker with enough capital can potentially stake many tokens to gain high voting power, create a malicious proposal and then vote for it. Since proposals can pass early as long as the voting threshold is reached (see contracts/cw-proposal-single/src/proposal.rs:112-114) a passed malicious proposal without giving the community enough time to discuss and block the governance attack. As a result, the attacker's governance attack would succeed, causing potentially catastrophic damage to the protocol. This is especially problematic if the contracts hold non-native tokens, which may have a higher value than the cost of the attack. execute to",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Consider checking whether the item key exists before removing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "In contracts/cw-core/src/contract.rs:420-434, any provided key as an argument will be removed from the ITEMS storage state as seen in line 430. Since the remove storage function will not dierentiate whether the key exists or not, it is possible to remove a key that never existed in the storage.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Admin withdrawals will aect the reward distribution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "execute_withdraw The in contracts/stake-cw20-reward-distributor/src/contract.rs:185 allows the the contract without an option for a partial admin to withdraw the entire balance of withdrawal. function After the admin withdraws funds using a Withdraw message, the contract will have empty funds, which causes the minimum comparison in line 156 to result in a zero amount. This implies that the Distribute message would pay zero rewards to the staking address for the whole staked duration. The staking address would need to wait some time for the pending rewards to recover to the intended value to receive another set of staking rewards. We consider this to be a minor issue since only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Reward duration should be validated as non-zero value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "contracts/stake-cw20-external-rewards/src/contract.rs:65, In msg.reward_duration represents the reward duration value which is used to calculate the reward rate. If the reward duration value provided is 0, it would cause a division by zero error in line 174 during the execute_fund functionality, causing the contract to be unable to be funded. We consider this to be a minor issue since only the contract owner can cause it. Even if it happens, the problem can be resolved by updating the reward duration to a non-zero value via the UpdateRewardDuration message.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Maximum number of items is not sucient to prevent out of gas error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "MAX_ITEM_INSTANTIATIONS_ON_INSTANTIATE The in contracts/cw-core/src/contract.rs:84 is not sucient as it will allow for such a large number of items that the proceeding instantiation loop will run out of gas well before the limit is met. The maximum should be set to a more conservative value rather than u64::MAX - 100. validation",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. execute_pause does not enforce maximum pause duration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "The execute_pause function in contracts/cw-core/src/contract.rs:173 does not enforce a maximum pause duration. The value of pause_duration is added to the current block time and then saved to PAUSED with no checks or validation. This is problematic because if the value is accidentally set to a very high value, it will eectively render the contract useless, without a way to recover. Another potential scenario is that the duration is sent as a Height rather than a Time, which may result in the contract being paused for longer than anticipated.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Incomplete threshold validation in staked balance voting contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "In contracts/cw20-staked-balance-voting/src/contract.rs:84, ActiveThreshold::Percentage is only validated to be smaller than 100%, but not validated to be larger than 0%. Zero values may cause undesired voting outcomes.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Admin rights go against best practices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "It is best practice to restrict admin permissions to actions that do not directly allow access to or could create a loss of user funds. In contracts/cw-core/src/contract.rs:194, the contract admin can run any message, introducing a centralization risk and a single point of failure if the admin keys are lost or compromised. In other reports, centralization risks have been agged with higher severity. In this case, we interpret the admin as a parent DAO which mitigates the centralization risk.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Voting module design is prone to conguration risk",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "The core contract and the voting module are closely interlinked. Because the voting module has only one interface (i.e. to the core contract), updating the voting module introduces an additional point of failure and a conguration risk (e.g. that a proposal module is congured as the voting module) without many benets that come from the modular design. Because this issue is based on a design choice the severity is informational.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Additional funds sent to the contract are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "In contracts/stake-cw20-external-rewards/src/contract.rs:143-153, a check is performed that ensures that in the transaction there is a Coin with the expected denom eld. This validation does not ensure that no other native tokens are sent though, and any additional native tokens are not returned to the user, so they will be stuck in the contract forever.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Voting thresholds can be set to unusual values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf",
        "body": "packages/voting/src/threshold.rs:73-80, In set PercentageThreshold such that a majority can be achieved under very unusual conditions (e.g. if 1% are in favor and 99% percent are against a proposal). While this allows possible to is it for innovative forms of governance, it is prone to user error which may lead to devastating consequences.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. UpdateExchangeRate message leads to delegation of incorrect amount of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The execute_update_exchange_rate function tries to delegate more than it should, as it doesnt take into account the protocol_fee that needs to be accrued in case it is not zero. This causes ExecuteMsg::UpdateExchangeRate to error if the contract balance is less than the amount to be delegated plus the protocol fee. variable claimed_rewards in The the contracts/prism_hub/src/autho_compounding.rs:87, in the protocol_fee the message contracts/prism_hub/src/autho_compounding.rs:66. Therefore, moving fee funds will be executed rst and then the delegation message will try to delegate an amount bigger than the actual balance, as protocol_fee has already been transferred. used includes fee_collector transferred incorrectly previously since it that to is is A proof of concept test case for this security issue can be found at Appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. State update not stored",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The execute_update_global function uses the incorrect instance of the loaded STATE to update the principle_balance_before_exchange_update element of the struct. it could Although at dramatically aect future features as an outdated value would result in incorrect results when used as part of calculations. the code base does not make use of this element, the moment of changing Instead in contracts/prism_hub/src/contract.rs:213, the code changes the value that is loaded Consequently, principle_balance_before_exchange_update will never be updated. last_state stored. never value initial state but the the of in Please note that we consider this issue to be a minor issue since the aected variable is not used. In a future release, this issue might have critical consequences.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Custom access control implementation is error-prone and decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract implements custom access controls, which introduce a few issues: The transfer of the creator role to a dierent account is implemented in a one-step fashion without conrmation from the receiving party. This could potentially cause a loss of access to the role in case a mistake is made during the role transfer. In addition, the Access Control logic that enforces these restrictions is duplicated across the handlers of each function, which negatively impacts the code's readability and maintainability, as it is error-prone.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Lack of conguration parameter validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract lacks validation steps on most conguration parameters upon instantiation or update. Although the values are supplied by the owner, the well-functioning of the protocol if an unexpected value were to be assigned by mistake or if a rate parameter were assigned a value outside of the 0 to 1 range. For example, a fee rate of 1 this could aect will not make the protocol usable, while a fee rate greater than 1 will lead to the protocol losing value. The following lines are aected:  contracts/prism_hub/src/config.rs:35-40  contracts/prism_hub/src/contract.rs:70-75",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. uluna coin denom is used instead of underlying_coin_denom",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract denes in the Parameters struct the underlying_coin_denom eld. This parameter represents the denom of the coin that is delegated by the contract to validators. However in lines:  contracts/prism_hub/src/autho_compounding.rs:68  contracts/prism_hub/src/autho_compounding.rs:89  contracts/prism_hub/src/contract.rs:44 instead of using the correct denom saved in the store, uluna is hardcoded. This implies that the contract will work on chains with a uluna denom, such as Terra.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Pseudorandom validator selection can be predicted and gamed by validators",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "In order to fairly select a validator during auto compounding, unbonding, and validator delisting, the protocol is using XorShiftRng with the current block height as a seed to generate a pseudo-random index. This calculation at a certain block height is easy to predict. Validators could use this information to try to execute a specic transaction at a specic block height in order to be selected, in case of auto compounding, or not be selected in case of unbonding and validator delisting.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. WithdrawUnbonded transaction requires the execution of multiple unbounded loops",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "In execute_withdraw_unbonded function running multiple unbounded loops. contracts/prism_hub/src/unbond.rs:146, the handles WithdrawUnbonded messages In line 168 the process_withdraw_rate function executes two unbounded loops over all not processed yet UnbondHistory. In line 170 the get_finished_amount function executes an unbounded loop over the user unbounding waitlist. In line 180 and 181 the get_unbond_batches and remove_unbond_wait_list functions execute an unbounded loop over the user unbonding waitlist. This implies that under specic conditions, for example if the user has a lot of pending batches to unbond in the whitelist or if the user is another contract that does a big number of operations, the execution can run out of gas and the user would not be able to withdraw their funds. We consider this issue to only be of minor severity since it is unlikely to occur in the short to mid-term.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Updating token_contract will aect previously bonded funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The contracts/prism_hub/src/config.rs:74. update admin can the token_contract parameter in As the entire protocol state relies on information that depends on that parameter or queries using that parameter, any update will aect users that have their funds previously bonded by not allowing them to unbond. We classify this issue as minor since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Outdated and unmaintained dependencies in use",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract uses outdated versions of multiple libraries, version that publicly known vulnerabilities CVE-2021-32810 and CVE-2020-35880. including a cosmwasm-vm In addition, two libraries were aected by lacks some important upgrades. Although bigint is not maintained and therefore there is no x available, crossbeam-deque aected by CVE-2021-32810 has an ocial patch ready. Further details can be found in Appendix 2.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Custom functionality for checking additional funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract makes use of custom functionality to check for additional funds being sent in and contracts/prism_hub/src/bond.rs:35-47 contracts/prism_hub/src/contract.rs:39-45. Although not a security issue, well-known community-driven libraries are recommended for this kind of feature.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Canonical address transformations are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "While previously recommended as a best practice, usage of canonical addresses for storage is no longer encouraged. The background is that canonical addresses are no longer stored in a canonical format, so the transformation just adds overhead without much benet. Additionally, the codebase is more complicated with address transformations.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Missing tax deductions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero tax rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See this discussion for more details about the tax rate changes on Terra.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Typographical errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "In contracts/prism_hub/src/contract.rs:51 and other places, the wrongly typed porotcol_fee_collector occurs, which should be protocol_fee_collector. The same misspelling will also introduce a cascading eect when other protocols query the config. In addition, in contracts/prism_hub/src/config.rs:139, the conguration is loaded for a function named token, which is potentially another typo.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Duplicated code can negatively impact maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "read_validators in The contracts/prism_hub/src/state.rs:176 and 20 are performing the same logic. Additionally, all validators are valid in the Prism Auto Compounding cAsset protocol. Code duplication increases code complexity and can negatively impact maintainability. read_valid_validators functions and",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Unused code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "Multiple instances of unused code exist in the codebase, including variables and functions that are only used within tests, but not in the actual contract. Unused code aects the overall code readability, and might confuse users since it is suggestive of any features that are currently not being implemented. The following list includes the aected lines:  contracts/prism_hub/src/state.rs:10, 53-63  contracts/prism_hub/src/contract.rs:36, 37, 58  contracts/prism_hub/src/hub.rs:160, 163  The UnbondHistory struct includes elements that are not in use. batch_id is not used as it is the actual key in the history storage instance. Similarly, applied_exchange_rate and withdraw_rate seem to reect the same value here, however, applied_exchange_rate is only used inside tests and not the actual contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Comment contradicts implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract includes comments describing the required privileges for each function for assigned execution message. comment handler The an as of a execute_register_validator in contracts/prism_hub/src/config.rs:96 states that the functionality is callable only by the creator. However, this diers from the implementation as the Hub contract itself is whitelisted too, given that this message is sent by the contract upon instantiation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Lack of address validation upon querying",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "The Hub contract doesnt validate the input address of the query_unbond_requests function. Although not being a security risk, it may lead to a lowered user experience if incomplete or invalid addresses are provided and no address validation error is returned.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Ineciency in querying a specic validator",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "In contract/prism_hub/src/config.rs:112, the execution is querying the list of all validators in order to check if the provided one is part of the list. Instead of executing query_all_validators and then iterating through the list in order to nd the required one, which has a O(n) complexity, query_validator could be used to directly query the required one.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Lack of pausing mechanism",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf",
        "body": "Currently when the smart contract is deployed, if there is any catastrophic security loophole being discovered there is no quick way to limit its functionality and restrict the potential impact of the vulnerability while the team carries out an investigation/working on an upgrade.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Autocompounder is vulnerable to share ination attack",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "compute_mint_amount The in contracts/autocompounder/src/handlers/reply.rs:130 is vulnerable to a share ination attack. A share ination attack represents a scenario where a malicious actor articially inates the supply of tokens, potentially manipulating the token's value and diluting other holders' shares. function Currently, the function computes the mint amount by using integer division. Due to the nature of integer division, results are always oored. This allows an attacker to inate their current shares while stealing funds from unsuspecting users. The compute_mint_amount is susceptible to this attack because the denominator of the integer division staked_lp can be manipulated for Astroport, representing the total staked amount of the proxy address. An example attack scenario: 1. The attacker makes the rst deposit of 1 token and thus receives one share",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Finally, the computed lp_tokens_withdraw_amount value will be evaluated to 7501 ((1/2) * 15002), earning the attacker an extra 2499 (7501-5002) liquidity pool tokens. redeems attacker shares. their The Recommendation We recommend enforcing a minimum amount that needs to be met in the rst deposit. This will greatly increase the cost of orchestrating a share ination attack. Note that it is common practice to mint dead shares to the protocol to increase the cost of the attack further. For more details, please see Astroports implementation. Status: Resolved 2. Attackers can cause batch unbondings to fail, preventing users from unstaking liquidity pool tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Unbonding cooldowns are not respected",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In the contracts/autocompounder/src/handlers/execute.rs:471-488, check_unbonding_cooldown function attempts to verify the last unbonding time has the LATEST_UNBONDING exceeded the minimum unbonding cooldown time. However, storage state is never stored anywhere in the codebase. Consequently, batch unbondings can be repeatedly performed without respecting the congured cooldown period. This issue also causes the query_latest_unbonding function to fail when loading LATEST_UNBONDING from the storage. We classify this issue as major because it aects the correct functioning of the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Compounding will fail for zero performance fees",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In contracts/autocompounder/src/handlers/reply.rs:190-200, the fees are deducted from rewards and sent to the commission address. However, the swap will fail if the performance fee is zero, preventing the auto-compounding from working successfully. Please see the test_zero_performance_fees test case to reproduce the issue. We classify this issue as minor because the manager contract can recover to a correct state by updating the performance fees.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Hard-coded slippage value makes deposits susceptible to sandwich attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "deposit in The a contracts/autocompounder/src/handlers/execute.rs:143 hard-coded max spread value of 5%. Depending on the pair that liquidity is being provided for, this may be a too large value, making the deposit functionality vulnerable to a sandwich attack. species function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Non-updatable conguration can not reect changes in staking contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "the In contracts/autocompounder/src/handlers/instantiate.rs:139-148, conguration and unbonding_period directly from the staking contract. However, there is no entry point to update this data. min_unbonding_cooldown dened taking both as is In case the aected parameters are modied in the staking contract, this will cause inconsistencies in the unbonding mechanism. The underlying messages directed to the staking contract could fail without the users being able to understand why, as the reported information will not reect the new limits.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Minting of zero vault tokens possible",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The autocompounder contract allows for the minting of zero shares upon depositing in some edge cases. This is possible as CW20 tokens now allow the minting of zero tokens, and the compute_mint_amount function does not perform further validation on the returned in amount contracts/autocompounder/src/handlers/reply.rs:135-143. minted shares be to of Users depositing small amounts of funds could receive zero shares in exchange, eectively losing access to those funds. In addition, this issue causes the Autocompounder is vulnerable to share ination attack to be even more lucrative for an attacker.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Unused variable in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In contracts/autocompounder/src/handlers/execute.rs:98, _staking_address variable is declared, but is not used. deposit the function in the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Lack of validation upon deposit lead to ineciencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The deposit function performs insucient validation on funds to be forwarded for liquidity provision in contracts/autocompounder/src/handlers/execute.rs:111-121. As the funds variable is not explicitly checked to contain pool assets only, the contract would try to provide liquidity with potentially erroneous assets in lines 140-144. This will cause the execution of all the code in the function to end up erroring, consuming an unnecessary amount of gas.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Remove TODO comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The codebase includes multiple TODO comments. It is best practice to remove all pending TODO items before releasing code to production.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Unused commented code in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In contracts/autocompounder/src/handlers/instantiate.rs:78-82, there is unused commented code. It is best practice to remove all unused commented code blocks before code is released toproduction.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Misleading variable name when withdrawing liquidity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In contracts/autocompounder/src/handlers/execute.rs:267 and 382, the swap_msg variable is set when calling withdraw_liquidity on the specic DEX. The swap_msg variable name is misleading, swaps are performed later on the DEX.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. calculate_withdrawals sets expiration to current block height which may become problematic if the function is exposed in a future upgrade",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "the contracts/autocompounder/src/handlers/execute.rs:411-414, In unbonding timestamp defaults to the current block height if config.unbonding_period is None. This is not a security concern in the current implementation, since the calculate_withdrawals function can only be called from the batch_unbond function, which ensures the unbonding period is Some(_), as seen in lines 161-163. If future code was introduced though that allows calling the calculate_withdrawals function without going through the batch_unbond functions, it might cause withdrawals to be unlocked immediately in the next block.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Users cannot query fees through smart queries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "In contracts/autocompounder/src/handlers/query.rs:16-42, no exposed queries return the fee congurations. Consequently, users cannot query the protocol's congured performance, deposit, and withdrawal fees.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Panicking macros and debugging code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The autocompounder contract uses Rust panicking macros to handle undesired situations in contracts/autocompounder/src/handlers/instantiate.rs:96 and 130. Panicking macros do not report meaningful error messages for users to understand what went wrong. In addition, an eprintln! statement which is typically used for debugging purposes can be found in contracts/autocompounder/src/handlers/execute.rs:357-360.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "20. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/autocompounder/Cargo.toml  packages/forty-two/Cargo.toml  packages/forty-two-boot/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "21. Additional funds sent to the contract are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf",
        "body": "The deposit function does not check whether additional native tokens are sent along the in contracts/autocompounder/src/handlers/execute.rs:89-157. message Any additional native tokens are not returned to the user, so they will be stuck in the contract forever. While blockchains generally do not protect users from sending funds to the wrong accounts, reverting extra funds increases the user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. The on-chain entropy is generated by querying Terra for the swap result between LUNA and TerraUSD for the amount of block height plus the block time in seconds. Since the swap amount will increase monotonically by a relatively xed amount, and the exchange rate between LUNA and TerraUSD is expected to uctuate by a few percentage points only per block, the resulting value will have little entropy. Recommendation We recommend relying on a more robust source of randomness. Status: Acknowledged The Ink team states in their documentation that it plans to move to an Oracles VRF as the source of randomness in a future version. 10. Updating Anchor aUST and market contract addresses in Anchor strategy could lead to incorrect states",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Ink Protocol/2021-09-15 Ink - Audit Report.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Users can steal all LP tokens from the Apollo static strategy",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "the apollo-static strategy Since in contracts/strategies/apollo-static/src/strategy.rs:38 will query the LP token balance of the contract including all previous deposits by other users. All of these deposits will be assigned to the caller, and the user can then extract all that value by immediately withdrawing/zapping out. LP tokens, the query simply holds",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Registering fees in the factory contract does not update the strategys extension reward index",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "the handle_register_fee in In the contracts/apollo-factory/src/contract.rs:586, strategys EXTENSION_TOTAL_COLLECTED_FEES extension_reward_index eld is not adjusted. That leads to an inconsistent state. Additionally, update_strategy is called, even though there were no changes to the strategy. updated, function are but the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Users are unable to collect rewards after withdrawing/zapping out of strategy",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "In contracts/apollo-factory/src/contract.rs:816, strategies are skipped if a user has no active deposits in a strategy. Users might have withdrawn/zapped out of a strategy, and hence have zero shares, but they might not have collected rewards yet. Such users are unable to collect the condition described above. the rewards from the strategies because of",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Strategies that start with paused rewards can never receive any rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "The rewards_paused eld cannot be updated in the handle_update_strategy function in contracts/apollo-factory/src/contract.rs:516. That means that a strategy that started without rewards can never receive any rewards.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Current block height not used in reward calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "the reward In packages/apollo-protocol/src/vault/vaults/anchor.rs:119, info from Anchor deposits is queried. That query uses a block_height of None, which will cause Anchor to return the latest stored values, rather than recalculating them at the current block height.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. APR calculation might panic if staked liquidity value is zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "When contracts/strategies/apollo-static/src/strategy.rs:493, might panic when staked_liquidity_value is 0. calculating APR the in contract the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Price queries do not ensure that price base is not outdated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "In multiple price queries from the oracle contract, the time since last_updated_quote is asserted to be greater than the strategys price_age_limit. However, the time since last_updated_base is not asserted  which might lead to usage of outdated prices. Instances of that issue are found in:  contracts/strategies/apollo-static/src/strategy.rs:433  contracts/strategies/apollo-static/src/strategy.rs:467  contracts/strategies/apollo-static/src/strategy.rs:481  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:409  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:465  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:479  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:423",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Queried reward and LP token prices in Apollo autocompound strategy are not checked to not be outdated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "the querying When in packages/apollo-protocol/src/strategy/strategies/autocompound/stra tegy.rs:309-325 and in 369-385, a check should be added to ensure these prices are not outdated. reward_token_price lp_token_price and",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Anchor reward rate calculation does not account for overlaps in distribution schedule",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf",
        "body": "rate reward in The not packages/apollo-protocol/src/vault/vaults/anchor.rs:147 account for overlaps in the distribution schedule coming from the anchor cong. The Anchor factory does allow overlaps. In the event of an overlap, the reward rate would be o. calculation rewards Anchor does for",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Users will receive incorrect amount of LP tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "execute_balancing_provide_liquidity The in osmosis-liquidity-helper/src/contract.rs:78 allows users to provide either a single asset or a pair of assets to a pool. In the case that a user provides multiple assets, the contract rst performs a double-sided liquidity provision followed by a single-sided provision for any left over assets. function the LP tokens minted during the double sided liquidity provision are never However, transferred to the recipient. The LP tokens received from the initial liquidity provision that will be returned in response to the message in line 122 will never get recorded because the ReturnLpTokens callback was not called with the contracts initial lp_token_balance. The result will be that the caller will only receive LP tokens for the second liquidity provision.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Balanced liquidity provision into constant product pool will fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "When a user performs a balanced liquidity provision into a constant product pool in astroport-liquidity-helper/src/contract.rs:90, the contract rst swaps any tokens to ensure the ratio remains constant and then supplies the tokens into the pool. Subsequently, the contract returns the received LP tokens to the recipient using the callback function ReturnLpTokens. During execution of each message the contract will transfer the recently minted LP tokens from itself in astroport-liquidity-helper/src/contract.rs:185-190 and then again in 250-255. the callback function is called twice, rst to the recipient. However, The ReturnLpTokens callback that is dened in lines 185-190 will be executed before the liquidity is provisioned and the contract's balance changes. This will cause return_amount in line 274 to be 0. When the function attempts to transfer a zero amount the CW20 transfer return an error and revert function will execute_balancing_provide_liquidity function. the transaction. This will eectively block the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. No validation of min_out for double sided liquidity provision",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "When providing liquidity in the execute_balancing_provide_liquidity function in osmosis-liquidity-helper/src/contract.rs:78, users are able to specify the min_out value which denes the minimum amount of LP tokens they want to receive when providing liquidity. In the case that a user provides multiple assets to a pool, the amount of LP tokens minted is never checked to ensure it is greater than the value min_out. This means users may in fact receive fewer LP tokens than expected.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Insucient validation of swap paths",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "In function update_path in cw-dex-router/src/contract.rs:231-249, the contract admin is able to add swap paths to enable the liquidation of tokens that both do and do not share a direct pool. Currently, the contract validates that the rst and last assets match the oer and ask assets. In the case that there are swap operations performed there may be a situation where intermediary assets do not match. This would cause the failure of any execution of the function basket_liquidate. We consider this a minor issue as the admin controls the addition of swap paths.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Insucient validation of vault conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "When instantiating and updating the cong of a vault, the function check is called in which apollo-vaults/packages/apollo-vault/src/state.rs87-110 than it insuciently Decimal::one(). the performance_fee to ensure that validates less is Specifying a performance fee of greater than Decimal::one() would cause an overow in apollo-vaults/packages/apollo-vault/src/state.rs:94. Additionally, reward_liquidation_target is not enforced to be one of the assets in the pool as specied in lines 32-34, which could potentially cause inconsistencies in the overall behavior of the vault.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Basket liquidation fails if no path is found for oer asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "the basket_liquidate function In cw-dex-router/src/contract.rs:251-305, swaps all oer assets into a single receive asset. The swap paths that are used to exchange the oer for the receive asset are dened by the contract admin. In the case that one of the oer assets does not have a path set to the receive asset the throw an error in cw-dex-router/src/contract.rs:276. This would contract will prevent liquidation and the original calling function, execute_compound found in apollo-vault/src/execute_compound.rs, but also the primary function of the relevant vault. the execution of both the basket We consider this only a minor issue as the swap paths are dened by the contract admin.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Lack of Osmosis Vault parameter validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "The osmosis-vault contract from Apollo vaults instantiate function does not validate the submitted msg.pool_id before storing it. This might cause two dierent vaults to coexist with the same ID but dierent base and vault tokens, potentially confusing users. it In addition, is recommended to validate msg.lockup_duration to be within the expected range to avoid creating either a zero or an arbitrarily large lockup duration by mistake.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Use of magic numbers throughout the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "Throughout the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. Instances of magic numbers are listed below:  astroport-liquidity-helper/src/contract.rs:62  astroport-liquidity-helper/src/contract.rs:95  cw-dex/src/implementations/astroport/helpers:185-186",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Additional funds sent to the contract are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf",
        "body": "In apollo-vaults/packages/apollo-vault/src/execute_staking.rs:46, a check is performed that ensures that in the transaction the desired native assets have been received. This validation does not ensure that no other native tokens are sent though, and any additional native tokens are not returned to the user, so they will be stuck in the contract forever.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Truncated CW20 token transfer amount for CW20 tokens with more than 8 decimals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "The Wormhole token bridge contract truncates CW20 token amounts to 8 decimals. implies that a small amount of tokens (the so-called dust) stays in the This token-translator contract and is not transferred to the Wormhole token bridge. The user will hence receive fewer bridged CW20 tokens than initially transferred tokenfactory tokens.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Lack of conguration parameter validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "instantiation, During contract are WORMHOLE_CONTRACT token_bridge_contract InstantiateMsg message. the storage variables TOKEN_BRIDGE_CONTRACT and the initialized the src/contract.rs:33-39 with in values wormhole_contract supplied in and However, the provided values are missing address validation. Invalid strings would lead to a non-functioning contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Contracts are not compliant with the CW2 Migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "The token-translator contract does not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Redundant check on the submessage reply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "the submessage has been successful by The token-translator validates whether checking the replys result this check is unnecessary as the submessage is declared as SubMsg::reply_on_success. For SubMsg::reply_on_success submessages, the reply handler is only called upon the success of the submessage, making it impossible that the result is an Err variant. in src/contract.rs:94-97. However, Although not a security issue, unnecessary code can negatively impact maintainability and slightly increase gas consumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Unused WORMHOLE_CONTRACT storage variable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "During contract instantiation, the WORMHOLE_CONTRACT storage variable is initialized with the wormhole_contract value in src/contract.rs:37-39, which is supplied within the InstantiateMsg message. However, the value of WORMHOLE_CONTRACT is never read from storage or used in any other way.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Missing attributes on some message handlers responses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "informative attributes when The token-translator contract does not make use of returning a response in the convert_and_transfer, convert_bank_to_cw20, and convert_cw20_to_bank message handlers. This could negatively impact o-chain services that try to monitor the state of the protocol. In addition, although the contract does not save any owner eld in the storage. the instantiation function response includes a misleading owner attribute,",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Unhandled zero-amount transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf",
        "body": "Using the ConvertAndTransfer and ConvertBankToCw20 messages, a user can send tokens to the contract. They are later validated in the context of whether more than one type of coin has been sent, but there is no validation enforcing that the transferred amount is greater than zero. As a consequence, the functions may unnecessarily perform operations, ending up with a panic, and Cw20ExecuteMsg::Transfer do not support transferring zero-amounts. TokenBridgeExecuteMsg::InitiateTransfer because both This leads to unnecessary gas consumption. Also, panics degrade the user experience since they do not provide any context why an error has occurred and how it can be resolved.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. Unsuccessful MsgTransfer message could drain the relayers funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Persistence/2023-02-17 Audit Report - pSTAKE Native v1.0.pdf",
        "body": "In x/lscosmos/keeper/handshake.go:488-500, the function responsible for handling Timeout and Acknowledgement_Error responses (see lines 196 and 258) originated by MsgTransfer messages try to resend them through GenerateAndExecuteICATx. In a scenario where a transaction always has unsuccessful responses, the execution will end up performing a loop between the controller and controlled chains with the result of draining the relayers funds. For example, this could happen if the controlled chain is halted or is performing an update. Additionally, an attacker may trigger multiple such transfers to congest and slow down the chain. As a result, users will nd their transactions taking more time to process.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Liquidated and excess funds are stuck in the liquidation lterer contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "contracts/liquidation-filterer/src/contract.rs:84, the In execute_liquidation function does not properly handle collateral transfer after a liquidation attempt. We outline three possible scenarios that causes funds to be stuck in the contract: Firstly, the liquidation logic forces the caller to provide funds in line 99, but there is a possibility that the user to liquidate is not liquidatable. In this case, the provided funds are not refunded. the red bank refunds excess funds to the liquidation lterer contract (see Secondly, contracts/red-bank/src/execute.rs:1083-1088). There is no way to withdraw these excess funds though. Lastly, the red bank contract will transfer Mars tokens to the contract after a successful liquidation attempt. There is no logic in the contract that allows a withdrawal in return for the liquidated collateral. As a result, the liquidated collaterals are inaccessible.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Liquidation lterer contract cannot process multiple liquidations eciently",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "contracts/liquidation-filterer/src/contract.rs:114, In two of Liquidation messages are constructed, debt_denom or user_address, the transaction will return an error. when them have the same least if at The former happens because the sub-messages reuse the total funds with the same denom. Since the rst message already includes all funds, the contract will not have enough funds to process the subsequent liquidation messages with the same denom. The latter fails because the contract would send duplicate liquidation messages to the red bank contract, and since liquidating a user twice is not possible, the transaction would fail too. Additionally, the liquidation lterer contract does not tolerate failures. The whole liquidation execution would fail if any liquidation attempts were frontrunned by another liquidator. As a result, undercollateralized positions might not be liquidated eciently during high volatility and activity in the market.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Smart contracts holding tokens on Terra classic cannot claim their airdrop",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "of the current airdrop implementation The in contracts/airdrop/src/contract.rs requires users to prove their ownership of Terra tokens by providing signatures using the same private keys that were used in Terra classic. Smart contracts, however, do not have the capability to sign messages as they do not have private keys. As a result, smart contracts are unable to provide the required signatures, making it impossible for them to claim airdrops. This prevents smart contract holders from participating in airdrops, which could lead to a signicant portion of the token holders being excluded from the airdrop distribution. contract smart",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. liquidation-filterer contract is not compliant with CW2 Migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The liquidation-filterer contract does not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. InstantiateMsg is not validated in the airdrop contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In contracts/airdrop/src/contract.rs:28, when handling the InstantiateMsg, no validation of the merkle_root length and sent funds is performed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Schedule structs are not validated in the vesting contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In  contracts/vesting/src/contract.rs:37,  contracts/vesting/src/contract.rs:102, and  contracts/vesting/src/contract.rs:65, the Schedule structs are handled without being validated. This could lead to situations where the start_time timestamp value is less than the current timestamp or the cliff value is greater than or equal to duration.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. liquidation-filterer contract could be optimized",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The liquidation-filterer contract is designed to be able to trigger a set of liquidations in the red bank. In order to accomplish this, the LiquidateMany message takes a list of Liquidate elements, iterates through all of them, performs a query in order to check if they are liquidatable, and then forwards the Liquidate messages to the red bank. Since the list of Liquidate elements could be of a relevant cardinality and each iteration performed both a query and a transaction, there is a possibility that the execution goes out of gas and reverts all the intended liquidations. Also, transactions can change the health status of a position, which invalidates previous query results.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/liquidation-filterer/Cargo.toml  contracts/airdrop/Cargo.toml  contracts/vesting/Cargo.toml While enabled implicitly through the workspace manifest, future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Contracts should implement a two step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Custom access controls implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "Contracts implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Incorrect comment for LiquidateMany message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In contracts/liquidation-filterer/src/msg.rs:17, the LiquidateMany message is Set emission per second for an asset to holders of its maToken. This is incorrect because the messages functionality is to liquidate multiple undercollateralized positions from the red bank. the comment for",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Suboptimal voting power calculation in vesting contract allows for unfairness in voting process",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The current implementation in contracts/vesting/src/contract.rs:199 calculates voting power from staked tokens, locked tokens in the vesting contract and unlocked tokens from the vesting contract that are not yet withdrawn. Ok(Some(position)) => position.total - position.withdrawn However, this calculation method is suboptimal because it does not account for tokens that are currently withdrawable. In fact, it allows users to vote on a proposal and immediately withdraw the withdrawable tokens, which means that the tokens used to vote are no longer staked and do not contribute to the voting power. This can lead to unfairness in the voting process.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Voting power is valid on the same block schedule created",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf",
        "body": "contracts/vesting/src/contract.rs:197, In query_voting_power functionality determines a users voting power by checking the POSITIONS storage state. Since positions are directly updated in the same block when create_position is called, this might allow an exploit similar to the Beanstalk exploit. the it With that said, is currently not exploitable since only the contract owner can create is another smart contract allowing positions. However, suppose the contract owner permissionless position creation. In that case, an attacker can ash loan a big amount of Mars tokens to create a large position for themselves which comes with high voting power. We consider this a minor issue because it may lead to a vulnerability if the architecture changes in the future.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. NOIZDStaking.sol: Instant withdrawal signatures can be replayed to bypass freeze time in some cases",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf",
        "body": "Nonces are used as a type of withdrawal id to make instant withdrawal permissions unique, which is veried in function _withdrawInstant. However, nonces are kept on a per-user basis, meaning that a user could re-use an admin generated signature intended for another user currently on the same nonce.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. NOIZDStaking.sol: Refund could be blocked by a malicious or faulty receiver",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf",
        "body": "The transaction reverts if a single Ether transfer fails (line 388), allowing a malicious or faulty receiver to block the refund operation. This is mitigated by the fact that the built-in pagination allows the admin caller to avoid such malicious or faulty receivers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. NOIZDNFT.sol: Unreachable conditional statement",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf",
        "body": "The following code in function tokenURI in line 63 will always result in the execution of the rst branch: return string(abi.encodePacked(baseURI, _tokenURIs[tokenId])) : \"\"; bytes(baseURI).length > ? The reason for this is that baseURI is read from the hardcoded value \"ipfs://\".",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Outdated OpenZeppelin release used",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf",
        "body": "The codebase imports a relatively recent version of the OpenZeppelin smart contract library. However, there have been recent security releases that x issues, some of which are related to ECSDA signing. These issues seem not to apply in the present use case of the contracts. However, we recommend using the latest security release, particularly, since the draft EIP-712 implementation used is updated frequently.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Queried voting power when executing proposals is set to current height, allowing anyone to execute proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:365, the callers voting power is queried at the current block height to ensure they are one of the DAOs members. This implies that any caller can execute a proposal by staking a small number of funds after the proposal ends and calling the execute_execute function.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Users might be unable to claim NFTs if they unstake a large amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-cw721-staked/src/contract.rs:143-158, the execute_unstake function attempts to validate the outstanding NFT claims is not greater than or equal to the congured max claim amount. Since the outstanding claims do not include the current amount of token_ids to claim, a user can unstake a large number of NFTs in one transaction as long the old outstanding claim amount is smaller than the max claim limit. As result, users would be unable to claim NFTs using the execute_claim_nfts function due to an out-of-gas error. a Please see the test_bypass_max_claims test case to reproduce the issue. We classify this issue as major since it can only happen when the user unstakes a large number of NFTs in one transaction, but the user is not able to recover these NFTs.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Duplicate input elds would be overwritten",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/dao-core/src/contract.rs:76-78, the InitialItem key from the msg.initial_items vector is being saved into the ITEMS storage state. If there were duplicate keys, the previous ones would get overwritten, causing only the last value to be stored. the that, in Besides duplicate contracts/dao-core/src/contract.rs:497-500 addresses in the to_add vector. Consequently, the previous SubDao charter would get overwritten, causing the SUBDAO_LIST only to save the last charter value. execute_update_sub_daos_list function does lter not",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. DumpState query does not paginate proposal modules which can result in out of gas errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "the query_dump_state In contracts/dao-core/src/contract.rs:665-668, function attempts to fetch all proposal modules stored in the PROPOSAL_MODULES storage. The query will fail if too many stored proposal modules exist due to an out-of-gas error. As a result, the active_proposal_module_count and total_proposal_module_count values cannot be queried, representing the number of active proposal modules and the total number of proposal modules. We classify this issue as minor since only the contract admin can instantiate proposal modules.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Admin can replay migration to overwrite dao_uri and re-enable proposal modules when contract is paused",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "The migrate handler in contracts/dao-core/src/contract.rs:831-879 does not ensure the current contract version is lower than the version to migrate to. This is problematic because the contract admin can abuse the migration function to modify the dao_uri and re-enable all proposal modules when the contract is paused, allowing them to partially bypass the contract state. Ideally, a paused contract should not have its storage state mutable until the expiration ends. Please see the test_replay_migrate test case to reproduce the issue. We classify this issue as minor since only the contract admin can perform migrations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. DAO has inuence over voting results",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:285, the voters voting power is determined by querying the congured DAO contract. Since the total voting power is queried and stored as seen in line 207, updating the DAO contract to a dierent address might cause incorrect voting results. Suppose the voter staked more tokens in the newly updated DAO contract. This would cause the execute_vote function to query the new voting power and compare it against the old total voting power, leading to an incorrect voting result. Besides that, the DAO can also update the only_members_execute boolean which aects the execute_execute function. Suppose the only_members_execute conguration is set to true during the proposal creation time and set to false after the proposal passes. The DAO members would expect only they can execute the proposal. However, since the only_members_execute value is loaded from the conguration directly, anyone can execute the proposal. close Lastly, the close_proposal_on_execution_failure boolean can be updated by the DAO to the execute to close_proposal_on_execution_failure was set to false and the message to execute fails in line 409. The DAO can interfere by updating the conguration to true and re-execute the function, causing the proposal status to be set to ExecutionFailed. automatically. proposals Suppose that fail This issue is also present contract. in the contracts/proposal/dao-proposal-single We classify this issue as minor since only the DAO contract can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Too many proposal modules stored would cause migration to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "contracts/dao-core/src/contract.rs:837-859 and In contracts/proposal/dao-proposal-single/src/contract.rs:879-919, all stored proposal modules are collected without pagination. This is problematic because if too many proposal modules were stored, the migrate function would fail due to an out-of-gas error, preventing the admin from migrating the contract to the latest version. We classify this issue as minor since only the contract admin can instantiate proposal modules.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Setting AbsoluteCount to zero will always show proposals as active",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-cw20-staked/src/contract.rs:307-315, no validation ensures the count value inside the ActiveThreshold::AbsoluteCount enum is greater than zero. In comparison, the ActiveThreshold::Percentage enum is validated to ensure the percent value is greater than zero in line 213. If the count value is congured to zero, the query_is_active query will always return true despite the total amount of tokens staked being zero. We classify this issue as minor since only the DAO contract can congure active thresholds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. A counterparty in escrow can always withdraw, resulting in temporary grief",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In the contracts/external/cw-token-swap/src/contract.rs:197, execute_withdraw function allows a counterparty to withdraw the funds deposited in the contract. Since the escrow completion depends on the payment of the last counterparty, whoever deposited rst can always withdraw their (such as frontrunning the other user), causing the transaction never to be completed. funds from the contract",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Active threshold could be set for a very small percentage",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-cw20-staked/src/contract.rs:214-229, the execute_update_active_threshold function allows a DAO to set an active threshold. It validates that the threshold is between 0 to 100, meaning the DAO can set it to a very small percentage (e.g. 2%). This may allow malicious participants to execute an attack on the DAO.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. All implemented electoral schemes are Condorcet-incomplete",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "Both intended electoral systems, ranked choice voting and single-member plurality voting, do not satisfy the Condorcet winner criterion. This means both cannot ensure that the Condorcet winner (the alternative that would win a two-option vote against each of the other options in a plurality vote) wins the vote. A mechanism to pick a Condorcet winner is desirable because it is considered prudent decision-making, particularly regarding budgetary decisions.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Migration does not update the latest contract name and version",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-staking-denom-staked/src/contract.rs:1 16-118, the migrate handler does not automatically set the latest contract name and version. If the admin migrates the contract, the query_info query in line 100 will still show the old contract name and version.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Users can unstake zero amounts of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-native-staked/src/contract.rs:180-197, the execute_unstake function does not validate the amount to be 0. Since the amount is not validated, a valid claim is still created for the user, causing the outstanding claims to be increased in line 182. Consequently, the current outstanding claims will be growing and compared to the MAX_CLAIMS amount, potentially causing the user to be unable to unstake tokens as intended.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Permissionless proposal creation policy could result in spam proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/proposal/dao-proposal-single/src/contract.rs:164-166, the DAO contract allows dierent congurations. If the pre-propose module is unset and the proposal_creation_policy is set to Anyone, malicious users can spam the DAO with unnecessary proposals.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. dao-voting-staking-denom-staked allows malicious actors to manipulate voting power",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/voting/dao-voting-staking-denom-staked/src/contract.rs:5 8-98, the query_voting_power_at_height and query_total_power_at_height function return the current voting power irrespective of the provided height argument. Normally, the total voting power of a proposal is snapshotted at a specic block height using the TotalPowerAtHeight VotingPowerAtHeight is queried with the proposals start height to get the users staked amount. Since both queries return the height based on the users argument value, this means the user-staked amount can be manipulated. contract. When voting votes, user the in a If the user changed their staked amount (e.g., staked more tokens), their staking power would be changed. However, the total power saved in the proposal still uses the old total staking power value. Due to this, users who vote will be queried with current voting power, not snapshotted power. This allows malicious users to manipulate their voting weight. For example, imagine Alice and Bob each have 500 voting power at block height 10. The stored total voting power in the proposal will be 1000 (500+500=1000). At block height 20, Alice stakes more tokens causing her voting power to be 1200. Alice then votes, and the contract queries Alices voting power at block height 10. However, due to the issue described above, her voting power returned will be 1200 instead of 500, causing Alice to have a higher voting power than intended. We classify this issue as minor because ICS chains do not have a staking module, preventing the usage of this contract. However, this would be an issue if the contract is deployed on a chain with a staking module.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Non-token might be miscongured as a staking asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In contracts/staking/cw20-stake/src/contract.rs:79, any address could be congured as a staking token, even contracts do not implement token interfaces. We classify this issue as informational because the contract miscongure an incorrect CW20 token address, even if implemented. instantiator can always the recommendation below is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Ranked choice voting not implemented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "The documentation mentions the implementation of ranked choice voting, but it is not implemented.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Multiple choice voting is prone to social engineering attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "Multiple choice voting systems, where users can specify options as free text, are prone to social engineering attacks, as users can try to confuse users with odd alternatives. This is particularly problematic in conjunction with Condorcet-incomplete voting schemes, where minority alternatives can win. Users can try to submit duplicate \"No\"-options or introduce \"quasi-No\"-options and split up the \"No\"-voters into smaller subsets such that they do not get a share of votes to prevent any of the other options. An oversimplied example is illustrated below. Question: What kind of horse should we buy? Answers:  Black  Red  We should discuss this again next year  None of the above While both We should discuss this again next year and None of the above are the equivalent of We shouldn't buy a horse now, one of the options Black or Red might win even if the majority of voters do not want to buy a horse, because the No-votes are split.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Iterations over hooks might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf",
        "body": "In packages/cw-hooks/src/lib.rs:34-52, gas. iterations over hooks might run out of We classify this issue as informational as only admins can cause it and it is recoverable.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Conict of permissioning prevents feeder from submitting prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "When feeding prices into a price feed the contract checks that the owner is the sender of the message in contracts/oracle-proxy-feed/src/contract.rs:125. Subsequently when pushing prices to the relevant asset feeds the contract checks whether the message sender is a registered feeder in line 143. This means that only the contract owner who also is the feeder can submit prices to the feeder contracts.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Incorrect price list query in oracle hub",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "hub oracle in The the query_proxy_list contracts/oracle-hub/src/contract.rs:70 function. This incorrectly returns a list of the registered proxies for a specic asset token and not the latest prices. message calls PriceList query",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Unbounded number of oracle proxies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "The number of proxies that can be registered to the oracle hub is unbounded in contracts/oracle-hub/src/state.rs:39. Having a potentially large number of proxies would make execution functions costly and query functions unperformant. In extreme cases, this could cause the querier to run out of gas.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Oracle query functions contain unbounded loops",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "and Band Chainlink The contracts/oracle-proxy-band/src/contract.rs:172 contracts/oracle-proxy-chainlink/src/contract.rs:164. signicant computational resources leading to issues in the calling contracts. functions contain query unbounded loops in and They may use",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Sorting proxy list on every query is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "Every call to query_price in contracts/oracle-hub/src/query.rs:54, 84 and 118 sorts the proxy list. Doing so on every call is computationally inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Legacy price response returns last updated value for quote price in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "The LegacyPriceResponse contains u64::MAX for the last_updated_quote in contracts/oracle-hub/src/query.rs:126. A last updated quote value in the future may be unexpected to callers of the query and may cause errors in calling contract if that edge case is not handled.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "Packages contracts/oracle-proxy-band/Cargo.toml, contracts/oracle-proxy-chainlink/Cargo.toml, contracts/oracle-proxy-feed/Cargo.toml packages/tefi-oracle/Cargo.toml do not enable overflow-checks for release prole. contracts/oracle-hub/Cargo.toml, and the While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Oracle price query variable naming may be confusing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "The oracle hub price query in contracts/oracle-hub/src/query.rs:38 exposes a eld named timeframe, which does not clearly communicate the intent of the eld. Moreover, it is not obvious whether timeframe should be provided in seconds, blocks or the API should be as another unit. Since the oracle may be used by many projects, self-explanatory as possible.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Legacy price query does not support dierent bases",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf",
        "body": "The oracle hub price query in contracts/oracle-hub/src/query.rs:102 takes both a base and quote asset as an argument. However, if the quote asset is not base_denom the contract throws an error in line 108. This makes the API less user-friendly as requests for prices the oracle has access to would be rejected unexpectedly.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. Iteration over queued stakings in end blocker can be exploited to halt block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/All in Bits/2022-04-04 Audit Report - Budget and Farming Cosmos SDK Modules v1.0.pdf",
        "body": "Within the EndBlocker of the farming module, multiple iterations occur over all queued stakings in x/farming/keeper/staking.go:399. An attacker could create a large number of stakings in an epoch to cause the end blocker to run too long to nish creation of the block within Tendermints propose timeout. The cost of this attack is relatively small since the staked amount could be minimal, and staking itself is not gas-intensive.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "1. Vault deposits are not aected by delisted coins",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "In contracts/credit-manager/src/health.rs:160, when a coin is delisted, the LTV is set to zero. However, vault deposits of the delisted coin are not aected, as seen in lines 100-128. Consequently, users can maintain the collateral value of coins deposited prior to delisting. They could even time an attack based on the previous LTV by frontrunning the delist transaction or entering a vault when an announcement to delist a specic coin is published. For example, suppose ATOM is to be delisted by the Mars team. A borrower notices it and enters a locked vault that accepts ATOM as a base deposit. Despite ATOM being delisted, the borrowers collateral in the form of vault tokens still contributes to the overall LTV. The borrower can execute the RequestVaultUnlock message to convert the vault tokens back to ATOM, contributing to the total collateral value using the red banks LTV. Additionally, the client also identied that delisted vaults still contribute to the total collateral value. We classify this issue as major because this aects the correct functioning of the overall system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. account-nfts contract UpdateConfig message cannot be executed after the minter role is transferred to credit-manager",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "The comment in contracts/account-nft/src/msg/instantiate.rs:22-24 states that the minter role will be transferred to the credit-manager contract. However, the the account-nfts credit-manager contract has no message dened to call UpdateConfig, and that implies proposed_new_minter conguration values can no longer be updated once the ownership has been transferred. max_value_for_burn which the We classify this issue as major because this aects the correct functioning of the overall system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Allowing deposit or duplicate vault tokens may cause unexpected outcomes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "In the contracts/credit-manager/src/vault/utils.rs:92-101, rover_vault_balance_value function queries the balance of vault tokens to calculate the tokens value. However, there is no validation to ensure the contract owner does not congure the vault token as allowed coins or that the congured vaults do not contain duplicate token denoms. This is problematic because either of the above would cause the queried balance to include user deposits or other vault balances, causing the following functions to return a greater amount than expected:  vault_utilization_in_deposit_cap_denom  query_all_total_vault_coin_balances  query_total_vault_coin_balance  assert_deposit_is_under_cap As a result, the rst three functions would return incorrect information to users, while the last function would potentially cause a denial of service due to an AboveVaultDepositCap error when users try to deposit into vaults. Please see the test_duplicate_vault_tokens test case to reproduce this issue. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Transactions including ProvideLiquidity or WithdrawLiquidity actions may run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "In contracts/credit-manager/src/zap.rs:16 and 55, the provide_liquidity and withdraw_liquidity functions could trigger a large number of sub-messages that may consume the transactions entire gas. Those actions send a message to the zapper contract in order to execute a trade on osmosis and then return liquidity pool tokens and remainder coins to the recipient. To achieve this, they have to send a sub-message to osmosis for the trade and (n+1) ReturnCoin sub-messages - where n is the number of coins. Additionally, for each of the sub-messages, a Bank message is created. Since ProvideLiquidity and WithdrawLiquidity actions are only a part of the transaction, the transaction will also include AssertOneVaultPositionOnly and AssertBelowMaxLTV callbacks, which may consume an excessive amount of gas.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Coin whitelist update may run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "the UpdateConfig In contracts/credit-manager/src/update_config.rs:45, message handler clears all the ALLOWED_COINS map entries and then inserts all new coins provided in the message into the map. Since this operation requires iterating on both the stored and the proposed whitelists in order to perform the update, the execution may run out of gas if the number of elements in the whitelist is signicant.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Use of magic numbers decreases maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "Throughout the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. Instances of magic numbers are listed below:  contracts/zapper/base/src/contract.rs:113  contracts/zapper/base/src/contract.rs:159  contracts/account-nft/src/contract.rs:36",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Dependency on unreleased node version",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "The current codebase includes a x for spot price queries from Osmosis GAMMs in packages/chains/src/helpers.rs:73-76. However, at the time of writing, the x made in the node client is still unreleased. We classify this issue as informational as it is not expected that these contracts will be deployed prior to the x being released.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Proposed new minter cannot be removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "there are no handlers In contracts/account-nft/src/contract.rs:67-77, exposed to remove the proposed_new_minter from the contract storage. This is problematic because if the pending minter does not intend to accept the role, the current minter cannot set the value back to None. We classify this issue as informational because the contract minter can still overwrite the minter back to the current contract addresses, which is equivalent to an empty proposed new minter.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Withdrawing liquidity requires the coin to be whitelisted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf",
        "body": "In contracts/credit-manager/src/zap.rs:61 and 79, the liquidity pool token and withdrawn liquidity are validated to be whitelisted. In the delisting logic pull request, one of the changes allows the withdrawal of assets that are not included in the whitelisted assets. However, this is not applied when withdrawing liquidity tokens.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Schedules start and end point timestamps are not validated to be in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "assert_vesting_schedules The contracts/tokenomics/vesting/src/contract.rs:240-254 ensures that scheduled end point is past the start point. function dened in the However, there is no check in place that enforces the start point or the endpoint to be in the future. This implies that there may be vesting schedules that instantly vest, which will probably only happen unintentionally. We classify this issue as minor because only the contract owner can create vesting schedules.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Unbounded iteration through schedules can permanently inhibit the execution of transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "and In contracts/tokenomics/vesting/src/contract.rs:324 contracts/tokenomics/vesting/src/contract.rs:386, unbounded loops are used to iterate through all the registered schedules. Consequently, if the cardinality of registered schedules is signicant, the execution could run out of gas and revert the transaction. Additionally, since there is no way to remove completed schedules, this could permanently inhibit the execution of transactions. We classify this issue as minor because only the contract owner can create vesting schedules.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Miscongured zero max spread causes swaps to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "In contracts/tokenomics/maker/src/contract.rs:59, the max_spread value is not validated to be greater than zero. If the max_spread value is miscongured as zero, all swaps will fail due to a MaxSlippageAssertion contract error. This issue is also present during the conguration update phase in line 698. We classify this issue as minor because only the contract owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Governance fee percentage is not set to 100 if the staking contract address is not set",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "The documentation in packages/astroport/src/maker.rs:17 states if staking_contract is set to None, the governance_percent value should be equal to 100. that However, this behavior is not enforced during contract instantiation and the UpdateConfig message handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. No events are emitted upon successful contract instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "In contracts/tokenomics/maker/src/contract.rs:97, no custom events or attributes are emitted upon successful contract instantiation. This prevents o-chain listeners from indexing parameters congured by the contract instantiator.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Incomplete parameter documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "In several instances of the codebase, function comments do not include documentation of all parameters:  contracts/tokenomics/maker/src/contract.rs:106-112 and 614-624  second_receiver_params is not included.  contracts/tokenomics/vesting/src/contract.rs:61-75  The RegisterVestingAccounts, WithdrawFromActiveSchedule, ProposeNewOwner, DropOwnershipProposal, and ClaimOwnership messages are not documented.  contracts/tokenomics/vesting/src/contract.rs:369  The account, receiver, and amount parameters are not documented.  contracts/tokenomics/maker/src/utils.rs:132-143  The bridge_token and factory_contract parameters are not documented.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Outstanding TODO comment",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "In contracts/tokenomics/maker/src/utils.rs:21, a TODO comment is present that questions whether the swap simulation should adjust according to the token's precision. This indicates that the codebase might not be ready for production.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Zero amount withdrawal will always fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "contracts/tokenomics/vesting/src/contract.rs:375, the In withdraw_from_active_schedule function does not validate that to withdraw is not zero. As Cosmos SDK prevents zero-amount native token transfers, specifying zero withdrawal amounts will fail. The resulting transfer error might confuse users. the amount",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Redundant check in calc_schedule_unlocked_amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf",
        "body": "calc_schedule_unlocked_amount in The the contracts/tokenomics/vesting/src/contract.rs:349 checks whether time_period is not zero. This check is redundant as new schedules are validated through function enforces the assert_vesting_schedules function in line 246. This implying that end_point.time to be strictly greater time_period is always greater than zero. than start_point.time, function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Unbounded iteration allows attackers to attack validators, slowing down or even halting block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "App modules implement logic that needs to iterate through slices in order to nd a specic element with the selected ID. This has the consequence of having unbounded loops with an asymptotic cost of O(n). This is even worse when a loop is done over arrays that contain other arrays. In this case, the asymptotic cost is O(n^2) or O(n^3). Unbounded loops can allow two dierent types of attack: 1. Validator slashing A malicious actor could spam a transaction, that he knows performs an unbounded loop, to a particular node trying to force it to be not able to compute the transaction before the BroadcastTxCommit timeout. This can prevent that node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. the NewTxTimeoutHeightDecorator will discard all messages with an Also, elapsed heightTimeout. This could be used in a particular event in order to manipulate it. As the validator was not able to sign the block, it implies that this event is decreasing its sign ratio. That could lead the validator to be slashed. 2. Stop or slow down the block production A malicious actor could spam the previous message to a set of validators. If a signicant number of them hit the timeout and halt simultaneously, block production may stop or slow down. Iterations vulnerable to this attack are:  x/asset/keeper/app.go:117  x/asset/keeper/app.go:262  x/asset/keeper/asset.go:160  x/collector/keeper/collector.go:104  x/locker/keeper/msg_server.go:238  x/locker/keeper/msg_server.go:310  x/vault/keeper/vault.go:47  x/vault/keeper/vault.go:57  x/vault/keeper/vault.go:347  x/vault/keeper/vault.go:421  x/vault/keeper/vault.go:441  x/rewards/keeper/keeper.go:86  x/rewards/keeper/keeper.go:156",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Transaction gas price is not related to execution complexity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "In app/ante.go:47, NewConsumeGasForTxSizeDecorator is calculating the gas cost of a transaction. taking care of This decorator computes the gas cost of a transaction by multiplying the size of transaction in bytes with TxSizeCostPerByte. the Even if this is a good heuristic to estimate the potential transaction cost, thats not enough. Transaction cost should be proportional to the computational complexity of its execution. For instance, a transaction that has an asymptotic complexity of O(1) and that is not doing I/O operations, should not have the same cost as another one that has a O(n) complexity and is executing extensive I/O operations. Messages vulnerable to this attack are:  MsgCreateLockerRequest in x/locker/handler.go:18  MsgCreateRequest in x/vault/handler.go:18  MsgWithdrawRequest in x/vault/handler.go:24  MsgDrawRequest in x/vault/handler.go:27  MsgRepayRequest in x/vault/handler.go:30  MsgCloseRequest in x/vault/handler.go:33  MsgCreateGauge in x/rewards/handler.go:19  MsgMintNewTokensRequest in x/tokenmint/handler.go:21  MsgDepositESM in x/esm/handler.go:18 The current lack of accounting for execution complexity can make it aordable for an attacker to perform DoS spamming with expensive messages that have a small payload.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Vault ID collisions could lead to the loss, tampering or overwriting of existing vault data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The MsgCreate function, in x/vault/keeper/msg_server.go, creates a new CDP or vault with a unique vaultId. In line 148, an ID is assigned to the newVault, concatenating the apps Shortname and the ExtendedPairs vault counter. However, this formula can lead to collisions, either accidental or intentional, which could cause a loss or tampering of existing vault data. Example:  ShortName1=Test1 and updatedCounter=1, with resulting vaultId=Test11  ShortName2=Test and updatedCounter=11, with resulting vaultId=Test11 It should be noted that this also aects stable vault IDs.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Locker ID collisions could lead to the loss, tampering or overwriting of existing locker data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "Similarly to the vault ID collision issue, lockerIds are subject to collision due to the concatenation formula that is used to derive new userLocker.lockerId, in the function MsgCreateLocker, in x/locker/keeper/msg_server.go:85. This could lead to the loss or overwriting of key locker data, either accidentally or intentionally.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Users cannot redeem their collateral assets regardless of the ESM status",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "in if condition x/esm/keeper/msg_server.go:71, The the MsgCollateralRedemption handler, will never be executed, which blocks users from redeeming their collateral assets regardless of the ESM status. If the esmStatus.status is True, the condition in line 68 will be True, returning the ErrCoolOffPeriodRemains. And if the esmStatus.status is False, the condition in line 71 will be also False, preventing the execution of the if-block which contains the collateral redemption logic. in",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. GetPriceForAsset returns price of 2000000 for assets when the market is not found",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The GetPriceForAsset function in x/market/keeper/oracle.go:175 returns a static price of 2000000 for assets when the market is not found. This is problematic because instead of returning an error for this case, the GetPriceForAsset will silently return an incorrect value for the asset's price. This can have unintended consequences that may allow attackers to economically exploit the protocol.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Computationally heavy operations in BeginBlocker and EndBlocker may slow down or stop block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "BeginBlocker and EndBlocker are functions that are executed at the start/end of each block, even if there are no transactions. To not have a negative impact on block production, it should have a light and constant computational footprint. In fact, it is wise to be cautious about adding too much computational weight at the start of each block, as blocks arrive at approximately seven-second intervals. Also, it should be a good practice to make the BeginBlocker/EndBlocker execution independent, or at least with a sub-linear dependency, from the amount of data stored on-chain. A huge workload may slow down the block production, Tendermints proposal timeout is surpassed. in the worst case so much that The codebase implements multiple BeginBlocker/EndBlocker functions that are computationally heavy and/or depend on on-chain state:  x/auction/abci.go:8  x/esm/abci.go:10  x/market/abci.go:10  x/rewards/abci.go:11  x/liquidity/abci.go:12  x/liquidity/abci.go:29",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Multi-purpose BeginBlocker error handling may disable critical functionality if an error is raised",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The BeginBlocker functions in:  x/rewards/abci.go:11  x/auction/abci.go:8 use an error-handling approach that stops the execution if one of the functions returns an error. This means that if the rst function execution returns an error, the other ones that come after that one will not be executed. While this can be a good approach for interdependent functions, it is not a good design in cases when functions are independent. in example, For DebtActivator and DutchActivator are independent SurplusActivator will deny the execution of the other two. the Rewards modules BeginBlocker, SurplusActivator in functions but an error",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "9. Error handling during slices loop terminates the execution without executing the logic for all items",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "In  x/auction/keeper/surplus.go:27,  x/auction/keeper/surplus.go:33,  x/auction/keeper/dutch.go:56,  x/auction/keeper/dutch_lend.go:49,  x/auction/keeper/debt.go:26,  x/auction/keeper/debt.go:32, and  x/esm/abci.go:32-35, error handling logic during a slice iteration terminates the execution without iterating through all items. This behavior could lead to incoherent functionality if the loop triggers an error in the initial slice items. information inside the slice and to disabled This has the consequence of not checking all the items after the faulty one, and in the worst case, if the error is raised in the 0 position of the slice, to not check at all liquidation for collateralized positions.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "10. An attacker could send MsgRemoveMarketForAssetRequest messages every 20 blocks in order to make the Market module unusable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "x/market/handler.go:25, In MsgRemoveMarketForAssetRequest. anyone is allowed to send a An attacker could use this transaction to delete all the Market instances saved in the store, making the Market module unusable. The transaction can be executed every 20 blocks, which is the oracle data fetch interval.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "11. Permissionless Rewards module Whitelisting process allows attackers to manipulate the Asset Whitelist and App Vault Whitelist",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "x/rewards/handler.go, WhitelistAsset, and RemoveWhitelistAppIdVault RemoveWhitelistAsset, are messages In, WhitelistAppIdVault permissionless. Since those messages are responsible for the management of the Asset Whitelist and App Vault Whitelist, they should be executable only from privileged users or through governance. In fact, having those messages executable by anyone makes the Whitelist process ineective and exposes an attack surface. For example a malicious actor could delete all Assets from the AssetWhitelist and make the module unusable, or could add an Asset to the whitelist that should not be allowed.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "12. Gas is not consumed if the transaction returns an error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The ConsumeGas function calls in lines:  x/liquidity/keeper/pool.go:182,  x/liquidity/keeper/pool.go:255,  x/liquidity/keeper/pool.go:313,  x/liquidity/keeper/swap.go:123,  x/liquidity/keeper/swap.go:233,  x/liquidity/keeper/swap.go:292,  x/liquidity/keeper/swap.go:362,  x/liquidity/keeper/rewards.go:312, and  x/liquidity/keeper/rewards.go:424, are located at the end of the transaction execution and are not called if an error occurs. Consequently, a malicious actor is allowed to spam transactions that trigger an error in the middle of the execution without being charged of the dened gas fees.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "13. CosmWasm - State query binding can perform a GRPC call to an arbitrary URL",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "In contracts/governance/src/msg.rs:12, target eld of type String. the InstantiateMsg is expecting a This eld is then used by the contract to perform State queries in  contracts/governance/src/contract.rs:128 and  contracts/governance/src/contract.rs:442 in order to get the state at a particular BlockHeight. The CosmWasm State query binding is resolved in the Cosmos SDK side by the QueryPlugin in app/wasm/query_plugin.go:54 and handled by the QueryState function in x/locker/keeper/locker.go:328. In x/locker/keeper/locker.go:335 the target eld propagated from the CosmWasm contract is used as URL to create a GRPC insecure connection. This mechanism is intended to work to call a Full Node but it has some possible problems:  Every target URL is allowed so an attacker could use this to perform a DOS or to create a botnet using chain nodes to perform a DDOS.  Exposed GRPC port could be not the same in dierent nodes as it can be congured by see https://docs.cosmos.network/master/core/grpc_rest.html#grpc-server, or it could be behind a Load Balancer, Reverse Proxy, Docker network, Ingress, etc. operators, node  It is performing the call with grpc.WithInsecure() so there is no trust to the It MITM GRPC attacks https://grpc.io/docs/guides/auth/#with-server-authentication-ssltls contacted. allows server like  Congurations and security enforcements rules through iptables or ufw or similar softwares on machines where the chain node is hosted could block this type of calls That means that a CosmWasm contract is able to make the chain node perform a GRPC insecure connection to an arbitrary URL by simply using the State query binding.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "14. Error raised in BeginBlocker could lead to state corruption",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The modules that raise errors in BeginBlocker which could lead to a state where partial state changes are performed but other intended state changes are not committed. This function logs errors but has no control over the state and no mechanism to revert partial updates. This implies that if an error is raised in the middle of an execution ow, the execution will stop and log the error, but no action will be taken in order to revert state updates that have been done leading to state corruption.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "15. CosmWasm - Deposited funds of other denom will be stuck in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "In contracts/governance/src/contract.rs:534 in the execute_deposit message, if the voter has made a deposit to the given proposal before, the Coins that were previously added in the rst deposit will be increased with the amount of the new deposit. However, there is no check that info.funds.len == 1, so dierent denoms will be accepted and not accounted for, resulting in these funds remaining permanently stuck in the contract. The same issue occurs if a user only sends one coin of a certain denom to an existing proposal with a dierent denom. After the proposal has passed or been rejected, the execute_refund function in 570 will not return the coins whose denoms are dierent from the original deposit.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "16. UpdateAssetsRecords is not enforcing a unique Denom for an Asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The UpdateAssetsRecords function in x/asset/keeper/asset.go:189 is not consistently handling the Denom to Id mapping when updating an Asset with a new Denom eld. asset.Denom Since the with DeleteAssetForDenom(ctx, asset.Denom) in line 205 is not deleting the mapping with the old Denom but is instead trying to delete the mapping with the new one. msg.Denom updated 203, line in is This has the consequences of not having a unique Denom for an Asset Id in the Denom to Id mapping.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "17. AddAppRecords may overwrite existing app name entries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The AddAppRecords function in x/asset/keeper/app.go:208-210 incorrectly performs an app name validation that will allow for the existing app Id to be overwritten in In line 208 the HasAppForName check is passed msg.ShortName SetAppForName. rather than msg.Name, so in eect the name is not checked currently.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "18. MsgAddWhiteListedAsset allow any caller to add an asset id to a lockers whitelist",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The MsgAddWhiteListedAsset function in x/locker/keeper/msg_server.go:327 does not include any permission checks to ensure only authorized addresses are able to add asset Ids to the lockers whitelist. Currently any user may send this message to add asset Ids to the lockers whitelist.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "19. AddAppRecords may accept invalid GenesisToken array",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf",
        "body": "The AddAppRecords function in x/asset/keeper/app.go:203 does not perform proper validation on the GenesisToken array before setting it in the store. At a minimum, the function should conrm that the slice of MintGenesisToken does not contain duplicates, and that the Recipient is a valid address. stored invalid An AddAssetInAppRecords CheckIfAssetIsAddedToAppMapping function. GenesisToken messages array during could break the the execution handling of of the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Market timestamp checks market prices Since the Recommendation We recommend performing validation on the posted prices. For instance, there could be a maximum allowed delta per time unit, such that a price of 0 would not be accepted. While this does not fully resolve the centralization issue, privilege abuse would be more involved (and require multiple transactions over a longer timespan). This would allow operators and users to react. Furthermore, bugs in the o-chain bots that result in clearly wrong prices would no longer break the whole system. Alternatively, prices could be aggregated, for example by calculating a time-weighted median price to minimize the impact of a single buggy or compromised bot. Status: Acknowledged 11. PID parameter centralization risk",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neptune/2023-04-09 Audit Report - Neptune Protocol v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Liquidation penalty is not validated during struct initialization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "In cadence/contracts/LendingComptroller.cdc:125-127 of the MoneyMarket repository, the liquidation penalty is not validated to be below 1.0 (ie. 100%) during the Market struct initialization. As a result, misconguring the liquidation penalty value might cause a liquidator to receive more funds than intended, causing a loss of funds for the borrower. We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Interest rate model capability is not validated during update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "In cadence/contracts/LendingPool.cdc:959-970 of the MoneyMarket repository, the newly set interest rate model capability is not validated to exist and can be borrowed. As a result, setting a non-existing capability for the interest rate model would cause several accrueInterestReadonly, functions getPoolBorrowRateScaled, and getPoolSupplyAprScaled. getPoolBorrowAprScaled contract notably fail, the to in We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Local resource reference can be used for eciency",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "In cadence/contracts/PriceOracle.cdc:128-130 of the Oracle repository, the certificate argument is passed as an OracleCertificate resource reference which is implemented by the OracleInterface contract interface. The certificate is then veried by checking its type against the local OracleCertificate resource to make sure the caller can only be the current contract. This validation can be removed to introduce eciency by only accepting the local OracleCertificate resource reference as an argument.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Feeders can set non expirable prices by changing the expired duration to arbitrary high value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "In cadence/contracts/PriceOracle.cdc:122-124 of the Oracle repository, feeders can set an arbitrary high expired duration which makes their prices non-expirable. With that said, this doesnt directly aect the prices of assets until more than half of the feeders act maliciously and set the expired duration to an arbitrarily high value. We consider this to be a minor issue since this requires more than half of the feeders to be malicious.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Sorting algorithm can be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "the current In cadence/contracts/PriceOracle.cdc:222 of the Oracle repository, sorting algorithm is inecient due to time complexity. Since takeMedianPrice functionality will be called many times, this causes every other operation that is dependent on it to become gas inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Typographical errors found in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "there were In cadence/contracts/PriceOracle.cdc of several typographical errors found in lines 104 and 383. Specically, the word oralce_public should be replaced with oracle_public while the word _ExpriedDuration should be replaced with _ExpiredDuration. the Oracle repository,",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Possible chances of path collisions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf",
        "body": "In the MoneyMarket repository, the following storage and public paths are very generic:  cadence/contracts/LendingPool:1086  cadence/contracts/LendingPool:1088  cadence/contracts/LendingPool:1089 This might lead to path collisions, potentially incorrect data access or resources overwriting.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attacker can bypass self-call validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf",
        "body": "validate_msg_calculate_usage The in contracts/croncat-tasks/src/helpers.rs:88 does not properly validate the value of contract_addr for the WasmMsg::Execute message type. This value is partially the task cannot call any of the validated in check_for_self_calls, associated CronCat addresses, but it does not account for the edge case that one of these addresses can be provided as all uppercase letters. This is possible for WasmMsg::Execute task actions that don't include queries. to check that function For example an attacker can specify an all uppercase version of the manager contract address, and then pass an address to update the owner and take control of the manager contract. These messages will also not cause errors during the address validation by the underlying Cosmos SDK, which is triggered from the wasm modules MsgExecuteContract message validation. The WasmMsg will be routed by the wasm module and will undergo stateless function will check validation in the message's ValidateBasic function. This msg.Contract with the sdk.AccAddressFromBech32, which returns the type AccAddress []byte. It does not dierentiate if the supplied address is in uppercase or lowercase. They will both normalize to the same byte slice, as long as the chain prex has the same case. See Appendex A: Test 1 Case 2 for more detail. The following shows two Bech32 addresses that both evaluate to the same account address: 395441E922FCBDC6BEC9B76EAC2C7D647B50D66F cosmos1892yr6fzlj7ud0kfkah2ctrav3a4p4n060ze8f 395441E922FCBDC6BEC9B76EAC2C7D647B50D66F COSMOS1892YR6FZLJ7UD0KFKAH2CTRAV3A4P4N060ZE8F",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Task contracts execute_update_config is permissionless",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf",
        "body": "execute_update_config in The contracts/croncat-tasks/src/contract.rs:96 allows any caller to execute a cong update for the Tasks contract. This will allow an attacker to gain complete control over the Tasks contract by updating critical parameters, for example, setting themselves as the contract owner. function",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Agents can bypass task delegation mechanism",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf",
        "body": "execute_proxy_call in The contracts/croncat-manager/src/contract.rs:188-208 incorrectly assumes that when a calling agent supplies a task hash the task is event based. This will allow agents to bypass the task delegation logic and directly execute tasks on a rst come rst serve basis. function This is based on the assumption that agents are all behaving according to the client software. But an agent owner could modify the client software to game this system and prot from receiving a disproportionate amount of tasks. For example, a malicious agent client could query to nd out which slot tasks are executable, and then simply call execute_proxy_call with the task_hash to avoid the agent_task checks in line 217. On chains that support Skip, this could even become a MEV opportunity where agents would compete to get their bundle accepted and frontrun the normal task delegation logic. This would completely exclude other agents that are acting normally. A proof of concept for this attack is available i",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Users are unable to withdraw funds once admin deposited all funds in the Red Bank",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "on In the Lockdrop contract, users are able to withdraw funds as long as it's under the congured withdrawal timeline. The withdrawal function will decrease the contracts total locked UST amount based (contracts/lockdrop/src/contract.rs:395). Once the admin deposits all funds to the Red Bank via DepositUstInRedBank, the contracts total locked UST will be set to 0 (L791). Since it only accounts for the deposit timeline instead of the withdrawal timeline (L465-472), users will be unable to withdraw their locked funds even if the withdrawal window is still open. withdrawal user's the We set the severity to Major since the users funds are still recoverable after a certain timeline.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Malicious users can cheat lockup rewards without locking their funds if claim is enabled before withdrawal timeline",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "condition In the Lockdrop contract, users can execute ClaimRewardsAndUnlock to claim rewards in the enabled (contracts/lockdrop/src/contract.rs:686-688). Claims can only be enabled from the Auction contract via AddLiquidityToAstroportPool which accounts in deposit and itself the windows (contracts/auction/src/contract.rs:440-445). withdrawal contract Auction claims only that are for Since both Auction and Lockdrop contracts are independently initialized, theres a possibility that admin might enable claims during the deposit or withdrawal phase of Lockdrop contract. If this happens, a malicious user can potentially cheat the lockup rewards via an attack scenario below: 1. Execute DepositUst to deposit a large amount of funds into any lockup position 2. Claim ClaimRewardsAndUnlock executing rewards via with lockup_to_unlock_duration_option as None 3. contracts/lockdrop/src/contract.rs:703-715, enter In calculate_mars_incentives_for_lockup internal function. Notice that lockup_info.ust_locked variable will be used to calculate users position rewards via calculate_weight. code will 4. Due to the code logic that only updates users MARS rewards when its 0, user_info.total_mars_incentives will not be updated in the future (contracts/lockdrop/src/contract.rs:704). The malicious user will have a denite reward. 5. Execute WithdrawUst to remove all funds locked under that lockup position (funds that can be removed highly depends on window timeline). In L382, the corresponding locked UST amount will decrease, however, the users MARS rewards will still remain the same. We set the severity to minor since this will only be exploitable if the timeline is congured incorrectly/far between Lockdrop and Auction contract which will inuence the execution of EnableClaims.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Users that claimed airdrops will miss out on additional airdrops",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The current implementation of airdrop claims allows only one claim per user due to the the condition in contracts/airdrop/src/contract.rs:326. At contract owner has the ability to update Merkle roots in L198-200. Taken together, if a user was assigned additional airdrops, they would not be able to claim those additional airdrops. Even without an update, the current design does not allow a user to claim multiple airdrop leaves from the same Merkle tree. the same time,",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Missing validation on Cong parameters can lead to human errors and unexpected behavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The Auction, Lockdrop, and LP Staking contracts are missing validation checks in some of its Cong numerical values. For example, in contracts/auction/src/contract.rs:61, there is no check that msg.init_timestamp corresponds to a future value (i.e. msg.init_timestamp>= env.block.time). in lockdrop/src/contract.rs:45. validation Lockdrop contract present This the in is example An contracts/lp_staking/src/contract.rs:37-39, init_timestamp + cycle_duration <= till_timestamp. Staking the LP in contract in there is no validation that that is Examples of missing validation checks in the Lockdrop contract are:  No validation that there are repeated values in msg.lockup_durations in line 67  No check that msg.seconds_per_duration_unit is non-zero. Examples of missing validation checks in the Auction contract are:  No check that config.mars_vesting_duration is non-zero, which would cause division by zero error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing MARS rewards validation may cause auction participants to lose their deserved rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In the Auction contract, anyone can deposit MARS to increase the overall reward for users via If no one deposited any MARS token rewards before the IncreaseMarsIncentives. is not possible to continue admin executed AddLiquidityToAstroportPool, depositing minted tokens (contracts/auction/src/contract.rs:199-L203). This would cause auction participants to receive zero Mars token rewards in return for their MARS token delegation. it token already shares MARS due LP to",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Querying the state of the contract may return false information",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In the LP staking contract, in lines lp_staking/src/contracts.rs:315-352, there is a max function that takes the timestamp provided by the user and the current timestamp. Therefore, if the user-provided timestamp is in the past, the returned information will be false, as it will correspond to the current timestamp. If the user, which can be a 3rd party protocol, relies on this query to do further calculations, this might cause unintended consequences.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Typo in variable names might cause errors in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "In the Lockdrop contract, contracts/lockdrop/src/contract.rs:832, there is a typo in the variable xmars_accured, which may cause development errors in the future.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Overow checks not set for most packages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf",
        "body": "The following Cargo.toml les do not enable overow-checks for the release prole:  packages/mars-periphery/Cargo.toml  contracts/airdrop/Cargo.toml  contracts/auction/Cargo.toml  contracts/lockdrop/Cargo.toml  contracts/lockdrop/Cargo.toml",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Meta transactions can be replayed across contracts and networks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "Currently, the implementation of meta transactions does not verify the contract and network of the transaction. As a result of this, it is possible to replay a meta transaction in dierent contracts such as Alice Terra tokens for UST and EUT and networks such as testnet or mainnet. That could lead to double-spending.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Execute deposit stable function uses relayers funds instead of users funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "When a user attempts to deposit funds into Anchor protocol, the request originates from execute_relay into execute_deposit_stable due to meta transactions. In relay.rs:63-65, the relayer attempts to execute the request as the user via mutating info.sender which then executes the message in line 81. as When the operation continues to execute_deposit_stable, the request will see Since funds. info.funds info.sender execute_deposit_stable determines the fund amount via checking info.funds (execute.rs:94-99), this would cause the relayers funds to be deposited into Anchor instead of the users funds. user while relayers are the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Anchor exchange rate used might be out of date due to missing block height argument",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "The Anchor exchange rate is queried from the Anchor contracts, through the utility function in compute_exchange_rate contracts/alice_terra_token/src/utils.rs. However, no block height argument is supplied. Without the block height argument, Anchor returns a raw exchange rate from stored values without accruing interest since the last update, which means an outdated exchange rate is returned. Using this value could lead to slightly incorrect calculations. dened",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Missing validation during instantiate phase allows fee_ratio to be over 100%",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "fee_ratio is the percentage of fees Alice protocol would receive from user yields. During the instantiation phase (alice_terra_token/src/contract.rs:50) and migration phase (contract.rs:141) ,  there is no validation to ensure the ratio should be 0-100%.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Sent tokens other than in stable denom are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "During execute_deposit_stable and execute_deposit_stable_authorized, the users uusd funds are processed and deposited to Anchor protocol. If the user deposited additional tokens (other than uusd), the funds would get stuck in the contract after the operation succeeds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Querying registered contracts in Overseer is unbounded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "RegisteredContracts in The alice_overseer/src/contract.rs, which could cause calling transactions to run out of gas. Even if it is unlikely that there would be enough registered contracts to make the query out of gas, since registered contracts cannot be removed an out-of-gas situation could be irreversible. unbounded message query is",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. execute_redeem_stable returned amount might be dierent from actual amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "The execute_redeem_stable function requests a stable denom amount and then returns a calculated amount to the user. The returned value may be dierent from the actual returned amount due to possible slashing penalties, fees, taxes etc.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. aTerra exchange rate is queried twice during execute_redeem_stable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf",
        "body": "functions The and query_aterra_exchange_rate both query aTerra exchange rate individually. During execute_redeem_stable, both functions are used to retrieve the aTerra exchange rate in alice_terra_token/src/execute.rs:163 and 165 which is inecient. compute_and_update_exchange_rate",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Unbounded iteration in the tax modules AnteHandler could be used by an attacker to slow down or halt the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "In x/tax/keeper/taxdecorator.go:76-81, the ApplyTax function called from the tax modules AnteHandler is performing an unbounded iteration over the feeCoins provided by users. An attacker could craft a message with a signicant number of Coins with the intention of slowing down the block production, which in extreme cases may lead to Tendermints propose timeout to be surpassed. This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of peers hit the timeout and halt simultaneously, block production may stop. A test case is provided in Appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. ValidateMinter does not guarantee that provided parameters are adherent to the dened minting schedule",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "In x/mint/types/minter.go:43, the ValidateMinter function does not verify that the parameters passed on genesis are conformant with the equation that denes the minting schedule. There is a risk that one or more of them are not correct, which would lead to a awed minting schedule. Once this happens, there is no straightforward way to return to the intended trajectory. It is important to note, nevertheless, that there are checks to ensure that the total minted amount does not exceed a predened threshold.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Silently handled broken invariant could lead to inconsistent chain state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "In x/mint/abci.go:41-44, during the calculation of the time interval between two subsequent blocks, the guard that checks that the timestamp of the current block is greater than the previous one does not panic or return an error. Instead, it assigns blocks with the same timestamp, letting the execution ow continue. Since the code should always enforce the invariant   >  0 incorrect subsequent block order or simultaneous blocks should result in an error and eventually halt the chain. We classify this as a minor issue since Tendermint is already enforcing this invariant.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. The feeCaps parameter is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "In x/tax/types/params.go:103-113, the validateFeeCaps function that is invoked by ValidateBasic is not validating the feeCaps parameter. Instead, a TODO comment is present as a reminder to implement the validation logic. Consequently, every string value could be provided as feeCaps parameter.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Minting cap is not enforced during genesis",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "the In x/mint/types/minter.go:48, TotalMinted parameter is positive, but it does not validate that the value is less than the MintingCap. the ValidateMinter function ensures that This implies that during genesis, a TotalMinted parameter value that exceeds the MintingCap amount is accepted and stored.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. The FixedMintedAmount parameter value is incoherent with the documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf",
        "body": "In x/mint/types/minter.go:11, FixedMintedAmount is set implies that 0.0825% of the total amount of tokens is minted per year. to 103125 which However, implementation and could lead to an unintended minting schedule. the docs dene this number to be 0.08% which is incoherent with the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Lack of stream status validation can be exploited to drain contract funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contracts finalize_stream function does not validate that the current streams status is not Status::Finalized. An attacker could exploit this by repeatedly calling the finalize_stream function to trigger Bankmsg::Send messages using the streams treasury as the beneciary. This results in transfers of both the creation denom and creators_revenue, drainting the contracts funds. A proof of concept test case can be found in the test case Faulty stream state validation lead to draining of funds in the appendix.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Stream status not saved after update allows contract funds being drained",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contracts finalize_stream function does save the new stream status after updating it in src/contract.rs:618-620. Consequently, the status will remain the same when calling the finalize_stream function again. Similarly to the issue Lack of stream state validation lead to draining of funds, this can be exploited by repeatedly calling finalize_stream to trigger Bankmsg::Send messages, which drains the contracts funds. The same proof of concept test case Faulty stream state validation lead to draining of funds in the appendix applies here.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Updating stream_creation_fee or stream_creation_denom will cause ongoing streams to error when nalized or canceled",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "constructed In the execute_finalize_stream and sudo_cancel_stream functions, the BankMsg is and config.stream_creation_denom. Both config values are only checked during stream creation, and any changes to these values after creation will impact streams that have not been nalized. This can cause inconsistent states and errors if the contract does not hold a sucient balance or the right denom to pay the fees. config.stream_creation_fee with suppose there are two non-nalized streams and the value of For example, config.stream_creation_fee is increased. Now the rst stream to nalize would spend a larger amount on fees than was contributed during the stream creation. This will result in the rst streams balance being too low to nalize the second stream. The functions in src/contract.rs:645 and src/killswitch.rs:272 send a and BankMsg config.stream_creation_denom. config.stream_creation_fee using",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Lack of conguration parameter validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract does not validate several conguration parameters upon instantiation in src/contract.rs:32-45 and in the sudo_update_config function in lines 794-803. The following parameters should be carefully reviewed:  stream_creation_denom: creation as it will fail to match. Incorrect casing of the denom could block stream  stream_creation_fee: If set to zero, it will render the mechanism ineective and may allow spamming/grieng.  exit_fee_percent: If set to a value greater than one, line 630 will underow and streams can never be nalized.  accepted_in_denom: Incorrect casing of the denom could block stream creation as it will fail to match. In addition, operational issues if the account gets compromised or the organization requires a change. it should be noted that protocol_admin is not updatable. This could cause Although some of the consequences outlined above could have a major impact on users, privileged functions are operated by informed users which are less prone to errors. Therefore, we classify this issue as minor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Exit fee percent validation diers from documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "included the following comment about exit_fee_percent The streamwap contract validation in src/contract.rs:31: exit fee percent can not be higher than 1 and must be greater than 0. Instead, the implementation allows the value to be less than one and greater than or equal to zero.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Stream creation parameters lack validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The creation of a stream in src/contract.rs:188 is lacking validation, which may lead to unintended consequences for stream creators. Firstly, there should be a validation to ensure that out_denom is not the same as in_denom. Secondly, out_supply should be validated to ensure it is not 0. While fund amount cannot be 0 in Cosmos SDK messages, if out_denom == config.stream_creation_denom the amount of out_supply specied in line 164 could be 0 and still pass the validation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Stream actions performed at streams end time may introduce unintended consequences",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract allows for the following messages to be executed at the streams end_time:  ExecuteMsg::Subscribe,  ExecuteMsg::Withdraw,  ExecuteMsg::ExitStream, and  ExecuteMsg::PauseStream. This is problematic since it can lead to inconsistent states. in the current For example, the end_time blocktime. This could introduce a scenario similar to the one described in the Unspent tokens could be locked in the contract upon exit nding. implementation, a caller can subscribe at Although no clear exploitation path have been identied, the current implementation is error-prone.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of best-eort validation on stream name and URL",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract does not perform any validation on the name and url elds of newly created streams in src/contract.rs:189 and 190. Although this does not have direct security related implications, these elds could be used to orchestrate phishing campaigns against unsuspecting users. Also, the name eld could be deliberately set by an attacker to confuse users, for example by setting it as an empty or very lengthy string.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Unspent tokens could be locked in the contract upon exit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The documentation on the execute_exit_stream function reads that it should withdraw purchased tokens to his account, and claim unspent tokens. However, the implementation only withdraws the users purchased tokens but does not check for and claim any unspent tokens. The potential impact could be considered to be major or even critical, given that a users tokens could get locked forever in the contract, but no scenario was found where the in_token amount could be greater than zero when exiting a stream. We have raised this issue as informational as, although not having found a clear exploitation path, potential edge cases may arise with future updates to the contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Lack of action along executed messages event attributes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract is lacking additional event attributes labeled as action on some of its entry points responses. The functions in the following lines were aected:  src/contract.rs:59  src/killswitch.rs:167, 201, 235, and 278 Although not a security issue, some o-chain components may rely on this kind of information being broadcasted upon successful execution of a contracts message handler.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Optimization possible on multiple code paths",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract currently contains minor ineciencies. While none of these issues pose a security concern, they should be addressed to further optimize the codebase. For example, when a user attempts to withdraw an amount of zero. The following functionalities can be reviewed for inecient code paths:  In src/contract.rs:266-273, updates on out_remaining and dist_index could be included in the if statement inline 276, as both will be left unchanged when the new_distribute_balance is zero. the  In src/contract.rs:295, it is inecient to include the case where the numerator is zero.  In src/contract.rs:499-501, the code never executes, as line 497 already uses info.sender to load the position. Therefore, position.owner will always be equal to info.sender.  In src/contract.rs:554, it is inecient to raise an error if withdraw_amount is equal to zero.  In src/killswitch.rs:46, it is inecient to raise an error if withdraw_amount is equal to zero.  In src/killswitch.rs:256, the assignment is redundant as the variable was already updated and saved to storage in lines 256-254.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Custom access controls implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract implements custom access controls. Although no instances of broken controls or bypasses have been found, using a single assert function to validate readability and controls maintainability. risks while improving the codebases reduces potential",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Misleading error messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "The streamswap contract includes several custom errors in src/error.rs:38, 44, 77, and 104 that raise misleading or non-meaningful information to the user. In addition, descriptive of the actual situation. the NoFundsSent custom error raised in src/contract.rs:184 is not",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "contracts/pf-dca/Cargo.toml does not enable overflow-checks for the release prole. While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Additional funds sent to the contract are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf",
        "body": "the transaction includes In src/contract.rs:160-187, during stream creation, checks are performed that ensure two Coins with the expected out_denom and that stream_creation_denom eld (one Coin with stream_creation_denom eld if both out_denom and stream_creation_denom are the same). This validation does not ensure that no other native tokens are sent though, and any additional native tokens are not returned to the user, so they will be stuck in the contract forever. While blockchains generally do not protect users from sending funds to wrong accounts, reverting extra funds increases the user experience.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Withdrawing voting tokens will panic if amount is not set",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anchor/Audit Report - Anchor Protocol [20210406].pdf",
        "body": "Unwrapping contracts/gov/src/contract.rs:303 will panic if the amount is None. withdraw_voting_tokens amount the the in function in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. A validator updating its ConsumerKey to the same key causes a panic in the related consumer chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "In x/ccv/provider/keeper/key_assignment.go:505-523, during the processing the execution appends two abci.ValidatorUpdate of ConsumerKey assignments, elements to the newUpdates slice for each consumer key to replace. The rst abci.ValidatorUpdate is constructed with the old key and Power equal to zero and the second one contains the new key with the validators current Power. If a validator updates its key to the same one, the newUpdates slice will contain two elements with the same key and dierent Power, respectively zero and the current one. This would cause the related consumer chain to panic when trying to update the validator set due to the duplicated ConsumerKey in the validator set.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Attackers can DOS attack consumer chains by sending multiple coins to the provider chains reward address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "the the During execution in SendRewardsToProvider x/ccv/consumer/keeper/distribution.go:103, gets the balance of all the coins in the tstProviderAddr and sends them to the provider chain. EndBlocker, consumer function, dened chains the of In order to do so, it has to iterate through all the coins found in the reward address and send them one by one through IBC to the provider chain. Since anyone is allowed to send coins to the reward address, an attacker could create and send a large number of coins with dierent denoms to it, for example using a chain with the token factory module, in order to attack the mentioned unbounded iteration and DOS attack the chain. Consequently, the execution of the EndBlocker will take more time and resources than expected causing the consumer chain to slow down or in the worst case even halt.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Validators can slow down the provider chain by submitting multiple AssignConsumerKey messages in the same block",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "AssignConsumerKey The in x/ccv/provider/keeper/key_assignment.go:378, enables validators to assign themselves a dierent consumerKey for approved consumer chains. function, dened In order to perform this action the consumerAddrsToPrune AddressList grows by one element in line 428. this AddressList Since in x/ccv/provider/keeper/relay.go:95, it could be utilized by attackers to slow down the provider chain. EndBlocker iterated over the in is To execute such an attack, malicious actors could craft transactions with multiple AssignConsumerKey messages and spam the provider chain with those transactions. The consumerAddrsToPrune AddressList will grow of the same cardinality as the AssignConsumerKey sent messages. Consequently, the execution of the EndBlocker will take more time and resources than expected causing the provider chain to slow down or in the worst case even halt. We classify this issue as major instead of critical since the number of iterations is bounded by the maximum number of messages in a block.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. The provider chain halts on failure to send packets to a single consumer chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "the execution During SendVSCPacketsToChain x/ccv/provider/keeper/relay.go:182, panics if consumer chain. function, provider the of chains EndBlock function, dened it fails to send a packet the in to a This implies that an issue relevant only to a consumer chain will make the provider chain panic. Likewise, consumers will also panic in x/ccv/consumer/keeper/relay.go:180 because they will not be able to send packets to the provider. This evidences a single point of failure  an error occurring on a single packet for a single consumer can halt the entire ICS network. We classify this issue as major instead of critical because in the current version consumer chains, relayers, and light clients are assumed to be non-malicious.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Potential loss of rewards during consumer chain removal",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "In x/ccv/consumer/keeper/distribution.go, the reward distribution process takes place at the end of each block on the consumer chain. When the number of blocks for transmission is exceeded, the accumulated rewards are sent to the provider. If a proposal to remove or stop a consumer chain is successfully executed, the code at x/ccv/provider/keeper/proposal.go:155-232 automatically handles the removal process. This includes tasks such as cleaning up the state, closing the channel, releasing unbonding operations, and deleting all related data. However, it does not explicitly check whether the rewards associated with the consumer chain have been distributed before removing the chain. This may lead to a loss of rewards that have not been sent to the provider.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Consumer chains can DOS the provider chain by sending slash packets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "In x/ccv/provider/keeper/throttle.go:274-276, a panic occurs if the cardinality of the queue of throttled packets is bigger than the dened MaxThrottledPackets hard cap. This behavior can be exploited by a malicious consumer chain, making the provider unable to process any further packets from other consumers. To execute such an attack, the malicious consumer chain can spam the provider chain with slash packets in order to ll the queue and cause a panic. Since the validation of slash packets in x/ccv/provider/keeper/relay.go does not disregard duplicate or other invalid slash packets, the attack can be performed for example by simply sending a valid slash packet multiple times. This could cause other consumer chains to be removed from the ICS because the provider will not receive relevant maturity notications before the timeout. We classify this issue as minor instead of major because in the current version consumer chains, relayers, and light clients are assumed to be non-malicious.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Validators can evade slashing if an equivocation proposal is submitted seven days or later after the infraction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "When a validator performs a double-signing infraction on a consumer chain, equivocation slashing should be proposed and voted upon. Since the voting period lasts two weeks and the unbonding period is currently set to three weeks, an equivocation slashing proposal submitted seven days or later after the infraction takes place allows the validator to unbond and evade slashing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Consumer chains can expand provider chain unbonding period",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "The default unbonding period for consumer chains DefaultConsumerUnbondingPeriod is set in x/ccv/consumer/types/params.go:37 to one day less than the default unbonding period, which is currently three weeks. Since a validators unbonding matures only after all consumer chains unbondings mature, the DefaultConsumerUnbondingPeriod is chosen to ensure that the validators can unbond without any delays. However, since the consumer unbonding period is not enforced in the code to be less than the providers, consumer chains congured with a bigger unbonding period will delay the providers unbonding period.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Unbounded loop over proposals in BeginBlock could slow down block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "In x/ccv/provider/keeper/proposal.go:370 and 504, an unbounded loop is used to iterate over the ConsumerAdditionProposals and ConsumerRemovalProcess list. This loop has no set limit for the number of times it can run. Since there are no restrictions on the number of consumer chains that can be supported by the provider chain, a large number of proposals could slow down or halt the chain. We are reporting this with Minor severity since proposals go through governance voting and the likelihood of having multiple proposals with the same SpawnTime or StopTime is low.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Unbounded loops over consumer chains in EndBlock could slow down block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "When the EndBlock function is executed on the provider chain, there are several instances where the GetAllConsumerChains function is called to retrieve a list of all consumer chains. As there are no restrictions on the number of consumer chains that a provider can support, this slice can potentially be very large. The GetAllConsumerChains function is called in:  x/ccv/provider/keeper/proposal.go:60,  x/ccv/provider/keeper/proposal.go:173, and  x/ccv/provider/keeper/proposal.go:224. These unbounded lists are then iterated over to perform various operations for all active there are iterations over leadingVSCMaturedData, consumer chains. Specically, pendingPackets, and MustApplyKeyAssignmentToValUpdates. If the cardinality of these lists increases, block production may slow down, possibly even halting the chain. Operations on time-critical applications running on the network such as auctions or governance proposal execution may be delayed when a consumer chain oods the EndBlocker with fraudulent VSC matured packets, leading to a delay in block production. We are reporting this issue as Minor since consumer chains can only be added through governance.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. LastTransmissionBlockHeight is wrongly updated if the IBC token transfer fails",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "the execution During in the x/ccv/consumer/keeper/distribution.go:21, LastTransmissionBlockHeight is updated with the current timestamp even if the IBC token transfer fails. EndBlockRD function, dened the of This implies that rewards are not re-sent in the next block but in the next epoch, leading to lower rewards for unstaking validators. Also, a misleading value is stored.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Inecient removal of executed proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "The BeginBlock function, which is called at the beginning of every block, calls BeginBlockInit in x/ccv/provider/keeper/proposal.go:367 to get the pending consumer addition proposals and then deletes executed proposals in line 391. even the However, DeletePendingAdditionProps function is called to fetch a KVStore from the MultiStore every block, which is inecient. proposal execute, pending there no to is if This ineciency can be removed by changing the function to delete a single executed proposal and moving it inside the for loop. The same issue applies to the DeletePendingRemovalProps function called from BeginBlockCCR in x/ccv/provider/keeper/proposal.go:501.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Emitting incorrect events is misleading",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "In case of unmarshalling packet data failure in the OnRecvPacket function, the ack value will contain an error acknowledgment which is used to emit an event with AttributeKeyAckSuccess in both x/ccv/consumer/ibc_module.go:237 and x/ccv/provider/ibc_module.go:205. This is misleading for client applications and users, since a success ag can be returned along with an error. the DistributeRewardsInternally rewards distributes ConsumerRedistributeName to Similarly, in the x/ccv/consumer/keeper/distribution.go and feeCollector the ConsumerToSendToProviderName DefaultConsumerRedistributeFrac. By the time the sendRewardsToProvider function is called, feeCollector has a zero balance. Thus, in x/ccv/consumer/keeper/distribution.go:138 will always contain 0 emitted fpTokens, which again is misleading for client applications and users the emitted event according function from to",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Redundant checks are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "The codebase contains redundant checks:  The version check in x/ccv/consumer/ibc_module.go:95 is unnecessary as it is already invoked in line 42.  The ValidateBasic function in x/ccv/provider/client/cli/tx.go:56 is the unnecessary GenerateOrBroadcastTxWithFactory function in line 60. invoked already as in is it",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Outstanding TODOs",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "There are multiple TODOs in the codebase that development: imply that the codebase is still in  x/ccv/types/expected_keepers.go:82,  x/ccv/provider/ibc_module.go:185, and  x/ccv/consumer/keeper/genesis.go:21.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Miscellaneous comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf",
        "body": "Across the codebase, instances of unused/commented code and inaccurate comments have been found. This can negatively impact the maintainability of the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. getAllPrivate function incorrectly returns public capabilities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/CapabilityProxy.cdc:62-64, the getAllPrivate function returns all capabilities stored in the self.publicCapabilities dictionary. This is incorrect because the function should return all private capabilities instead of public ones. Consequently, the function will always return incorrect types of capabilities. We classify this issue as major because it aects the correct functioning of the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Deny list lter allows retrieving invalid capabilities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/CapabilityFilter.cdc:44, the allowed function returns true when the capability cannot be borrowed. This is problematic because a malicious parent account can store invalid capabilities and use them once the underlying resource becomes borrowable. Consequently, this allows the parent account to bypass the lter restrictions created by the child account. to the appendix to reproduce the issue. While the provided test case Please refer demonstrates a situation in which the parent account can bypass the manager capability lter, this issue can similarly lead to bypassing the capability lter in the proxy account.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Capabilities are not checked to be valid",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In several instances of the codebase, capabilities are not validated to be borrowable before storing them. The following code locations should have the capability validated:  addCapability function in contracts/CapabilityProxy.cdc:87-94.  Initialization phase in contracts/HybridCustody.cdc:354 where the filter is not nil.  setManagerCapabilityFilter contracts/HybridCustody.cdc:418 managerCapabilityFilter is not nil. function where in the Consequently, the capabilities might fail to borrow the underlying resource reference when used, which is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Replaying publishToParent causes the ProxyAccount resource to be overwritten",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/HybridCustody.cdc:593, no validation ensures the publishToParent function is not called towards the same parent address more than once. If the function was called twice for the same parent address, the old ProxyAccount resource will be removed, the as seen in line 621. This is inecient because the child account should call removeParent function to overwrite an existing parent.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Potential incorrect owner query before ownership acceptance",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "the giveOwnership function sets the In contracts/HybridCustody.cdc:707, acctOwner to the recipient to indicate they own this child account. However, there is a possibility that the recipient does not claim the published capability from the child's account. Consequently, the getOwner function in line 690 would still show the account owner is the recipient, which is incorrect.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Removing nonexistent capabilities emits events",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "the removeType In contracts/CapabilityFilter.cdc:34-37 and lines 72-75, function removes the capability from the dictionary without checking its existence. This is problematic because the FilterUpdated event would be emitted accordingly to indicate the capability is inactive, which is incorrect. After all, the capability was never added before.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Transferring ownership does not emit an AccountUpdated event",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/HybridCustody.cdc:327-333, the giveOwnerShip function calls the child account to transfer ownership to another user. However, the AccountUpdated event is not emitted to notify event listeners that there is a change in the owned account.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Unlinking the public proxy account resource path is unnecessary",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/HybridCustody.cdc:672, the removeParent function unlinks the public path for the proxy account identier. This is unnecessary because public paths are not linked during the creation of the proxy account resource.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Named parameters are not used for known functionalities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/HybridCustody.cdc:801, the display metadata view is stored in a dictionary with a hardcoded key display. Since the eld and the functionality is already known, hardcoding the parameter can be avoided.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Duplicate function can be removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "the getAddresses function performs the In contracts/HybridCustody.cdc:279, same action as getChildAddresses. This is inecient because calling both functions returns the same functionality and result.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Default manager capability lter cannot be updated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/HybridCustody.cdc:223, the filter variable acts as a default lter value passed to any newly added child account. Since the manager resource owner cannot modify calling the setManagerCapabilityFilter again. This can easily get complicated when the number of child accounts increases. this, any new lter to add requires the manager intends",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Codebase readability can be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "The readability of contracts/HybridCustody.cdc: the project can be further improved in the following contexts in 1. The variable and function names used to denote the type of account are inconsistent across the contract. Some of them can be useful when referenced within the context it is dened but results in reduced readability in general. Consider explicitly naming the account types and identiers and keeping them consistent across the contract. For example, lines 211 and 363 use both childAccount and account to specify a child account. In this case, explicitly calling out the child's account can improve readability. 2. The seal and removeOwned functions do not sound as cautious as they need to be, possibly causing their impact to be undermined. Consider making their importance more explicit in addition to the comments already given in the contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. addFactory function overwrites existing types",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In contracts/CapabilityFactory.cdc:17, the function addFactory doesnt check if the type that is being added already exists or not. If the type to be added already exists, it may be overwritten by mistake.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Outstanding TODO comments in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf",
        "body": "In several TODO. This decreases the readability of the codebase. instances of the codebase, many unimplemented functionalities are marked as",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Non-deterministic iteration may break consensus",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "the following maps In a Cosmos SDK blockchain, non-determinism of blocks will cause the blockchain to halt. The is not deterministic: blockDistrState.Txs, iteration over blockDistrState.Contracts, in contractDistrState.TxGasUsed x/rewards/keeper/distribution.go:122, 133, 147 and 181 respectively. This can lead to consensus failure, since the order of iteration over a Go map is not guaranteed to be the same every time the program is executed. and",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Contract owners may set excessive FlatFee",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "The SetFlatFee function in x/rewards/keeper/msg_server.go:89 does not impose an upper-bound limit on the FlatFee amount. While the FlatFee is determined by the owner of a contract, governance should dene a maximum fee to prevent excessive amounts that may impact the usability of contracts that are popular on the chain. While this is unlikely, contract owners may introduce prohibitively high fee amounts after their contract has achieved mass adoption.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Missing usage description for transaction and query CLI commands",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "It is best practice to supply a long message for transaction and query CLI commands of a to both users and external Cosmos SDK application, since such messages are helpful developers. With the exception of getTxSetContractMetadataCmd, all transaction and query CLI commands for the rewards module in x/rewards/client/cli/tx.go:24-28 and x/rewards/client/cli/query.go:22-29 are missing long messages.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Mismatch between technical specication and implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "The technical specication in x/rewards/spec/01_state.md:74 species that an Object is pruned (removed) at the BeginBlocker. However, objects are actually pruned in the cleanupTracking function in x/rewards/keeper/distribution.go:237-238, which is executed during the EndBlocker.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Non-standard error codes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "to the documentation According Cosmos (https://docs.cosmos.network/main/building-modules/errors), there are restrictions on error codes. One such restriction is that error codes must be greater than one, because the value one in x/rewards/types/errors.go:8 is registered with the error code one. ErrContractNotFound errors. However, reserved internal ocial SDK for is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Miscellaneous code quality comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf",
        "body": "Throughout the codebase, some instances of inecient code and misleading comments have been found.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. backend-node/helpers/funcitons/utils.ts: Key size mismatch in AES encryption",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf",
        "body": "Server-side encryption only uses the top 16 bytes of the derived value as an encryption key: const key = sha256(secret).substr(0, 32); The above code derives the key as the top 32 characters of a hex string, meaning the actual keyspace is reduced to 128 bits, even though AES-256 is used.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. backend-node/helpers/functions/utils.ts: Backend encryption uses SHA-256 for key derivation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf",
        "body": "The functions encrypt() and decrypt()derive the encryption key hashing the DB_BACKEND_SALT. SHA-256 on its own is not a secure key environment variable derivation function. This issue is marked as minor since the encrypted data has already been encrypted client-side.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Email 2FA codes do not expire",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf",
        "body": "Email backend-node/controllers/wallet.controller.ts, codes 2FA are generated in function updateEmail2fa(). However, considered good practice to limit the time between rst- and second-factor authentication. these codes remain valid indenitely. is generally It",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Outdated dependencies in Backend",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf",
        "body": "versions and Outdated web3-eth-accounts npm packages are used. These modules introduce a nested dependency to an insecure version of the elliptic cryptography library. ethereumjs-util ethereumjs-tx, the for",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Outdated dependencies in SDK",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf",
        "body": "Outdated versions for the web3 and web3-provider-engine npm packages are used. Newer versions of these two modules introduce minor security xes of nested dependencies.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Consider using GCM mode for server-side encryption",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf",
        "body": "The backend uses CBC mode with PKCS#7 padding for 256-bit AES encryption. CBC mode is generally considered less secure because of its inherent vulnerability to oracle padding attacks. Whilst this type of attack should not be an issue in this particular application, GCM is generally recommended as a more secure option.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Lack of propagation of slashes to user deposits may lead to users rushing to unbond since last unbonding users may not be able to receive their stake back",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "The current architecture does not propagate slashes to user deposits, but rather relies on a slashing fund reserve to replenish slashes. That slashing fund is managed by the contract manager. There is currently no logic that reduces any users funds to account for slashes. That makes the whole protocol inherently unstable  any slashing compensation fund will eventually run out of tokens, at which point the last users to undelegate their funds will lose those funds. Rational users will anticipate that loss, which might trigger them to rush to unbond as quickly as possible. The only way to prevent this from happening is a sucient slashing fund reserve, but a rational manager would anticipate that rush and not be incentivized to replenish the reserves. The current slashing compensation is implemented as follows: The validator contracts manager can add or remove slashing funds at any time through the add_slashing_funds and remove_slashing_funds functions. Those funds are tracked in the contracts state in the slashing_funds eld. Whenever rewards are redeemed through the pools contract, the delegations of all validators are queried and a check for slashed validators is performed. If a validator got slashed, the contract uses those slashing_funds to delegate the slashed in contracts/validator/src/contract.rs:309. amount back to the validator their full deposited stake back on undelegation in Independent of slashing, users get contracts/delegator/src/contract.rs:297. As described above, this process makes the Stader protocol unstable. Apart from that, there is another issue: Slashed validators are jailed on Terra, so compensating the slashed amount will not be productive.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Validator removal happens without updating the pools contract, which leads to inconsistent state and implies that removed validators will still receive delegations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "Currently, the only way to remove validators is through the remove_validator function in the validator contract in contracts/validator/src/contract.rs:164. That implies that the validator storage of pools contract will not be updated: Validators are neither removed from the validators vector of PoolRegistryInfo, nor are they removed from the VALIDATOR_REGISTRY. Since removing a validator also leads to a re-delegation of the bonded tokens, these stake changes are not reected in the VALIDATOR_REGISTRY of the pools contract. This has several critical implications: The validator state will be inconsistent between contracts, unbonding through the pools contract will try to unbond from an already unbonded validator, and new deposits through the pools contract will be delegated to a previously removed validator through contracts/pools/src/contract.rs:231.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Rewards are double counted, leading to slashing funds being distributed as rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "In the validator contract, each validator is stored in the VALIDATOR_REGISTRY with their current stake and their accrued rewards. That accrued_rewards eld is incremented in dierent places in the contract, leading to double-counting of rewards instances are contracts/validator/src/contract.rs:238, 321, 394, 410, 490, 691, and 962. Consequently, the total calculated in contracts/validator/src/contract.rs:605 the will swap_and_transfer function transfers too many rewards, distributing funds as rewards that It will also lead to the transfer_reconciled_funds function not returning the error in line 770 even if it is expected to. should be reserved for slashing compensation. collected rewards. actually implies bigger That than that the be",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. First user to deposit rewards into an empty strategy that contains remainder tokens will lose these rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "the contracts/scc/src/helpers.rs:79, In get_strategy_shares_per_token_ratio function returns the default_s_t_ratio in the case where the total tokens in the SIC are zero. It returns zero though in the case where the token balance of the SIC is positive, but the total shares are zero in line 84. That could happen if all deposits have been redeemed, but the SIC still owns a remainder, e. g. from integer division or unclaimed rewards. In such a case, the next user to deposit tokens will not get any shares assigned in contracts/scc/src/contract.rs:1162, and hence lose their deposit.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Multiple reward coins sent to SIC auto-compound and base contracts or coins sent in wrong denom will be locked inaccessibly in contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "check The for in and contracts/sic-auto-compound/src/contract.rs:510 packages/sic-base/src/contract.rs:126 as well as the check for the wrong coin denom in lines 516 and 132 of those respective contracts do not return an Err, but rather Ok, which means that the transactions will not be reverted. Consequently, multiple coins sent multiple coins sent or coins sent in the wrong denom will not be returned, but rather locked inaccessibly in the contract.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Undelegating from a strategy with not sucient funds will lead to users losing (part of) their rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "in contracts/scc/src/contract.rs:487. In the undelegate_from_strategies function in the SCC contract, an iteration over all strategies is performed, sending the UndelegateRewards message for each strategy to its SIC contract. That message species the amount to be unbounded in the next undelegation batch that UndelegateRewards message in the SIC auto-compound contract checks whether enough suce in funds are available and returns an Ok message if contracts/sic-auto-compound/src/contract.rs:571. Since an Ok return value does not revert the transaction, no rewards will be undelegated from the SIC, but the SCC will be updated that the undelegation batch was processed, including updated shares and a new release time for the unbonding. No unbonding happened though, and thus users will not get the funds they should have gotten, with no way to recover. funds do not handler The for",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Replacing a validator that is receiving a redelegation will lead to loss of delegation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "When replacing a validator in the SIC auto-compound contract, only the funds in the in will can_redelegate contracts/sic-auto-compound/src/contract.rs:310. The can_redelegate eld will be zero if the outgoing validator is currently receiving a redelegation, and contain the full delegation amount otherwise. In the case where the outgoing validator receives a redelegation, no funds will be redelegated, but the validator will still be removed from the redelegated eld be validator_pool list in line 337. The delegation amount and the received redelegation will be locked in the pool due to the condition in line 268.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Usage of stored rather than queried delegation amounts may lead to an inconsistent state when unbonding",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "The current logic that processes undelegation batches in the pool contract iterates over a pools validators in contracts/pools/src/contract.rs:413 to undelegate enough stake to satisfy the amount requested from users. That logic uses the stored stake of validators, rather than querying the currently delegated funds. This is problematic, since validators might have been slashed/jailed or decided to unbond since the storage was last updated. In those cases, the actual undelegated amount would be smaller than the amount requested by users, since Cosmos SDK caps the undelegated amount to the available amount, rather than returning an error. The pools contract would not be aware of the discrepancy, and the stored stake would be inconsistent with actual delegations.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Util functions iterating over unordered hash maps may lead to Terra node consensus failures",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf",
        "body": "The map_to_coin_vec and map_to_deccoin_vec functions iterate over the keys of a HashMap in packages/stader-utils/src/coin_utils.rs:111, 121 as well as in packages/sic-base/src/helpers.rs:184. Since HashMap keys are returned in an arbitrary order, the resulting vector has an arbitrary order of its entries. That could lead to dierent stored data in the contract storage between Terra nodes, which might cause consensus failures.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Disabled collateral can be re-enabled by depositing on behalf of the user",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/red-bank/src/execute.rs:471, the users collateral to market bit is automatically set if the user deposits a collateral asset. An attacker can re-enable a disabled asset as collateral by depositing a small number of funds on behalf of a victim. As a result, the re-enabled collateral will get liquidated if the borrower does not maintain the sucient liquidation threshold ratio. This might cause an unexpected loss to the victim since they disabled the asset as collateral. Please see the test_enable_asset_as_collateral_for_other_users test case in the appendix to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Swapping assets in the reward collector contract are vulnerable to sandwich attack",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/rewards-collector/osmosis/src/route.rs:121, the minimum amount of swap output is hardcoded to zero. Due to no slippage protection, an attacker can the normal price, calling the perform a sandwich attack by purchasing the asset at SwapAsset operation to buy the asset at an increased price, then immediately selling it for a prot. The attacker can repeatedly perform this attack to force the contract into buying assets at a higher price, resulting in a loss of funds.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Red banks markets with an id greater than 128 cannot be used",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "The red bank contract can handle an indenite amount of Markets that are created by the contract owner and stored in the MARKETS mapping. Each Market struct has a unique index attribute that is responsible for indicating its bit position in borrowed_assets and collateral_assets bitmaps dened in the User struct. Since those bitmaps are Uint128, they can handle a maximum of 128 Markets. This implies that any Market with an index greater than 128 cannot be used because of an overow in contracts/red-bank/src/helpers.rs:29.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Incorrect refund address during debt repayment",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "the caller The repay function allows repayment of a loan on behalf of other accounts. In a scenario where in account contracts/red-bank/src/execute.rs:843, refund the excess amount to the target address passed in the on_behalf_of parameter and not the caller. This implies that the party repaying the loan will lose funds to the debtor. behalf the function will overpays another debt on of",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Computationally heavy unbounded loop during user position health calculation can lead to out-of-gas execution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "contracts/red-bank/src/health.rs:121, In get_user_positions functionality attempts to loop over all markets initialized in the red bank contract. Since the is unbounded and markets cannot be removed, the execution gets more market count expensive with the number of markets and might eventually run out of gas if there are too many markets initialized. the This issue is also present in the UserDebts and UserCollaterals query messages in contracts/red-bank/src/query.rs:123-149 and 164-180. The queries attempt to loop through all markets without any pagination limit.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Address provider contract does not validate the newly set owner as valid address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/address-provider/src/contract.rs:77, the contract owner is set to the new_owner string provided by the caller. If the new owner is not a valid address, it will cause the address provider contract to have an invalid owner. As a result, it would prevent the SetAddress and TransferOwnership functionality from working correctly. We consider misconguration. this a minor",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Users will be unable to claim rewards if too many asset incentives are added",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In the incentives contract, users can call ClaimReward to retrieve their accrued Mars rewards. The message is handled by the compute_user_unclaimed_rewards function in line contracts/incentives/src/helpers.rs:84 which loops through all the asset incentives. On a long enough timeframe, if many assets get added to the protocol, this gets more expensive and could eventually run out of gas and hence block claiming of rewards for a given user.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Addresses are not validated if a wrong prefix is set in the address-provider contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "contracts/address-provider/src/helpers.rs:11, the In assert_valid_addr function is executed, all addresses that start with a prefix dierent from the stored one are assumed to be valid without executing api.addr_validate. when This implies that invalid addresses can be stored in the contract mapping and that the check on the given prefix can be bypassed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Setting price source for liquidity token aects Prices query message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/oracle/osmosis/src/price_source.rs:125-127, the liquidity token price source cannot be queried as it will return an Unimplemented error. However, the contract owner can add a liquidity token price source in lines 97-99. This means that the Prices query message would be aected since it includes the liquidity token price source when querying. Note that users can manually avoid querying the LiquidityToken price source by ltering out the aected entry with the start_after and limit arguments. Please see the  test_query_liquidity_token_prices test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Markets reserve_factor attribute is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In packages/outpost/src/red_bank/market.rs:79, the validate method for the Market struct is not checking reserve_factor. Since this attribute represents the percentile of the borrow rate that is kept as protocol rewards, a value greater than one could cause the execution to distribute an incorrect amount of funds. We consider this issue to be minor since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Contracts are not compliant with CW2 Migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "The following contracts do not adhere to the CW2 Migration specication standard:  address-provider  oracle  incentives  red-bank  rewards-collector This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Unversioned dependencies could lead to supply chain attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "oracle The contracts/oracle/osmosis/Cargo.toml:37. requires contract osmo-bindings as a dependency in Since it is fetching it directly from the GitHub repository without specifying the wanted commit hash or tag, any changes to that repositorys main branch may accidentally be included in the contract. This could lead to bugs as well as supply chain attacks.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. optimal_utilization_ratio value could cause a division by zero panic if not correctly validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In the packages/outposts/src/red_bank/interest_rate_model.rs:35, divide_decimal_by_decimal is dividing the current_utilization_rate by optimal_utilization_rate. Since optimal_utilization_rate is not validated to be greater than zero, this division could cause a panic.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Zero Mars token code identier will lead to InitAsset failures",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/red-bank/src/execute.rs:60, when conguring the Mars token code identier, it is not validated to not be zero. If the code identier is congured as zero, it will cause the InitAsset functionality to fail. This issue is also present in line 103 when updating the conguration.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Liquidator is unable to specify the receiver address which negatively impacts integrations and exibility",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/red-bank/src/contract.rs:72, there is no way for the liquidator to specify the recipient address for receiving underlying collateral. This will add overhead for periphery contracts to specify the logic for redirecting the liquidated assets transfers to rightful liquidators.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Avoid meaningless conguration update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/oracle/base/src/contract.rs:113, the contract owner can update the execution will be the conguration with the owner value as None. As a result, to the meaningless because the option_string_to_addr functionality will default original conguration owner. This would cause no changes to be modied in the end.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. InvalidDepositAmount validation during red bank deposit can be removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In contracts/red-bank/src/execute.rs:459-464, the check ensures the deposit amount is not zero when depositing in the red bank. This check is unnecessary as the one_coin functionality from cw_utils already prevents zero amounts, as seen in contracts/red-bank/src/contract.rs:53.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/address-provider/Cargo.toml  contracts/oracle/base/Cargo.toml  contracts/oracle/osmosis/Cargo.toml  contracts/incentives/Cargo.toml  contracts/red-bank/Cargo.toml  contracts/rewards-collector/base/Cargo.toml  contracts/rewards-collector/osmosis/Cargo.toml While enabled implicitly through the workspace manifest, future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Contracts should implement a two step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "20. TWAPs are more sensitive to manipulation than median prices in \"one-block\" attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "In a \"one-block\" attack, an attacker manipulates the price of an asset and then arbitrages it back in the next block. This type of attack is possible when the attacker knows in advance to be the creator for the next block (e.g. the attacker is a validator in PoS blockchains with deterministic slots) since the validators can order transactions to minimize the risk of the attack. Because TWAPs are calculated using the time-weighted average of prices, a \"one-block\" attack will have a greater impact on the TWAP calculation than on the median price. This is because the manipulated price will be included in the TWAP calculation, whereas it will not aect the median price. Therefore, TWAPs are more sensitive to manipulation than median prices in \"one-block\" attacks.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "21. Custom access control implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf",
        "body": "Contracts implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Subwallet factory updates could lead to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "During the creation of a subwallet, the addresses of the Anchor Money Market and Terra token contracts are passed from the subwallet factory cong to the newly instantiated wallet - see contracts/subwallet-factory/src/contract.rs:107. These addresses are then stored in the cong of the new subwallet. The subwallet factory contract owner is able to update the addresses of the Anchor Money Market and Terra token. These changes would not be reected in the existing subwallets. This could lead the subwallets to use incorrect addresses for the Anchor market and Terra token.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Product factory updates could lead to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "During the creation of a xed recurring subscription contract the address of the job registry contract see contracts/sub1-fixed-recurring-subscriptions/src/contract.rs:74. This address is then stored in the cong of the subscription contract. specied is - The product factory contract is able to update the address of the job registry contract. This change would not be reected in the existing recurring subscription contract  unlike the protocol fee and other conguration parameters dened in the product factory, which are queried prior to use rather than stored. This could lead the subscriptions to use an incorrect address for the job registry contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Protocol fee decimal places incorrectly specied",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "The protocol fee is dened in basis points during instantiation of the product-factory contract cong. During both, the instantiation and update of the cong, the protocol fee is veried to ensure that is less than the maximum of 5%. As the fee is represented in basis points 5% is dened as 500, which implies that in xed-point arithmetic 4 decimal places are being used - i.e. 500 / 10,000 = 0.05. On lines sub1-fixed-recurring-subscriptions/src/contract.rs:346 and 697, decimal places are applied incorrectly when calculating the ratio of the protocol fee. In each case, the protocol fee could be greater than 100%. Which could lead to users being charged excessive amounts for using the protocol.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Owner cannot freeze admins",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "the function executing When in contracts/admin-core/src/contract.rs:84, the contract veries that the sender is a whitelisted admin. Once this function is executed the contract owner will be unable to append new admins or otherwise unfreeze the admin list. This is contrary to the documentation denition of the owner being the highest-privilege access. execute_freeze, found as Further access verication to the execute_freeze function uses the can_modify function which checks that the sender is on the admin list. However, in the case that the owners address is not on said list this check would fail. Preventing the owner from successfully calling the execute_freeze function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Owner cannot execute set permissions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "le contracts/subwallet/src/contract.rs:389 In function execute_set_permissions veries that the message sender is an admin whitelisted for the wallet. However, if the sender is the owner and not present on the admin whitelist then the execution will fail. As the owner has the highest-privilege access to a wallet this is contrary to the documentation. the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Admin whitelist cannot be unfrozen",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "le contracts/admin-core/src/contract.rs:54 In function execute_freeze freezes the list of whitelisted admins for a suberra wallet. Once frozen there is no way to reverse this decision, even for the wallet owner. It may be necessary to remove, or add, an admin due to scenarios such as the case of a leaked private key. the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Protocol fee decimal places should be dened as constants",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "The protocol fee is dened in basis points during instantiation of the product-factory contract cong. During both, the instantiation and update of the cong, the protocol fee is veried to ensure that is less than the maximum of 5%. As the fee is represented in basis points 5% is dened as 500, which implies that in xed-point arithmetic 4 decimal places are being used - i.e. 500 / 10,000 = 0.05. However, throughout the code base, there is no constant variable dened to use in protocol fee calculations. Rather values are used on an ad-hoc basis, including:  sub1-fixed-recurring-subscriptions/src/contract.rs:271  sub1-fixed-recurring-subscriptions/src/contract.rs:346  sub1-fixed-recurring-subscriptions/src/contract.rs:697  sub2-p2p-recurring-transfers/src/contract.rs:451",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Unbounded number of contract admins",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "There is no limit dened in contracts/admin-core/src/state.rs:10 to the number of addresses that can be whitelisted as Suberra wallet admins. Should the number of admins be excessively large this could make execution functions costly and query functions unperformant. In extreme cases, this could cause the querier to run out of gas.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Total number of subscriptions increments on cancellation undo",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf",
        "body": "When a cancelled subscription is undone through the execute_subscribe function, contracts/sub1-fixed-recurring-subscriptions/src/contract.rs:389, the function create_subscription is called. This function increments the total number of In the case of an undone cancellation, this leads to the number of subscriptions by 1. subscriptions being incremented unnecessarily.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Oracle migration from v04 to v05 skips deprecated pre-votes and votes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra/Terra Columbus-5 - Audit Report.pdf",
        "body": "x/oracle/legacy/v05/migrate.go:26 elds In ExchangeRatePrevotes and ExchangeRateVotes from v04 are skipped and not added as entries to the v05 genesis elds AggregateExchangeRatePrevotes and AggregateExchangeRateVotes. That implies that existing valid (albeit deprecated) votes are lost in the migration. deprecated the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Wrong validation before setting Ethereum public key in conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Persistence/2022-01-20 Audit Report - Persistence Bridge - v1.0.pdf",
        "body": "In application/configuration/configuration.go:115, a validation check for non-emptiness of caspTMPublicKey is performed, but then the caspEthPublicKey conguration value is assigned.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. PeriodicVesting is unintendedly releasing tokens to users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf",
        "body": "In vesting:src/msg.rs:117-138, the vested amount of tokens that is ready to be redeemed by the user is calculated using a PeriodicVesting schedule. It is supposed to calculate the current number of elapsed intervals since start_time in order to compute the total amount of vested tokens. As demonstrated in the test case in Appendix 1, the code is not calculating the correct vested tokens though, which leads to the following problems:  At start_time, the user can already redeem the rst tranche of tokens, even if no interval has elapsed.  The user gets a token tranche more than expected at the end of the vesting period.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. LOCKINGADDRESS is never populated which will block rebasing functionality",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf",
        "body": "The handle_lock_nft function in locking:src/contract.rs:256-266 does not store the locking address to LOCKINGADDRESS. The function creates a mutable vector of addresses from LOCKINGADDRESS where it pushes the senders address but the address is never saved to LOCKINGADDRESS. This results in the map never being populated, which will highly impact other functionality in the contract such as the calculate_rebase_reward function that performs a rebase.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Multiple rounding issues may cause zero rewards being distributed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf",
        "body": "functions of Several the locking contract are aected by rounding issues since their mathematical operations use U128 integers for divisions where the numerator is smaller than the denominator. This causes the result to be truncated to zero instead of the desired ratio before it is multiplied, causing the whole operation to be zero. Therefore, reward distribution will result in a zero tokens distribution. In particular in the The aected operations can be found on rewards related features. calculate_bribe_reward, and calculate_surplus_reward functions. The aected instances can be found at and locking:src/contract.rs:770, locking:src/query.rs:322. calculate_rebase_reward 870, 888, 904, 919,",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Unbounded iterations may cause calculate_rebase_reward to run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf",
        "body": "The calculate_rebase_reward function in locking:src/contract.rs:798 performs an unbounded iteration over all entries in LOCKINGADDRESS, and then for each address in LOCKINGADDRESS it will iterate through all vtokens for the gov_token_denom. Both VTOKENS and LOCKINGADDRESS are unbounded and have the potential to grow large with time and normal use. In addition, as mentioned in the nding LOCKINGADDRESS entries are never removed which may introduce state bloat, LOCKINGADDRESS can never be reduced, exacerbating this issue. The impact of this issue is that the rebasing functionality of the contract could become blocked for a specic app_id.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Reward collection for an address will eventually fail due to block gas limit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/pNetwork/20200915_pNetwork DAO staking+reward audit.pdf",
        "body": "Function collectRewardsFor() loops over a an ever-growing array of rewards. This means that the transaction will eventually hit the block gas limit when the array grows too large. From this point, rewards the rewards, and any future rewards for an address will be stuck. The reason for this behavior is that the array can only grow, making the loop more gas-intensive every time.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Staking operation does not check for allowance",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/pNetwork/20200915_pNetwork DAO staking+reward audit.pdf",
        "body": "stake() in the StakingManager contract uses safeTransferFrom() to The function msg.sender to the vault. However, whilst the senders balance is transfer tokens form checked for sufficient funds, no check is performed whether the contract has been authorized to transfer sufficient funds on behalf of the user. This means that the transfer might fail with an unspecific error message.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Gas-intensive loops over unbounded arrays in staking manager",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/pNetwork/20200915_pNetwork DAO staking+reward audit.pdf",
        "body": "Lock data structures, The staking manager stores information in user stakes in arrays of maxLocks variable, which can be set by an authorized caller. These arrays are limited by the searched using for loops during insertion and removal (staking and unstaking). It is generally considered dangerous to loop over unbounded or variable-sized arrays since it results in unpredictable gas consumption. In the extreme case, this can lead to the block gas limit being exceeded and certain transactions never completing. In this particular case, this may lead to unstake() fails due to the array becoming too large. This may occur if stuck funds if maxLocks is accidentally set too large. Note, that this issue has been classified as minor because maxLocks can only be set by a trusted account. However, accidental misconfiguration can still lead to stuck funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Sequence is not reset when establishing a new channel",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "packages/polytone/src/callback.rs:90-117, In request_callback function reads the latest value stored in the SEQ storage and saves it as the callback for the incoming packet sequence. However, the SEQ storage does not reset the sequence back to 1 when the old channel is closed via ibc_channel_close. the Suppose the old channel is closed and a new channel is established. The packet sequence will start as 1. Since the SEQ storage records the old channel's sequence value, the CALLBACKS storage will save the pending callback with an incorrect seq value. As a result, pending callbacks will never be executed properly by the intended receiver, causing CALLBACKS not to be handled and LOCAL_TO_REMOTE_ACCOUNT not to save the request initializer's remote proxy contract address.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Controllers could instantiate proxies and execute messages on the receiver chain on behalf of other users without their consent",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "on_behalf_of The contracts/note/src/msg.rs:61 allows messages on the receiver chain on behalf of other users. attribute the of Execute struct controlled note contracts dened in to execute However, this is possible without the targeted user's consent allowing the controller account to impersonate unaware users on the controlled chains. While this cannot directly aect targeted users and their funds, controller compromise their reputation. it could allow a malicious to perform phishing and fraud campaigns or impersonate users in order to",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Encoding extensions are not enforced during handshake",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "The Polytone protocol denes encoding extensions in order to ensure that connected chains exchange data with an agreed format. To do so, in packages/polytone/src/handshake/note.rs:35, the protocol requires that the voice contracts extensions are a subset of the note contracts. However, encodings, contracts/note/src/ibc.rs:26 and 41. the implementation, the exchanges instead of exchanging the underlying chain-supported in hardcoded JSON-CosmosMsg dened string This would cause the mentioned validation check during the handshake to succeed without actually enforcing the extensions subset requirement.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. The proxy contract does not return the correct index of an errored message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "In contracts/proxy/src/contract.rs:78, returns an error containing the index of the errored message. the proxy contracts reply handler However, it returns the cardinality of submitted messages instead of the actual index. This would cause the propagation of an error with incorrect information leading to potentially wrong actions in the callback.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. PROXY_CODE_ID and BLOCK_MAX_GAS are not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "When instantiating the note and voice contracts, no validations are performed to validate the PROXY_CODE_ID and BLOCK_MAX_GAS values. This is problematic because misconguring the PROXY_CODE_ID to zero would cause the proxy instantiation to fail in contracts/voice/src/contract.rs:93. As for BLOCK_MAX_GAS value, it should be validated to be higher than ACK_GAS_NEEDED and ERR_GAS_NEEDED to prevent underows in contracts/voice/src/ibc.rs:102 and contracts/note/src/ibc.rs:102 and 123. classify We MigrateMsg::WithUpdate message to recover from these situations. as minor because the contract issue this admin can use the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. The note contract cannot handle more than 2^64-1 messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf",
        "body": "In packages/polytone/src/callback.rs:97, incremented and saved. the message sequence SEQ is However, since it is stored as a u64, the increment will overow, and panic because of the overflow-check in place in the Cargo.toml, after the execution of 2^64-1 messages. This would prevent users from interacting with the contract and consequently lose access to their proxy accounts in the controlled chain.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Proposals tally returns wrong vote results",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In neutron:x/gov/keeper/tally.go:79-81, when calculating the result of a governance proposal, the execution is not accounting for NoWithVeto votes. The current implementation returns a failed proposal result if the following inequation is true:     .   It is evident that NoWithVeto votes are not counted and treated as Yes votes in the example in Appendix 1. This implies that proposals that should fail will be unintendedly successful.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. An error triggered during the handling of an Ack IBC message will make the channel unusable and spam the network",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "Neutron uses ORDERED channels, which means that there is a sequencer that keeps track of the currently waiting Ack message. is in handled in This message https://github.com/cosmos/ibc-go/blob/77c10be63204a52ec53b1e8ef91a76bae140d5ed/mod ules/core/keeper/msg_server.go#L588-L647 that incrementing the responsible for the IBCModules HandleAcknowledgement method NextSequenceAck and call dened in neutron:x/interchaintxs/keeper/ibc_handlers.go:16-47. Acknowledgement function dened the is it returns an error, If incremented. This could happen for various reasons: the execution will revert and NextSequenceAck will not be  Sudo handlers in the smart contract return an error because of a bug or an invalid input data  Sudo handlers are not dened in the smart contract This implies that the channel will be unusable and that the relayer will continue sending the same failing Ack message. Also, an attacker could use a signicant amount of deployed smart contracts and transactions with failing Sudo handlers in order to let relayers spam the network with Ack messages and trigger the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. This can prevent that node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. IBC events loop in Sudo handler could drain relayers funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "A malicious hacker could develop a CosmWasm smart contract that implements an IBC events loop in the Sudo handler. For example a contract that in the Response Sudo handler, executes another transaction that will trigger the same Response handler and so on. Since there is not an aggregate gas counter for all the dierent transactions of the IBC events ow that could break the loop with an out of gas error, the execution can run until all the relayers funds are drained. Also, this behavior could be used to congest and slow down the chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Attackers are able to spam the network with IBC messages using the ibc-transfer module",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In  neutron:internal/sudo/sudo.go:100-103,  neutron:internal/sudo/sudo.go:132-135, and  neutron:internal/sudo/sudo.go:166-169, the execution is checking that the received Acknowledgement or Timeout Packet is related to an IBC transaction originated from an existing CosmWasm smart contract address and returning an error otherwise. Since it is possible to send an ibc-transfer modules transfer transaction also from a non contract address, for example using the neutrond CLI, with the following command: neutrond tx ibc-transfer transfer an attacker could send a big number of small value transfer messages in order to spam the network with Acknowledgement packets and let them fail in the guard implemented in the mentioned lines. A huge number of such messages could congest nodes and make them unable to process blocks before the BroadcastTxCommit timeout. Also, the NewTxTimeoutHeightDecorator will discard all messages with an elapsed heightTimeout, which could be used in a particular event in order to manipulate it. This can prevent that node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Unbounded iteration in ValidateBasic may cause node timeout",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "ValidateBasic The in x/interchainqueries/types/tx.go:73-100 includes an unbounded iteration that may be exploited to cause a node timeout. MsgRegisterInterchainQuery function for The function loops over TransactionsFilter, a caller-supplied slice that is not checked for duplicate entries and does not have a dened size upper-bound. It is best practice to keep ValidateBasic logic simple as gas is not charged when it is executed. It should only perform all necessary stateless checks to enable middleware operations (for example, parsing the required signer accounts to validate a signature by a middleware) without impacting performance in the CheckTx phase. Other validation operations must be performed when handling a message in a modules MsgServer.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Unbounded iteration in PerformSubmitTx could be used by an attacker to slow down or halt the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In neutron:wasmbinding/message_plugin.go:204, SubmitTx is performing an unbounded iteration over submitTx.Msgs. An attacker could craft a message with a signicant number of Msgs with the intention of spamming the the block production time triggering the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. and impact network This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Unbounded iteration in EndBlocker when calculating vote power could be used by an attacker to slow down or halt the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In neutron:x/gov/keeper/voting.go:40-51, in order to calculate voting powers, the EndBlocker is running an unbounded iteration over a slice containing all voting user votes. An attacker could use a signicant number of addresses with a small amount of tokens in order to grow the slice length and impact the block production time, eventually triggering the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Attackers could steal funds from the ibc-transfer contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "neutron-contracts:contracts/ibc_transfer/src/contract.rs:43, In execute_send is called in order to complete an IBC-20 transaction from source chain to sink chain, but this function does not verify that there are sucient funds in the contract to support an IBC transfer. Because the execute_send function lacks an authorization check, an attacker can frontrun the legit user and steal funds by sending them from the contract to its own address on the sink chain. We classify this issue as major instead of critical since the ibc-transfer contract is meant to be an example.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Fee struct could be simplied to avoid manipulations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In neutron:proto/feerefunder/fee.proto:17, Fees denition includes Coins as an attribute in order to track users and relayers payments. The checkFees function dened in neutron:x/feerefunder/keeper/keeper.go:169 ensures that the user pays the right amount, checking that coins are over a threshold. However, theres no validation for the denom. This can be abused, and only one coin with almost no value could be used to pass the validation checks.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Unbounded messages loop could run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "In neutron-contracts:contracts/neutron_interchain_queries/src/contrac t.rs:312, tx_body.messages to lter out the required transaction. the recipient_deposits_from_tx_body function iterates over the However, because the number of messages is unknown, this could lead to an unbounded loop execution, which could cause an out-of-gas error. This implies that the smart contract may never be able to consume the supplied dataset corresponding to the query. Even though this is a major issue, we classify it as minor since the aected contract is only an example contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Contracts are not compliant with CW2 migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf",
        "body": "The following contracts do not adhere to the CW2 migration specication:  neutron-contracts:contracts/reflect,  neutron-contracts:contracts/neutron_interchain_txs,  neutron-contracts:contracts/neutron_interchain_queries, and  neutron-contracts:contracts/ibc-transfer. This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Use of dependencies with know security vulnerabilities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dock/Audit Report - Dock Wallet.pdf",
        "body": "An analysis of the dependency tree shows 117 known vulnerabilities in the dependency tree. Of these vulnerabilities, 2 are considered of critical severity and 35 are considered of high severity.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. Manually unpausing the hub contract after migration might lead to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2021-11-23 Audit Report - Lido Finance stLuna v1.2.pdf",
        "body": "The migration process described below has been implemented after the frozen commit for this audit. A change to the migration logic of the hub contract was necessary since a migration within one transaction ran out of gas. An audit of the updated migration logic has been performed on commit e04eb1313c481bdeae084a1dab064afdab5ddbae. the hub contract, During migration of to true in contracts/anchor_basset_hub/src/contract.rs:755, which leads to a rejection of all messages except updates of params and the migration of old unbond waitlist entries in line 137. a paused param is set In the current implementation, the contract must be explicitly unpaused by the owner when the migration is done. There is no validation that the migration has actually been fully performed though. If unpaused before the migration has been nished, partially migrated unbonding waitlist entries might be processed, which could cause missed waitlist entries without a way to recover. Additionally, the paused ag can be used at any time by the owner to pause/unpause the hub contract. If the owner key is ever compromised, ownership could be transferred and the contract paused, leaving any funds inaccessible. We classify this issue as minor since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Deposited funds remain locked in custom bond contract for perpetuity custom_bond",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "The at contracts/custom_bond/src/execute.rs:169 does not include any functionality to transfer the deposited principal token funds into the custom_treasury contract. Because of this, any deposited principal token funds will remain locked in the deposit contract for perpetuity. deposit contracts function",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Fees sent to the incorrect treasury leads to loss of Olympus treasury income",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "During the bond creation using create_bond_from_temp and create_bond at contracts/factory/src/contract.rs:231 and 282, the factory contract is using the incorrect value of custom_treasury as olympus_treasury instead of config.treasury. The config.treasury treasury address provided during the initialization at contracts/factory/src/contract.rs:36 is currently unused. The issue can be xed through governance because the olympus_treasury address can be changed through the update_olympus_treasury function. But the collected fees would not be sent to the olympus_treasury until the address is correctly set, they would be transferred to the custom_treasury contract which Olympus does not own.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Additional deposits will reset the vesting term of existing bonds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "Depositing additional funds to an existing bond will cause the vesting term of these existing deposits to be reset in contracts/custom_bond/src/execute.rs:261. That implies that funds that are not yet redeemed by the bonder will have an extended vesting period. i.e on January 6. Suppose that after 4 days, For example, if Alice deposits 100 token A (principal token) on January 1, the vesting term is 5 days and the bond price is 25, then she would get 4 payout tokens after the completion of 5 days, i.e. on January 5 Alice deposits an additional 100 token A and Alice did not redeem during those 4 days, then her new vesting term will be again 5 days as per line 261. If she wants to redeem after 1 day, i.e. on January 6, she will only be able to redeem 8 * 1 / 5 = 1.6 token B, even though the previous 4 tokens should have already been vested.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Missing support for upgrades of bond and treasury contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "the bond and treasury contracts sets the factory contract as the admin in Creation of contracts/factory/contract.rs:197, 226, and 277. This means only the factory contract can upgrade the bond and treasury contracts, but there is no function in the factory contract to execute updates. The contracts also lack versioning information that can be handy in the future during upgrades of the contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Centralization risk in withdrawal of treasury funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "Currently, contracts/custom_treasury/src/contract.rs:118 withdraw is access the to function controlled by in the assert_policy_privilege function which ensures that the info.sender equals the config.policy address. The withdraw function allows the policy account to issue an arbitrary withdrawal from the treasury to any recipient. In the event of the policy account being compromised, an attacker would have the ability to completely drain the treasury. We classify this nding as minor because while the impact would be major, the likelihood of this event occurring is low if strong key management practices are used on the policy account.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Usage of dierent versions of cw20 crate",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf",
        "body": "Within the project's Cargo.toml les, dierent versions are used for the cw20 crate:  Version 0.10.3 in contracts/custom_treasury/Cargo.toml:28  Version 0.8.0 in contracts/custom_bond/Cargo.toml:29  Version 0.8.0 in contracts/olympus_pro/Cargo.toml:20",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Slashing distribution may create a tragedy of the commons where slashing is never applied and new users are disincentivized to enter the protocol",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "function calculate_new_withdraw_rate time (minus an unbonding_period delta time). in The lido_cosmos_hub/src/unbond.rs:129 updates the historical withdraw_rate of a given batch to account for slashing events that happened between the unbond epoch and the current In line 140 of a each calculate_new_withdraw_rate, batch_slashing_weight, which is the proportion of the unbonded ATOM amount of a given last unbonded ATOM of execute_withdraw_unbonded execution. That implies, that no matter when the slashing occurred, slashing will aect all users that have unbonded but have not yet withdrawn. all batches assigned batch batch since total gets the the to This mechanic can create a tragedy of the commons situation, as waiting unstakers are incentivized to not withdraw, since their slashing amount will be reduced the more other users unbond in subsequent batches. Worst case, this can result in a deadlock where no one is incentivized to withdraw. Moreover, new stakers coming in when there are pending slashes will participate in those not yet applied slashes, disincentivizing new users to stake funds. Due to the condition in contracts/lido_cosmos_hub/src/unbond.rs:59, external intervene to resolve the problem by triggering a new withdraw_rate users cannot calculation, since withdrawing is restricted to users that have pending withdrawals.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Unbounded unbond history entries may cause all deposited funds stuck in the hub contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "running out of gas causing stuck irrecoverable funds in the hub contract. The execute_withdraw_unbonded function contains unbounded loops which have the In risk of the lido_cosmos_hub/src/contract.rs:102, calculate_newly_added_unbonded_amount function, there is an unbounded loop that in line 203, iterates over the unprocessed UnbondHistory entries. In a similar manner, inside within the process_withdraw_rate function, another unbounded loop iterates over the same UnbondHistory entries that haven been just processed. If there are no withdrawals for a long enough timeframe, or if the epoch_period is very short, there may be too many entries so this cannot be processed as it would run out of gas, leaving all funds stuck forever in the contract. We do not classify this issue as critical since any user withdrawing unbonded funds will move the last_processed_batch forward, iterations the next withdrawing user needs to process. reducing the number of",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Unbounded unbond wait entities may cause user funds to be stuck in hub contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "an unbounded loop starting in The get_finished_amount function contains lido_cosmos_hub/src/state.rs:113 that iterates over each UnbondWaitEntity of a user. Removal of deprecated batches in the   remove_unbond_wait_list function in line 67 is also unbounded. If there are no withdrawals for a long enough timeframe, or if the epoch_period is short, there may be too many entries so this iteration would run out of gas, leaving the funds of the given user stuck in the contract. issue same could The in lido_cosmos_hub/src/contract.rs:483 and the query_get_finished_amount function in contracts/lido_cosmos_hub/src/state.rs:137 to run out of gas, making the WithdrawableUnbonded and UnbondRequests query unusable. query_unbond_requests function cause the We do not consider this issue to be critical, since the probability of a user experiencing this issue is fairly small. However, its theoretically possible and may happen when using bots and/or automated bonding/unbonding strategies.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Missing validation of Lido fee rate may cause reward dispatch to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "The lido_fee_rate parameter in the Cosmos Reward Dispatcher contract determines the fee Lido applies to bonded Atom rewards. However, there is no validation that this value is smaller instantiation the (lido_cosmos_rewards_dispatcher/src/contract.rs:39) execute_update_config function (line 113). If the fee parameter is bigger than one, dispatch of rewards will fail due to an underow in line 147. Decimal::one() contract than or at in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing validation for stored validator and guardian addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "of list addresses The in lido_cosmos_validators_registry/src/contract.rs:46 is not validated as Addr type. Likewise, addresses are not validated in the add_validator function in line 116. REGISTRY validators stored of in issue is present in lido_cosmos_hub/src/contract.rs:142 in the A similar execute_add_guardians function, where the new GUARDIANS addresses stored are not validated as Addr.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Unbounded guardians query may run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "contracts/lido_cosmos_hub/src/contract.rs:409, In query_guardians iterates over all guardians in storage. Since there can be an unlimited amount of guardians in storage, this iteration can run out of gas. We mark this issue as minor since guardians can only be added by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Slashing is not accounted for in queries which may give wrong results and cause unexpected behavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "lido_cosmos_hub/src/contract.rs:451 In function query_withdrawable_unbonded returns the withdrawable amount for a given address. However, the latest withdraw_rate is not taken into account which is discounting any slashing events that may have occurred. Hence, this query may return incorrect results which may cause unexpected behavior on 3rd party applications integrated with Lido. the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Negative unbonded amounts are not being handled when calculating the withdraw rate",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "In contracts/lido_cosmos_hub/src/unbond.rs:163, when calculating the new withdraw_rate, there is a signed subtraction that might return a negative value. If that were to happen, tokens would be sent to the users that the user should not receive. This could occur if the full amount were slashed, or if nearly the full amount is slashed due to rounding/truncation. Even though this scenario is unlikely, it is theoretically possible as the Cosmos SDK allows a slashing fraction of 100%.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Missing denomination check may become problematic in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "only which contracts Lido Cosmos Hub the Currently, the underlying_coin_denom, In contracts/lido_cosmos_hub/src/contract.rs:341 there is a check to add the delegation amount of the underlying_coin_denom. However, other denominations that are delegated at the same time will be ignored. This could cause issues if the protocol were to add new staking tokens in the future. A similar missing denomination check is also present in contracts/lido_cosmos_validators_registry/src/contract.rs:160 and 223. staking updated. support be cannot in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Users might lose unbonded funds to users that unbond in the next batch if the unbonding period of the hub contract is shorter than the one of the underlying blockchain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "expected undonded amount with Within the execute_withdraw_unbonded function, slashing is applied to an undelegation batch by adjusting the statom_withdraw_rate of that badge. This is done by comparing the The actual_unbonded_amount is calculated by subtracting the stored prev_hub_balance in hubs from contracts/lido_cosmos_hub/src/unbond.rs:193. expected undbonded amount is then computed in the calculate_newly_added_unbonded_amount function by iterating over all unbonding history entries from the last processed/released one to the one thats older than unbonding_period param. unbonded amount. balance current ATOM actual The the the This works well if the unbonding_period param is equal to or greater than the underlying blockchains unbonding period. If the unbonding_period param is too short though, the expected unbonded amount may be bigger than the actual unbonded amount, even if no slashing happens. the statom_withdraw_rate will be too low, and unbonding users lose funds to users in the next unbonding batch. In that case, Despite the severe implications of a too short unbonding_period param, we classify this issue as minor, since governance can ensure equality of the periods by carefully making required changes.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Users are subject to slashing between unbonding and undelegation batch execution, which is currently not documented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "The current implementation of Lido nance does undelegations in batches for eciency reasons. Undelegations happen at most every epoch_period through the logic in the execute_unbond_statom function at lido_cosmos_hub/src/unbond.rs:289. That implies that users that have sent unbond messages to the hub contract will still be subject to slashing until the delegation batch is executed. This behavior is dierent from Cosmos SDKs slashing module, which only slashes delegators that were active when the slashing event occurred. This dierence is currently not documented.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Ability to pause hub contract increases risks associated with compromised owner key",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "The hub contains a paused param, which can be set/unset at any time by the owner to pause/unpause in contracts/lido_cosmos_hub/src/contract.rs:177 and 196. If the owner key is ever compromised or lost, funds may be left inaccessible forever in the contract. contracts the We classify this issue as informational since a compromised owner key has other severe implications and proper key management is an underlying assumption of the protocol in any case.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Exchange rate is not updated after bonding rewards and may exhibit small variations due to rounding/truncation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "In contracts/lido_cosmos_hub/src/bond.rs:94, when the BondType is StAtom, the exchange rate is not updated. Since the new stATOM is minted in proportion to the exchange rate, it should remain identical. However, due to rounding/truncation, the exchange rate may be subject to small variations and these are not accounted for.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Storing exchange rate and total stATOM issued in hubs state is inecient and complicates the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "a hub eld State contains contracts statom_exchange_rate The in packages/basset/src/hub.rs:28, which is updated in several places throughout the codebase, for example whenever rewards are accumulated. Since rewards are accruing on on an ongoing basis, the stored exchange rate will be almost instantly outdated. To use the correct value, the current implementation updates the stored exchange rate before every usage, including before a query of the State. Consequently, there is little point in storing the statom_exchange_rate in the State in the rst place. Storing unnecessary data is inecient and makes the codebase more complicated. Similarly, the State contains a eld total_statom_issued in line 26. However, this is inecient as it should be equivalent to the supply of stATOM, which is queried within the function call in contracts/lido_cosmos_hub/src/bond.rs:71.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Outdated references to Terra implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "The documentation states that any logic related to the Terra implementation should be marked as an issue. In this informational issue, we list comments and code that references the Terra implementation. - All contracts and packages use version 0.16.0 of cosmwasm-std, which is a legacy version only used on Terra. - Comment in lido_cosmos_validators_registry/src/contrac.rs:156 referencing Terra Core. - Outdated documentation title in contracts/lido_cosmos_hub/README.md:1.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Duplicate check slashing message is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "the in In contracts/lido_cosmos_token_statom/src/handler.rs:51-62, a duplicated slashing message in case the burn sender is not the hub_contract. The second CheckSlashing message does not have any new eect on the state, so it seems unnecessary. message Burn there is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Inaccurate logic conditions in delegation calculation can undermine the eciency of the contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "the in In lido_cosmos_validators_registry/src/common.rs:38, if coins_per_validator + extra_coin is equal to validator.total_delegated, an unnecessary iteration over the loop will be made when bonding or removing a validator. calculate_delegations function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Name and version of stATOM contract are incorrectly set up",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "inherits its instantiate function from cw20-base, The stATOM cw20-compliant contract in calling cw20_init incorrectly lido_cosmos_token_statom/src/contract.rs:41. This function will store the CONTRACT_NAME to crates.io:cw20-base and CONTRACT_VERSION to 0.8.0, instead of crates.io:lido_cosmos_token_statom and 1.0.0 respectively. function the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Remove unused code to improve contract size and readability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "such code Unused in lido_cosmos_hub/src/state.rs:35 increases contract bloat without providing any in functionality. package/basset/src/contract_error.rs:5. MAX_DEFAULT_RANGE_LIMIT ContractError example Another const enum the as is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "20. Marking paused parameter in the Hub as an Option adds unnecessary complexity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "hub contract The in paused packages/basset/src/hub.rs:141, that guardians and the contract owner can use in critical situations to disable most interactions with the contracts. However, the type of paused is Option<bool> instead of just bool, which adds extra unnecessary complexity. parameter dened switch, has a",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "21. Incorrect query function name may negatively aect user and developer experience",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf",
        "body": "function in The contracts/lido_cosmos_hub/src/contract.rs:489 is referencing a dierent storage map UNBOND_HISTORY_MAP which may confuse users and may cause further issues if 3rd party developers query this function. query_unbond_requests_limitation",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Contract creators can update the gas price into invalid integer value in order to disable the wasmxs BeginBlocker execution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "cw-injective:contracts/registry/src/contract.rs:149, In creator can update the gas price to an invalid string. the contract Since gas prices are supposed to be denominated in integer values, this would cause the in ToContractExecutionParams injective-core:injective-chain/modules/wasmx/types/exec_msgs.go:12 7 due to an invalid gas price. message fail to Consequently, the ExecuteContracts functionality in BeginBlocker will always fail due in to the FetchRegisteredContractExecutionList function returning an error injective-core:injective-chain/modules/wasmx/keeper/wasm.go:50. A malicious user can use this behavior to inhibit the BeginBlocker execution of the wasmx module.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Valid positions may be rejected prior the application of PnL",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "the During injective-core:injective-chain/modules/exchange/keeper/wasm_privil eged_action.go, the initial margin requirements of positions are veried twice: It is veried before and after the application of PnL in lines 128 and 139, respectively. synthetic handling trades of in Consequently, if a position does not fulll the initial margin requirement before the application it afterwards, an error is thrown. This implies that valid of position delta but does fulll positions can be rejected.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Governance is not able to eectively remove a contract from registry",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "In injective-core:injective-chain/modules/wasmx/proposal_handler.go:1 3-24 no proposal is dened that allows removal of a contract from the registry. The wasmx module can disable a contract, but the contracts creator could simply re-activate it by interacting with that contract. This implies that a compromised contract, a contract that has been migrated to a malicious code, or one that has lost its reputation, cannot be removed from the registry.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. registry contract and wasmx module are not aware of registered contract migrations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "The ContractRegistrationRequestProposal proposal species a contract address that should be added in the registry. The contract address identies the contract instance, but not its deployed wasm code. In fact, a malicious contract creator could migrate a registered contract to a new wasm binary in order to steal user funds or to execute malicious logic that can impact the entire chain, for example, a high resource computation in the begin_blocker handler.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Integer gas price type allows negative values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "The Int type is used to represent the gas price in the ContractRegistrationRequest struct in injective-core:injective-chain/modules/wasmx/types/wasmx.pb.go. dened As an integer type can hold both positive and negative numbers, a negative gas price would trigger an error during the execution of a wasmxs registered contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Max contract gas limit can be set lower than minimum execution gas limit, causing contract registration to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "In injective-core:injective-chain/modules/wasmx/types/params.go:111-1 there is no validation to ensure the MaxContractGasLimit value is higher than 21, keeper.MinExecutionGasLimit, which represents the minimum gas limit (90396 in injective-core:injective-chain/modules/wasmx/keeper/wasm.go:17). As a result, a misconguration of the maximum contract gas limit to be lower than 90396 would in the injective-core:injective-chain/modules/wasmx/proposal_handler.go:3 0 to always fail, aecting the handleContractRegistration functionality. validation cause",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Too many contracts registered would cause GetContracts and GetActiveContracts query messages to fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "In cw-injective:contracts/registry/src/contract.rs:220 and 237, both to fetch all query_contracts and query_active_contracts messages attempt contracts registered in the storage and return them to the caller. This is problematic because the query could run out of gas in an execution context if too many contracts are stored.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Custom calls between Cosmos SDK modules and CosmWasm contracts require third-party developers to implement their own authorization logic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "The wasmx and exchange modules are performing authorized calls to particular CosmWasm contract handlers using custom logic. In order to do so, Cosmos SDK modules are performing Execute functions from wasm module impersonating the receiver contract. From the CosmWasm side, it is as if the message comes from the contract itself. This means that on the CosmWasm contract, contract developers need to implement custom authorization logic in order to restrict the access of a particular entrypoint only to Injective Cosmos SDK modules. Delegating the authorization of the interaction between modules and smart contracts to third-party developers is risky since they could not implement it in the right way or not implement it at all. Additionally, the workaround to use the receiver contract address to call modules reserved handlers has the side eect that the contract can execute calls that should be reserved to wasmx and exchange modules by itself.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Name validation can be bypassed with whitespace",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "In injective-core:injective-chain/modules/exchange/types/msgs.go:1288, the execution will revert if the data name provided is an empty string. This validation can be bypassed by providing whitespace. Ideally, whitespaces should be prohibited since they are also invalid names.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Consider deduping batch contract addresses in ValidateBasic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "In injective-core:injective-chain/modules/wasmx/types/proposal.go:83, the ValidateBasic function does not lter duplicate contract addresses contained in the ContractRegistrationRequests array. Such duplicate contract addresses would cause in each the injective-core:injective-chain/modules/wasmx/proposal_handler.go:6 0 since the contract is already registered. duplicated execution contract address fail for to",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Outstanding TODO comments present in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "TODO comments were found in the following code lines:  injective-core:injective-chain/modules/wasmx/keeper/wasm.go:1  injective-core:injective-chain/modules/wasmx/keeper/wasm.go:2  injective-core:injective-chain/modules/wasmx/keeper/wasm.go:2  cw-injective:packages/injective-cosmwasm/src/subaccount.rs:12",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. A dev-dependency is vulnerable to two CVEs",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf",
        "body": "plotters The in cw-injective:packages/injective-math/Cargo.toml:27 is vulnerable to two CVEs: dev-dependency dened crate as a  RUSTSEC-2020-0159: chrono  RUSTSEC-2020-0071 - Potential segfault in the time crate",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Claiming allocation will cause proposed receivers previous allocation to be overwritten, leaving funds inaccessible in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "contracts/builder_unlock/src/contract.rs:305-311 the In astroport-governance repository, the proposed receivers allocation is overwritten via PARAMS.save and STATUS.save without they have existing AllocationParams and AllocationStatus. If the proposed receiver decides to claim a new allocation while having an existing allocation, their existing allocations ASTRO token will be stuck in the contract. verifying whether of",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Original receivers that transferred allocation will not be able to receive new allocations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "contracts/builder_unlock/src/contract.rs:303-311 In the astroport-governance repository, if the original receiver had transferred their ownership of allocation to a new receiver, their AllocationParams is removed via PARAMS.remove in line 308. However, their AllocationStatus is not removed via STATUS.remove, which means that the original receiver will have an outdated AllocationStatus but no associated AllocationParams with it. of This is problematic since the original receiver will be unable to receive new allocations due to lines 153-158.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Leftover amount after providing liquidity is not refunded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "the astrozap repository, In contracts/astrozap/src/contract.rs:84 of offer_asset is calculated by using Newton's method. Since the method does not have 100% accuracy (in the referenced white paper, the specic example shows a 0.04% error), it will cause a remainder of tokens to be left in the contract. Moreover, Newtons method does (see not contracts/astrozap/src/math.rs:74). for offer_asset. MAX_ITERATIONS within It convergence can output erroneous guarantee values",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Miscongured schedule duration could cause division by zero error, leaving funds inaccessible",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "contracts/builder_unlock/src/contract.rs:427 In the astroport-governance repository, schedule.duration is used as a denominator to calculate the amount of tokens that can be unlocked between start time and end time. If the value is zero, a division by zero error would occur and will cause the specic allocation to be locked in the contract. of We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. UnlockedTokens query message does not include cliff period during calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "contracts/builder_unlock/src/contract.rs:362-372 In astroport-governance repository, query_tokens_unlocked of the uses tokens that are unlocked compute_unlocked_amount to compute the number of according to the current timestamp. The function does not include the schedules cli period when calculating the withdrawable token amount, this would cause an incorrect amount returned to the caller. An example calculation that includes a cli period can be found in contracts/builder_unlock/src/contract.rs:442-445.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Extra funds sent to AstroZap contract are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "In contracts/astrozap/src/contract.rs:74-79 of the astroport-governance repository, users sent funds are being used in handle_deposits to verify that the funds user claimed to have deposited are actually deposited to the contract. The current implementation does not return an error though if additional native tokens are sent to the contract, leaving them stuck in the contract. We consider this to be a minor issue, since it is caused by a user error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Duplicate accounts creation in xAstro token instantiation would cause inated xAstro total supply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf",
        "body": "In contracts/xastro_token/src/contract.rs:104-108 of the astroport-core repository, duplicate accounts are not veried when creating initial accounts during the contract is passed twice in create_accounts, the accounts balance would be overwritten via BALANCES.save but total_supply would still record the balance amount of both. As a result, xAstro tokens total supply would be inated. the same account address instantiation phase. If We consider this to be a minor issue since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Unbounded loops in the nitro package can lead to a DoS",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/nitro/keeper/msg_server.go:75 and x/nitro/keeper/prover.go:24, the user-provided elds msg.EndSlot and proof.Hash may lead to an unbounded loop or an arbitrarily computationally expensive transaction which can lead to a DoS. This is problematic since the Validate function in x/nitro/keeper/prover.go:24 does not charge gas to the sender of the transaction, making the attack free of charge. It is important to note that both these code paths are called by the SubmitFraudChallenge method in x/nitro/keeper/msg_server.go:56, which is currently not registered on the Router in x/nitro/module.go:107.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Not registered message types prevent users from sending transactions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "MsgContractDepositRent and MsgUnregisterContract are not registered in RegisterInterfaces and RegisterCodec in x/dex/types/codec.go. Hence, the module will not route the messages to an appropriate message server. Thus, users will not be able to send transactions with the aforementioned message types.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. MsgContractDepositRent should set a minimum amount to avoid potential spamming",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/dex/keeper/msgserver/msg_server_contract_deposit_rent.go:12, there is no minimum limit to the amount that can be sent, and there is no gas charged for the operation, by default. This can be a cost-eective attack vector for the protocol, in which multiple transactions are sent with negligible amounts to consume CPU cycles with minimal cost. This may be used to slow down block production or even halt the chain.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Tick sizes are wrongly updated when a newly registered pair already exists",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/dex/keeper/msgserver/msg_server_register_pairs.go:36, any errors returned from the k.AddRegisteredPair function are silently ignored. This implies that the execution will continue even if the creator of a contract is trying to register a pair that already exists. This unhandled error has the unintended consequence that SetPriceTickSizeForPair and SetQuantityTickSizeForPair are called in lines 37-38, updating the current tick sizes of an already existing pair. Since events for that pair are not emitted, this could break any integrations with o-chain components and third-party applications relying on those events.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Processing of MsgPlaceOrders and MsgSend messages in EndBlocker may be exploited to halt the chain if mispriced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "Due to the processing of MsgPlaceOrders and MsgSend messages in the EndBlocker, a user can send transactions with multiple MsgPlaceOrders and MsgSend messages that are successfully included in a block, but then fail during the EndBlocker execution. An attacker may exploit this feature if the computation needed in the EndBlocker is not properly priced in the transaction. If a network has zero or low fees, an attacker could send hundreds of thousands of MsgPlaceOrders and MsgSend messages at comparatively low cost for the computation required which can slow down block production up to the point where the blockchain halts.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Contract claiming is not possible due to a logic error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "if In the ContractDepositRent function, a new owner can claim a contract 0. However, contract.RentBalance x/dex/keeper/msgserver/ msg_server_contract_deposit_rent.go:28, the SendCoins operation is executed from the old creatorAddr, not from msg.Sender. Thus, this function will always fail when called by any address which is not the current owner, rendering the claim functionality unusable. == in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Past minting emissions would never happen if the chain is down on the required release date",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In validates if x/mint/types/minter.go:56, function the date of the block is equal to the scheduledReleaseDate, and gets GetScheduledTokenRelease the executed in the BeginBlock of the epoch module. If the date matches, new mint emissions of the chain token will be performed. However, the function does not consider if the date scheduledReleaseDate is in the past, but the emission of the given epoch has not happened yet. Therefore, in case the Sei chain is down for more than 24 hours, the release of tokens is skipped, altering the emission plan.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Amino codec must be registered to support end users with hardware devices like Ledger",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/dex/types/codec.go:50, Amino should be used to register all interfaces and concrete types for the dex module. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Insucient validation of addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "The address of the creator, as well as the address of the contract in validateCancels the function in x/dex/keeper/msgserver/msg_server_cancel_orders.go are only checked against zero-length and not for validity of the address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. GetContract parse error not handled explicitly",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/dex/keeper/contract.go:37, the method GetContract returns an error either when the contract is not present in the storage, or when the contract is found but cannot be parsed in x/dex/keeper/msgserver/msg_server_register_contract.go:95, 107, and 193 assume that the contract does not exist upon either error and does not handle parsing errors. However, properly. contexts calling the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Fund transfer in EndBlocker goes against best practices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "function sends a transaction using the MsgPlaceOrders message, the When a user in transferFunds x/dex/keeper/msgserver/msg_server_place_orders.go:15 is called to create a DepositInfoEntry with the users fund amount in MemState. The amount is not actually moved from the senders account until the GetDepositSudoMsg function is called in the If a user EndBlock function in x/dex/keeper/abci/end_block_deposit.go:33. sends a transaction with multiple messages of MsgPlaceOrders and MsgSend, the transaction would be successfully included in a block but the deposit might fail during the EndBlocker execution since insucient time. Such asynchronously failing messages can negatively impact the user experience. It is best practice to fail fast by directly transferring funds from a senders account during message execution. After that, the deposit can still be handled in the EndBlock function. funds may be available at that",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Events are not emitted consistently across the application, which may impact the ability of third-party applications to be integrated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "Cosmos events are emitted by applications to notify third-party applications such as block explorers about events that occur on the chain. Not emitting events consistently across the application may impact the ability of these applications to parse the activity that happens in Sei, impacting user and developer experience. The following instances of messages and functionality lack emission of events:  x/epoch/module.go:188  x/dex/keeper/msgserver/msg_server_unregister_contract.go:12",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. ChangeAdmin does not validate that the new admin is dierent from the current one, which may cause errors in contracts and applications relying on this logic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "function ChangeAdmin The in x/tokenfactory/keeper/ msg_server.go:135 permits the admin of a token denom to change its address to a new one. However, there is no check that NewAdmin is dierent from the current one. An event of a change of admin is emitted nonetheless, which may cause unexpected behavior in applications relying on this information. tokenfactory module the in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Ination rate is set to 0%, while the documentation indicates an intended default ination rate of 13%",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/mint/types/minter.go:26, it is stated that the intended default initial ination rate should be 13%. However, in line 21, the initial ination rate is set to sdk.NewDec(0).",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. UnregisterContract should remove associated pairs after the contract is removed to avoid consuming unnecessary disk space on validators",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "is the contract removed in Once in x/dex/keeper/msgserver/msg_server_unregister_contract.go:12, its associated states are not deleted. An attacker can exploit storage by registering contracts, and then unregistering them multiple times. The cost of such an attack is comparatively low as rent is refunded to the contract owner after unregistration. UnregisterContract function the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Inecient implementation of UpdateQuantityTickSize and UpdatePriceTickSize",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "implementation The x/dex/keeper/msgserver/msg_server_update_quantity_tick_size.go:11 iterates through the tick size list, performing validation and then iteration through the same list happens again in SetQuantityTickSizeForPair. A similar implementation is performed to update price tick size. UpdateQuantityTickSize of in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Strict parsing of boolean CLI arguments may degrade user experience",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "In x/dex/client/cli/tx/tx_register_contract.go, the arguments [need the string true, which hook] and [need order matching] only check against degrades the user experience. For example, if a user capitalizes the word, the ag is going to be set to false.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Inecient implementation of CancelOrders",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "The implementation of CancelOrders in x/dex/exchange/cancel_order.go iterates through orderbook.Longs) and cancelOrder(cancel, cancelOrder(cancel, orderbook.Shorts) for each one. This is inecient, since an order is always just in either the long or short orderbook. orders, calling all",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Inecient implementation of PlaceOrders",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf",
        "body": "The implementation of transferFunds within the PlaceOrders function is inecient. In x/dex/keeper/msgserver/msg_server_place_orders.go:25-29, there is a loop validating that the fund amounts are dierent from Nil. However, this iteration is redundant as the same validation is performed in line 38.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Vesting contract allows unlimited allocation by malicious CW20 contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-02 Audit Report - Levana Stage 2 v1.0.pdf",
        "body": "The CW20 receive hook of the vesting contract currently accepts any CW20 token. Therefore, through contracts/levana-vesting/src/contract.rs:74-95, it is possible for an attacker to create unlimited allocations using a malicious CW20 token contract that sets cw20_msg.sender to the protocols admin address. The attacker could subsequently withdraw Levana tokens once the vesting period has expired.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "1. Ethereum events are not correctly conrmed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "Events emitted by the Ethereum smart contracts must reach a certain amount of block conrmations before validators vote to include them on Namada. An event is conrmed if the dierence between the heights of the current block and the block containing the event is greater than or equal to the required amount of conrmations. the PendingEvent::is_confirmed However, in apps/src/lib/node/ledger/ethereum_node/events.rs:206 considers a block conrmed if the required amount of confirmations is greater than or equal to the block height dierence. Thus, there are more block conrmations, the block is considered unconrmed and discarded from further processing. This leads to frozen funds in case of the TransferToNamada event. function if",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Missing replay protection for signatures",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "in the current validators function set are provided in the execution of the Signatures of contracts/contract/Governance.sol:42, upgradeContract upgradeBridgeContract function in contracts/contract/Governance.sol:60 and addContract function in contracts/contract/Governance.sol:77. In all three functions, messageHash gets calculated to validate the given signatures. There is no replay protection for these functions though, which implies that an attacker can use previously provided signatures to again upgrade/update the state of the contract given that the validator set during the signature creation time is the same as the attack time. For example, an attacker may replay a previous upgrade and then execute a message, which may lead to irrecoverable state inconsistencies in the contract.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Bridging tokens from Ethereum to Namada with an invalid amount of receiver addresses will freeze escrowed funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "ERC-20 tokens are transferred from Ethereum to Namada using the transferToNamada function in contracts/Bridge.sol. The appropriate Namada receiver addresses are provided with the function parameter address[] calldata _tos. After transferring the specied tokens to the Bridge contract for escrow, an event TransferToNamada is emitted and processed by Namada validators. However, if the amount of _tos receiver addresses does not match the length of the other parameters _froms and _amounts, the event is discarded. Escrowed ERC-20 tokens for this specic token transfer transaction are locked and the user can not withdraw funds.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Oracle uses an unbounded queue which might lead to out-of-memory issues",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "In apps/src/lib/node/ledger/ethereum_node/oracle.rs:33 in the Oracle struct the sender attribute is of type UnboundedSender. Its unbounded nature might cause an out-of-memory termination of the process in case the reader side of the channel cannot consume events as fast as the producer creates them. There might be a possibility of an attack in which a large number of events on the Ethereum side are crafted with the intention of exhausting the memory of the node.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Incorrect accounting of voting power for Ethereum events",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "In apps/src/lib/node/ledger/shell/vote_extensions/ethereum_events.rs: 186, the voting power for events gets accounted for cumulatively rather than per event to check whether sucient votes are provided for Ethereum events by Namada validators. This allows malicious validators to successfully add invalid events. For example, an event crafted without actually locking funds in the Ethereum smart contract could be used to mint new funds on the Namada chain.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. The minimum number of block conrmations required to bridge ERC20 tokens from Ethereum to Namada is not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "Transferring ERC20 tokens to Namada by using the transferToERC function in the contracts/Bridge.sol contract emits the TransferToNamada event. This event includes the number of block conrmations that must be reached on the Ethereum chain before validators vote to include them on Namada. This number is provided by the function parameter uint256 confirmations and must be at least the protocol-specied minimum initially set to 100. However, this aforementioned invariant is not number of conrmations, enforced in the apps/src/lib/node/ledger/ethereum_node/events.rs:288. As a result, a user can circumvent the protocol-specied minimum number of conrmations, which might be exploited to double-spend funds. RawTransfersToNamada::decode function in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Slashable oense for voting on an unconrmed event is not accounted as misbehavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "slashing applying When in apps/src/lib/node/ledger/shell/mod.rs:525, EvidenceType gets matched with the SlashType. Voting on unconrmed events is considered a slashable oense according to the provided documentation, but it is not accounted for as one of the variants of EvidenceType. This allows validators to vote on unconrmed events. This issue may be abused by malicious validators to double-spend funds. validators",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Validator set update protocol transactions are not validated in the process proposal phase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "Transactions in newly proposed blocks are validated by all validator nodes in the in Shell::process_proposal valid apps/src/lib/node/ledger/shell/process_proposal.rs type transactions. However, contrary to properly validating protocol ProtocolTxType::EthereumEvents, type ProtocolTxType::ValidatorSetUpdate are not currently validated. transactions of transactions ensure to of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Unsafe use of selfdestruct",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "Using selfdestruct in contracts/contract/Bridge.sol:160 is not safe because ERC20 funds would be lost those funds were not withdrawn before executing the selfdestruct function. There is no inherent protection that makes sure all funds are withdrawn from the contract before selfdestruct so there is a risk of human error of misplacing an ERC20 token address within the _tokens param of withdraw function. if",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. The total size in bytes of the transactions in a block proposal can exceed the block byte size limit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "Tendermint expects the application to check whether the size of all transactions exceeds the byte limit RequestPrepareProposal.max_tx_bytes, which by default to 1048576 bytes. If so, the application must remove transactions at the end of the list until the implementation of total byte size is at or below the limit. However, in Shell::prepare_proposal not apps/src/lib/node/ledger/shell/prepare_proposal.rs:48-57 enforce this limit. Therefore, if the transaction byte size limit surpasses the limit, Tendermint will reject the block. the current is set does For more details, see requirement number 2 in Tendermints' formal requirements.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Smart contract hub can upgrade contracts to an already used contract address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "The contracts/Hub.sol contract holds references to the addresses of the latest contract version. Contracts are upgraded to a newer address with the upgradeContract function. However, the current implementation does not verify if the Hub contract already uses the new contract address. Even though there is no immediate security implication, upgrading to an already used contract address should be prevented, similar to how it is implemented in the addContract function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. The minimum number of conrmations needed to trust an Ethereum branch should be set to 100",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "According to the specs, TransferToNamada events may include a custom minimum number of conrmations, which must be at least the protocol-specied minimum number of conrmations to 100. However, MIN_CONFIRMATIONS in apps/src/lib/node/ledger/ethereum_node/oracle.rs:19 is currently set to 50, deviating from the specs. initially but set is",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Less than half of the available wrapped transactions from the mempool are potentially included in a proposal",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "A block proposer anticipates including half of the available wrapped transactions from the mempool in a new block proposal. However, the Shell::build_mempool_txs function in takes apps/src/lib/node/ledger/shell/prepare_proposal.rs:136-148 rst half of the transactions in txs: Vec<Vec<u8>> and then lters the transactions to only include TxType::Wrapper transactions. In case there are non-wrapper transactions in this batch of taken transactions, the block will include less than half of the anticipated wrapped transactions from the mempool.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Include a check to ensure that a transfer is sent only if the slashed_amount is greater than 0",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "In apps/proof_of_stake/src/lib.rs:881 the transfer method is regardless of the amount being slashed. called",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Instance of potential integer overow on arithmetic operations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "the calculating When apps/src/lib/node/ledger/shell/vote_extensions/ethereum_events.rs: 186 there is no check for arithmetic overow. In the event of an overow, events that should be part of ethereum_events::VextDigest will otherwise be ignored. However, this event seems unlikely to ever happen, since the total voting power is greater than the sum of the validator voting powers. validator_voting_power in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Typographical error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf",
        "body": "In TransactionGasExceedededError has a spelling mistake. shared/src/ledger/gas.rs:13, the enum variant",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Late depositors would get the same amount of dividend as early depositors, causing an unfair dividend allocation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "In contracts/core/phaser/src/contract.rs:211, new users that stake their kUST tokens will have their last_dividend_points set to 0. This is problematic since the value of last_dividend_points is used to determine the amount of dividends a user is entitled to claim as seen in contracts/core/phaser/src/util.rs:72-78. This would cause late depositors to claim the same dividend allocation as early depositors, resulting in unfair dividend allocation and possibly insucient funds in the contract. is also issue present in This of contracts/core/vault/src/contract.rs:262. last_accumulated_yield_weight is used to calculate the yield users are entitled to earn in contracts/core/vault/src/cdp.rs:40-53. As above, late depositors would be able to claim more yield than intended. contract value vault Here, the the in",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Malicious users can trick the system into receiving more yield than entitled",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "In contracts/core/vault/src/contract.rs:252-256, existing depositors will have their cdp.total_deposited value increased based on the amount they deposited without allocating the yield beforehand. This is problematic because the yield earned is based on the user's deposited amount as seen in contracts/core/vault/src/cdp.rs:50. Consequently, a malicious user can deposit funds repeatedly into the vault contract and withdraw them after some time to claim more yield than they should have received.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Users are unable to withdraw all funds from vault contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "Users are able to call the Redeem message in order to withdraw UST or aUST from the vault contract. Before that, the users collateral debt position (CDP) is checked to verify the user's position is not undercollateralized. However, users will be unable to withdraw the max available amount of funds since the is_cdp_healthy_after_withdraw function veries that using Decimal256::from_ratio as seen in contracts/core/vault/src/cdp.rs:21. If the user attempts to withdraw all available funds, the value passed would become 0 and eventually cause a division by 0 panic. collateralization users CDP lower than limit the the by is",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Updating users collateral debt position causes loss of yield",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "In contracts/core/vault/src/cdp.rs:29, users cdp.total_credit value is updated when the earned yield is higher than users debt. If the user has an existing cdp.total_credit balance, it would be overwritten due to the latest value being directly set instead of increased along with the existing balance. This would cause a portion of the users earned yield to be stuck in the contract.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Users are unable to withdraw funds once phaser is started",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "the update_account function In contracts/core/phaser/src/util.rs:63, attempts to deduct users entitled dividend from cfg.unclaimed_div value. This value can only be increased when theres an increase in UST allocations as seen in line 54. However, the increased amount comes from cfg.total_div which means the amount will never be enough to deduct users entitled dividend, which will cause an underow error. To illustrate the scenario: 1. Alice stakes user.deposited_synth_tokens cfg.total_deposited_synth_tokens to be 100. kUST via ReceiveMsg::Stake, this would cause and 2. 200 UST is sent via Distribute message which causes cfg.total_deposited_base_tokens and cfg.buffer to be 200. 3. Bob decides to stake 50 kUST which would cause run_phaser to execute. Assuming cfg.phase_period has passed, the contract will enter line 53-54 with cfg.total_div and cfg.unclaimed_div value as 2 (200/100 = 2). 4. At this point, theres a high possibility that no one can withdraw their funds since the phaser is executed. update_account. 5. Alice decides to withdraw her tokens by calling ExecuteMsg::Unstake which will call from dividends_owing function would be 200 (100*2 = 200, see lines 73-75). Since the value of cfg.unclaimed_div is 2 while the owing value is 200, this would cause an underow error in line 63. returned amount owing result, the In This issue also aects other entry points that call update_account function, which are Phase, Stake, and Unstake.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. More synthetic tokens are burned than intended",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "In contracts/core/phaser/src/contract.rs:376, the amount of synthetic tokens burned depends on the balance of user.realized_tokens and not on the currently phased amount. This would cause more synthetic tokens being burned than the intended amount, which opens the possibility that there are not enough synthetic tokens in the phaser contract. As a result, this would cause a loss of funds for the protocol.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Claim message in phaser contract withdraws more UST than the user should own, leading to a loss of funds for other users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "In contracts/core/phaser/src/contract.rs:309-313, when a user decides to claim their phased UST, the contract withdraws the amount in aUST without calculating the exchange rate. Due to the fact that aUST usually trades above UST, this may lead to a withdrawal of a greater amount of UST from the adapter than the user should be able to claim. This causes a loss of funds for the whole protocol.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Anchor exchange rate used might be out of date due to missing block height argument",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf",
        "body": "The Anchor exchange rate is queried from the Anchor contracts, through the utility function epoch_state, in contracts/core/adapters/anchor/src/msg.rs:102-114. However, no block height argument the block height argument, Anchor returns a raw exchange rate from stored values without accruing interest since the last update, which means an outdated exchange rate is returned. Using this value could lead to slightly incorrect calculations. is supplied. Without dened",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Decimal places inconsistency between deposit and withdrawals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "Amounts are interpreted dierently in deposit and withdrawal operations. The underlying token contract uses 18 decimal places. However, deposit and withdrawal requests use 0 and 18 decimal places for the amounts specied. This may lead to confusion for integrators which may cause bugs. In addition, the total amount is limited to 50 digits, whilst the underlying token contract technically allows for 78 digit numbers (in decimal representation). This is unlikely to cause any issue in practice since such large numbers will not occur.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Number of blocks required for deposits to be conrmed is relatively small",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "The smart contract integration conrms events through event ltering transfer events. The constant REQUIRED_NUMBER_OF_BLOCK_CONFIRMATIONS is used to congure a limit of block conrmations that need to have occurred before such a deposit is considered conrmed. By default this is set to 6 block conrmations, This number is relatively small and corresponds to the number of conrmations usually used in Bitcoin. In Ethereum higher numbers are usually recommended, due to the lower block time. Major exchanges require 20 or even 50 blocks.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Ethereum address elds can be longer than required",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "The character limit specied for Ethereum addresses in ethereum/models is 200 characters. However, an Ethereum address expressed as a string in its standard format is 42 characters long (including leading 0x). Whilst this is not a security list, allowing the API to store and receive longer addresses could cause confusion or make the system more error-prone by allowing extra data to be received.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Leaked API keys in source code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "Several les are found to contain API keys and secrets, namely: - - - - .gitlab/gitlab_runner/runner1-cong/cong-template.toml avbox/app/routes.py backend/cong/settings/common.py backend/cong/settings/dev.py Depending on the API key usage and validity, a malicious user can abuse a leaked API key to cause damage to the overall project.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Websocket connection can be initiated by anyone",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "When initiating a WebSocket connection, there is no CSRF protection implemented. A malicious user can start a WebSocket connection and send arbitrary WebSocket messages as the victim. The impact of this issue depends on the implementation of the WebSocket itself. This is unlikely to be exploited since the SameSite Cookies which are set to Lax are preventing it. However, theres still a risk for users that use outdated browsers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. backend/apps/common/zoom/client.py: Meeting duration always calculated as zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "In line 61 the following expression is used to calculate a meeting duration: duration = event.time_slot.end_time - event.time_slot.end_time This will always result in zero.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. backend/apps/pages/views.py: context key INVOICE_STATUS set twice",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf",
        "body": "The eld is set twice (line 157 and line 188).",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Using non-prexed addresses in storage keys can lead to key collisions, allowing exploits to overwrite data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The key returned by the GetTokenizeShareRecordIdByOwnerAndIdKey function in x/staking/types/keys.go contains an address that length prexed. Since addresses could have variable lengths, key collisions are possible if the storage key contains a non-prexed address followed by another component. This could lead to accidental collisions and could be exploited by an attacker to deliberately overwrite existing data at a target storage location. is not",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Tokenization of a delegation and selling the shares allows evasion of slashes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "a is the in no delegation in When tokenized x/staking/keeper/msg_server.go, or Redelegation entry is created, but the current delegation is immediately unbonded and a new delegation the from the module TokenizeShareRecord. This implies that the previous delegator will not be subject to slashing for infractions that happened before the tokenization. Instead, slashes are now applied to the module address associated with the TokenizeShareRecord. UnbondingDelegationEntry TokenizeShares associated with function address created is Since Cosmos SDK applies slashes for past infractions to all currently bonded tokens, this is not an issue, as long as the previous delegator owns the created share tokens. The previous delegator might have an incentive though to sell share tokens quickly if they are aware of a pending slashing event. If there is information asymmetry between the share token holder and a potential buyer, a delegator can use this mechanism to evade slashing. An example of this could be a validator that equivocated but has not published the double-signed block. Rational buyers would therefore not buy any token shares before the UnbondingTime passed but not all buyers can be assumed to be rational. We consider this issue to be major, because it can be used to circumvent one of the fundamental features of proof of stake blockchains.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Withdrawal of tokenized share record rewards is unbounded, owner can be grieved by an attacker",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "WithdrawTokenizeShareRecordReward The in x/distribution/keeper/keeper.go contains an unbounded iteration over all TokenizeShareRecord of an owner, which may run out of gas if too many entries exist. This may happen unintentionally. function Even worse, since it is possible to transfer ownership of a record to any other address, an attacker can create many low-value TokenizeShareRecords and transfer ownership of them to relevant the TokenizeShareRecords to another account to resolve this issue, it allows the attacker to grieve the owner. owner. While transfer owner target target can a The same issue exists in the TokenizeShareRecordReward query function in x/distribution/keeper/grpc_query.go.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Several errors are not checked",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "In several places in the codebase, errors are not checked, and execution continues even if operations failed. This may cause an inconsistent state  a message handler may succeed and write changes to storage even though some operations failed. Instances of not checked errors are in: a) x/distribution/module.go:73: Error return value types.RegisterQueryHandlerClient is not checked b) x/distribution/module.go:146: Error return value cfg.RegisterMigration is not checked c) x/distribution/types/msg.go:183: sdk.AccAddressFromBech32 is not checked Error return value d) x/staking/genesis.go:43: Error return value keeper.SetValidatorByConsAddr is not checked e) x/staking/module.go:79: return types.RegisterQueryHandlerClient is not checked Error value of of of of of f) x/staking/module.go:143: Error return value of cfg.RegisterMigration is not checked g) x/distribution/types/msg.go:183: Error return value sdk.AccAddressFromBech32 is not checked h) x/staking/keeper/msg_server.go:100: k.SetValidatorByConsAddr is not checked i) x/staking/keeper/msg_server.go:457: k.ValidateUnbondAmount is not checked j) x/staking/keeper/msg_server.go:477: k.AddTokenizeShareRecord is not checked k) x/staking/keeper/msg_server.go:550: k.DeleteTokenizeShareRecord is not checked m) x/staking/types/msg.go:380: l) x/staking/keeper/msg_server.go:598: sdk.AccAddressFromBech32 is not checked Error sdk.AccAddressFromBech32 is not checked Error sdk.AccAddressFromBech32 is not checked n) x/staking/types/msg.go:414: Error return value Error return value Error return value Error return value Error return value return value return value of of of of of of of of o) x/staking/types/msg.go:442: Error sdk.AccAddressFromBech32 is not checked return value of p) x/slashing/genesis.go:19: Error return value of keeper.AddPubkey is not checked q) x/slashing/module.go:81: Error return value of types.RegisterQueryHandlerClient is not checked r) x/slashing/module.go:144: Error return value of cfg.RegisterMigration is not checked s) x/slashing/keeper/hooks.go:35: Error return value of k.AddPubkey is not checked t) x/slashing/keeper/hooks.go:69: Error return value of h.k.AfterValidatorCreated is not checked",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Tokenize share record reward query does not include automatically withdrawn rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "TokenizeShareRecordReward The x/distribution/keeper/grpc_query.go does withdrawn rewards that have been sent to the TokenizeShareRecords module account. in automatically query not function account for",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Share token denoms may be all lower- or all upper-cased, depending on user input",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The getShareTokenDenom function in x/staking/keeper/msg_server.go creates the denom for new share tokens through concatenation of the user-supplied validator address and a unique ID. The validator address is taken without transformations from the users input. Since Bech32 addresses are valid in either all upper or all lower case, there can be two valid denoms for the same share tokens. While this has not been found to cause any security issues in the current implementation, it may create problems for applications integrating with this module or lead to issues when further logic is added in the future.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Usage of panics for control ow is bad practice",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "In several places in the codebase, panics are used for control ow. While this is no security issue since transactions recover from panics in Cosmos SDK, this may lead to problems in the future. For example, a caller of keeper functions may try to handle errors, while the function panics instead. Instances of panic usage for control ow can be found in: a) x/distribution/keeper/allocation.go:33 b) x/distribution/keeper/delegation.go:35, 40, 48 and 127 c) x/distribution/keeper/hooks.go:50 and 97 d) x/distribution/keeper/invariants.go:87 e) x/distribution/keeper/keeper.go:38 f) x/distribution/keeper/store.go:51 and 70 g) x/distribution/keeper/validator.go:70, 80 and 92 h) x/distribution/types/keys.go:65, 79, 94, 108, 122 and 136 i) x/distribution/types/msg.go:35, 72, 107 and 146 j) x/slashing/keeper/infractions.go:19 and 25 k) x/slashing/keeper/signing_info.go:109, 121 and 125 l) x/slashing/types/msg.go:28 m) x/staking/keeper/alias_functions.go:68 n) x/staking/keeper/delegation.go:96, 108, 202, 208, 219, 225, 400, 407, 411, 459, 464, 468, 574, 582, 593, 614 and 717 o) x/staking/keeper/invariants.go:63 and 106 p) x/staking/keeper/keeper.go:42, 46 and 67 q) x/staking/keeper/pool.go:23 and 31 r) x/staking/keeper/querier.go:493, 497 and 502 s) x/staking/keeper/query_utils.go:26, 47, 112 and 116 t) x/staking/keeper/slash.go:29, 54, 70, 128, 132, 135, 208, 251, 256, 259, 271, 276, 287, 292 and 296 u) x/staking/keeper/val_state_change.go:30, 41, 45, 67, 71, 75, 139, 165, 233, 241, 249, 258, 267, 278 and 319 v) x/staking/keeper/validator.go:29, 50, 158, 162, 167, 316, 414, 427, 431 and 435 w) x/staking/types/authz.go:44 x) x/staking/types/delegation.go:51, 66, 73, 151 and 246 y) x/staking/types/historical_info.go:33 z) x/staking/types/keys.go:96 aa) x/staking/types/msg.go:75, 80, 179, 236, 290 and 345 bb) cc) x/staking/types/validator.go:154, 262, 276, 381, 396, 400, 426 and 466 x/staking/types/params.go:94",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Addresses are not properly validated, which may cause panics and unexpected behavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "This validation. The ValidateBasic method, in x/distribution/types/msg.go:47, includes basic address the DelegatorAddress or the WithdrawAddress provided is empty, but does not validate whether if msg.DelegatorAddress=' ', this check would not return an error, producing further panics and expected behavior. is a correctly formatted Bech32 string. As an example, validation only and raises the input checks error an if",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Dierent tokens for share records of the same validator can have dierent exchange rates after slashing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The staking module creates distinct TokenizeShareRecords whenever a user tokenizes a delegation. These share records have all unique denoms, and their tokens are not fungible with each other, even if the validator is the same. While this simplies the architecture of the module, it implies that the exchange rate between such records starts to diverge over time, specically when tokens are minted after slashing occured. The reason for this is that during the TokenizeShares function in x/staking/keeper/msg_server.go:454, shares are minted without considering the current exchange rate of previous share records. As an example, suppose 1000 ATOM are delegated, of which 500 ATOM are tokenized in record 1. There exist now 500 val...1 tokens. Now suppose a 10% slash happens, such that there are only 900 ATOM in the delegation, and the 500 val...1 tokens are only worth 450 ATOM. If now another 200 ATOM of the same delegation are tokenized in record 2, there will be 200 val...2 tokens. As a result: - - val...1 tokens have an exchange rate of 0.9 ATOM/val...1, while val...2 tokens have an exchange rate of 1 ATOM/val...2. This is not a direct security concern, but may confuse users and lead to problems if protocols built on top of the Liquidity Staking Cosmos SDK module do not consider these dierences properly.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Staking rewards are decoupled from share token holders",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The current architecture separates holders of a tokenized delegation and the recipient of rewards for that delegation. A holder of share record tokens is not eligible for any rewards, instead these rewards accumulate in one single account per tokenized share record. The reward recipient is specied as the TokenizedShareOwner in the TokenizeShares function. It can be transferred using the TransferTokenizeShareRecord function. While this is not a security concern, it may be unexpected that share record tokens do not contain eligibility for rewards.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Lack of event emission is bad practice",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "TokenizeShares, The TransferTokenizeShareRecord message handlers in x/staking/keeper/msg_server.go do currently not emit any events. The Unjail message handler in x/slashing/keeper/msg_server.go does emit an event, but does not include information about the action (unjailing). RedeemTokens and Emitting events is a best practice, since it allows o-chain subscribers/indexers to track events.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Tokenized share record related transactions and queries are only available via CLI, not REST",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "Transaction and query functionality for tokenized share records have been added to the CLI in x/distribution/client/cli/tx.go, x/distribution/client/cli/query.go, x/staking/client/cli/tx.go and x/staking/client/cli/query.go, but not to the x/distribution/client/rest/tx.go, x/distribution/client/rest/query.go, x/staking/client/rest/tx.go and x/staking/client/rest/query.go. interfaces REST in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Storing the Id in TokenizeShareRecord is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The TokenizeShareRecord contains the Id of the record. That is unnecessary since every lookup of the record implies that the ID is known, since its part of the key.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Storing the ShareTokenDenom in TokenizeShareRecord is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The TokenizeShareRecord contains the ShareTokenDenom of is unnecessary, since the ShareTokenDenom can be derived from the stored Validator and Id. the record. That",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Specication is outdated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The specication is outdated in several ways: a) x/staking/spec/01_state.md is missing an entry for 0x64 for LastTokenizeShareRecordIdKey. b) x/staking/spec/* still describes queues, which have been removeg from the module.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Unused code negatively impacts maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf",
        "body": "The code base contains unused code. Unused code increases the code size and hence inhibits maintainability. Instances of unused code are: a) The NewStakeAuthorization function in x/staking/types/authz.go. b) The AllInvariants function in x/distribution/keeper/invariants.go. c) The AllInvariants function in x/staking/keeper/invariants.go. d) The ValidatePowerReduction function in x/staking/types/params.go.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. parser.go: Incorrect prex comparison in function EthereumEventToEthBridgeClaim()",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf",
        "body": "On line 56, contains defaultEthereumPrefix, but does not actually verify that it starts with it. function EthereumEventToEthBridgeClaim() only checks that symbol",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. x/clp/keeper/Calculations.go: Token decimal adjustment is always executed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf",
        "body": "In functions calcLiquidityFee() and calcSwapResult(), there are checks to see if the number of decimals of external tokens needs to be normalized. However, the actual adjustment code is executed in either case, due to the following incorrect if statement: if adjustExternalToken { if toRowan { X = X.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) x = x.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) } else { Y = Y.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) } } else { if toRowan { X = X.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) x = x.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) Y = Y.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) } else { } }",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Outdated indirect dependency with multiple known security vulnerabilities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf",
        "body": "The codebase uses an outdated version of the ecdt library (versions 3.3.13). This version includes a number of known vulnerabilities, including TLS authentication issues, TCP proxy discovery issues, and missing password length verications.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Consider using a mock address for ETH",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf",
        "body": "In the contracts, for referencing an ETH value transfer the token address is set to 0x0, however, this is already the default value mappings. While there's no security implication as is, a better option would be to choose a mock address for ETH, like 0xeeeee.... to avoid any possible confusion with uninitialized addresses.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Node package inclusion in Solidity les breaks build system",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf",
        "body": "The smart contract course les include OpenZeppelin dependencies imported as npm packages with relative path names. For example: import \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\"; This breaks the functionality of most up-to-date development frameworks, including True used in the project, leading to the project not currently building on a clean installation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Provide formal documentation on why the number 30 Ethereum blocks were chosen as safe enough nality for Sifchain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf",
        "body": "Provide more explicit documentation of the security assumptions that made Sifchain arrive at the fact that 30 blocks are safe nality for the purposes of the Sifchain application",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Missing default case in switch statement",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf",
        "body": "switch The data cmd/ebrelayer/relayer/ethereum.go:158-168 is lacking a default case. always recommended to add default cases for clarity and dealing with unexpected data. processing statement Ethereum event for in is It",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Unbounded dictionary records might cause denial of service",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/PegBridge.cdc:86, the records dictionary is used to record existing minting and burning hash identiers as seen in lines 223 and 263. While recording the identiers on-chain are required to prevent replay attacks, this would cause the accounts If the account doesnt hold enough Flow tokens storage capacity to increase limitlessly. proportional to the increased storage capacity, this would cause new transactions to fail as it would put the account over its storage capacity. This issue is also found in contracts/SafeBox.cdc in lines 149 and 185 where it holds the deposit and withdrawal hash identiers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Adding delay transfer should not be allowed when the contract is paused",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/DelayedTransfer.cdc:73, through the executeDelayXfer function is allowed even if the contract is paused. If a catastrophic adding delay transfers event happens, users may continuously get exploited since new delay transfers can still be added while most other functionalities in the contract are inaccessible.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Public keys are not validated when updating or resetting signers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/cBridge.cdc:36, the passed signers public keys are directly set without verifying whether the public keys are valid and conform to the hardcoded signature algorithm which is ECDSA_secp256k1. If an invalid public key or a public key with a dierent signature algorithm is passed, the public key construction in lines 61 to 64 would fail, potentially in the causing the whole cBridge contract updateSigners function in lines 157-172. to be unusable. This issue is also present We consider this to be a minor issue since it can only be caused by the admin or existing signers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Duplicate public keys are not removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/cBridge.cdc:36, the passed signers public keys are directly set without verifying whether they are duplicates or not. If a public key is twice in the signers dictionary, the signature validation can be replayed and potentially allow the signer to hold more signing power than intended. This issue is also present in the updateSigners function from in lines 157-172. We consider this to be a minor issue since it can only be caused by the admin or existing signers.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing logic validations during struct initialization might cause temporary denial of service",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/PegBridge.cdc:52-53, the TokenCfg structs minBurn and maxBurn values are not validated. Specically, the minimum burn amount should be validated to be lower than the maximum burn amount while the maximum burn amount should be validated to be higher than the minimum burn amount if the value is not 0. If the values are initialized incorrectly, the burn function would fail in lines 255-258. This issue is also found present in contracts/SafeBox.cdc from lines 49-50. We consider this to be a minor issue since it can only be caused by the admin.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Sensitive resources can easily be shared and not revoked",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "Throughout the codebase, every admin resource has a createXAdmin method (where X is a placeholder for the resource) that allows the existing resource to create a new admin resource in contracts/SafeBox.cdc:114-116). Due to this, admin resource ownership can be provided to multiple accounts, which increases the attack surface. Admin permissions cannot be revoked in the current implementation, which exacerbates the issue. assigned account another (e.g. that can be to",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Misconguration of chain identier values might lead to replay attack possibility",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/PegBridge.cdc:190 and contracts/SafeBox.cdc:122, the chain identier values use the chID argument, which is supplied by the contract instantiator. That argument is concatenated with the contracts address and name in the next line. Since the chain identier is solely based on what value the contract instantiator provides, this will open up a replay attack possibility if the same chain identier is used across multiple deployments, for example on mainnet and testnet. As a result, this would cause the domainPrefix value to be the same across the mainnet and testnet contracts (assuming the same contract address and name), potentially allowing an attacker to replay mint and withdrawal operations in contracts/PegBridge.cdc:213-214 and contracts/SafeBox.cdc:172-173. We consider this issue to be minor since it would only occur if the contract instantiator instantiated the chain identiers incorrectly.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Token receiving capability may not exist, which leads to failure of deposits",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/SafeBox.cdc:151, the capability for receiving funds gets accessed. There is no validation though to ensure self.account has the public capability stored at tokenCfg.vaultPub. As a result, the deposit operation would fail every time for the specic whitelisted token.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Delay threshold check should use greater than or equal symbol",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf",
        "body": "In contracts/PegBridge.cdc:229 and contracts/SafeBox.cdc:191, the if statement check uses the greater than symbol > to determine whether the mint or withdrawal amount is required to be delayed. As any amount that reaches the delay threshold should be delayed, the check should include equality of the amounts.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. MsgInstantiateOracle is not registered",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/types/codec.go:18, MsgInstantiateOracle is not registered as a concrete implementation of the sdk.Msg interface. While there are no issues when executing a MsgInstantiate transaction message without the registration, an error will occur if a transaction message contains code that involves marshaling or unmarshalling an unregistered message.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Amino codec must be registered to support end users with hardware devices like Ledger",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/types/codec.go:33, Amino should be used to register all interfaces and concrete types for the icaoracle module. This is necessary for legacy binary and JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Missing GenesisState validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/keeper/genesis.go:11, InitGenesis is missing genesis state validation. Without validation, miscongurations may go unnoticed and might eventually be dicult to correct.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Governance can activate invalid oracles",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/keeper/gov/gov.go:11-13, the ToggleOracle function can be called by governance to enable or disable any oracles. However, no validation ensures that the oracle already has a contract instantiated on the host chain and the channel is still active. Enabling such invalid oracles is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Removing oracles does not remove associated metrics",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/keeper/gov/gov.go:16-24, the RemoveOracle function can be called by governance to remove any oracle as long as it exists in the storage. However, no validation ensures that the metrics associated with the oracles are removed too. If a channel times out and governance removes the oracle, the pending metrics will remain forever in the storage in an IN_PROGRESS state.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Oracles cannot be added again if they have an active channel and are removed through governance",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In stride:x/icaoracle/keeper/gov/gov.go:16-24, the RemoveOracle function can be called by governance to remove any oracle as long as it exists in storage. However, if governance removed OracleChainId while the channel is still active, the chain identier cannot be added back through the AddOracle function. This is due the error occurring in stride:x/icaoracle/keeper/msg_server.go:85 because the channel would still be active. Since interchain account channels cannot be closed manually by users, the oracle for the specic chain id cannot be added back anymore.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. RestoreOracleICA does not ensure that channel is closed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "RestoreOracleICA The in stride:x/icaoracle/keeper/msg_server.go:150 does not explicitly check to ensure that the channel for the requested oracle is closed. If the channel is closed an error should be returned. this function is called for an open channel RegisterInterchainAccount will fail later in the functions execution, but will not return an error that clearly communicates its cause. In the case that function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Duplicated ValidateBasic invocation in CLI",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "CLI commands transaction All stride:x/icaoracle/client/cli/tx.go:19 stride:x/icaoracle/client/cli/gov.go:55 function before calling GenerateOrBroadcastTxCLI. registered in the GetTxCmd function in and msg.ValidateBasic call the As msg.ValidateBasic is already called inside the GenerateOrBroadcastTxCLI function this is a duplicated invocation, which is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Incorrect usage message for GetCmdQueryOracle command",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "usage message in The stride:x/icaoracle/client/cli/query.go:47 is incorrect. The command expects to receive exactly one argument holding the chain id, but the usage message is not describing this. GetCmdQueryOracle command for",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Unused code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "Across the codebase, locations. Unused code decreases the maintainability of the codebase. instances of unused errors and functions exist in the following  ErrMarshalFailure in stride:x/icaoracle/types/error.rs:18  ErrUnmarshalFailure in stride:x/icaoracle/types/error.rs:19  CWTemplateContract in cw-ica-oracle:src/helpers.rs:10-27",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Events are not always emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "There are multiple functions within the scope of this audit that do not emit events or attributes. It is best practice to emit events and attributes to improve the usability of the contracts and to support o-chain event listeners and blockchain indexers. The following functions do not emit events or attributes:  In cw-ica-oracle:src/contract.rs:15, the instantiate function should emit an event containing the admin_address value.  In cw-ica-oracle:src/execute.rs:19, the post_metric function should emit events containing the new_metric and new_price values.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Misleading comments in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf",
        "body": "In cw-ica-oracle:src/state.rs:127, the add function for the History storage state mentions that Old items are removed from the back of the deque when capacity is reached. However, this is incorrect because the old items are actually removed from the front of the deque when the capability is reached, as seen in line 137. in cw-ica-oracle:src/execute.rs:46, Additionally, the comment species that duplicated metrics will not be added to the store while in the current implementation duplicate new metrics silently overwrite existing metrics.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attacker can extract all Sigma tokens from the factory contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "claim_deposit The in contracts/sigma_factory/src/contract.rs:363 allows an attacker to extract all Sigma tokens from the factory contract. Currently, any address with an unlocked deposit can perform this attack. There is no step in the function where entries are removed from CREATOR_TO_UNLOCK and the deposit redemption is not recorded anywhere. function The following is a potential attack scenario: 1. The attacker creates an option",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. The attacker can repeatedly call claim_deposit and will continue to receive config.deposit_amount each transaction until the factory contract has no Sigma tokens left. Recommendation We recommend removing the CREATOR_TO_UNLOCK map entries after they are utilized in claim_deposit. In addition, we recommend storing the amount the user deposited and only returning it rather than returning config.deposit_amount. This amount can be decremented or set to zero after the user has claimed their deposit. Status: Resolved 2. Logic error prevents the redemption of aUST",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Settlement of stage 4 might run out of gas if too many depositing addresses exist",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "In contracts/sigma_vault/src/contract.rs:996-1017, the deposits may run out of gas if the vector has many entries. Many entries might occur if an attacker would create many addresses to prevent the settlement of puts. This would result in the vault no longer being able to settle puts. There is currently no way to recover from this issue. iterations over",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Depositors may receive dierent amount than original deposit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "claim_deposit The in contracts/sigma_factory/src/contract.rs:383 allows the depositor to claim their deposit after it has reached its unlock_timestamp. The deposit is sent back in a CW20 transfer message in lines 379-386. This message amount sends the current config.deposit_amount (an updatable value) to the depositor. This is problematic if the deposit_amount at from the deposit_amount at the time of the claim. the option was created is dierent the time that function The value of deposit_amount is updatable in line 323 by the gov contract or the owner. If this value is changed in the period of time after the option has been created but before the deposit is claimed it will cause the user to receive a dierent amount than they originally deposited when they created the option.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Updatable option conguration parameters may impact the exercisability of options that are in the money",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "The update_config function in contracts/sigma_option/src/contract.rs:122 allows config.owner to update the options parameters. There is currently no safeguard to ensure that these parameters cannot be updated on live options. Allowing for these parameters to be updated is very problematic. For example, if the owner were to change config.call_or_put, it would aect the exercisability of previously minted shares. This could be done accidentally or intentionally. In a situation where the owner is compromised, the attacker could change parameters to ensure that no users can exercise their options. There does not appear to be a reason why the option parameters would need to be updated once they are initially set, and removing this functionality completely would eliminate this possibility completely. The following parameters should not be updatable after they have been originally set:  underlying_asset  denomination  call_or_put  american_or_european  strike_price  expiration_time  exercisable_token  obligation_token",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Excess funds sent while exercising via vault contract will be lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "In both contracts/sigma_vault/src/contract.rs:570 and 582, if the user sends more funds than the exercisable units balance of the vault then they will eectively remain in the contract and not be returned back to the sender. This may result in the caller receiving less value than they have sent to the vault contract. In lines 570 and 582 there are validations to ensure that the units_sent or funds_sent are less than exercisable_units, and it will return an error if the funds are insucient. This check does not account for a situation where the caller sends funds in excess of the amount of exercisable_units. After this step, the function uses exercisable_units directly in all of the remaining messages and calculations and disregards the actual amount sent by the caller. This will result in the excess funds remaining in the vault contract and the caller will receive less value than they sent.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Missing tax deductions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See https://agora.terra.money/t/proposal-to-reduce-the-terra-tax-rate-to-zero/3524 for more detail around the tax rate discussion.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. treasury_take, percent and fee should be validated to ensure they fall within an expected range of values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "In multiple occurrences values are set or updated without validations to ensure that they fall within an expected range. These are: 1. config.treasury_take in the update_config function and the instantiate function in contracts/sigma_collector/src/contract.rs:155. 2. percent in the ExecuteMsg::Convert handling in contracts/sigma_collector/src/contract.rs:84. 3. config.fee in the update_config function and the instantiate function in contracts/sigma_factory/src/contract.rs:338 and contracts/sigma_factory/src/contract.rs:49, a misconguration could cause an error in contracts/sigma_option/src/contract.rs:574.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Miscongured distribution schedule cong can cause panics in LP staking contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "a In contracts/sigma_lp_staking/src/contract.rs:35 distribution_schedule may be stored with a start time that is greater than the end time. This would cause contracts/sigma_lp_staking/src/contract.rs:331 to panic. For informational purposes, we also highlight that it is possible to supply a schedule with gaps and overlaps. Such gaps and overlaps do not cause errors, but might not be intended.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Subtraction may cause wrap around underow",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "are multiple There in instances contracts/sigma_xsig_reward/src/xsig.rs that may cause an underow if not handled properly. It is best practice to perform checked subtraction to return None or to use saturating subtraction to keep the result at the numeric bounds, rather than wrapping around during an underow. subtractions of This is important because Rust behaves dierently in debug mode and release mode. In debug mode, Rust adds built-in checks for overow/underow and panics when an overow/underow occurs at runtime. However, in release or optimization mode, Rust silently ignores this behavior by default and computes twos complement wrapping. The following are occurrences of unchecked subtraction:  contracts/sigma_xsig_reward/src/xsig.rs:30  contracts/sigma_xsig_reward/src/xsig.rs:31  contracts/sigma_xsig_reward/src/xsig.rs:32  contracts/sigma_xsig_reward/src/xsig.rs:68  contracts/sigma_xsig_reward/src/xsig.rs:69",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Extra funds sent may be lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "There are multiple instances in the contracts where native funds are improperly handled which may lead to a loss of funds. The current implementation does not account for a situation where the caller sends multiple funds. info.funds is a vector of Coin, but the current implementation only accounts for the specic denom used by the contract. It is best practice to provide an error if funds are sent that the contract does not handle. The following are instances of where funds are handled in this manner:  contracts/sigma_option/src/contract.rs:319  contracts/sigma_option/src/contract.rs:358  contracts/sigma_vault/src/contract.rs:563  contracts/sigma_vault/src/contract.rs:576  contracts/sigma_vault/src/contract.rs:1309  contracts/sigma_vault/src/contract.rs:1379  contracts/sigma_vault/src/contract.rs:1386",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. distribute function allows collector to send any asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "The distribute function in contracts/sigma_collector/src/contract.rs:205 allows the caller to specify any asset while this function appears to be intended to only handle Sig distributions. This can be problematic if the caller species an asset that is not Sig.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. CREATOR_TO_UNLOCK may cause an out of gas error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "The CREATOR_TO_UNLOCK maps elements are never removed in the factory contract. This may cause an out of gas error in query_deposits. It is best practice to delete map entries once they have been used and are no longer necessary and also to limit the maximum number of entries to a map.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Iterations over several maps may cause out of gas errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "Iterations over several maps that are used in the factory contract might run out of gas and cause errors. These are: 1. tickers_by_option_info in contracts/sigma_factory/src/contract.rs:447 2. expiries_by_option_info in contracts/sigma_factory/src/contract.rs:465 3. strikes_by_option_info in contracts/sigma_factory/src/contract.rs:484 Out of gas errors can happen because those maps are unbounded. Since the initial amount of options is limited by the maximum expiry of three years it will not happen at launch and therefore this is only a minor issue. However, as options accumulate over the years this might become a serious problem for the protocol.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Oracles for low liquidity assets might be prone to manipulation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "Traditional options with physical delivery do not require to be in the money to be exercised. In some cases, settling an option out of the money or near the money can be economically benecial  e.g. if an equivalent order would have a large price impact on the markets. The use of oracles makes sure that options are not executed at a loss. However, if the oracle price is manipulated the oracle can stop users from executing options in the money.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Canonical address transformations are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "Usage of canonical addresses for storage is no longer recommended as a best practice. The reason is that canonical addresses are no longer stored in a canonical format, so the transformation just adds overhead without much benet. Additionally, the codebase is more complicated with address transformations.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Unnecessary use of less than or equal to",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf",
        "body": "receive_cw20 in The contracts/sigma_xsig_reward/src/contract.rs:126 checks if the amount sent is less than or equal to zero. This can be changed to check only if the amount is equal to zero before returning the error. function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Non-deterministic iterations can cause consensus failures",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "In several instances of the codebase, iterations are done over maps. Since Go map iterations are non-deterministic, this would cause each validator to produce a dierent app hash, causing a consensus failure and potentially leading to a chain halt. Aected code lines:  x/stakeibc/keeper/unbonding_records.go:101-109 and 147-152  x/stakeibc/keeper/msg_server_rebalance_validators.go:61-63  app/app.go:762 and 849  cmd/strided/root.go:349 This issue has independently been detected by the client during the audit, but it is still present in the commit hash that was used for the audit.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. GetHostZoneFromHostDenom incorrectly uppercases user input, which can be used to mint invalid assets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "x/stakeibc/keeper/host_zone.go:57, In the GetHostZoneFromHostDenom keeper function automatically uppercases the denom argument in line 59 and compares it against the zones denom which is also uppercased in line 61. As the denom argument is mostly supplied by the user, this would cause an unintended validation bypass. the users input msg.HostDenom is passed as the denom argument to For example, in GetHostZoneFromHostDenom x/stakeibc/keeper/msg_server_liquid_stake.go:22 when the user wants to liquid stake. A user can provide a mixed case argument such as \"aToM\" which will be validated as \"ATOM\" due to the automatic uppercase handling. As a result, the user can mint invalid stAssets such as \"staToM, which is incorrect and not accepted when redeeming the staked assets via RedeemStake.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Computationally heavy operations in BeginBlocker may slow down or stop block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "BeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. There are two modules within the scope of this audit where the BeginBlocker or EndBlocker contains unbounded loops that can slow or even halt the chain. Both the interchainquery and epochs modules BeginBlocker or EndBlocker functions: contain resource intensive  x/interchainquery/keeper/abci.go:18  x/epochs/keeper/abci.go:14",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. RegisterHostZone does not validate Bech32Prefix which will lead to staked funds being unredeemable if miscongured",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "function RegisterHostZone in The lacking x/stakeibc/keeper/msg_server_register_host_zone.go:15 validations to ensure the msg.Bech32Prefix is valid and not empty. This functionality is the ValidateBasic function for neither performed in RegisterHostZone nor the eld is empty MsgRegisterHostZone. This MsgRedeemStake will error and block all that specic zone since AccAddressFromBech32 will return an error if hostZone.Bech32Prefix is empty. There is no way to update this eld or a hostzone so any funds that get staked to a hostzone will not be redeemable. is a critical check because if redemptions for is We classify this issue as major instead of critical, since only the admins can cause it. Still, it leads to permanently locked funds, that would require a chain upgrade to be resolved. This issue has independently been detected by the client during the audit, but it is still present in the commit hash that was used for the audit.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. RegisterHostZone does not ensure that HostDenom and IbcDenom are unique which may introduce conicts when returning a hostzone from these values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "function RegisterHostZone in The lacking x/stakeibc/keeper/msg_server_register_host_zone.go:15 validations to ensure the hostzone being registered does not contain duplicate elds with existing hostzones. For example, if msg.HostDenom is the same as an existing hostzone it will eectively invalidate any guarantee that GetHostZoneFromHostDenom provides. GetHostZoneFromHostDenom is used in multiple locations to derive the hostzone from a denom passed in so msg.HostDenom should be unique throughout all hostzones. This is the same case with msg.IbcDenom and GetHostZoneFromIBCDenom. is We classify this issue as major instead of critical, since only the admins can cause it. Still, it leads to permanently locked funds, that would require a chain upgrade to be resolved.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Hard-coded admins increase the potential of unauthorized privileged activity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "In utils/utils.go:17-21, a hardcoded slice ADMINS is dened to represent the addresses that may perform a privileged activity. This is problematic because it creates a the admins is situation where it compromised. For example, one of the addresses is labeled as a testnet address which likely has private keys that have been shared amongst the development team. If this address were to remain in ADMINS it would present a serious risk to Stride as the address could perform multiple privileged actions. to control access and respond if one of is dicult",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. OnTimeoutPacket method not implemented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "In x/stakeibc/module_ibc.go:143, OnTimeoutPacket is not implemented and will panic on any timeout. Operations involving token transfers and burns could potentially lead to a state in which a chain updates the state as based on a successful transfer, but ignores the timeout. This can cause balances that arent synchronized between chains, which can ultimately lead to users not being able to redeem their tokens successfully, or even being able to redeem more than what they should.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Misconguring CurrentEpoch and CurrentEpochStartHeight during genesis initialization would cause overow issues",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "In x/epochs/types/genesis.go:51, the genesis initialization parameters are validated via the Validate function to prevent incorrect congurations. There are no validations that verify the value of CurrentEpoch and CurrentEpochStartHeight to not be negative values though. it would cause unintended consequences when converting them into unsigned values using the uint64 function. For example, the epoch number in x/stakeibc/keeper/hooks.go:36 would underow and become a tremendously large value, which is incorrect. they are congured as negative values, If",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Participation rewards congured can be negative",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf",
        "body": "In x/mint/types/params.go:177-191, there is no validation that makes sure the participation rewards decimal value is not a negative value. The participation rewards value is used in x/mint/keeper/keeper.go:163 when distributing the minted coins via the DistributeMintedCoin keeper function. A miscongured participation rewards value would cause the execution to panic in x/mint/keeper/keeper.go:135 due to a negative coin amount. As a result, hooks that should be executed after an epoch ends (see x/mint/keeper/hooks.go:16) would keep failing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Lack of deadline parameter exposes user to risk of price volatility",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf",
        "body": "The deadline parameter for the ExactInputSingleParams call to the Uniswap router is set to block.timestamp. This means that no deadline is set, implying that depending on gas provided by the frontend and network congestion, a long time might pass before the swap is executed, exposing the user to the risk of price changes. This is mitigated by carefully choosing the amountOutMinimum. However, for the given use case of the contract acting as a simple wrapper for o-chain code, passing on a front-end dened deadline value can help to protect users from misconguring this value.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Version pragma allows for versions with security vulnerabilities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf",
        "body": "The codebase allows any Solidity compiler version from 0.8 to less than 0.9. A number of important compiler bugs have recently been xed. In particular, version 0.8.4 xed important security issues.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "3. Outdated comment",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf",
        "body": "The comment in line 26 and 27 does not correspond to the current implementation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Contract does not implement slippage control",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf",
        "body": "The contract is designed to accept an amountOutMin parameter that may be calculated o-chain and passed to the contract. While not a security concern, this architecture puts the responsibility of correct parameter choices on the frontend/user.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Pending TODO comment indicates that a function is not needed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf",
        "body": "The decimal2decimal256 function was moved out of into packages/astroport/src/lib.rs:72-78, where a TODO comment was included the function was no longer necessary. Keeping unused code reduces stating that maintainability. the pair contract",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. Inconsistent usage of query_pools function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf",
        "body": "instances of the pair contract, the In several lines query_pools contracts/pair/src/contract.rs:334 and 633 use &env.contract.address, while lines 778, 940, and 989 use &config.pair_info.contract_addr. the contract_addr argument example, inconsistently. function used For for is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "3. Factory address cannot be queried",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf",
        "body": "the query_config function In contracts/pair/src/contract.rs:1064-1073, does not include config.factory_addr in the ConfigResponse struct. Consequently, users cannot query the factory address from the pair contracts queries.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Misleading owner during cong query",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf",
        "body": "The owner value is set to None in contracts/pair/src/contract.rs:1071. Users may interpret this as the contract not being subject to any updates, as no contract owner exists. call XYKPoolUpdateParams::EnableAssetBalancesTracking, which enables asset tracking in the pool. misleading though, factory owner This can the as is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Randomness precompile does not charge gas for external call processing",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "get_randomness The in builtin_actors/actors/evm/src/interpreter/precompiles.rs:346, which is callable from the FEVM, does not account for gas for the entire process. precompile dened In ref_fvm/fvm/src/gas/price_list.rs:684, gas is only charged for hashing and the precompile call but not for the random value generation process. Since this function can be invoked by any contract in FEVM, an attacker is able to create a contract that intensively calls this precompile in order to use computational resources without being charged appropriate gas. This could lead to overloading nodes in the network, up to the point where block production slows down or even stops due to timeouts being reached.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Actor installation is not charging gas on wasm preload error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "In ref-fvm/fvm/src/kernel/default.rs:906, charging gas after the engine preload operations. the install_actor function is This implies that if the engine fails to set up the wasm engine and bytecode, it will return an error interrupting the execution without calling the on_install_actor function, which is responsible for charging gas. An attacker could take advantage of this by loading an invalid serialized wasm le that consumes computational resources and then returns an error in the preload operations paying no additional gas.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. No gas is charged for event emission and storage",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "In fvm/src/gas/price_list.rs:274-281, the gas cost for event-related operations is zero. This implies that no additional gas cost is charged to actors that emit events, including FEVM. Additionally, during the execute_message function, the commit_events function, dened in fvm/src/machine/default.rs, performs an unbounded loop through all the provided StampedEvents in order to store them one by one in an Array Mapped Trie without accounting for gas. Since no gas is charged for event emission and storage, an attacker could leverage this behavior in order to consume computational resources without paying additional gas. This can be exploited to slow down block production or even halt the chain.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. difficulty opcode is not following the EVM specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "As per the legacy EVM specication, the DIFFICULTY opcode returns the current block diculty. After the introduction of EIP-4399, this opcode behavior changed slightly in order to return an RNG beacon following the RANDAO specication. The current FEVM implementation of the DIFFICULTY opcode always returns zero. This implies that smart contracts using this functionality could suer unexpected behaviors.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Storage opcodes do not follow EIP-2929",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "In the EVM Berlin fork, EIP-2929 got introduced, which is not implemented in current storage opcodes in the FEVM. Because of that, the FEVM implementation diverts from the gas handling of the EVM.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Maximum stack size can be exceeded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "Prior to executing an opcode, the stack size is checked by calling the Stack::ensure function in builtin-actors/actors/evm/src/interpreter/stack.rs. the current stack size is insucient, the stack size is doubled, possibly increasing the stack size beyond STACK_SIZE. If If the Stack::ensure function is called again as part of executing the next opcode, and the required size is less or equal to the current stack size, it will consider the stack size sucient without checking the size limit. This leads to the stack size being increased beyond the intended limit of 1024 to a maximum stack size of 2048.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Deviating from the EVM, retrieving the code for non-existing accounts reverts the transaction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "the The opcodes EXTCODESIZE, EXTCODECOPY, and EXTCODEHASH retrieve the bytecode by calling in get_evm_bytecode_cid builtin-actors/actors/evm/src/interpreter/instructions/ext.rs. However, non-existent account, leading to the transaction being reverted. this function returns an unhandled error in case the address belongs to a function On the contrary, the EVM returns 0 for EXTCODESIZE, and the keccak256 hash of empty data (0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470) for EXTCODEHASH if the target address is a non-existent account.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Opcode gas accounting deviating from the Ethereum EVM specication could lead to unexpected behavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "Due to the dierent gas accounting, contracts developed for the EVM might experience compatibility and portability issues when deployed to the FEVM. Commonly, code is optimized regarding gas cost, but since the FEVMs gas accounting is dierent, the same contract executing on the EVM might run out of gas on FEVM or vice versa. Please nd below a few concrete examples of issues caused by the diverging gas accounting: 1. In the following example, the store function is executable on Ethereum and Binance Smart Chain with num = 50_000, while not executable on the FEVM. It runs out of gas if num >= 45_000. uint256 number; function store(uint256 num) public { for(uint256 i = 0; i<num; i++){ number = i; } } 2. If a contract contains a call instruction with an explicitly provided gas limit via {gas:value}, it may not be portable from the EVM to the FEVM. The optionally dened gas limit for the call instruction has to account for all the internal FVM operations (e.g., system.send handling), making it complex for developers to guess the correct amount of gas limit to provide. An example is provided in Appendix 1. 3. Ethereum smart contract developers usually optimize the code and the build process to minimize gas costs for the user. enables that solc https://docs.soliditylang.org/en/v0.8.17/internals/optimizer.html. optimizations dierent types of rely on opcodes Using the --optimize-runs compiler ag optimizes the gas cost of contracts designed to be deployed once and executed multiple times or if they are children of a factory contract. Also, some common patterns exist to optimize the code to use cheaper opcodes. For example, using SSTORE to store zeros in the EVM is cheaper than other numbers. All of these types of optimizations are not eective in the FEVM and could lead to portability issues. An example of how optimizations aect gas usage in FEVM is provided in Appendix 2.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. assert instruction does not consume all the remaining gas as dened in the EVM specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "As per the EVM specication, the assert instruction should consume all the remaining available gas by executing the 0xFE INVALID opcode. However, the FEVM implementation returns error code 33 without charging the remaining gas.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. The bitwise SAR opcode returns 1 instead of 0 if shift is greater than or equal to 256",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "to 256 for The EVM specication states that the SAR opcode should return 0 if shift is greater than or the FEVM implementation in equal builtin-actors/actors/evm/src/interpreter/instructions/bitwise.rs: 43 for the SAR opcode returns U256::ONE (i.e. 1) instead of 0 in this case. This can lead to incorrect results for the SAR opcode. 0. However, a value >=",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "11. LOG opcodes do not revert in case of a STATICCALL",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "According to the EVM specication, executing LOG opcodes is not allowed in a read-only STATICCALL and should revert in this case. However, the FEVM log function implementing the in does builtin-actors/actors/evm/src/interpreter/instructions/log.rs not check if the current call is a staticcall. opcodes LOG",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "12. block.coinbase is not following the EVM specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "According to the EVM specication, the block.coinbase instruction should return the miner of the current block. In contrast, in the FEVM, a zero value is returned. This implies that all the smart contracts that use this information, for example, as a source of entropy, will not work as intended. Examples of usages of this instruction on open source projects can be found with this GitHub query, resulting in around 24K results.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "13. FEVM gas consumption could saturate the available gas in a block and slow down the processing of core Filecoin operations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "The FEVM gas consumption is generally higher than that of other core Filecoin network transactions. For example, a FIL transfer performed through FEVM costs 1.651.058 gas, while the same operation costs 489.268 with a base Send transaction. Since FEVM-related gas fees are on a dierent numeric magnitude than base operations, this could lead to a situation where FEVM transactions could saturate the block, leaving little room for core Filecoin operations.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "14. The CREATE2 opcode smart contract generation is not supported by FEVM",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "The FEVM does not support smart contract creation using the CREATE2 opcode, while the EVM does. This behavior breaks the compatibility of smart contracts expected to work in the FEVM. A sample smart contract used for testing is available in Appendix 3. The functions create2NewToken and deploy in the provided smart contract revert when executed with the following error: { \"code\": 1, \"message\": \"message execution failed: exit 33, reason: message failed   with backtrace:\\n00: f01306 (method 2) -- contract reverted (33)\\n01: f010 (method 3) -- Serialization error for Cbor protocol: Mismatch { expect_major: 2, byte: 152 } (21)\\n (RetCode=33)\" } As a reference, the same smart contract can be successfully deployed with the CREATE2 opcode on the Goerli network: https://goerli.etherscan.io/tx/0x60150e92677fc2738571222de5a0c107780c131a38f87a493f2 58a56444f93",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "15. FEVM allows funds to be sent to a contract without the need for a receive or fallback method",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "Using the send and transfer functions on the FEVM, a contract can receive funds even without having a fallback or receive function. In contrast, the EVM specication requires that a smart contract cannot receive payments if it lacks a receive or fallback function. Breaking this assumption may result in unexpected behavior, including potentially lost funds. A sample smart contract used for testing is available in Appendix 4.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "16. After SELFDESTRUCT, FEVM does not follow the EVM specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "In the EVM, when a smart contract executes the SELFDESTRUCT opcode, it thereafter operates as an EOA, which means that its code is erased while it continues to receive payments. However, the funds are no longer available since smart contracts do not have explicit private keys. the FEVM, after executing SELFDESTRUCT on a smart contract, payments can no longer be received, and the error actor doesn't exist is returned. implementation of In the present This behavior of FEVM deviates from the EVM, which may cause problems when migrating EVM-based smart contracts directly to FEVM. A sample smart contract used for testing is available in Appendix 5.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "17. DELEGATECALL does not propagate msg.value to the implementation contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "As per the specication of the DELEGATECALL opcode, the execution context should be the same as the caller contract, which implies that the msg.value and msg.sender values should be the same in the implementation contract, and the implementation contract can utilize those values during execution. However, the FEVM implementation of DELEGATECALL does not propagate the msg.value of the caller context during the delegatecall, since in msg.value builtin-actors/actors/evm/src/interpreter/instructions/call.rs:148. This reduces the portability of EVM contracts to the FEVM and may even lead to unexpected these behavior with potentially catastrophic consequences if divergences in behavior. teams are unaware of U256::zero() passed as is A sample smart contract used for testing is available in Appendix 6.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "18. Diverging behavior of gas refunds during SELFDESTRUCT between EVM and FEVM",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "According to the EVM specication, the SELFDESTRUCT opcode refunds 24000 gas units. The accumulated refund can not exceed half of the gas used for the current context, while a gas refund is provided only once at the end of the transaction's execution. In contrast, the FEVM refunds gas upon SELFDESTRUCT during the the transaction in ref-fvm/fvm/src/kernel/default.rs:180. That implies that the execution can use refunded gas, which may lead to unexpected behavior when porting smart contracts from the EVM to the FEVM. execution of",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "19. Retrieving the code of precompile addresses reverts, which diverges from the EVM specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf",
        "body": "In the FEVM, the opcodes EXTCODESIZE, EXTCODECOPY, and EXTCODEHASH revert if the target address is a precompile. Given that the FEVM considers all addresses in the range between 0x0 and 0xffff as precompiles, the aforementioned opcodes revert for those addresses See builtin-actors/actors/evm/src/interpreter/instructions/ext.rs:59. precompiles. even they are not if On the contrary, the EVM returns 0 for EXTCODESIZE and the keccak256 hash of empty data (0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470) for EXTCODEHASH if the target address is a precompile.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Deactivated market assets would cause forced liquidation on borrowers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "In mars-red-bank/src/account.rs:61, the function get_user_position is used internally to calculate the borrowers debt, average liquidation threshold and most importantly the health factor which determines whether the borrower can be liquidated. The function iterates over all assets in that the borrower has a position, without accounting in the markets active state. If a market is deactivated, borrowers will be unable to perform any actions on it including repaying their loans. the market asset This would cause problems if the borrower is borrowing had been deactivated by the contract owner. The debt of the inactive market would still be included when calculating the overall health factor for the borrower. Although the deactivated market asset prevents liquidation attempts, a liquidator can still bypass it by liquidating other active collateral assets. Hence, the borrower would be subjected to forced liquidation due to the inability to repay their loans.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Staking xMars rewards can be sandwiched by an attacker, skimming its value before accruing to stakers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "Protocol rewards can be swapped and transferred by anyone to the Staking contract. A combination of public messages executed in one transaction can be leveraged by an attacker to skim the rewards of xMars stakers as shown below: 1. Withdraw Mars rewards (or ma_mars) using mars-protocol-rewards-collector/src/contract.rs:187. execute_withdraw_from_red_bank from the Red Bank to the Protocol Collector in 2. Sell assets if you have Mars/maMars inventory",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. Sell MARS bought in step 4. This can be also exploited with rewards denominated in assets other than Mars, but the severity of this performed on Mars rewards is greater due to steps 6 and 7. Recommendation We recommend either rate-limiting/restricting the access of these public functions, or allowing the Protocol Rewards Collector to send rewards directly in the denomination they are withdrawn from the Red Bank, and swapping them back to Mars on the Staking contract without the intermediate swap to UST. Status: Acknowledged The Mars team is working on ideas to solve this on future versions of the protocol that the community could adopt. In the meantime, the community would have to evaluate the risk of adding Mars as a borrowable asset to the money market. At rst most fees will be collected in uusd which would only be swapped to Mars in the case of staking which would make the window for this attack small. 3. Malicious smart contracts can avoid liquidation attempts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. Initializing vesting contract wrongly would cause inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "In the Vesting contract, congurations such as unlock_start_time, unlock_cliff and unlock_duration are congured during contract initialization. There are no validations in place to verify submitted values are correct, eg. unlock_start_time must be a timestamp in the future instead of the past.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Duplicate accounts creation would cause inconsistent total supply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "In the xMars token contract, accounts are created via create_accounts during contract initialization. As shown in contracts/mars-xmars-token/src/contract.rs:53-62, the function loops through a set of accounts without verifying possible duplications. If the accounts contain any repeated address, the previous balance would be overwritten but the total_supply would increase, creating a discrepancy between the two.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Sent tokens other than denoms are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "are then In the Red Bank contract, users can deposit native assets via DepositNative message. The coins called get_denom_amount_from_coins. The function does not limit user sent funds to exactly one type of funds. If the user sent two types of funds (eg. LUNA and UST), the other assets which are not denom would be lost in the contract. function internal parsed which from an is",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Expiration can be set to past timestamp and block height",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf",
        "body": "In the Ma-token contract, IncreaseAllowance and DecreaseAllowance allow specifying an Expiration via block height or block timestamp. The specication does not verify whether the supplied Expiration value is higher than the current timestamp or block height. Users may set the expiration value to a past timestamp or block height, which causes the approval to fail.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Saving an invalid LastResultsHash and AppHash when performing a hard rollback",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "Hard rollback deletes the block and the app states to recover an incorrect application state In internal/state/rollback.go:117, when removeBlock is true, the transition. in the block latest internal/state/rollback.go:110-111, latestBlock is used to store both LastResultsHash and AppHash in rolledBackState where it should use rollbackBlock when performing a hard rollback. However, removed store. block from is",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Missing error handling for setProposal might cause unwanted state to be ushed to disk and invalid proposals to be included in a block",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "In internal/consensus/state.go:1037.go, there is a call to method setProposal which returns an error. However, this error is not immediately handled, which might cause the proposal to be ushed to disk and created even when an error occurred. One of the reasons why setProposal may return a non-nil error upon an invalid proposal signature as depicted in internal/consensus/state.go:2333. In that case, a proposal that has been signed by a wrong signature gets added to a block, even though it should have been discarded.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Remove unused les and code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "Across the codebase, various instances of unused les and code have been found.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Use of deprecated function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "The abci/client/grpc_client.go:60. deprecated function grpc.WithInsecure is used in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "5. Redundant use of span closing statements is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "In the finalizeCommit method in internal/consensus/state.go:2148, the storeBlockSpan is closed. However, this operation is redundant as in line 2141 there is a deferred statement already closing the same span. Redundant code can make the code more complex or inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Missing validation might lead to dangling pointer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf",
        "body": "In the OnStart method in internal/mempool/reactor.go:98, the channel eld from the Reactor type is not checked against the nil value. This can cause a dangling pointer, and the main thread to crash. This is not a security concern in the current implementation, since upon node creation in node/node.go:274 the mempool reactor is initialized and the channel is created by passing a callback SetChannel to method AddChDescToBeAdded. Nevertheless, the fact that the mempool constructor initializes the channel as nil, and there is no further validation could potentially cause an issue in the future.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attackers can drain funds from contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:245, the execute_set_recipient function sets the escrow status to EscrowStatus::Active even if the escrow is already completed and its funds were transferred. This allows an attacker to reactivate completed escrows to drain funds from the contract by executing SetRecipient and Approve messages repeatedly. Additionally, since in src/commands.rs:610 the function send_tokens returns an empty vector when the balance is empty, even if the receiver did not deposit funds, the sender can still perform the attack draining funds from the contract. Please see the steal_funds test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Malicious arbiters can steal funds by overwriting the recipient address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:408-415, an arbiter needs to approve the escrow before processing the trade. A malicious arbiter can execute the SetRecipient message to overwrite the recipient address to another one under its control and then call the Approve message to steal the original recipients funds. Please see the arbiter_steal_funds test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Funds are locked if the recipient has deposited and the arbiter does not approve the escrow before the deadline",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:408-415, the arbiter is required to approve the escrow to process the trade if it is created providing an arbiter and recipient. If the arbiter does not approve the escrow before the deadline, funds will be stuck in the contract. In fact, both Approve and Refund messages will revert respectively with Expired and RecipientAlreadyDeposited contract errors. Due to the impossibility of the arbiter rejecting an escrow and refunding both parties, this issue is likely to happen when the arbiter opposes the trade. Please see the funds_stuck_arbiter_after_deadline test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Escrows can be completed without recipients interaction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:255, the execute_approve function does not verify the recipients balance is not empty when processing the trade, allowing the trade to be completed without any deposits from the recipient. This is problematic because the recipient could collude with the arbiter to approve the escrow and steal the creators funds. Consequently, the creators funds will be sent to the recipient, while the creator receives nothing in return. Please see the approve_without_deposit test case to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Escrow and vesting end times should be enforced to be in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "During the execution of Create messages, in both src/commands.rs:126-129 and src/commands.rs:196, the vesting_end_time and end_time timestamps are not validated to be in the future. This could lead to scenarios where the newly created escrow is already expired, or the vested tokens are immediately redeemable.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Division by zero error if creator or receiver fee percentage is set to zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "During contract instantiation, zero percentage fees for creator or receiver are accepted. However, since this value is used as a denominator in the calc_minimum_balance function in src/commands:696 during the handling of Create messages, a zero value will lead to a division by zero error. if any the Additionally, transfer_tokens_messages function will fail because the contract will try to send zero amount of fees, which will be prevented by Cosmos SDK. fee collectors are miscongured to receive zero fees,",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Missing address validation during contract instantiation and conguration update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "During contract UpdateConfig messages in src/commands.rs:16-51, admins addresses are not validated. instantiation in src/contract.rs:28-54 as well as execution of the fee_collectors and Storing invalid addresses could lead to unexpected behavior like errors when completing escrows because of the failure of Bank messages directed to an invalid fee collector address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Fee collectors' percentage sum should not exceed 100",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "both In fee_collectors vector provided by the admin is set in the CONFIG struct. src/contract.rs:40-42 src/commands.rs:35-40, and the Since this vector represents a weighted list of addresses that should receive fees, the sum of the percentages of all the vectors elements should not exceed 100 to avoid charging more fees than expected. Additionally, duplicate addresses are allowed in the vector, potentially leading to higher fees than intended. We classify this issue as minor since only the contract admin can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Contract-dened admins can lock user funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:655-691, the calc_fees function iterates over all fee collectors for each balance coin in order to send fees through Bank messages. limit Since no upper for fee_collectors is enforced, admins could store a large fee_collectors vector in order to let the contract run out of gas during the calc_fees function execution. Consequently, all the messages that involve the sending of funds will fail, leading to the lock of user funds in the contract. We classify this issue as minor since it can only be caused by admins who are community-trusted entities.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. OTC_ACTIVE_PAIRS_COUNT is not decrement when public OTC is modied into private",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:230, the execute_set_recipient function does not decrease the active OTC pairs when a public OTC trade becomes private. Consequently, incorrect values. this causes the MarketEscrowActivePairsCount query to return Please see the public_to_private_does_not_decrease_active_otc test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Missing validation to ensure that creator_balance is not equal to asking_price",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:96, creator_balance is equal to the asking_price. the function execute_create is not checking if the If an escrow with the same provided and asked coins denom and amount is created, this could generate a potentially unwanted arbitrage opportunity and make the creator lose funds on the trade.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Admin can update fee_collectors to an empty vector",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "src/commands.rs:35-40, fee_collectors, In assert_has_fee_collectors is not called to ensure the fee collectors vector is not empty. update during an of This is inconsistent with the contract instantiation phase in src/contract.rs:36.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Redundant partial ll validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:461-463, the if statement ensures the escrow allows partial lls in the execute_receiver_partial_deposit function. This check can be removed as the same validation is performed in src/commands.rs:333.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Incorrect comment for vesting_end_time",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "In src/commands.rs:90, the comment documents that vesting_end_time represents the vesting start time. This is incorrect, as the variable represents the vestings end time.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Loss of escrow information after the execution of Refund messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "During the handling of Refund messages, the execute_refund function removes the selected escrow data from the storage. While this is not a security issue, it could degrade the user experience since escrow information is not queriable anymore, and all the involved parties have no more reference to their operations. Additionally, in the case of partially lled escrows, the removal of the original escrow could lead to the impossibility of retrieving data from its partial_fill_of_id.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Custom access controls implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf",
        "body": "The contract implements custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Password still in memory after logout",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "Unlike the mnemonic, the password (which can be used to retrieve the mnemonic) is still visible in memory after the user is logged out. For instance, the following memory dump was taken after logging out on a Windows machine: $ strings nym-wallet.DMP | grep \"AAAa1\" AAAa1234!@ The password of the user was AAAa1234+@ and this string is still in memory after logging out.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Mnemonic kept in memory after account creation within the wallet",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "To ensure that the mnemonic is not kept in memory, it is overwritten with a fresh mnemonic in the zeroize implementation (within account_data.rs). This works well and we ensured that the mnemonic cannot be retrieved from a memory dump after the user is logged out. However, this is not the case when a new account is created within the wallet (clicking on the account symbol and then selecting Create account). Then, the mnemonic is still kept in memory, even after the user is logged out. This can be seen in the following screenshot, where a memory dump on Windows was taken after the user was logged out. Previously, an account with the mnemonic frequent husband lecture orphan position surround pumpkin twin write express axis employ guard outside defense swim impulse spot hair punch load today tragic because\" was added within the app:",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Limited range of password special characters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "PasswordStrength The in nym-wallet/src/pages/auth/components/password-strength.tsx uses regex patterns to validate the strength of a password. However, the regex pattern for a \"strong\" password enforces a strict set of symbols, disallowing certain characters such as \"}\" from being used. This restriction limits the range of possible passwords and makes it easier for an attacker to successfully guess a password through brute-force methods. component React",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. User is forced to copy the mnemonic phrase to the clipboard",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "During account creation, the user is presented with the mnemonic phrase and is required to click the \"Copy mnemonic\" button, which copies the phrase to the clipboard. This practice poses a security risk as the mnemonic phrase may be accessed by other applications.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. No conrmation of mnemonic when account is added in the wallet",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "When a new account is created on the start screen using Create account, there is no conrmation ow ensure that the user backed up/noted down the mnemonic. Instead, only the password is required to continue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Mix node description requested via HTTP",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "The function get_mix_node_description (within bond.rs) requests the description of a mix node via unencrypted HTTP. While this information is only used for display purposes (limiting the impact of a MITM attack on the connection), it is still recommended to use encrypted connections for all external requests.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Known vulnerabilities in dependencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "There are known vulnerabilities in two dependencies (crate chrono and time): chrono 0.4.19 Potential segfault in `localtime_r` invocations 2020-11-10 RUSTSEC-2020-0159 https://rustsec.org/advisories/RUSTSEC-2020-0159 Crate: Version: Title: Date: ID: URL: Solution: Upgrade to >=0.4.20 Dependency tree:  vesting-contract 1.1.0  nym_wallet 1.1.1  nym-wallet-types 1.0.0   nym-types 1.0.0 chrono 0.4.19  vergen 5.1.17             nym_wallet 1.1.1  validator-client 0.1.0        nym_wallet 1.1.1  nym-wallet-types 1.0.0  nym-types 1.0.0  nym_wallet 1.1.1  nym_wallet 1.1.1  nym-wallet-types 1.0.0 time 0.1.43 Potential segfault in the time crate 2020-11-18 RUSTSEC-2020-0071 https://rustsec.org/advisories/RUSTSEC-2020-0071 Crate: Version: Title: Date: ID: URL: Solution: Upgrade to >=0.2.23 Dependency tree: time 0.1.43  chrono 0.4.19  vesting-contract 1.1.0  nym_wallet 1.1.1  nym-wallet-types 1.0.0   nym-types 1.0.0  vergen 5.1.17             nym_wallet 1.1.1  validator-client 0.1.0        nym_wallet 1.1.1  nym-wallet-types 1.0.0  nym-types 1.0.0  nym_wallet 1.1.1  nym_wallet 1.1.1  nym-wallet-types 1.0.0 Similarly, there are NPM packages with known vulnerabilities (which are shown when running yarn audit). The output of running yarn audit indicates that 63 vulnerabilities were found in the audited packages. Of these vulnerabilities, 2 are rated as moderate, 46 are rated as high, and 15 are rated as critical.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Inadequate password strength validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "React PasswordStrength in The validates nym-wallet/src/pages/auth/components/password-strength.tsx the strength of a password on a scale of \"insucient\", \"medium,\" and \"strong\". The password strength calculation is based on the length of the password and the occurrence of a set of predened characters. However, this calculation is inadequate and may classify low entropy passwords, such as abc1234! or passw0rd! as \"strong\" passwords. This could lead to a complete loss of funds if an attacker can obtain an encrypted wallet le and successfully guesses the password, for example by using common password lists. component",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Unhandled errors thrown by asynchronous functions in React hooks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf",
        "body": "If errors thrown by asynchronous functions within React hooks are not caught and handled properly, they will be silently ignored and the React error boundary will not be triggered. The user will not be notied of the error and the application may end up in an inconsistent state. The following but incomplete list of hooks is aected: - - - nym-wallet/src/context/main.tsx:109 nym-wallet/src/context/main.tsx:147 nym-wallet/src/context/main.tsx:160",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Missing validation of the bridged_denom format",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf",
        "body": "In contracts/lido-satellite/src/msg.rs:16-21, not validate the format of the bridged_denom variable. the validate function does This is problematic since the contract is designed to hold only funds denominated in bridged denoms. Specically, the provided denom should adhere to the required format of ibc/{denom} before proceeding with any subsequent processing steps.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Additional funds sent by the user besides config.bridged_denom are locked",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf",
        "body": "In contracts/lido-satellite/src/execute.rs:15 and 39, the find_denom function checks for the existence of a Coin with the config.bridged_denom among the funds sent with the message. This validation does not ensure however that no other native tokens have been sent, and any such additional native tokens are not returned to the user, so they will be stuck in the contract forever. While blockchains generally do not protect users from sending funds to wrong accounts, reverting extra funds increases the user experience.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Missing check that the contract has enough funds to cover the creator_fee",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf",
        "body": "In contracts/lido-satellite/src/contract.rs:31, before creating a new denom, no check is performed to ensure that the contract has sucient funds to cover the creator_fee. the tokenfactory module Since in https://github.com/neutron-org/neutron/blob/v1.0.2/x/tokenfactory/keeper/createdenom.go#L1 5, if the contract does not hold enough funds, an error will be raised. denom creation imposes fee for a This behavior could complicate the contract deployment process and lead to ineciencies.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "4. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf",
        "body": "The lido-satellite contract does not enable overflow-checks for the release prole. While enabled implicitly through the workspace manifest, future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Weights for most calls do not account for computation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dock/Dock PoS - Audit Report [20210706].pdf",
        "body": "The weights for calls cover storage reads and writes in all cases, but most weights do not account for time spent running the calls. There is a risk of some calls being overly cheap, which opens the possibility for an attacker to ood the network with transactions. When that happens, normal transactions might no longer be able to be processed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Unhandled zero-amount transfers in marketplace contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "In several occurrences when performing BankMsg::Send, there is no validation to ensure the amount to transact is greater than zero. Consequently, the transaction will fail and revert. 1. 2. 3. 4. contracts/marketplace/src/execute.rs:1209-1216 the contracts/reserve-auction/src/helpers.rs:143-146, In settle_auction function will fail if the remaining amount is zero after deducting the protocol and royalty fees. In packages/common/src/lib.rs:78-82, the royalty_payout function will fail if the royaltys share is zero. In 1223-1230, deducting the royalty, network, and nder fees. lines In and 1074-1081, the value of execute_remove_stale_collection_bid functions will params.bid_removal_reward_percent is set to zero or to the maximum bps value. lines if the remaining amount is zero after execute_remove_stale_bid if contracts/marketplace/src/execute.rs:1023-1030 the payout function will fail and and the fail",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Validate that the amount is not zero before sending funds to the bidder and operator. Status: Resolved 2. Protocol does not enforce minimum reserve price to be in STARS denom",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "In contracts/reserve-auction/src/helpers.rs:131, the fair_burn function is called to burn a portion of the bid amounts, expecting the bid denom to be STARS. This is problematic because there is no validation ensuring that config.min_reserve_price is in the STARS denom. Additionally, when settling the auction in lines 143-146, the settle_auction function distributes the config.min_reserve_price is denominated in a dierent denom, incorrect funds will be distributed instead. Consequently, denom. STARS funds with the if",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. MAX_FIXED_PRICE_ASK_AMOUNT is not enforced during ask price update",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "In the contracts/marketplace/src/execute.rs:412, execute_update_ask_price function does not validate the price.amount does not exceed MAX_FIXED_PRICE_ASK_AMOUNT. This invariant is enforced in line 308 during the execute_set_ask function, but it is not enforced when updating the asking price.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. TODO comment in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "In packages/common/src/lib.rs:65, a TODO comment is in the codebase. TODOs in production code are a deviation from best practices.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Duplicate nder fee validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "contracts/marketplace/src/execute.rs:474-478 In duplicate validations of finders_fee_bps are performed. and 484-488, In fact, the only dierence lines between these two checks are variable names (fee vs finders_fee_bps), but validations are identical. the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Reserve prices can be updated for expired auctions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf",
        "body": "the contracts/reserve-auction/src/execute.rs:158, In execute_update_reserve_price function does not validate whether the auction is expired. An expired auction should not be modiable.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Potential integer over-/underflows, division by zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dock/Audit Report - Dock Token Migration.pdf",
        "body": "In multiple places in the pallet, over-/underflows of integers are not checked and in one instance, a division by zero could occur: 1. bonus.total_locked_bonus += amount; in the add_swap_bonus function pallets/token_migration/src/lib.rs#L406",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. bonus.total_locked_bonus -= bonus_to_unlock; in the unlock_vesting_bonus Recommendation function ( pallets/token_migration/src/lib.rs#L531 ) We recommend checking for over-/underflow and division by zero manually or using checked_add , checked_sub , checked_mul checked_div or . Status: Resolved 2. Migrators have free autonomy to spend/transfer funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dock/Audit Report - Dock Token Migration.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Undelegations will fail when redelegating to a new validator",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "contracts/external/cw-vesting/src/stake_tracker.rs:71-74, In cardinality is not undelegations will fail in line 100 as the cardinality tries to decrement a zero-value. the increased when redelegating to a new validator. Consequently, Although the vesting recipient can prevent this issue by redelegating back to the source validator, it is irrecoverable if the vesting is canceled. In that case, the owner can no longer withdraw the delegated funds. Please see the test_redelegate_should_increase_cardinality test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Misconguring the total vested amount to be lower than the sent CW20 amount would cause a loss of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "In contracts/external/cw-vesting/src/contract.rs:38, the total amount of tokens to be vested depends on the PayrollInstantiateMsg.total amount (see the total contracts/external/cw-payroll-factory/src/contract.rs:87). amount to vest is lower than the sent CW20 amount, the excess tokens will be left in the cw-payroll-factory contract. If can Suppose a scenario where the cw-payroll-factory does not have any owner. An calling attacker higher ReceiveMsg::InstantiatePayrollContract PayrollInstantiateMsg.total amount, causing the cw-payroll-factory contract to send the excess funds to the newly instantiated cw-vesting contract. tokens with by a excess steal the Please see the test_inconsistent_cw20_amount test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Misconguring start time to be in the past might cause undesired payouts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "In contracts/external/cw-vesting/src/contract.rs:34, the start_time of the vesting can be set to a past value, which might lead to undesired payouts. We classify this issue as minor since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Vesting duration parameter is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "In cw-vesting/src/contract.rs:41, the duration_seconds parameter is initialized with a non-validated value. This results in the possibility of instant vesting, releasing funds immediately upon reaching start_time, which may not be intended. The value of duration_seconds is handled using the SaturatingLinear variant of the Schedule type. Using it with a start_time in the future and duration_seconds equal to 0 renders it equivalent to the PiecewiseLinear schedule consisting of a single step releasing the whole amount. We classify this issue as minor since only the contract instantiator can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Undelegation does not emit custom events",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "undelegation in During contracts/external/cw-vesting/src/contract.rs:366, no events or attributes are emitted upon successful execution. This is inconsistent with execute_delegate and execute_redelegate, where attributes are emitted in lines 259 and 324, respectively. execute_undelegate function the in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Values held in StakeTracker cannot be queried",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "There is a certain amount of code implementing tracking of delegations in the cw-vesting smart contract. The structure StakeTracker, dened in stake_tracker.rs, contains the elds total_staked, validators, and cardinality. They all reect the chronology of staked funds by the validator and account unbonding times. However, call graph analysis reveals that only total_staked aects the outcome of transaction processing. In contrast, validators and cardinality are never read outside tests in stake_tracker_tests.rs. StakeTracker does, however, update them, e.g. in the on_bonded_slash function in stake_tracker.rs:113 with a clever technique of reconstructing proper delegated amounts after slashing events. The concern is that elds validators and cardinality require computation and on-chain space while not being utilized in any way except testing.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Potential misleading error in ReceiveMsg::Fund",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf",
        "body": "In cw-vesting/src/contract.rs:153, the error ContractError::Funded is thrown if the status of the vesting is not Unfunded. However, the contract also can be in the Canceled state.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. Instantiator may introduce misconguration by providing non-compliant proxy code_id",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Public Awesome/2023-01-27 Audit Report - ICS721 v1.0.pdf",
        "body": "function instantiate in The contracts/cw-ics721-bridge/src/contract.rs:26 does not check to ensure that the proxy code_id specied is a compliant cw721-proxy contract. The functionality for the INSTANTIATE_PROXY_REPLY_ID reply is generic contract instantiation logic which does not conrm that the contract is compliant. While it is unlikely that the instantiator of the contract would unknowingly introduce a misconguration by providing an invalid proxy, the impact of this would be that NFTs could be sent from other chains to this bridge and debt vouchers could be minted, but they would be unredeemable if the proxy contract did not support the correct interface to allow for NFTs to be sent back to their origin chain. This could be corrected by a migration to a compliant proxy contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. No matter whether the user supplies one or more entries with the duplicated denom in the asset_amounts array of either the try_mint or the try_receive_burn function, only the rst entry will be used, all others will be ignored. In the case of a duplicate native token, a user could send just one entry in the asset_amounts argument to the try_mint function, but there will be a duplicate in subtraction contracts/nebula-cluster/src/contract/handle.rs:478. When that calculated happens, in contract from contracts/nebula-penalty/src/contract.rs:134 will stay the same (since the imbalance just shifts to the right). The denominator in line 137 will get smaller though, which will lead to a higher minted token amount for the attacker. If the attacker immediately burns the cluster tokens, they can drain assets from the cluster. inventory amount penalty reward token from the the the the of assert_sent_native_token_balance in The not contracts/nebula-cluster/src/contract/handle.rs:464 prevent this issue since it checks the amount in every iteration, and not the sum of the amounts across all tokens with the same denom. does We classify this issue as minor since it is caused by a wrong parameterization which can only be changed during initialization, by governance or the composition oracle. Recommendation We recommend checking the assets argument in the init and try_reset_target functions for duplicates and returning an error if any duplicates are found. Status: Resolved 5. No validation of initial cluster target weight sum to equal 100",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nebula/Nebula - Audit Report.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Non-deterministic iteration in BuildDependencyDag may break consensus",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In x/accesscontrol/keeper/keeper.go:333, nodes iterate over anteDepSet. Due to the non-deterministic behavior of iteration over maps in Go, there could be two dierent types of errors from ValidateAccessOp. This could lead to consensus failure.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. RegisterWasmDependency allows anyone to register contract dependency mappings that can increase gas consumption",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "function RegisterWasmDependency in The x/accesscontrol/keeper/msg_server.go:22 allows anyone to register contract dependency mappings. It does not validate if the transaction sender is the contract owner. the Sei Chain where the These contract dependency mappings are used by in GetWasmDependencyMapping x/accesscontrol/keeper/keeper:126 gets a contracts dependency mapping information. This may create opportunities for attackers to exploit applications on top of Sei Chain. For instance, an exploiter can make the getMessageMultiplierDenominator function return WasmCorrectDependencyDiscountDenominator. This will lead to an increase of the the DispatchMsg function in gas consumption for wasmbinding/message_plugin.go:118 of Sei Chain does not validate message dependencies if a contracts WasmDependencyMapping is disabled. app/antedecorators/gas.go:34 that particular contract. Moreover, function dened Chain Sei of in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Several errors are not handled and may cause an inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "there are unhandled errors that allow execution to In several places of continue even when operations have failed. This may produce inconsistent states and unexpected panics. the codebase, Instances of unhandled errors can be found in:  x/bank/keeper/keeper.go:47  x/bank/keeper/keeper.go:456  x/bank/keeper/keeper.go:434  x/bank/keeper/keeper.go:378  x/accesscontrol/handler.go:14  baseapp/abci.go:31 As an example, the UpsertDeferredSends function may return an error, which is not checked. The calling function, DeferredSendCoinsFromAccountToModule, should propagate the Error upstream, but since the Error is not handled this will not happen. Since the execution would continue, it may leave the network in an inconsistent state or cause an unexpected panic.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Missing LegacyAmino codec registration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In x/accesscontrol/module.go:45, the RegisterLegacyAminoCodec function does not register the modules LegacyAmino codec. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Use of deprecated function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "x/accesscontrol/client/utils/utils.go:15 and In x/accesscontrol/client/utils/utils.go:28, the ReadFile function is called from the ioutil package, yet that package is deprecated as of Go 1.16. The function should be used from the os package instead.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Resolve TODOs before release",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "There are multiple TODOs in the codebase that may refer to sensitive or important logic. Instances are:  baseapp/abci.go:170  baseapp/baseapp.go:717  x/accesscontrol/keeper/keeper.go:406  types/module/module.go:289",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Unnecessary lock acquisition might negatively impact performance",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In types/context_cache.go:68, there is a check to circuit break in case the amount is not valid. However, before that check, a lock is acquired which is not needed for this specic validation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. MintCoins does not perform a nil pointer validation in case the module name is passed incorrectly",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In x/bank/kepper/keeper.go:561, the module account is retrieved to add coins to it through the createCoins function in line 565. However, if the moduleName does not exist, it would return a nil pointer from the GetModuleAccountAndPermissions function. Currently, the only place that the function is called is in x/mint/keeper/keeper.go:103, and the module name is a constant. Therefore, unless that specic module name does not exist, there is no attack vector with the current design.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Unused assignment in GetSigners",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In types/tx/types.go:125, there is an assignment to the variable seen which is never used thereafter.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Commented code in encryptPrivKey",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "In encryptPrivKey in crypto/armor.go:149, there is an assignment that has been commented out.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Missing usage description for transaction and query CLI commands",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "transaction in The commands and and x/accesscontrol/client/cli/tx.go:18 x/accesscontrol/client/cli/query.go:13 are missing a long message to describe their usage, which could be helpful for users and external developers. accesscontrol module query the of",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Miscellaneous comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf",
        "body": "Across the codebase, various instances of unused code and misleading comments have been found.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Cache hit counters can be used to crash nodes and halt a chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The VM implementation contains a cache to eciently load smart contract instances that are pinned or used repeatedly. For analytical purposes, that cache increments the hit counters hits_pinned_memory_cache, in packages/vm/src/cache.rs whenever an instance is read from it. These hit counters are incremented using integer addition, which can cause panics in the case of integer overows. hits_memory_cache, hits_fs_cache and An attacker can exploit this issue to crash a node and possibly even halt the chain, for example by repeatedly querying an instance from a CosmWasm smart contract. The hit counters currently use the u32 type. To cause an overow, almost 4.3 billion cash hits are required. While this is a huge number, the counters are only reset upon node restart, so there is a real possibility for long-running nodes to suer from such an overow panic. Moreover, an attacker does not need to cause almost 4.3 billion cache hits within one transaction  such an attack can be executed across many blocks. Query nodes are even easier to target, since they can be queried repeatedly with little resource cost by the attacker.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Gas counting in vm backend does not correctly add externally used gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The packages/vm/src/backend.rs:56: GasInfos add_assign method incorrectly sets in externally_used: self.externally_used + other.cost This implies that the externally_used gas of other is not accounted for. An attacker could call external them, potentially blocking block production. functions without paying gas for We classify this issue as minor since the add_assign method is currently only used in test code.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Overow in gas counting might halt block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "and add_asign process_gas_info The in packages/vm/src/backend.rs:55, 56, packages/vm/src/environment.rs:341 and 352, which could potentially allow an attacker to halt block production of the underlying blockchain if the CosmWasm vm is compiled without overflow-checks enabled for the release prole. functions overow might",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Ed25519 batch verication is not benchmarked, might run out of memory and halt block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The do_ed25519_batch_verify function imposes limits to the number of messages, signatures, and public keys per batch in packages/vm/src/imports.rs:291-305, but there currently exists no benchmarking code in the codebase that veries that these limits are reasonable. production of the underlying blockchain might halt. If the limits are too high, validators might run out of memory, and block",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Unlimited WASM table size may be exploited to crash the node",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "of the states memory While in packages/vm/src/wasm_backend/store.rs:82, tables are not. The WebAssembly (see spec https://webassembly.github.io/spec/core/syntax/types.html#table-types). If such a growth of a table can be triggered from smart contracts, it may exhaust the resources of the underlying node, potentially crashing it and stopping block production. can grow indenitely instances are not limited, limited tables they that is if We tried to write a WASM module using WAT that adds new elements in a loop, but apparently, elem sections need to be at the module top level, so adding more entries to the table would linearly increase the WASM blob size. While we have not been able to exploit this issue by adding elements to the table, there may be other ways to make the table size grow indenitely.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Unbounded iteration over WASM imports may slow down block production or stop the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The check_wasm_imports function collects all into a BTreeSet in packages/vm/src/compatibility.rs:152, which uses an unbounded iteration over the imports. This may be exploited to slow down block production, possibly even stopping the chain. the wasm contract imports of We classify this issue as minor since there is an implicit limit to the number of imports through the WASM size limit.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Compilation of wasm code does not specify memory limit and might halt block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The save_wasm function calls compile in packages/vm/src/cache.rs:154 without setting a memory limit. This could cause the node to run out of memory, potentially halting block production of the underlying blockchain if no mechanism for recovery is implemented. We only consider this to be an informational issue since the underlying blockchain should reject wasm code that is too big, and the singlepass compiler used will execute in linear time, preventing JIT-bombs.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Attribute keys starting with underscores lead to panics, causing smart contract runtime errors in debug mode",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "for attributes constructor The in packages/std/src/results/events.rs:71 if an attribute key starts with an underscore _. This will lead to runtime errors for smart contract projects that have code paths that were not extensively tested. An example could be a DeFi protocol that adds an attribute with an underscore under certain conditions, for example an emergency withdrawal. The panic would prevent the emergency withdrawal, putting user funds at risk. debug panics mode in The check in the constructor does also not guarantee that a key does not start with an underscore, since library users could simply manually push attributes with any key. We classify this issue as informational since it only aects code compiled with debug assertions.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Overows could occur if library users do not enable overow-checks, panics abort execution",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "In several places in the codebase, overows are not handled explicitly. This is not a security concern as long as overow-checks are enabled for the release prole, but there is a risk that a library user does not enable overow-checks. Additionally, overow-checks cause overows to panic, which is less user friendly than an overow error message that allows unwinding the operation. A panic in WebAssembly always aborts the execution and does not unwind. Instances of potential overows are: - - - - The nextval function in packages/storage/src/sequence.rs:19. The plus_seconds, plus_nanos, minus_seconds, and minus_nanos methods in packages/std/src/timestamp.rs:37-57. The isqrt method in packages/std/src/math/isqrt.rs:28. The sqrt_with_precision method in packages/std/src/math/decimal.rs:181 and in packages/std/src/math/decimal256.rs:194.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Math method types are inconsistent and not exhaustive",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "In packages/std/src/math, several math types are implemented, such as Decimal, Decimal256, Uint64, Uint128, or Uint256. The API of those math types contains several inconsistencies and functionality diverges or is partially not implemented, even between similar types such as Uint64 and Uint128. These dierences can lead to a decrease in the development experience when using math types of the std package. Examples of these discrepancies are: - - - - - - - - - - - - - - - - Sub and Mul are implemented for Uint128, Uint256 and Uint512, but missing for Uint64. SubAssign and MulAssign are implemented for Uint128, Uint256 and Uint512, but missing for Uint64. wrapping_add, wrapping_sub, wrapping_mul, and wrapping_pow are implemented for Uint64 and Uint128, but missing for Uint256 and Uint512. Mul is implemented for Decimal and Decimal256, but Div is not implemented for them. For Decimal and Decimal256, Div returns a Decimal, while DivAssign returns a Uint128 multily_ratio and full_mul is implemented for Uint64, Uint128 and Uint256 but missing for Uint512. pow is implemented for Uint256 but missing for Uint64, Uint128 and Uint512. checked_pow is implemented for Uint128 and Uint256 but missing for Uint64 and Uint512. saturating_pow is implemented for Uint128, but missing for Uint256 and Uint512. check_div_euclid is implemented for Uint64 and Uint128, but missing for Uint256 and Uint512. Shl is implemented for Uint256, but missing for Uint64, Uint128 and Uint512. ShrAssign is implemented for Uint64, Uint128, Uint256 and Uint512, but ShlAssign is missing for all unsigned integers. checked_shl is implemented for Uint256, but missing for Uint64, Uint128 and Uint512. Inconsistent with other methods, TryFrom<Uint128> for Uint64 is dened in packages/std/src/math/uint128.rs, and not in packages/std/src/math/uint64.rs. Inconsistent with other methods, TryFrom<Uint512> for Uint128 is dened in packages/std/src/math/uint512.rs, and not in packages/std/src/math/uint128.rs. The from_str function results in an error on an empty string in packages/std/src/math/uint256.rs, but not in packages/std/src/math/uint128.rs and packages/std/src/math/uint512.rs, which is inconsistent. - - - - - - - - Inconsistent with other methods, TryFrom<Uint256> for Uint128 is dened in packages/std/src/math/uint256.rs, and not in packages/std/src/math/uint128.rs. In packages/std/src/math/uint128.rs:215, StdError::generic_err is used for parsing errors instead of StdError::parse_err. The new function in packages/std/src/math/uint512.rs is not marked as const, which it is in packages/std/src/math/uint256.rs. Some methods return StdError::generic_err(\"Error parsing whole\") while others return an ParseErr. Some methods return StdError::generic_err(format!(\"Serializing QueryRequest: {}\", serialize_err)) instead of StdError::serialize_err. The wasmer::SerializeError and wasmer::DeserializeError is wrongly transformed into a VmError::cache_err instead of a VmError::serialize_err in packages/vm/src/errors/vm_error.rs:325 and 331. The VmError::cache_err in packages/vm/src/checksum.rs:47 should be a VmError::conversion_err. Some methods use expect, while others use unwrap, which results in panics without messages explaining what went wrong.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Several dependencies are outdated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "There are several dependencies that are not used in their latest version. Some of them contain security vulnerabilities. A subset that might introduce vulnerabilities is: - - - - chrono contains a potential segfault, currently used in version 0.4.19, no safe upgrade available. time contains a potential segfault, currently used in version 0.1.43, upgrade to >= 0.2.23 instead. ed25519-zebra is currently used in version 2.2.0, available in 3.0.0 rand_core is currently used in version 0.5.1 in package cosmwasm-crypto, available in 0.6.3",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Unaudited cryptography library",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The library implementation of ECDSA in crate k256 is unaudited and comes with the following warning in its documentation: Security Warning The elliptic curve arithmetic contained in this crate has never been independently audited! crate This has been designed with the goal of ensuring that secret-dependent operations are performed in constant time (using the subtle crate and constant-time formulas). However, it has not been thoroughly assessed to ensure that generated assembly is constant time on common CPU architectures. USE AT YOUR OWN RISK!",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Ed25519 batch verication succeeds for empty data, which may not be obvious to library users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The ed25519_batch_verify function in packages/crypto/src/ed25519.rs:65 succeeds if provided with an empty collection of messages, signatures, and public keys. This behavior is correctly documented in line 64. Still, an unsuspecting library user might not be aware of this implementation, which could lead to bugs in dependent codebases.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Consuming gas after performing Ed25519 batch verication is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "do_ed25519_batch_verify The in packages/vm/src/imports.rs:312-318 after executing the batch verication in line 311. This is inecient since the verication can be skipped if the gas limit is hit. consumes currently function gas",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Missing overow checks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf",
        "body": "The workspace manifest Cargo.toml as well as the following packages do not enable overflow-checks for the release prole: packages/profiler/Cargo.toml - packages/crypto/Cargo.toml - packages/derive/Cargo.toml - - packages/schema/Cargo.toml - packages/std/Cargo.toml - packages/storage/Cargo.toml - packages/vm/Cargo.toml",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Overow checks are not enabled for the release prole, which can lead to a loss of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "In contracts/cw20-blocklist/Cargo.toml, overflow-checks are not enabled for the release prole. Since there are arithmetic calculations that do not use checked increasing an calculations to prevent overow issues in the cw20-base contract accounts balance), an overow in production would be silently ignored. (e.g.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Users can evade having blocked funds destroyed by using uppercase addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "The cw20-blocklist contract does maintain the blocklist with lowercase addresses, and it performs lowercasing of an address before checking whether it is on the blocklist. The underlying cw20-base contract, on the other hand, does not lowercase addresses. This discrepancy allows users to evade having blocked funds destroyed, by having their balance sent to an uppercase address, rather than a lowercase one. If a user sends the the Transfer message to a previously unused and not blocked uppercase address, execute_transfer function of the cw20-base contract will update BALANCES with the uppercase address as the key. Blocklisting that address works as expected, since all blocklist see checks If the minter contracts/cw20-blocklist/src/contract.rs:195, 211, and 254. now wants the address DestroyBlockedFunds message, the destroy_blocked_funds function is trying to reduce BALANCES using the lowercased address as a key in lines 160-168. This will fail, since the balance was stored under an uppercase address as the key. associated with transforming lowercase, performed address funds using burn after that are the the to to",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Missing validations during contract instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "In contracts/cw20-blocklist/src/contract.rs:36-38, msg.name, msg.symbol, and msg.decimals are not validated. the passed arguments Without validation of name and symbol, the minter is able to pass invalid or non-printable characters that could aect front-end rendering, allow script injection, or passing strings very long strings which may inhibit usability of the token. Without validation of decimals, the minter is able to pass any supported u8 value (from 0 to 255). An uncommonly large decimal point might cause issues for protocols that build on top of this contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. One-step minter update increase risk of lost minter permissions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "The cw20-blocklist contract allows the current minter to update the minter address in one single step. While this is common practice, it presents a risk for the minting permission to become lost if the new address is incorrect. A two-step minter update will allow the current minter to propose a new minter address, and then the account that is proposed as the new minter may call a separate function that will allow them to claim the minting permission and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Consider using time locks to automatically unblock addresses in the event of a lost/compromised minter private key",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "Throughout the codebase, the minter can perform various privileged actions such as adding and removing addresses to/from the blocklist. A blocked address will remain blacklisted until the minter decides to unblock them. In the event that the private key is lost or compromised and the minter updated, the blacklisted address may never be unblocked.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Blocked addresses can receive tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "In the codebase, there are no restrictions that prevent blocked addresses from receiving tokens. Since the minter can destroy funds held by a blocked address using the DestroyBlockedFunds message, we recommend disallowing funds to be sent to a blocked address.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Removal of Burn and BurnFrom may impact contract composability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "The cw20-blocklist contract does not include the Burn and BurnFrom messages that the cw20-base contract provides. This may impact composability of the cw20-blocklist contract with other smart contracts, In the current implementation, a Redeem message exists, that only allows the minter to burn tokens. that may rely on burning of funds.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Duplicate code impacts maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "Throughout the codebase, privileged execution messages such as AddToBlockedList, RemoveFromBlockedList, UpdateMinter, Redeem, and DestroyBlockedFunds messages are all restricted to minter access. The logic that veries whether info.sender is the minter is duplicated across the handlers for these functions, which negatively impacts the code's maintainability and readability and may lead to future errors.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. cw20-blocklist modies cw20-base interface, which negatively impacts composability and is not documented correctly",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "Compared with the cw20-base contract, following modications: the cw20-blocklist contract exhibits the Initial balances cannot be provided during instantiation 1. Minter is always set to the instantiator 2. Minting cap cannot be set 3. 4. Marketing info cannot be set or queried 5. Burn and BurnFrom messages have been removed 6. Minter, AllAllowances, AllAccounts, MarketingInfo, and DownloadLogo queries have been removed This reduces the composability of the cw20-blocklist contract, since it may not be possible for some projects to swap a cw20-base contract with a cw20-blocklist It also aects frontends and implementation without aggregation layers that may rely on some of the removed queries. Lastly, the documentation in contracts/cw20-blocklist/README.md:3 describes that the cw20-blocklist further modication of their code. contract extends the cw20-base to add blocklist functionality, which is misleading.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Testing wallet seed phrase and private keys are exposed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "In keys.terrain.js, the testing wallets mnemonic and private keys are hardcoded and visible to the public. Although these secrets are intended to be used purely for testing purposes, it is a violation of best practice to commit wallet seed phrases or private keys into a repository. These accounts may accidentally be used by developers on mainnet, in which case funds may be lost or permissions be exploited.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Outdated dependencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf",
        "body": "The cw20-blocklist contract contains outdated dependencies, see Appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Attacker can drain funds by refusing completed oers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "In contracts/nft-loans-non-custodial/src/execute.rs:336, a borrower can refuse an oer even if the oer had been accepted. Suppose a borrower calls RefuseOffer for an accepted loan  that allows the lender to call WithdrawRefusedOffer in order to withdraw the deposited funds. This is problematic because the lender already had their principal in back interest contracts/nft-loans-non-custodial/src/execute.rs:546-549, resulting in the contract losing funds. repaid and An attacker can exploit this issue by completing and refusing a loan to withdraw excess funds as the lender. This can be exploited repeatedly to drain all funds from the contract. Please see the test_steal_funds test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Borrowers are forced to default on loans with zero fees or interest",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "In the contracts/nft-loans-non-custodial/src/execute.rs:557-567, contract tries to send fees to the treasury without validating that the amount is greater than zero. Suppose a lender accepted a loan with the loan terms interest as 0. The calculated fee amount would be zero (see line 531), causing the contract to send 0 funds to the fee contract. Since Cosmos SDK does not allow 0 amount transfers, borrowers would not be able to repay in time, causing their loans to default. A lender can exploit this issue by providing zero-interest loans, forcing the borrower to default on their loans so the lender can have the NFT in return. Additionally, this issue will also occur if the admin sets the fee rate to the maximum value, preventing all borrowers from repaying their loans successfully.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Attackers can steal NFTs with approvals on contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "and In contracts/nft-loans-non-custodial/src/execute.rs:433-440 contracts/raffles/src/execute.rs:64-71, the CW721 NFT is transferred to the contract using the TransferNft message without verifying the caller is the owner of the NFT. Since the transferred NFT is stored under the callers rae or loan, the caller can withdraw the NFT after it ends, causing the real owner to lose their NFT. The possibility of this could happen when the user approves their NFT in the rst transaction but fails to create a successful rae or loan in the second transaction (e. g. due to invalid arguments). An attacker can then exploit the vulnerability If the approval is not revoked and does not expire in the next block. We classify this as a major issue because the attack requires pre-approval on the contract for successful exploitation.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Malicious rae owner can replay CancelRaffle message to steal NFTs in contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "In contracts/raffles/src/execute.rs:172, the get_raffle_owner_messages function is called to refund the owner their NFT when the owner cancels a rae. The execute_cancel_raffle function does not prevent replay attacks, allowing the owner to cancel a rae as long as there are no tickets bought. An attacker can exploit this issue by creating a rae and immediately canceling it, resulting in the contract storing a valid RAFFLE_INFO for the specic rae identier value. After that, the attacker sells the NFT in a marketplace to a victim. Once the victim creates a rae and deposits the NFT into the contract, the attacker executes CancelRaffle and steals the NFT. We classify this as a major issue due to the high exploit diculty.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Incorrect implementation of CW20 Receive message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "In contracts/raffles/src/contract.rs:113, users can deposit CW20 tokens into the contract through a receive callback function. However, the callback message does not follow the CW20 specication. Consequently, users are unable to deposit CW20 into the rae contract directly. We consider this a minor issue as users can still deposit CW20 tokens using the allowance functionality.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Consider validating fee distribution address and fee rate",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf",
        "body": "contracts/nft-loans-non-custodial/src/contract.rs:45 and In contracts/nft-loans-non-custodial/src/admin.rs:40, the contract owner instantiates and updates the fee distributor address. However, in each case, the address is not validated, which could lead to the contract being unable to execute as transfers may be made to an invalid address. the owner contract in Similarly, and contracts/nft-loans-non-custodial/src/contract.rs:46 contracts/nft-loans-non-custodial/src/admin.rs:61. A miscongured fee rate would prevent users from repaying borrowed funds due to overows occurring in contracts/nft-loans-non-custodial/src/execute.rs:527. instantiates updates rate and the fee We classify this as a minor issue since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Schedule cli shifts the unlock start date rather than leads to unlocked tokens that cannot be claimed yet",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "a and When dening an allocation of ASTRO for a user, the contract owner species a start date, a calculating the unlocked_amount in cli, duration. However, when time and cli are contracts/builder_unlock/src/contract.rs:939, the added, eectively just shifting the start date. The consequence of unlock_amount does not increase linearly from the start time, but from the sum of start date and cli instead. this is that the start contradicts in This packages/astroport-governance/src/builder_unlock.rs:35 which states Time after the cliff during which the remaining tokens linearly unlock. comment the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Recipient transfer does not transfer unlocked amount checkpoint",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "the in During execute_claim_receiver contracts/builder_unlock/src/contract.rs:650, only the astro_withdrawn eld of the allocation status STATUS is transferred to the new receiver, but not any amount that was previously unlocked in unlocked_amount_checkpoint. function This implies that the new receiver may have to wait longer for funds to unlock in the case where the previous recipient had an allocation decrease and the unlocked funds were stored in unlocked_amount_checkpoint.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Increasing the cli may result in unlocked tokens becoming locked again",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "In the increase_cliffs function, the contract owner can set a new cli for an allocation in in already contracts/builder_unlock/src/contract.rs:721. This may result unlocked tokens no longer being unlocked. Apart from this, an increasing cli in the current implementation may lead to an underow causing a panic in line 970 if a user already withdrew a bigger amount than the new unlocked amount. Note that this has no security implication, but a panic leads to a bad user experience.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Inconsistency in validation during recipient transfer may lead to a loss of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "the execute_propose_new_receiver returned in In contracts/builder_unlock/src/contract.rs:389 if the receiver has allocation parameters PARAMS with a non-zero amount. In the execute_claim_receiver function, however, an error is returned in contracts/builder_unlock/src/contract.rs:630 if a PARAMS entry exists for the receiver, even if the amount is zero. function, error an is This inconsistency allows a recipient with PARAMS but a zero amount to be proposed as the receiver, but that new recipient can never claim that allocation. This might lead to a loss of funds for the new receiver if the previous receiver of the allocation does not cooperate to resolve the issue. We classify this issue as minor since rstly, the creation of PARAMS allocations with a zero amount does not make much sense and may never exist, and secondly, the previous and new recipients are likely controlled by the same entity, in which case they can resolve the issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Maximum allocation amount can be set lower than total deposits",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "the update_config a In in new_max_allocations_amount contract/builder_unlock/src/contract.rs:689. There is currently no validation, however, that the new value is bigger than total_astro_deposited. contract function owner able the set to is This max_allocations_amount and implies that no new allocations can be created. total_astro_deposited assumption breaks that the <= We classify this issue as minor since only the owner can cause it, and since it can be resolved by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Transfer of unallocated tokens leads to wrong token accounting",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "During the execute_transfer_unallocated function, the total_astro_deposited the state the execute_increase_allocation in total_astro_deposited is which inconsistent decreased. increases function, variable amount This with not is contracts/builder_unlock/src/contract.rs:519. total_astro_deposited amount hence includes unallocated tokens. The Consequently, the total_astro_deposited state variable will be bigger than actual deposits after a transfer of unallocated funds. This implies that the condition checking total_astro_deposited against max_allocations_amount in line 523 will lead to an surpass the max_allocations_amount. deposited amount actual does even error not if We classify this issue as minor since it can be worked around by the owner by increasing max_allocations_amount.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Lack of validation when creating an allocation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "In the execute_create_allocations function, the passed AllocationParams are stored in contracts/builder_unlock/src/contract.rs:295. This implies that allocations can be created with a start_time in the past, a zero duration, zero amount or an invalid proposed_receiver address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Unnecessary lowercasing of addresses is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "the both codebase, Throughout custom addr_validate_to_lower function are used to convert String to Addr types and validate their correctness. As the version of cosmwasm-std dened in the Cargo.toml is it is no longer necessary to convert strings to lowercase. Using a custom function is 1.1, inecient and unnecessarily increases the codebase. deps.api.validate and the the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Unnecessary load of PARAMS during creation of an allocation is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "During the creation of an allocation, the contract veries that a user does not have an existing in allocation contracts/builder_unlock/src/contract.rs:287. Loading the value is inecient though, since it is not used. PARAMS loading value from the by",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Unnecessary validation of STATUS during creation of an allocation is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "by During the creation of an allocation, the contract veries that a user does not have an existing allocation in contracts/builder_unlock/src/contract.rs:299. However, there is already a check for PARAMS in line 287. Since both STATUS and PARAMS are created for new allocations, non-existence of an entry in PARAMS implies non-existence of that entry in STATUS, which makes the STATUS check unnecessary. checking STATUS the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Unnecessary loading of STATUS during claim of new receiver is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "In the execute_claim_receiver function, the STATUS of the new receiver is loaded in contracts/builder_unlock/src/contract.rs:649. However, an error is returned before in line 630 if that new receiver has stored PARAMS. Since PARAMS and STATUS for a receiver always exist both or neither, the code block in lines 649-653 has no eect.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Misleading function name compute_withdraw_amount may negatively impact maintainability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "The compute_withdraw_amount function calculates the amount of Astro a user may withdraw in contracts/builder_unlock/src/contract.rs:956. the function also updates the users STATUS, which contradicts the function name, which only indicates a computation. This might mislead In addition,",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Inecient validation of prev_receiver",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "When a user accepts a claim of a token allocation, the function loads the PARAMS and in STATUS contracts/builder_unlock/src/contract.rs:625 and subsequently removes both the PARAMS and STATUS of said previous receiver. previous receiver the of During each of these four interactions, the function validates the prev_receiver address. This is unnecessary and wastes computational resources.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Lack of error message for query of non-existent allocation may confuse users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf",
        "body": "When an allocation does not exist for a queried user through the QueryMsg::Allocation the query_allocation function returns an allocation with empty values in query, contracts/builder_unlock/src/contract.rs:760 and 763, rather than an error message that the allocation does not exist. This may be confusing to users.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Excess liquidity pool tokens are never refunded to the user",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/vault/src/contract.rs:1084, excess liquidity pool tokens are refunded to the caller. However, the recipient should be cw20_msg.sender instead of info.sender, which represents the liquidity pool token itself instead of the original sender. Consequently, excess tokens will be transferred to the liquidity token itself, causing a loss of funds for the sender.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Malicious users can prevent stakers from withdrawing LP tokens and rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "add_reward_schedule The in contracts/multi_staking/src/contract.rs:183 allows any user to add a rewards schedule with any asset. This is problematic because a user may add a malicious token contract that returns an error when its Transfer message is invoked, eectively blocking users from being able to withdraw their funds. function In addition, this function also presents the opportunity for anyone to increase the size of LP_GLOBAL_STATE and REWARD_SCHEDULES to the point where they will return out-of-gas errors. For example, an attacker can create many CW20 tokens and send them as reward assets, causing iterations to fail due to the execution limit. Iterations that will fail can be found in the following locations:  contracts/multi_staking/src/contract.rs:295  contracts/multi_staking/src/contract.rs:357  contracts/multi_staking/src/contract.rs:403  contracts/multi_staking/src/contract.rs:570  contracts/multi_staking/src/contract.rs:615 We classify this issue as critical because both attacks would prevent users from withdrawing their liquidity pool tokens and rewards.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Numerical non-convergence might lead to erroneous computations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "the non-convergence in of The contracts/stable_5pool/src/math.rs:45-70 is not handled. A loop carries out up to 32 iterations over an approximating function, and after the iterations, the computations are carried out with the last approximating value. Consequently, the value might not be at the desired precision, which might cause erroneous computations. Furthermore, this computation is a sub-computation of another solver (calc_y in line 83), which might also lead to a situation where two approximated values of a proposed d lead to the same value in y and an erroneous convergence of calc_y. solver",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. AfterJoinResponse does not return fee value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "The in contracts/vault/src/contract.rs:749-775 includes logic to handle a fee returned execute_join_pool function in the AfterJoinResponse. Each of the current pools returns None for this value during OnJoinPool, so currently, the logic is unused. This will result in the collected fees not being sent to the protocol fee collector or the developer fee collector.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Funds in the keeper contract cannot be withdrawn",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/keeper/src/contract.rs:70-81, there is no functionality for the vault owner to withdraw funds from the keeper contract. Funds will be sent to the keeper contract as part of the protocol fees. This means that the vault owner cannot withdraw collected protocol fees.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Owner address is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/keeper/src/contract.rs:45, msg.owner is not validated before it is saved. If the address is incorrectly set and that goes unnoticed, it could result in a loss of funds once the keeper contract begins to receive funds.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Duplicate scaling factors cause ineective updates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/pools/stable_pool/src/contract.rs:74-88, the provided scaling factors are validated to ensure the asset information exists in the pool. However, no validation is performed to ensure duplicate assets are not provided. This is problematic because the update_scaling_factor function can only update the rst index, as seen in line 287. In contrast, the scaling_factors function returns the last value (see a is the old scaling contracts/pools/stable_pool/src/state.rs:57). As a result, factor the used StablePoolUpdateParams::UpdateScalingFactor message. duplicated updated despite being asset there still will via be if Please see the test_ineffective_scaling_factor_update test case to reproduce the issue. We classify this issue as major since it prevents the scaling factor manager from updating the congurations correctly.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Consider validating burn shares are greater than zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/stable_5pool/src/contract.rs:603-621, errors that occur inside the imbalanced_withdraw function are silenced, causing the shares to burn to become the a message zero. imbalanced_withdraw functionality to withdraw funds from the pool without burning the required tokens. attacker causes inside errors send that can An Due to the fact that no validation exists to ensure that the burn amount is not zero, attackers cannot exploit this like the previous issue due to the inability to burn 0 liquidity pool tokens in contracts/vault/src/contract.rs:1073. However, a code refactor might change this, such as adding an if statement only to burn shares if its higher than zero. Please see the burn_funds_free_asset test case in the appendix to reproduce this issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Users may receive unexpected mint amounts because the lp_to_mint parameter is unused",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "The execute_join_pool function in contracts/vault/src/contract.rs:694 provides the optional parameter of lp_to_mint, which allows the caller to specify the amount of LP tokens they want to get against their provided assets. This value is silently the weighted pool's ignored types. for in query_on_join_pool contracts/weighted_pool/src/contract.rs:381 ignores the _mint_amount parameter entirely and performs no checks to validate that it is met. existing pool example, function For the all This issue is found in all of the following pool types:  stable5 - query_on_join_pool - contracts/stable_5pool/src/contract.rs:392  weighted - query_on_join_pool - contracts/weighted_pool/src/contract.rs:381 The lp_to_mint is currently an unused parameter that should either be removed or enforced. The current implementation can result in the user receiving an amount of LP tokens that were not expected.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Consider verifying the developers address to be valid",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/vault/src/contract.rs:81-82, the developers address inside the fee info is not checked to be a valid address. This is problematic because the developers address is used to update the pools conguration in line 329. Other than that, executions that send the fee to the developer would fail due to an invalid address specied. We classify this issue as minor since only the admin can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Users can send more liquidity pool tokens than specied",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/vault/src:228, the second condition veries that the specied burn amount must be higher than the actual amount transferred. This is problematic because if a user sent extra liquidity pool tokens, the tokens would be stuck in the contract. For example, Alice can send 500 tokens but may only specify the burn amount as 300. As a result, 200 tokens are not refunded back to Alice due to the refund amount being determined by the burn_amount. We classify this as a minor issue since it can only be caused by user misconguration.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Users can miscongure weighted pool conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "During the contract initialization process for the weighted pool, no validation ensures the provided WeightedParams in contracts/weighted_pool/src/contract.rs:66 is valid with the asset information. The current implementation allows users to congure duplicate weighted assets, which causes incorrect nal weights. Other than that, the contract accepts a zero weight amount, causing a division by zero panic in contracts/weighted_pool/src/utils.rs:196.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Excess native funds sent are lost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "The execute_join_pool function in contracts/vault/src/contract.rs:820 calls the find_sent_native_token_balance function to get the amount of a specied denom if the pool being joined includes native funds. This check ensures that info.funds contains the specied denom, but the execute_join_pool function should also ensure that info.funds does not contain any unexpected denoms. Otherwise those excess funds would be lost.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Owner address validation is not performed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "The instantiate function in contracts/multi_staking/src/contract.rs:43 does not validate msg.owner. An address validation should occur before an address value is stored in the contracts cong. If this eld were improperly set to an invalid address, then the contract would lose all of its owner functionality. Similarly, in is contracts/multi_staking/src/contract.rs:255 before the value is passed to the bond function. beneficiary validated not",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Multihop swap lacking multiswap_request validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "execute_multihop_swap in The contracts/router/src/contract.rs:117 does not perform any validation or pre-processing on the user-supplied vector of HopSwapRequest. The user-supplied least minimal validation before the swapping callback multiswap routes should have at sequence is initiated. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Ended reward schedules consume unnecessary computation power",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/multi_staking/src/contract.rs:295-301, the compute_reward function takes all reward schedules and skips the ones that have ended. This causes unnecessary gas consumption as ended reward schedules do not need to be processed. Suppose a scenario where the number of nished reward schedules grows too large such that an out-of-gas error would occur in the compute_reward function, preventing users from withdrawing liquidity pool tokens and rewards.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. UnclaimedRewards query returns incorrect value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "the last_distributed In contracts/multi_staking/src/contract.rs:628, value defaults to the supplied block_time value if the ASSET_LP_REWARD_STATE does not exist. This is incorrect because the update_staking_rewards function defaults the value to zero, as seen in contracts/multi_staking/src/contract.rs:467. Consequently, the UnclaimedRewards query will return a lower unclaimed rewards value than it should. Please see the test_incorrect_query_unclaimed_rewards test case in the appendix to reproduce this issue. We classify this issue as minor since it only aects the UnclaimedRewards query return value.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Removing and adding LP tokens might run out of gas if too many tokens are registered",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/multi_staking/src/contract.rs:144-180, the allow_lp_token and remove_lp_token_from_allowed_list functions might run out of gas if too many LP tokens are registered. As a consequence, removing and adding LP tokens will become impossible. Only a migration of the contract allows recovery from this issue. We classify this issue as minor since it can only be caused by an admin.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Unlocking liquidity pool tokens too frequently will prevent users from claiming them",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf",
        "body": "In contracts/multi_staking/src/contract.rs:499-515, the unlock function iterates over all users unlocking positions and lters them. If a user requests to unbond their liquidity pool tokens too many times, the USER_LP_TOKEN_LOCKS for the specic user will grow too large to be processed, causing an out-of-gas error eventually. We classify this issue as minor because it is unlikely that users will unbond their liquidity pool tokens to an amount high enough to cause computation limit issues.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. A website viewed with the wallets' web browser can place arbitrary information in browser and wallet activity history",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The in-app browser allows a web page to send messages back to the application. A web-page can set any host, title url, and origin values which are later displayed in the browser and wallet activities histories. Moreover, a web page can set any arbitrary URL for its own entry in the browser history. This functionality opens possibilities for phishing attacks  a user might unknowingly navigate to a malicious URL by clicking on entries in the browser history. Additionally, the arbitrary URL set by a web page will be displayed in the wallet activities history if the web page has initiated web3 wallet transactions.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. The browser shows secure green lock icon next to URL even when the actual protocol is clear-text HTTP",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The in-app Browser always shows a green lock icon next to the URL being visited even if the is insecure HTTP. This can mislead users into thinking that a connection is used protocol encrypted, although it this issue for example through man-in-the-middle attacks or redirects to unencrypted versions of the site without the user noticing. is not. Attackers can exploit",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. It is possible to delete the wallet without providing a correct PIN",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "If an incorrect PIN is entered ten times, the application provides an option to delete the old wallet and create a new one. Since the wallet application does not require that access to a mobile device is secured by a PIN or biometric measures, a malicious actor can simply delete the wallet on a device.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Sensitive data may be logged",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The app uses Sentry for error tracking without any ltering of sensitive information. Because of that, sensitive data may be sent to external servers. If an attacker manages to get access to such a server (e.g., by compromising team members or vulnerabilities in the server), they may be able to access this data. Such attacks have happened in the past. In Cypher Wallets codebase, this could for instance happen to API tokens (in src/core/card.ts:15) or keystore information (in src/core/Keychain.tsx:107) which is included in a captured exception.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Insucient ENS name validation enables social engineering attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "Generally, it is a good idea to only allow ASCII-characters for ENS names because the same human-readable name may have multiple valid UTF-8 encodings. Attackers can abuse this to trick users into sending funds to unintended ENS names that they have registered. The following regex pattern is used in src/core/util.tsx to validate ENS names: /[-a-zA-Z0-9@:%._\\+~#=]{1,256 }\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)?/ig This pattern matches on partial strings in the middle and does not require that the whole checked string adheres to it. isValidEns will therefore return true if the string contains some non-ASCII characters in the beginning, as long as there is at least one ASCII character before the dot.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Sign-in requires signing an arbitrary message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "When using the Cypher Wallet the rst time, a sign-in to the CypherD API server is performed in the background. This sign-in requires signing a message fetched from the CypherD API server in src/core/globalContext.tsx:153. This is a security measure to ensure that the current user controls the wallet's public address. However, signing arbitrary messages can be harmful. For example, they can be used to steal funds from the user or perform malicious actions in the event of a compromised server. This issue is also observed in the following locations: - - src/containers/DebitCard/aptoCard.tsx:59 src/containers/InfoScreen/legalAgreement.tsx:44",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Outdated use of Facebook Conceal as the default secure storage option on Android",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The _setInternetCredentialsOptions function in src/core/Keychain.tsx:92 uses Facebook Conceal as the storage for the cipher. However, for Android API level 23+, the Android Keystore is the recommended storage option. Moreover, Shared Preferences together with the plain-text decryption key. in the case of Android before API level 23, an encrypted ciphertext is stored in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "8. Injected JavaScript is not veried",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The WebView that is used in src/components/WebScreen.tsx injects the content of a JavaScript le that is loaded from the server public.cypherd.io before loading the content. However, this code is not veried in any way. An attacker that manages to control the server that is responsible for public.cypherd.io can therefore distribute malicious JavaScript that is executed before every page load.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "9. Known vulnerabilities in dependencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "There are NPM packages with known vulnerabilities (which are shown when running npm audit). The output of npm audit indicates that 56 vulnerabilities were found in the audited packages. Of these vulnerabilities, 1 is rated as low, 14 are rated as moderate, 33 are rated as high, and 8 are rated as critical.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "10. The browser leaks wallet addresses to visited websites",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The in-app browser allows a web page to send messages back to the application. A web page can request user wallet addresses and this information will be provided to the web page automatically without user consent.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Users cannot set a PIN if biometrics are enabled",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The app only requires a PIN if logging in with biometric data is not activated on the device. This may be insucient for some use cases. For instance, a user that regularly shares their device may still want to set a PIN, even if they authenticate with their ngerprint or face scan.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. The Ethereum address of a user is sent to external platforms",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The Ethereum address of a user is passed as the user ID to Intercom through the Intercom.registerIdentifiedUser function. While this may make the handling of support requests easier, a user might not want to be associated with their Ethereum address, as this can result in a loss of anonymity.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Hard-coded Cosmos gas prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "the gas price for every supported chain is In src/constants/cosmosConfig.ts, hard-coded. This can lead to too high or too low gas prices. In the rst case, a user unnecessarily pays too much for a transaction. With too low gas prices, the transaction can be delayed and may fail.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. No pagination is used when querying APIs with a limit",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "a of limit with The conguration in the le src/core/globalContext.tsx contains multiple API endpoints is initialGlobalState.rpcEndpoints.COSMOS.otherUrls.balance. Besides the balances key, this endpoint contains a key pagination that contains the next URL to query if the result is larger than the limit. However, this key is ignored and only the key balances is used in src/core/cosmosStaking.tsx. In rare edge cases where the queried address has a non-zero balance for over 1,000 coins, it can happen that the desired balance is not found because only the rst 1,000 results are considered. endpoint 1,000. such One",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. The seed phrase is shared insecurely between view navigations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "src/containers/Options/SecurityPrivacy.tsx:58 and In src/containers/OnBoarding/confirmSeedPhrase.tsx:16, the loaded recovery seed phrase is passed as a navigation parameter to the next screen view via the navigate function. This imposes a potential security issue, as the seed phrase is passed unencrypted to the next screen view and could be logged by an integrated tracking plugin (e.g., Sentry or Intercom).",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. PIN code length is limited to 4 digits",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "A PIN code is used to protect the wallet from unauthorized access on Android devices and as a fallback on iOS devices in case biometric authentication is unavailable. Setting a PIN code is implemented in src/containers/PinAuthetication/setPin.tsx:34. However, the PIN code length is limited to four digits, which is considered weak.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Small entered token fractions are incorrectly parsed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "Entering token fractions with a very small USD value leads to displaying an inated USD value due to the internal representation in scientic notation. For example, entering 0.00000001 MATIC tokens with a USD value of 1.2313863e-7 USD in the send token view incorrectly shows a USD value of 1.23 USD.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Number formatting is not using the users locale",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "The Cypher Wallet does not use the decimal separator of the users current locale when entering numbers. This currently prevents entering numbers with a decimal separator other than a dot (e.g., German users may enter 1,5 instead of 1.5) and may lead to confusion. Besides misleading display issues, mobile device keyboards may have a xed decimal separator, and users might not be able to type the required decimal separator.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Static retry delay of 100ms for failed API HTTP requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf",
        "body": "In src/core/Http.tsx, the axios library is congured with the axios-retry plugin to retry failed HTTP requests with a static delay of 100 milliseconds and a maximum of 5 retries. If the request fails, this could lead to a large number of requests in a short period of time, as well as insucient time for the server to recover.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Protocol mint fees locked in factory contract for perpetuity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Edge/2022-04-23 Audit Report - Edge Protocol v1.0.pdf",
        "body": "The Edge pool contract mints eTokens to the factory contract when computing the interest accrued in contracts/edge-pool/src/borrow.rs:532. However, there is no function in the factory contract that allows the factory owner to redeem these eToken funds. The eTokens accrued during interest computations are thus locked in perpetuity.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Permissionless trade execution allows for price manipulation and arbitrage opportunities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "In contracts/pf-dca/src/execute.rs:66-81, the try_perform_dca function is permissionless, introducing a number of risks. While the execution of a single transaction might pose a small risk, i.e. a loss of funds for users due to arbitrage opportunities for another users, a coordinated attack that uses a larger amount of scheduled transactions might have a severe impact by extending (or even creating) such arbitrage opportunities to a degree that they could become market manipulations and enable the attacker to buy/sell funds at large discounts/premia. First, an attacker could use a set of scheduled transactions to manipulate oracle spot prices or TWAPs by triggering them simultaneously in a low liquidity environment. Second, an attacker can always arbitrage the slippage of the scheduled transactions by placing an order in front and behind the target transaction  a so-called sandwich attack. As the attacker can send the PerformDca message themself, this gives them the ability to write scripts that optimize for such an attack, for example reverting in the case of an unforeseen event. Third, an attacker can combine the rst two attacks for an inverted sandwich attack: The attacker could use one set of transactions to manipulate some oracle price to sell their own asset at a higher price and use a second set of transactions to provide enough liquidity to sell at the manipulated price, irrespective of the slippage limit. In addition to arbitrage, the owner might be forced to execute additional DCAs that are ready for execution when planning to cash out by having their CancelDca transaction front-run. However, this scenario will cause a minor inconvenience to the user compared to the above. The potential impact of this issue could be considered critical. We classify it as major though since the likelihood of exploitation is low as it requires a subset of the following market conditions: High slippage tolerances or large amounts of scheduled transactions within a short period of time and/or an oracle to be manipulated.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Lack of validation of conguration parameters upon instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "The pf-dca contract does not perform any validation on the conguration parameters set upon potentially causing issues that could render the contract unusable. in contracts/pf-dca/src/contract.rs:53-64, instantiation  destination_wallet address is not validated. An invalid address could cause any swap to fail as the message in line 138 will have an invalid recipient. In addition, the current implementation does not follow the documentation that states the destination wallet should default to the senders address.  source_denom is not validated. A wrong letter case of a denom or a denom that does in contracts/pf-dca/src/execute.rs:104-108 to fail, potentially leaving the amount to be swapped sitting idle in the contract. swap message exist will dened related cause not the  The destinations vector can be empty or the denoms not sanitized. This will lead to either no swaps happening at all or swaps failing.  max_slippage can be any Decimal number, even outside of the 0-100 range leading to potential inconsistencies. In addition, a high slippage is not recommended as it will allow for arbitrage opportunities as the ones described at Permissionless trade execution allows for price manipulation and arbitrage opportunities.  router_contract address is not validated, which would cause all swaps to fail if an invalid address is provided.  swap_interval can be set to zero, eectively allowing users to trigger all the swaps at once. We classify this issue as major given that none of the above parameters can be updated once the contract is deployed, which means that any of these errors require a new deployment.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. DCA end not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "The pf-dca contract does not enforce the congurations num_trades limit on the number of trades performed in contracts/pf-dca/src/execute.rs:66-121. This allows users to keep using the PerformDca message for as long as the contract has enough funds to perform additional swaps. Although not implying a security risk per se, the actual implementation diers from the implied behavior and STATE.num_trades_executed, which are not used otherwise. DcaConfig.num_trades existence the by of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. DCA execution might run out of gas if too many destinations are congured",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "the iterations performed over In contracts/pf-dca/src/execute.rs:83-86, destinations might run out of gas if too many destinations are congured. As a consequence, trade execution might fail permanently. In that case, the only way to recover the assets in the contract is the cancellation of the whole DCA.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Rounding issues on swap message creation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "The pf-dca contract allows swapping into multiple destination denoms, distributing the total amount using their assigned weight. The calculation of the nal amount to be traded to each denom is done in contracts/pf-dca/src/execute.rs:92-100. The division by total_weight is an integer division, leaving any remainder to stay idle in the contract until the user decides to cancel the DCA. This corresponds to rounding down/using the oor function. A proof of concept unit test can be found in the Appendix: Rounding issues on swap message creation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Users assets can get stuck in the DCA contract until cancelation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "pf-dca are The contracts/pf-dca/src/contract.rs:45 to satisfy that all trades contract enough checks assets only if sent   in along can be funded with the correct amount should satisfy   =   *   per trade. The documentation states that the total amount     such that it is required that the user submits the correct amount of funds. However, the code allows initializing contract with      *  , creating a possibility for  users to lock up excessive amounts of funds accidentally. The only way for the user to receive those funds back is to cancel the whole strategy, which would then require them to re-instantiate to resume the strategy with the correct amount of assets. In addition, when the swaps for a given asset fail, the remaining not swapped assets are left in the contract with no way for the user to either claim them or retry the swap. This may lead to frozen funds accumulating in the contract, unusable by the user until cancellation of the strategy.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Coarse-grained authorization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "pf-dca in The contracts/pf-dca/src/helpers.rs:7 does not follow best practices for authorization since it combines two separate entities into one layer of privileges by giving access to privileged functionality to both owner and destination_wallet. verify_sender contracts function For example, if the owner tries to pause the contract in order to stop the money ow into the destination_wallet, the destination_wallet can revert this action by unpausing the contract. The only way for the owner to prevent this is to cancel the DCA. In the future, when further functionality is added, this may lead to an overly privileged party with unintended consequences.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Commented code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "The contracts within the scope of this audit include commented code. Although not a security issue, commented code indicates that the codebase may not yet be ready for release and may negatively aect readability and maintainability. The following instances were found:  contracts/pf-dca/src/state.rs:5-29  packages/phase-finance/src/msg.rs:45-50 In addition, language potentially harmful contracts/pf-dca/src/tests.rs:135 packages/phase-finance/src/constant.rs:1. to the clients reputation was found in and",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Ineective resume and pause operations allowed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "pf-dca in The contracts/pf-dca/src/execute.rs:34 and 46 do not check if the contract is actually paused or not. resume_dca pause_dca contracts functions and Although not a security issue, pausing or unpausing a contract that is not already in that state will just spend gas without actually changing the contracts state.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "The following contract and package do not enable overflow-checks for the release prole:  contracts/pf-dca/Cargo.toml  packages/phase-finance/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Unnecessary panics negatively aect usability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf",
        "body": "In contracts/pf-dca/src/helpers.rs, the conversion from string to Uint128 is assuming valid data due to the ltering of anything dierent than numbers. There are two cases that are unhandled though:  Empty strings (when token_string is not starting with number)  Numbers that are too big to parse Those cases cause the function to panic, negatively aecting the user experience compared to error messages.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Locked funds will be inaccessible if lockdrop incentives have not been set by the end of the withdrawal window",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "is and DelegateAstroToAuction that can be executed after During ClaimRewardsAndOptionallyUnlock message handlers the withdrawal window, a users in total_astro_rewards contracts/lockdrop/src/contract.rs:827 and 910. That calculation is done in the update_user_lockup_positions_and_calc_rewards function, which contains an assertion that config.lockdrop_incentives is set and will panic otherwise in 1735. Lockdrop incentives can only be set by sending the IncreaseAstroIncentives message, which will fail after the end of the withdrawal window though. By the time this panic occurs, there is no way to recover from it, which would render any locked funds inaccessible in the lockdrop contract. calculated The same issue exists in the query_lockup_info function in line 1592. in been minted contracts/auction/src/contract.rs:618. Likewise, the auction contract contains the same mechanism  during the ClaimRewards message handler, a users auction_incentive_amount is calculated after LP shares The have update_user_incentives_and_lp_share function that performs the calculation contains an assertion that the astro_incentive_amount is set and will return an error otherwise the by fail after the LP shares have been IncreaseAstroIncentives message, which will minted. By the time this panic occurs, there is no way to recover from it, which implies that any contributed Astro and UST tokens are locked inaccessible in the contract. incentives sending These 717. only can set be in We only classify this issue as major since it can only be caused by oversight of the contract owner.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Unlocking funds may fail if a user has too many lockup positions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "all over lockup iterations update_user_lockup_positions_and_calc_rewards contains The unbounded in contracts/lockdrop/src/contract.rs:1703 and 1707. These iterations could run out of gas if a user submits many lockups for dierent pools and durations. Since the update_user_lockup_positions_and_calc_rewards function will be called when a user sends a DelegateAstroToAuction or ClaimRewardsAndOptionallyUnlock message, the user will be unable to unlock funds. There is currently no way to recover from this issue. function a positions user by The same issue exists in the query_user_info handler in lines 1453 and 1457. We only classify this issue as major since it is unlikely that users submit enough lockup positions to cause out of gas issues.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. In the event of a compromised or lost owner key funds will be locked in the contracts forever",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "The only way to retrieve delegated funds from the auction contract after the withdrawal window is closed is through an InitPool message sent from the contract owner. In the event that the owner key is compromised or control over it is lost, delegated funds will be stuck in the auction contract forever. If an attacker gains access to the key, they could extort compensation for releasing the funds. the auction contracts InitPool message also sends the EnableClaims Likewise, in message to the lockdrop contract. That message enables claims by users contracts/lockdrop/src/contract.rs:436-442. As before, a compromised or lost owner key implies that funds will be locked in the lockdrop contract forever. same mechanism in claims The contracts/airdrop/src/contract.rs:197. The issue is less problematic here, since only airdropped funds are in the contract, but still, claims will be impossible if the owner key is compromised or lost contract, enables airdrop the in Even though a compromised owner account could have other severe consequences, this issue has been added due to the high value that will probably be locked in these contracts. We still classify this issue only as minor since proper management of the owner account is assumed. The operational security of Astroport, which includes proper key management, has not been in scope of this audit though.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Liquidity migration might be prevented by target contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "The MigrateLiquidity message of the lockdrop contract triggers a withdrawal of funds from TerraSwap in contracts/lockdrop/src/contract.rs:505. In theory, the target contracts message handler could be upgraded such that the call would always revert. In that case, funds would be stuck in the lockdrop contract, with no way for liquidity migration and no way for users to withdraw their funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Issues in generator or downstream reward contracts may lead to users being unable to unlock LP tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "In the lockdrop contracts ClaimRewardsAndOptionallyUnlock message handler in contracts/lockdrop/src/contract.rs:948-954 the generator contract is queried to check pending token/reward balances. Any misconguration/issue with the generator or proxy rewards contracts (which could be caused by a downstream issue in another protocol such as Anchor or Mirror) might make this query fail, which would prevent a user from ever unlocking their LP tokens. We classify this issue as minor since a misconguration is unlikely.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Auction contract may enable claims while withdrawal window of lockdrop contract is still open which could lead to an incorrect state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "The auction contract can enable claims by sending the EnableClaims message at any time, is still open, a user calling the even before the withdrawal window is closed. to will handle_claim_rewards_and_unlock_for_lockup total_astro_rewards being set at contracts/lockdrop/src/contract.rs:910, which might not use nal values. The owner could still update a pool, which might impact the state.total_incentives_share total_astro_rewards calculation. function change would result lead and the of If it",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Staked Astroport LP will become unclaimable if generator contract is updated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "lockdrop contracts The in contracts/lockdrop/src/contract.rs:270-273, currently enables the generator contract address to be updated. Changing the generator contract address would make any staked Astroport LP at the time unclaimable after the change. This would eectively reduce all users balances. handle_update_config function The same issue exists in the auction contracts handle_update_config function in contracts/auction/src/contract.rs:200-204.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of validation on incentives share value can lead to locked funds becoming inaccessible",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "are rewards When users try to delegate Astro rewards or claim rewards and optionally unlock funds, their Astro the calculated function update_user_lockup_positions_and_calc_rewards internally calls calculate_astro_incentives_for_lockup, which will panic in contracts/lockdrop/src/contract.rs:1666 if total_incentives_share is zero. This cannot be recovered from, since pools can neither be added nor updated after the withdrawal window is closed. Consequently, any funds in the lockdrop contract will become inaccessible. function. That in We only classify this issue as minor since it is caused by a misconguration by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Updating the Astro token address may lead to an inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf",
        "body": "The lockdrops handle_update_config function currently enables the Astro token address in to contracts/lockdrop/src/contract.rs:253-256. Changing the Astro token address after users have called DelegateAstroToAuction may lead to an inconsistent astro_token updated be state between the stored values in the lockdrop contract and the balances in the Astro token contract.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Users existing balance will be inaccessible if UpdateAccounts is called with a new denom",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs:694-703, a users existing balance will be overwritten when the denom in the BatchUpdateRequest is not found in previously stored balances. This is caused by not including the existing balance when adding a new balance in line 721. Consequently, balances with denoms that were sent previously will be stuck in the contract. A test case demonstrating the above scenario can be found in appendix 2.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Fee denom deposited by user will be inaccessible if excluded from conguration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs:332-347, platform funds sent by the user will not be included as deposited funds. This is problematic since there is no validation that platform funds must be included in the allowed funds vector. As a result, users that deposit platform funds would not have their account balance updated, leading to a loss of funds. A test case demonstrating the above scenario can be found in appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Migration might fail due to out of gas error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/contract.rs:183-187, the for loop tries to process all launchers stored inside the contract. Since launchers are unbounded and cannot be removed, sooner or later the launchers' storage might grow too big to process. Consequently, this might cause the migration transaction to fail due to an out of gas error. We classify this issue as minor since it can only be caused by the owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Incorrect deposit history will be logged when users deposit into a prefund",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs:364-373, the deposit history of users that deposited into a prefund will be incorrect. Firstly, the launcher_id value is hardcoded to None in the FundingHistory although the user deposits to a prefund in line 246. Secondly, history will be empty because it is ignored, see lines 332 to 347. if config.fee_denom is not included in config.denoms vector, the deposit Thirdly, the deposit history will record the user's deposit to be lower than intended due to double platform fee deduction if the config.fee_denom is included in config.denoms vector (see lines 295-300 and 332-336). In result, deposit_history value as seen in contracts/account/src/queries.rs:72. this would cause the Investor query message to return an incorrect The above scenarios can be demonstrated with test cases which can be found in appendix 3.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Guaranteed allocation size might be incorrectly overwritten when updating congurations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "to the contracts/prefund/src/commands.rs:80-94, In of state.guaranteed_allocation_size is forcefully updated even if there's no valid update If guaranteed_allocation_size is instantiated to contain a valid Some value and one of the admins decides to update congurations that aren't related to it (e.g. the name or description), the value of guaranteed_allocation_size will be overwritten to None in line 93. As a result, return an incorrect value in contracts/prefund/src/queries.rs:46. the State query message will max_participants corresponding value. value the A test case demonstrating the above scenario can be found in appendix 4. that leads possible scenario the Another when guaranteed_allocation_size the updated_config.total_tokens_for_sale case, has updated_config.max_particpants state.guranteed_allocation_size is set to None whilst its value should get updated to the new value of total_tokens_for_sale. is a None value while has a incorrect value. Some value that an to of In",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Missing logical validations might cause unexpected outcomes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In the prefund contract, there are several cong values that are currently not validated. For example, the value of msg.end_date should be greater than msg.start_date and the value of msg.max_prefund should be greater than msg.min_prefund. If any of these values are congured incorrectly, it would cause the contract to be unusable. For example, try_allocate in function the contracts/prefund/src/commands.rs:123-129 if msg.start_date is greater than msg.end_date. would fail",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Missing address validations might lead to failures of execution handlers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In the prefund contract, there are addresses in cong values that are not validated before storing. Incorrect addresses would lead to issues when executing functions such as the prefund whitelist_contract. This issue exists during both the instantiation of contract in contracts/prefund/src/contract.rs:46-69 and updates to the cong in contracts/prefund/src/commands.rs:43-78.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Missing tax deductions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero tax rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See this discussion for more details about the tax rate changes on Terra.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. try_update_accounts allows arbitrary balance updates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs:666, the admins are able to increase any existing investors balance without any restriction limit. The team states that the amount of allocation is determined by their own Atlo rating which is calculated via an o-chain script. Since theres no validation in place (e.g. verifying the investor did invest into the prefund or making sure the refund amount lower than the deposited amount), a miscalculation in the script might cause the investor to get more/less tokens than intended. is equal to or",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Lowercasing denoms will cause issues with IBC tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs, there are several instances where token denoms are converted to lowercase via to_lowercase. Since token denoms are case sensitive, the contract will be unable to support IBC tokens.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Prefund deposit amount needs to be greater than intended",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/commands.rs:333-316, users deposited funds are deducted twice even though they have already been deducted in lines 295 to 300. This causes an unnecessary requirement that the prefund deposit amount must be greater by twice the value of platform fees. There might be a possibility that the users deposit is rejected due to insucient funds.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Possibility of duplicate denoms in conguration is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In contracts/account/src/contract.rs:43, denoms are added into the cong during contract instantiation phase. If the admin decides to add custom denoms via passing a valid msg.denoms vector, the corresponding denoms function will not remove duplicate denominations from the vector. Consequently, there is a possibility that the same denom is added twice to the config.denoms vector, which is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Users can deposit into inactive/ended launchers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf",
        "body": "In the accounts contract, a value is stored to keep track in which state the launcher is. However, the launchers state does not get automatically updated nor does it get used to validate whether the given launcher id should receive investments or not. Hence, an investor may invest in a launcher that has ended, which would lead to a failure when allocating the funds, because the prefund contract checks for the end_date. To resolve this issue, the admin would need to withdraw funds from the prefund contracts individually.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Delays in the execution of UpdateExecutor transactions could temporarily inhibit the capability of the protocol to execute requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "the The guard in contracts/registry-stake/src/contract.rs:338 checks if current epochs executor is set or not, ensuring that update_executor is called before execute_request for the new epoch. Since transaction order from the mempool is not deterministic, the capability of the protocol to execute requests will be temporarily inhibited until an UpdateExecutor transaction is executed.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. stakes vector could exceed the CosmWasm VM memory limit when loaded",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "In contracts/registry-stake/src/state.rs:68, the stakes attribute is dened in the State struct as a vector of strings. This implies that every time the read_state function is invoked, all the State data, including the stakes vector, is loaded into memory. Since the stakes vector has no maximum length, the CosmWasm VM memory could not have enough space available to load it resulting in an execution panic. A bad actor could intentionally use this issue to cause any interaction with the protocol to be very gas intensive, up to the point where any interaction will run out of gas. With current parameters on Osmosis, the cost of this attack would be in the millions of US dollars. While this might still be economically viable, we classify this issue as major, since it can be resolved with a contract upgrade.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Unstake transactions are likely to fail if more than one of them is processed in the same block",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "Unstake in The contracts/registry-stake/src/contract.rs:635-698, takes as input parameter a vector of numeric indexes that represent the users stake slots in the stakes vector. transaction handler, dened In order to process the deletion of the vector data at the provided indexes within an O(1) asymptotic cost, the swap_remove function is used. This method performs a delete substituting data in the selected index slot with the data stored in the latest element of the vector. Consequently, a removal of one element aects also the ordering of the elements stored in the latest positions of the vector. If we have more than one Unstake transaction in the same block, the indexes for any subsequent positions might be wrong, leading to an error, or, if the same sender controls the position, to the deletion of the wrong position. This implies that the likelihood of an Unstake transaction to succeed depends on dierent unpredictable factors like:  The order of transactions in a block  The cardinality of Unstake transactions in a block  The distance of the index to the end of the stakes vector The likelihood of having a transaction error increases drastically on particular events, for example a market crash where users may want to exit funds from the protocol quickly. Additionally, bad actors can grieve users by staking many small amounts, and then front-running others to cause unstake failures. This could be used together with a short of the tokens to attack the whole protocol and prot from a panic in users.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Protocol is prone to censorship",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "The guard dened in contracts/registry-stake/src/contract.rs:342-347 ensures that only the currently elected executor can submit the ExecuteRequest message. This implies that the currently elected executor is not participating, the protocol will be stuck for the entire epoch with no executed requests. responsive and actively if Since every AUTO token holder can stake its tokens and participate in the election, there is a possibility that the executor could be an inactive protocol participant. Also, a malicious actor could stake a large amount of tokens in order to intentionally stop the requests execution, causing all or targeted executions to get delayed. This is particularly impactful for users and attractive for attackers if requests contain trading transactions that require to be executed in a timely manner. Usually, in proof of stake (PoS) systems, such actors would bear an economic cost such as infrastructure maintenance, cost of staked capital, and third-party delegation loss. Also, in this case, it is required to deposit the stake in the contract only for one block since there is no unbonding period, reducing the attackers capital cost and making the attack cheaper with respect to other PoS systems. In fact, in contracts/registry-stake/src/contract.rs:635-698, the Unstake message handler allows the currently elected executor to unstake all of its stake slots without losing its role. Consequently the executor can be in charge of its role without having its stake deposited in the protocol. This would allow an attacker to get an AUTO loan, stake and be elected, unstake, repay the loan and act as an inactive executor in order to stop requests execution without having to hold or loan tokens for long. Also, it is worth to note that in contracts/registry-stake/src/contract.rs:645, during the handling of the Unstake transaction, the executor election is done before removing the unstaking users address from the stakes vector. This implies that an unstaking user could be elected as the current epoch executor without having capital at risk stored in protocol. We classify this issue as minor since the client intends to set the epoch length to 100 blocks, which corresponds to 10 minutes on Osmosis and is low enough to reduce the impact of an attack. Still, market manipulation even over a short time window may be exploited.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Partially implemented tax deductions may lead to failures if tax rates are updated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "In packages/autonomy/src/asset.rs:44-46, used to calculate taxes to be paid when transferring native coins, always returns zero. the compute_tax function that is Consequently it is not eective and future changes in the Osmosis (or another) chain could inhibit the execution of requests submitted in the registry.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Contracts are not compliant with CW2 Migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "The following contracts do not adhere to the CW2 Migration specication standard: a) registry-stake b) wrapper-osmosis This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. AssetInfo struct is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf",
        "body": "In contracts/registry-stake/src/contract.rs:61, representing the AUTO token provided during the instantiation is stored without validation. the AssetInfo struct Since this struct contains an address, it should be checked to ensure that it is a valid one.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. First depositor can be front-run for unfair prot causing direct losses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The hub contract does not prevent the rst depositor from being front-run to eectively get fewer shares than planned from which the attacker will prot. In contracts/hub/src/math.rs:36-38, the number of shares that a user receives depends on ustake_supply, uluna_to_bond, and uluna_bonded. However, if a malicious depositor makes a large enough donation to the vault at the right time, increasing uluna_bonded, the next depositor will not receive their expected amount of shares. The below describes a potential exploit scenario that could be followed by an attacker Mallory to take advantage of a victim Alice: 1. Upon identifying that Alice is trying to make the rst deposit of X uluna into the hub contract, Malloryfront-runs their transaction with two calls: a. Making a minimal initial deposit, let's say 1 uluna, to obtain one unit of shares and setting ustake_supply to one. b. Donating a number of tokens to the contract equal to X/2 uluna, increasing the bonded_luna value without increasing ustake_supply",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Mallory will then be able to return the share to get 1/2 + 3x/4 uluna after having spent just 1 + X/2 uluna, eectively proting X/4 uluna. Note that this issue is only exploitable at the beginning of the contracts lifecycle and does only aect the rst user making the deposit. However, as the potential loss of funds can be substantial we classify it as critical. Recommendation We recommend performing the rst deposit atomically upon contract deployment. Their rst deposit should be large enough to limit the impact of the described exploit. Status: Resolved 2. Underow upon slope calculation may lead to unreliable voting power",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Unharvested rewards not accounted for in compute_mint_amount function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "compute_mint_amount at the The contracts/hub/src/execute.rs:144, does not take into account unharvested rewards when calculating the mint amount for a new user. As the protocol reinvests rewards, these belong to previous users, and new users are also given a share of these new rewards. contract, function located hub of Protocol users have a natural the harvest function to minimize any unharvested rewards getting distributed to other users. We classify this issue as minor, since the client states it is expected behaviour and that they will explain this in the user interface. incentive to call",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Period rounding can lead to undesired results",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The function create_lock converts a timestamp into a number of periods to get the current blocks period (variable block_period) and to calculate the number of periods for the lock rounding occurs which can lead to (variable periods). unexpected and potentially undesired results. these operations, In both of The rounding down of block_period means that the start of the lock could be set to the current period. Because of that, the minimum number of periods will not be strictly enforced. For instance, if a user creates a lock just before a period ends, the capital is locked up for one week less than if he creates a lock just after a period starts. On the other hand, the rounding down of periods may confuse a user. If a user species a time that corresponds to 3.99 weeks, the lock will only be created for three periods (three weeks).",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Lack of validation of embedded logos",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The voting-escrow contract does not validate_marketing_info contracts/amp-governance/voting_escrow/src/marketing_validation.rs :52-69. validate embedded logos during its in function If an embedded logo is submitted on instantiation it will be saved without any further check. This is not the case for the execute_upload_logo function of CW20, which successfully validates all cases through validate_logo.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of validation upon instantiation of the Hub contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The hub contracts instantiation function in contracts/hub/src/execute.rs:33 lacks some validation steps of epoch_period and unbond_period. In addition, the list of validators stored in line 49 is checked for duplicates but it does not actually validate addresses to be those of active validators. The same situation is found in the add_validator function in lines 666-682. We classify this issue as minor since instantiation parameters are usually reviewed with care by a privileged user or development team before deployment.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Insucient validation in address blacklisting function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The voting-escrow contracts update_blacklist function checks that the two vectors provided as arguments, append_addrs and remove_addrs, do not clash with the current contents in the contracts/amp-governance/voting_escrow/src/contract.rs:707-714. However, it does not check if addresses are duplicated within each vector or if an address is part of both at the same time. blacklist of Duplicated addresses in append_addrs cause minor ineciencies as those will be saved into the storage, unnecessarily growing it with no purpose and opening a window for future inconsistencies. This limited impact in line 744, as processing the rst instance of any address causes the cur_power of duplicated iterations to be zero. is mitigated by the if statement On the other hand, duplicates in remove_addrs have a real impact as there are no checks in place to avoid repeated calls to the checkpoint function in line 778. This leads to additional accounting in voting power in line 347 linked to the blacklisting of the same address,  compromising the integrity of the scheduled slope changes and the stored Point. For addresses that are present in both vectors, the function rst appends addresses and then removes them. If, by mistake, the same address is part of both, that address will not be contained in the nal blacklist without the owner or guardian being aware of this situation. Although the impact of this issue can be considered major, the function is restricted to privileged addresses which are less prone to error in general. Therefore, this issue has been raised as minor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Coecient calc implementation diers from documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "calc_coefficient The in packages/eris/src/helpers/slope.rs:6-10 is documented with the following line: Coefficient to 1 and [`MAX_LOCK_TIME`] is 9. However, the actual implementation does not adhere to this comment as when the interval is zero weeks, the returned value will be zero instead of one. calculation [`WEEK`] function where equal found is This issue has been raised as informational as every instance that calls the aected function checks the supplied interval to not be zero before or cant be zero given the contracs logic.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Widespread usage of generic errors in the Hub contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The error handling in the hub contract is based on StdError::generic_err instead of declaring custom errors, as opposed to the voting-escrow contract which mostly relies on custom errors. Although not a security issue, dening individual generic error messages decreases maintainability.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Lack of drop proposal function on owner transfer mechanism",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The hub contract implements a two-step transfer mechanism for updating the owner in order to remove a new_owner address address, submitted by mistake, the current owner would have to call transfer_ownership again and overwrite the address. following best practices. However, Although eective in practice, purpose of clearing this value.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Hardcoded denom and EPOCH_START",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The hub contract makes use of the CONTRACT_DENOM constant to set the denom in multiple instances, following best practices. However, the following instances have been found to use a hardcoded uluna string instead of the CONTRACT_DENOM constant:  contracts/hub/src/types/staking.rs:44, 67, 93  contracts/hub/src/queries.rs:80 Although not a security issue, it impacts maintainability and may lead to errors in the future, such as a partial change of denoms throughout the codebase. In addition, the code in packages/eris/src/governance_helper.rs:16 denes a variable EPOCH_START with a specic value assigned to it. It is important to make sure that this value is correct and intended for the specic use case before deploying the code to production, as it may need to be adjusted or replaced with a dynamic value that can change over time.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Optimization in compute_undelegations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "iterates over merge_with_validators in The hub contract uses a loop that if the variable uluna_to_undelegate contracts/hub/src/math.rs:86. However, is set to zero, the subsequent computations on lines 91 and beyond will have no eect, wasting computational resources.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Outdated documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "README type The ExecuteMsg::SubmitUnbond, which does not exist and was, presumably, replaced by ExecuteMsg::SubmitBatch. mentions message folder hub the le in a",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Unnecessary conversion to lowercase in addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The contracts within scope used the addr_validate_to_lower helper function to sanitize addresses, found at packages/eris/src/helper.rs:25-31. Since CosmWasm 1.0.0, the addr_validate utility also validates address capitalization, hence making it redundant to perform this check manually.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Incorrect comments and typographical errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "The following incorrect comments and typographical errors were found in the audited codebase. Although not security related, they decrease documentation quality and readability of the codebase:  contracts/amp-governance/voting_escrow/src/contract.rs:724 accumulator for old slopes instead of accumulator for old amount.  contracts/amp-governance/voting_escrow/src/state.rs:17 list of whitelisted logo urls prexes instead of list of contracts to receive updates on user's lock info, or something similar.  contracts/amp-governance/voting_escrow/src/state.rs:44 the timestamp when the lock position starts instead of the period when the lock position starts  contracts/hub/src/contract.rs:141 must be 1-2 instead of must be 1  contracts/hub/src/execute.rs:305 and 309 validatiors instead of validators",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Commented code",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf",
        "body": "A commented function was found in packages/eris/src/helpers/slope.rs:20-24. Although not a security issue, commented code decreases readability and may cause issues if re-introduced in the future without being properly re-architected.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Removing merchant does not remove associated deposit addresses",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "the In the contracts/wbtc-controller/src/auth/merchant.rs:45-66, remove_merchant function does not remove the merchants associated deposit addresses and from MERCHANT_DEPOSIT_ADDRESS storage. When a merchant is removed, they should no longer have the associated roles assigned. However, the GetCustodianDepositAddress and GetMerchantDepositAddress queries will show that the removed merchant still has a valid deposit address on the Bitcoin blockchain. CUSTODIAN_DEPOSIT_ADDRESS_PER_MERCHANT",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Approving mint requests does not ensure the requestor still holds the merchant role",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "In contracts/wbtc-controller/src/contract.rs:149-189, when approving a pending mint request, no validation ensures that the requester still holds the merchant role. For example, consider a scenario where the member manager revokes the merchant role post the issuance of a mint request. The mint requester, no longer holding the merchant role, should not be permitted to receive WBTC. However, due to a lack of validation when the custodian approves the mint request, the requester can still receive WBTC even though they no longer hold the merchant role. We classify this issue as minor because the custodian is considered a privileged and trusted role.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Incorrect governor attribute value emitted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "In contracts/wbtc-controller/src/contract.rs:58, the governor attribute value is emitted as info.sender. This is incorrect because the governor's address is set to msg.governor, causing o-chain event listeners and blockchain indexers to record incorrect data.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Merchant deposit addresses are not ensured to be unique",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "In contracts/wbtc-controller/src/tokenfactory/deposit_address.rs:67-9 1, the set_custodian_deposit_address function does not ensure that the provided deposit_address is unique across merchants. This could lead to a custodian mistakenly assigning the same deposit_address to multiple merchants. A malicious merchant could exploit this if the custodian unsuspectingly assigns an existing address to the malicious merchant. The malicious merchant could then issue duplicate mint requests with a transaction identier of the duplicate address. Assume the custodian sets the same deposit address for two merchants. The rst merchant sends BTC to the deposit address. The second merchant did not make a deposit, but they took the rst merchant's transaction identier and issued a mint request for themselves. Since the deposit address for the second merchant matches the transaction identiers receiver address, the custodian might approve this deceptive mint request. We classify this issue as minor because it requires a misconguration by the custodian, which is a privileged and trusted role.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Separation of privileged addresses is not enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "While extensive eort has been made to dene privileged access roles within the protocol, privilege separation of these roles is not properly enforced. Currently, no validation exists to enforce that these privileges are designated to unique addresses. In the unlikely case of a compromised account, privilege sharing will have severe implications. While this measure cannot prevent account compromise, it can limit the impact and serve as an additional layer of security for the protocol. Another step that can be taken to reduce the impact of a compromised account is to implement timelocks to prevent frequent updates of addresses.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Attributes are not properly emitted during contract instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "instantiation process, During the contract the initialize_governor function in contracts/wbtc-controller/src/auth/governor.rs:16 returns attributes, but they in contracts/wbtc-controller/src/contract.rs:44. function calling used are not the by Consequently, the attributes will not be properly emitted during instantiation.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. GetMintRequestsCount and GetBurnRequestsCount query fails when there are no mint or burn requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "In the contracts/wbtc-controller/src/tokenfactory/nonce.rs:30-33, custom get function returns the stored nonce value in the storage using the load function. the Since the load function fails when there is no previously stored value, GetMintRequestsCount and GetBurnRequestsCount queries will fail when no mint or burn requests are issued.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Typographical error aects codebase readability",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "In contracts/wbtc-controller/src/tokenfactory/deposit_address.rs:12, be the DepositAddressManager. DepositAddressMananger wrongly occurs, should which typed While the typography error doesnt aect the code functionality, it increases the chances of introducing mistakes that can be easily avoided.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Storage entries spread across multiple les increase the chances of storage key collision",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf",
        "body": "The contract contains multiple storage entries that are dened in separate les. While this does not aect increases the likelihood of accidental storage key collisions. One common pattern is consolidating all storage entries into a single le, increasing code readability and reducing the likelihood of storage key collisions. the code quality, it",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Astral assembly does not impose negative consequences for creation of low-quality or malicious proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "The end_proposal function in contracts/assembly/src/contract.rs:330 returns the proposal creators funds regardless of the outcome of the proposal. This does not provide any disincentive for submission of malicious or spam proposals, which could allow malicious actors to grief the assembly contracts.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Link validation allows for non fully formed domains to be whitelisted",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "validate_links The in packages/astroport-governance/src/assembly.rs:387 performs validation on whitelisted links during instantiation and cong updates. Currently, the validation criteria for links is related to the characters of the string. This is potentially problematic when viewed in conjunction with how proposal links are checked against the whitelist. function is link proposal validation in The packages/astroport-governance/src/assembly.rs:280. the whitelisted links are used as a prex validation for the proposal link. This can be problematic if the whitelist contains entries that are not FDQNs (fully qualied domain names). Specically, if it will allow an attacker to create a the link does not contain a TLD (top level domain), if the whitelist malicious domain that will still pass the whitelist validation. For example, contains https://astroport, attackers could register a domain that shares the same prex such as https://astroport-gov.com or a domain that has a dierent TLD such as https://astroport.xyz to conduct an attack. handled Currently,",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. No minimum value for voting quorum in cong validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "the contracts assembly the In instantiate and update_config functions apply a maximum quorum size during cong validation. However, no validation is performed to ensure that the minimum quorum size is not below a sensible threshold. contract/assembly/src/contract.rs, in This could enable the quorum threshold to be set to a level whereby proposals could be passed without a signicant proportion of the total token supply being involved in the proposal.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Unbounded loop could run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "function The in contract/escrow_fee_distributor/src/contract.rs:284 uses a loop and break conditions to calculate the claim amounts from the last claimed period to the current period. calc_claim_amount found In the case that claims are not processed for a long period of time this loop may run out of gas and become unexecutable. However, due to the unlikelihood of this occurring and the fact that it would only aect one user the severity is noted as minor.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. New owner proposal minimum and maximum expiry times",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "The function propose_new_owner in packages/astroport/src/common.rs:34-67 enables the current owner of a contract to propose a new owner who is subsequently able to claim the contract ownership. The original owner species an amount of time, expires_in, during which the proposal is claimable. However, there are no minimum or maximum requirements to the amount of time that the proposal can be active for. This could lead to a proposal that expires immediately preventing a proposed owner from claiming or alternatively a claim being active for excessives periods of time.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Incorrect attribute emission during pool deactivation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "of execution in The upon contracts/tokenomics/generator/src/contract.rs execution. However, the attribute action of that event is incorrectly dened as setup_pool. This could lead to event listeners or other queries from being unable to identify blocks that contain deactive_pool messages. deactive_pool function event emits the an",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Updating the expiration period can lead to unexpected behavior of live proposals",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "the function in In contract/assembly/src/contract.rs:532 the expiration period can be updated. Doing so would also alter the expiration period of live proposals. This could have the consequence of live proposals ending much sooner than anticipated and lead to operational issues. update_config found",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Update of factory contract owner may cause inconsistency",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "execute_create_pair The in contracts/factory/src/contract.rs:352 instantiates a new pair contract, with the admin set to config.owner. This may be problematic as config.owner is an updatable value which may lead to a pair contracts admin being dierent from the factory contracts owner. function Note, that the scope of this issue is related to migrations of the pair contract. This means that the previous owner of the factory contract will remain the admin of the new pair contract and can perform contract migrations. This situation is not inherently malicious or exploitable, but it does present a situation where it becomes dicult to manage the migration of multiple pair contracts with potentially many dierent owners. the previous owner are compromised An extreme scenario where the private keys of presents room for human error since every pair would need to have the admin manually updated.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Blacklist design presents centralization concerns",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "a The receive_cw20 function in contracts/voting_escrow/src/contract.rs:447 implements CreateLock, ExtendLockAmount, and DepositFor functionality. While this does not pose a direct security threat, it allows the owner and guardian_addr to control which addresses have voting power. This raises concerns around centralization of the protocol. blacklist_check control access the to to",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Use of magic numbers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "In the factory contract in packages/astroport/src/factory.rs:61, numbers are used without context for calculations  so-called magic numbers. Usage of magic numbers is problematic since they decrease the maintainability of the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Duplicate zero amount check is inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "the in In contracts/escrow_fee_distributor/src/contract.rs:182-216, claim amount is validated during the creation of the transfer message to ensure it is not zero. This check is repeated in the function transfer_token_amount in line 204. This is inecient. function claim the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Contract should return error if boolean parameter is updated to the same value that is currently set",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf",
        "body": "update_config The in contracts/escrow_fee_distributor/src/contract.rs:377 allows the owner to update the contracts conguration parameters. To improve the user experience, the function should return an error if the value of is_claim_disabled is updated to the value that is currently set to inform the caller that the value has not been changed. function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Lack of token whitelist validation when swapping and creating a position or executing a strategy may lead to loss of user funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "In ethereum_hardhat/contracts/EthereumManager.sol:412 and 478, the swapTokenAndCreatePosition and swapTokenAndExecuteStrategy functions allow users to swap tokens and create or execute a strategy based on the provided strategy and chain identier. However, there is no validation that makes sure the swapped token toToken is whitelisted for that strategy identier strategyId and chain identier strategyChainId. and the createPosition function in line 391 veries that the assetInfos, In contrast, the strategyId, isTokenWhitelistedForStrategy mapping in line 277 to ensure the assets are whitelisted the and strategy validateAndTransferAssetFromSender function. strategyChainId arguments specied identier using chain valid are the via for The impact of this issue depends on how the contract on the other chain handles the non-whitelisted token. A possibility that might happen is that the recipient contract will reject the sent VAA message because the strategy does not support the asset token, causing a loss of funds for the sender.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Contracts are not compliant with CW2 Migration specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "The smart contracts do not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Inability to update the admin address of the terra_manager prevents incidence response",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "In contracts/terra_manager/src/contract.rs, the admin address is saved in the storage in the instantiate message. After that, the admin cant change its address. This may lead to severe implications if the private keys controlling the admin account are ever compromised, in which case an update of the admin address would help to prevent exploits.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Missing allowance check when executing a strategy with CW20 token causes meaningless error message",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "In packages/aperture_common/src/token_utils.rs:47, when creating the message to move assets from the sender to the current contract, the execution uses a cw20::Cw20ExecuteMsg::TransferFrom. This type of message requires that the sender provided an allowance for the spender contract. If no allowance is granted, message execution will fail without a meaningful error message.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Missing tax deductions",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero tax rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See this discussion for more details about the tax rate changes on Terra.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Cross-chain fee BPS value may be set to be larger than MAX_CROSS_CHAIN_FEE_BPS",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "the ethereum_hardhat/contracts/EthereumManager.sol:119, In the not _crossChainFeeBPS MAX_CROSS_CHAIN_FEE_BPS value as seen in line 131. As a result, an admin setting a _crossChainFeeBPS higher than MAX_CROSS_CHAIN_FEE_BPS will cause the calculated cross-chain fee in line 328 to be larger than intended. validated below value be to is",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Usage of deprecated safeApprove function opens up front-running possibilities",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "In ethereum_hardhat/contracts/EthereumManager.sol:187 and 338, the safeApprove function is used to give approvals for other contracts to use the current contracts token balance. However, the safeApprove functionality is deprecated as it opens up possibilities for sandwich attacks similar to the classic ERC20 approve() function.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Custom implementation of admin role increases code complexity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "In contracts/terra_manager/src/contract.rs a custom implementation of an admin role is used. Using a battle-tested reference implementation reduces the complexity of the codebase.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Removing a strategy from terra_manager may lead to unlinked data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "contracts/terra_manager/src/contract.rs:63, executing the selected strategy metadata is removed from when In ExecuteMsg::RemoveStrategy, STRATEGY_ID_TO_METADATA_MAP. As positions in POSITION_TO_STRATEGY_LOCATION_MAP are potentially pointing to a deleted strategy, this may lead to partial/unlinked data in the storage.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "contracts/terra_manager/Cargo.toml The overflow-checks for the release prole. package does not enable While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Re-entrancy guard TODO comment in Solidity codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf",
        "body": "ethereum_hardhat/contracts/EthereumManager.sol:290, an In outstanding TODO comment indicating whether or not to implement a reentrancy guard in recordNewPositionInfo functionality. If the reentrancy guard is not applied, an attacker can keep reentering recordNewPositionInfo functionality, allowing the attacker to create fake positions under them. That said, there arent direct security risks since the rest of the code execution validates the attacker sent assets as specied in the assetInfos and fromToken argument. theres",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Lottery is (almost) never considered started, allowing user interaction during a running lottery which will lead to inconsistent contract states",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "In several places in the lotto contract, the condition !current_lottery.rand_round == 0 is used to determine whether the current lottery has been started. That condition will never return true though, since !current_lottery.rand_round is evaluated rst, leading to a binary not operation on the unsigned integer, which is in almost all cases not equal to 0. The condition is found in contracts/lotto/src/contract.rs:228, 366, 567, 658, and 807. This issue implies that deposits, gifts, withdrawals, sponsor withdrawals and claims are still possible while a lottery is running, leading to an inconsistent contract state.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Combinations beginning with 99 will not receive their prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "In the execute_prize function of the lotto contract, winners are determined with a storage iteration in contracts/lotto/src/prize_strategy.rs:181. The iteration starts at the rst two digits of the winning sequence of the lottery and ends at the next integer, excluding that number. For the case of the starting digits 99 though, the next integer would be 100, which is reduced to 99 in line 175. The iteration uses an exclusive upper bound in line 185, which means that the iterator would go from 99 to 99, and hence nish directly without any iteration. That implies that any combination starting with 99 will not be determined as a winner, which is incorrect. Conversely, no winners will be stored if the winning sequence starts with 99.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Lotto contracts incremental glow emission rate may be bypassed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "lotto contracts The contracts/lotto/src/contract.rs:885 glow_emission_rate. Updates are increments/decrements GlowEmissionRate query. of the determined that execute_epoch_ops used is function to update glow_emission_rate are done through the distributor in the in contracts The execute_epoch_ops function has no access control and no rate limit though, which means that any user can call it repeatedly to bypass incremental adjustments.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Claiming deposits from the lotto contract can run out of gas if a user has many unbonding info entries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "During the lotto contracts claim_deposits function, an unbounded iteration happens over a depositors unbonding_info vector in contracts/lotto/src/helpers.rs:44. If In the current that vector contains too many entries, implementation, that issue cannot be recovered from, which leads to a user being unable to retrieve their funds back. run out of gas. the call will While this issue can lead to inaccessible user funds, we do not classify it as critical since it is very unlikely for a user to have a large number of unbonding_info entries. It is still possible, for example, if another contract builds on top of Glow and withdraws in quick successions.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Exchange rate queries in lotto contract may receive outdated values, leading to share uctuations and unused UST stuck in the contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "or In multiple places in the codebase, Anchors aUST/UST exchange rate is queried through an EpochState query and then used calculate the aUST/UST value of deposited, gifted, sponsored (in contracts/lotto/src/contract.rs:260, 399, 507, 580, 674, and 74). The query does not include the current block number though. Without a block number, Anchor returns the exchange rate based on the last interest computation, not the latest one. That implies that the actual exchange rate may be lower than expected, with the following consequences: UST/aUST withdrawn execution during lottery and  During deposit, gift, and sponsor, the stored share will be higher than the actual aUST received. That will cause the shares to vary slightly between depositors.  During withdrawal, sponsor withdrawal, and lottery execution, too much aUST is burned, leading to unused UST stuck in the contract. Additionally, in the withdraw, sponsor_withdraw and execute_lottery functions the UST amount sent back from Anchor will have taxes deducted, while the amount used in the lotto contracts calculations is not considering taxes. That causes too many funds to be distributed, which implies that the last users will not be able to claim their deposits back due to the condition in contracts/lotto/src/contract.rs:863.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Winning sequence calculation may panic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "The winning sequence of a lottery is determined in the sequence_from_hash function of the lotto contract function, a hexadecimal string is ltered by decimal characters, and then the resulting string is sliced into the winning sequence. That slicing is done by index access of the string in line 16, which will in contracts/lotto/src/oracle.rs:14. Within that panic if the ltered string is shorter than 6 characters. Since a hexadecimal string can contain no single decimal character (an example is 0xaaaa..aa), such a panic will eventually occur. We consider this issue not to be critical since it is very unlikely and recoverable by triggering the execute_prize function again, which should result in a dierent hash and resolve the issue.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Updates of the lotto contracts split factor cong value will leave user funds inaccessible and lead to errors during award calculation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "the function in of In update_config contracts/lotto/src/contract.rs:1010, the split_factor can be updated. That split_factor is used during deposits/gifts and withdrawals to update the pools lottery_deposits, lottery_shares, and deposit_shares values. If it is changed while the lotto contract holds any user deposits, any subsequent withdrawal will apply a dierent split_factor and hence lead to an inconsistent state. contract lotto the That implies that the subtractions in contracts/lotto/src/contract.rs:737-738 will panic for the last users trying to withdraw their tokens, leaving them unable to access their funds. Additionally, the execute_lottery function in contracts/lotto/src/prize_strategy.rs:69-102 would lead to unexpected errors. the award calculation of We classify this issue as minor since it can only be caused by the contract owner.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Winner prize calculation will leave inaccessible division remainder in lotto contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "During the lotto contracts winner prize calculation, integer division is used to determine the prize for the winner in   contracts/lotto/src/helpers.rs:78. That integer division will leave a remainder in the contract, which is inaccessible by anyone.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Lack of prize distribution validation in lotto contract could lead to too high prizes distributed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf",
        "body": "The prize_distribution passed to the lotto contracts instantiate function and used in contracts/lotto/src/contract.rs:71 is not validated. If the sum of its items is greater than one, higher prizes will be assigned to winners than available, and the last winners to claim their prizes will run into an InsufficientClaimableFunds error. We still classify this issue as minor since it can only be caused by the owner during instantiation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Written signed state hash may use stale data",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/pTokens/20210518_pNetworks Enclaves Integration Audit Report.pdf",
        "body": "In src/main/java/io/ptokens/database/DatabaseWiring.java:188, the writeSignedStateHash method is called after the database transaction is ended in line 183. If any data is written between that end of the transaction and the data retrieved within writeSignedStateHash, the signed state hash references stale data and cannot be trusted.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Liquidity token price source does not work with Osmosis pools",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "In packages/abstract-os/src/objects/price_source.rs:222-226, the liquidity pool token asset must be a CW20 token, or else an error will occur. This is problematic because Osmosis uses native tokens as liquidity pool tokens (e.g., gamm/pool/1), preventing root users from conguring PriceSource::LiquidityToken asset value calculation for Osmosis-based pools.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. API contracts cannot use reply handlers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "In packages/abstract-api/src/endpoints.rs, is not registered for Abstract APIs. This means the API contracts reply entry point will not be executed even if dened, causing the transaction to revert. the reply entry point We classify this issue as major because it aects the correct functioning of the system.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Installed modules can execute arbitrary Cosmos messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The proxy contract allows whitelisted modules to execute arbitrary messages through the ExecuteMsg::ModuleAction entry-point handled by the execute_module_action function in contracts/core/proxy/src/commands.rs:19-33. As a result, any ill-intended module could perform high-impact actions on the proxy, such as stealing all funds. Similarly, the execute_ibc_action function in lines 37-63 allows arbitrary execution of Cosmos messages over IBC with a similar impact.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Root users updating module addresses might cause inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "update_module_addresses in function The contracts/core/manager/src/commands.rs:46 allows the caller to update the OS_MODULES map directly. This privileged function is intended for contract-to-contract interaction in which the caller likely performs lookups and validations on the message parameter. For example, the manager contract calls this function internally through the register_module and set_migrate_msgs_and_context functions. In contrast, the root user should not call this function to update the module addresses as it could introduce unintended consequences to their OS, for example, if:  The new address is not whitelisted in the proxy contract using the whitelist_dapp_on_proxy function.  The old address is not removed from the proxy contract using the remove_dapp_from_proxy_msg function.  New modules that require dependencies to work are directly set instead of using the intended install procedure via the install_module function.  Modules are removed without checking their dependents from the DEPENDENTS storage state.  The root user bypasses validation in contracts/core/manager/src/commands.rs:87-89 by directly calling the module factory contract. This can be achieved by updating any dummy name to the module factory contract address via the update_module_addresses function and the install_module functions using the ExecOnModule message to forward the message to the module factory contract to register the module.  Duplicate addresses are provided within the to_add vector which would only cause the last one to be stored. While most of these examples may not cause signicant issues, not automatically removing an old module from the proxy contract would allow it to execute commands via execute_module_action even though the OS_MODULES storage state is modied.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Migration to an older version is not prevented and may lead to state inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "an for multiple contracts in scope does not prevent a contract The migrate entry point migration and version. Currently, older to migrate_module_data functions are only executed when the contract is being migrated to a newer version. In the case that a migration is performed to an older version, no error would be raised, causing the new version of the contract to not be set, and the module data would be silently not migrated to the next version. set_contract_version the  contracts/core/manager/src/contract.rs:34  contracts/core/proxy/src/contract.rs:65  packages/abstract-app/src/endpoints/migrate.rs:41 In addition, the migrate function does not check if the contract name is indeed the same. In case of a mistake when selecting the code ID, the contract instance could be migrated to a dierent contract. We classify this issue as minor since only the root user can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Governance type lacking validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "When the os-factory contract instantiates the manager contract, the governance type is converted to a string. Then it is passed to the os_info as a string. This conversion is made, but the governance type should only support Monarchy and External, which are the two variants in by packages/abstract-os/src/objects/gov_type.rs:9. GovernanceDetails supported enum the set_root_and_gov_type in The contracts/core/manager/src/commands.rs:239 allows this value to be updated directly by the root user as a string. Hence, its value can diverge from the enum variants. function for Similarly, the instantiate function also takes this piece of data as a string instead of an enum without further validation.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. subscriptor_address is not updatable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "contracts The manager contract implements the subscriptor_address role to suspend most of in function However, the contracts/core/manager/src/commands.rs:407-427 does not allow for this address to be updated. update_info functionality. the is best practice to allow updates of privileged addresses, which is useful It operational changes or if a privileged account is compromised. in case of",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Queries might fail due to unbounded iterations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "In packages/abstract-api/src/endpoints/query.rs:48 and 60-64, all traders and dependencies are returned without pagination. If too many traders or dependencies are the BaseQueryMsg::Traders and BaseQueryMsg::Config registered/installed, queries might fail due to an out-of-gas error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Add action prevailing over remove action when updating oracles assets",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "oracle package implements in The update_assets packages/abstract-os/src/objects/oracle.rs:47-72, which two vectors: One of the assets to be added to the oracle and one of the assets to be removed. The function rst removes any assets in the to_remove vector and then adds the ones in to_add vector. function accepts the This approach is not recommended since if the same asset is found in both vectors, it will neither be removed nor added, and no error is raised. This implies that in case of a mistake where the owner accidentally sends an asset in both vectors, they will be unaware of that mistake.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Lack of input validations when upgrading modules",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The manager contracts ExecuteMsg::Upgrade entry-point is handled by the in upgrade_modules function does not contracts/core/manager/src/commands.rs:255-277. This thoroughly validate the modules argument vector, which can lead to the following problems: function Firstly, in the case that duplicated modules are provided, two identical migration messages will be forwarded, causing the second migration attempt to fail if the migrate only if newer pattern is in place (as recommended by best practices), causing the whole call to fail. Secondly, the function does not check that the provided vector is empty, allowing for an inecient execution that will forward the Callback message without actual changes. if Thirdly, the whole execution would be short-circuited to the upgrade_self function if one of the modules to upgrade is abstract:manager. This is problematic if other modules need to be migrated along because they will be ignored and potentially cause a partial state mutation. For example, the last module to be migrated is the manager contract, the MIGRATE_CONTEXT storage state will store the previous module_id and old dependencies while the update_module_addresses function will overwrite the old module address to the new one in line 300. Since the migration is never executed for other modules, the root user can only call the ExecOnModule message to the invalid new app address (which should be the old one), and the handle_callback and assert_migrate_requirements functions will execute the same module ID more than once, consuming extra gas. Finally, as the provided modules are not checked to have a migrate function, the forwarded migrate message will fail when a non-migratable module is provided, causing the whole call to revert. We classify this issue as minor because it can only be caused by the root user.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Querying conguration does not return the subscriptors address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The manager contract implements an entry point to query its conguration. This call managed the contracts/core/manager/src/queries.rs:36-49. handle_config_query function by is in this However, details: subscriptor_address is not retrieved, even though it plays a central role as it is in charge of the contracts suspension. conguration function retrieve does not the full",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Remove duplicate permission check",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "the in In contracts/core/manager/src/commands.rs:233, there is a validation to assert that the caller is the root user. This is unnecessary as the execute_update_admin function performs this check already and is called later in the function. assert_admin function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Contracts should implement a two-step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Incorrect comments",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "exec_on_module in The contracts/core/manager/src/commands.rs:167 that seems to be copied from another function. comment incorrect contains function an similar A packages/abstract-os/src/objects/module_version.rs:48-50. set_module_data situation occurs also the in function in",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Insucient validation to hinder o-chain attacks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The manager contract includes three pieces of information that could potentially be used as part of injection or phishing schemes: name, description, and link. These could: traditional web exploits such as script 1. Contain whitespace intended to trick users 2. Contain code that may be executed in a users browser 3. Contain links to external resources that may be malicious 4. Contain insecure links",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "None of the packages and contracts enabled overflow-checks for the release prole. While enabled implicitly through the workspace manifest, future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Misleading message names",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The SuspendOs and EnableIBC functions in the manager contract are both potentially misleading function names. Based on their names, the functions seem declarative of one specic action, but each of these functions actually supports enabling and disabling functionality. For example, a call to EnableIBC with a status of false actually disables the IBC functionality.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Sudo messages are not exported",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "and In packages/abstract-api/src/endpoints.rs packages/abstract-app/src/endpoints.rs, sudo messages are not exported as valid entry points. If governance decides to vote and execute arbitrary messages on the API or app contracts, they will fail.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Governance type implementation diverges from documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf",
        "body": "The governance documentation page lists three governance types: monarchy, multisig, and in token. packages/abstract-os/src/objects/gov_type.rs:9-22 only implements two governance types: monarchy and multisig. GovernanceDetails However, enum the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Pools with big but dierent token amounts allow attackers to extract free value with minimal cost",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "For big amounts of tokens in the oer and ask pools with dierent token values, the calc_out_given_in function in contracts/terraswap_pair/src/math.rs:11 applies rounding, which opens a way for an attacker to extract value from a pool with a very small cost. imagine a pool with 5_000_000_000_000 A tokens, and a pool with As an example, 1_000_000_000 B tokens, with both weights set to 1 for simplicity. If a user now sends 1 B token, we expect the user to get 5_000 A tokens back. When a user sends 1 A token, we expect the user to get 0 B tokens back (actually 0.0002, but since we are dealing with integers here, the remainder will be dropped). The current implementation incorrectly returns 1 B token though. Imagine further that the value of 1 B token is 5_000 USD, and the value of 1 A token is 1 USD, an attacker can now get a risk free return of around 4_999 USD (minus transaction fees) per transaction. If the attacker repeats this attack, they will be able to drain the pool. Even worse, whenever the attacker shifts the balance enough, other arbitrageurs will be able to extract value by bringing the pool back to the 5_000 to 1 ratio, allowing the attacker to repeat the attack from where they started. Here is a failing test case demonstrating the example: #[test] fn compute_swap_rounding() { let offer_pool = Uint128::from(5_000_000_000_000_u128); let offer_weight = FixedFloat::from_num(1); let ask_pool = Uint128::from( ); let ask_weight = FixedFloat::from_num(1); let offer_amount = Uint128::from(1_u128); let return_amount = Uint128::from(0_u128); let spread_amount = Uint128::from(0_u128); let commission_amount = Uint128::from(0_u128); assert_eq!( compute_swap(offer_pool, offer_weight, ask_pool, ask_weight, offer_amount), Ok((return_amount, spread_amount, commission_amount)) ); }",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Duplicate storage in two contracts could lead to inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "i. e. asset_infos, Both factory and pair contracts store the information about pairs, in contract_addr, and in contracts/terraswap_factory/src/state.rs:19 contracts/terraswap_pair/src/state.rs:4. This duplicate storage might lead to inconsistencies between the two contract states. liquidity_token, start_time end_time, and",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Migration of the pair contract is disabled",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "In the Instantiate message for the pair contract, the admin eld is set to None in contracts/terraswap_factory/src/contract.rs:149. This that pair contracts cannot be migrated. implies",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. A pairs asset infos are no longer stored sorted which might break other contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "of the In the last version of TerraSwap LBP, the asset_infos stored in the FactoryPairInfo struct in is no contracts/terraswap_factory/src/contract.rs:139 were sorted. That longer the case. That change is not a problem for the audited contracts, since they use a pair_key helper function that generates a key based on the sorted asset_infos. This change, however, might break other contracts that depend on the previous design of stored sorted asset_infos. contract factory",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Unnecessary sub-messages introduce complexity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "Most contract interactions in the codebase are utilizing sub-messages, which have been introduced to Terra with the Columbus-5 upgrade. Sub-messages have been added to allow processing of the result of a call, for example, to handle errors. If the result of a call is not processed, regular messages should be used. There is no security concern in the usage of sub-messages, since they currently use the ReplyOn::Never value which causes a failure to propagate to the caller. Unnecessary usage of sub-messages can be found in:  contracts/terraswap_factory/src/contract.rs:33, 145 and 172  contracts/terraswap_pair/src/contract.rs:73, 101, 259, 307, 360, 370, 381 and 492  contracts/terraswap_router/src/contract.rs:117 and 141  contracts/terraswap_router/src/operations.rs:45, 59 and 97",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Contract name is not unique",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "In contracts/terraswap_token/src/contract.rs:16, the contract name from the CW20 base contract is used in the following string declaration: const CONTRACT_NAME: &str = \"crates.io:cw20-base\";",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Pair contract registration message in factory can be replaced with sub-message reply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "In contracts/terraswap_factory/src/contract.rs:156, a hook pattern is used to register the newly created pairs contract address in the factory. That pattern requires an exposed Register message type in the factory contract. Sub-messages have been introduced with the Columbus 5 upgrade of Terra to allow the processing of a reply without the need to expose a public message handler.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Post initialize message in pair contract can be replaced with sub-message reply",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf",
        "body": "In contracts/terraswap_pair/src/contract.rs:86, a hook pattern is used to set the newly created liquidity token contract address in the pair contracts cong. That pattern requires an exposed PostInitialize message type in the pair contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Unlimited iterator stack might allow an attacker to crash the node, halting block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "The global map iteratorStack in api/iterator.go has no upper limit, which might allow an attacker to exhaust the memory of the node by creating recursive CosmWasm messages/queries that create many entries on the stack. While gas limits might prevent this issue if they are set properly, there is no guarantee that the memory is big enough to hold all the iterator stack entries the gas limit permits. This issue might cause the node to crash, potentially leading to a halt of block production if block producers are aected.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. FFI result handling may lead to memory leaks in certain cases",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "During calls from Rust to Go code through the FFI, UnmanagedVectors are created for error messages. This happens in:  The canonical_address function in libwasmvm/src/api.rs:51.  The human_address function in libwasmvm/src/api.rs:79.  The next function in libwasmvm/src/iterator.rs:60.  The query_raw function in libwasmvm/src/querier.rs:45.  The get function in libwasmvm/src/storage.rs:29.  The scan function in libwasmvm/src/storage.rs:65.  The set function in libwasmvm/src/storage.rs:118.  The remove function in libwasmvm/src/storage.rs:146. These UnmanagedVectors are destroyed within the into_ffi_result function, but only if the closure dened in libwasmvm/src/error/go.rs:75-80 is executed. That only the GoResult::Other or happens in the cases where the GoResult is of either GoResult::User variant. In all other cases, a memory leak can occur if the called code is writing to the UnmanagedVectors. In some cases, a similar issue exists with the result coming from through the FFI, for instance:  The canonical_address function in libwasmvm/src/api.rs:50.  The human_address function in libwasmvm/src/api.rs:78.  The next function in libwasmvm/src/iterator.rs:58 and 59.  The query_raw function in libwasmvm/src/querier.rs:44.  The get function in libwasmvm/src/storage.rs:28. Those UnmanagedVectors are only consumed if no error is returned, but the Go code could in theory write to those unmanaged vectors, even if an error is set. This would also cause a memory leak. Finally, the iterators next function only consumes the UnmanagedVector of the value if the key is not None in libwasmvm/src/iterator.rs:83.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Gas overow errors are treated as normal panics and do not consume Cosmos SDK gas, which can be exploited to halt block production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "Within callbacks into Cosmos SDK, there is a special ErrorGasOverflow which occurs if the uint64 that is used to store gas consumption overows (see store/types/gas.go in Cosmos SDK). In such a case of an ErrorGasOverflow, Cosmos SDK sets the consumed gas to 0 in store/types/gas.go:77. The wasmvm callbacks treat such gas overow errors as normal panics, as opposed to treating them as ErrorOutOfGas, see api/callbacks.go:73-78. This leads to a gas consumption of 0 units for the Cosmos SDK related functionality. An attacker may exploit this by sending multiple messages that deliberately cause the Cosmos SDK gas counting to overow. While such messages would revert, they would consume less gas than expected such that block production might surpass Tendermints propose timeout. That could cause block production to halt.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. IBC packet receive functions result is not unwrapped, which is inconsistent and error-prone",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "The IBCPacketReceive function in lib.go:510 returns a result, and does not unwrap the errors as all other functions in lib.go do. That is inconsistent and may lead to errors if not properly handled by the calling context.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Assumption that caller of VMs create function limits contract size is inconsistent and error-prone",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "As mentioned in the TODO in lib.go:67, the VMs Create function does currently not enforce any gas limits during contract creation. Since the singlepass compiler is used, gas counting during compilation is not necessary  but the caller of the function should ensure that the size of the wasm code is limited such that block production of the underlying blockchain cannot come to a halt. Moving that responsibility to the caller is inconsistent since other functions of the VM do accept gas limits. It also requires clear documentation and introduces the likelihood of mistakes by the wasmvm integrator.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "6. Caught Rust panics do not log errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "In several places in the codebase, panics are caught using catch_unwind. catch_unwind returns an Err(cause), where cause is the object that invoked the panic. Currently, the cause is neither logged nor returned. This negatively impacts maintainability. Instances are: libwasmvm/src/cache.rs:43, 92, 116, 143, 169, 230, 305, as well as libwasmvm/src/calls.rs:433 and 517.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Outdated specication/documentation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "The documentation in various Markdown les is outdated, for example: - - - - - - - - implementation of the Instantiate, Execute and Query interfaces in implementation in spec/Specification.md:43 describes that the balance of a contract instances account is passed in, which is not implemented at the moment. Accordingly, the current the ContractInfo in types/env.go:24 does not contain the Balance eld as is documented in lines 99-100. The documentation of spec/Specification.md:54-59 do not match their lib.go:118, 166, and 211. The documentation of the Result struct in spec/Specification.md:116 does not match the implementation of ContractResult in types/msg.go:12. The documentation of the CosmosMsg struct in spec/Specification.md:141 does not match its implementation in types/msg.go:68. in The spec/Specification.md:161 and 180 are not implemented. Also in lines spec/Specification.md:159 and types/msg.go:238-239 it is stated that a contract is immutable once deployed, but there is no enforcement of immutable interfaces between contract upgrades. The Params struct in spec/Specification.md:75 is now called Env and does contain TransactionInfo instead of MessageInfo, see types/env.go. The comment providing storage iteration/scans in the future, which is already implemented. Additionally, the codebase contains several TODOs in comments that are already resolved, e. g. in types/ibc.go:148 or in lib.go:67 (gas counting is addressed by caller and singlepass backend prevents JIT bombs in the contract code). in spec/Specification.md:202 describes the possibility of ContractMsg documented OpaqueMsg structs and",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Inconsistent type usage for usedGas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - wasmvm v1.0.pdf",
        "body": "The type of usedGas is used inconsistently  in some instances C.uint64 is used, in others the type alias cu64: The functions cSet, cDelete, and cQueryExternal utilize C.uint64 instead of cu64 in api/callbacks.go.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Harvest message can be sandwiched to skim rewards",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "The Harvest operation in contracts/martian-field/src/contract.rs:23-26 claims rewards from the Astroport generator and then, after treasury fees have been applied, sells ASTRO to rebalance between the primary and secondary assets (in two steps). Since the Harvest message is permissionless and can be called by anyone, there is an opportunity in contracts/martian-field/src/execute.rs:210. skim the operation, reducing bonded amount total the to An example of the arbitrage attack to skim rewards would be the following, executed as a single transaction: 1. User swaps ASTRO for the primary asset",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Go to step 1 when ASTRO rewards have accrued. Bots could perpetually exploit this arbitrage if it were economically viable, hindering the overall nancial performance of the Field of Mars protocol. Recommendation We recommend making the Harvest operation permissioned, to reduce the opportunity for arbitrage. Alternatively, the team/community could aim to call the Harvest function with enough frequency so the arbitrage attack is not economically feasible due to transaction fees, but this is also dependent on the ASTRO rewards claimed. Status: Resolved 2. High spread might cause swapped primary asset not enough to cover users debt",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Tax deduction logic is not implemented",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "The Field of Mars contract uses the cw-asset library as a dependency, to facilitate the handling of both CW20 and native assets. The cw-asset library does not account for Terra taxes logic, which may cause forward-compatibility issues in the future. Even though the tax rate is currently set to zero, the tax mechanism itself has not been removed. Whilst unlikely, a future governance vote might decide to make use of the mechanism again and augment the tax as provide_liquidity() in martian-field/src/execute_callbacks.rs:18, potentially causing the loss of native contract funds due to accounting errors, and/or panics. rate, which would functions aect such",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Typos in response attributes may degrade the user experience",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "In the UpdatePosition msg, in contracts/martian-field/src/execute.rs:109, the response \"martian_field :: excute :: there is a typo in the attribute of update_position\". This may degrade the user or development experience when using this contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Remove unused code in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "The Snapshot feature in the codebase is not used anywhere in the codebase. Theres no entry point for users or contract admin to execute that function. Additionally, theres a TODO the code in contracts/martian-field/src/state.rs:12 hinting that comment should be deleted.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Outstanding TODOS are present in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Fields of Mars v1.0.pdf",
        "body": "During the audit engagement, several TODO comments were found in the following code lines:  contracts/martian-field/src/execute.rs:186-187  contracts/martian-field/src/execute.rs:266  contracts/martian-field/src/execute_callbacks.rs:517  contracts/martian-field/src/state.rs:12 This implies that the contract might still be under development and not yet ready for mainnet deployment.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Withdrawal of IDO pre-fund contributions will fail in most cases due to funds being deposited in Anchor",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The function withdraw_prefund in contracts/ido-prefund/src/execute.rs will revert in most cases since most of the funds are not actually stored in the contract itself but are deposited into Anchor as soon as a certain threshold is reached. This means that withdrawal requests by end-users will fail until the funds are redeemed from Anchor into the contract.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Missing input validation on staking cong update might lead to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The function update_config in contracts/staking/src/contract.rs fails to validate the unbonding conguration provided as an argument by not calling the available assert_unbond_config function, which ensures that unbonding periods are specied in the right order to be processable by the unbonding logic. This could lead to inconsistent contract state and errors during unbonding attempts.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. The staking contract owner can withdraw all reward tokens from the contract but users can not unbond without penalty",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The staking contract owner can use the function emergency_withdraw to remove all funds from the smart contract. This seems to be intended for emergency use in case of a vulnerability being detected. However, this does leave the user in a position in which they cannot use unbond to get their own funds back without a penalty.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Staking contract can run out of funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The staking contract relies on being funded since rewards are transferred from the contracts balance to the user. In the case of the contract running out of funds, users are left without rewards.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Multisig implementation does not follow CW3 specication",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The implementation of (https://github.com/CosmWasm/cw-plus/blob/main/packages/cw3/README.md). However, does not follow the naming convention for the interface, which might lead to confusion. the multisig contract is relatively close to the CW3 specication it In addition, the code implements basic functionality that is already implemented by the CW3 reference implementation (https://github.com/CosmWasm/cw-plus/tree/main/contracts/cw3-ex-multisig).",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Multisig proposals do not expire and cannot be closed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "Proposals submitted to the multisig remain in an executable state forever. This could lead to old proposals being executed by a signer after circumstances have changed, for example, when a transaction is not relevant anymore. Additionally, the lack of support for cancelling proposals means that a proposer cannot withdraw a past proposal even if the set of signers changes through a cong change. An example of this being a problem could be a proposal having been replaced by a newer version and then accidentally being executed when the signing threshold is lowered.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Staking contract sends UST fees to arbitrary burn address",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The staking contract charges a UST fee on all operations. Collected fees can be withdrawn from the contract by sending them to a burn address that can be set by the owner to any address. This is inconsistent with the burn terminology.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Reward withdrawals in staking contract charge fees even if no rewards are distributable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "The withdraw function in contracts/staking/src/contract.rs does not fail when no rewards are distributable. This means that the user spends gas and fees without receiving any reward in return. Whilst this may be intentional, it is not what a user would expect as normal behaviour.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Missing tax deductions on UST transfers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/StarTerra/Audit Report - StarTerra.pdf",
        "body": "In contracts/ido-prefund/src/execute.rs UST is sent out from the contract in the functions withdraw_prefund and withdraw_ido_funds. In both cases the code fails to account for Terra taxes on native tokens, meaning that these taxes are taken from the contracts balance. In addition, functions deposit_prefund and deposit_anchor_by_admin send UST to Anchor. However, the bookkeeping of user funds takes into account taxes on UST transfers. This is unlikely to lead to the contract ever running out of funds due to fees. However, operator benets may be slightly lower than expected in certain cases.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. app.dart: Logging of sensitive information possible",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "In initCrashlytics, the following error handler is congured to record utter errors in Firebase: FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterError; This conguration applies to the whole app and therefore also the wallet part. There, it is possible that sensitive information (mnemonic, private key) are included in a stack trace and sent to rebase. When an account that has access to these information is breached, an attacker can steal all coins that belong to these wallets, which happened in the past.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. No limit for unsuccessful PIN entries",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "The wallet is protected by a 6-digit PIN, meaning there are 1,000,000 possible combinations (and roughly 3,000 of them are invalid because of the complexity requirements). Therefore, it will take on average 498,500 tries to nd the correct PIN, meaning a brute force attack is feasible. The wallet currently does not enforce an upper limit on the number of tries and also does not implement a measure like an exponential backo to protect users against such attacks.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Disconnecting the wallet does not require the PIN",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "When a user wants to disconnect his current wallet, he is not asked for the PIN. While this may be desirable from a UX perspective, disconnecting a wallet is a sensitive operation with potential nancial eects. For instance, when the user did not backup the wallet previously, he will lose access to the coins in the wallet.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. security_manager.dart: Initialization vector reuse in AES CBC mode",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "In onPinCodeChanged, the old key is decrypted with the old PIN and the resulting plain text then encrypted again with the new PIN. Because SecretKeyEncryptor._getInitVector returns the current initialization vector (if one exists), the same IV is used for both operations, which should not be done in AES CBC mode.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. wallet_address.dart: Insecure mnemonic generation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "To generate a mnemonic, the function generateMnemonic of the package bip39 is used. This library does not generate the mnemonic in a cryptographically secure way because of an o-by-one error: It calls _randomBytes within generateMnemonic. The _randomBytes function calls nextInt(_SIZE_BYTE) on the Random.secure() PRNG to get a random byte. This function generates random integers from 0, inclusive, to the provided maximum, exclusive. Because _SIZE_BYTE is set to 255, there is therefore no way that _randomBytes returns the value 255, meaning non-uniform randomness is used to generate the mnemonic.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. wallet_transaction_bloc.dart: Unnecessary gas estimation for FCD transfers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/FreshCut/Audit Report - FreshCut Audit.pdf",
        "body": "In _transferFromConnectedToExternal, the gas limit for FCD transfers is estimated. This value is then passed to fcdWallet.transfer, which further passes it to _contractService.send. However, because ContractService.send has a hard-coded limit of 62,000 for FCD transfers, the whole estimation is unnecessary and never used.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. payout function may panic due to lack of fee and royalty validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "The payout function in contracts/marketplace/src/execute.rs:890-946 handles the distribution of funds when a sale is being nalized. There are a number of parties that may be paid during the sale of an NFT, such as the seller, nder, artist, and the network. Each of these parties has a dened percentage they receive which is dened in various conguration parameters. The payout function does properly validate that the sum of each of these payment parameters is not greater than 100%. finders_fee, network_fee, and royalty.share should be validated to ensure that their sum is not greater than the payment. The amounts of seller_share_msg, royalty, finders_fee, and network_fee are all independently calculated o of the original payment value with no respect to their sum. An example of a situation that would cause a panic is if a certain collection had an abnormally high royalty.share. For example, let's say the royalty.share is 95%. The subtraction of   royalty.share, network_fee, and finders_fee in line 931 would be greater than the original payment and cause a panic due to an underow (the workspace has overflow-checks enabled, which causes underows to panic).",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Misconguring stale bid duration causes operators to be unable to remove stale bids",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "the contract instantiation During in contracts/marketplace/src/execute.rs:49, msg.stale_bid_duration is not validated to have the input cast as Duration::Time, which is inconsistent with updating of parameters in contracts/marketplace/src/sudo.rs:96-98. As a result, a misconguration of initializing the stale bid duration as Duration::Height would cause the execution to fail in lines 745 and 796 because the Duration enum does not allow addition of time and height. execution message process during sudo",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Bidder can specify unchecked nders fee",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "and execute_accept_collection_bid lines execute_accept_bid the contracts/marketplace/src/execute.rs:513 bid.finders_fee_bps if there is no existing ask when a seller accepts a bid. This is problematic because nothing stops a bidder from specifying a very high value. While the nder's fee would still go to the sellers specied nder, it may be a proportion that is higher than the seller expected. in use and When creating an ask, params.max_finders_fee_percent, but mentioned above. the nders fee is validated to ensure that this check doesnt occur it is less than in the cases Example: 1. A user creates a bid with a very high nders fee of 90% (high but not enough to error). They would need to create a bid on an NFT that doesnt currently have an ask. 2. Owner would accept the bid 3. 4. The sellers specied nder would get nearly all of the value from the NFT sale, and If there is no ask, then bid.finders_fee_bps is used the seller would not. It is important to note that the caller still species the nder's address when accepting a bid. If this nder value was also pulled from the bid, this would be a critical issue allowing bidders to pay virtually nothing for NFTs.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Percentage and basis point values lack maximum value validation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "contracts/marketplace/src/execute.rs:47 of In max_finders_fee_percent and bid_removal_reward_percent are converted to Decimal::percent values but are not checked to ensure that they do not exceed 100%. If it would be harmful to the either of these values were to be set to greater than 100%, protocol. It is best practice to enforce a hard limit on percent values. values and 50, the During the payout calculation, the nders fee could be greater than 100% which will cause the calculations to underow, but this would panic because of enable overflow-checks. Additionally, in execute_remove_stale_bid, a bid_removal_reward_percent greater than 100% would result in a reward greater than the value of the original bid. is situation in This also contracts/marketplace/src/sudo.rs:58. trading_fee_percent, max_finders_fee_percent, and bid_removal_reward_bps should all be validated to ensure that they are not greater than 100%. sudo_update_params function present the in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Sellers can update the price for inactive ask requests",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "execute_update_ask_price in The contracts/marketplace/src/execute.rs:306 allows the seller to update their NFT asking price without validating whether the associated ask request is expired or inactive. This might cause a misconception to the seller that their ask request is still valid and available for bidders to bid, which may not be true. functionality",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Bidders may set themselves as nder and receive nders fee",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "the execute_set_bid in In contracts/marketplace/src/execute.rs:334, when a bid is placed on an NFT with a FixedPrice auction, the nder is specied by the set_bid caller. That nder is then passed to the finalize_sale function and in the payout function, the address is then paid the nders fee. This function does contain any logic to verify that the nder address specied is not info.sender. This means that the function does not prevent bidders from specifying themselves as the nder and receiving the illegitimate nder fee. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Existing operators will be overwritten",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "sudo_update_params The in contracts/marketplace/src/sudo.rs:86-88 does not incrementally add operators, instead, it will overwrite the existing vector with the new operators. This may become problematic as the number of operators grows. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. A large number of hooks may cause out of gas errors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "The sudo_add_sale_hook, sudo_add_ask_hook, and sudo_add_bid_hook functions in contracts/marketplace/src/sudo.rs do not impose a maximum number of hooks that may be added. As the marketplace scales, the number of hooks may begin to grow and cause out-of-gas errors. Note that this is recoverable because the contract contains hook removal functionality. It is best practice to impose a maximum number of hooks as they increase the gas cost of the call.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Release candidate dependencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "contract/marketplace/Cargo.toml:36-37, In cosmwasm-storage crates are specied at a release candidate version. the cosmwasm-std and As rc software is by convention still in development we suggest not using it in production.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. reserved_for should only be used when the sale type is not an auction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "When bidders attempt to bid on an existing ask request via   execute_set_bid functionality, the reserved_for value would be validated to ensure only the seller specied bidder can seen bid in asked contracts/marketplace/src/execute.rs:378-382. While this functionality is intended for sellers to reserve the sales for a specic bidder, it would defeat the purpose of the auction if the sales type is not xed price. request the on as",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. map_validate does not ensure the address vector is deduplicated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "The map_validate function in contracts/marketplace/src/helpers.rs:28-33 does not ensure that the provided vector of addresses is deduplicated, which is inecient.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "there While level, checks contracts/marketplace/Cargo.toml does not explicitly enable overflow-checks for the release prole. workspace overow are the at While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Potentially unexpected hook behavior",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2022-08-01 Audit Report - Stargaze Marketplace v1.0.pdf",
        "body": "There are several scenarios throughout the marketplace contract where actions may be performed without triggering the expected hooks. While this is not inherently a vulnerability, it may lead to unintended consequences if these scenarios are not explicitly considered when implementing hooks. For example, a seller can call SetAsk multiple times to eectively update/overwrite their current ask. This will trigger the HookAction::Create hook multiple times, but not the HookAction::Delete hook, which may be unexpected. The same issue is also found when setting bids.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Bridge operator has full control over funds and relies on backend service controlling a hot wallet",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The centralized design of the bridge allows the bridge operator full access to the users funds. This means the operating entity has to be fully trusted since it can withdraw users funds and censor transactions. The design comes with additional security risks in the form of a backend process (MONITOR) that manages the bridge through a single private key, which is used as a hot wallet. In case of the server being compromised and an attacker gaining access to the key, all funds are at risk, and transactions can be censored or executed at will. Furthermore, a potential DoS attack on the MONITOR could block the entire bridge functionality.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Addresses are encoded as string and not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The function receiveTokens takes a string parameter as the destination address. The reasoning behind this seems to be that some receiver blockchains use dierent address encoding. However, this means that addresses are not validated and tokens might be sent to an invalid address.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. Adding of new blockchains can be front-run to avoid paying the minimal fee",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "Adding and conguring the support for a new blockchain requires multiple transactions: - addBlockchain - setMinorTokenAmount - setMinGasPrice The function receiveTokens can be called immediately after the rst addBlockchain transaction. Such a call would allow the usage of the bridge with a zero minBRZFee. This attack might be worthwhile for an attacker if a user wants to use the bridge with a high fee.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Unused sender parameter in accept transfer function",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "In the acceptTransfer function, the sender parameter is passed but not included in the transaction id calculation. Whilst the sender information does not add security, it might add value to the calculation of the transaction id for o-chain purposes.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Outdated dependencies in build- and deployment system",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The build- and deployment system has several outdated dependencies with known security vulnerabilities. Some of these relate to cryptographic primitives used for deployment.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Inecient array data structure for tracking supported blockchains",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The dierent blockchains supported are stored in an array of strings. This requires an iteration of the entire list in functions like existsBlockchain.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "7. Potential data structure optimization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "mapping(string => uint256) private minBRZFee; mapping(string => uint256) private minGasPrice; mapping(string => uint256) private minTokenAmount;",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "8. Oracle functionality mixed with bridge logic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The minBRZFee variable is required to calculate fees in the receiveTokens function. The calculation happens on-chain based on quoteETH_BRZ, gasAcceptTransfer and minGasPrice in the _updateMinBRZFee function. Currently, these variables are set by admin calls. In future versions, the quoteETH_BRZ will be provided by oracles, according to the code comments. The contract is already laid out to include oracle support in a future version. However, is not considered best practice due to poor separation of concerns. integrating oracle functionality into the bridge module itself",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Admin role also controls oracle",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The information required to calculate minBRZFee is currently provided by the admin role. This concentrates a lot of functionality in a single private key managed by the admin server (MONITOR).",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Slightly outdated OpenZeppelin release used",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The codebase imports a relatively recent version of the OpenZeppelin smart contract library. However, there have been recent security releases that x vulnerabilities. These issues seem not to apply in the present use case of the contracts. However, we recommend using the latest security release.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Unnecessary use of modier for authorization on private method",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The private _processTransaction method is covered by access control modiers. Authorization modiers like onlyMonitor or whenNotPaused are only required for external or public methods but not for private ones. In this particular case, they are already covered in the caller function.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Unnecessary long digit constant",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "A constant is dened to represent 10^18 for token decimal conversion: uint256 public constant ETH_IN_WEI = 1000000000000000000;",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Gas Optimizations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/BRZ/Audit Report - BRZ Bridge.pdf",
        "body": "The contracts can be optimized for more ecient gas usage in multiple places.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Querying all strategies or user strategies of the factory might run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2021-08-18 Audit Report - Apollo.pdf",
        "body": "The factorys GetStrategies and GetUserStrategies queries are using unbounded storage iterators in contracts/apollo-factory/src/state.rs:91 and 132. As more strategies are added to the factory, the gas cost of running those queries does increase. This is not a security concern for Apollo, since those queries are not used anywhere within the current codebase. Other projects could rely on the queries though. If they do, a high amount of strategies could lead to the queries running out of gas.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Revoked collateral assets re-activated during contract migration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "When performing the migration of the collateral oracle contract, legacy collateral information is migrated to the new storage layout. During this process, every collateral is marked with in is_revoked: false The contracts/mirror_collateral_oracle/src/migration.rs:112. consequence of this is that collateral that had previously been revoked is now re-activated.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Incorrect specication of migration poll voting period",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "During the creation of a new migration poll, the voting period is dened incorrectly as that of the default poll cong in line contracts/mirror_gov/src/contract.rs:329. The impact of this would be the reduction in the voting period of migration polls, allowing less time for them to pass with a potential danger of a distributed poll deposit by the protocol.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Collateral oracles cong migration is not performed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "in The contracts/mirror_collateral_oracle/src/migration.rs:49 is unused. This implies that after the migration, the cong will not be decoded properly. migrate_config function",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Admin rights cannot be revoked when claimed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "of current implementation in contract The contracts/admin_manager/src/contract.rs allows an account to claim the contracts admin rights. Upon claiming the admin rights the account becomes the target contracts admin and has the right to perform contract migrations. There is no mechanism to revoke any claimed admin rights. If the third partys account is lost or compromised, there is no way for the protocol to recover, and all locked funds might be lost forever. manager admin the",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Users can grief creation of admin polls",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "Creation of a new admin poll is not possible if the number of existing polls is greater or equal to MAX_POLLS_IN_PROGRESS in contracts/mirror_gov/src/contract.rs:335. The impact of which is prevention of new admin polls being created through continuous adding of new polls. We consider this issue to be minor since it is mitigated by the fact that deposits for failed polls are distributed to stakers. Despite this cost, there is still a possibility of attackers trying to grief admin actions.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Admin and migration poll conguration can be updated in a default poll",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "If the governance cong is updated through a poll, the default_poll_config will be used in contracts/mirror_gov/src/contract.rs:435. This could enable a whale or colluding token holders to alter the conguration of the admin and migration poll types through a default poll. Subsequently, such malicious actors could execute migration and admin actions with signicantly lower poll requirements to extract value from Mirror. We consider this issue minor since the community could observe such polls and intervene by rejecting them.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Admin manager can be updated in governance contract with default poll cong",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "all admin While contracts/mirror_gov/src/contract.rs:373, an update of the admin_manager dened in the contract with the default poll cong. through the current implementation allows or migration congs actions admin imply poll After updating the admin_manager to any other address, normal messages can be used for admin actions, including contract migrations. As in the last issue, we only consider this issue minor since the community could observe such polls and intervene by rejecting them.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Migrations that run out of gas remain executable and may be triggered in the far future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "The governance contract supports migrations to be run when a poll is executed through the ExecutePoll message. Such execution, which is triggered as a sub-message in contracts/mirror_gov/src/contract.rs:615, does not have a gas limit set. If the migration (or any other message) runs out of gas, the whole ExecutePoll message will revert. As a consequence, the poll will not be changed from PollStatus::Passed to PollStatus::Failed. This implies that polls will stay open for an unlimited time. the status of This can become problematic if Terra decides to increase the gas limit for messages in the future. In such a case outdated migration messages might be triggered, which could lead to an inconsistent state of the contracts. This issue also replies to any other poll running out gas, but is especially devastating with migrations that might change the storage layout.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Addresses for migration in migration polls are not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/2022-01-14 Audit Report - Mirror Decentralized Governance v1.0.pdf",
        "body": "When creating migration polls, addresses for the contracts to be migrated are currently not validated in contracts/mirror_gov/src/contract.rs:409. This could lead to failure of migration executions. message creation prior to",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Royalty contract owners can steal royalty funds by changing the funds recipient address.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/royalty/src/contract.rs:126 i.e recipient The update_royalty() function allows updating address and royalty rate a NFT minter wishes to charge, However, this function can also called by the royalty contract owner who can provide recipient address of its convenience in the used calculating the recipient value at contracts/royalty/src/contract.rs:126. This would allow the contract owner to rug pull all the royalty funds of the NFT minters. royalty parameters, arguments function that can",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Bidding contract owners can abuse their authority to front-run threshold values leading to unfair auctions.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/bidding/src/contract.rs:82, 151 In English auctions, bid acceptance is directly proportional to the bid amount. By changing the threshold value during the auction phase using the update_config() function, the owner can decrease the threshold value such that his bid becomes the highest and overwrites the current highest bid using the place_bid() function. Even if the owner changes the threshold value during the auction without having any intention to gain an advantage, this still leads to unfair auctions as other participants may try to outbid the current highest bid compared to the previous threshold value.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Contract owner could steal funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-contract-queuing At - src/execute.rs:249 The refund() function can only be called by the queuing contract owner and that will allow them to remove all the CW20 tokens it holds without sending the NFT to the appropriate owner who puts their order in the queue.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Whitelisting in queuing contract can be bypassed by directly queuering the storage contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-contract-queuing At - src/execute.rs:114 The queue() function checks for the whitelisted address at each stage, and allows only the whitelisted addresses to claim tokens in claim(). The logic that checks the whitelisting queries the info.sender contract directly. The contract can respond to the query with any whitelisted address.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Change of storage contract address may lead to loss of funds.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/storage.rs:80 execute_change_storage()changes the storage address. This may lead to loss of funds if the storage address for the given maker address already exists and the new code_id doesnt have the appropriate functions to claim assets out of it.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Cyclic dependencies are present in auction_house and royalty contracts that would break the initialization of the respective contracts.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/contract.rs:37, contracts/royalty/src/contract.rs:28 Instationation of the auction_house contract requires the address of the royalty contract whilst instantiation of the royalty contract requires the address of the auction_house contract. Because of this cyclic interdependency, it would not be possible to deploy both of the contracts with valid params.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. The non-atomic nature of the place_bid function may lead to locked funds.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/storage/src/order.rs:208,209 contracts/bidding/src/contract.rs:99 To place a bid, a user needs to send funds to the storage contract rst and then call the place_bid() function of the bidding contract , which triggers the bidding_lock() function in the storage contract to lock funds. This is a 2-step process which may lead to locking of funds if the second transaction fails. To retrieve those funds users have to explicitly call the claim_assets()funciton. This process may introduce some inconsistencies and non-atomic behaviour may cause more gas consumption.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Incorrect nonce management",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/OnePlanet/Audit Report - One Planet.pdf",
        "body": "Repo - one-planet-auction-contract At - contracts/auction_house/src/contract.rs:194 Nonces can be passed as a parameter when calling the approve_order()function that makes no usage no nonce as it is controlled by the user itself. This will allow the replication of order and restrict adding as new order if the same nonce gets used.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Missing tax deduction in collectors swap, LLI farmings mint and the treasurys spend function will drain contracts funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-01-13 Audit Report - Levana Stage 1 - v1.0.pdf",
        "body": "The collector contracts swap function can deal with native and cw20 tokens. However, in the case of in take contracts/levana-collector/src/contract.rs:285. into account code does token, native taxes not the a Similarly, contracts/levana-lli-farming/src/contract.rs:353. farming contracts mint_lli function does not deduct the LLI taxes in Likewise, contracts/levana-treasury/src/contract.rs:62. taxes are not accounted for in the treasury contracts spend function in Failure to deduct taxes will mean that the contracts funds are slowly drained.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "2. Proxy rewards not included in active pools will be lost upon claiming",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-10 Audit Report - Astroport Core Updates v1.0.pdf",
        "body": "In the contracts/tokenomics/generator/src/contract.rs:231, ClaimRewards message fetches accrued proxy rewards from all active pools instead of the specied liquidity pools (see lines 748-754). When the claim_rewards function in line 982 is executed during the callback, only the specied liquidity pools will have their proxy reward index updated. This is problematic because if the provided liquidity pools do not contain all the active pools, the proxy reward index for left-out pools will not be updated, causing a loss of rewards for depositors. This issue was discovered by the client independently during the audit, but it is still present in the commit hash used for the audit.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "1. Separation of ash loan payback verication into separate contract could allow administrator to steal funds and introduces misconguration risks",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "The stablecoin-vault relies on the amount being lent in a ash loan to be tracked in the separate profit-check contract, which then checks that the amount has been repaid in full. This means that the actual ashloan functionality and the repay check are implemented in two dierent admin-congured contracts. As a result, a compromised admin could congure the profit-check address in the stablecoin-vault contract to point to a custom version that does not require full ash loan repayment for its own loans and use the ashloan function to extract user funds from the vault. In addition, having two independent contracts in a 1-to-1 that have to be congured separately with the corresponding address pointers to each other is error-prone and could lead to accidental misconguration.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Systemic dependence on Anchor may impede the ability to stabilize the UST peg via arbitrage during bank run cycle",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "The litepaper explains how bank run cycles can be a threat to the UST peg. If systemic risks materialize in the form of an event that has an impact on the whole Terra ecosystem, this will likely impact Anchor as well. In addition, a malfunction of Anchor or a bank run on Anchor might trigger substantial corrections in the Terra ecosystem. The fact that only a xed amount of UST  i.e. the stable_cap  is meant to remain in the vault will decrease the ratio of UST/aUST in the vault with increasing liquidity in the vault. With a growing amount of liquidity in the vault, the ability to stabilize the UST peg via arbitrage will depend more and more on Anchor being seamlessly working, which is not guaranteed during a bank run cycle. there Moreover, setting contracts/stablecoin-vault/src/contract.rs:770 meaning that the value could be set unrealistic values accidentally. validation when no is the via stable in set_stable_cap, cap",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Fixed fee buer might lead to failure of large ash loans",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In contracts/stablecoin-vault/src/contract.rs:37, FEE_BUFFER is set to a constant value. The buer is used in line 268 to assure that the contract has enough liquidity to pay taxes and fees. The messages for the fees and taxes are then created in lines 295 and 299 as functions of the amount and fees/taxes. If fees and taxes exceed the buer, large ash loans might fail because they will not be protable.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Flash loan and treasury related messages could run out of gas due to too many whitelisted contracts, assets or dapps",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In contracts/stablecoin-vault/src/contract.rs:244 the handle_flashloan function might run out of gas if the number of whitelisted_contracts gets very large. As this is unlikely and can only happen through governance motions this is only a minor issue. Similarly, in contracts/treasury/treasury/src/contract.rs an unlimited number if the of assets might cause executions of dapp-messages to fail by running out of gas, transactins uses the query compute_total_value. Lastly, in contracts/treasury/treasury/src/contract.rs:160, the removal of a dapp might fail if there are too many dapps and the message runs out of gas. This might not be a big issue, since the hite Whale architecture gure indicates that dapps will be limited.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Unvalidated and too high fee parameters might cause errors in production",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In contracts/stablecoin-vault/src/contract.rs:838-856 all fees in set_fee can be set to values equal to or larger than 1. These can cause errors, e.g. in line 428, where Decimal::from_ratio(amount - treasury_fee, total_share) causing the withdrawal functionality to fail. Similarly, we highlight for informational purposes, that the validation of new_fee.share > Decimal::one() in contracts/treasury/dapps/vault/src/commands.rs:293 allows for a fee equal to 1, which would trigger inecient messages.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Anchor exchange rate might be out of date and as a consequence transactions might fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In the contracts/stablecoin-vault/src/contract.rs:271 query_aust_exchange_rate functionality is used in the simplied form without the current block height as an input parameter. Anchor in this case uses stored values to calculate the exchange rate, which might be out of date. This implies that there may be imprecisions in the Anchor withdrawal message below in lines 451-454 and 655, which could lead to a failure in execution.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Denomination check is incomplete",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In packages/white_whale/src/denom.rs the length (size of the String) of a denomination is checked to be smaller than or equal to ve in order to determine whether a given token is a native token. This might fail because a coins Denom can have between 2 and 127 characters.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Zero amounts being sent in messages will fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "In contracts/treasury/dapps/terraswap/src/commands.rs:133, 120 and 172, zero amounts might be sent. These messages will always fail since zero transfers revert.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "9. Canonical address transformations are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/WhiteWhale/Audit Report - White Whale.pdf",
        "body": "While previously recommended as a best practice, usage of canonical addresses is no longer encouraged. The background is that canonical addresses are no longer stored in a canonical format, so the transformation just adds overhead without much benet. Additionally, the codebase is more complicated with address transformations.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Lack of accounting for slashing could lead to a bank run, resulting in loss of funds for slow depositors",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "to for The due logic example slashing. The codebase does not handle any reduction in a pools total value locked, which could happen the TransferWithdrawalToLocalChain function is implemented with the assumption that the amount returned by the unbonding callback will be equal to the amount specied at the beginning of the unbonding request. In the event that slashing occurs, the module will have a lower than expected balance which will cause later withdrawal requests to fail. This will create a situation where early withdrawals can be fully lled while later withdrawals will fail once the module's balance drops below the requested withdrawal amount. These withdrawals will fail until the module's balance is re-capitalized. The missing amount would need to be fully refunded to the modules balance for all users to be able to successfully withdraw their initial amounts. in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Updating the validator set of a pool does not trigger a redelegation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "If the proposal passes, The parameters of a pool can be updated through an update-pool proposal, including any changes to the validator set. the pool will be updated in x/millions/keeper/keeper_pool.go through the UpdatePool function. However, a change in the validator set does not trigger a redelegation to the new set of validators, instead only the ag isEnabled is updated. Any new deposits will be delegated to the new set of validators but for existing delegations to be updated, depositors need to withdraw, wait for the three-week unbonding period and redeposit.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Delegated funds cannot be redelegated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The codebase does not send redelegate packets, thus the function RedelegateCallback In the situation in x/millions/keeper/callbacks_redelegate.go is never used. where delegations need to ow from one validator to another (e.g. if a validator stops validating blocks) after the validator set got updated through the update-pool proposal, every depositor would need to manually withdraw, wait for the three-week unbonding period, and redeposit. This will require coordination, manual actions by users and impact the overall staking returns, as some depositors may not follow those steps and others have to wait for the unbonding period.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. DrawRetry will always fail",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The function DrawRetry in x/millions/keeper/msg_server_draw.go:13 does not behave correctly, and as a result, the draw will never be able to be re-executed. The and ClaimRewardsOnNativeChain, ExecuteDraw functions are all incorrectly called with the parameter draw.PoolId instead of the DrawID. This will cause the TransferRewardsToLocalChain and ExecuteDraw functions to fail due to an erroneous draw state. The ClaimRewardsOnNativeChain function will be executed successfully, claiming pool rewards but returning a wrong draw, unless draw.DrawId is equal to draw.PoolId. This means that any draw that fails its initial execution, will be stuck in an erroneous state. TransferRewardsToLocalChain,",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. MinDepositAmount is not strictly enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The function SetParams in x/millions/types/params.go:21 does not explicitly validate that the value of MinDepositAmount is not zero. Although a proposal to update the parameters would prevent a minimum deposit amount of zero, as it is caught in the update_params messages ValidateBasic function, MinDepositAmount could be set to 0 during genesis without causing an error.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. The chain could be spammed with deposits of negligible amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The function SetParams in x/millions/types/params.go:36 does not enforce a reasonable minimum acceptable amount for MinDepositAmount. Thus, the parameter can theoretically be set close to zero, allowing for spam deposits with negligible amounts. The LaunchNewDraw function is triggered by the BeginBlocker function and iterates over an unbounded loop of deposits. The ability to add a high amount of negligible deposits can allow an attacker to slow down or even halt block production. The minimum deposit needs to be reasonably high to provide enough nancial disincentive against such an attack. We classify this issue as minor since governance controls this value.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. An updated InitialDrawAt cannot be enforced",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The ShouldDraw function in x/millions/types/draw_schedule.go returns true if a draw should be executed. For the rst draw, it will only return true if it is passed the InitialDrawAt parameter of DrawSchedule. However, if the draw schedule is updated through a proposal and a new InitialDrawAt is set to a time in the future, this will not be enforced since the condition in line 46 will not be met. Thus, draws will continue to be drawn every DrawDelta, even if InitialDrawAt has not been met.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Missing validation checks in the codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "There are missing or insucient validation checks in the codebase:  The PrizeBatch validation in x/millions/types/prize_batch.go:19 allows for a DrawProbability of 0. A prize strategy that has 0 draw probability for all batches would make it impossible for the pool to have a winner.  The FeesStakers parameter is not validated in x/millions/types/proposal_update_params.go.  The DrawSchedule validation in x/millions/types/draw_schedule.go:10 does not check if DrawDelta is less than the MaxDrawScheduleDelta. Use the ValidateNew function for validation of DrawSchedule instead.  The PoolId, DepositId, and ToAddress are not properly validated in in MsgWithdrawDeposit x/millions/types/message_withdraw_deposit.go:36.  In the in MsgDeposit's x/millions/types/message_deposit.go:49, the msg.Amount is being checked to ensure the amount deposited is not negative, but it does not check if the amount is 0. ValidateBasic function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Inactive validators may receive delegations, reducing protocol yield",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "DelegateDepositOnNativeChain The in x/millions/keeper/keeper_deposit.go:111 delegates deposits to the native chain of the pool. However, it is possible for a validator to have already stopped validating and unbonded at the time the latest pool validator set has been proposed and approved. This would allow delegations of pool deposits to inactive validators that will not produce any yield. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. PrizeExpirationDelta parameter can be set to a value that prevents prize claims",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The function ValidateBasics in x/millions/types/params.go:36 would allow for a PrizeExperiationDelta as short as a second. Very short periods would prevent winners from claiming their prizes. We classify this issue as minor since it can only be caused by governance.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. FeesStakers parameter can be set unreasonably high",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The function ValidateBasics in x/millions/types/params.go:36 does not prevent an unreasonably high value for the FeesStakers parameter. Although this parameter is controlled by governance, it is possible to be set close to 1, which would mean that all draw proceedings will be taken as fees, causing depositors to receive only a minimal amount of rewards.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Redundant checks are inecient",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "The codebase contains redundant checks that lead to ineciencies:  The last draw state check in x/millions/keeper/keeper_draw.go:51 is a through duplicate it x/millions/keeper/keeper_blockers.go:375, ListPoolsToDraw. validation invoked already as is  The ValidateDenom function in x/millions/types/pool.go checks the length of the denomination inside the function. The validation checks in lines 20 and 26 can be removed.  The validation to check if the sender has sucient balance in is  The x/millions/keeper/msg_server_deposit.go:60-62 is duplicate as it already checked in the SendCoins function called in line 79. sanitizedDenom in x/millions/keeper/msg_server_deposit.go:34 can be removed if a stateless check is performed in the message ValidateBasic function in x/millions/types/message_deposit.go:37. function  A length of validators check in x/millions/keeper/keeper_pool.go:251 is in duplicate x/millions/types/proposal_update_pool.go:49. checked already being as is it  The in x/millions/types/message_deposit.go:53 can be removed as it is being checked already through the AccAddressFromBech32 function in line 55. strings.TrimSpace call  All the transaction commands in x/million/client/cli/tx.go:25-30 call msg.ValidateBasic. This is unnecessary, since the function is already invoked in the GenerateOrBroadcastTxWithFactory function.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Outstanding TODO comments in codebase",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "There are multiple TODOs in the codebase that may refer to important logic. Instances are:  x/millions/keeper/keeper_draw.go:199  x/millions/keeper/keeper_pool.go:85",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Inaccurate messages may confuse or mislead users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "Across the codebase, instances of inaccurate messages have been found, that could confuse or mislead users.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Missing usage description for all transaction and query CLI commands",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "the and transaction in All and x/million/client/cli/tx.go:25-30 x/million/client/cli/query.go:37-59 are missing a long message that describes their usage, which would be helpful for users and external developers. the Millions module query CLI commands for",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Code ineciencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "There are several parts of the codebase that can be optimized to perform stateful and stateless checks, reduce computational resources and gas consumption:  Trim whitespace to catch more cases of invalid values instead of just empty strings for the parameters ChainId, Bech32PrefixAccAddr, and Bech32PrefixValAddr in x/millions/types/pool.go:13, ValidateBasic.  In x/millions/types/message_deposit.go:44-51, using msg.Amount.Validate can replace the implemented functions.  In x/millions/types/proposal_register_pool.go:59-64, validation checks with strings.TrimSpace can be replaced with the ValidateDenom function from Cosmos SDKs types package.  The ComputeSplitDelegations in x/millions/keeper/keeper_deposit.go:130-133 and 158-161 can be combined. function",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "17. Code quality could be improved",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "Across the codebase instances of unused or commented code have been found.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "18. Unused pool states",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "the pool states PoolState_Paused and PoolState_Killed are unused. Currently, Additionally, in x/millions/keeper/msg_server_deposit.go:15 allows for deposits to be made to a paused pool. If a paused pool state was implemented in the future without updating this function it could be problematic. Deposit function the",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "19. Additional rewards are ignored",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lum Network/2023-05-15 Audit Report - Lum Millions Module v1.0.pdf",
        "body": "the OnClaimRewardsOnNativeChainCompleted ignores additional coins Currently, returned in the ICA claim rewards callback if they do not match the module account. With interchain security, it is becoming more common to expect chains to return more than one type of reward coin. Overall this would also increase the rewards users receive. there in Additionally, x/millions/keeper/keeper_draw.go:193 that iterates over every coin received. While the likelihood of receiving a large amount of additional coins from a trusted chain is low this edge case should still be handled. unbounded iteration an is",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Users will not get native assets back when borrowing them from borrowed farm",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "In the callback_unbond_hook function, stakers that borrow native assets should receive the swapped amount since the pairs swap_msg functionss to parameter to see Some(staker_addr.to_string()), contracts/borrowed-farm/src/bond.rs:407. For native assets though, there is a bug in packages/alpha-homora-v2/src/adapters/pair.rs:206. Consequently, a swap of native assets would be called with None set as the to parameter, which would lead to the swapped funds being stuck in the borrowed farm contract. swap_msg functions is set apply value does that not the the to in",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Attackers may delay price update transactions by feeders to manipulate oracle prices",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "the When feeders feed prices to the oracle contract, PriceInfo is set to the current block timestamp. When querying prices from the oracle, that last_update_time value is used in contracts/oracle/src/contract.rs:265 to check whether the last updated price is too old. An attacker (or colluding validators) may exploit this by delaying transactions to shift price updates. the last_update_time of Suppose that a feeder sends a price update transaction in block 12345. An attacker may execute a DOS attack on the target node or the feeders infrastructure to prevent the inclusion of the transaction until some point in the future (e.g. block 13000). In that later block 13000, the price will be accepted and will be considered up to date. That allows an attacker to shift prices around to their benet.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. New borrowers using Homora Bank will pay fees for older borrowers",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "During borrows and repays in the Homora Bank contract, the current debt state is updated in In that function, the interest accrued within the Red the update_debt_state function. Bank is calculated, and a proportional Homera fee is stored in state.homora_fee. When a user now repays their loan, they will have to pay that homora_fee proportionally to the in amount contracts/homora-bank/src/contract.rs:462-464 does not account the duration a user has been borrowing though, which implies that new users pay the fees for previous users. current mechanism implemented for repay. debt they The of As an example, suppose there is a current debt of 100 in the Homora Bank and a homora_fee of 10. Now a user is borrowing 100 tokens and immediately repays these 100 tokens in the same block. The current logic will charge that user a proportional fee of 10 * 100 / 200 = 5 tokens.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Tokens with low price may have wrong price quoted by oracle due to loss of precision and price impact of probe amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "calculating in When contracts/oracle/src/contract.rs:297, the price_multiplier, which eectively truncates any decimals beyond 6 decimal places. This is a major issue for tokens that have very low prices and many decimal places. For is multiplied price the in price median oracle the the by example, a token with 18 decimal places and a current price of 0.0000018 would be wrongly represented within the Alpha protocol with a price of 0.000001. Additionally, the probe amount may lead to too much of a price impact for tokens with a low token price.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Wrong interest rate is used when withdrawing from lending bank, leading to small losses for other users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "to interest rates are During the execute_withdraw function of the lending bank contract, updated in withdrawal contracts/lending-bank/src/contract.rs:701. With the linear interest model, a withdrawal implies that utilization goes up, which means that both the borrow rate and the liquidity increase. balance reect after new the in line 707, the balance after withdrawal is calculated. Within that calculation in the Then, get_updated_liquidity_index function, the new liquidity rate is used to update the liquidity index. Since the liquidity rate went up, the liquidity index is higher than it should be. This implies that the user will have fewer IB tokens burned than they should have. The protocol and hence other users will take the dierence. The impact of this issue depends on the activity of the protocol with high amounts locked, small burned amounts and frequent interactions that update interest rates, the impact of a wrong index is rather minor. If there are big withdrawals and less frequent interactions though, there can be material losses for other users.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Adjusting positions up will fail if borrow asset is native but provide asset is CW20 or vice versa",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "the In method contracts/borrowed-farm/src/adapters/leveraged_farm.rs:73, wrong borrow_asset_info is sent in line 75. increase_position_msgs provide_asset_info whether native check is a in there is a while asset, This is no issue if both tokens are either native or both are CW20 tokens. If they are of dierent asset types though, no funds of borrow_asset_info will be sent or no allowance will be increased, which will lead to a failure of the execute_adjust_position function when positions are increased in contracts/borrowed-farm/src/bond.rs:557.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "7. Oracle uses median of recent (spot) prices, may be subject to spot price manipulation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "Dierent functions in the protocol query the oracle contract for asset prices. Each asset has those prices in the dierent price sources, and the oracle returns the median of query_asset_price function in contracts/oracle/src/contract.rs:297. All of the price sources use a single stored or queried price. Some of those price sources use spot prices. Spot prices can be manipulated, for example by swapping large amounts of tokens before using the Alpha contracts. Depending on the conguration of an asset, this may allow manipulation of the median price, and hence may be exploited by an attacker. We classify this issue as minor since spot prices are only supposed to be used for testing.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Swap amount calculation does not account for taxes",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "function get_swap_amount in The contracts/leveraged-farm/src/deposit.rs:81 and 102 on the amounts prior to deducting tax, which happens in lines 84 and 104, respectively. That implies that the swap calculation will be slightly o, and the small dierence will be arbitrated away by external actors. While the impact of this dierence is small, it will take away from a users yield and is easily prevented. called is We consider this issue to be minor since the impact is relatively small.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Repayment may fail if amounts are small",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "During repayment, in the callback_repay function, a swap happens between asset A and asset B to settle outstanding debt from bank A and bank B. Those swaps have a condition to tokens swap in contracts/leveraged-farm/src/withdraw.rs:181 and 197. If that minimum is swapped, the remaining amount of the bid asset might not suce though to repay the other loan. minimum of a",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Swap calculation in leveraged farm uses hardcoded fee and will be wrong if the underlying fee is changed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "get_swap_amount The in contracts/leveraged-farm/src/deposit.rs:43 assumes that the underlying pool swap fee is 0.3%. That value is hardcoded in the formula and hence calculated swap amounts will be wrong if the underlying swapping protocol changes their fee. function same exists The contracts/borrowed-farm/src/bond.rs:527. issue the in execute_adjust_position function in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Lack of price validation in oracle might cause issues",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "Prices from feeders are currently not validated. Feeders could (accidentally) set a price to zero in contracts/oracle/src/contract.rs:133. That causes inconsistencies in the protocol, for example in health checks of a position.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Cong parameter validation missing in Homora Banks init asset cong",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "the Homora Bank, conguration In the execute_init_asset_config function of parameters in are contracts/homora-bank/src/contract.rs:175-180. If those parameters are set to invalid values, the collateral_factor is set to zero. the protocol might not work as expected  for example if validated not neither Additionally, execute_update_asset_config function currently validate the fee_rate or liquidation_bonus. execute_init_asset_config nor the the the We consider this to be a minor issue since it can only be caused by the owner and is recoverable.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Treating Luna as a special case for tax calculation may lead to problems with Terra protocol updates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "In packages/alpha-homora-v2/src/adapters/asset.rs:318, Luna is treated as a special case for tax calculations, with a hard-coded zero tax value. However, this might lead to inconsistencies if Terra changes the Luna tax policy in a future protocol update. In such a case, the contract would pay the tax, misusing funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "14. Reliance on assumed received amounts might cause issues in the future",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "In several places in the codebase, the implicit assumption is made that another contract is sending a requested amount. Even if correct today, that assumption might be wrong in a future update of a dependent contract, for example, if fees are introduced that reduce the sent amount. An example of this can be found in the Homora Bank contract, where an asset is borrowed from the bank in contracts/homora-bank/src/contract.rs:387. Then the asset is sent to the borrower in line 389, without verifying that the requested amount has actually been received.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "15. Failing swap simulation in leveraged farm may lead to high arbitrage losses when providing liquidity",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "If the swap simulation in contracts/leveraged-farm/src/deposit.rs:89 or 109 fails, a zero value is used. Swapping is then skipped in lines 91 or 111, but the liquidity is still provided and the position increased. This may cause liquidity provision with a ratio that is far away from actual pools of the AMM, and the dierence will likely be arbitraged away by external parties, leading to a loss of value.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "16. Spot price queries from oracle may return wrong prices if neither asset is UST",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "the function, query_spot_price In in contracts/oracle/src/contract.rs:331-335 that one of the two assets of the pair the price will always be quoted in assets[1]. This is is UST. problematic, since a misconguration of the pair would lead to the protocol executing with wrong prices, rather than returning errors. assumption is made thats not the case, implicit the If",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "17. Interest rate calculation does not account for leap years/seconds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "SECONDS_PER_YEAR in The contracts/lending-bank/src/interest_rates.rs:20 has a value of 31536000 seconds, which corresponds to 365 days (a non-leap year). This implies that in leap years and when leap seconds are used, the interest rate will be slightly higher than expected. constant",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "18. Querying the lending banks market list, user debt and user positiont may run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "The query_markets_list, query_user_debt, and get_user_asset_positions in functions unbounded and contracts/lending-bank/src/contract.rs:1079, contracts/lending-bank/src/accounts.rs:73. That may run out of gas. iterations markets contain stored 1104, over all",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Max di value validation in borrowed farm is executed on previous value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Spectrum/2022-07-02 Audit Report - Alpha v1.0.pdf",
        "body": "the execute_update_position_parameters In in contracts/borrowed-farm/src/contract.rs:297, validate_percentage is called with the previous max_diff value, not the newly set one. That allows a max_diff value that is bigger than 1. function",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Balance updates performed from precompiles are overwritten if the precompile is executed in a transaction with other state change logic",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "Delegate in The precompiles/staking/tx.go:59 and precompiles/distribution/tx.go:67 are not correctly committing balance changes if the caller function performs state changes. WithdrawDelegatorRewards precompiles dened and Consequently, attackers could craft a contract where it is possible to delegate to a validator without having the delegated amount deducted from their balance. users the Additionally, WithdrawDelegatorRewards precompile could lose their rewards, depending on the contract implementation. leveraging contract interact with that a A test case reproducing the issue is provided in Appendix 1. This issue as well as the test case in Appendix 1 has been disclosed by the Evmos team to Oak Security during the audit.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. User distribution authorizations can be misused by malicious contracts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "The state transition functions of the distribution module require the user to authorize the to execute the SetWithdrawAddress, WithdrawDelegatorRewards, and caller WithdrawValidatorCommision functions. Failure to do so would result in the transaction's inability to interact with the distribution precompile. However, the distribution precompile lacks the functionality to revoke authorization once granted, resulting in smart contracts having access granted until the authorizations expiry. Although a user can revoke the authorization directly through the Cosmos SDKs authz module, this defeats the purpose of having the precompile in the rst place.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "3. The bech32 precompiler is not loaded in the EVM",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "The x/evm/keeper/precompiles.go:20-41, initializes the list of available precompiles. AvailablePrecompiles function, dened in However, the bech32 precompile is not added to the list, which renders the precompile inaccessible in the EVM. Additionally, return a valid precompile address. in precompiles/bech32/bech32.go:63, the Address function does not Consequently, the bech32 precompile cannot be executed.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Validators and Redelegations queries are not callable from EVM precompiles",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "The validators and redelegations functions are available in the staking precompile at precompiles/staking/Staking.sol:201 and 227. However, the implementation of both functions in precompiles/staking/tx.go is missing, rendering the functions uncallable from EVM-based smart contracts.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Queries do not support pagination, enabling attackers to DOS the chain",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "The query implementations do not support result pagination. This could be problematic since some of the implemented Cosmos SDK queries could return a large number of items. Some examples are the ValidatorSlashes and DelegationRewards queries dened in precompiles/distribution/distribution.go:160. Additionally, gas is not charged depending on the size of the query result size, but rather on the query input size. This could allow malicious actors to execute computationally and memory-heavy queries with a disproportionate gas cost, which could slow down block production up to the point where the chain halts.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. The Approve function does not allow ne-grained Coin allowances, allowing more Coins than intended in case of multiple messages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Evmos/2023-07-08 Audit Report - Evmos EVM Extensions v1.0.pdf",
        "body": "The Approve function dened in precompiles/staking/approve.go:32 iterates through a list of user-provided Cosmos SDK message types to allow a grantee to execute them on behalf of the user with the amount of user-specied Coins. However, because of the chosen input data structure, an encoded (Address, Coin, []string) tuple, it is not possible to specify how many Coins are to be used for each individual message. This results in allowing each message type with the Coin dened in the input parameter. Consequently, the total allowance will be dierent from the specied input since it will be equal to the cardinality of messages multiplied by the provided Coin. For example, a message with an allowance of 1ucoin and four message types will result in a total allowance of 4ucoin.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Wrong reservation assignment could lead to incorrect receiver for NFT",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "In contracts/contracts/stardust-nft-distribution/src/contract.rs:222, the senders address is assigned to the reservation. Since the contract owner and operator are able to create reservations on behalf of users, this might lead to the contract owner or operator receiving the NFT, rather than the reservation owner, even though the reservation owner paid for the NFT. This could lead to lost NFTs, for example, if the owner or operator is a smart contract such as a governance contract that cannot transfer NFTs.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Missing check for makers ability to cover the maker fee leads to incorrect validation query result",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "query_validate in The not contracts/contracts/stardust-settlement/src/queries.rs:9 validate whether the maker has enough stardust balance to cover the maker fee charged in when contracts/contracts/stardust-settlement/src/order.rs:117 checking if an order is suciently capitalized. This will lead to undercapitalized orders being returned as valid, which is incorrect. function does",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. NFT ownership is not cleared when NFTs are withdrawn, which leads to inconsistent state",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "The settlement contract does not clear the stored NFT_OWNER for an NFT when a user sends the Withdraw message. NFT ownership is only updated on deposit in the in deposit_balance contracts/contracts/stardust-settlement/src/state.rs:70, but not cleared in in leads to contracts/contracts/stardust-settlement/src/state.rs:80. That an inconsistent state. withdraw_balance function function the",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Setting royalties in settlement contract fails for CW1155 tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "of the part settlement in As contracts/contracts/stardust-settlement/src/royalties.rs:22, the minter of the token is queried. That query uses the CW721 contracts Minter query, which does not exist for CW1155 tokens. Consequently, royalty fees can only be set for CW721 tokens, not for CW1155 tokens. set_royalty contracts function",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "5. Submit execution plan will fail due to message sent to wrong contract",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "the In contracts/contracts/stardust-settlement/src/execution.rs:131, ValidateAndTransferExecutorBalance message is sent to the executor contract, but the executor contract does not accept that message.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "6. Missing check for ability to execute an order leads to misleading validation query result",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "query_validate in The the contracts/contracts/stardust-settlement/src/queries.rs:10 validate_into_info function with None as the last argument. That leads to a skip of validation whether a particular account can actually execute the order. This implies a misleading query result since a successfully validated order might fail validation during execution. function calls",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Querier contracts order update returns a misleading taker asset lled value",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "the querier In contracts/contracts/stardust-querier/src/contract.rs:132, taker_asset_filled is set to a value of 0 for orders   that are undercapitalized, lled or cancelled. A 0 ll value is inconsistent. OrderUpdate contracts logic in",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Closing an English auction leaves the maker order open",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "the in In function contracts/contracts/stardust-auction/src/contract.rs:132, the maker order is not closed when closing the English auction. That leaves dangling maker orders, leading to an inconsistent state. close_english_auction",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Treating Luna as a special case for tax calculation may lead to problems with Terra protocol updates",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "In contracts/packages/stardust_protocol/src/asset.rs:35 Luna is treated as a special case for tax calculations, with a hard-coded zero value. However, this might lead to inconsistencies if Terra changes Luna tax policy in a future protocol update. In such a case, the contract would pay the tax, leading to any user funds being spent.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Approve and transfer pattern implies a bad user experience and might introduce security issues",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "In several places in the codebase, the protocol relies on the approve and transfer pattern. It is generally better to use CW20 receive hooks, as they provide a better user experience (they do not require a separate approval and do not require revocation), are more gas ecient, and are usually more secure since approvals have often a disproportionate size and no expiry.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "11. Relayer fees are skipped if either taker or maker fee is zero",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "in The contracts/contracts/stardust-settlement/src/order.rs:94 contains the logical or || operator instead of the logical and && operator. This leads to no fees are being charged if either the maker or the taker fee is zero statement if",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "12. Missing input validation of order infos and ll amounts in order execution might confuse users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "execute_orders in The not contracts/contracts/stardust-settlement/src/order.rs:149 validate whether two arrays order_infos and fill_amounts are of equal length. If they are not, any excess elements will be ignored. That might be unexpected for users. function does",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "13. Overow checks not enabled for release prole in all packages",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Random Earth/2021-12-10 Audit Report - Random Earth v1.1.pdf",
        "body": "in the workspace level contracts/Cargo.toml, some packages do not While set explicitly enable overow checks. This is not a security concern in the current version of the contracts since the checks are enabled from the workspace to all packages, but future refactoring might leave some packages vulnerable to over- or underows. Packages that currently dont have overow checks enabled are:  contracts/contracts/stardust-settlement/Cargo.toml  contracts/contracts/stardust-auction/Cargo.toml  contracts/contracts/stardust-executor/Cargo.toml  contracts/contracts/stardust-nft-distribution/Cargo.toml  contracts/contracts/stardust-querier/Cargo.toml  contracts/contracts/stardust-registry/Cargo.toml",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Borrowers can prevent liquidation leading to bad debt accumulating",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "liquidating When in contracts/credit-manager/src/vault/liquidate_vault.rs:154-166, all the borrowers unlocking positions are processed in a loop. A borrower can create many tiny unlocking positions using the RequestVaultUnlock message, causing the total unlocking positions cardinality to grow to the point where the liquidate_unlocking function runs out of gas. collateral This is highly problematic, since borrowers can prevent being liquidated, which can result in bad debt accumulating.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Liquidators can extract a higher value by looping small amounts of liquidations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "In the contracts/credit-manager/src/liquidate_coin.rs:119-127, request_amount is rounded up using the ceil function. This allows a liquidator to extract a higher value by liquidating small amounts of collateral within a loop. Additionally, the maximum close factor can be bypassed as long as a single liquidation message does not exceed the limit, allowing the total liquidated amount to be higher than the congured limit. We consider liquidations consumes a lot of gas, which decreases the protability of the attack. instead of critical this a major issue because performing multiple small Please see the test_repeated_single_liquidation test case to reproduce the issue.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Contract version and name are overwritten during instantiation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "the In contracts/account-nft/src/contract.rs:23-36, during instantiation of account-nft contract, in contract/account-nft/src/contract.rs:29-33 and then again during the call of the parent contract instantiation in contract/account-nft/src/contract.rs:35. the version and name of the contract are set twice. First This implies that the stored CW2 metadata would be the one from the cw721-base contract and not the intended one, potentially causing problems in future migrations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "4. Duplicate keys should be removed to prevent miscongurations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "contracts/credit-manager/src/instantiate.rs:19-25 and In contracts/oracle-adapter/src/contract.rs:47-49, the msg.allowed_vaults, msg.vault_pricing and msg.allowed_coins are not deduplicated before storing them. If any allowed vault addresses or coin denominations are duplicates, earlier congurations would be overwritten, and only the last key would be saved successfully. We classify this issue as minor since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Update of the account-nft address can lead to state inconsistencies",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "In contracts/credit-manager/src/execute.rs:65-80, the contract owner is able to update the address of the account-nft contract. This can cause state inconsistencies as account ids associated with the previous NFT contract are removed. Also, owners of NFTs from the old contract will lose access to their funds managed in the credit-manager that will be virtually transferred to the owners of the NFTs from the new contract. We classify this issue as minor since only the owner can cause it.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Funds held by swapper contract may be unintendedly withdrawn",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "When performing a swap in the swapper contract, the output is transferred to the recipient using in message contract/swapper/base/src/contract.rs:187-194. TransferResult created a Then any amount of contract/swapper/base/src/contract.rs:234. the denom_in and denom_out is transferred to the recipient in However, in the case that the swapper contract holds additional funds of either denomination those would be automatically sent to the recipient in addition to the input and output amounts. We classify this issue as minor despite the fact that no funds should be present in the swapper contract there may be situations where funds are sent to the contract, e.g. an airdrop or inadvertent usage.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Update of the red bank address in the credit-manager could lead to state inconsistency",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "In contracts/credit-manager/src/execute.rs:65-80, the contract owner is able to update the address of the red bank in the credit-manager. This would cause state inconsistencies since all the data stored in TOTAL_DEBT_SHARES and DEBT_SHARES will not be updated accordingly.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. The execution of the AssertBelowMaxLTV callback at the end of the UpdateCreditAccount transaction could run out of gas",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "In the contracts/credit-manager/src/execute.rs:285-288, AssertBelowMaxLTV is always added to the list of callbacks to execute after the other Actions provided as an input in the UpdateCreditAccount message. This callback is executing two times an unbounded loop through the COIN_BALANCES, DEBT_SHARES and VAULT_POSITIONS vectors that have not a capped length. Also, it is executed after all the other Actions and Callbacks so it has only a fraction of the initially provided gas. This implies that if the cardinality of the vectors is signicant, the remaining gas could not be enough to pay the computation leading to out of gas errors. While this scenario is not likely to happen at the launch of the protocol, the risk of running out of gas will increase with more assets supported and wider adoption.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. MAX_CLOSE_FACTOR is not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "the contract owner In contracts/credit-manager/src/instantiate.rs:15, denes the MAX_CLOSE_FACTOR of liquidations which determines the maximum amount of a position that can be liquidated. However, ineectual and not providing a limit to the value that can be liquidated in a single transaction. the value provided has no validation which could lead to the variable being",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "10. Query silently returns input when no pricing method is found.",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "function The in contracts/oracle-adapter/src/contract.rs nds the pricing methodology of the coin denom and queries the relevant vault to calculate the value of redemption. query_priceable_underlying If the submitted coin denom does not have a vault price then the input is simply returned to the user. This could lead to wrong assumptions and may negatively impact the usability of the query.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Redundant checks on received funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "the try_from function attempts to In packages/rover/src/coins.rs:136-158, verify that no zero amount denom and no duplicate denoms are provided. This check is unnecessary because Cosmos SDK will prevent zero amounts from being sent (an error will occur) and will automatically combine duplicate denoms into one single denom (eg. [200 ATOM, 100 ATOM] will become [300 ATOM] ).",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Contracts should implement a two step ownership transfer",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "13. Custom access controls implementation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "The contracts within the scope of this audit implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "14. Overow checks not enabled for release prole",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/account-nft/Cargo.toml  contracts/credit-manager/Cargo.toml  contracts/oracle-adapter/Cargo.toml  contracts/swapper/Cargo.toml  packages/rover/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "15. Unbounded number of steps during route registration",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "In contracts/swapper/base/src/contract.rs:246-274, is able to dene custom swap routes between token pairs in order to facilitate the exchange of tokens that do not have a shared pool. However, the number of steps a route is able to host is unbounded which could lead to inecient routes being dened. the owner",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "16. Unused callback should be removed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-12-09 Audit Report - Mars Rover v1.0.pdf",
        "body": "ForceExitVault The packages/rover/src/msg/execute.rs:147-151, protocol and should be removed from the codebase to increase its maintainability. in dened is not used anywhere in the callback",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "1. Users' inactivity could permanently freeze the protocol",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "calculate_streaming_fee The in contracts/core/src/state/mod.rs:44-75 calculates the time-weighted streaming fee with the following formula: function dened  = (1 +   )   1 where  is the elapsed time since the latest stream fee application. If this time delta gets too big, the exponential operation could perform an overow, reverting the message handling. This could happen, for example, after a chain upgrade or during a bear market where users are less interested in interacting with the contract. Since the calculate_streaming_fee function is executed for each Execute message, its overow and revert of the message would permanently freeze the protocol. A test case is provided in Appendix 1.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "2. Rebalance nalization may become unachievable due to streaming fee collection",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "Streaming fees are collected via the collect_streaming_fee function implemented in in contracts/core/src/execute/fee.rs contracts/core/src/contract.rs:67, including rebalance messages. execution message every on If the deation target units are attained during rebalancing (i.e., target_unit == current_unit  notice the strict equality check), decrementing the collected fee from the current asset units in line 139 of the collect_streaming_fee function will result in an inability to pass the strict equality check in the finalize function. As a result, rebalancing becomes stuck and cannot be nalized.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "3. Inability to inate an asset caused by using the wrong coin denomination for swapping the reserve to asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The inflate function incorrectly uses the RESERVE_DENOM constant as the token_in argument in contracts/core/src/execute/rebalance.rs:436. msg_swap_exact_in call the for Since RESERVE_DENOM has a constant \"reserve\" value, which is not a valid coin denomination, the intended swap fails, causing the transaction to revert.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "4. Asset deation uses wrong swap direction by swapping the reserve to the asset",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The process of deating an asset during rebalancing involves swapping an exact amount of the asset (denom) to the reserve (token.reserve_denom). in the current However, in implementation, contracts/core/src/execute/rebalance.rs uses the asset coin denomination denom as the token_out argument for the msg_swap_exact_out function, resulting in the reserve being swapped to the asset rather than the intended swap of the asset to the reserve. deflate function the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "5. Deating an asset distributes the asset amount rather than the reserve amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The deflate function within contracts/core/src/execute/rebalance.rs is designed to distribute the reserve amount received to the RESERVE_BUFFER via the distribute_after_deflate function for subsequent asset ination. However, the current implementation mistakenly distributes the asset amount instead of the reserve amount. This can lead to incorrect accounting of reserves and prevent subsequent ination of assets.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "6. Total supply is not correctly computed",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "In contracts/core/src/execute/mod.rs:100, during the execution of Burn messages, the total supply is decreased by the amount of the received tokens. However, since part of the users provided tokens is sent to the fee_collector because of the burn fee, the computed total supply is not correct because it is not accounting for the fees. This implies that the total supply recorded in the contract is smaller than the actual one and a Burn message from the fee_collector would redeem more collateral than expected.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "7. ClaimProof does not include beneciary address, which allows front-running of airdrops",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "of types proofs in  Two contracts/airdrop/src/execute.rs:108-116, extracting the claim_proof distinguishes between the Account and ClaimProof types. While the Account type always includes the address of the beneciary, ClaimProof allows claiming with an arbitrary string. airdrops for supported logic are the for This is problematic because it enables front-running of these claims. When an attacker sees the proof string, he can submit it himself and claim the amount before the user.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "8. The same claim proof can be used multiple times",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "In contracts/airdrop/src/lib.rs:18, the user input that is proven is dened as {claim_proof}{amount}, i.e., concatenation of the claim proof and the amount. This input is veried with the provided claim proof. Because this encoding is ambiguous, an attacker can craft multiple combinations that result in the same user input and which are not rejected as invalid or duplicates. For instance, let us assume that claim_proof = abcd1234. An amount of 5 results in a user input of abcd12345, which is the value of the leaf. However, setting claim_proof = abcd123 and amount = 45 also results in user input of abcd12345. Because it is only veried (in contracts/airdrop/src/execute.rs:142), both calls will succeed and the user can claim 45 + 5 = 50 tokens instead of the intended 5. claim_proof before used was that not the",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "9. Inability to mint, burn and rebalance index tokens following the initial deate rebalance trade",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "Deating of an asset persists and updates the temporary accounting asset RESERVE_DENOM as part of the UNITS map alongside the other assets of the index. This RESERVE_DENOM is a constant string that resolves to \"reserve\" and is not a valid coin denomination. Any attempt to transfer this asset will result in an error. Due to the assumption that all assets within the UNITS map are tokens with valid coin denominations, the core functionalities of the protocol - minting, burning, and rebalancing - stop working after the initial deate rebalance trade, as RESERVE_DENOM is also added to the UNITS map. Minting  Since minting index tokens requires sending all asset tokens of UNITS along with the minting message, it is not possible to mint index tokens as RESERVE_DENOM cannot be transferred.  The Burning in contracts/core/src/state/units.rs determines the amount of underlying assets to redeem to the user when burning index tokens. Those assets are then transferred to the user. However, as RESERVE_DENOM is kept within the UNITS map and not removed from the redeemable assets, the transfer and hence the transaction reverts. get_redeem_amounts function fees are automatically Rebalancing  In the case of streaming fees being congured, collected and realized on every rebalance message. However, fees are also incorrectly collected from RESERVE_DENOM. As it is not possible to transfer the collected fees of the RESERVE_DENOM coin denomination, rebalancing reverts.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "10. Rebalance may not be nalizable because of rounding error",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The function distribute_after_deflate distributes the amount provided after an ination operation to the RESERVE_BUFFER entries for the dierent tokens. It does so by rst calculating the individual share for each token by dividing the weight by the total weight and then multiplying this ratio by the amount. However, because xed point arithmetic is used, there can be a very small loss of precision (in the 18th decimal place) when performing the division. While this loss of precision generally would be negligible, it breaks an important invariant of the rebalance operation: The sum of all RESERVE_BUFFER entries will no longer be equal to the RESERVE_DENOM balance. is for This the problematic In the contracts/core/src/execute/rebalance.rs:470, RESERVE_DENOM balance is exactly zero. But since this balance can only be decreased by consuming RESERVE_BUFFER entries, the condition may fail when there is a small amount left due to the imprecision of the calculation. Therefore, nalizing the rebalance operation will not be possible. nalization. required that is it",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "11. Burning index tokens via the periphery contract yields substantially fewer asset tokens",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "Burning index tokens via the periphery BurnExactAmountIn message invokes the burn_exact_amount_in function in contracts/periphery/src/execute.rs. This function in contracts/core/src/query.rs to determine the redeemable amounts of asset tokens, which are then swapped to a desired token (output_asset). simulate_burn function located core calls the the simulate_burn However, to amount_with_fee. Instead of calculating the burn fee amount and deducting it from the provided amount of index tokens, it multiplies the amount with the fee.burn ratio in line 119. This results in the amount_with_fee being just the fee, not the amount minus the fee. incorrectly the burn function applies fee Consequently, the amount_with_fee is substantially smaller than the provided amount of index tokens. As a result, the periphery contract will swap only a fraction of the redeemed assets to the desired token. As users can provide a minimum amount (min_output) of the desired token to receive, the transaction fails if this condition is not met. This renders the BurnExactAmountIn periphery message unusable.",
        "labels": [
            "Oak Security",
            "Severity: High"
        ]
    },
    {
        "title": "12. The streaming fee calculation formula returns wrong results for some input values",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "calculate_streaming_fee The in contracts/core/src/state/mod.rs:44-75 calculates the time-weighted streaming fee with the following formula: function dened  = (1 +   )   1 where  is the elapsed time from the latest stream fee application. Since this function returns a rate that has to be deducted from token units, the result must input be in the [0,1] range. Since the result depends on the and the    variables, it may fall outside of this range for some of those values. Results outside of the mentioned range would cause wrong calculations resulting in token units being incorrectly reduced and accrued to the fee collector. A graphical simulation is provided in the Appendix.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "13. Minting and burning index tokens interferes with rebalancing and can render rebalance nalization unachievable",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "As minting and burning index tokens continue to work while rebalancing is ongoing, the total supply of index tokens can uctuate during rebalancing. During rebalancing, the deflate_reserve and deflate functions deate assets, while in the inflate inflate_reserve functions assets inate and contracts/core/src/execute/rebalance.rs. These functions use the current supply of index tokens (token.total_supply) to perform calculations. For example, amount of reserve tokens to the total supply of index tokens (token.total_supply). the inflate_reserve function calculates the swap_unit ratio of the reserve The in is contracts/core/src/execute/rebalance.rs:355 and persisted in the UNITS map. RESERVE_DENOM swap_unit reduced then unit by As the token.total_supply changes during the rebalancing process, the swap_unit increases or decreases accordingly. This can result in RESERVE_DENOM never reaching 0, which is required to nalize the ongoing rebase.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "14. Asset ination simulates the swap incorrectly and expands by the wrong amount",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "Inating an asset by a certain amount is achieved by swapping the reserve to the asset. To determine the resulting amount (amount_out) of the asset (denom), the token swap is in simulated contracts/core/src/execute/rebalance.rs:402. sim_swap_exact_in function using the instead of using the reserve coin denomination (token.reserve_denom), the However, asset denom is used as the token_in argument for the sim_swap_exact_in function. As a result, the swap is simulated from the asset to the reserve instead of the reserve to the asset. This results in either a failed transaction due to the unsatised min_amount_out slippage protection or, in using the wrong amount the slippage protection is bypassed, (amount_out) to calculate the expansion amount (expand_unit) of the asset. if Additionally, this incorrect amount_out value is supplied as the token_out_min argument for the msg_swap_exact_in function in line 438, potentially causing the swap to fail due to the unsatised slippage protection condition.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "15. An invalid rebalance conguration could prevent its nalization",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "Rebalance::validate in The validating the contracts/core/src/state/rebalance.rs is rebalance cong before the protocol's governance can initiate a new rebalance. Once a rebalance has started, the cong can not be altered until the rebalance is nalized. responsible function for However, the current implementation of the Rebalance::validate function is missing some important checks, which can lead to failed rebalances. Specically, if the ination ratios in the conguration are incomplete or empty, it will not be possible to utilize the reserve fully. When attempting to nalize the rebalance, the non-zero check in contracts/core/src/execute/rebalance.rs:468 will fail, causing the nalization of the rebalance to fail. UNITS[RESERVE_DENOM] of Similarly, if the conguration includes duplicate coin denominations within the inflation and deflation vectors, the nalization of the rebalance will fail because of the guard in contracts/core/src/state/rebalance.rs:456-463. the impossibility of a Rebalance being nalized as strict equality cannot be true for two instances of the same denom with dierent amounts. results This in We classify this issue as major because only governance can initiate a rebalance and dene its conguration.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "16. Streaming fee realization mechanism can be manipulated by the fee collector to maximize prot",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The function realize_streaming_fee can be executed by the designated fee collector address at any time in order to collect fees. collected fees The calculated by multiplying the unit value with the token.total_supply in contracts/core/src/execute/fee.rs:156 for each Coin. are This is problematic because while unit is a time-weighted value, token.total_supply is a value that uctuates over time, leading to too high or low streaming fees. Moreover, it may be economically feasible for the fee collector to temporarily inate the total supply (by minting), execute realize_streaming_fee, and burn the tokens again.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "17. Tokens that are sent by mistake are not refunded when minting",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "The function mint calls assert_units to calculate how many tokens to refund for all backing assets in contracts/core/src/execute/mod.rs:43. The assert_units function checks that info.funds contains an entry for every element in assets, in order to calculate refunds for these elements. However, it is not validated that info.funds does not contain any additional entries. Therefore, info.funds is checked to be a superset of assets. This means that if a user sends other tokens along the call, those will be lost and not refunded.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "18. Fees rates are not validated",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "In contracts/core/src/contract.rs:30-40, during the contracts instantiation, input provided fee rates dened in msg.fee_strategy are not validated to be in the [0,1] range. that range will cause errors in calculations since fees could exceed Values outside of amounts.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "19. Inconsistent query results and failed index token burns due to lack of considering a minimum fee for small index token amounts",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/IBCX/2023-04-29 Audit Report - IBCX v1.0.pdf",
        "body": "simulate_mint The contracts/core/src/query.rs lack Uint128::one(), make_burn_msgs_with_fee_collection contracts/core/src/execute/fee.rs. unlike and the simulate_burn application of the functions in a minimum fee of and in functions make_mint_msgs_with_fee_collection This absence of a minimum fee in the simulate_mint function results in incorrect query results. Additionally, the lack of applying a minimum fee in the simulate_burn function results in a failed burn transaction for small index token amounts (if amount * fee < 1) when used via the periphery contract. This occurs because the make_burn_swap_msgs function in contracts/periphery/src/msgs.rs expects a larger amount of redeemed asset tokens than actually received and fails to swap due to insucient funds.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "1. Lack of pool status validation in claim function leads to a race between underwriters to withdraw and insurees to claim funds",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The claim function in src/contract.rs:251 does not perform a check to ensure that the pool is not in a closed state. If the pool status is closed and a hack/default event occurs, swaps can still be performed. Insurees will only claim if the payout amount is bigger than the value of the covered token. Rational underwriters will anticipate that, and rush to withdraw liquidity to maximize their return. Rational insurees will anticipate that rush, and try to claim as fast as possible. This race can lower trust in the protocol, but will eventually put users to a disadvantage that act slower than others.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "2. Wrong payout calculation may lead to last claiming insurees not being able to claim",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The calculation of payout in the claim function in src/contract.rs:302 uses the default_ratio rather than the payout_ratio. This is dierent from the calculation of the capacity in line 476 and may result in the last insuree trying to swap running into out-of-funds errors.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "3. Owner may update default ratio to prevent claims from being made",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "default_ratio, payout_ratio, and expiration are updatable variables that are used to determine whether or not the default event occurred in src/contract.rs:288, how much to pay out in 288, and whether the pool is closed in line 512-514. If the owner account was compromised or the owner simply wanted to control whether claims should be possible and what height they should have, they could update these values, aecting any users that have not claimed yet.",
        "labels": [
            "Oak Security",
            "Severity: Medium"
        ]
    },
    {
        "title": "4. Lack of validation of state parameters",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The instantiate and update_config functions in src/contract.rs:28 and 408 lack validation of the following parameters:  expiration: If set to a time in the past, this will cause the next invocation of check_if_at_status to transition the pool status to closed.  payout_ratio: If set to zero, the next invocation of the purchase would attempt to divide by zero in line 476 while attempting to calculate the total_capicity, which would cause a panic.  price (validated in the instantiate, but not in the update_config function): If set to zero, the purchase function would panic in line 220. A price of more than one would economically not make much sense.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "5. Pool may be congured with an incorrect credit token",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The InstantiateMsg struct in src/msg.rs:11 denes credit_token with a type of Addr, which is then stored without validation in src/contract.rs:70. This allows instantiation of a pool with an invalid credit token address, which may only be detected when claims happen after a hack/default.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "6. Owner may update parameters that can negatively impact users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The update_config function in src/contract.rs:408-439 allows the owner to update the following values:  price  expiration  default_ratio  payout_ratio Any underwriters that provide liquidity to the pool at the time of such a change would be subject to these changes, but they have no way to withdraw the pool if the values change to their disadvantage. This disincentivizes underwriters from entering the pool in the rst place, and also adds to centralization of the protocol. We classify this nding as minor because only the owner can make these changes.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "7. Claim payout attribute value is missing tax deduction",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The payout attribute in the claim function in src/msg.rs:324 contains the pre-tax payout value. This value will be dierent from the amount that is actually sent after deducting the tax.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "8. Lack of validation of Cw20ReceiveMsg msg can surprise users",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The claim function in src/contract.rs:255 receives a Cw20ReceiveMsg but does not match/use the contained msg. This means that the contract will execute a claim regardless of the received message. This goes against user expectations.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "9. Default state assessment of protocols added in the future may be subject to manipulation",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The audited smart contract only supports protection against drops in the Anchor exchange rate. That exchange rate can only be manipulated by an attacker that is a validator and deliberately gets slashed. Future extensions of the protocol might support insurance of tokens from other protocols though, with default conditions that may be subject to manipulation. In the past, many exploits of protocols were based on manipulation of spot prices, which is a concern for the Risk Harbor protocol. Even though this issue does not aect the current iteration of Risk Harbor, we still classify it as minor since it poses a potential risk of a future iteration.",
        "labels": [
            "Oak Security",
            "Severity: Low"
        ]
    },
    {
        "title": "10. Hard-coded Anchor market address decreases exibility",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The calculation of the redemption_ratio in src/contract.rs:285 uses a hard-coded (currently placeholder) address for the Anchor market contract. This decreases the exibility of the contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "11. Selective usage of CW20 features may lead to wrong user expectations",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "The contract selectively imports and uses code from the CW20 reference implementation. At the same time, the contract does not expose all of the CW20 execution and query message entry points. Depending on the frontend users are using, bought coverage might show up as a CW20 token to the user, but functionality such as transferring, sending, or burning those this selective usage of CW20 code increases the tokens is not available. Moreover, complexity of the contract.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "12. Lack of validation of pool name length may have adverse consequences",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Risk Harbor/2022-03-22 Audit Report - Risk Harbor v1.0.pdf",
        "body": "the stores contract The in src/contract.rs:38-49. The CW20_base crate performs a validation check to ensure that the token name adheres to the expected format and returns an error if this condition is not met. the CW20 format token using base info Using too long names might have adverse consequences, for example for user interfaces that expect limited token names.",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    },
    {
        "title": "2. The new owner account claims ownership, which applies the conguration changes. Status: Resolved 35. Misleading error message while trying to send and repay at the same time",
        "html_url": "https://github.com/oak-security/audit-reports/tree/master/Membrane/2023-06-15 Audit Report - Membrane v1.0.pdf",
        "body": "The mint_revenue function in contracts/cdp/src/position.rs:1639 performs a check to prevent the two optional variables send_to and repay_for being specied simultaneously or not specied at all. if True, However, \"Destination address is required\". specied, the error message is wrong. the error message informs about the second scenario only, that is, If both send_to and repay_for are",
        "labels": [
            "Oak Security",
            "Severity: Informational"
        ]
    }
]